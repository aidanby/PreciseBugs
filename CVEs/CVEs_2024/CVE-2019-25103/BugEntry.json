{"buggy_code": ["// @flow\n\nvar assert = require(\"assert\");\nvar _ = require(\"underscore\");\nvar React = require(\"react\");\nvar ReactDOMServer = require(\"react-dom/server\");\n\nvar SimpleMarkdown = require(\"../simple-markdown.js\");\nvar blockParse = SimpleMarkdown.defaultBlockParse;\nvar inlineParse = SimpleMarkdown.defaultInlineParse;\nvar implicitParse = SimpleMarkdown.defaultImplicitParse;\nvar defaultReactOutput = SimpleMarkdown.defaultReactOutput;\nvar defaultHtmlOutput = SimpleMarkdown.defaultHtmlOutput;\n\n/*:: // Flow definitions & hackery\n\nvar FLOW_IGNORE_COVARIANCE = {\n  console: {\n    warn: (console.warn : any),\n  },\n};\n*/\n\n// A pretty-printer that handles `undefined` and functions better\n// than JSON.stringify\n// Important because some AST node fields can be undefined, and\n// if those don't show up in the assert output, it can be\n// very confusing to figure out how the actual and expected differ\n// Whether node's util.inspect or JSON.stringify is better seems\n// context dependent.\nvar prettyPrintAST = function(ast) {\n    return JSON.stringify(ast, null, 4);\n//    return nodeUtil.inspect(ast, {\n//        depth: null,\n//        colors: false\n//    });\n};\n\nvar validateParse = function(parsed, expected) {\n    if (!_.isEqual(parsed, expected)) {\n        var parsedStr = prettyPrintAST(parsed);\n        var expectedStr = prettyPrintAST(expected);\n        // assert.fail doesn't seem to print the\n        // expected and actual anymore, so we just\n        // throw our own exception.\n        throw new Error(\"Expected:\\n\" +\n            expectedStr +\n            \"\\n\\nActual:\\n\" +\n            parsedStr\n        );\n    }\n};\n\nvar reactToHtml = function(reactElements) {\n    var rawHtml = ReactDOMServer.renderToStaticMarkup(\n        React.createElement('div', {}, reactElements)\n    );\n    var innerHtml = rawHtml\n        .replace(/^<div>/, '')\n        .replace(/<\\/div>$/, '');\n    var simplifiedHtml = innerHtml\n        .replace(/>\\n*/g, '>')\n        .replace(/\\n*</g, '<')\n        .replace(/\\s+/g, ' ');\n    return simplifiedHtml;\n};\n\nvar htmlThroughReact = function(parsed) {\n    var output = defaultReactOutput(parsed);\n    return reactToHtml(output);\n};\n\nvar htmlFromReactMarkdown = function(source) {\n    return htmlThroughReact(implicitParse(source));\n};\n\nvar htmlFromMarkdown = function(source) {\n    var html = defaultHtmlOutput(implicitParse(source));\n    var simplifiedHtml = html.replace(/\\s+/g, ' ');\n    return simplifiedHtml;\n};\n\nvar assertParsesToReact = function(source, html) {\n    var actualHtml = htmlFromReactMarkdown(source);\n    assert.strictEqual(actualHtml, html);\n};\n\nvar assertParsesToHtml = function(source, html) {\n    var actualHtml = htmlFromMarkdown(source);\n    assert.strictEqual(actualHtml, html);\n};\n\ndescribe(\"simple markdown\", function() {\n    describe(\"parser\", function() {\n        it(\"should parse a plain string\", function() {\n            var parsed = inlineParse(\"hi there\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"hi there\"\n            }]);\n        });\n\n        it(\"should parse bold\", function() {\n            var parsed = inlineParse(\"**hi**\");\n            validateParse(parsed, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse italics\", function() {\n            var parsed = inlineParse(\"*hi*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*test i*\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"test i\"\n                }]\n            }]);\n        });\n\n        it(\"should not parse ** as empty italics\", function() {\n            var parsed = inlineParse(\"**\");\n            validateParse(parsed, [\n              { type: \"text\", content: \"*\" },\n              { type: \"text\", content: \"*\" },\n            ]);\n        });\n\n        it(\"should parse a single italic character\", function() {\n            var parsed = inlineParse(\"*h*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"h\"\n                }]\n            }]);\n        });\n\n        it(\"should parse strikethrough\", function() {\n            var parsed = inlineParse(\"~~hi~~\");\n            validateParse(parsed, [{\n                type: \"del\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            // not super important that it parses this like this, but\n            // it should be a valid something...\n            var parsed2 = inlineParse(\"~~~~~\");\n            validateParse(parsed2, [\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n            ]);\n        });\n\n        it(\"should support escapes in strikethrough\", function() {\n            validateParse(inlineParse(\"~~hi\\\\~~ there~~\"), [{\n                type: \"del\",\n                content: [\n                    { type: \"text\", content: \"hi\" },\n                    { type: \"text\", content: \"~\" },\n                    { type: \"text\", content: \"~ there\" },\n                ]\n            }]);\n        });\n\n        it(\"should not allow strikethrough to contain non-closing ~~s\", function() {\n            validateParse(inlineParse(\"~~hi ~~there~~\"), [\n                { type: \"text\", content: \"~\" },\n                { type: \"text\", content: \"~hi \" },\n                { type: \"del\", content: [{ type: \"text\", content: \"there\" }] },\n            ]);\n        });\n\n        it(\"should parse underlines\", function() {\n            var parsed = inlineParse(\"__hi__\");\n            validateParse(parsed, [{\n                type: \"u\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse nested bold/italics\", function() {\n            var parsed = inlineParse(\"***hi***\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse nested bold/italics/underline\", function() {\n            var parsed1 = inlineParse(\"***__hi__***\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"u\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }]\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*__**hi**__*\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"u\",\n                    content: [{\n                        type: \"strong\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"***bolditalics***\");\n            validateParse(parsed3, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bolditalics\",\n                    }]\n                }]\n            }]);\n\n            var parsed4 = inlineParse(\"**bold *italics***\");\n            validateParse(parsed4, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"bold \",\n                }, {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"italics\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped underscores in underscore italics\", function() {\n            var parsed1 = inlineParse(\"_ABC\\\\_DEF_\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"ABC\",\n                }, {\n                    type: \"text\",\n                    content: \"_\",\n                }, {\n                    type: \"text\",\n                    content: \"DEF\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"_**ABC\\\\_DEF**_\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"_\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"_**ABC\\\\$DEF**_\");\n            validateParse(parsed3, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"$\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n\n            validateParse(inlineParse(\"_\\\\\\\\_\"), [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"\\\\\",\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped asterisks in asterisk italics\", function() {\n            var parsed1 = inlineParse(\"*hi\\\\* there*\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \" there\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"_**ABC\\\\*DEF**_\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"*\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped asterisks in asterisk bolds\", function() {\n            var parsed1 = inlineParse(\"**hi\\\\* there**\");\n            validateParse(parsed1, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \" there\",\n                }]\n            }]);\n\n            validateParse(inlineParse(\"**hi\\\\** there**\"), [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \"* there\",\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped underscores in underlines\", function() {\n            var parsed1 = inlineParse(\"__hi\\\\__ there__\");\n            validateParse(parsed1, [{\n                type: \"u\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"_\",\n                }, {\n                    type: \"text\",\n                    content: \"_ there\",\n                }]\n            }]);\n        });\n\n        it(\"should parse complex combined bold/italics\", function() {\n            var parsed = inlineParse(\"***bold** italics*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\",\n                    }]\n                }, {\n                    type: \"text\",\n                    content: \" italics\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*hi **there you***\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi \",\n                }, {\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"there you\",\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"***like* this**\");\n            validateParse(parsed3, [{\n                type: \"strong\",\n                content: [{\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"like\",\n                    }]\n                }, {\n                    type: \"text\",\n                    content: \" this\",\n                }]\n            }]);\n\n            var parsed4 = inlineParse(\"**bold *and italics***\");\n            validateParse(parsed4, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"bold \",\n                }, {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"and italics\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple bold/italics/underlines\", function() {\n            var parsed = inlineParse(\n                \"*some* of this __sentence__ is **bold**\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"some\"\n                    }]\n                },\n                {\n                    type: \"text\",\n                    content: \" of this \"\n                },\n                {\n                    type: \"u\",\n                    content: [{\n                        type: \"text\",\n                        content: \"sentence\"\n                    }]\n                },\n                {\n                    type: \"text\",\n                    content: \" is \"\n                },\n                {\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\"\n                    }]\n                }\n            ]);\n\n            validateParse(inlineParse(\"_italics __bold___\"), [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"italics \",\n                }, {\n                    type: \"u\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse inline code\", function() {\n            var parsed = inlineParse(\"`hi`\");\n            validateParse(parsed, [{\n                type: \"inlineCode\",\n                content: \"hi\"\n            }]);\n        });\n\n        it(\"should parse * and _ inside `` as code\", function() {\n            var parsed = inlineParse(\n                \"`const int * const * const p; // _hi_`\"\n            );\n            validateParse(parsed, [{\n                type: \"inlineCode\",\n                content: \"const int * const * const p; // _hi_\"\n            }]);\n        });\n\n        it(\"should allow you to escape special characters with \\\\\", function() {\n            var parsed = inlineParse(\n                \"\\\\`hi\\\\` \\\\*bye\\\\* \\\\~\\\\|\\\\<\\\\[\\\\{\"\n            );\n            validateParse(parsed, [\n                { type: \"text\", content: \"`\" },\n                { type: \"text\", content: \"hi\" },\n                { type: \"text\", content: \"`\" },\n                { type: \"text\", content: \" \" },\n                { type: \"text\", content: \"*\" },\n                { type: \"text\", content: \"bye\" },\n                { type: \"text\", content: \"*\" },\n                { type: \"text\", content: \" \" },\n                { type: \"text\", content: \"~\" },\n                { type: \"text\", content: \"|\" },\n                { type: \"text\", content: \"<\" },\n                { type: \"text\", content: \"[\" },\n                { type: \"text\", content: \"{\" },\n            ]);\n\n            var parsed2 = inlineParse(\n                \"hi\\\\^caret\"\n            );\n            validateParse(parsed2, [\n                { type: \"text\", content: \"hi\" },\n                { type: \"text\", content: \"^\" },\n                { type: \"text\", content: \"caret\" },\n            ]);\n        });\n\n        it(\"should parse basic []() links as links\", function() {\n            var parsed = inlineParse(\"[hi](http://www.google.com)\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }],\n                target: \"http://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"[secure](https://www.google.com)\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"secure\"\n                }],\n                target: \"https://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\n                \"[local](http://localhost:9000/test.html)\"\n            );\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"local\"\n                }],\n                target: \"http://localhost:9000/test.html\",\n                title: undefined\n            }]);\n\n            var parsed4 = inlineParse(\n                \"[params](http://localhost:9000/test.html\" +\n                \"?content=%7B%7D&format=pretty)\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"params\"\n                }],\n                target: \"http://localhost:9000/test.html\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: undefined\n            }]);\n\n            var parsed5 = inlineParse(\n                \"[hash](http://localhost:9000/test.html#content=%7B%7D)\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"hash\"\n                }],\n                target: \"http://localhost:9000/test.html#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should allow escaping `[` with `\\\\`\", function() {\n            // Without the backslash, the following would be a\n            // link with the text \"hi\".\n            // With the backslash, it should ignore the '[hi]'\n            // portion, but will still detect that the inside\n            // of the parentheses contains a raw url, which it\n            // will turn into a url link.\n            var parsed = inlineParse(\"\\\\[hi](http://www.google.com)\");\n            validateParse(parsed, [\n                {content: \"[\", type: \"text\"},\n                {content: \"hi\", type: \"text\"},\n                {content: \"]\", type: \"text\"},\n                {content: \"(\", type: \"text\"},\n                {\n                    type: \"link\",\n                    content: [{\n                        type: \"text\",\n                        content: \"http://www.google.com\"\n                    }],\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {content: \")\", type: \"text\"},\n            ]);\n        });\n\n        it(\"should allow escaping of link urls with `\\\\`\", function() {\n            var parsed = inlineParse(\"[test link](https://test.link/\\\\(test\\\\))\");\n            validateParse(parsed, [\n                {\n                    type: \"link\",\n                    content: [{\n                        type: \"text\",\n                        content: \"test link\"\n                    }],\n                    target: \"https://test.link/(test)\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse basic <autolinks>\", function() {\n            var parsed = inlineParse(\"<http://www.google.com>\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://www.google.com\"\n                }],\n                target: \"http://www.google.com\"\n            }]);\n\n            var parsed2 = inlineParse(\"<https://www.google.com>\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"https://www.google.com\"\n                }],\n                target: \"https://www.google.com\"\n            }]);\n\n            var parsed3 = inlineParse(\"<http://localhost:9000/test.html>\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html\"\n                }],\n                target: \"http://localhost:9000/test.html\"\n            }]);\n\n            var parsed4 = inlineParse(\n                \"<http://localhost:9000/test.html\" +\n                \"?content=%7B%7D&format=pretty>\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html\" +\n                            \"?content=%7B%7D&format=pretty\"\n                }],\n                target: \"http://localhost:9000/test.html\" +\n                        \"?content=%7B%7D&format=pretty\"\n            }]);\n\n            var parsed5 = inlineParse(\n                \"<http://localhost:9000/test.html#content=%7B%7D>\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html#content=%7B%7D\"\n                }],\n                target: \"http://localhost:9000/test.html#content=%7B%7D\"\n            }]);\n        });\n\n        it(\"should parse basic <mailto@autolinks>\", function() {\n            var parsed = inlineParse(\"<test@example.com>\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"test@example.com\"\n                }],\n                target: \"mailto:test@example.com\"\n            }]);\n\n            var parsed2 = inlineParse(\"<test+ext@example.com>\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"test+ext@example.com\"\n                }],\n                target: \"mailto:test+ext@example.com\"\n            }]);\n\n            var parsed3 = inlineParse(\"<mailto:test@example.com>\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"mailto:test@example.com\"\n                }],\n                target: \"mailto:test@example.com\"\n            }]);\n\n            var parsed4 = inlineParse(\"<MAILTO:TEST@EXAMPLE.COM>\");\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"MAILTO:TEST@EXAMPLE.COM\"\n                }],\n                target: \"MAILTO:TEST@EXAMPLE.COM\"\n            }]);\n        });\n\n        it(\"should parse basic freeform urls\", function() {\n            var parsed = inlineParse(\"http://www.google.com\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://www.google.com\"\n                }],\n                target: \"http://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"https://www.google.com\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"https://www.google.com\"\n                }],\n                target: \"https://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\"http://example.com/test.html\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html\"\n                }],\n                target: \"http://example.com/test.html\",\n                title: undefined\n            }]);\n\n            var parsed4 = inlineParse(\n                \"http://example.com/test.html\" +\n                \"?content=%7B%7D&format=pretty\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html\" +\n                            \"?content=%7B%7D&format=pretty\"\n                }],\n                target: \"http://example.com/test.html\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: undefined\n            }]);\n\n            var parsed5 = inlineParse(\n                \"http://example.com/test.html#content=%7B%7D\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html#content=%7B%7D\"\n                }],\n                target: \"http://example.com/test.html#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should not split words before colons\", function() {\n            var parsed = inlineParse(\"Here is a rule: try this\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"Here is a rule\",\n            }, {\n                type: \"text\",\n                content: \": try this\",\n            }]);\n        });\n\n        it(\"should parse freeform urls inside paragraphs\", function() {\n            var parsed = blockParse(\n                \"hi this is a link http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: \"hi this is a link \",\n                    },\n                    {\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"http://www.google.com\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }\n                ]\n            }]);\n        });\n\n        it(\"should parse [reflinks][and their targets]\", function() {\n            var parsed = implicitParse(\n                \"[Google][1]\\n\\n\" +\n                \"[1]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = blockParse(\n                \"[1]: http://www.google.com\\n\\n\" +\n                \"[Google][1]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse inline link titles\", function() {\n            var parsed = inlineParse(\n                \"[Google](http://www.google.com \\\"This is google!\\\")\"\n            );\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"Google\"\n                }],\n                target: \"http://www.google.com\",\n                title: \"This is google!\"\n            }]);\n\n            var parsed2 = inlineParse(\n                \"[Google](http://www.google.com \\\"still Google\\\")\"\n            );\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"Google\"\n                }],\n                target: \"http://www.google.com\",\n                title: \"still Google\"\n            }]);\n        });\n\n        it(\"should parse reflink titles\", function() {\n            var parsed = implicitParse(\n                \"[Google][1]\\n\\n\" +\n                \"[1]: http://www.google.com (This is google!)\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: \"This is google!\"\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: \"This is google!\"\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[1]: http://www.google.com \\\"still Google\\\"\\n\\n\" +\n                \"[Google][1]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: \"still Google\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: \"still Google\"\n                    }]\n                },\n            ]);\n\n            // test some edge cases, notably:\n            // target of \"\"; title using parens; def with a `-` in it\n            var parsed3 = implicitParse(\n                \"[Nowhere][nowhere-target]\\n\\n\" +\n                \"[nowhere-target]: <> (nowhere)\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Nowhere\"\n                        }],\n                        target: \"\",\n                        title: \"nowhere\"\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"nowhere-target\",\n                    target: \"\",\n                    title: \"nowhere\"\n                },\n            ]);\n        });\n\n        it(\"should parse [reflinks][] with implicit targets\", function() {\n            var parsed = implicitParse(\n                \"[Google][]\\n\\n\" +\n                \"[Google]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[Google]: http://www.google.com\\n\\n\" +\n                \"[Google][]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should handle multiple [reflinks][to the same target]\", function() {\n            var parsed = implicitParse(\n                \"[Google][1] [Yahoo][1]\\n\\n\" +\n                \"[1]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        {\n                            type: \"link\",\n                            content: [{\n                                type: \"text\",\n                                content: \"Google\"\n                            }],\n                            target: \"http://www.google.com\",\n                            title: undefined\n                        },\n                        {\n                            type: \"text\",\n                            content: \" \"\n                        },\n                        {\n                            type: \"link\",\n                            content: [{\n                                type: \"text\",\n                                content: \"Yahoo\"\n                            }],\n                            target: \"http://www.google.com\",\n                            title: undefined\n                        },\n                    ]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            // This is sort of silly, but the last def overrides all previous\n            // links. This is just a test that things are continuing to work\n            // as we currently expect them to, but I seriously hope no one\n            // writes markdown like this!\n            var parsed2 = implicitParse(\n                \"[test][1]\\n\\n\" +\n                \"[1]: http://google.com\\n\\n\" +\n                \"[test2][1]\\n\\n\" +\n                \"[1]: http://khanacademy.org\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"test\"\n                        }],\n                        target: \"http://khanacademy.org\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"test2\"\n                        }],\n                        target: \"http://khanacademy.org\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://khanacademy.org\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse basic images\", function() {\n            var parsed = inlineParse(\"![](http://example.com/test.png)\");\n            validateParse(parsed, [{\n                type: \"image\",\n                alt: \"\",\n                target: \"http://example.com/test.png\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"![aaalt](http://example.com/image)\");\n            validateParse(parsed2, [{\n                type: \"image\",\n                alt: \"aaalt\",\n                target: \"http://example.com/image\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\n                \"![](http://localhost:9000/test.html \\\"local\\\")\"\n            );\n            validateParse(parsed3, [{\n                type: \"image\",\n                alt: \"\",\n                target: \"http://localhost:9000/test.html\",\n                title: \"local\"\n            }]);\n\n            var parsed4 = inlineParse(\n                \"![p](http://localhost:9000/test\" +\n                \"?content=%7B%7D&format=pretty \\\"params\\\")\"\n            );\n            validateParse(parsed4, [{\n                type: \"image\",\n                alt: \"p\",\n                target: \"http://localhost:9000/test\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: \"params\"\n            }]);\n\n            var parsed5 = inlineParse(\n                \"![hash](http://localhost:9000/test.png#content=%7B%7D)\"\n            );\n            validateParse(parsed5, [{\n                type: \"image\",\n                alt: \"hash\",\n                target: \"http://localhost:9000/test.png#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should parse [refimages][and their targets]\", function() {\n            var parsed = implicitParse(\n                \"![aaalt][1]\\n\\n\" +\n                \"[1]: http://example.com/test.gif\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"aaalt\",\n                        target: \"http://example.com/test.gif\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://example.com/test.gif\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[image]: http://example.com/test.gif\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: undefined\n                    }]\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[image]: http://example.com/test.gif \\\"title!\\\"\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: \"title!\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: \"title!\"\n                    }]\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[image]: http://example.com/test.gif (*title text*)\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: \"*title text*\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: \"*title text*\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should compare defs case- and whitespace-insensitively\", function() {\n            var parsed = implicitParse(\n                \"[Google][HiIiI]\\n\\n\" +\n                \"[HIiii]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"hiiii\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[Google][]\\n\\n\" +\n                \"[google]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[Google][ h    i ]\\n\\n\" +\n                \"[  h i   ]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \" h i \",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should not allow defs to break out of a paragraph\", function() {\n            var parsed = implicitParse(\"hi [1]: there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"hi \", type: \"text\"},\n                    {content: \"[1\", type: \"text\"},\n                    {content: \"]\", type: \"text\"},\n                    {content: \": there\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should allow a group of defs next to each other\", function() {\n            var parsed = implicitParse(\n                \"[a]: # (title)\\n\" +\n                \"[b]: http://www.google.com\\n\" +\n                \"[//]: <> (hi)\\n\" +\n                \"[label]: # (there)\\n\" +\n                \"[#]: #\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"def\",\n                    def: \"a\",\n                    target: \"#\",\n                    title: \"title\"\n                },\n                {\n                    type: \"def\",\n                    def: \"b\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"def\",\n                    def: \"//\",\n                    target: \"\",\n                    title: \"hi\"\n                },\n                {\n                    type: \"def\",\n                    def: \"label\",\n                    target: \"#\",\n                    title: \"there\"\n                },\n                {\n                    type: \"def\",\n                    def: \"#\",\n                    target: \"#\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse a single top-level paragraph\", function() {\n            var parsed = blockParse(\"hi\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple top-level paragraphs\", function() {\n            var parsed = blockParse(\"hi\\n\\nbye\\n\\nthere\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"there\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not parse single newlines as paragraphs\", function() {\n            var parsed = inlineParse(\"hi\\nbye\\nthere\\n\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"hi\\nbye\\nthere\\n\"\n            }]);\n        });\n\n        it(\"should not parse a single newline as a new paragraph\", function() {\n            var parsed = blockParse(\"hi\\nbye\\nthere\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\\nbye\\nthere\"\n                }]\n            }]);\n        });\n\n        it(\"should allow whitespace-only lines to end paragraphs\", function() {\n            var parsed = blockParse(\"hi\\n \\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed2 = blockParse(\"hi\\n  \\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed3 = blockParse(\"hi\\n\\n  \\n  \\n\");\n            validateParse(parsed3, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed4 = blockParse(\"hi\\n  \\n\\n   \\nbye\\n\\n\");\n            validateParse(parsed4, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse a single heading\", function() {\n            var parsed = blockParse(\"### heading3\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 3,\n                content: [{\n                    type: \"text\",\n                    content: \"heading3\"\n                }]\n            }]);\n        });\n\n        it(\"should parse a single lheading\", function() {\n            var parsed = blockParse(\"heading2\\n-----\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 2,\n                content: [{\n                    type: \"text\",\n                    content: \"heading2\"\n                }]\n            }]);\n        });\n\n        it(\"should not parse a single lheading with two -- or ==\", function() {\n            var parsed = blockParse(\"heading1\\n==\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {type: \"text\", content: \"heading1\\n\"},\n                    {type: \"text\", content: \"=\"},\n                    {type: \"text\", content: \"=\"},\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"heading2\\n--\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    {type: \"text\", content: \"heading2\\n\"},\n                    {type: \"text\", content: \"-\"},\n                    {type: \"text\", content: \"-\"},\n                ]\n            }]);\n        });\n\n        it(\"should not parse 7 #s as an h7\", function() {\n            var parsed = blockParse(\"#######heading7\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 6,\n                content: [{\n                    type: \"text\",\n                    content: \"#heading7\"\n                }]\n            }]);\n        });\n\n        it(\"should parse a heading between paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \"#heading\\n\\n\\n\" +\n                \"para 2\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }]\n                },\n                {\n                    type: \"heading\",\n                    level: 1,\n                    content: [{\n                        type: \"text\",\n                        content: \"heading\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not allow headings mid-paragraph\", function() {\n            var parsed = blockParse(\n                \"paragraph # text\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph \", type: \"text\"},\n                    {content: \"# text\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \"paragraph\\n\" +\n                \"text\\n\" +\n                \"----\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph\\ntext\\n\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse a single top-level blockquote\", function() {\n            var parsed = blockParse(\"> blockquote\\n\\n\");\n            validateParse(parsed, [{\n                type: \"blockQuote\",\n                content: [{\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"blockquote\"\n                    }],\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple blockquotes and paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \"> blockquote 1\\n\" +\n                \">\\n\" +\n                \">blockquote 2\\n\\n\" +\n                \"para 2\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }],\n                },\n                {\n                    type: \"blockQuote\",\n                    content: [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"blockquote 1\"\n                            }],\n                        },\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"blockquote 2\"\n                            }],\n                        }\n                    ]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }],\n                },\n            ]);\n        });\n\n        it(\"should not let a > escape a paragraph as a blockquote\", function() {\n            var parsed = blockParse(\n                \"para 1 > not a quote\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"para 1 \", type: \"text\"},\n                    {content: \"> not a quote\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse a single top-level code block\", function() {\n            var parsed = blockParse(\"    if (true) { code(); }\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"if (true) { code(); }\"\n            }]);\n        });\n\n        it(\"should parse a code block with trailing spaces\", function() {\n            var parsed = blockParse(\"    if (true) { code(); }\\n    \\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"if (true) { code(); }\"\n            }]);\n        });\n\n        it(\"should parse fence blocks\", function() {\n            var parsed = blockParse(\"```\\ncode\\n```\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"code\"\n            }]);\n\n            var parsed2 = blockParse(\n                \"```aletheia\\n\" +\n                \"if true [code()]\\n\" +\n                \"```\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"codeBlock\",\n                lang: \"aletheia\",\n                content: \"if true [code()]\"\n            }]);\n        });\n\n        it(\"should allow indentation inside code blocks\", function() {\n            var parsed = blockParse(\n                \"```\\n\" +\n                \"if (true === false) {\\n\" +\n                \"    throw 'world does not exist';\\n\" +\n                \"}\\n\" +\n                \"```\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: (\n                    \"if (true === false) {\\n\" +\n                    \"    throw 'world does not exist';\\n\" +\n                    \"}\"\n                ),\n            }]);\n\n            var parsed = blockParse(\n                \"~~~\\n\" +\n                \"    this should be indented\\n\" +\n                \"~~~\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"    this should be indented\",\n            }]);\n        });\n\n        it(\"should parse mixed paragraphs and code\", function() {\n            var parsed = blockParse(\n                \"this is regular text\\n\\n\" +\n                \"    this is code\\n\\n\" +\n                \"this is more regular text\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"this is regular text\"\n                    }]\n                },\n                {\n                    type: \"codeBlock\",\n                    lang: undefined,\n                    content: \"this is code\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"this is more regular text\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse top-level horizontal rules\", function() {\n            var parsed = blockParse(\n                \"---\\n\\n\" +\n                \"***\\n\\n\" +\n                \"___\\n\\n\" +\n                \" - - - - \\n\\n\" +\n                \"_ _ _\\n\\n\" +\n                \"  ***  \\n\\n\"\n            );\n            validateParse(parsed, [\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n            ]);\n        });\n\n        it(\"should parse hrs between paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \" * * * \\n\\n\" +\n                \"para 2\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }]\n                },\n                { type: \"hr\" },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not allow hrs within a paragraph\", function() {\n            var parsed = blockParse(\n                \"paragraph ----\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph \", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse simple unordered lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \" * bye\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        content: \"hi\",\n                        type: \"text\",\n                    }],\n                    [{\n                        content: \"bye\",\n                        type: \"text\",\n                    }],\n                    [{\n                        content: \"there\",\n                        type: \"text\",\n                    }],\n                ],\n                type: \"list\",\n            }]);\n        });\n\n        it(\"should parse simple ordered lists\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: true,\n                start: 1,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse simple ordered lists with silly numbers\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"13. second\\n\" +\n                \"9. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                start: 1,\n                ordered: true,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \"63. first\\n\" +\n                \"13. second\\n\" +\n                \"9. third\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                start: 63,\n                ordered: true,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse nested lists\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"   * inner\\n\" +\n                \"   * inner\\n\" +\n                \"3. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: true,\n                start: 1,\n                items: [\n                    [{\n                        content: \"first\",\n                        type: \"text\",\n                    }],\n                    [\n                        {\n                            content: \"second\\n\",\n                            type: \"text\",\n                        },\n                        {\n                            ordered: false,\n                            start: undefined,\n                            items: [\n                                [{\n                                    content: \"inner\",\n                                    type: \"text\",\n                                }],\n                                [{\n                                    content: \"inner\",\n                                    type: \"text\",\n                                }]\n                            ],\n                            type: \"list\",\n                        }\n                    ],\n                    [{\n                        content: \"third\",\n                        type: \"text\",\n                    }],\n                ],\n                type: \"list\",\n            }]);\n\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \"    * bye\\n\" +\n                \"    * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        content: 'hi\\n ', // NOTE(aria): The extra space here is\n                        type: 'text',     //  weird and we should consider fixing\n                    },\n                    {\n                        ordered: false,\n                        start: undefined,\n                        items: [\n                            [{\n                                content: \"bye\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"there\",\n                                type: \"text\",\n                            }],\n                        ],\n                        type: \"list\",\n                    }]\n                ],\n                type: \"list\",\n            }]);\n        });\n\n        it(\"should parse loose lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should have defined behaviour for semi-loose lists\", function() {\n            // we mostly care that this does something vaguely reasonable.\n            // if you write markdown like this the results are your own fault.\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \" * hi\\n\\n\" +\n                \" * bye\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"there\"\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse paragraphs within loose lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\\n\" +\n                \"   hello\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"hi\"\n                            }]\n                        },\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"hello\"\n                            }]\n                        },\n                    ],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should allow line breaks+wrapping in tight lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \"   hello\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\\nhello\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should allow code inside list items\", function() {\n            var parsed = blockParse(\n                \" * this is a list\\n\\n\" +\n                \"       with code in it\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    {\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"this is a list\"\n                        }]\n                    },\n                    {\n                        type: \"codeBlock\",\n                        lang: undefined,\n                        content: \"with code in it\"\n                    }\n                ]]\n            }]);\n\n            var parsed2 = blockParse(\n                \" * this is a list\\n\\n\" +\n                \"       with code in it\\n\\n\" +\n                \" * second item\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"this is a list\"\n                            }]\n                        },\n                        {\n                            type: \"codeBlock\",\n                            lang: undefined,\n                            content: \"with code in it\"\n                        }\n                    ],\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"second item\"\n                            }]\n                        },\n                    ],\n                ]\n            }]);\n        });\n\n        it(\"should allow lists inside blockquotes\", function() {\n            // This list also has lots of trailing space after the *s\n            var parsed = blockParse(\n                \"> A list within a blockquote\\n\" +\n                \">\\n\" +\n                \"> *    asterisk 1\\n\" +\n                \"> *    asterisk 2\\n\" +\n                \"> *    asterisk 3\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"blockQuote\",\n                content: [\n                    {\n                        type: \"paragraph\",\n                        content: [{\n                            content: \"A list within a blockquote\",\n                            type: \"text\",\n                        }]\n                    },\n                    {\n\n                        type: \"list\",\n                        ordered: false,\n                        start: undefined,\n                        items: [\n                            [{\n                                content: \"asterisk 1\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"asterisk 2\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"asterisk 3\",\n                                type: \"text\",\n                            }],\n                        ]\n                    }\n                ]\n            }]);\n        });\n\n        it(\"symbols should not break a paragraph into a list\", function() {\n            var parsed = blockParse(\"hi - there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"- there\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"hi * there\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"* there\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed3 = blockParse(\"hi 1. there\\n\\n\");\n            validateParse(parsed3, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi 1\", type: \"text\" },\n                    { content: \". there\", type: \"text\" },\n                ]\n            }]);\n        });\n\n        it(\"dashes or numbers should not break a list item into a list\", function() {\n            var parsed = blockParse(\"- hi - there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"- there\", type: \"text\" },\n                ]]\n            }]);\n\n            var parsed2 = blockParse(\"* hi * there\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"* there\", type: \"text\" },\n                ]]\n            }]);\n\n            var parsed3 = blockParse(\"1. hi 1. there\\n\\n\");\n            validateParse(parsed3, [{\n                type: \"list\",\n                ordered: true,\n                start: 1,\n                items: [[\n                    { content: \"hi 1\", type: \"text\" },\n                    { content: \". there\", type: \"text\" },\n                ]]\n            }]);\n        });\n\n        it(\"should ignore double spaces at the end of lists\", function() {\n            var parsed = blockParse(\" * hi  \\n * there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{type: \"text\", content: \"hi\"}],\n                    [{type: \"text\", content: \"there\"}],\n                ]\n            }]);\n        });\n\n        it(\"should parse very simple tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"text\", content: \"h1\"}],\n                    [{type: \"text\", content: \"h2\"}],\n                    [{type: \"text\", content: \"h3\"}]\n                ],\n                align: [null, null, null],\n                cells: [\n                    [\n                        [{type: \"text\", content: \"d1\"}],\n                        [{type: \"text\", content: \"d2\"}],\n                        [{type: \"text\", content: \"d3\"}]\n                    ],\n                    [\n                        [{type: \"text\", content: \"e1\"}],\n                        [{type: \"text\", content: \"e2\"}],\n                        [{type: \"text\", content: \"e3\"}]\n                    ]\n                ]\n            }];\n\n            var parsedPiped = blockParse(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"| e1 | e2 | e3 |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"h1 | h2 | h3\\n\" +\n                \"- | - | -\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"e1 | e2 | e3\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should parse inside table contents\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"em\", content: [{type: \"text\", content: \"h1\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"h2\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"h3\"}]}],\n                ],\n                align: [null, null, null],\n                cells: [[\n                    [{type: \"em\", content: [{type: \"text\", content: \"d1\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"d2\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"d3\"}]}],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                \"| *h1* | *h2* | *h3* |\\n\" +\n                \"| ---- | ---- | ---- |\\n\" +\n                \"| *d1* | *d2* | *d3* |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"*h1* | *h2* | *h3*\\n\" +\n                \"-|-|-\\n\" +\n                \"*d1* | *d2* | *d3*\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should parse table alignments\", function() {\n            var validateAligns = function(tableSrc, expectedAligns) {\n                var parsed = blockParse(tableSrc + \"\\n\");\n                assert.strictEqual(parsed[0].type, \"table\");\n                var actualAligns = parsed[0].align;\n                validateParse(actualAligns, expectedAligns);\n            };\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [null, null, null]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|:--:|:-: | :-: |\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"center\", \"center\", \"center\"]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| :- |:---| :--|\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"left\", \"left\", \"left\"]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -: |-:  |  -:|\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"right\", \"right\", \"right\"]\n            );\n\n            validateAligns(\n                \"h1 | h2 | h3\\n\" +\n                \":-|:-:|-:\\n\" +\n                \"d1 | d2 | d3\\n\",\n                [\"left\", \"center\", \"right\"]\n            );\n\n            validateAligns(\n                \"h1 | h2 | h3\\n\" +\n                \" :---:  |:--|    --:\\n\" +\n                \"d1 | d2 | d3\\n\",\n                [\"center\", \"left\", \"right\"]\n            );\n        });\n\n        it(\"should parse empty table cells\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [],\n                    [],\n                    []\n                ],\n                align: [null, null, null],\n                cells: [\n                    [\n                        [],\n                        [],\n                        []\n                    ],\n                    [\n                        [],\n                        [],\n                        []\n                    ]\n                ]\n            }];\n\n            var parsedPiped = blockParse(\n                \"|    |    |    |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"|    |    |    |\\n\" +\n                \"|    |    |    |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"   |    |   \\n\" +\n                \"- | - | -\\n\" +\n                \"   |    |   \\n\" +\n                \"   |    |   \\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should allow escaping pipes inside tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: 'Attribute'},\n                        {type: \"text\", content: '|'},\n                    ],\n                    [\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: 'Type'},\n                        {type: \"text\", content: '|'},\n                    ],\n                ],\n                align: [null, null],\n                cells: [[\n                    [\n                        {type: \"text\", content: \"pos\"},\n                        {type: \"text\", content: \"|\"},\n                        {type: \"text\", content: \"position\"}\n                    ],\n                    [\n                        {type: \"text\", content: '\"left'},\n                        {type: \"text\", content: '\" '},\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: ' '},\n                        {type: \"text\", content: '\"right'},\n                        {type: \"text\", content: '\"'}\n                    ],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                '| \\\\|Attribute\\\\| | \\\\|Type\\\\|         |\\n' +\n                '| --------------- | ------------------ |\\n' +\n                '| pos\\\\|position  | \"left\" \\\\| \"right\" |\\n' +\n                '\\n'\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                '\\\\|Attribute\\\\| | \\\\|Type\\\\|        \\n' +\n                '--------------- | ------------------\\n' +\n                'pos\\\\|position  | \"left\" \\\\| \"right\"\\n' +\n                '\\n'\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should allow pipes in code inside tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"text\", content: 'Attribute'}],\n                    [{type: \"text\", content: 'Type'}],\n                ],\n                align: [null, null],\n                cells: [[\n                    [{type: \"inlineCode\", content: \"position\"}],\n                    [{type: \"inlineCode\", content: '\"left\" | \"right\"'}],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                '| Attribute    | Type                  |\\n' +\n                '| ------------ | --------------------- |\\n' +\n                '| `position`   | `\"left\" | \"right\"`   |\\n' +\n                '\\n'\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                'Attribute    | Type                 \\n' +\n                '------------ | ---------------------\\n' +\n                '`position`   | `\"left\" | \"right\"`\\n' +\n                '\\n'\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should be able to parse <br>s\", function() {\n            // Inside a paragraph:\n            var parsed = blockParse(\"hi  \\nbye\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi\", type: \"text\" },\n                    { type: \"br\" },\n                    { content: \"bye\", type: \"text\" },\n                ]\n            }]);\n\n            // Outside a paragraph:\n            var parsed2 = inlineParse(\"hi  \\nbye\");\n            validateParse(parsed2, [\n                { content: \"hi\", type: \"text\" },\n                { type: \"br\" },\n                { content: \"bye\", type: \"text\" },\n            ]);\n\n            // But double spaces on the same line shouldn't count:\n            var parsed3 = inlineParse(\"hi  bye\");\n            validateParse(parsed3, [\n                { content: \"hi  bye\", type: \"text\" },\n            ]);\n        });\n\n        it(\"should parse unicode characters in a word\", function() {\n            var parsed = inlineParse(\"string with parse \u00f6ppurtuniti\u00e9s\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"string with parse \u00f6ppurtuniti\u00e9s\"\n            }]);\n        });\n    });\n\n    describe(\"preprocess step\", function() {\n        it(\"should strip `\\\\f`s\", function() {\n            var parsed = blockParse(\"hi\\n\\n\\fbye\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n\n            var parsed2 = blockParse(\"hi\\n\\f\\nbye\\n\\n\");\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n        });\n\n        it(\"should handle \\\\r nicely\", function() {\n            var parsed = blockParse(\"hi\\r\\nbye\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi\\nbye\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"hi\\r\\rbye\\n\\n\");\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n        });\n\n        it(\"should treat \\\\t as four spaces\", function() {\n            var parsed = blockParse(\"\\tcode\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"code\",\n            }]);\n        });\n    });\n\n    describe(\"parser extension api\", function() {\n        it(\"should parse a simple %variable% extension\", function() {\n            var percentVarRule = {\n                match: function(source) {\n                    return /^%([\\s\\S]+?)%/.exec(source);\n                },\n\n                order: SimpleMarkdown.defaultRules.em.order + 0.5,\n\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n\n            var rules = _.extend({}, SimpleMarkdown.defaultRules, {\n                percentVar: percentVarRule\n            });\n\n            var rawBuiltParser = SimpleMarkdown.parserFor(rules);\n\n            var inlineParse = function(source) {\n                return rawBuiltParser(source, {inline: true});\n            };\n\n            var parsed = inlineParse(\"Hi %name%!\");\n\n            validateParse(parsed, [\n                {content: \"Hi \", type: \"text\"},\n                {content: \"name\", type: \"percentVar\"},\n                {content: \"!\", type: \"text\"},\n            ]);\n        });\n\n        describe(\"should sort rules by order and name\", function() {\n            var emRule = {\n                match: SimpleMarkdown.inlineRegex(/^_([\\s\\S]+?)_/),\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n            var strongRule = {\n                match: SimpleMarkdown.defaultRules.strong.match,\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n            var textRule = _.extend({}, SimpleMarkdown.defaultRules.text, {\n                order: 10\n            });\n\n            it(\"should sort rules by order\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"should allow fractional orders\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1.4\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0.9\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0.5\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"should allow negative orders\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: -1\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: -2\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n            });\n\n            it(\"should break ties by rule name\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n\n                // ...regardless of their order in the\n                // original rule definition\n                var parser2 = SimpleMarkdown.parserFor({\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n            });\n\n            it(\"should output a warning for non-numeric orders\", function() {\n                var oldconsolewarn = console.warn;\n                var warnings = [];\n                /*::FLOW_IGNORE_COVARIANCE.*/ console.warn = function(warning) {\n                    warnings.push(warning);\n                };\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1/0 - 1/0\n                    }),\n                    text: textRule\n                });\n\n                assert.strictEqual(warnings.length, 1);\n                assert.strictEqual(\n                    warnings[0],\n                    \"simple-markdown: Invalid order for rule `em1`: NaN\"\n                );\n\n                /*::FLOW_IGNORE_COVARIANCE.*/ console.warn = oldconsolewarn;\n            });\n\n            it(\"should break ties with quality\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 1; },\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                // ...regardless of their order in the\n                // original rule definition\n                var parser2 = SimpleMarkdown.parserFor({\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 1; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"rules with quality should always win the tie\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                // except if they don't match\n                var parser2 = SimpleMarkdown.parserFor({\n                    em: _.extend({}, emRule, {\n                        order: 0,\n                    }),\n                    strong: _.extend({}, strongRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em\"},\n                ]);\n                var parsed2b = parser2(\"**hi**\", {inline: true});\n                validateParse(parsed2b, [\n                    {content: \"hi\", type: \"strong\"},\n                ]);\n            });\n        });\n\n        it(\"should append arrays returned from `parse` to the AST\", function() {\n            var parser1 = SimpleMarkdown.parserFor({\n                fancy: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^.*/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        return capture[0].split(' ').map(function(word) {\n                            return { type: \"text\", content: word };\n                        });\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text\n            });\n\n            var parsed1 = parser1(\"this is some text\", {inline: true});\n            validateParse(parsed1, [\n                {content: \"this\", type: \"text\"},\n                {content: \"is\", type: \"text\"},\n                {content: \"some\", type: \"text\"},\n                {content: \"text\", type: \"text\"},\n            ]);\n        });\n\n        it(\"should support [repeated] data extraction via mutating state\", function() {\n            // This is sort of a more complex example than is necessary,  but I\n            // wanted to have some more in-depth tests, so here!\n            // This result counts the words in input/output through state, and also\n            // gives a flattened array result of the words.\n            var rules = {\n                Array: {\n                    result: function(arr, output, state) {\n                        return arr.map(function(node) {\n                            return output(node, state);\n                        }).filter(function(word) {\n                            return !!word;\n                        });\n                    },\n                },\n                word: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\w+/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        state.wordCount++;\n                        return {content: capture[0]};\n                    },\n                    result: function(node, output, state) {\n                        state.wordCount++;\n                        return node.content;\n                    },\n                },\n                delimiter: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    match: function(source) {\n                        return /^\\W+/.exec(source);\n                    },\n                    result: function(node, output, state) {\n                        return null;\n                    },\n                }),\n            };\n\n            var parse = SimpleMarkdown.parserFor(rules, {wordCount: 0});\n            var output = SimpleMarkdown.outputFor(rules, 'result', {wordCount: 0});\n\n            // test parsing\n            var parseState = {};\n            var ast1 = parse('hi here are some words', parseState);\n            assert.strictEqual(parseState.wordCount, 5);\n            // and repeated parsing\n            var ast2 = parse('hi here are some words', parseState);\n            assert.strictEqual(parseState.wordCount, 5);\n            assert.deepEqual(ast1, ast2);\n\n            // test output\n            var outputState = {};\n            var result1 = output(ast1, outputState);\n            assert.deepEqual(result1, ['hi', 'here', 'are', 'some', 'words']);\n            assert.strictEqual(outputState.wordCount, 5);\n            var result2 = output(ast2, outputState);\n            assert.strictEqual(outputState.wordCount, 5);\n            assert.deepEqual(result2, ['hi', 'here', 'are', 'some', 'words']);\n            assert.deepEqual(result1, result2);\n        });\n\n        it(\"should allow default state params in parserFor\", function() {\n            var parser1 = SimpleMarkdown.parserFor(\n                {\n                    fancy: {\n                        order: SimpleMarkdown.defaultRules.text.order - 1,\n                        match: function(source) {\n                            return /^\\w+/.exec(source);\n                        },\n                        parse: function(capture, parse, state) {\n                            var word = capture[0];\n                            var translated = state.lookup[word];\n                            if (translated) {\n                                return {content: translated};\n                            } else {\n                                return {content: word, type: 'text'};\n                            }\n                        },\n                    },\n                    text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                        match: function(source) {\n                            return /^\\W+/.exec(source);\n                        },\n                    }),\n                },\n                {\n                    lookup: {\n                        \"this\": \"th\u00eds\",\n                        \"is\": \"\u00ecs\",\n                        \"text\": \"t\u00eaxt\"\n                    },\n                }\n            );\n\n            var parsed1 = parser1(\"this is some text\", {inline: true});\n            validateParse(parsed1, [\n                {content: \"th\u00eds\", type: \"fancy\"},\n                {content: \" \", type: \"text\"},\n                {content: \"\u00ecs\", type: \"fancy\"},\n                {content: \" \", type: \"text\"},\n                {content: \"some\", type: \"text\"},\n                {content: \" \", type: \"text\"},\n                {content: \"t\u00eaxt\", type: \"fancy\"},\n            ]);\n        });\n\n        it(\"should allow default state params in outputFor\", function() {\n            var output = SimpleMarkdown.outputFor(\n                {\n                    Array: SimpleMarkdown.defaultRules.Array,\n                    text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                        react: function(node, output, state) {\n                            return React.createElement(\n                                state.TextComponent,\n                                {key: state.key},\n                                node.content\n                            );\n                        },\n                    }),\n                },\n                'react',\n                {\n                    // make all text bold\n                    TextComponent: 'b',\n                }\n            );\n\n            var parsed1 = inlineParse(\"this is some text\");\n            var results1 = output(parsed1);\n\n            assert.strictEqual(\n                reactToHtml(results1),\n                '<b>this is some text</b>'\n            );\n        });\n\n        it(\"should not require passing state to recursiveParse\", function() {\n            var parse = SimpleMarkdown.parserFor({\n                bracketed: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\{((?:\\\\[\\S\\s]|[^\\\\\\*])+)\\}/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        var result = {\n                            // note no passing state here:\n                            content: parse(capture[1]),\n                            token: state.token || 0,\n                        };\n                        state.token = (state.token || 0) + 1;\n                        return result;\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text,\n            }, {disableAutoBlockNewlines: true});\n\n            var parsed1 = parse('{outer {inner}}', {inline: true, token: 5327});\n\n            validateParse(parsed1, [{\n                type: 'bracketed',\n                content: [\n                    {\n                        type: 'text',\n                        content: 'outer ',\n                    },\n                    {\n                        type: 'bracketed',\n                        content: [{\n                            type: 'text',\n                            content: 'inner',\n                        }],\n                        token: 5327,\n                    }\n                ],\n                token: 5328,\n            }]);\n\n            // but shouldn't keep old state around between parses:\n            var parsed2 = parse('{outer {inner}}');\n\n            validateParse(parsed2, [{\n                type: 'bracketed',\n                content: [\n                    {\n                        type: 'text',\n                        content: 'outer ',\n                    },\n                    {\n                        type: 'bracketed',\n                        content: [{\n                            type: 'text',\n                            content: 'inner',\n                        }],\n                        token: 0,\n                    }\n                ],\n                token: 1,\n            }]);\n        });\n\n        it(\"should not require passing state to recursiveOutput\", function() {\n            var output = SimpleMarkdown.outputFor({\n                Array: SimpleMarkdown.defaultRules.Array,\n                paragraph: Object.assign({}, SimpleMarkdown.defaultRules.paragraph, {\n                    html: function(node, output) {\n                        return '<p>' + output(node.content) + '</p>';\n                    },\n                }),\n                text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    html: function(node, output, state) {\n                        return '<span class=\"' +\n                            (state.spanClass || 'default') +\n                            '\">' +\n                            /*SimpleMarkdown.sanitizeText*/(node.content) +\n                            '</span>';\n                    },\n                }),\n            }, 'html');\n\n            var parsed1 = SimpleMarkdown.defaultBlockParse('hi there!');\n            var result1 = output(parsed1, {spanClass: 'special'});\n            assert.strictEqual(\n                result1,\n                '<p><span class=\"special\">hi there!</span></p>'\n            );\n\n            // but shouldn't keep state around between outputs:\n            var parsed2 = SimpleMarkdown.defaultBlockParse('hi there!');\n            var result2 = output(parsed2);\n            assert.strictEqual(\n                result2,\n                '<p><span class=\"default\">hi there!</span></p>'\n            );\n        });\n\n        it(\"should ignore null or undefined rules\", function() {\n            var rules = {\n                Array: SimpleMarkdown.defaultRules.Array,\n                spoiler: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\[\\[((?:[^\\]]|\\][^\\]])+)\\]\\]/.exec(source);\n                    },\n                    parse: function(capture, parse) {\n                        return {content: parse(capture[1])};\n                    },\n                    html: function(node, output) {\n                        return '<span style=\"background: black;\">' +\n                            output(node.content) +\n                            '</span>';\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text,\n            };\n\n            var parse = SimpleMarkdown.parserFor(rules, {inline: true});\n            var output = SimpleMarkdown.outputFor(rules, 'html');\n\n            var parsed1 = parse('Hi this is a [[spoiler]]');\n            validateParse(parsed1, [\n                {type: 'text', content: 'Hi this is a '},\n                {\n                    type: 'spoiler', content: [\n                        {type: 'text', content: 'spoiler'},\n                    ]\n                },\n            ]);\n            var result1 = output(parsed1);\n            assert.strictEqual(result1,\n                'Hi this is a <span style=\"background: black;\">spoiler</span>'\n            );\n        });\n    });\n\n    describe(\"react output\", function() {\n        it(\"should sanitize dangerous links\", function() {\n            var html = htmlFromReactMarkdown(\n                \"[link](javascript:alert%28%27hi%27%29)\"\n            );\n            assert.strictEqual(html, \"<a>link</a>\");\n\n            var html2 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: javascript:alert('hi');\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var html3 = htmlFromReactMarkdown(\n                \"[link](data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==)\"\n            );\n            assert.strictEqual(html3, \"<a>link</a>\");\n\n            var html4 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==\\n\\n\"\n            );\n            assert.strictEqual(\n                html4,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var html5 = htmlFromReactMarkdown(\n                \"[link](vbscript:alert)\"\n            );\n            assert.strictEqual(html5, \"<a>link</a>\");\n\n            var html6 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: vbscript:alert\\n\\n\"\n            );\n            assert.strictEqual(\n                html6,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n        });\n\n        it(\"should not sanitize safe links\", function() {\n            var html = htmlFromReactMarkdown(\n                \"[link](https://www.google.com)\"\n            );\n            assert.strictEqual(\n                html,\n                \"<a href=\\\"https://www.google.com\\\">link</a>\"\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: https://www.google.com\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\">\" +\n                    \"<a href=\\\"https://www.google.com\\\">link</a>\" +\n                \"</div>\"\n            );\n        });\n\n        it(\"should output headings\", function() {\n            assertParsesToReact(\n                \"### Heading!\\n\\n\",\n                \"<h3>Heading!</h3>\"\n            );\n\n            assertParsesToReact(\n                \"## hi! ##\\n\\n\",\n                \"<h2>hi!</h2>\"\n            );\n\n            assertParsesToReact(\n                \"Yay!\\n====\\n\\n\",\n                \"<h1>Yay!</h1>\"\n            );\n\n            assertParsesToReact(\n                \"Success\\n---\\n\\n\",\n                \"<h2>Success</h2>\"\n            );\n        });\n\n        it(\"should output hrs\", function() {\n            assertParsesToReact(\n                \"-----\\n\\n\",\n                \"<hr/>\"\n            );\n            assertParsesToReact(\n                \" * * * \\n\\n\",\n                \"<hr/>\"\n            );\n            assertParsesToReact(\n                \"___\\n\\n\",\n                \"<hr/>\"\n            );\n        });\n\n        it(\"should output codeblocks\", function() {\n            var html = htmlFromReactMarkdown(\n                \"    var microwave = new TimeMachine();\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                \"<pre><code>var microwave = new TimeMachine();</code></pre>\"\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"~~~\\n\" +\n                \"var computer = new IBN(5100);\\n\" +\n                \"~~~\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<pre><code>var computer = new IBN(5100);</code></pre>\"\n            );\n\n            var html3 = htmlFromReactMarkdown(\n                \"```yavascript\\n\" +\n                \"var undefined = function() { return 5; }\" +\n                \"```\\n\\n\"\n            );\n            assert.strictEqual(\n                html3,\n                '<pre><code class=\"markdown-code-yavascript\">' +\n                'var undefined = function() { return 5; }' +\n                '</code></pre>'\n            );\n        });\n\n        it(\"should output blockQuotes\", function() {\n            assertParsesToReact(\n                \"> hi there this is a\\ntest\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n\n            assertParsesToReact(\n                \"> hi there this is a\\n> test\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n        });\n\n        it(\"should output lists\", function() {\n            assertParsesToReact(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n\n            assertParsesToReact(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\",\n                '<ol start=\"1\">' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ol>'\n            );\n\n            assertParsesToReact(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \"    * inner\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second <ul><li>inner</li></ul></li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n        });\n\n        it(\"should output tables\", function() {\n            assertParsesToReact(\n                \"h1 | h2 | h3\\n\" +\n                \"---|----|---\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToReact(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|----|----|----|\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToReact(\n                \"h1 | h2 | h3\\n\" +\n                \":--|:--:|--:\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr>' +\n                '<th style=\"text-align:left\" scope=\"col\">h1</th>' +\n                '<th style=\"text-align:center\" scope=\"col\">h2</th>' +\n                '<th style=\"text-align:right\" scope=\"col\">h3</th>' +\n                '</tr>' +\n                '</thead><tbody>' +\n                '<tr>' +\n                '<td style=\"text-align:left\">d1</td>' +\n                '<td style=\"text-align:center\">d2</td>' +\n                '<td style=\"text-align:right\">d3</td>' +\n                '</tr>' +\n                '</tbody></table>'\n            );\n        });\n\n        // TODO(aria): Figure out how to test the newline rule here\n\n        it(\"should output paragraphs\", function() {\n            var html = htmlFromReactMarkdown(\n                \"hi\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                '<div class=\"paragraph\">hi</div>'\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"hi\\n\\n\" +\n                \"bye\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                '<div class=\"paragraph\">hi</div>' +\n                '<div class=\"paragraph\">bye</div>'\n            );\n        });\n\n        it(\"should output escaped text\", function() {\n            assertParsesToReact(\n                \"\\\\#escaping\\\\^symbols\\\\*is\\\\[legal](yes)\",\n                '#escaping^symbols*is[legal](yes)'\n            );\n        });\n\n        it(\"should output links\", function() {\n            assertParsesToReact(\n                \"<https://www.khanacademy.org>\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"<aria@khanacademy.org>\",\n                '<a href=\"mailto:aria@khanacademy.org\">' +\n                'aria@khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"https://www.khanacademy.org\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"[KA](https://www.khanacademy.org)\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"[KA][1]\\n\\n[1]: https://www.khanacademy.org\\n\\n\",\n                '<div class=\"paragraph\">' +\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>' +\n                '</div>'\n            );\n        });\n\n        it(\"should output strong\", function() {\n            assertParsesToReact(\n                \"**bold**\",\n                '<strong>bold</strong>'\n            );\n        });\n\n        it(\"should output u\", function() {\n            assertParsesToReact(\n                \"__underscore__\",\n                '<u>underscore</u>'\n            );\n        });\n\n        it(\"should output em\", function() {\n            assertParsesToReact(\n                \"*italics*\",\n                '<em>italics</em>'\n            );\n        });\n\n        it(\"should output simple combined bold/italics\", function() {\n            assertParsesToReact(\n                \"***bolditalics***\",\n                '<em><strong>bolditalics</strong></em>'\n            );\n            assertParsesToReact(\n                \"**bold *italics***\",\n                '<strong>bold <em>italics</em></strong>'\n            );\n        });\n\n        it(\"should output complex combined bold/italics\", function() {\n            assertParsesToReact(\n                \"***bold** italics*\",\n                '<em><strong>bold</strong> italics</em>'\n            );\n            assertParsesToReact(\n                \"*hi **there you***\",\n                '<em>hi <strong>there you</strong></em>'\n            );\n        });\n\n        it(\"should output del\", function() {\n            assertParsesToReact(\n                \"~~strikethrough~~\",\n                '<del>strikethrough</del>'\n            );\n        });\n\n        it(\"should output inline code\", function() {\n            assertParsesToReact(\n                \"here is some `inline code`.\",\n                'here is some <code>inline code</code>.'\n            );\n        });\n\n        it(\"should output text\", function() {\n            assertParsesToReact(\n                \"Yay text!\",\n                'Yay text!'\n            );\n        });\n\n        it(\"shouldn't split text into multiple spans\", function() {\n            var parsed = SimpleMarkdown.defaultInlineParse(\"hi, there!\");\n            var elements = SimpleMarkdown.defaultReactOutput(parsed);\n            assert.deepEqual(elements, [\"hi, there!\"]);\n        });\n\n        it(\"should join text nodes before outputting them\", function() {\n            var rules = Object.assign({}, SimpleMarkdown.defaultRules, {\n                text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    react: function(node, output, state) {\n                        return React.createElement(\n                            'span',\n                            {key: state.key, className: 'text'},\n                            node.content\n                        );\n                    }\n                }),\n            });\n\n            var output = SimpleMarkdown.outputFor(rules, 'react');\n\n            var parsed = SimpleMarkdown.defaultInlineParse(\n                \"Hi! You! Are! <3!\"\n            );\n\n            var html = reactToHtml(output(parsed));\n\n            assert.strictEqual(\n                html,\n                '<span class=\"text\">Hi! You! Are! &lt;3!</span>'\n            );\n        });\n    });\n\n    describe(\"html output\", function() {\n        it(\"should sanitize dangerous links\", function() {\n            var markdown = \"[link](javascript:alert%28%27hi%27%29)\";\n            assertParsesToHtml(\n                markdown,\n                \"<a>link</a>\"\n            );\n\n            var markdown2 = \"[link][1]\\n\\n\" +\n                \"[1]: javascript:alert('hi');\\n\\n\";\n            assertParsesToHtml(\n                markdown2,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var markdown3 = \"[link](data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==)\";\n            assertParsesToHtml(\n                markdown3,\n                \"<a>link</a>\"\n            );\n\n            var markdown4 = \"[link][1]\\n\\n\" +\n                \"[1]: data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==\\n\\n\";\n            assertParsesToHtml(\n                markdown4,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var markdown5 = \"[link](vbscript:alert)\";\n            assertParsesToHtml(\n                markdown5,\n                \"<a>link</a>\"\n            );\n\n            var markdown6 = \"[link][1]\\n\\n\" +\n                \"[1]: vbscript:alert\\n\\n\";\n            assertParsesToHtml(\n                markdown6,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n        });\n\n        it(\"should not sanitize safe links\", function() {\n            var html = htmlFromMarkdown(\n                \"[link](https://www.google.com)\"\n            );\n            assert.strictEqual(\n                html,\n                \"<a href=\\\"https://www.google.com\\\">link</a>\"\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: https://www.google.com\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\">\" +\n                    \"<a href=\\\"https://www.google.com\\\">link</a>\" +\n                \"</div>\"\n            );\n        });\n\n        it(\"should output headings\", function() {\n            assertParsesToHtml(\n                \"### Heading!\\n\\n\",\n                \"<h3>Heading!</h3>\"\n            );\n\n            assertParsesToHtml(\n                \"## hi! ##\\n\\n\",\n                \"<h2>hi!</h2>\"\n            );\n\n            assertParsesToHtml(\n                \"Yay!\\n====\\n\\n\",\n                \"<h1>Yay!</h1>\"\n            );\n\n            assertParsesToHtml(\n                \"Success\\n---\\n\\n\",\n                \"<h2>Success</h2>\"\n            );\n        });\n\n        it(\"should output hrs\", function() {\n            assertParsesToHtml(\n                \"-----\\n\\n\",\n                \"<hr>\"\n            );\n            assertParsesToHtml(\n                \" * * * \\n\\n\",\n                \"<hr>\"\n            );\n            assertParsesToHtml(\n                \"___\\n\\n\",\n                \"<hr>\"\n            );\n        });\n\n        it(\"should output codeblocks\", function() {\n            var html = htmlFromMarkdown(\n                \"    var microwave = new TimeMachine();\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                \"<pre><code>var microwave = new TimeMachine();</code></pre>\"\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"~~~\\n\" +\n                \"var computer = new IBN(5100);\\n\" +\n                \"~~~\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<pre><code>var computer = new IBN(5100);</code></pre>\"\n            );\n\n            var html3 = htmlFromMarkdown(\n                \"```yavascript\\n\" +\n                \"var undefined = function() { return 5; }\" +\n                \"```\\n\\n\"\n            );\n            assert.strictEqual(\n                html3,\n                '<pre><code class=\"markdown-code-yavascript\">' +\n                'var undefined = function() { return 5; }' +\n                '</code></pre>'\n            );\n        });\n\n        it(\"should output blockQuotes\", function() {\n            assertParsesToHtml(\n                \"> hi there this is a\\ntest\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n\n            assertParsesToHtml(\n                \"> hi there this is a\\n> test\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n        });\n\n        it(\"should output lists\", function() {\n            assertParsesToHtml(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n\n            assertParsesToHtml(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\",\n                '<ol start=\"1\">' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ol>'\n            );\n\n            assertParsesToHtml(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \"    * inner\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second <ul><li>inner</li></ul></li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n        });\n\n        it(\"should output tables\", function() {\n            assertParsesToHtml(\n                \"h1 | h2 | h3\\n\" +\n                \"---|----|---\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToHtml(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|----|----|----|\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToHtml(\n                \"h1 | h2 | h3\\n\" +\n                \":--|:--:|--:\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr>' +\n                '<th style=\"text-align:left;\" scope=\"col\">h1</th>' +\n                '<th style=\"text-align:center;\" scope=\"col\">h2</th>' +\n                '<th style=\"text-align:right;\" scope=\"col\">h3</th>' +\n                '</tr>' +\n                '</thead><tbody>' +\n                '<tr>' +\n                '<td style=\"text-align:left;\">d1</td>' +\n                '<td style=\"text-align:center;\">d2</td>' +\n                '<td style=\"text-align:right;\">d3</td>' +\n                '</tr>' +\n                '</tbody></table>'\n            );\n        });\n\n        // TODO(aria): Figure out how to test the newline rule here\n\n        it(\"should output paragraphs\", function() {\n            var html = htmlFromMarkdown(\n                \"hi\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                '<div class=\"paragraph\">hi</div>'\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"hi\\n\\n\" +\n                \"bye\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                '<div class=\"paragraph\">hi</div>' +\n                '<div class=\"paragraph\">bye</div>'\n            );\n        });\n\n        it(\"should output escaped text\", function() {\n            assertParsesToHtml(\n                \"\\\\#escaping\\\\^symbols\\\\*is\\\\[legal](yes)\",\n                '#escaping^symbols*is[legal](yes)'\n            );\n        });\n\n        it(\"should output links\", function() {\n            assertParsesToHtml(\n                \"<https://www.khanacademy.org>\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"<aria@khanacademy.org>\",\n                '<a href=\"mailto:aria@khanacademy.org\">' +\n                'aria@khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"https://www.khanacademy.org\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"[KA](https://www.khanacademy.org)\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"[KA][1]\\n\\n[1]: https://www.khanacademy.org\\n\\n\",\n                '<div class=\"paragraph\">' +\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>' +\n                '</div>'\n            );\n        });\n\n        it(\"should output strong\", function() {\n            assertParsesToHtml(\n                \"**bold**\",\n                '<strong>bold</strong>'\n            );\n        });\n\n        it(\"should output u\", function() {\n            assertParsesToHtml(\n                \"__underscore__\",\n                '<u>underscore</u>'\n            );\n        });\n\n        it(\"should output em\", function() {\n            assertParsesToHtml(\n                \"*italics*\",\n                '<em>italics</em>'\n            );\n        });\n\n        it(\"should output simple combined bold/italics\", function() {\n            assertParsesToHtml(\n                \"***bolditalics***\",\n                '<em><strong>bolditalics</strong></em>'\n            );\n            assertParsesToHtml(\n                \"**bold *italics***\",\n                '<strong>bold <em>italics</em></strong>'\n            );\n        });\n\n        it(\"should output complex combined bold/italics\", function() {\n            assertParsesToHtml(\n                \"***bold** italics*\",\n                '<em><strong>bold</strong> italics</em>'\n            );\n            assertParsesToHtml(\n                \"*hi **there you***\",\n                '<em>hi <strong>there you</strong></em>'\n            );\n        });\n\n        it(\"should output del\", function() {\n            assertParsesToHtml(\n                \"~~strikethrough~~\",\n                '<del>strikethrough</del>'\n            );\n        });\n\n        it(\"should output inline code\", function() {\n            assertParsesToHtml(\n                \"here is some `inline code`.\",\n                'here is some <code>inline code</code>.'\n            );\n        });\n\n        it(\"should output text\", function() {\n            assertParsesToHtml(\n                \"Yay text!\",\n                'Yay text!'\n            );\n        });\n\n        it(\"shouldn't split text into multiple spans\", function() {\n            var parsed = SimpleMarkdown.defaultInlineParse(\"hi, there!\");\n            var elements = SimpleMarkdown.defaultHtmlOutput(parsed);\n            assert.deepEqual(elements, \"hi, there!\");\n        });\n    });\n\n    describe(\"convenience wrappers\", function() {\n        describe(\"markdownToReact\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var elems = SimpleMarkdown.markdownToReact(\n                    \"Hi there!\\n\\nYay!\"\n                );\n\n                assert.strictEqual(reactToHtml(elems),\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>'\n                );\n            });\n        });\n\n        describe(\"markdownToHtml\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var html = SimpleMarkdown.markdownToHtml(\n                    \"Hi there!\\n\\nYay!\"\n                );\n\n                assert.strictEqual(html,\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>'\n                );\n            });\n        });\n\n        describe(\"ReactMarkdown component\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var elem = React.createElement(SimpleMarkdown.ReactMarkdown, {\n                    source: \"Hi there!\\n\\nYay!\"\n                });\n\n                assert.strictEqual(reactToHtml(elem), '<div>' +\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>' +\n                    '</div>'\n                );\n            });\n        });\n    });\n\n    describe(\"helper functions\", function() {\n        describe(\"sanitizeText\", function() {\n            it(\"should escape basic html\", function() {\n                var result = SimpleMarkdown.sanitizeText(\n                    'hi <span class=\"my-class\">there</span>'\n                );\n                assert.strictEqual(\n                    result,\n                    'hi &lt;span class=&quot;my-class&quot;&gt;there&lt;/span&gt;'\n                );\n            });\n        });\n    });\n\n    describe(\"Exponential backtracking avoidance\", function() {\n        it(\"should parse long inlineCode quickly\", function() {\n            var source = '`' + Array(2000).join(' ');\n            var startTime = Date.now();\n            var parsed = inlineParse(source);\n            var duration = Date.now() - startTime;\n            assert.ok(duration < 10, \"Expected parsing to finish in <10ms, but was \" + duration + \"ms.\");\n        });\n    });\n});\n", "/* @flow */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {[string]: any};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n}\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n};\n\n// End Flow Definitions\n*/\n\n// Open IIFE, and immediately close it in flow\n(function() { /*::})*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n// Turn various crazy whitespace into easy to process things\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /*::(*/ rules[typeA] /*:: :any)*/;\n        var ruleB /* : ParserRule */ = /*::(*/ rules[typeB] /*:: :any)*/;\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var latestState;\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        var prevCapture = \"\";\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /*::(*/ rules[currRuleType] /*:: : any)*/;\n\n            do {\n                var currOrder = currRule.order;\n                var currCapture = currRule.match(source, state, prevCapture);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCapture\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ rules[currRuleType] /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            // Lie to flow and say these checks always happen\n            if (state.disableErrorGuards !== true) { /*:: } { */\n                if (rule == null || capture == null /*:: || ruleType == null */) {\n                    throw new Error(\n                        \"Could not find a matching rule for the below \" +\n                        \"content. The rule with highest `order` should \" +\n                        \"always match content provided to it. Check \" +\n                        \"the definition of `match` for '\" +\n                        ruleList[ruleList.length - 1] +\n                        \"'. It seems to not match the following source:\\n\" +\n                        source\n                    );\n                }\n                if (capture.index !== 0 &&\n                    source.slice(0, capture[0].length) !== capture[0]\n                ) {\n                    throw new Error(\n                        \"`match` must return a capture starting at index 0 \" +\n                        \"(the current parse index). Did you forget a ^ at the \" +\n                        \"start of the RegExp?\"\n                    );\n                }\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(parsed);\n            }\n\n            prevCapture = capture[0];\n            source = source.substring(prevCapture.length);\n        }\n        return result;\n    };\n\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | null */,\n    props /* : { [string]: any } */\n) {\n    var element = {\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key,\n        ref: null,\n        props: props,\n        _owner: null\n    };\n    return /* :: (( */ element /* :: : any ) : ReactElement) */;\n};\n\n// Returns a closed HTML tag.\n// tagName: Name of HTML tag (eg. \"em\" or \"a\")\n// content: Inner content of tag\n// attributes: Optional extra attributes of tag as an object of key-value pairs\n//   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n// isClosed: boolean that controls whether tag is closed or not (eg. img tags).\n//   defaults to true\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n// Parse some content with the parser `parse`, with state.inline\n// set to true. Useful for block elements; not generally necessary\n// to be used by inline elements (where state.inline is already true.\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_BLOCK_TRIM = /\\n+/g;\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    var parseTable = function(trimEndSeparators) {\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state, prevCapture) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCapture);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                var res = LIST_R.exec(source);\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(item, i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(item, i) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(row, r) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(content, c) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(row) {\n                var cols = row.map(function(content, c) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s\\\\~]|\\s+(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2]\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : NodeOutput<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    var latestState;\n    var arrayRule = rules.Array || defaultRules.Array;\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRule[property](ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\nvar ReactMarkdown = function(props) {\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{[any]: ?Attr}, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, arguments);\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, arguments);\n    }\n};\n\nif (typeof module !== \"undefined\" && module.exports) {\n    module.exports = SimpleMarkdown;\n} else if (typeof global !== \"undefined\") {\n    global.SimpleMarkdown = SimpleMarkdown;\n} else {\n    window.SimpleMarkdown = SimpleMarkdown;\n}\n/*:: module.exports = SimpleMarkdown; */\n\n// Close the IIFE\n/*:: (function() { */})();\n\n"], "fixing_code": ["// @flow\n\nvar assert = require(\"assert\");\nvar _ = require(\"underscore\");\nvar React = require(\"react\");\nvar ReactDOMServer = require(\"react-dom/server\");\n\nvar SimpleMarkdown = require(\"../simple-markdown.js\");\nvar blockParse = SimpleMarkdown.defaultBlockParse;\nvar inlineParse = SimpleMarkdown.defaultInlineParse;\nvar implicitParse = SimpleMarkdown.defaultImplicitParse;\nvar defaultReactOutput = SimpleMarkdown.defaultReactOutput;\nvar defaultHtmlOutput = SimpleMarkdown.defaultHtmlOutput;\n\n/*:: // Flow definitions & hackery\n\nvar FLOW_IGNORE_COVARIANCE = {\n  console: {\n    warn: (console.warn : any),\n  },\n};\n*/\n\n// A pretty-printer that handles `undefined` and functions better\n// than JSON.stringify\n// Important because some AST node fields can be undefined, and\n// if those don't show up in the assert output, it can be\n// very confusing to figure out how the actual and expected differ\n// Whether node's util.inspect or JSON.stringify is better seems\n// context dependent.\nvar prettyPrintAST = function(ast) {\n    return JSON.stringify(ast, null, 4);\n//    return nodeUtil.inspect(ast, {\n//        depth: null,\n//        colors: false\n//    });\n};\n\nvar validateParse = function(parsed, expected) {\n    if (!_.isEqual(parsed, expected)) {\n        var parsedStr = prettyPrintAST(parsed);\n        var expectedStr = prettyPrintAST(expected);\n        // assert.fail doesn't seem to print the\n        // expected and actual anymore, so we just\n        // throw our own exception.\n        throw new Error(\"Expected:\\n\" +\n            expectedStr +\n            \"\\n\\nActual:\\n\" +\n            parsedStr\n        );\n    }\n};\n\nvar reactToHtml = function(reactElements) {\n    var rawHtml = ReactDOMServer.renderToStaticMarkup(\n        React.createElement('div', {}, reactElements)\n    );\n    var innerHtml = rawHtml\n        .replace(/^<div>/, '')\n        .replace(/<\\/div>$/, '');\n    var simplifiedHtml = innerHtml\n        .replace(/>\\n*/g, '>')\n        .replace(/\\n*</g, '<')\n        .replace(/\\s+/g, ' ');\n    return simplifiedHtml;\n};\n\nvar htmlThroughReact = function(parsed) {\n    var output = defaultReactOutput(parsed);\n    return reactToHtml(output);\n};\n\nvar htmlFromReactMarkdown = function(source) {\n    return htmlThroughReact(implicitParse(source));\n};\n\nvar htmlFromMarkdown = function(source) {\n    var html = defaultHtmlOutput(implicitParse(source));\n    var simplifiedHtml = html.replace(/\\s+/g, ' ');\n    return simplifiedHtml;\n};\n\nvar assertParsesToReact = function(source, html) {\n    var actualHtml = htmlFromReactMarkdown(source);\n    assert.strictEqual(actualHtml, html);\n};\n\nvar assertParsesToHtml = function(source, html) {\n    var actualHtml = htmlFromMarkdown(source);\n    assert.strictEqual(actualHtml, html);\n};\n\ndescribe(\"simple markdown\", function() {\n    describe(\"parser\", function() {\n        it(\"should parse a plain string\", function() {\n            var parsed = inlineParse(\"hi there\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"hi there\"\n            }]);\n        });\n\n        it(\"should parse bold\", function() {\n            var parsed = inlineParse(\"**hi**\");\n            validateParse(parsed, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse italics\", function() {\n            var parsed = inlineParse(\"*hi*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*test i*\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"test i\"\n                }]\n            }]);\n        });\n\n        it(\"should not parse ** as empty italics\", function() {\n            var parsed = inlineParse(\"**\");\n            validateParse(parsed, [\n              { type: \"text\", content: \"*\" },\n              { type: \"text\", content: \"*\" },\n            ]);\n        });\n\n        it(\"should parse a single italic character\", function() {\n            var parsed = inlineParse(\"*h*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"h\"\n                }]\n            }]);\n        });\n\n        it(\"should parse strikethrough\", function() {\n            var parsed = inlineParse(\"~~hi~~\");\n            validateParse(parsed, [{\n                type: \"del\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            // not super important that it parses this like this, but\n            // it should be a valid something...\n            var parsed2 = inlineParse(\"~~~~~\");\n            validateParse(parsed2, [\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n                { content: \"~\", type: \"text\" },\n            ]);\n        });\n\n        it(\"should support escapes in strikethrough\", function() {\n            validateParse(inlineParse(\"~~hi\\\\~~ there~~\"), [{\n                type: \"del\",\n                content: [\n                    { type: \"text\", content: \"hi\" },\n                    { type: \"text\", content: \"~\" },\n                    { type: \"text\", content: \"~ there\" },\n                ]\n            }]);\n        });\n\n        it(\"should not allow strikethrough to contain non-closing ~~s\", function() {\n            validateParse(inlineParse(\"~~hi ~~there~~\"), [\n                { type: \"text\", content: \"~\" },\n                { type: \"text\", content: \"~hi \" },\n                { type: \"del\", content: [{ type: \"text\", content: \"there\" }] },\n            ]);\n        });\n\n        it(\"should parse underlines\", function() {\n            var parsed = inlineParse(\"__hi__\");\n            validateParse(parsed, [{\n                type: \"u\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse nested bold/italics\", function() {\n            var parsed = inlineParse(\"***hi***\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse nested bold/italics/underline\", function() {\n            var parsed1 = inlineParse(\"***__hi__***\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"u\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }]\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*__**hi**__*\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"u\",\n                    content: [{\n                        type: \"strong\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"***bolditalics***\");\n            validateParse(parsed3, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bolditalics\",\n                    }]\n                }]\n            }]);\n\n            var parsed4 = inlineParse(\"**bold *italics***\");\n            validateParse(parsed4, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"bold \",\n                }, {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"italics\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped underscores in underscore italics\", function() {\n            var parsed1 = inlineParse(\"_ABC\\\\_DEF_\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"ABC\",\n                }, {\n                    type: \"text\",\n                    content: \"_\",\n                }, {\n                    type: \"text\",\n                    content: \"DEF\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"_**ABC\\\\_DEF**_\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"_\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"_**ABC\\\\$DEF**_\");\n            validateParse(parsed3, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"$\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n\n            validateParse(inlineParse(\"_\\\\\\\\_\"), [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"\\\\\",\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped asterisks in asterisk italics\", function() {\n            var parsed1 = inlineParse(\"*hi\\\\* there*\");\n            validateParse(parsed1, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \" there\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"_**ABC\\\\*DEF**_\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"ABC\",\n                    }, {\n                        type: \"text\",\n                        content: \"*\",\n                    }, {\n                        type: \"text\",\n                        content: \"DEF\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped asterisks in asterisk bolds\", function() {\n            var parsed1 = inlineParse(\"**hi\\\\* there**\");\n            validateParse(parsed1, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \" there\",\n                }]\n            }]);\n\n            validateParse(inlineParse(\"**hi\\\\** there**\"), [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"*\",\n                }, {\n                    type: \"text\",\n                    content: \"* there\",\n                }]\n            }]);\n        });\n\n        it(\"should allow escaped underscores in underlines\", function() {\n            var parsed1 = inlineParse(\"__hi\\\\__ there__\");\n            validateParse(parsed1, [{\n                type: \"u\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\",\n                }, {\n                    type: \"text\",\n                    content: \"_\",\n                }, {\n                    type: \"text\",\n                    content: \"_ there\",\n                }]\n            }]);\n        });\n\n        it(\"should parse complex combined bold/italics\", function() {\n            var parsed = inlineParse(\"***bold** italics*\");\n            validateParse(parsed, [{\n                type: \"em\",\n                content: [{\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\",\n                    }]\n                }, {\n                    type: \"text\",\n                    content: \" italics\",\n                }]\n            }]);\n\n            var parsed2 = inlineParse(\"*hi **there you***\");\n            validateParse(parsed2, [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi \",\n                }, {\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"there you\",\n                    }]\n                }]\n            }]);\n\n            var parsed3 = inlineParse(\"***like* this**\");\n            validateParse(parsed3, [{\n                type: \"strong\",\n                content: [{\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"like\",\n                    }]\n                }, {\n                    type: \"text\",\n                    content: \" this\",\n                }]\n            }]);\n\n            var parsed4 = inlineParse(\"**bold *and italics***\");\n            validateParse(parsed4, [{\n                type: \"strong\",\n                content: [{\n                    type: \"text\",\n                    content: \"bold \",\n                }, {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"and italics\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple bold/italics/underlines\", function() {\n            var parsed = inlineParse(\n                \"*some* of this __sentence__ is **bold**\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"em\",\n                    content: [{\n                        type: \"text\",\n                        content: \"some\"\n                    }]\n                },\n                {\n                    type: \"text\",\n                    content: \" of this \"\n                },\n                {\n                    type: \"u\",\n                    content: [{\n                        type: \"text\",\n                        content: \"sentence\"\n                    }]\n                },\n                {\n                    type: \"text\",\n                    content: \" is \"\n                },\n                {\n                    type: \"strong\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\"\n                    }]\n                }\n            ]);\n\n            validateParse(inlineParse(\"_italics __bold___\"), [{\n                type: \"em\",\n                content: [{\n                    type: \"text\",\n                    content: \"italics \",\n                }, {\n                    type: \"u\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bold\",\n                    }]\n                }]\n            }]);\n        });\n\n        it(\"should parse inline code\", function() {\n            var parsed = inlineParse(\"`hi`\");\n            validateParse(parsed, [{\n                type: \"inlineCode\",\n                content: \"hi\"\n            }]);\n        });\n\n        it(\"should parse * and _ inside `` as code\", function() {\n            var parsed = inlineParse(\n                \"`const int * const * const p; // _hi_`\"\n            );\n            validateParse(parsed, [{\n                type: \"inlineCode\",\n                content: \"const int * const * const p; // _hi_\"\n            }]);\n        });\n\n        it(\"should ignore a single space at the start and end of an inline code block separating a '`'\", function() {\n            var parsed1 = inlineParse(\n                \"test `` ` `` escaping a code block\"\n            );\n            validateParse(parsed1, [\n                {type: \"text\", content: \"test \"},\n                {type: \"inlineCode\", content: \"`\"},\n                {type: \"text\", content: \" escaping a code block\"},\n            ]);\n\n            var parsed1 = inlineParse(\n                \"test ``  `  `` escaping a code block\"\n            );\n            validateParse(parsed1, [\n                {type: \"text\", content: \"test \"},\n                {type: \"inlineCode\", content: \" ` \"},\n                {type: \"text\", content: \" escaping a code block\"},\n            ]);\n        });\n\n        it(\"should allow you to escape special characters with \\\\\", function() {\n            var parsed = inlineParse(\n                \"\\\\`hi\\\\` \\\\*bye\\\\* \\\\~\\\\|\\\\<\\\\[\\\\{\"\n            );\n            validateParse(parsed, [\n                { type: \"text\", content: \"`\" },\n                { type: \"text\", content: \"hi\" },\n                { type: \"text\", content: \"`\" },\n                { type: \"text\", content: \" \" },\n                { type: \"text\", content: \"*\" },\n                { type: \"text\", content: \"bye\" },\n                { type: \"text\", content: \"*\" },\n                { type: \"text\", content: \" \" },\n                { type: \"text\", content: \"~\" },\n                { type: \"text\", content: \"|\" },\n                { type: \"text\", content: \"<\" },\n                { type: \"text\", content: \"[\" },\n                { type: \"text\", content: \"{\" },\n            ]);\n\n            var parsed2 = inlineParse(\n                \"hi\\\\^caret\"\n            );\n            validateParse(parsed2, [\n                { type: \"text\", content: \"hi\" },\n                { type: \"text\", content: \"^\" },\n                { type: \"text\", content: \"caret\" },\n            ]);\n        });\n\n        it(\"should parse basic []() links as links\", function() {\n            var parsed = inlineParse(\"[hi](http://www.google.com)\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }],\n                target: \"http://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"[secure](https://www.google.com)\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"secure\"\n                }],\n                target: \"https://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\n                \"[local](http://localhost:9000/test.html)\"\n            );\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"local\"\n                }],\n                target: \"http://localhost:9000/test.html\",\n                title: undefined\n            }]);\n\n            var parsed4 = inlineParse(\n                \"[params](http://localhost:9000/test.html\" +\n                \"?content=%7B%7D&format=pretty)\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"params\"\n                }],\n                target: \"http://localhost:9000/test.html\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: undefined\n            }]);\n\n            var parsed5 = inlineParse(\n                \"[hash](http://localhost:9000/test.html#content=%7B%7D)\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"hash\"\n                }],\n                target: \"http://localhost:9000/test.html#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should allow escaping `[` with `\\\\`\", function() {\n            // Without the backslash, the following would be a\n            // link with the text \"hi\".\n            // With the backslash, it should ignore the '[hi]'\n            // portion, but will still detect that the inside\n            // of the parentheses contains a raw url, which it\n            // will turn into a url link.\n            var parsed = inlineParse(\"\\\\[hi](http://www.google.com)\");\n            validateParse(parsed, [\n                {content: \"[\", type: \"text\"},\n                {content: \"hi\", type: \"text\"},\n                {content: \"]\", type: \"text\"},\n                {content: \"(\", type: \"text\"},\n                {\n                    type: \"link\",\n                    content: [{\n                        type: \"text\",\n                        content: \"http://www.google.com\"\n                    }],\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {content: \")\", type: \"text\"},\n            ]);\n        });\n\n        it(\"should allow escaping of link urls with `\\\\`\", function() {\n            var parsed = inlineParse(\"[test link](https://test.link/\\\\(test\\\\))\");\n            validateParse(parsed, [\n                {\n                    type: \"link\",\n                    content: [{\n                        type: \"text\",\n                        content: \"test link\"\n                    }],\n                    target: \"https://test.link/(test)\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse basic <autolinks>\", function() {\n            var parsed = inlineParse(\"<http://www.google.com>\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://www.google.com\"\n                }],\n                target: \"http://www.google.com\"\n            }]);\n\n            var parsed2 = inlineParse(\"<https://www.google.com>\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"https://www.google.com\"\n                }],\n                target: \"https://www.google.com\"\n            }]);\n\n            var parsed3 = inlineParse(\"<http://localhost:9000/test.html>\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html\"\n                }],\n                target: \"http://localhost:9000/test.html\"\n            }]);\n\n            var parsed4 = inlineParse(\n                \"<http://localhost:9000/test.html\" +\n                \"?content=%7B%7D&format=pretty>\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html\" +\n                            \"?content=%7B%7D&format=pretty\"\n                }],\n                target: \"http://localhost:9000/test.html\" +\n                        \"?content=%7B%7D&format=pretty\"\n            }]);\n\n            var parsed5 = inlineParse(\n                \"<http://localhost:9000/test.html#content=%7B%7D>\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://localhost:9000/test.html#content=%7B%7D\"\n                }],\n                target: \"http://localhost:9000/test.html#content=%7B%7D\"\n            }]);\n        });\n\n        it(\"should parse basic <mailto@autolinks>\", function() {\n            var parsed = inlineParse(\"<test@example.com>\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"test@example.com\"\n                }],\n                target: \"mailto:test@example.com\"\n            }]);\n\n            var parsed2 = inlineParse(\"<test+ext@example.com>\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"test+ext@example.com\"\n                }],\n                target: \"mailto:test+ext@example.com\"\n            }]);\n\n            var parsed3 = inlineParse(\"<mailto:test@example.com>\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"mailto:test@example.com\"\n                }],\n                target: \"mailto:test@example.com\"\n            }]);\n\n            var parsed4 = inlineParse(\"<MAILTO:TEST@EXAMPLE.COM>\");\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"MAILTO:TEST@EXAMPLE.COM\"\n                }],\n                target: \"MAILTO:TEST@EXAMPLE.COM\"\n            }]);\n        });\n\n        it(\"should parse basic freeform urls\", function() {\n            var parsed = inlineParse(\"http://www.google.com\");\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://www.google.com\"\n                }],\n                target: \"http://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"https://www.google.com\");\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"https://www.google.com\"\n                }],\n                target: \"https://www.google.com\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\"http://example.com/test.html\");\n            validateParse(parsed3, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html\"\n                }],\n                target: \"http://example.com/test.html\",\n                title: undefined\n            }]);\n\n            var parsed4 = inlineParse(\n                \"http://example.com/test.html\" +\n                \"?content=%7B%7D&format=pretty\"\n            );\n            validateParse(parsed4, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html\" +\n                            \"?content=%7B%7D&format=pretty\"\n                }],\n                target: \"http://example.com/test.html\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: undefined\n            }]);\n\n            var parsed5 = inlineParse(\n                \"http://example.com/test.html#content=%7B%7D\"\n            );\n            validateParse(parsed5, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"http://example.com/test.html#content=%7B%7D\"\n                }],\n                target: \"http://example.com/test.html#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should not split words before colons\", function() {\n            var parsed = inlineParse(\"Here is a rule: try this\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"Here is a rule\",\n            }, {\n                type: \"text\",\n                content: \": try this\",\n            }]);\n        });\n\n        it(\"should parse freeform urls inside paragraphs\", function() {\n            var parsed = blockParse(\n                \"hi this is a link http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {\n                        type: \"text\",\n                        content: \"hi this is a link \",\n                    },\n                    {\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"http://www.google.com\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }\n                ]\n            }]);\n        });\n\n        it(\"should parse [reflinks][and their targets]\", function() {\n            var parsed = implicitParse(\n                \"[Google][1]\\n\\n\" +\n                \"[1]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = blockParse(\n                \"[1]: http://www.google.com\\n\\n\" +\n                \"[Google][1]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse inline link titles\", function() {\n            var parsed = inlineParse(\n                \"[Google](http://www.google.com \\\"This is google!\\\")\"\n            );\n            validateParse(parsed, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"Google\"\n                }],\n                target: \"http://www.google.com\",\n                title: \"This is google!\"\n            }]);\n\n            var parsed2 = inlineParse(\n                \"[Google](http://www.google.com \\\"still Google\\\")\"\n            );\n            validateParse(parsed2, [{\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: \"Google\"\n                }],\n                target: \"http://www.google.com\",\n                title: \"still Google\"\n            }]);\n        });\n\n        it(\"should parse reflink titles\", function() {\n            var parsed = implicitParse(\n                \"[Google][1]\\n\\n\" +\n                \"[1]: http://www.google.com (This is google!)\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: \"This is google!\"\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: \"This is google!\"\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[1]: http://www.google.com \\\"still Google\\\"\\n\\n\" +\n                \"[Google][1]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: \"still Google\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: \"still Google\"\n                    }]\n                },\n            ]);\n\n            // test some edge cases, notably:\n            // target of \"\"; title using parens; def with a `-` in it\n            var parsed3 = implicitParse(\n                \"[Nowhere][nowhere-target]\\n\\n\" +\n                \"[nowhere-target]: <> (nowhere)\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Nowhere\"\n                        }],\n                        target: \"\",\n                        title: \"nowhere\"\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"nowhere-target\",\n                    target: \"\",\n                    title: \"nowhere\"\n                },\n            ]);\n        });\n\n        it(\"should parse [reflinks][] with implicit targets\", function() {\n            var parsed = implicitParse(\n                \"[Google][]\\n\\n\" +\n                \"[Google]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[Google]: http://www.google.com\\n\\n\" +\n                \"[Google][]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should handle multiple [reflinks][to the same target]\", function() {\n            var parsed = implicitParse(\n                \"[Google][1] [Yahoo][1]\\n\\n\" +\n                \"[1]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        {\n                            type: \"link\",\n                            content: [{\n                                type: \"text\",\n                                content: \"Google\"\n                            }],\n                            target: \"http://www.google.com\",\n                            title: undefined\n                        },\n                        {\n                            type: \"text\",\n                            content: \" \"\n                        },\n                        {\n                            type: \"link\",\n                            content: [{\n                                type: \"text\",\n                                content: \"Yahoo\"\n                            }],\n                            target: \"http://www.google.com\",\n                            title: undefined\n                        },\n                    ]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            // This is sort of silly, but the last def overrides all previous\n            // links. This is just a test that things are continuing to work\n            // as we currently expect them to, but I seriously hope no one\n            // writes markdown like this!\n            var parsed2 = implicitParse(\n                \"[test][1]\\n\\n\" +\n                \"[1]: http://google.com\\n\\n\" +\n                \"[test2][1]\\n\\n\" +\n                \"[1]: http://khanacademy.org\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"test\"\n                        }],\n                        target: \"http://khanacademy.org\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"test2\"\n                        }],\n                        target: \"http://khanacademy.org\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://khanacademy.org\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse basic images\", function() {\n            var parsed = inlineParse(\"![](http://example.com/test.png)\");\n            validateParse(parsed, [{\n                type: \"image\",\n                alt: \"\",\n                target: \"http://example.com/test.png\",\n                title: undefined\n            }]);\n\n            var parsed2 = inlineParse(\"![aaalt](http://example.com/image)\");\n            validateParse(parsed2, [{\n                type: \"image\",\n                alt: \"aaalt\",\n                target: \"http://example.com/image\",\n                title: undefined\n            }]);\n\n            var parsed3 = inlineParse(\n                \"![](http://localhost:9000/test.html \\\"local\\\")\"\n            );\n            validateParse(parsed3, [{\n                type: \"image\",\n                alt: \"\",\n                target: \"http://localhost:9000/test.html\",\n                title: \"local\"\n            }]);\n\n            var parsed4 = inlineParse(\n                \"![p](http://localhost:9000/test\" +\n                \"?content=%7B%7D&format=pretty \\\"params\\\")\"\n            );\n            validateParse(parsed4, [{\n                type: \"image\",\n                alt: \"p\",\n                target: \"http://localhost:9000/test\" +\n                        \"?content=%7B%7D&format=pretty\",\n                title: \"params\"\n            }]);\n\n            var parsed5 = inlineParse(\n                \"![hash](http://localhost:9000/test.png#content=%7B%7D)\"\n            );\n            validateParse(parsed5, [{\n                type: \"image\",\n                alt: \"hash\",\n                target: \"http://localhost:9000/test.png#content=%7B%7D\",\n                title: undefined\n            }]);\n        });\n\n        it(\"should parse [refimages][and their targets]\", function() {\n            var parsed = implicitParse(\n                \"![aaalt][1]\\n\\n\" +\n                \"[1]: http://example.com/test.gif\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"aaalt\",\n                        target: \"http://example.com/test.gif\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"1\",\n                    target: \"http://example.com/test.gif\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[image]: http://example.com/test.gif\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: undefined\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: undefined\n                    }]\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[image]: http://example.com/test.gif \\\"title!\\\"\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: \"title!\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: \"title!\"\n                    }]\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[image]: http://example.com/test.gif (*title text*)\\n\\n\" +\n                \"![image][]\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"def\",\n                    def: \"image\",\n                    target: \"http://example.com/test.gif\",\n                    title: \"*title text*\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"image\",\n                        alt: \"image\",\n                        target: \"http://example.com/test.gif\",\n                        title: \"*title text*\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should compare defs case- and whitespace-insensitively\", function() {\n            var parsed = implicitParse(\n                \"[Google][HiIiI]\\n\\n\" +\n                \"[HIiii]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"hiiii\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed2 = implicitParse(\n                \"[Google][]\\n\\n\" +\n                \"[google]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \"google\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n\n            var parsed3 = implicitParse(\n                \"[Google][ h    i ]\\n\\n\" +\n                \"[  h i   ]: http://www.google.com\\n\\n\"\n            );\n            validateParse(parsed3, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"link\",\n                        content: [{\n                            type: \"text\",\n                            content: \"Google\"\n                        }],\n                        target: \"http://www.google.com\",\n                        title: undefined\n                    }]\n                },\n                {\n                    type: \"def\",\n                    def: \" h i \",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should not allow defs to break out of a paragraph\", function() {\n            var parsed = implicitParse(\"hi [1]: there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"hi \", type: \"text\"},\n                    {content: \"[1\", type: \"text\"},\n                    {content: \"]\", type: \"text\"},\n                    {content: \": there\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should allow a group of defs next to each other\", function() {\n            var parsed = implicitParse(\n                \"[a]: # (title)\\n\" +\n                \"[b]: http://www.google.com\\n\" +\n                \"[//]: <> (hi)\\n\" +\n                \"[label]: # (there)\\n\" +\n                \"[#]: #\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"def\",\n                    def: \"a\",\n                    target: \"#\",\n                    title: \"title\"\n                },\n                {\n                    type: \"def\",\n                    def: \"b\",\n                    target: \"http://www.google.com\",\n                    title: undefined\n                },\n                {\n                    type: \"def\",\n                    def: \"//\",\n                    target: \"\",\n                    title: \"hi\"\n                },\n                {\n                    type: \"def\",\n                    def: \"label\",\n                    target: \"#\",\n                    title: \"there\"\n                },\n                {\n                    type: \"def\",\n                    def: \"#\",\n                    target: \"#\",\n                    title: undefined\n                },\n            ]);\n        });\n\n        it(\"should parse a single top-level paragraph\", function() {\n            var parsed = blockParse(\"hi\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple top-level paragraphs\", function() {\n            var parsed = blockParse(\"hi\\n\\nbye\\n\\nthere\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"there\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not parse single newlines as paragraphs\", function() {\n            var parsed = inlineParse(\"hi\\nbye\\nthere\\n\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"hi\\nbye\\nthere\\n\"\n            }]);\n        });\n\n        it(\"should not parse a single newline as a new paragraph\", function() {\n            var parsed = blockParse(\"hi\\nbye\\nthere\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\\nbye\\nthere\"\n                }]\n            }]);\n        });\n\n        it(\"should allow whitespace-only lines to end paragraphs\", function() {\n            var parsed = blockParse(\"hi\\n \\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed2 = blockParse(\"hi\\n  \\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed3 = blockParse(\"hi\\n\\n  \\n  \\n\");\n            validateParse(parsed3, [{\n                type: \"paragraph\",\n                content: [{\n                    type: \"text\",\n                    content: \"hi\"\n                }]\n            }]);\n\n            var parsed4 = blockParse(\"hi\\n  \\n\\n   \\nbye\\n\\n\");\n            validateParse(parsed4, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse a single heading\", function() {\n            var parsed = blockParse(\"### heading3\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 3,\n                content: [{\n                    type: \"text\",\n                    content: \"heading3\"\n                }]\n            }]);\n        });\n\n        it(\"should parse a single lheading\", function() {\n            var parsed = blockParse(\"heading2\\n-----\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 2,\n                content: [{\n                    type: \"text\",\n                    content: \"heading2\"\n                }]\n            }]);\n        });\n\n        it(\"should not parse a single lheading with two -- or ==\", function() {\n            var parsed = blockParse(\"heading1\\n==\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {type: \"text\", content: \"heading1\\n\"},\n                    {type: \"text\", content: \"=\"},\n                    {type: \"text\", content: \"=\"},\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"heading2\\n--\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    {type: \"text\", content: \"heading2\\n\"},\n                    {type: \"text\", content: \"-\"},\n                    {type: \"text\", content: \"-\"},\n                ]\n            }]);\n        });\n\n        it(\"should not parse 7 #s as an h7\", function() {\n            var parsed = blockParse(\"#######heading7\\n\\n\");\n            validateParse(parsed, [{\n                type: \"heading\",\n                level: 6,\n                content: [{\n                    type: \"text\",\n                    content: \"#heading7\"\n                }]\n            }]);\n        });\n\n        it(\"should parse a heading between paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \"#heading\\n\\n\\n\" +\n                \"para 2\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }]\n                },\n                {\n                    type: \"heading\",\n                    level: 1,\n                    content: [{\n                        type: \"text\",\n                        content: \"heading\"\n                    }]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not allow headings mid-paragraph\", function() {\n            var parsed = blockParse(\n                \"paragraph # text\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph \", type: \"text\"},\n                    {content: \"# text\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \"paragraph\\n\" +\n                \"text\\n\" +\n                \"----\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph\\ntext\\n\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse a single top-level blockquote\", function() {\n            var parsed = blockParse(\"> blockquote\\n\\n\");\n            validateParse(parsed, [{\n                type: \"blockQuote\",\n                content: [{\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"blockquote\"\n                    }],\n                }]\n            }]);\n        });\n\n        it(\"should parse multiple blockquotes and paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \"> blockquote 1\\n\" +\n                \">\\n\" +\n                \">blockquote 2\\n\\n\" +\n                \"para 2\\n\\n\"\n            );\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }],\n                },\n                {\n                    type: \"blockQuote\",\n                    content: [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"blockquote 1\"\n                            }],\n                        },\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"blockquote 2\"\n                            }],\n                        }\n                    ]\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }],\n                },\n            ]);\n        });\n\n        it(\"should not let a > escape a paragraph as a blockquote\", function() {\n            var parsed = blockParse(\n                \"para 1 > not a quote\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"para 1 \", type: \"text\"},\n                    {content: \"> not a quote\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse a single top-level code block\", function() {\n            var parsed = blockParse(\"    if (true) { code(); }\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"if (true) { code(); }\"\n            }]);\n        });\n\n        it(\"should parse a code block with trailing spaces\", function() {\n            var parsed = blockParse(\"    if (true) { code(); }\\n    \\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"if (true) { code(); }\"\n            }]);\n        });\n\n        it(\"should parse fence blocks\", function() {\n            var parsed = blockParse(\"```\\ncode\\n```\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"code\"\n            }]);\n\n            var parsed2 = blockParse(\n                \"```aletheia\\n\" +\n                \"if true [code()]\\n\" +\n                \"```\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"codeBlock\",\n                lang: \"aletheia\",\n                content: \"if true [code()]\"\n            }]);\n        });\n\n        it(\"should allow indentation inside code blocks\", function() {\n            var parsed = blockParse(\n                \"```\\n\" +\n                \"if (true === false) {\\n\" +\n                \"    throw 'world does not exist';\\n\" +\n                \"}\\n\" +\n                \"```\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: (\n                    \"if (true === false) {\\n\" +\n                    \"    throw 'world does not exist';\\n\" +\n                    \"}\"\n                ),\n            }]);\n\n            var parsed = blockParse(\n                \"~~~\\n\" +\n                \"    this should be indented\\n\" +\n                \"~~~\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"    this should be indented\",\n            }]);\n        });\n\n        it(\"should parse mixed paragraphs and code\", function() {\n            var parsed = blockParse(\n                \"this is regular text\\n\\n\" +\n                \"    this is code\\n\\n\" +\n                \"this is more regular text\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"this is regular text\"\n                    }]\n                },\n                {\n                    type: \"codeBlock\",\n                    lang: undefined,\n                    content: \"this is code\"\n                },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"this is more regular text\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should parse top-level horizontal rules\", function() {\n            var parsed = blockParse(\n                \"---\\n\\n\" +\n                \"***\\n\\n\" +\n                \"___\\n\\n\" +\n                \" - - - - \\n\\n\" +\n                \"_ _ _\\n\\n\" +\n                \"  ***  \\n\\n\"\n            );\n            validateParse(parsed, [\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n                { type: \"hr\" },\n            ]);\n        });\n\n        it(\"should parse hrs between paragraphs\", function() {\n            var parsed = blockParse(\n                \"para 1\\n\\n\" +\n                \" * * * \\n\\n\" +\n                \"para 2\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 1\"\n                    }]\n                },\n                { type: \"hr\" },\n                {\n                    type: \"paragraph\",\n                    content: [{\n                        type: \"text\",\n                        content: \"para 2\"\n                    }]\n                },\n            ]);\n        });\n\n        it(\"should not allow hrs within a paragraph\", function() {\n            var parsed = blockParse(\n                \"paragraph ----\\n\" +\n                \"more paragraph\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    {content: \"paragraph \", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\", type: \"text\"},\n                    {content: \"-\\nmore paragraph\", type: \"text\"},\n                ]\n            }]);\n        });\n\n        it(\"should parse simple unordered lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \" * bye\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        content: \"hi\",\n                        type: \"text\",\n                    }],\n                    [{\n                        content: \"bye\",\n                        type: \"text\",\n                    }],\n                    [{\n                        content: \"there\",\n                        type: \"text\",\n                    }],\n                ],\n                type: \"list\",\n            }]);\n        });\n\n        it(\"should parse simple ordered lists\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: true,\n                start: 1,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse simple ordered lists with silly numbers\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"13. second\\n\" +\n                \"9. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                start: 1,\n                ordered: true,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \"63. first\\n\" +\n                \"13. second\\n\" +\n                \"9. third\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                start: 63,\n                ordered: true,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"first\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"second\",\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"third\",\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse nested lists\", function() {\n            var parsed = blockParse(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"   * inner\\n\" +\n                \"   * inner\\n\" +\n                \"3. third\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: true,\n                start: 1,\n                items: [\n                    [{\n                        content: \"first\",\n                        type: \"text\",\n                    }],\n                    [\n                        {\n                            content: \"second\\n\",\n                            type: \"text\",\n                        },\n                        {\n                            ordered: false,\n                            start: undefined,\n                            items: [\n                                [{\n                                    content: \"inner\",\n                                    type: \"text\",\n                                }],\n                                [{\n                                    content: \"inner\",\n                                    type: \"text\",\n                                }]\n                            ],\n                            type: \"list\",\n                        }\n                    ],\n                    [{\n                        content: \"third\",\n                        type: \"text\",\n                    }],\n                ],\n                type: \"list\",\n            }]);\n\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \"    * bye\\n\" +\n                \"    * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        content: 'hi\\n ', // NOTE(aria): The extra space here is\n                        type: 'text',     //  weird and we should consider fixing\n                    },\n                    {\n                        ordered: false,\n                        start: undefined,\n                        items: [\n                            [{\n                                content: \"bye\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"there\",\n                                type: \"text\",\n                            }],\n                        ],\n                        type: \"list\",\n                    }]\n                ],\n                type: \"list\",\n            }]);\n        });\n\n        it(\"should parse loose lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should have defined behaviour for semi-loose lists\", function() {\n            // we mostly care that this does something vaguely reasonable.\n            // if you write markdown like this the results are your own fault.\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"text\",\n                        content: \"hi\"\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n\n            var parsed2 = blockParse(\n                \" * hi\\n\\n\" +\n                \" * bye\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\"\n                        }]\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"bye\"\n                    }],\n                    [{\n                        type: \"text\",\n                        content: \"there\"\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should parse paragraphs within loose lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\\n\" +\n                \"   hello\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"hi\"\n                            }]\n                        },\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"hello\"\n                            }]\n                        },\n                    ],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should allow line breaks+wrapping in tight lists\", function() {\n            var parsed = blockParse(\n                \" * hi\\n\" +\n                \"   hello\\n\\n\" +\n                \" * bye\\n\\n\" +\n                \" * there\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"hi\\nhello\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"bye\"\n                        }]\n                    }],\n                    [{\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"there\"\n                        }]\n                    }],\n                ]\n            }]);\n        });\n\n        it(\"should allow code inside list items\", function() {\n            var parsed = blockParse(\n                \" * this is a list\\n\\n\" +\n                \"       with code in it\\n\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    {\n                        type: \"paragraph\",\n                        content: [{\n                            type: \"text\",\n                            content: \"this is a list\"\n                        }]\n                    },\n                    {\n                        type: \"codeBlock\",\n                        lang: undefined,\n                        content: \"with code in it\"\n                    }\n                ]]\n            }]);\n\n            var parsed2 = blockParse(\n                \" * this is a list\\n\\n\" +\n                \"       with code in it\\n\\n\" +\n                \" * second item\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"this is a list\"\n                            }]\n                        },\n                        {\n                            type: \"codeBlock\",\n                            lang: undefined,\n                            content: \"with code in it\"\n                        }\n                    ],\n                    [\n                        {\n                            type: \"paragraph\",\n                            content: [{\n                                type: \"text\",\n                                content: \"second item\"\n                            }]\n                        },\n                    ],\n                ]\n            }]);\n        });\n\n        it(\"should allow lists inside blockquotes\", function() {\n            // This list also has lots of trailing space after the *s\n            var parsed = blockParse(\n                \"> A list within a blockquote\\n\" +\n                \">\\n\" +\n                \"> *    asterisk 1\\n\" +\n                \"> *    asterisk 2\\n\" +\n                \"> *    asterisk 3\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsed, [{\n                type: \"blockQuote\",\n                content: [\n                    {\n                        type: \"paragraph\",\n                        content: [{\n                            content: \"A list within a blockquote\",\n                            type: \"text\",\n                        }]\n                    },\n                    {\n\n                        type: \"list\",\n                        ordered: false,\n                        start: undefined,\n                        items: [\n                            [{\n                                content: \"asterisk 1\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"asterisk 2\",\n                                type: \"text\",\n                            }],\n                            [{\n                                content: \"asterisk 3\",\n                                type: \"text\",\n                            }],\n                        ]\n                    }\n                ]\n            }]);\n        });\n\n        it(\"symbols should not break a paragraph into a list\", function() {\n            var parsed = blockParse(\"hi - there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"- there\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"hi * there\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"* there\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed3 = blockParse(\"hi 1. there\\n\\n\");\n            validateParse(parsed3, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi 1\", type: \"text\" },\n                    { content: \". there\", type: \"text\" },\n                ]\n            }]);\n        });\n\n        it(\"dashes or numbers should not break a list item into a list\", function() {\n            var parsed = blockParse(\"- hi - there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"- there\", type: \"text\" },\n                ]]\n            }]);\n\n            var parsed2 = blockParse(\"* hi * there\\n\\n\");\n            validateParse(parsed2, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [[\n                    { content: \"hi \", type: \"text\" },\n                    { content: \"* there\", type: \"text\" },\n                ]]\n            }]);\n\n            var parsed3 = blockParse(\"1. hi 1. there\\n\\n\");\n            validateParse(parsed3, [{\n                type: \"list\",\n                ordered: true,\n                start: 1,\n                items: [[\n                    { content: \"hi 1\", type: \"text\" },\n                    { content: \". there\", type: \"text\" },\n                ]]\n            }]);\n        });\n\n        it(\"should ignore double spaces at the end of lists\", function() {\n            var parsed = blockParse(\" * hi  \\n * there\\n\\n\");\n            validateParse(parsed, [{\n                type: \"list\",\n                ordered: false,\n                start: undefined,\n                items: [\n                    [{type: \"text\", content: \"hi\"}],\n                    [{type: \"text\", content: \"there\"}],\n                ]\n            }]);\n        });\n\n        it(\"should parse very simple tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"text\", content: \"h1\"}],\n                    [{type: \"text\", content: \"h2\"}],\n                    [{type: \"text\", content: \"h3\"}]\n                ],\n                align: [null, null, null],\n                cells: [\n                    [\n                        [{type: \"text\", content: \"d1\"}],\n                        [{type: \"text\", content: \"d2\"}],\n                        [{type: \"text\", content: \"d3\"}]\n                    ],\n                    [\n                        [{type: \"text\", content: \"e1\"}],\n                        [{type: \"text\", content: \"e2\"}],\n                        [{type: \"text\", content: \"e3\"}]\n                    ]\n                ]\n            }];\n\n            var parsedPiped = blockParse(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"| e1 | e2 | e3 |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"h1 | h2 | h3\\n\" +\n                \"- | - | -\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"e1 | e2 | e3\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should parse inside table contents\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"em\", content: [{type: \"text\", content: \"h1\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"h2\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"h3\"}]}],\n                ],\n                align: [null, null, null],\n                cells: [[\n                    [{type: \"em\", content: [{type: \"text\", content: \"d1\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"d2\"}]}],\n                    [{type: \"em\", content: [{type: \"text\", content: \"d3\"}]}],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                \"| *h1* | *h2* | *h3* |\\n\" +\n                \"| ---- | ---- | ---- |\\n\" +\n                \"| *d1* | *d2* | *d3* |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"*h1* | *h2* | *h3*\\n\" +\n                \"-|-|-\\n\" +\n                \"*d1* | *d2* | *d3*\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should parse table alignments\", function() {\n            var validateAligns = function(tableSrc, expectedAligns) {\n                var parsed = blockParse(tableSrc + \"\\n\");\n                assert.strictEqual(parsed[0].type, \"table\");\n                var actualAligns = parsed[0].align;\n                validateParse(actualAligns, expectedAligns);\n            };\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [null, null, null]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|:--:|:-: | :-: |\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"center\", \"center\", \"center\"]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| :- |:---| :--|\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"left\", \"left\", \"left\"]\n            );\n\n            validateAligns(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"| -: |-:  |  -:|\\n\" +\n                \"| d1 | d2 | d3 |\\n\",\n                [\"right\", \"right\", \"right\"]\n            );\n\n            validateAligns(\n                \"h1 | h2 | h3\\n\" +\n                \":-|:-:|-:\\n\" +\n                \"d1 | d2 | d3\\n\",\n                [\"left\", \"center\", \"right\"]\n            );\n\n            validateAligns(\n                \"h1 | h2 | h3\\n\" +\n                \" :---:  |:--|    --:\\n\" +\n                \"d1 | d2 | d3\\n\",\n                [\"center\", \"left\", \"right\"]\n            );\n        });\n\n        it(\"should parse empty table cells\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [],\n                    [],\n                    []\n                ],\n                align: [null, null, null],\n                cells: [\n                    [\n                        [],\n                        [],\n                        []\n                    ],\n                    [\n                        [],\n                        [],\n                        []\n                    ]\n                ]\n            }];\n\n            var parsedPiped = blockParse(\n                \"|    |    |    |\\n\" +\n                \"| -- | -- | -- |\\n\" +\n                \"|    |    |    |\\n\" +\n                \"|    |    |    |\\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                \"   |    |   \\n\" +\n                \"- | - | -\\n\" +\n                \"   |    |   \\n\" +\n                \"   |    |   \\n\" +\n                \"\\n\"\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should allow escaping pipes inside tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: 'Attribute'},\n                        {type: \"text\", content: '|'},\n                    ],\n                    [\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: 'Type'},\n                        {type: \"text\", content: '|'},\n                    ],\n                ],\n                align: [null, null],\n                cells: [[\n                    [\n                        {type: \"text\", content: \"pos\"},\n                        {type: \"text\", content: \"|\"},\n                        {type: \"text\", content: \"position\"}\n                    ],\n                    [\n                        {type: \"text\", content: '\"left'},\n                        {type: \"text\", content: '\" '},\n                        {type: \"text\", content: '|'},\n                        {type: \"text\", content: ' '},\n                        {type: \"text\", content: '\"right'},\n                        {type: \"text\", content: '\"'}\n                    ],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                '| \\\\|Attribute\\\\| | \\\\|Type\\\\|         |\\n' +\n                '| --------------- | ------------------ |\\n' +\n                '| pos\\\\|position  | \"left\" \\\\| \"right\" |\\n' +\n                '\\n'\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                '\\\\|Attribute\\\\| | \\\\|Type\\\\|        \\n' +\n                '--------------- | ------------------\\n' +\n                'pos\\\\|position  | \"left\" \\\\| \"right\"\\n' +\n                '\\n'\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should allow pipes in code inside tables\", function() {\n            var expected = [{\n                type: \"table\",\n                header: [\n                    [{type: \"text\", content: 'Attribute'}],\n                    [{type: \"text\", content: 'Type'}],\n                ],\n                align: [null, null],\n                cells: [[\n                    [{type: \"inlineCode\", content: \"position\"}],\n                    [{type: \"inlineCode\", content: '\"left\" | \"right\"'}],\n                ]]\n            }];\n\n            var parsedPiped = blockParse(\n                '| Attribute    | Type                  |\\n' +\n                '| ------------ | --------------------- |\\n' +\n                '| `position`   | `\"left\" | \"right\"`   |\\n' +\n                '\\n'\n            );\n            validateParse(parsedPiped, expected);\n\n            var parsedNp = blockParse(\n                'Attribute    | Type                 \\n' +\n                '------------ | ---------------------\\n' +\n                '`position`   | `\"left\" | \"right\"`\\n' +\n                '\\n'\n            );\n            validateParse(parsedNp, expected);\n        });\n\n        it(\"should be able to parse <br>s\", function() {\n            // Inside a paragraph:\n            var parsed = blockParse(\"hi  \\nbye\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi\", type: \"text\" },\n                    { type: \"br\" },\n                    { content: \"bye\", type: \"text\" },\n                ]\n            }]);\n\n            // Outside a paragraph:\n            var parsed2 = inlineParse(\"hi  \\nbye\");\n            validateParse(parsed2, [\n                { content: \"hi\", type: \"text\" },\n                { type: \"br\" },\n                { content: \"bye\", type: \"text\" },\n            ]);\n\n            // But double spaces on the same line shouldn't count:\n            var parsed3 = inlineParse(\"hi  bye\");\n            validateParse(parsed3, [\n                { content: \"hi  bye\", type: \"text\" },\n            ]);\n        });\n\n        it(\"should parse unicode characters in a word\", function() {\n            var parsed = inlineParse(\"string with parse \u00f6ppurtuniti\u00e9s\");\n            validateParse(parsed, [{\n                type: \"text\",\n                content: \"string with parse \u00f6ppurtuniti\u00e9s\"\n            }]);\n        });\n    });\n\n    describe(\"preprocess step\", function() {\n        it(\"should strip `\\\\f`s\", function() {\n            var parsed = blockParse(\"hi\\n\\n\\fbye\\n\\n\");\n            validateParse(parsed, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n\n            var parsed2 = blockParse(\"hi\\n\\f\\nbye\\n\\n\");\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n        });\n\n        it(\"should handle \\\\r nicely\", function() {\n            var parsed = blockParse(\"hi\\r\\nbye\\n\\n\");\n            validateParse(parsed, [{\n                type: \"paragraph\",\n                content: [\n                    { content: \"hi\\nbye\", type: \"text\" },\n                ]\n            }]);\n\n            var parsed2 = blockParse(\"hi\\r\\rbye\\n\\n\");\n            validateParse(parsed2, [\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"hi\", type: \"text\" },\n                    ],\n                },\n                {\n                    type: \"paragraph\",\n                    content: [\n                        { content: \"bye\", type: \"text\" },\n                    ],\n                },\n            ]);\n        });\n\n        it(\"should treat \\\\t as four spaces\", function() {\n            var parsed = blockParse(\"\\tcode\\n\\n\");\n            validateParse(parsed, [{\n                type: \"codeBlock\",\n                lang: undefined,\n                content: \"code\",\n            }]);\n        });\n    });\n\n    describe(\"parser extension api\", function() {\n        it(\"should parse a simple %variable% extension\", function() {\n            var percentVarRule = {\n                match: function(source) {\n                    return /^%([\\s\\S]+?)%/.exec(source);\n                },\n\n                order: SimpleMarkdown.defaultRules.em.order + 0.5,\n\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n\n            var rules = _.extend({}, SimpleMarkdown.defaultRules, {\n                percentVar: percentVarRule\n            });\n\n            var rawBuiltParser = SimpleMarkdown.parserFor(rules);\n\n            var inlineParse = function(source) {\n                return rawBuiltParser(source, {inline: true});\n            };\n\n            var parsed = inlineParse(\"Hi %name%!\");\n\n            validateParse(parsed, [\n                {content: \"Hi \", type: \"text\"},\n                {content: \"name\", type: \"percentVar\"},\n                {content: \"!\", type: \"text\"},\n            ]);\n        });\n\n        describe(\"should sort rules by order and name\", function() {\n            var emRule = {\n                match: SimpleMarkdown.inlineRegex(/^_([\\s\\S]+?)_/),\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n            var strongRule = {\n                match: SimpleMarkdown.defaultRules.strong.match,\n                parse: function(capture, parse, state) {\n                    return {\n                        content: capture[1]\n                    };\n                }\n            };\n            var textRule = _.extend({}, SimpleMarkdown.defaultRules.text, {\n                order: 10\n            });\n\n            it(\"should sort rules by order\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"should allow fractional orders\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1.4\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0.9\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0.5\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"should allow negative orders\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: -1\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                var parser2 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: -2\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 1\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n            });\n\n            it(\"should break ties by rule name\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n\n                // ...regardless of their order in the\n                // original rule definition\n                var parser2 = SimpleMarkdown.parserFor({\n                    em2: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    em1: _.extend({}, emRule, {\n                        order: 0\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em1\"},\n                ]);\n            });\n\n            it(\"should output a warning for non-numeric orders\", function() {\n                var oldconsolewarn = console.warn;\n                var warnings = [];\n                /*::FLOW_IGNORE_COVARIANCE.*/ console.warn = function(warning) {\n                    warnings.push(warning);\n                };\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 1/0 - 1/0\n                    }),\n                    text: textRule\n                });\n\n                assert.strictEqual(warnings.length, 1);\n                assert.strictEqual(\n                    warnings[0],\n                    \"simple-markdown: Invalid order for rule `em1`: NaN\"\n                );\n\n                /*::FLOW_IGNORE_COVARIANCE.*/ console.warn = oldconsolewarn;\n            });\n\n            it(\"should break ties with quality\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 1; },\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                // ...regardless of their order in the\n                // original rule definition\n                var parser2 = SimpleMarkdown.parserFor({\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 1; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n            });\n\n            it(\"rules with quality should always win the tie\", function() {\n                var parser1 = SimpleMarkdown.parserFor({\n                    em1: _.extend({}, emRule, {\n                        order: 0,\n                    }),\n                    em2: _.extend({}, emRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed1 = parser1(\"_hi_\", {inline: true});\n                validateParse(parsed1, [\n                    {content: \"hi\", type: \"em2\"},\n                ]);\n\n                // except if they don't match\n                var parser2 = SimpleMarkdown.parserFor({\n                    em: _.extend({}, emRule, {\n                        order: 0,\n                    }),\n                    strong: _.extend({}, strongRule, {\n                        order: 0,\n                        quality: function() { return 2; },\n                    }),\n                    text: textRule\n                });\n\n                var parsed2 = parser2(\"_hi_\", {inline: true});\n                validateParse(parsed2, [\n                    {content: \"hi\", type: \"em\"},\n                ]);\n                var parsed2b = parser2(\"**hi**\", {inline: true});\n                validateParse(parsed2b, [\n                    {content: \"hi\", type: \"strong\"},\n                ]);\n            });\n        });\n\n        it(\"should append arrays returned from `parse` to the AST\", function() {\n            var parser1 = SimpleMarkdown.parserFor({\n                fancy: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^.*/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        return capture[0].split(' ').map(function(word) {\n                            return { type: \"text\", content: word };\n                        });\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text\n            });\n\n            var parsed1 = parser1(\"this is some text\", {inline: true});\n            validateParse(parsed1, [\n                {content: \"this\", type: \"text\"},\n                {content: \"is\", type: \"text\"},\n                {content: \"some\", type: \"text\"},\n                {content: \"text\", type: \"text\"},\n            ]);\n        });\n\n        it(\"should support [repeated] data extraction via mutating state\", function() {\n            // This is sort of a more complex example than is necessary,  but I\n            // wanted to have some more in-depth tests, so here!\n            // This result counts the words in input/output through state, and also\n            // gives a flattened array result of the words.\n            var rules = {\n                Array: {\n                    result: function(arr, output, state) {\n                        return arr.map(function(node) {\n                            return output(node, state);\n                        }).filter(function(word) {\n                            return !!word;\n                        });\n                    },\n                },\n                word: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\w+/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        state.wordCount++;\n                        return {content: capture[0]};\n                    },\n                    result: function(node, output, state) {\n                        state.wordCount++;\n                        return node.content;\n                    },\n                },\n                delimiter: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    match: function(source) {\n                        return /^\\W+/.exec(source);\n                    },\n                    result: function(node, output, state) {\n                        return null;\n                    },\n                }),\n            };\n\n            var parse = SimpleMarkdown.parserFor(rules, {wordCount: 0});\n            var output = SimpleMarkdown.outputFor(rules, 'result', {wordCount: 0});\n\n            // test parsing\n            var parseState = {};\n            var ast1 = parse('hi here are some words', parseState);\n            assert.strictEqual(parseState.wordCount, 5);\n            // and repeated parsing\n            var ast2 = parse('hi here are some words', parseState);\n            assert.strictEqual(parseState.wordCount, 5);\n            assert.deepEqual(ast1, ast2);\n\n            // test output\n            var outputState = {};\n            var result1 = output(ast1, outputState);\n            assert.deepEqual(result1, ['hi', 'here', 'are', 'some', 'words']);\n            assert.strictEqual(outputState.wordCount, 5);\n            var result2 = output(ast2, outputState);\n            assert.strictEqual(outputState.wordCount, 5);\n            assert.deepEqual(result2, ['hi', 'here', 'are', 'some', 'words']);\n            assert.deepEqual(result1, result2);\n        });\n\n        it(\"should allow default state params in parserFor\", function() {\n            var parser1 = SimpleMarkdown.parserFor(\n                {\n                    fancy: {\n                        order: SimpleMarkdown.defaultRules.text.order - 1,\n                        match: function(source) {\n                            return /^\\w+/.exec(source);\n                        },\n                        parse: function(capture, parse, state) {\n                            var word = capture[0];\n                            var translated = state.lookup[word];\n                            if (translated) {\n                                return {content: translated};\n                            } else {\n                                return {content: word, type: 'text'};\n                            }\n                        },\n                    },\n                    text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                        match: function(source) {\n                            return /^\\W+/.exec(source);\n                        },\n                    }),\n                },\n                {\n                    lookup: {\n                        \"this\": \"th\u00eds\",\n                        \"is\": \"\u00ecs\",\n                        \"text\": \"t\u00eaxt\"\n                    },\n                }\n            );\n\n            var parsed1 = parser1(\"this is some text\", {inline: true});\n            validateParse(parsed1, [\n                {content: \"th\u00eds\", type: \"fancy\"},\n                {content: \" \", type: \"text\"},\n                {content: \"\u00ecs\", type: \"fancy\"},\n                {content: \" \", type: \"text\"},\n                {content: \"some\", type: \"text\"},\n                {content: \" \", type: \"text\"},\n                {content: \"t\u00eaxt\", type: \"fancy\"},\n            ]);\n        });\n\n        it(\"should allow default state params in outputFor\", function() {\n            var output = SimpleMarkdown.outputFor(\n                {\n                    Array: SimpleMarkdown.defaultRules.Array,\n                    text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                        react: function(node, output, state) {\n                            return React.createElement(\n                                state.TextComponent,\n                                {key: state.key},\n                                node.content\n                            );\n                        },\n                    }),\n                },\n                'react',\n                {\n                    // make all text bold\n                    TextComponent: 'b',\n                }\n            );\n\n            var parsed1 = inlineParse(\"this is some text\");\n            var results1 = output(parsed1);\n\n            assert.strictEqual(\n                reactToHtml(results1),\n                '<b>this is some text</b>'\n            );\n        });\n\n        it(\"should not require passing state to recursiveParse\", function() {\n            var parse = SimpleMarkdown.parserFor({\n                bracketed: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\{((?:\\\\[\\S\\s]|[^\\\\\\*])+)\\}/.exec(source);\n                    },\n                    parse: function(capture, parse, state) {\n                        var result = {\n                            // note no passing state here:\n                            content: parse(capture[1]),\n                            token: state.token || 0,\n                        };\n                        state.token = (state.token || 0) + 1;\n                        return result;\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text,\n            }, {disableAutoBlockNewlines: true});\n\n            var parsed1 = parse('{outer {inner}}', {inline: true, token: 5327});\n\n            validateParse(parsed1, [{\n                type: 'bracketed',\n                content: [\n                    {\n                        type: 'text',\n                        content: 'outer ',\n                    },\n                    {\n                        type: 'bracketed',\n                        content: [{\n                            type: 'text',\n                            content: 'inner',\n                        }],\n                        token: 5327,\n                    }\n                ],\n                token: 5328,\n            }]);\n\n            // but shouldn't keep old state around between parses:\n            var parsed2 = parse('{outer {inner}}');\n\n            validateParse(parsed2, [{\n                type: 'bracketed',\n                content: [\n                    {\n                        type: 'text',\n                        content: 'outer ',\n                    },\n                    {\n                        type: 'bracketed',\n                        content: [{\n                            type: 'text',\n                            content: 'inner',\n                        }],\n                        token: 0,\n                    }\n                ],\n                token: 1,\n            }]);\n        });\n\n        it(\"should not require passing state to recursiveOutput\", function() {\n            var output = SimpleMarkdown.outputFor({\n                Array: SimpleMarkdown.defaultRules.Array,\n                paragraph: Object.assign({}, SimpleMarkdown.defaultRules.paragraph, {\n                    html: function(node, output) {\n                        return '<p>' + output(node.content) + '</p>';\n                    },\n                }),\n                text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    html: function(node, output, state) {\n                        return '<span class=\"' +\n                            (state.spanClass || 'default') +\n                            '\">' +\n                            /*SimpleMarkdown.sanitizeText*/(node.content) +\n                            '</span>';\n                    },\n                }),\n            }, 'html');\n\n            var parsed1 = SimpleMarkdown.defaultBlockParse('hi there!');\n            var result1 = output(parsed1, {spanClass: 'special'});\n            assert.strictEqual(\n                result1,\n                '<p><span class=\"special\">hi there!</span></p>'\n            );\n\n            // but shouldn't keep state around between outputs:\n            var parsed2 = SimpleMarkdown.defaultBlockParse('hi there!');\n            var result2 = output(parsed2);\n            assert.strictEqual(\n                result2,\n                '<p><span class=\"default\">hi there!</span></p>'\n            );\n        });\n\n        it(\"should ignore null or undefined rules\", function() {\n            var rules = {\n                Array: SimpleMarkdown.defaultRules.Array,\n                spoiler: {\n                    order: SimpleMarkdown.defaultRules.text.order - 1,\n                    match: function(source) {\n                        return /^\\[\\[((?:[^\\]]|\\][^\\]])+)\\]\\]/.exec(source);\n                    },\n                    parse: function(capture, parse) {\n                        return {content: parse(capture[1])};\n                    },\n                    html: function(node, output) {\n                        return '<span style=\"background: black;\">' +\n                            output(node.content) +\n                            '</span>';\n                    },\n                },\n                text: SimpleMarkdown.defaultRules.text,\n            };\n\n            var parse = SimpleMarkdown.parserFor(rules, {inline: true});\n            var output = SimpleMarkdown.outputFor(rules, 'html');\n\n            var parsed1 = parse('Hi this is a [[spoiler]]');\n            validateParse(parsed1, [\n                {type: 'text', content: 'Hi this is a '},\n                {\n                    type: 'spoiler', content: [\n                        {type: 'text', content: 'spoiler'},\n                    ]\n                },\n            ]);\n            var result1 = output(parsed1);\n            assert.strictEqual(result1,\n                'Hi this is a <span style=\"background: black;\">spoiler</span>'\n            );\n        });\n    });\n\n    describe(\"react output\", function() {\n        it(\"should sanitize dangerous links\", function() {\n            var html = htmlFromReactMarkdown(\n                \"[link](javascript:alert%28%27hi%27%29)\"\n            );\n            assert.strictEqual(html, \"<a>link</a>\");\n\n            var html2 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: javascript:alert('hi');\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var html3 = htmlFromReactMarkdown(\n                \"[link](data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==)\"\n            );\n            assert.strictEqual(html3, \"<a>link</a>\");\n\n            var html4 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==\\n\\n\"\n            );\n            assert.strictEqual(\n                html4,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var html5 = htmlFromReactMarkdown(\n                \"[link](vbscript:alert)\"\n            );\n            assert.strictEqual(html5, \"<a>link</a>\");\n\n            var html6 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: vbscript:alert\\n\\n\"\n            );\n            assert.strictEqual(\n                html6,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n        });\n\n        it(\"should not sanitize safe links\", function() {\n            var html = htmlFromReactMarkdown(\n                \"[link](https://www.google.com)\"\n            );\n            assert.strictEqual(\n                html,\n                \"<a href=\\\"https://www.google.com\\\">link</a>\"\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: https://www.google.com\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\">\" +\n                    \"<a href=\\\"https://www.google.com\\\">link</a>\" +\n                \"</div>\"\n            );\n        });\n\n        it(\"should output headings\", function() {\n            assertParsesToReact(\n                \"### Heading!\\n\\n\",\n                \"<h3>Heading!</h3>\"\n            );\n\n            assertParsesToReact(\n                \"## hi! ##\\n\\n\",\n                \"<h2>hi!</h2>\"\n            );\n\n            assertParsesToReact(\n                \"Yay!\\n====\\n\\n\",\n                \"<h1>Yay!</h1>\"\n            );\n\n            assertParsesToReact(\n                \"Success\\n---\\n\\n\",\n                \"<h2>Success</h2>\"\n            );\n        });\n\n        it(\"should output hrs\", function() {\n            assertParsesToReact(\n                \"-----\\n\\n\",\n                \"<hr/>\"\n            );\n            assertParsesToReact(\n                \" * * * \\n\\n\",\n                \"<hr/>\"\n            );\n            assertParsesToReact(\n                \"___\\n\\n\",\n                \"<hr/>\"\n            );\n        });\n\n        it(\"should output codeblocks\", function() {\n            var html = htmlFromReactMarkdown(\n                \"    var microwave = new TimeMachine();\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                \"<pre><code>var microwave = new TimeMachine();</code></pre>\"\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"~~~\\n\" +\n                \"var computer = new IBN(5100);\\n\" +\n                \"~~~\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<pre><code>var computer = new IBN(5100);</code></pre>\"\n            );\n\n            var html3 = htmlFromReactMarkdown(\n                \"```yavascript\\n\" +\n                \"var undefined = function() { return 5; }\" +\n                \"```\\n\\n\"\n            );\n            assert.strictEqual(\n                html3,\n                '<pre><code class=\"markdown-code-yavascript\">' +\n                'var undefined = function() { return 5; }' +\n                '</code></pre>'\n            );\n        });\n\n        it(\"should output blockQuotes\", function() {\n            assertParsesToReact(\n                \"> hi there this is a\\ntest\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n\n            assertParsesToReact(\n                \"> hi there this is a\\n> test\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n        });\n\n        it(\"should output lists\", function() {\n            assertParsesToReact(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n\n            assertParsesToReact(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\",\n                '<ol start=\"1\">' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ol>'\n            );\n\n            assertParsesToReact(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \"    * inner\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second <ul><li>inner</li></ul></li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n        });\n\n        it(\"should output tables\", function() {\n            assertParsesToReact(\n                \"h1 | h2 | h3\\n\" +\n                \"---|----|---\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToReact(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|----|----|----|\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToReact(\n                \"h1 | h2 | h3\\n\" +\n                \":--|:--:|--:\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr>' +\n                '<th style=\"text-align:left\" scope=\"col\">h1</th>' +\n                '<th style=\"text-align:center\" scope=\"col\">h2</th>' +\n                '<th style=\"text-align:right\" scope=\"col\">h3</th>' +\n                '</tr>' +\n                '</thead><tbody>' +\n                '<tr>' +\n                '<td style=\"text-align:left\">d1</td>' +\n                '<td style=\"text-align:center\">d2</td>' +\n                '<td style=\"text-align:right\">d3</td>' +\n                '</tr>' +\n                '</tbody></table>'\n            );\n        });\n\n        // TODO(aria): Figure out how to test the newline rule here\n\n        it(\"should output paragraphs\", function() {\n            var html = htmlFromReactMarkdown(\n                \"hi\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                '<div class=\"paragraph\">hi</div>'\n            );\n\n            var html2 = htmlFromReactMarkdown(\n                \"hi\\n\\n\" +\n                \"bye\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                '<div class=\"paragraph\">hi</div>' +\n                '<div class=\"paragraph\">bye</div>'\n            );\n        });\n\n        it(\"should output escaped text\", function() {\n            assertParsesToReact(\n                \"\\\\#escaping\\\\^symbols\\\\*is\\\\[legal](yes)\",\n                '#escaping^symbols*is[legal](yes)'\n            );\n        });\n\n        it(\"should output links\", function() {\n            assertParsesToReact(\n                \"<https://www.khanacademy.org>\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"<aria@khanacademy.org>\",\n                '<a href=\"mailto:aria@khanacademy.org\">' +\n                'aria@khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"https://www.khanacademy.org\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"[KA](https://www.khanacademy.org)\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>'\n            );\n\n            assertParsesToReact(\n                \"[KA][1]\\n\\n[1]: https://www.khanacademy.org\\n\\n\",\n                '<div class=\"paragraph\">' +\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>' +\n                '</div>'\n            );\n        });\n\n        it(\"should output strong\", function() {\n            assertParsesToReact(\n                \"**bold**\",\n                '<strong>bold</strong>'\n            );\n        });\n\n        it(\"should output u\", function() {\n            assertParsesToReact(\n                \"__underscore__\",\n                '<u>underscore</u>'\n            );\n        });\n\n        it(\"should output em\", function() {\n            assertParsesToReact(\n                \"*italics*\",\n                '<em>italics</em>'\n            );\n        });\n\n        it(\"should output simple combined bold/italics\", function() {\n            assertParsesToReact(\n                \"***bolditalics***\",\n                '<em><strong>bolditalics</strong></em>'\n            );\n            assertParsesToReact(\n                \"**bold *italics***\",\n                '<strong>bold <em>italics</em></strong>'\n            );\n        });\n\n        it(\"should output complex combined bold/italics\", function() {\n            assertParsesToReact(\n                \"***bold** italics*\",\n                '<em><strong>bold</strong> italics</em>'\n            );\n            assertParsesToReact(\n                \"*hi **there you***\",\n                '<em>hi <strong>there you</strong></em>'\n            );\n        });\n\n        it(\"should output del\", function() {\n            assertParsesToReact(\n                \"~~strikethrough~~\",\n                '<del>strikethrough</del>'\n            );\n        });\n\n        it(\"should output inline code\", function() {\n            assertParsesToReact(\n                \"here is some `inline code`.\",\n                'here is some <code>inline code</code>.'\n            );\n        });\n\n        it(\"should output text\", function() {\n            assertParsesToReact(\n                \"Yay text!\",\n                'Yay text!'\n            );\n        });\n\n        it(\"shouldn't split text into multiple spans\", function() {\n            var parsed = SimpleMarkdown.defaultInlineParse(\"hi, there!\");\n            var elements = SimpleMarkdown.defaultReactOutput(parsed);\n            assert.deepEqual(elements, [\"hi, there!\"]);\n        });\n\n        it(\"should join text nodes before outputting them\", function() {\n            var rules = Object.assign({}, SimpleMarkdown.defaultRules, {\n                text: Object.assign({}, SimpleMarkdown.defaultRules.text, {\n                    react: function(node, output, state) {\n                        return React.createElement(\n                            'span',\n                            {key: state.key, className: 'text'},\n                            node.content\n                        );\n                    }\n                }),\n            });\n\n            var output = SimpleMarkdown.outputFor(rules, 'react');\n\n            var parsed = SimpleMarkdown.defaultInlineParse(\n                \"Hi! You! Are! <3!\"\n            );\n\n            var html = reactToHtml(output(parsed));\n\n            assert.strictEqual(\n                html,\n                '<span class=\"text\">Hi! You! Are! &lt;3!</span>'\n            );\n        });\n    });\n\n    describe(\"html output\", function() {\n        it(\"should sanitize dangerous links\", function() {\n            var markdown = \"[link](javascript:alert%28%27hi%27%29)\";\n            assertParsesToHtml(\n                markdown,\n                \"<a>link</a>\"\n            );\n\n            var markdown2 = \"[link][1]\\n\\n\" +\n                \"[1]: javascript:alert('hi');\\n\\n\";\n            assertParsesToHtml(\n                markdown2,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var markdown3 = \"[link](data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==)\";\n            assertParsesToHtml(\n                markdown3,\n                \"<a>link</a>\"\n            );\n\n            var markdown4 = \"[link][1]\\n\\n\" +\n                \"[1]: data:text/html;base64,PHNjcmlwdD5hbGVydCgnaGknKTwvc2NyaXB0Pg==\\n\\n\";\n            assertParsesToHtml(\n                markdown4,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n\n            var markdown5 = \"[link](vbscript:alert)\";\n            assertParsesToHtml(\n                markdown5,\n                \"<a>link</a>\"\n            );\n\n            var markdown6 = \"[link][1]\\n\\n\" +\n                \"[1]: vbscript:alert\\n\\n\";\n            assertParsesToHtml(\n                markdown6,\n                \"<div class=\\\"paragraph\\\"><a>link</a></div>\"\n            );\n        });\n\n        it(\"should not sanitize safe links\", function() {\n            var html = htmlFromMarkdown(\n                \"[link](https://www.google.com)\"\n            );\n            assert.strictEqual(\n                html,\n                \"<a href=\\\"https://www.google.com\\\">link</a>\"\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"[link][1]\\n\\n\" +\n                \"[1]: https://www.google.com\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<div class=\\\"paragraph\\\">\" +\n                    \"<a href=\\\"https://www.google.com\\\">link</a>\" +\n                \"</div>\"\n            );\n        });\n\n        it(\"should output headings\", function() {\n            assertParsesToHtml(\n                \"### Heading!\\n\\n\",\n                \"<h3>Heading!</h3>\"\n            );\n\n            assertParsesToHtml(\n                \"## hi! ##\\n\\n\",\n                \"<h2>hi!</h2>\"\n            );\n\n            assertParsesToHtml(\n                \"Yay!\\n====\\n\\n\",\n                \"<h1>Yay!</h1>\"\n            );\n\n            assertParsesToHtml(\n                \"Success\\n---\\n\\n\",\n                \"<h2>Success</h2>\"\n            );\n        });\n\n        it(\"should output hrs\", function() {\n            assertParsesToHtml(\n                \"-----\\n\\n\",\n                \"<hr>\"\n            );\n            assertParsesToHtml(\n                \" * * * \\n\\n\",\n                \"<hr>\"\n            );\n            assertParsesToHtml(\n                \"___\\n\\n\",\n                \"<hr>\"\n            );\n        });\n\n        it(\"should output codeblocks\", function() {\n            var html = htmlFromMarkdown(\n                \"    var microwave = new TimeMachine();\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                \"<pre><code>var microwave = new TimeMachine();</code></pre>\"\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"~~~\\n\" +\n                \"var computer = new IBN(5100);\\n\" +\n                \"~~~\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                \"<pre><code>var computer = new IBN(5100);</code></pre>\"\n            );\n\n            var html3 = htmlFromMarkdown(\n                \"```yavascript\\n\" +\n                \"var undefined = function() { return 5; }\" +\n                \"```\\n\\n\"\n            );\n            assert.strictEqual(\n                html3,\n                '<pre><code class=\"markdown-code-yavascript\">' +\n                'var undefined = function() { return 5; }' +\n                '</code></pre>'\n            );\n        });\n\n        it(\"should output blockQuotes\", function() {\n            assertParsesToHtml(\n                \"> hi there this is a\\ntest\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n\n            assertParsesToHtml(\n                \"> hi there this is a\\n> test\\n\\n\",\n                '<blockquote><div class=\"paragraph\">' +\n                'hi there this is a test' +\n                '</div></blockquote>'\n            );\n        });\n\n        it(\"should output lists\", function() {\n            assertParsesToHtml(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n\n            assertParsesToHtml(\n                \"1. first\\n\" +\n                \"2. second\\n\" +\n                \"3. third\\n\\n\",\n                '<ol start=\"1\">' +\n                '<li>first</li>' +\n                '<li>second</li>' +\n                '<li>third</li>' +\n                '</ol>'\n            );\n\n            assertParsesToHtml(\n                \" * first\\n\" +\n                \" * second\\n\" +\n                \"    * inner\\n\" +\n                \" * third\\n\\n\",\n                '<ul>' +\n                '<li>first</li>' +\n                '<li>second <ul><li>inner</li></ul></li>' +\n                '<li>third</li>' +\n                '</ul>'\n            );\n        });\n\n        it(\"should output tables\", function() {\n            assertParsesToHtml(\n                \"h1 | h2 | h3\\n\" +\n                \"---|----|---\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToHtml(\n                \"| h1 | h2 | h3 |\\n\" +\n                \"|----|----|----|\\n\" +\n                \"| d1 | d2 | d3 |\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr><th scope=\"col\">h1</th><th scope=\"col\">h2</th><th scope=\"col\">h3</th></tr>' +\n                '</thead><tbody>' +\n                '<tr><td>d1</td><td>d2</td><td>d3</td></tr>' +\n                '</tbody></table>'\n            );\n\n            assertParsesToHtml(\n                \"h1 | h2 | h3\\n\" +\n                \":--|:--:|--:\\n\" +\n                \"d1 | d2 | d3\\n\" +\n                \"\\n\",\n                '<table><thead>' +\n                '<tr>' +\n                '<th style=\"text-align:left;\" scope=\"col\">h1</th>' +\n                '<th style=\"text-align:center;\" scope=\"col\">h2</th>' +\n                '<th style=\"text-align:right;\" scope=\"col\">h3</th>' +\n                '</tr>' +\n                '</thead><tbody>' +\n                '<tr>' +\n                '<td style=\"text-align:left;\">d1</td>' +\n                '<td style=\"text-align:center;\">d2</td>' +\n                '<td style=\"text-align:right;\">d3</td>' +\n                '</tr>' +\n                '</tbody></table>'\n            );\n        });\n\n        // TODO(aria): Figure out how to test the newline rule here\n\n        it(\"should output paragraphs\", function() {\n            var html = htmlFromMarkdown(\n                \"hi\\n\\n\"\n            );\n            assert.strictEqual(\n                html,\n                '<div class=\"paragraph\">hi</div>'\n            );\n\n            var html2 = htmlFromMarkdown(\n                \"hi\\n\\n\" +\n                \"bye\\n\\n\"\n            );\n            assert.strictEqual(\n                html2,\n                '<div class=\"paragraph\">hi</div>' +\n                '<div class=\"paragraph\">bye</div>'\n            );\n        });\n\n        it(\"should output escaped text\", function() {\n            assertParsesToHtml(\n                \"\\\\#escaping\\\\^symbols\\\\*is\\\\[legal](yes)\",\n                '#escaping^symbols*is[legal](yes)'\n            );\n        });\n\n        it(\"should output links\", function() {\n            assertParsesToHtml(\n                \"<https://www.khanacademy.org>\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"<aria@khanacademy.org>\",\n                '<a href=\"mailto:aria@khanacademy.org\">' +\n                'aria@khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"https://www.khanacademy.org\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'https://www.khanacademy.org' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"[KA](https://www.khanacademy.org)\",\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>'\n            );\n\n            assertParsesToHtml(\n                \"[KA][1]\\n\\n[1]: https://www.khanacademy.org\\n\\n\",\n                '<div class=\"paragraph\">' +\n                '<a href=\"https://www.khanacademy.org\">' +\n                'KA' +\n                '</a>' +\n                '</div>'\n            );\n        });\n\n        it(\"should output strong\", function() {\n            assertParsesToHtml(\n                \"**bold**\",\n                '<strong>bold</strong>'\n            );\n        });\n\n        it(\"should output u\", function() {\n            assertParsesToHtml(\n                \"__underscore__\",\n                '<u>underscore</u>'\n            );\n        });\n\n        it(\"should output em\", function() {\n            assertParsesToHtml(\n                \"*italics*\",\n                '<em>italics</em>'\n            );\n        });\n\n        it(\"should output simple combined bold/italics\", function() {\n            assertParsesToHtml(\n                \"***bolditalics***\",\n                '<em><strong>bolditalics</strong></em>'\n            );\n            assertParsesToHtml(\n                \"**bold *italics***\",\n                '<strong>bold <em>italics</em></strong>'\n            );\n        });\n\n        it(\"should output complex combined bold/italics\", function() {\n            assertParsesToHtml(\n                \"***bold** italics*\",\n                '<em><strong>bold</strong> italics</em>'\n            );\n            assertParsesToHtml(\n                \"*hi **there you***\",\n                '<em>hi <strong>there you</strong></em>'\n            );\n        });\n\n        it(\"should output del\", function() {\n            assertParsesToHtml(\n                \"~~strikethrough~~\",\n                '<del>strikethrough</del>'\n            );\n        });\n\n        it(\"should output inline code\", function() {\n            assertParsesToHtml(\n                \"here is some `inline code`.\",\n                'here is some <code>inline code</code>.'\n            );\n        });\n\n        it(\"should output text\", function() {\n            assertParsesToHtml(\n                \"Yay text!\",\n                'Yay text!'\n            );\n        });\n\n        it(\"shouldn't split text into multiple spans\", function() {\n            var parsed = SimpleMarkdown.defaultInlineParse(\"hi, there!\");\n            var elements = SimpleMarkdown.defaultHtmlOutput(parsed);\n            assert.deepEqual(elements, \"hi, there!\");\n        });\n    });\n\n    describe(\"convenience wrappers\", function() {\n        describe(\"markdownToReact\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var elems = SimpleMarkdown.markdownToReact(\n                    \"Hi there!\\n\\nYay!\"\n                );\n\n                assert.strictEqual(reactToHtml(elems),\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>'\n                );\n            });\n        });\n\n        describe(\"markdownToHtml\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var html = SimpleMarkdown.markdownToHtml(\n                    \"Hi there!\\n\\nYay!\"\n                );\n\n                assert.strictEqual(html,\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>'\n                );\n            });\n        });\n\n        describe(\"ReactMarkdown component\", function() {\n            it(\"should work on a basic 2 paragraph input\", function() {\n                var elem = React.createElement(SimpleMarkdown.ReactMarkdown, {\n                    source: \"Hi there!\\n\\nYay!\"\n                });\n\n                assert.strictEqual(reactToHtml(elem), '<div>' +\n                    '<div class=\"paragraph\">Hi there!</div>' +\n                    '<div class=\"paragraph\">Yay!</div>' +\n                    '</div>'\n                );\n            });\n        });\n    });\n\n    describe(\"helper functions\", function() {\n        describe(\"sanitizeText\", function() {\n            it(\"should escape basic html\", function() {\n                var result = SimpleMarkdown.sanitizeText(\n                    'hi <span class=\"my-class\">there</span>'\n                );\n                assert.strictEqual(\n                    result,\n                    'hi &lt;span class=&quot;my-class&quot;&gt;there&lt;/span&gt;'\n                );\n            });\n        });\n    });\n\n    describe(\"Exponential backtracking avoidance\", function() {\n        it(\"should parse long inlineCode quickly\", function() {\n            var source = '`' + Array(2000).join(' ');\n            var startTime = Date.now();\n            var parsed = inlineParse(source);\n            var duration = Date.now() - startTime;\n            assert.ok(duration < 10, \"Expected parsing to finish in <10ms, but was \" + duration + \"ms.\");\n        });\n    });\n});\n", "/* @flow */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n *\n * LICENSE (MIT):\n * New code copyright (c) 2014-2019 Khan Academy & Aria Buckles.\n *\n * Portions adapted from marked.js copyright (c) 2011-2014\n * Christopher Jeffrey (https://github.com/chjj/).\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*::\n// Flow Type Definitions:\n\ntype Capture =\n    Array<string> & {index: number} |\n    Array<string> & {index?: number};\n\ntype Attr = string | number | boolean;\n\ntype SingleASTNode = {\n    type: string,\n    [string]: any,\n};\n\ntype UnTypedASTNode = {\n    [string]: any\n};\n\ntype ASTNode = SingleASTNode | Array<SingleASTNode>;\n\ntype State = {[string]: any};\n\ntype ReactElement = React$Element<any>;\ntype ReactElements = React$Node;\n\ntype MatchFunction = (\n    source: string,\n    state: State,\n    prevCapture: string\n) => ?Capture;\n\ntype Parser = (\n    source: string,\n    state?: ?State\n) => Array<SingleASTNode>;\n\ntype ParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => (UnTypedASTNode | ASTNode);\n\ntype SingleNodeParseFunction = (\n    capture: Capture,\n    nestedParse: Parser,\n    state: State,\n) => UnTypedASTNode;\n\ntype Output<Result> = (\n    node: ASTNode,\n    state?: ?State\n) => Result;\n\ntype NodeOutput<Result> = (\n    node: SingleASTNode,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ArrayNodeOutput<Result> = (\n    node: Array<SingleASTNode>,\n    nestedOutput: Output<Result>,\n    state: State\n) => Result;\n\ntype ReactOutput = Output<ReactElements>;\ntype ReactNodeOutput = NodeOutput<ReactElements>;\ntype HtmlOutput = Output<string>;\ntype HtmlNodeOutput = NodeOutput<string>;\n\ntype ParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: ParseFunction,\n};\n\ntype SingleNodeParserRule = {\n    +order: number,\n    +match: MatchFunction,\n    +quality?: (capture: Capture, state: State, prevCapture: string) => number,\n    +parse: SingleNodeParseFunction,\n};\n\ntype ReactOutputRule = {\n    // we allow null because some rules are never output results, and that's\n    // legal as long as no parsers return an AST node matching that rule.\n    // We don't use ? because this makes it be explicitly defined as either\n    // a valid function or null, so it can't be forgotten.\n    +react: ReactNodeOutput | null,\n};\n\ntype HtmlOutputRule = {\n    +html: HtmlNodeOutput | null,\n};\n\ntype ArrayRule = {\n    +react?: ArrayNodeOutput<ReactElements>,\n    +html?: ArrayNodeOutput<string>,\n    +[string]: ArrayNodeOutput<any>,\n};\n\ntype ParserRules = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule,\n};\n\ntype OutputRules<Rule> = {\n    +Array?: ArrayRule,\n    +[type: string]: Rule\n};\ntype Rules<OutputRule> = {\n    +Array?: ArrayRule,\n    +[type: string]: ParserRule & OutputRule,\n}\ntype ReactRules = {\n    +Array?: {\n        +react: ArrayNodeOutput<ReactElements>,\n    },\n    +[type: string]: ParserRule & ReactOutputRule,\n};\ntype HtmlRules = {\n    +Array?: {\n        +html: ArrayNodeOutput<string>,\n    },\n    +[type: string]: ParserRule & HtmlOutputRule,\n};\n\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\ntype NonNullReactOutputRule = {\n    +react: ReactNodeOutput,\n};\ntype ElementReactOutputRule = {\n    +react: NodeOutput<ReactElement>,\n};\ntype TextReactOutputRule = {\n    +react: NodeOutput<string>,\n};\ntype NonNullHtmlOutputRule = {\n    +html: HtmlNodeOutput,\n};\n\ntype DefaultInRule = SingleNodeParserRule & ReactOutputRule & HtmlOutputRule;\ntype TextInOutRule = SingleNodeParserRule & TextReactOutputRule & NonNullHtmlOutputRule;\ntype LenientInOutRule = SingleNodeParserRule & NonNullReactOutputRule & NonNullHtmlOutputRule;\ntype DefaultInOutRule = SingleNodeParserRule & ElementReactOutputRule & NonNullHtmlOutputRule;\n\ntype DefaultRules = {\n    +Array: {\n        +react: ArrayNodeOutput<ReactElements>,\n        +html: ArrayNodeOutput<string>\n    },\n    +heading: DefaultInOutRule,\n    +nptable: DefaultInRule,\n    +lheading: DefaultInRule,\n    +hr: DefaultInOutRule,\n    +codeBlock: DefaultInOutRule,\n    +fence: DefaultInRule,\n    +blockQuote: DefaultInOutRule,\n    +list: DefaultInOutRule,\n    +def: LenientInOutRule,\n    +table: DefaultInOutRule,\n    +newline: TextInOutRule,\n    +paragraph: DefaultInOutRule,\n    +escape: DefaultInRule,\n    +autolink: DefaultInRule,\n    +mailto: DefaultInRule,\n    +url: DefaultInRule,\n    +link: DefaultInOutRule,\n    +image: DefaultInOutRule,\n    +reflink: DefaultInRule,\n    +refimage: DefaultInRule,\n    +em: DefaultInOutRule,\n    +strong: DefaultInOutRule,\n    +u: DefaultInOutRule,\n    +del: DefaultInOutRule,\n    +inlineCode: DefaultInOutRule,\n    +br: DefaultInOutRule,\n    +text: TextInOutRule,\n};\n\ntype RefNode = {\n    type: string,\n    content?: ASTNode,\n    target?: string,\n    title?: string,\n};\n\n// End Flow Definitions\n*/\n\n// Open IIFE, and immediately close it in flow\n(function() { /*::})*/\n\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n// Turn various crazy whitespace into easy to process things\nvar preprocess = function(source /* : string */) {\n    return source.replace(CR_NEWLINE_R, '\\n')\n            .replace(FORMFEED_R, '')\n            .replace(TAB_R, '    ');\n};\n\nvar populateInitialState = function(\n    givenState /* : ?State */,\n    defaultState /* : ?State */\n) /* : State */{\n    var state /* : State */ = givenState || {};\n    if (defaultState != null) {\n        for (var prop in defaultState) {\n            if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n                state[prop] = defaultState[prop];\n            }\n        }\n    }\n    return state;\n};\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nvar parserFor = function(rules /*: ParserRules */, defaultState /*: ?State */) {\n    // Sorts rules in order of increasing order, then\n    // ascending rule name in case of ties.\n    var ruleList = Object.keys(rules).filter(function(type) {\n        var rule = rules[type];\n        if (rule == null || rule.match == null) {\n            return false;\n        }\n        var order = rule.order;\n        if ((typeof order !== 'number' || !isFinite(order)) &&\n                typeof console !== 'undefined') {\n            console.warn(\n                \"simple-markdown: Invalid order for rule `\" + type + \"`: \" +\n                String(order)\n            );\n        }\n        return true;\n    });\n\n    ruleList.sort(function(typeA, typeB) {\n        var ruleA /* : ParserRule */ = /*::(*/ rules[typeA] /*:: :any)*/;\n        var ruleB /* : ParserRule */ = /*::(*/ rules[typeB] /*:: :any)*/;\n        var orderA = ruleA.order;\n        var orderB = ruleB.order;\n\n        // First sort based on increasing order\n        if (orderA !== orderB) {\n            return orderA - orderB;\n        }\n\n        var secondaryOrderA = ruleA.quality ? 0 : 1;\n        var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n        if (secondaryOrderA !== secondaryOrderB) {\n            return secondaryOrderA - secondaryOrderB;\n\n        // Then based on increasing unicode lexicographic ordering\n        } else if (typeA < typeB) {\n            return -1;\n        } else if (typeA > typeB) {\n            return 1;\n\n        } else {\n            // Rules should never have the same name,\n            // but this is provided for completeness.\n            return 0;\n        }\n    });\n\n    var latestState;\n    var nestedParse = function(source /* : string */, state /* : ?State */) {\n        var result = [];\n        state = state || latestState;\n        latestState = state;\n        // We store the previous capture so that match functions can\n        // use some limited amount of lookbehind. Lists use this to\n        // ensure they don't match arbitrary '- ' or '* ' in inline\n        // text (see the list rule for more information).\n        var prevCapture = \"\";\n        while (source) {\n            // store the best match, it's rule, and quality:\n            var ruleType = null;\n            var rule = null;\n            var capture = null;\n            var quality = NaN;\n\n            // loop control variables:\n            var i = 0;\n            var currRuleType = ruleList[0];\n            var currRule /* : ParserRule */ = /*::(*/ rules[currRuleType] /*:: : any)*/;\n\n            do {\n                var currOrder = currRule.order;\n                var currCapture = currRule.match(source, state, prevCapture);\n\n                if (currCapture) {\n                    var currQuality = currRule.quality ? currRule.quality(\n                        currCapture,\n                        state,\n                        prevCapture\n                    ) : 0;\n                    // This should always be true the first time because\n                    // the initial quality is NaN (that's why there's the\n                    // condition negation).\n                    if (!(currQuality <= quality)) {\n                        ruleType = currRuleType;\n                        rule = currRule;\n                        capture = currCapture;\n                        quality = currQuality;\n                    }\n                }\n\n                // Move on to the next item.\n                // Note that this makes `currRule` be the next item\n                i++;\n                currRuleType = ruleList[i];\n                currRule = /*::((*/ rules[currRuleType] /*:: : any) : ParserRule)*/;\n\n            } while (\n                // keep looping while we're still within the ruleList\n                currRule && (\n                    // if we don't have a match yet, continue\n                    !capture || (\n                        // or if we have a match, but the next rule is\n                        // at the same order, and has a quality measurement\n                        // functions, then this rule must have a quality\n                        // measurement function (since they are sorted before\n                        // those without), and we need to check if there is\n                        // a better quality match\n                        currRule.order === currOrder &&\n                        currRule.quality\n                    )\n                )\n            );\n\n            // TODO(aria): Write tests for these\n            // Lie to flow and say these checks always happen\n            if (state.disableErrorGuards !== true) { /*:: } { */\n                if (rule == null || capture == null /*:: || ruleType == null */) {\n                    throw new Error(\n                        \"Could not find a matching rule for the below \" +\n                        \"content. The rule with highest `order` should \" +\n                        \"always match content provided to it. Check \" +\n                        \"the definition of `match` for '\" +\n                        ruleList[ruleList.length - 1] +\n                        \"'. It seems to not match the following source:\\n\" +\n                        source\n                    );\n                }\n                if (capture.index !== 0 &&\n                    source.slice(0, capture[0].length) !== capture[0]\n                ) {\n                    throw new Error(\n                        \"`match` must return a capture starting at index 0 \" +\n                        \"(the current parse index). Did you forget a ^ at the \" +\n                        \"start of the RegExp?\"\n                    );\n                }\n            }\n\n            var parsed = rule.parse(capture, nestedParse, state);\n            // We maintain the same object here so that rules can\n            // store references to the objects they return and\n            // modify them later. (oops sorry! but this adds a lot\n            // of power--see reflinks.)\n            if (Array.isArray(parsed)) {\n                Array.prototype.push.apply(result, parsed);\n            } else {\n                // We also let rules override the default type of\n                // their parsed node if they would like to, so that\n                // there can be a single output function for all links,\n                // even if there are several rules to parse them.\n                if (parsed.type == null) {\n                    parsed.type = ruleType;\n                }\n                result.push(parsed);\n            }\n\n            prevCapture = capture[0];\n            source = source.substring(prevCapture.length);\n        }\n        return result;\n    };\n\n    var outerParse = function(source /* : string */, state /* : ?State */) {\n        latestState = populateInitialState(state, defaultState);\n        if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n            source = source + \"\\n\\n\";\n        }\n        return nestedParse(preprocess(source), latestState);\n    };\n    return outerParse;\n};\n\n// Creates a match function for an inline scoped element from a regex\nvar inlineRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return regex.exec(source);\n        } else {\n            return null;\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function for a block scoped element from a regex\nvar blockRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        if (state.inline) {\n            return null;\n        } else {\n            return regex.exec(source);\n        }\n    };\n    match.regex = regex;\n    return match;\n};\n\n// Creates a match function from a regex, ignoring block/inline scope\nvar anyScopeRegex = function(regex /* : RegExp */) {\n    var match /* : MatchFunction */ = function(source, state) {\n        return regex.exec(source);\n    };\n    match.regex = regex;\n    return match;\n};\n\nvar TYPE_SYMBOL =\n    (typeof Symbol === 'function' && Symbol.for &&\n     Symbol.for('react.element')) ||\n    0xeac7;\n\nvar reactElement = function(\n    type /* : string */,\n    key /* : string | null */,\n    props /* : { [string]: any } */\n) {\n    var element = {\n        $$typeof: TYPE_SYMBOL,\n        type: type,\n        key: key,\n        ref: null,\n        props: props,\n        _owner: null\n    };\n    return /* :: (( */ element /* :: : any ) : ReactElement) */;\n};\n\n// Returns a closed HTML tag.\n// tagName: Name of HTML tag (eg. \"em\" or \"a\")\n// content: Inner content of tag\n// attributes: Optional extra attributes of tag as an object of key-value pairs\n//   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n// isClosed: boolean that controls whether tag is closed or not (eg. img tags).\n//   defaults to true\nvar htmlTag = function(\n    tagName /* : string */,\n    content /* : string */,\n    attributes /* : ?{[any]: ?Attr} */,\n    isClosed /* : ?boolean */\n) {\n    attributes = attributes || {};\n    isClosed = typeof isClosed !== 'undefined' ? isClosed : true;\n\n    var attributeString = \"\";\n    for (var attr in attributes) {\n        var attribute = attributes[attr];\n        // Removes falsey attributes\n        if (Object.prototype.hasOwnProperty.call(attributes, attr) &&\n                attribute) {\n            attributeString += \" \" +\n                sanitizeText(attr) + '=\"' +\n                sanitizeText(attribute) + '\"';\n        }\n    }\n\n    var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n    if (isClosed) {\n        return unclosedTag + content + \"</\" + tagName + \">\";\n    } else {\n        return unclosedTag;\n    }\n};\n\nvar EMPTY_PROPS = {};\n\nvar sanitizeUrl = function(url /* : ?string */) {\n    if (url == null) {\n        return null;\n    }\n    try {\n        var prot = decodeURIComponent(url)\n            .replace(/[^A-Za-z0-9/:]/g, '')\n            .toLowerCase();\n        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n            return null;\n        }\n    } catch (e) {\n        // decodeURIComponent sometimes throws a URIError\n        // See `decodeURIComponent('a%AFc');`\n        // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n        return null;\n    }\n    return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '/': '&#x2F;',\n    \"`\": '&#96;'\n};\nvar sanitizeText = function(text /* : Attr */) {\n    return String(text).replace(SANITIZE_TEXT_R, function(chr) {\n        return SANITIZE_TEXT_CODES[chr];\n    });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function(rawUrlString /* : string */) {\n    return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n\n// Parse some content with the parser `parse`, with state.inline\n// set to true. Useful for block elements; not generally necessary\n// to be used by inline elements (where state.inline is already true.\nvar parseInline = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = true;\n    var result = parse(content, state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\nvar parseBlock = function(parse, content, state) {\n    var isCurrentlyInline = state.inline || false;\n    state.inline = false;\n    var result = parse(content + \"\\n\\n\", state);\n    state.inline = isCurrentlyInline;\n    return result;\n};\n\nvar parseCaptureInline = function(capture, parse, state) {\n    return {\n        content: parseInline(parse, capture[1], state)\n    };\n};\nvar ignoreCapture = function() { return {}; };\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\";\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX);\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nvar LIST_ITEM_R = new RegExp(\n    LIST_ITEM_PREFIX +\n    \"[^\\\\n]*(?:\\\\n\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\",\n    \"gm\"\n);\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ ( *` *) $|^ ( *`)|(` *) $/g;\n// recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/;\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nvar LIST_R = new RegExp(\n    \"^( *)(\" + LIST_BULLET + \") \" +\n    \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" +\n    \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    \"|\\\\s*\\n*$)\"\n);\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = (function() {\n    // predefine regexes so we don't have to create them inside functions\n    // sure, regex literals should be fast, even inside functions, but they\n    // aren't in all browsers.\n    var TABLE_BLOCK_TRIM = /\\n+/g;\n    var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n    var TABLE_CELL_END_TRIM = / *$/;\n    var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n    var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n    var TABLE_LEFT_ALIGN = /^ *:-+ *$/;\n\n    var parseTableAlignCapture = function(alignCapture) {\n        if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n            return \"right\";\n        } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n            return \"center\";\n        } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n            return \"left\";\n        } else {\n            return null;\n        }\n    };\n\n    var parseTableAlign = function(source, parse, state, trimEndSeparators) {\n        if (trimEndSeparators) {\n            source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n        }\n        var alignText = source.trim().split(\"|\");\n        return alignText.map(parseTableAlignCapture);\n    };\n\n    var parseTableRow = function(source, parse, state, trimEndSeparators) {\n        var prevInTable = state.inTable;\n        state.inTable = true;\n        var tableRow = parse(source.trim(), state);\n        state.inTable = prevInTable;\n\n        var cells = [[]];\n        tableRow.forEach(function(node, i) {\n            if (node.type === 'tableSeparator') {\n                // Filter out empty table separators at the start/end:\n                if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n                    // Split the current row:\n                    cells.push([]);\n                }\n            } else {\n                if (node.type === 'text' && (\n                    tableRow[i + 1] == null ||\n                    tableRow[i + 1].type === 'tableSeparator'\n                )) {\n                    node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n                }\n                cells[cells.length - 1].push(node);\n            }\n        });\n\n        return cells;\n    };\n\n    var parseTableCells = function(source, parse, state, trimEndSeparators) {\n        var rowsText = source.trim().split(\"\\n\");\n\n        return rowsText.map(function(rowText) {\n            return parseTableRow(rowText, parse, state, trimEndSeparators);\n        });\n    };\n\n    var parseTable = function(trimEndSeparators) {\n        return function(capture, parse, state) {\n            state.inline = true;\n            var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n            var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n            var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n            state.inline = false;\n\n            return {\n                type: \"table\",\n                header: header,\n                align: align,\n                cells: cells\n            };\n        };\n    };\n\n    return {\n        parseTable: parseTable(true),\n        parseNpTable: parseTable(false),\n        TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n        NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n    };\n})();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE =\n        \"\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function(capture, state, refNode /* : RefNode */) {\n    var ref = (capture[2] || capture[1])\n        .replace(/\\s+/g, ' ')\n        .toLowerCase();\n\n    // We store information about previously seen defs on\n    // state._defs (_ to deconflict with client-defined\n    // state). If the def for this reflink/refimage has\n    // already been seen, we can use its target/source\n    // and title here:\n    if (state._defs && state._defs[ref]) {\n        var def = state._defs[ref];\n        // `refNode` can be a link or an image. Both use\n        // target and title properties.\n        refNode.target = def.target;\n        refNode.title = def.title;\n    }\n\n    // In case we haven't seen our def yet (or if someone\n    // overwrites that def later on), we add this node\n    // to the list of ref nodes for that def. Then, when\n    // we find the def, we can modify this link/image AST\n    // node :).\n    // I'm sorry.\n    state._refs = state._refs || {};\n    state._refs[ref] = state._refs[ref] || [];\n    state._refs[ref].push(refNode);\n\n    return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules /* : DefaultRules */ = {\n    Array: {\n        react: function(arr, output, state) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++, key++) {\n                // `key` is our numerical `state.key`, which we increment for\n                // every output node, but don't change for joined text nodes.\n                // (i, however, must change for joined text nodes)\n                state.key = '' + i;\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result.push(output(node, state));\n            }\n\n            state.key = oldKey;\n            return result;\n        },\n        html: function(arr, output, state) {\n            var result = \"\";\n\n            // map output over the ast, except group any text\n            // nodes together into a single string output.\n            for (var i = 0, key = 0; i < arr.length; i++) {\n\n                var node = arr[i];\n                if (node.type === 'text') {\n                    node = { type: 'text', content: node.content };\n                    for (; i + 1 < arr.length && arr[i + 1].type === 'text'; i++) {\n                        node.content += arr[i + 1].content;\n                    }\n                }\n\n                result += output(node, state);\n            }\n            return result;\n        }\n    },\n    heading: {\n        order: currOrder++,\n        match: blockRegex(/^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                level: capture[1].length,\n                content: parseInline(parse, capture[2], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'h' + node.level,\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"h\" + node.level, output(node.content, state));\n        }\n    },\n    nptable: {\n        order: currOrder++,\n        match: blockRegex(TABLES.NPTABLE_REGEX),\n        parse: TABLES.parseNpTable,\n        react: null,\n        html: null\n    },\n    lheading: {\n        order: currOrder++,\n        match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"heading\",\n                level: capture[2] === '=' ? 1 : 2,\n                content: parseInline(parse, capture[1], state)\n            };\n        },\n        react: null,\n        html: null\n    },\n    hr: {\n        order: currOrder++,\n        match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'hr',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<hr>\";\n        }\n    },\n    codeBlock: {\n        order: currOrder++,\n        match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            var content = capture[0]\n                .replace(/^    /gm, '')\n                .replace(/\\n+$/, '');\n            return {\n                lang: undefined,\n                content: content\n            };\n        },\n        react: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            return reactElement(\n                'pre',\n                state.key,\n                {\n                    children: reactElement(\n                        'code',\n                        null,\n                        {\n                            className: className,\n                            children: node.content\n                        }\n                    )\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var className = node.lang ?\n                \"markdown-code-\" + node.lang :\n                undefined;\n\n            var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n                class: className\n            });\n            return htmlTag(\"pre\", codeBlock);\n        }\n    },\n    fence: {\n        order: currOrder++,\n        match: blockRegex(/^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"codeBlock\",\n                lang: capture[2] || undefined,\n                content: capture[3]\n            };\n        },\n        react: null,\n        html: null\n    },\n    blockQuote: {\n        order: currOrder++,\n        match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n        parse: function(capture, parse, state) {\n            var content = capture[0].replace(/^ *> ?/gm, '');\n            return {\n                content: parse(content, state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'blockquote',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"blockquote\", output(node.content, state));\n        }\n    },\n    list: {\n        order: currOrder++,\n        match: function(source, state, prevCapture) {\n            // We only want to break into a list if we are at the start of a\n            // line. This is to avoid parsing \"hi * there\" with \"* there\"\n            // becoming a part of a list.\n            // You might wonder, \"but that's inline, so of course it wouldn't\n            // start a list?\". You would be correct! Except that some of our\n            // lists can be inline, because they might be inside another list,\n            // in which case we can parse with inline scope, but need to allow\n            // nested lists inside this inline scope.\n            var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCapture);\n            var isListBlock = state._list || !state.inline;\n\n            if (isStartOfLineCapture && isListBlock) {\n                source = isStartOfLineCapture[1] + source;\n                var res = LIST_R.exec(source);\n                return LIST_R.exec(source);\n            } else {\n                return null;\n            }\n        },\n        parse: function(capture, parse, state) {\n            var bullet = capture[2];\n            var ordered = bullet.length > 1;\n            var start = ordered ? +bullet : undefined;\n            var items = capture[0]\n                .replace(LIST_BLOCK_END_R, \"\\n\")\n                .match(LIST_ITEM_R);\n\n            // We know this will match here, because of how the regexes are\n            // defined\n            /*:: items = ((items : any) : Array<string>) */\n\n            var lastItemWasAParagraph = false;\n            var itemContent = items.map(function(item, i) {\n                // We need to see how far indented this item is:\n                var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n                var space = prefixCapture ? prefixCapture[0].length : 0;\n                // And then we construct a regex to \"unindent\" the subsequent\n                // lines of the items by that amount:\n                var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\");\n\n                // Before processing the item, we need a couple things\n                var content = item\n                         // remove indents on trailing lines:\n                        .replace(spaceRegex, '')\n                         // remove the bullet:\n                        .replace(LIST_ITEM_PREFIX_R, '');\n\n                // I'm not sur4 why this is necessary again?\n                /*:: items = ((items : any) : Array<string>) */\n\n                // Handling \"loose\" lists, like:\n                //\n                //  * this is wrapped in a paragraph\n                //\n                //  * as is this\n                //\n                //  * as is this\n                var isLastItem = (i === items.length - 1);\n                var containsBlocks = content.indexOf(\"\\n\\n\") !== -1;\n\n                // Any element in a list is a block if it contains multiple\n                // newlines. The last element in the list can also be a block\n                // if the previous item in the list was a block (this is\n                // because non-last items in the list can end with \\n\\n, but\n                // the last item can't, so we just \"inherit\" this property\n                // from our previous element).\n                var thisItemIsAParagraph = containsBlocks ||\n                        (isLastItem && lastItemWasAParagraph);\n                lastItemWasAParagraph = thisItemIsAParagraph;\n\n                // backup our state for restoration afterwards. We're going to\n                // want to set state._list to true, and state.inline depending\n                // on our list's looseness.\n                var oldStateInline = state.inline;\n                var oldStateList = state._list;\n                state._list = true;\n\n                // Parse inline if we're in a tight list, or block if we're in\n                // a loose list.\n                var adjustedContent;\n                if (thisItemIsAParagraph) {\n                    state.inline = false;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n                } else {\n                    state.inline = true;\n                    adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n                }\n\n                var result = parse(adjustedContent, state);\n\n                // Restore our state before returning\n                state.inline = oldStateInline;\n                state._list = oldStateList;\n                return result;\n            });\n\n            return {\n                ordered: ordered,\n                start: start,\n                items: itemContent\n            };\n        },\n        react: function(node, output, state) {\n            var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n\n            return reactElement(\n                ListWrapper,\n                state.key,\n                {\n                    start: node.start,\n                    children: node.items.map(function(item, i) {\n                        return reactElement(\n                            'li',\n                            '' + i,\n                            {\n                                children: output(item, state)\n                            }\n                        );\n                    })\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var listItems = node.items.map(function(item) {\n                return htmlTag(\"li\", output(item, state));\n            }).join(\"\");\n\n            var listTag = node.ordered ? \"ol\" : \"ul\";\n            var attributes = {\n                start: node.start\n            };\n            return htmlTag(listTag, listItems, attributes);\n        }\n    },\n    def: {\n        order: currOrder++,\n        // TODO(aria): This will match without a blank line before the next\n        // block element, which is inconsistent with most of the rest of\n        // simple-markdown.\n        match: blockRegex(\n            /^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/\n        ),\n        parse: function(capture, parse, state) {\n            var def = capture[1]\n                .replace(/\\s+/g, ' ')\n                .toLowerCase();\n            var target = capture[2];\n            var title = capture[3];\n\n            // Look for previous links/images using this def\n            // If any links/images using this def have already been declared,\n            // they will have added themselves to the state._refs[def] list\n            // (_ to deconflict with client-defined state). We look through\n            // that list of reflinks for this def, and modify those AST nodes\n            // with our newly found information now.\n            // Sorry :(.\n            if (state._refs && state._refs[def]) {\n                // `refNode` can be a link or an image\n                state._refs[def].forEach(function(refNode) {\n                    refNode.target = target;\n                    refNode.title = title;\n                });\n            }\n\n            // Add this def to our map of defs for any future links/images\n            // In case we haven't found any or all of the refs referring to\n            // this def yet, we add our def to the table of known defs, so\n            // that future reflinks can modify themselves appropriately with\n            // this information.\n            state._defs = state._defs || {};\n            state._defs[def] = {\n                target: target,\n                title: title,\n            };\n\n            // return the relevant parsed information\n            // for debugging only.\n            return {\n                def: def,\n                target: target,\n                title: title,\n            };\n        },\n        react: function() { return null; },\n        html: function() { return \"\"; }\n    },\n    table: {\n        order: currOrder++,\n        match: blockRegex(TABLES.TABLE_REGEX),\n        parse: TABLES.parseTable,\n        react: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? {} : {\n                    textAlign: node.align[colIndex]\n                };\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return reactElement(\n                    'th',\n                    '' + i,\n                    {\n                        style: getStyle(i),\n                        scope: 'col',\n                        children: output(content, state)\n                    }\n                );\n            });\n\n            var rows = node.cells.map(function(row, r) {\n                return reactElement(\n                    'tr',\n                    '' + r,\n                    {\n                        children: row.map(function(content, c) {\n                            return reactElement(\n                                'td',\n                                '' + c,\n                                {\n                                    style: getStyle(c),\n                                    children: output(content, state)\n                                }\n                            );\n                        })\n                    }\n                );\n            });\n\n            return reactElement(\n                'table',\n                state.key,\n                {\n                    children: [reactElement(\n                        'thead',\n                        'thead',\n                        {\n                            children: reactElement(\n                                'tr',\n                                null,\n                                {\n                                    children: headers\n                                }\n                            )\n                        }\n                    ), reactElement(\n                        'tbody',\n                        'tbody',\n                        {\n                            children: rows\n                        }\n                    )]\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var getStyle = function(colIndex) {\n                return node.align[colIndex] == null ? \"\" :\n                    \"text-align:\" + node.align[colIndex] + \";\";\n            };\n\n            var headers = node.header.map(function(content, i) {\n                return htmlTag(\"th\", output(content, state),\n                    { style: getStyle(i), scope: \"col\" });\n            }).join(\"\");\n\n            var rows = node.cells.map(function(row) {\n                var cols = row.map(function(content, c) {\n                    return htmlTag(\"td\", output(content, state),\n                        { style: getStyle(c) });\n                }).join(\"\");\n\n                return htmlTag(\"tr\", cols);\n            }).join(\"\");\n\n            var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n            var tbody = htmlTag(\"tbody\", rows);\n\n            return htmlTag(\"table\", thead + tbody);\n        }\n    },\n    newline: {\n        order: currOrder++,\n        match: blockRegex(/^(?:\\n *)*\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) { return \"\\n\"; },\n        html: function(node, output, state) { return \"\\n\"; }\n    },\n    paragraph: {\n        order: currOrder++,\n        match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'div',\n                state.key,\n                {\n                    className: 'paragraph',\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                class: 'paragraph'\n            };\n            return htmlTag(\"div\", output(node.content, state), attributes);\n        }\n    },\n    escape: {\n        order: currOrder++,\n        // We don't allow escaping numbers, letters, or spaces here so that\n        // backslashes used in plain text still get rendered. But allowing\n        // escaping anything else provides a very flexible escape mechanism,\n        // regardless of how this grammar is extended.\n        match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"text\",\n                content: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    tableSeparator: {\n        order: currOrder++,\n        match: function(source, state) {\n            if (!state.inTable) {\n                return null;\n            }\n            return /^ *\\| */.exec(source);\n        },\n        parse: function() {\n            return { type: 'tableSeparator' };\n        },\n        // These shouldn't be reached, but in case they are, be reasonable:\n        react: function() { return ' | '; },\n        html: function() { return ' &vert; '; },\n    },\n    autolink: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+:\\/[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1]\n            };\n        },\n        react: null,\n        html: null\n    },\n    mailto: {\n        order: currOrder++,\n        match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n        parse: function(capture, parse, state) {\n            var address = capture[1];\n            var target = capture[1];\n\n            // Check for a `mailto:` already existing in the link:\n            if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n                target = \"mailto:\" + target;\n            }\n\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: address\n                }],\n                target: target\n            };\n        },\n        react: null,\n        html: null\n    },\n    url: {\n        order: currOrder++,\n        match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n        parse: function(capture, parse, state) {\n            return {\n                type: \"link\",\n                content: [{\n                    type: \"text\",\n                    content: capture[1]\n                }],\n                target: capture[1],\n                title: undefined\n            };\n        },\n        react: null,\n        html: null\n    },\n    link: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var link ={\n                content: parse(capture[1], state),\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return link;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'a',\n                state.key,\n                {\n                    href: sanitizeUrl(node.target),\n                    title: node.title,\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                href: sanitizeUrl(node.target),\n                title: node.title\n            };\n\n            return htmlTag(\"a\", output(node.content, state), attributes);\n        }\n    },\n    image: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\"\n        )),\n        parse: function(capture, parse, state) {\n            var image = {\n                alt: capture[1],\n                target: unescapeUrl(capture[2]),\n                title: capture[3]\n            };\n            return image;\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'img',\n                state.key,\n                {\n                    src: sanitizeUrl(node.target),\n                    alt: node.alt,\n                    title: node.title\n                }\n            );\n        },\n        html: function(node, output, state) {\n            var attributes = {\n                src: sanitizeUrl(node.target),\n                alt: node.alt,\n                title: node.title\n            };\n\n            return htmlTag(\"img\", \"\", attributes, false);\n        }\n    },\n    reflink: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"link\",\n                content: parse(capture[1], state)\n            });\n        },\n        react: null,\n        html: null\n    },\n    refimage: {\n        order: currOrder++,\n        match: inlineRegex(new RegExp(\n            // The first [part] of the link\n            \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" +\n            // The [ref] target of the link\n            \"\\\\s*\\\\[([^\\\\]]*)\\\\]\"\n        )),\n        parse: function(capture, parse, state) {\n            return parseRef(capture, state, {\n                type: \"image\",\n                alt: capture[1]\n            });\n        },\n        react: null,\n        html: null\n    },\n    em: {\n        order: currOrder /* same as strong/u */,\n        match: inlineRegex(\n            new RegExp(\n                // only match _s surrounding words.\n                \"^\\\\b_\" +\n                \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" +\n                \"\\\\b\" +\n                // Or match *s:\n                \"|\" +\n                // Only match *s that are followed by a non-space:\n                \"^\\\\*(?=\\\\S)(\" +\n                // Match at least one of:\n                \"(?:\" +\n                  //  - `**`: so that bolds inside italics don't close the\n                  //          italics\n                  \"\\\\*\\\\*|\" +\n                  //  - escape sequence: so escaped *s don't close us\n                  \"\\\\\\\\[\\\\s\\\\S]|\" +\n                  //  - whitespace: followed by a non-* (we don't\n                  //          want ' *' to close an italics--it might\n                  //          start a list)\n                  \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" +\n                  //  - non-whitespace, non-*, non-backslash characters\n                  \"[^\\\\s\\\\*\\\\\\\\]\" +\n                \")+?\" +\n                // followed by a non-space, non-* then *\n                \")\\\\*(?!\\\\*)\"\n            )\n        ),\n        quality: function(capture) {\n            // precedence by length, `em` wins ties:\n            return capture[0].length + 0.2;\n        },\n        parse: function(capture, parse, state) {\n            return {\n                content: parse(capture[2] || capture[1], state)\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'em',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"em\", output(node.content, state));\n        }\n    },\n    strong: {\n        order: currOrder /* same as em */,\n        match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n        quality: function(capture) {\n            // precedence by length, wins ties vs `u`:\n            return capture[0].length + 0.1;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'strong',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"strong\", output(node.content, state));\n        }\n    },\n    u: {\n        order: currOrder++ /* same as em&strong; increment for next rule */,\n        match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n        quality: function(capture) {\n            // precedence by length, loses all ties\n            return capture[0].length;\n        },\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'u',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"u\", output(node.content, state));\n        }\n    },\n    del: {\n        order: currOrder++,\n        match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s\\\\~]|\\s+(?!~~))+?)~~/),\n        parse: parseCaptureInline,\n        react: function(node, output, state) {\n            return reactElement(\n                'del',\n                state.key,\n                {\n                    children: output(node.content, state)\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"del\", output(node.content, state));\n        }\n    },\n    inlineCode: {\n        order: currOrder++,\n        match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n            };\n        },\n        react: function(node, output, state) {\n            return reactElement(\n                'code',\n                state.key,\n                {\n                    children: node.content\n                }\n            );\n        },\n        html: function(node, output, state) {\n            return htmlTag(\"code\", sanitizeText(node.content));\n        }\n    },\n    br: {\n        order: currOrder++,\n        match: anyScopeRegex(/^ {2,}\\n/),\n        parse: ignoreCapture,\n        react: function(node, output, state) {\n            return reactElement(\n                'br',\n                state.key,\n                EMPTY_PROPS\n            );\n        },\n        html: function(node, output, state) {\n            return \"<br>\";\n        }\n    },\n    text: {\n        order: currOrder++,\n        // Here we look for anything followed by non-symbols,\n        // double newlines, or double-space-newlines\n        // We break on any symbol characters so that this grammar\n        // is easy to extend without needing to modify this regex\n        match: anyScopeRegex(\n            /^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/\n        ),\n        parse: function(capture, parse, state) {\n            return {\n                content: capture[0]\n            };\n        },\n        react: function(node, output, state) {\n            return node.content;\n        },\n        html: function(node, output, state) {\n            return sanitizeText(node.content);\n        }\n    }\n};\n\nvar ruleOutput = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */\n) {\n    if (!property && typeof console !== \"undefined\") {\n        console.warn(\"simple-markdown ruleOutput should take 'react' or \" +\n            \"'html' as the second argument.\"\n        );\n    }\n\n    var nestedRuleOutput /* : NodeOutput<any> */ = function(\n        ast /* : SingleASTNode */,\n        outputFunc /* : NodeOutput<any> */,\n        state /* : State */\n    ) {\n        return rules[ast.type][property](ast, outputFunc, state);\n    };\n    return nestedRuleOutput;\n};\n\nvar reactFor = function(outputFunc /* : ReactNodeOutput */) /* : ReactOutput */ {\n    var nestedOutput /* : ReactOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            var oldKey = state.key;\n            var result /* : Array<ReactElements> */ = [];\n\n            // map nestedOutput over the ast, except group any text\n            // nodes together into a single string output.\n            var lastResult = null;\n            for (var i = 0; i < ast.length; i++) {\n                state.key = '' + i;\n                var nodeOut = nestedOutput(ast[i], state);\n                if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n                    lastResult = lastResult + nodeOut;\n                    result[result.length - 1] = lastResult;\n                } else {\n                    result.push(nodeOut);\n                    lastResult = nodeOut;\n                }\n            }\n\n            state.key = oldKey;\n            return result;\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar htmlFor = function(outputFunc /* : HtmlNodeOutput */) /* : HtmlOutput */ {\n    var nestedOutput /* : HtmlOutput */ = function(ast, state) {\n        state = state || {};\n        if (Array.isArray(ast)) {\n            return ast.map(function(node) {\n                return nestedOutput(node, state);\n            }).join(\"\");\n        } else {\n            return outputFunc(ast, nestedOutput, state);\n        }\n    };\n    return nestedOutput;\n};\n\nvar outputFor = function/* :: <Rule : Object> */(\n    rules /* : OutputRules<Rule> */,\n    property /* : $Keys<Rule> */,\n    defaultState /* : ?State */\n) {\n    if (!property) {\n        throw new Error('simple-markdown: outputFor: `property` must be ' +\n            'defined. ' +\n            'if you just upgraded, you probably need to replace `outputFor` ' +\n            'with `reactFor`'\n        );\n    }\n\n    var latestState;\n    var arrayRule = rules.Array || defaultRules.Array;\n    var nestedOutput /* : Output<any> */ = function(ast, state) {\n        state = state || latestState;\n        latestState = state;\n        if (Array.isArray(ast)) {\n            return arrayRule[property](ast, nestedOutput, state);\n        } else {\n            return rules[ast.type][property](ast, nestedOutput, state);\n        }\n    };\n\n    var outerOutput = function(ast, state) {\n        latestState = populateInitialState(state, defaultState);\n        return nestedOutput(ast, latestState);\n    };\n    return outerOutput;\n};\n\nvar defaultRawParse = parserFor(defaultRules);\nvar defaultBlockParse = function(source, state) {\n    state = state || {};\n    state.inline = false;\n    return defaultRawParse(source, state);\n};\nvar defaultInlineParse = function(source, state) {\n    state = state || {};\n    state.inline = true;\n    return defaultRawParse(source, state);\n};\nvar defaultImplicitParse = function(source, state) {\n    var isBlock = BLOCK_END_R.test(source);\n    state = state || {};\n    state.inline = !isBlock;\n    return defaultRawParse(source, state);\n};\n\nvar defaultReactOutput /* : ReactOutput */ = outputFor(defaultRules, \"react\");\nvar defaultHtmlOutput /* : HtmlOutput */ = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function(source, state) /* : ReactElements */ {\n    return defaultReactOutput(defaultBlockParse(source, state), state);\n};\nvar markdownToHtml = function(source, state) /* : string */ {\n    return defaultHtmlOutput(defaultBlockParse(source, state), state);\n};\n\nvar ReactMarkdown = function(props) {\n    var divProps = {};\n\n    for (var prop in props) {\n        if (prop !== 'source' &&\n            Object.prototype.hasOwnProperty.call(props, prop)\n        ) {\n            divProps[prop] = props[prop];\n        }\n    }\n    divProps.children = markdownToReact(props.source);\n\n    return reactElement(\n        'div',\n        null,\n        divProps\n    );\n};\n\n\n/*:: // Flow exports:\ntype Exports = {\n    +defaultRules: DefaultRules,\n    +parserFor: (rules: ParserRules, defaultState?: ?State) => Parser,\n    +outputFor: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>, defaultState?: ?State) => Output<any>,\n\n    +ruleOutput: <Rule : Object>(rules: OutputRules<Rule>, param: $Keys<Rule>) => NodeOutput<any>,\n    +reactFor: (ReactNodeOutput) => ReactOutput,\n    +htmlFor: (HtmlNodeOutput) => HtmlOutput,\n\n    +inlineRegex: (regex: RegExp) => MatchFunction,\n    +blockRegex: (regex: RegExp) => MatchFunction,\n    +anyScopeRegex: (regex: RegExp) => MatchFunction,\n    +parseInline: (parse: Parser, content: string, state: State) => ASTNode,\n    +parseBlock: (parse: Parser, content: string, state: State) => ASTNode,\n\n    +markdownToReact: (source: string, state?: ?State) => ReactElements,\n    +markdownToHtml: (source: string, state?: ?State) => string,\n    +ReactMarkdown: (props: { source: string, [string]: any }) => ReactElement,\n\n    +defaultRawParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultBlockParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultInlineParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n    +defaultImplicitParse: (source: string, state?: ?State) => Array<SingleASTNode>,\n\n    +defaultReactOutput: ReactOutput,\n    +defaultHtmlOutput: HtmlOutput,\n\n    +preprocess: (source: string) => string,\n    +sanitizeText: (text: Attr) => string,\n    +sanitizeUrl: (url: ?string) => ?string,\n    +unescapeUrl: (url: string) => string,\n    +htmlTag: (tagName: string, content: string, attributes: ?{[any]: ?Attr}, isClosed: ?boolean) => string,\n    +reactElement: (type: string, key: string | null, props: { [string]: any }) => ReactElement,\n};\n\nexport type {\n    // Hopefully you shouldn't have to use these, but they're here if you need!\n    // Top-level API:\n    State,\n    Parser,\n    Output,\n    ReactOutput,\n    HtmlOutput,\n\n    // Most of the following types should be considered experimental and\n    // subject to change or change names. Again, they shouldn't be necessary,\n    // but if they are I'd love to hear how so I can better support them!\n\n    // Individual Rule fields:\n    Capture,\n    MatchFunction,\n    ParseFunction,\n    NodeOutput,\n    ArrayNodeOutput,\n    ReactNodeOutput,\n\n    // Single rules:\n    ParserRule,\n    ReactOutputRule,\n    HtmlOutputRule,\n\n    // Sets of rules:\n    ParserRules,\n    OutputRules,\n    Rules,\n    ReactRules,\n    HtmlRules,\n};\n*/\n\nvar SimpleMarkdown /* : Exports */ = {\n    defaultRules: defaultRules,\n    parserFor: parserFor,\n    outputFor: outputFor,\n\n    inlineRegex: inlineRegex,\n    blockRegex: blockRegex,\n    anyScopeRegex: anyScopeRegex,\n    parseInline: parseInline,\n    parseBlock: parseBlock,\n\n    // default wrappers:\n    markdownToReact: markdownToReact,\n    markdownToHtml: markdownToHtml,\n    ReactMarkdown: ReactMarkdown,\n\n    defaultBlockParse: defaultBlockParse,\n    defaultInlineParse: defaultInlineParse,\n    defaultImplicitParse: defaultImplicitParse,\n\n    defaultReactOutput: defaultReactOutput,\n    defaultHtmlOutput: defaultHtmlOutput,\n\n    preprocess: preprocess,\n    sanitizeText: sanitizeText,\n    sanitizeUrl: sanitizeUrl,\n    unescapeUrl: unescapeUrl,\n    htmlTag: htmlTag,\n    reactElement: reactElement,\n\n    // deprecated:\n    defaultRawParse: defaultRawParse,\n    ruleOutput: ruleOutput,\n    reactFor: reactFor,\n    htmlFor: htmlFor,\n\n    defaultParse: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultParse is deprecated, please use `defaultImplicitParse`');\n        }\n        return defaultImplicitParse.apply(null, arguments);\n    },\n    defaultOutput: function() {\n        if (typeof console !== 'undefined') {\n            console.warn('defaultOutput is deprecated, please use `defaultReactOutput`');\n        }\n        return defaultReactOutput.apply(null, arguments);\n    }\n};\n\nif (typeof module !== \"undefined\" && module.exports) {\n    module.exports = SimpleMarkdown;\n} else if (typeof global !== \"undefined\") {\n    global.SimpleMarkdown = SimpleMarkdown;\n} else {\n    window.SimpleMarkdown = SimpleMarkdown;\n}\n/*:: module.exports = SimpleMarkdown; */\n\n// Close the IIFE\n/*:: (function() { */})();\n\n"], "filenames": ["__tests__/simple-markdown-test.js", "simple-markdown.js"], "buggy_code_start_loc": [550, 642], "buggy_code_end_loc": [550, 1588], "fixing_code_start_loc": [551, 643], "fixing_code_end_loc": [571, 1589], "type": "CWE-1333", "message": "A vulnerability has been found in simple-markdown 0.5.1 and classified as problematic. Affected by this vulnerability is an unknown functionality of the file simple-markdown.js. The manipulation leads to inefficient regular expression complexity. The attack can be launched remotely. Upgrading to version 0.5.2 is able to address this issue. The name of the patch is 89797fef9abb4cab2fb76a335968266a92588816. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220639.", "other": {"cve": {"id": "CVE-2019-25103", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-12T15:15:10.610", "lastModified": "2023-02-24T06:23:30.793", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in simple-markdown 0.5.1 and classified as problematic. Affected by this vulnerability is an unknown functionality of the file simple-markdown.js. The manipulation leads to inefficient regular expression complexity. The attack can be launched remotely. Upgrading to version 0.5.2 is able to address this issue. The name of the patch is 89797fef9abb4cab2fb76a335968266a92588816. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220639."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:khanacademy:simple-markdown:0.5.1:*:*:*:*:node.js:*:*", "matchCriteriaId": "38F52322-21CB-4B8D-81C1-BFABDC464BA4"}]}]}], "references": [{"url": "https://github.com/ariabuckles/simple-markdown/commit/89797fef9abb4cab2fb76a335968266a92588816", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/ariabuckles/simple-markdown/releases/tag/0.5.2", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220639", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220639", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ariabuckles/simple-markdown/commit/89797fef9abb4cab2fb76a335968266a92588816"}}