{"buggy_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom typing import Any, Dict, Union\n\nimport logging\nimport cherrypy\n\nfrom . import Controller, BaseController, Endpoint, ENDPOINT_MAP, \\\n    allow_empty_body\nfrom .. import mgr\n\nfrom ..tools import str_to_bool\n\n\nlogger = logging.getLogger('controllers.docs')\n\n\n@Controller('/docs', secure=False)\nclass Docs(BaseController):\n\n    @classmethod\n    def _gen_tags(cls, all_endpoints):\n        \"\"\" Generates a list of all tags and corresponding descriptions. \"\"\"\n        # Scenarios to consider:\n        #     * Intentionally make up a new tag name at controller => New tag name displayed.\n        #     * Misspell or make up a new tag name at endpoint => Neither tag or endpoint displayed.\n        #     * Misspell tag name at controller (when referring to another controller) =>\n        #       Tag displayed but no endpoints assigned\n        #     * Description for a tag added at multiple locations => Only one description displayed.\n        list_of_ctrl = set()\n        for endpoints in ENDPOINT_MAP.values():\n            for endpoint in endpoints:\n                if endpoint.is_api or all_endpoints:\n                    list_of_ctrl.add(endpoint.ctrl)\n\n        tag_map: Dict[str, str] = {}\n        for ctrl in list_of_ctrl:\n            tag_name = ctrl.__name__\n            tag_descr = \"\"\n            if hasattr(ctrl, 'doc_info'):\n                if ctrl.doc_info['tag']:\n                    tag_name = ctrl.doc_info['tag']\n                tag_descr = ctrl.doc_info['tag_descr']\n            if tag_name not in tag_map or not tag_map[tag_name]:\n                tag_map[tag_name] = tag_descr\n\n        tags = [{'name': k, 'description': v if v else \"*No description available*\"}\n                for k, v in tag_map.items()]\n        tags.sort(key=lambda e: e['name'])\n        return tags\n\n    @classmethod\n    def _get_tag(cls, endpoint):\n        \"\"\" Returns the name of a tag to assign to a path. \"\"\"\n        ctrl = endpoint.ctrl\n        func = endpoint.func\n        tag = ctrl.__name__\n        if hasattr(func, 'doc_info') and func.doc_info['tag']:\n            tag = func.doc_info['tag']\n        elif hasattr(ctrl, 'doc_info') and ctrl.doc_info['tag']:\n            tag = ctrl.doc_info['tag']\n        return tag\n\n    @classmethod\n    def _gen_type(cls, param):\n        # pylint: disable=too-many-return-statements\n        \"\"\"\n        Generates the type of parameter based on its name and default value,\n        using very simple heuristics.\n        Used if type is not explicitly defined.\n        \"\"\"\n        param_name = param['name']\n        def_value = param['default'] if 'default' in param else None\n        if param_name.startswith(\"is_\"):\n            return \"boolean\"\n        if \"size\" in param_name:\n            return \"integer\"\n        if \"count\" in param_name:\n            return \"integer\"\n        if \"num\" in param_name:\n            return \"integer\"\n        if isinstance(def_value, bool):\n            return \"boolean\"\n        if isinstance(def_value, int):\n            return \"integer\"\n        return \"string\"\n\n    @classmethod\n    # isinstance doesn't work: input is always <type 'type'>.\n    def _type_to_str(cls, type_as_type):\n        \"\"\" Used if type is explicitly defined. \"\"\"\n        if type_as_type is str:\n            type_as_str = 'string'\n        elif type_as_type is int:\n            type_as_str = 'integer'\n        elif type_as_type is bool:\n            type_as_str = 'boolean'\n        elif type_as_type is list or type_as_type is tuple:\n            type_as_str = 'array'\n        elif type_as_type is float:\n            type_as_str = 'number'\n        else:\n            type_as_str = 'object'\n        return type_as_str\n\n    @classmethod\n    def _add_param_info(cls, parameters, p_info):\n        # Cases to consider:\n        #     * Parameter name (if not nested) misspelt in decorator => parameter not displayed\n        #     * Sometimes a parameter is used for several endpoints (e.g. fs_id in CephFS).\n        #       Currently, there is no possibility of reuse. Should there be?\n        #       But what if there are two parameters with same name but different functionality?\n        \"\"\"\n        Adds explicitly described information for parameters of an endpoint.\n\n        There are two cases:\n        * Either the parameter in p_info corresponds to an endpoint parameter. Implicit information\n        has higher priority, so only information that doesn't already exist is added.\n        * Or the parameter in p_info describes a nested parameter inside an endpoint parameter.\n        In that case there is no implicit information at all so all explicitly described info needs\n        to be added.\n        \"\"\"\n        for p in p_info:\n            if not p['nested']:\n                for parameter in parameters:\n                    if p['name'] == parameter['name']:\n                        parameter['type'] = p['type']\n                        parameter['description'] = p['description']\n                        if 'nested_params' in p:\n                            parameter['nested_params'] = cls._add_param_info([], p['nested_params'])\n            else:\n                nested_p = {\n                    'name': p['name'],\n                    'type': p['type'],\n                    'description': p['description'],\n                    'required': p['required'],\n                }\n                if 'default' in p:\n                    nested_p['default'] = p['default']\n                if 'nested_params' in p:\n                    nested_p['nested_params'] = cls._add_param_info([], p['nested_params'])\n                parameters.append(nested_p)\n\n        return parameters\n\n    @classmethod\n    def _gen_schema_for_content(cls, params):\n        \"\"\"\n        Generates information to the content-object in OpenAPI Spec.\n        Used to for request body and responses.\n        \"\"\"\n        required_params = []\n        properties = {}\n\n        for param in params:\n            if param['required']:\n                required_params.append(param['name'])\n\n            props = {}\n            if 'type' in param:\n                props['type'] = cls._type_to_str(param['type'])\n                if 'nested_params' in param:\n                    if props['type'] == 'array':  # dict in array\n                        props['items'] = cls._gen_schema_for_content(param['nested_params'])\n                    else:  # dict in dict\n                        props = cls._gen_schema_for_content(param['nested_params'])\n                elif props['type'] == 'object':  # e.g. [int]\n                    props['type'] = 'array'\n                    props['items'] = {'type': cls._type_to_str(param['type'][0])}\n            else:\n                props['type'] = cls._gen_type(param)\n            if 'description' in param:\n                props['description'] = param['description']\n            if 'default' in param:\n                props['default'] = param['default']\n            properties[param['name']] = props\n\n        schema = {\n            'type': 'object',\n            'properties': properties,\n        }\n        if required_params:\n            schema['required'] = required_params\n        return schema\n\n    @classmethod\n    def _gen_responses(cls, method, resp_object=None):\n        resp: Dict[str, Dict[str, Union[str, Any]]] = {\n            '400': {\n                \"description\": \"Operation exception. Please check the \"\n                               \"response body for details.\"\n            },\n            '401': {\n                \"description\": \"Unauthenticated access. Please login first.\"\n            },\n            '403': {\n                \"description\": \"Unauthorized access. Please check your \"\n                               \"permissions.\"\n            },\n            '500': {\n                \"description\": \"Unexpected error. Please check the \"\n                               \"response body for the stack trace.\"\n            }\n        }\n        if method.lower() == 'get':\n            resp['200'] = {'description': \"OK\"}\n        if method.lower() == 'post':\n            resp['201'] = {'description': \"Resource created.\"}\n        if method.lower() == 'put':\n            resp['200'] = {'description': \"Resource updated.\"}\n        if method.lower() == 'delete':\n            resp['204'] = {'description': \"Resource deleted.\"}\n        if method.lower() in ['post', 'put', 'delete']:\n            resp['202'] = {'description': \"Operation is still executing.\"\n                                          \" Please check the task queue.\"}\n\n        if resp_object:\n            for status_code, response_body in resp_object.items():\n                resp[status_code].update({\n                    'content': {\n                        'application/json': {\n                            'schema': cls._gen_schema_for_content(response_body)}}})\n\n        return resp\n\n    @classmethod\n    def _gen_params(cls, params, location):\n        parameters = []\n        for param in params:\n            if 'type' in param:\n                _type = cls._type_to_str(param['type'])\n            else:\n                _type = cls._gen_type(param)\n            if 'description' in param:\n                descr = param['description']\n            else:\n                descr = \"*No description available*\"\n            res = {\n                'name': param['name'],\n                'in': location,\n                'schema': {\n                    'type': _type\n                },\n                'description': descr\n            }\n            if param['required']:\n                res['required'] = True\n            elif param['default'] is None:\n                res['allowEmptyValue'] = True\n            else:\n                res['default'] = param['default']\n            parameters.append(res)\n\n        return parameters\n\n    @classmethod\n    def _gen_paths(cls, all_endpoints):\n        method_order = ['get', 'post', 'put', 'delete']\n        paths = {}\n        for path, endpoints in sorted(list(ENDPOINT_MAP.items()),\n                                      key=lambda p: p[0]):\n            methods = {}\n            skip = False\n\n            endpoint_list = sorted(endpoints, key=lambda e:\n                                   method_order.index(e.method.lower()))\n            for endpoint in endpoint_list:\n                if not endpoint.is_api and not all_endpoints:\n                    skip = True\n                    break\n\n                method = endpoint.method\n                func = endpoint.func\n\n                summary = \"No description available\"\n                resp = {}\n                p_info = []\n                if hasattr(func, 'doc_info'):\n                    if func.doc_info['summary']:\n                        summary = func.doc_info['summary']\n                    resp = func.doc_info['response']\n                    p_info = func.doc_info['parameters']\n                params = []\n                if endpoint.path_params:\n                    params.extend(\n                        cls._gen_params(\n                            cls._add_param_info(endpoint.path_params, p_info), 'path'))\n                if endpoint.query_params:\n                    params.extend(\n                        cls._gen_params(\n                            cls._add_param_info(endpoint.query_params, p_info), 'query'))\n\n                methods[method.lower()] = {\n                    'tags': [cls._get_tag(endpoint)],\n                    'summary': summary,\n                    'description': func.__doc__,\n                    'parameters': params,\n                    'responses': cls._gen_responses(method, resp)\n                }\n\n                if method.lower() in ['post', 'put']:\n                    if endpoint.body_params:\n                        body_params = cls._add_param_info(endpoint.body_params, p_info)\n                        methods[method.lower()]['requestBody'] = {\n                            'content': {\n                                'application/json': {\n                                    'schema': cls._gen_schema_for_content(body_params)}}}\n\n                if endpoint.is_secure:\n                    methods[method.lower()]['security'] = [{'jwt': []}]\n\n            if not skip:\n                paths[path] = methods\n\n        return paths\n\n    def _gen_spec(self, all_endpoints=False, base_url=\"\"):\n        if all_endpoints:\n            base_url = \"\"\n\n        host = cherrypy.request.base\n        host = host[host.index(':')+3:]\n        logger.debug(\"Host: %s\", host)\n\n        paths = self._gen_paths(all_endpoints)\n\n        if not base_url:\n            base_url = \"/\"\n\n        scheme = 'https'\n        ssl = str_to_bool(mgr.get_localized_module_option('ssl', True))\n        if not ssl:\n            scheme = 'http'\n\n        spec = {\n            'openapi': \"3.0.0\",\n            'info': {\n                'description': \"Please note that this API is not an official \"\n                               \"Ceph REST API to be used by third-party \"\n                               \"applications. It's primary purpose is to serve\"\n                               \" the requirements of the Ceph Dashboard and is\"\n                               \" subject to change at any time. Use at your \"\n                               \"own risk.\",\n                'version': \"v1\",\n                'title': \"Ceph-Dashboard REST API\"\n            },\n            'host': host,\n            'basePath': base_url,\n            'servers': [{'url': \"{}{}\".format(cherrypy.request.base, base_url)}],\n            'tags': self._gen_tags(all_endpoints),\n            'schemes': [scheme],\n            'paths': paths,\n            'components': {\n                'securitySchemes': {\n                    'jwt': {\n                        'type': 'http',\n                        'scheme': 'bearer',\n                        'bearerFormat': 'JWT'\n                    }\n                }\n            }\n        }\n\n        return spec\n\n    @Endpoint(path=\"api.json\")\n    def api_json(self):\n        return self._gen_spec(False, \"/\")\n\n    @Endpoint(path=\"api-all.json\")\n    def api_all_json(self):\n        return self._gen_spec(True, \"/\")\n\n    def _swagger_ui_page(self, all_endpoints=False, token=None):\n        base = cherrypy.request.base\n        if all_endpoints:\n            spec_url = \"{}/docs/api-all.json\".format(base)\n        else:\n            spec_url = \"{}/docs/api.json\".format(base)\n\n        auth_header = cherrypy.request.headers.get('authorization')\n        auth_cookie = cherrypy.request.cookie['token']\n        jwt_token = \"\"\n        if auth_cookie is not None:\n            jwt_token = auth_cookie.value\n        elif auth_header is not None:\n            scheme, params = auth_header.split(' ', 1)\n            if scheme.lower() == 'bearer':\n                jwt_token = params\n        else:\n            if token is not None:\n                jwt_token = token\n\n        api_key_callback = \"\"\", onComplete: () => {{\n                        ui.preauthorizeApiKey('jwt', '{}');\n                    }}\n        \"\"\".format(jwt_token)\n\n        page = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"referrer\" content=\"no-referrer\" />\n            <link rel=\"stylesheet\" type=\"text/css\"\n                  href=\"/swagger-ui.css\" >\n            <style>\n                html\n                {{\n                    box-sizing: border-box;\n                    overflow: -moz-scrollbars-vertical;\n                    overflow-y: scroll;\n                }}\n                *,\n                *:before,\n                *:after\n                {{\n                    box-sizing: inherit;\n                }}\n                body {{\n                    margin:0;\n                    background: #fafafa;\n                }}\n            </style>\n        </head>\n        <body>\n        <div id=\"swagger-ui\"></div>\n        <script src=\"/swagger-ui-bundle.js\">\n        </script>\n        <script>\n            window.onload = function() {{\n                const ui = SwaggerUIBundle({{\n                    url: '{}',\n                    dom_id: '#swagger-ui',\n                    presets: [\n                        SwaggerUIBundle.presets.apis\n                    ],\n                    layout: \"BaseLayout\"\n                    {}\n                }})\n                window.ui = ui\n            }}\n        </script>\n        </body>\n        </html>\n        \"\"\".format(spec_url, api_key_callback)\n\n        return page\n\n    @Endpoint(json_response=False)\n    def __call__(self, all_endpoints=False):\n        return self._swagger_ui_page(all_endpoints)\n\n    @Endpoint('POST', path=\"/\", json_response=False,\n              query_params=\"{all_endpoints}\")\n    @allow_empty_body\n    def _with_token(self, token, all_endpoints=False):\n        return self._swagger_ui_page(all_endpoints, token)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nfrom __future__ import absolute_import\nfrom typing import Any, Dict, Union\n\nimport logging\nimport cherrypy\n\nfrom . import Controller, BaseController, Endpoint, ENDPOINT_MAP\nfrom .. import mgr\n\nfrom ..tools import str_to_bool\n\n\nlogger = logging.getLogger('controllers.docs')\n\n\n@Controller('/docs', secure=False)\nclass Docs(BaseController):\n\n    @classmethod\n    def _gen_tags(cls, all_endpoints):\n        \"\"\" Generates a list of all tags and corresponding descriptions. \"\"\"\n        # Scenarios to consider:\n        #     * Intentionally make up a new tag name at controller => New tag name displayed.\n        #     * Misspell or make up a new tag name at endpoint => Neither tag or endpoint displayed.\n        #     * Misspell tag name at controller (when referring to another controller) =>\n        #       Tag displayed but no endpoints assigned\n        #     * Description for a tag added at multiple locations => Only one description displayed.\n        list_of_ctrl = set()\n        for endpoints in ENDPOINT_MAP.values():\n            for endpoint in endpoints:\n                if endpoint.is_api or all_endpoints:\n                    list_of_ctrl.add(endpoint.ctrl)\n\n        tag_map: Dict[str, str] = {}\n        for ctrl in list_of_ctrl:\n            tag_name = ctrl.__name__\n            tag_descr = \"\"\n            if hasattr(ctrl, 'doc_info'):\n                if ctrl.doc_info['tag']:\n                    tag_name = ctrl.doc_info['tag']\n                tag_descr = ctrl.doc_info['tag_descr']\n            if tag_name not in tag_map or not tag_map[tag_name]:\n                tag_map[tag_name] = tag_descr\n\n        tags = [{'name': k, 'description': v if v else \"*No description available*\"}\n                for k, v in tag_map.items()]\n        tags.sort(key=lambda e: e['name'])\n        return tags\n\n    @classmethod\n    def _get_tag(cls, endpoint):\n        \"\"\" Returns the name of a tag to assign to a path. \"\"\"\n        ctrl = endpoint.ctrl\n        func = endpoint.func\n        tag = ctrl.__name__\n        if hasattr(func, 'doc_info') and func.doc_info['tag']:\n            tag = func.doc_info['tag']\n        elif hasattr(ctrl, 'doc_info') and ctrl.doc_info['tag']:\n            tag = ctrl.doc_info['tag']\n        return tag\n\n    @classmethod\n    def _gen_type(cls, param):\n        # pylint: disable=too-many-return-statements\n        \"\"\"\n        Generates the type of parameter based on its name and default value,\n        using very simple heuristics.\n        Used if type is not explicitly defined.\n        \"\"\"\n        param_name = param['name']\n        def_value = param['default'] if 'default' in param else None\n        if param_name.startswith(\"is_\"):\n            return \"boolean\"\n        if \"size\" in param_name:\n            return \"integer\"\n        if \"count\" in param_name:\n            return \"integer\"\n        if \"num\" in param_name:\n            return \"integer\"\n        if isinstance(def_value, bool):\n            return \"boolean\"\n        if isinstance(def_value, int):\n            return \"integer\"\n        return \"string\"\n\n    @classmethod\n    # isinstance doesn't work: input is always <type 'type'>.\n    def _type_to_str(cls, type_as_type):\n        \"\"\" Used if type is explicitly defined. \"\"\"\n        if type_as_type is str:\n            type_as_str = 'string'\n        elif type_as_type is int:\n            type_as_str = 'integer'\n        elif type_as_type is bool:\n            type_as_str = 'boolean'\n        elif type_as_type is list or type_as_type is tuple:\n            type_as_str = 'array'\n        elif type_as_type is float:\n            type_as_str = 'number'\n        else:\n            type_as_str = 'object'\n        return type_as_str\n\n    @classmethod\n    def _add_param_info(cls, parameters, p_info):\n        # Cases to consider:\n        #     * Parameter name (if not nested) misspelt in decorator => parameter not displayed\n        #     * Sometimes a parameter is used for several endpoints (e.g. fs_id in CephFS).\n        #       Currently, there is no possibility of reuse. Should there be?\n        #       But what if there are two parameters with same name but different functionality?\n        \"\"\"\n        Adds explicitly described information for parameters of an endpoint.\n\n        There are two cases:\n        * Either the parameter in p_info corresponds to an endpoint parameter. Implicit information\n        has higher priority, so only information that doesn't already exist is added.\n        * Or the parameter in p_info describes a nested parameter inside an endpoint parameter.\n        In that case there is no implicit information at all so all explicitly described info needs\n        to be added.\n        \"\"\"\n        for p in p_info:\n            if not p['nested']:\n                for parameter in parameters:\n                    if p['name'] == parameter['name']:\n                        parameter['type'] = p['type']\n                        parameter['description'] = p['description']\n                        if 'nested_params' in p:\n                            parameter['nested_params'] = cls._add_param_info([], p['nested_params'])\n            else:\n                nested_p = {\n                    'name': p['name'],\n                    'type': p['type'],\n                    'description': p['description'],\n                    'required': p['required'],\n                }\n                if 'default' in p:\n                    nested_p['default'] = p['default']\n                if 'nested_params' in p:\n                    nested_p['nested_params'] = cls._add_param_info([], p['nested_params'])\n                parameters.append(nested_p)\n\n        return parameters\n\n    @classmethod\n    def _gen_schema_for_content(cls, params):\n        \"\"\"\n        Generates information to the content-object in OpenAPI Spec.\n        Used to for request body and responses.\n        \"\"\"\n        required_params = []\n        properties = {}\n\n        for param in params:\n            if param['required']:\n                required_params.append(param['name'])\n\n            props = {}\n            if 'type' in param:\n                props['type'] = cls._type_to_str(param['type'])\n                if 'nested_params' in param:\n                    if props['type'] == 'array':  # dict in array\n                        props['items'] = cls._gen_schema_for_content(param['nested_params'])\n                    else:  # dict in dict\n                        props = cls._gen_schema_for_content(param['nested_params'])\n                elif props['type'] == 'object':  # e.g. [int]\n                    props['type'] = 'array'\n                    props['items'] = {'type': cls._type_to_str(param['type'][0])}\n            else:\n                props['type'] = cls._gen_type(param)\n            if 'description' in param:\n                props['description'] = param['description']\n            if 'default' in param:\n                props['default'] = param['default']\n            properties[param['name']] = props\n\n        schema = {\n            'type': 'object',\n            'properties': properties,\n        }\n        if required_params:\n            schema['required'] = required_params\n        return schema\n\n    @classmethod\n    def _gen_responses(cls, method, resp_object=None):\n        resp: Dict[str, Dict[str, Union[str, Any]]] = {\n            '400': {\n                \"description\": \"Operation exception. Please check the \"\n                               \"response body for details.\"\n            },\n            '401': {\n                \"description\": \"Unauthenticated access. Please login first.\"\n            },\n            '403': {\n                \"description\": \"Unauthorized access. Please check your \"\n                               \"permissions.\"\n            },\n            '500': {\n                \"description\": \"Unexpected error. Please check the \"\n                               \"response body for the stack trace.\"\n            }\n        }\n        if method.lower() == 'get':\n            resp['200'] = {'description': \"OK\"}\n        if method.lower() == 'post':\n            resp['201'] = {'description': \"Resource created.\"}\n        if method.lower() == 'put':\n            resp['200'] = {'description': \"Resource updated.\"}\n        if method.lower() == 'delete':\n            resp['204'] = {'description': \"Resource deleted.\"}\n        if method.lower() in ['post', 'put', 'delete']:\n            resp['202'] = {'description': \"Operation is still executing.\"\n                                          \" Please check the task queue.\"}\n\n        if resp_object:\n            for status_code, response_body in resp_object.items():\n                resp[status_code].update({\n                    'content': {\n                        'application/json': {\n                            'schema': cls._gen_schema_for_content(response_body)}}})\n\n        return resp\n\n    @classmethod\n    def _gen_params(cls, params, location):\n        parameters = []\n        for param in params:\n            if 'type' in param:\n                _type = cls._type_to_str(param['type'])\n            else:\n                _type = cls._gen_type(param)\n            if 'description' in param:\n                descr = param['description']\n            else:\n                descr = \"*No description available*\"\n            res = {\n                'name': param['name'],\n                'in': location,\n                'schema': {\n                    'type': _type\n                },\n                'description': descr\n            }\n            if param['required']:\n                res['required'] = True\n            elif param['default'] is None:\n                res['allowEmptyValue'] = True\n            else:\n                res['default'] = param['default']\n            parameters.append(res)\n\n        return parameters\n\n    @classmethod\n    def _gen_paths(cls, all_endpoints):\n        method_order = ['get', 'post', 'put', 'delete']\n        paths = {}\n        for path, endpoints in sorted(list(ENDPOINT_MAP.items()),\n                                      key=lambda p: p[0]):\n            methods = {}\n            skip = False\n\n            endpoint_list = sorted(endpoints, key=lambda e:\n                                   method_order.index(e.method.lower()))\n            for endpoint in endpoint_list:\n                if not endpoint.is_api and not all_endpoints:\n                    skip = True\n                    break\n\n                method = endpoint.method\n                func = endpoint.func\n\n                summary = \"No description available\"\n                resp = {}\n                p_info = []\n                if hasattr(func, 'doc_info'):\n                    if func.doc_info['summary']:\n                        summary = func.doc_info['summary']\n                    resp = func.doc_info['response']\n                    p_info = func.doc_info['parameters']\n                params = []\n                if endpoint.path_params:\n                    params.extend(\n                        cls._gen_params(\n                            cls._add_param_info(endpoint.path_params, p_info), 'path'))\n                if endpoint.query_params:\n                    params.extend(\n                        cls._gen_params(\n                            cls._add_param_info(endpoint.query_params, p_info), 'query'))\n\n                methods[method.lower()] = {\n                    'tags': [cls._get_tag(endpoint)],\n                    'summary': summary,\n                    'description': func.__doc__,\n                    'parameters': params,\n                    'responses': cls._gen_responses(method, resp)\n                }\n\n                if method.lower() in ['post', 'put']:\n                    if endpoint.body_params:\n                        body_params = cls._add_param_info(endpoint.body_params, p_info)\n                        methods[method.lower()]['requestBody'] = {\n                            'content': {\n                                'application/json': {\n                                    'schema': cls._gen_schema_for_content(body_params)}}}\n\n                if endpoint.is_secure:\n                    methods[method.lower()]['security'] = [{'jwt': []}]\n\n            if not skip:\n                paths[path] = methods\n\n        return paths\n\n    def _gen_spec(self, all_endpoints=False, base_url=\"\"):\n        if all_endpoints:\n            base_url = \"\"\n\n        host = cherrypy.request.base\n        host = host[host.index(':')+3:]\n        logger.debug(\"Host: %s\", host)\n\n        paths = self._gen_paths(all_endpoints)\n\n        if not base_url:\n            base_url = \"/\"\n\n        scheme = 'https'\n        ssl = str_to_bool(mgr.get_localized_module_option('ssl', True))\n        if not ssl:\n            scheme = 'http'\n\n        spec = {\n            'openapi': \"3.0.0\",\n            'info': {\n                'description': \"Please note that this API is not an official \"\n                               \"Ceph REST API to be used by third-party \"\n                               \"applications. It's primary purpose is to serve\"\n                               \" the requirements of the Ceph Dashboard and is\"\n                               \" subject to change at any time. Use at your \"\n                               \"own risk.\",\n                'version': \"v1\",\n                'title': \"Ceph-Dashboard REST API\"\n            },\n            'host': host,\n            'basePath': base_url,\n            'servers': [{'url': \"{}{}\".format(cherrypy.request.base, base_url)}],\n            'tags': self._gen_tags(all_endpoints),\n            'schemes': [scheme],\n            'paths': paths,\n            'components': {\n                'securitySchemes': {\n                    'jwt': {\n                        'type': 'http',\n                        'scheme': 'bearer',\n                        'bearerFormat': 'JWT'\n                    }\n                }\n            }\n        }\n\n        return spec\n\n    @Endpoint(path=\"api.json\")\n    def api_json(self):\n        return self._gen_spec(False, \"/\")\n\n    @Endpoint(path=\"api-all.json\")\n    def api_all_json(self):\n        return self._gen_spec(True, \"/\")\n\n    def _swagger_ui_page(self, all_endpoints=False):\n        base = cherrypy.request.base\n        if all_endpoints:\n            spec_url = \"{}/docs/api-all.json\".format(base)\n        else:\n            spec_url = \"{}/docs/api.json\".format(base)\n\n        page = \"\"\"\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"referrer\" content=\"no-referrer\" />\n            <link rel=\"stylesheet\" type=\"text/css\"\n                  href=\"/swagger-ui.css\" >\n            <style>\n                html\n                {{\n                    box-sizing: border-box;\n                    overflow: -moz-scrollbars-vertical;\n                    overflow-y: scroll;\n                }}\n                *,\n                *:before,\n                *:after\n                {{\n                    box-sizing: inherit;\n                }}\n                body {{\n                    margin:0;\n                    background: #fafafa;\n                }}\n            </style>\n        </head>\n        <body>\n        <div id=\"swagger-ui\"></div>\n        <script src=\"/swagger-ui-bundle.js\">\n        </script>\n        <script>\n            window.onload = function() {{\n                const ui = SwaggerUIBundle({{\n                    url: '{}',\n                    dom_id: '#swagger-ui',\n                    presets: [\n                        SwaggerUIBundle.presets.apis\n                    ],\n                    layout: \"BaseLayout\"\n                }})\n                window.ui = ui\n            }}\n        </script>\n        </body>\n        </html>\n        \"\"\".format(spec_url)\n\n        return page\n\n    @Endpoint(json_response=False)\n    def __call__(self, all_endpoints=False):\n        return self._swagger_ui_page(all_endpoints)\n"], "filenames": ["src/pybind/mgr/dashboard/controllers/docs.py"], "buggy_code_start_loc": [8], "buggy_code_end_loc": [459], "fixing_code_start_loc": [8], "fixing_code_end_loc": [432], "type": "CWE-79", "message": "A flaw was found in Red Hat Ceph Storage 4, in the Dashboard component. In response to CVE-2020-27839, the JWT token was moved from localStorage to an httpOnly cookie. However, token cookies are used in the body of the HTTP response for the documentation, which again makes it available to XSS.The greatest threat to the system is for confidentiality, integrity, and availability.", "other": {"cve": {"id": "CVE-2021-3509", "sourceIdentifier": "secalert@redhat.com", "published": "2021-05-27T00:15:08.577", "lastModified": "2022-04-25T17:08:08.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in Red Hat Ceph Storage 4, in the Dashboard component. In response to CVE-2020-27839, the JWT token was moved from localStorage to an httpOnly cookie. However, token cookies are used in the body of the HTTP response for the documentation, which again makes it available to XSS.The greatest threat to the system is for confidentiality, integrity, and availability."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en Red Hat Ceph Storage 4, en el componente Dashboard.&#xa0;En respuesta a CVE-2020-27839, el token JWT fue movido de localStorage a una cookie httpOnly.&#xa0;Sin embargo, las cookies de token son usados en el cuerpo de la respuesta HTTP para la documentaci\u00f3n, que de nuevo lo pone a disposici\u00f3n de un ataque de tipo XSS. La mayor amenaza para el sistema es la confidencialidad, integridad y disponibilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph_storage:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6E54096-5D45-4CB2-AC9A-DDB55BF2B94C"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1950116", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/ceph/ceph/blob/f1557e8f62d31883d3d34ae241a1a26af11d923f/src/pybind/mgr/dashboard/controllers/docs.py#L394-L409", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/7a1ca8d372da3b6a4fc3d221a0e5f72d1d61c27b", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/adda853e64bdba1288d46bc7d462d23d8f2f10ca", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/af3fffab3b0f13057134d96e5d481e400d8bfd27", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ceph/ceph/commit/7a1ca8d372da3b6a4fc3d221a0e5f72d1d61c27b"}}