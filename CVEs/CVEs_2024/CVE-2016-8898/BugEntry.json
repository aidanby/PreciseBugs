{"buggy_code": ["<?php\n##################################################\n#\n# Copyright (c) 2004-2016 OIC Group, Inc.\n#\n# This file is part of Exponent\n#\n# Exponent is free software; you can redistribute\n# it and/or modify it under the terms of the GNU\n# General Public License as published by the Free\n# Software Foundation; either version 2 of the\n# License, or (at your option) any later version.\n#\n# GPL: http://www.gnu.org/licenses/gpl.txt\n#\n##################################################\n\n/**\n * This is the class expRouter\n *\n * @package Subsystems\n * @subpackage Subsystems\n */\n\nclass expRouter {\n\n    private $maps = array();\n    public  $url_parts = '';\n    public  $current_url = '';\n    /**\n     * Type of url\n     * either 'base' (default page), 'page', 'action', or 'malformed'\n     * @var string\n     */\n    public  $url_type = '';\n    /**\n     * Style of url\n     * either 'sef' or 'query'\n     * @var string\n     */\n    public  $url_style = '';\n    public  $params = array();\n    public  $sefPath = null;\n    \n    function __construct() {\n        self::getRouterMaps();\n    }\n\n    /**\n     * remove trailing slash\n     *\n     * @param $fulllink\n     *\n     * @return string\n     */\n    public static function cleanLink($fulllink)\n    {           \n        if(substr($fulllink, -1) == '/') $fulllink = substr($fulllink, 0, -1);  \n        return $fulllink;                                   \n    }\n    \n    /**\n\t * Will build url to a module/page/etc (determined by what is passed to the $params array).\n\t *\n\t * @param array $params The params that are passed will determine what link is make\n\t *               section\n\t *               action\n\t *               sef_name\n\t *               module\n\t *               controller\n\t *               action\n\t *\n\t * @param bool $force_old_school Old School as in not SEF.\n\t *\n\t * @param bool $secure If you set $secure true but ENABLE_SSL is not turned on in the config this will be forced false\n\t *\n\t * @param bool $no_map Ignore router_maps\n     *\n\t * @return string A url\n\t */\n    public function makeLink($params, $force_old_school=false, $secure=false, $no_map=false) {\n        $secure = ENABLE_SSL == 1 ? $secure : false;  // check if this site can use SSL if not then force the link to not be secure\n        $linkbase =  $secure ? URL_BASE_SECURE : URL_BASE;\n        $linkbase .= SCRIPT_RELATIVE;\n                \n        if (isset($params['section']) && $params['section'] == SITE_DEFAULT_SECTION) {            \n            return self::cleanLink($linkbase);\n        }\n\n        // Check to see if SEF_URLS have been turned on in the site config\n        if (SEF_URLS == 1 && ($_SERVER[\"PHP_SELF\"] == PATH_RELATIVE.'index.php' || $_SERVER[\"PHP_SELF\"] == PATH_RELATIVE.'install/index.php') && $force_old_school == false) {\n            \n            if (isset($params['section']) && !isset($params['action'])) {                \n                if (empty($params['sef_name'])) {\n                    global $db;\n\n                    $params['sef_name'] = $db->selectValue('section', 'sef_name', 'id='.intval($params['section']));\n                }                               \n                return self::cleanLink($linkbase.$params['sef_name']);\n            } else {                \n                // initialize the link\n                $link = '';               \n        \n                // we need to add the change the module parameter to controller if it exists\n                // we can remove this snippit once the old modules are gone.\n                if (!empty($params['module']) && empty($params['controller'])) $params['controller'] = $params['module'];\n            \n                // check to see if we have a router mapping for this controller/action\n                if (empty($no_map)){\n                    for ($i = 0, $iMax = count($this->maps); $i < $iMax; $i++) {\n                        $missing_params = array(\"dump\");\n\n                        if ((!empty($params) && !empty($params['controller']) && !empty($params['action'])) && (in_array($params['controller'], $this->maps[$i]) && in_array($params['action'], $this->maps[$i]) && (!isset($this->maps[$i]['src']) || in_array($params['src'], $this->maps[$i])))) {\n                            $missing_params = array_diff_key($this->maps[$i]['url_parts'], $params);\n                        }\n\n                        if (count($missing_params) == 0) {\n                            foreach($this->maps[$i]['url_parts'] as $key=>$value) {\n                                if ($key == 'controller') {\n                                    $link .= urlencode($value).\"/\";\n                                } else {\n                                    $link .= urlencode($params[$key]).\"/\";\n                                }\n                            }\n                            break;  // if this hits then we've found a match\n                        }\n                    }\n                }\n\n                // if we found a mapping for this link then we can return it now.\n                //if ($link != '') return self::encode($linkbase.$link);\n                if ($link != '') return self::cleanLink($linkbase.$link);\n                \n                if (!empty($params['controller'])) $link .= $params['controller'].'/';\n                if (!empty($params['action'])) $link .= $params['action'].'/';\n                foreach ($params as $key=>$value) {\n                    if(!is_array($value) && strpos($key,'__') !== 0 && $key !== 'PHPSESSID') {\n                        $value = trim($value);\n                        $key = trim($key);\n                        if ($value != \"\") {\n                            if ($key != 'module' && $key != 'action' && $key != 'controller') {\n                                if ($key != 'src') {\n                                    $link .= urlencode($key).\"/\".urlencode($value).\"/\";\n                                } else {\n                                    $link .= $key.\"/\".$value.\"/\";\n                                }\n                            }\n                        }\n                    }\n                }\n                //trim last / off                 \n                return self::cleanLink($linkbase.$link);\n            }\n        } else {\n            // if the users don't have SEF URL's turned on then we make the link the old school way.\n            if (!empty($params['sef_name'])) unset($params['sef_name']);\n            $link = $linkbase . SCRIPT_FILENAME . \"?\";\n            foreach ($params as $key=>$value) {\n                if (!is_array($value) && strpos($key,'__') !== 0 && $key !== 'PHPSESSID'){\n                    $value = trim($value);\n                    $key = trim($key);\n                    if ($value != \"\") {\n                        if ($key != 'src') {\n                            $link .= urlencode($key).\"=\".urlencode($value).\"&\";\n                        } else {\n                            $link .= $key.\"=\".$value.\"&\";\n                        }                    \n                    }\n                }\n            }\n\n            $link = substr($link,0,-1);\n            return $link; // phillip: removed htmlspecialchars so that links return without parsing & to &amp; in URL strings\n            //return htmlspecialchars($link,ENT_QUOTES);\n        }\n    }\n\n    /**\n     * Returns a cleaner canonical link sans 'src' param\n     *\n     * @return string\n     */\n    public function plainPath() {\n        $params = $this->params;\n        unset($params['src']);\n        return $this->makeLink($params);\n    }\n\n    public function routeRequest() {\n        global $user;\n\n        // strip out possible xss exploits via url\n        foreach ($_GET as $key=>$var) {\n            if (is_string($var) && strpos($var,'\">')) {\n                unset(\n                    $_GET[$key],\n                    $_REQUEST[$key]\n                );\n            }\n        }\n        // conventional method to ensure the 'id' is only an id\n        if (isset($_REQUEST['id'])) {\n            if (isset($_GET['id']))\n                $_GET['id'] = intval($_GET['id']);\n            if (isset($_POST['id']))\n                $_POST['id'] = intval($_POST['id']);\n\n            $_REQUEST['id'] = intval($_REQUEST['id']);\n        }\n        // do the same for the other id's\n        foreach ($_REQUEST as $key=>$var) {\n            if (is_string($var) && strrpos($key,'_id',-3) !== false) {\n                if (isset($_GET[$key]))\n                    $_GET[$key] = intval($_GET[$key]);\n                if (isset($_POST[$key]))\n                    $_POST[$key] = intval($_POST[$key]);\n\n                $_REQUEST[$key] = intval($_REQUEST[$key]);\n            }\n        }\n        if (empty($user->id) || (!empty($user->id) && !$user->isAdmin())) {  //FIXME why would $user be empty here unless $db is down?\n//            $_REQUEST['route_sanitized'] = true;//FIXME debug test\n            expString::sanitize($_REQUEST);  // strip other exploits like sql injections\n        }\n\n        // start splitting the URL into it's different parts\n        $this->splitURL();\n        // edebug($this,1);\n\n        if ($this->url_style == 'sef') {\n            if ($this->url_type == 'page' || $this->url_type == 'base') {\n                $ret = $this->routePageRequest();               // if we hit this the formatting of the URL looks like the user is trying to go to a page.\n                if (!$ret) $this->url_type = 'malformed';\n            } elseif ($this->url_type == 'action') {\n                $this->isMappedURL();                       //check for a router map\n                $ret = $this->routeActionRequest();         // we didn't have a map for this URL.  Try to route it with this function.\n\n                // if this url wasn't a valid section, or action then kill it.  It might not actually be a \"bad\" url, \n                // but this is a precautionary measure against bad paths on images, css & js file, etc...with the new\n                // mod_rewrite rules these bad paths will not route thru here so we need to take them into account and\n                // deal with them accordingly.\n                if (!$ret) $this->url_type = 'malformed';  \n            } elseif ($this->url_type == 'post') {\n                // some forms aren't getting the controller field set right when the form is created\n                // we are putting this check here to safe guard against a controller being referred to as\n                // a module in the form.\n                if (!empty($_POST['controller']) || !empty($_POST['module'])) {\n                    $module = !empty($_POST['controller']) ? expString::sanitize($_POST['controller']) : expString::sanitize($_POST['module']);\n                    // Figure out if this is module or controller request - WE ONLY NEED THIS CODE UNTIL WE PULL OUT THE OLD MODULES\n                    if (expModules::controllerExists($module)) {\n                        $_POST['controller'] = $module;\n                        $_REQUEST['controller'] = $module;\n                    }\n                }\n            }\n        } elseif ($this->url_style == 'query' && SEF_URLS == 1 && !empty($_REQUEST['section']) && PRINTER_FRIENDLY != 1 && EXPORT_AS_PDF != 1) {\n            // if we hit this it's an old school url coming in and we're trying to use SEF's. \n            // we will send a permanent redirect so the search engines don't freak out about 2 links pointing\n            // to the same page.\n            header(\"Location: \".$this->makeLink(array('section'=>intval($_REQUEST['section']))),TRUE,301);          \n        }\n\n        // if this is a valid URL then we build out the current_url var which is used by flow, and possibly other places too\n        if ($this->url_type != 'malformed') {               \n            $this->current_url = $this->buildCurrentUrl();\n        } else {\n            // check if the URL is looking for a non-existent page or controller (we will check for bad action in renderAction())\n            // if page or controller is not found we will route to the not found controller.            \n            $_REQUEST['controller'] = 'notfound';\n            $_REQUEST['action'] = 'handle';\n        }\n    }\n\n    //FIXME what are we doing with this history? saving each page load\n    public function updateHistory($section=null) {\n        global $db,$user;\n\n        // if its not already set\n        // configurable tracking length\n        setcookie('UserUID',expSession::getTicketString(),86400 * TRACKING_COOKIE_EXPIRES);\n        $cookieID = (empty($_COOKIE['UserUID'])) ? expSession::getTicketString() : $_COOKIE['UserUID'];\n        // Build out the object to insert into the db.\n        // Get our parameters.\n        $tmpParams = array();\n        foreach ($this->params as $key=>$value) {\n            if ($key != 'module' && $key != 'action' && $key != 'controller' && $key != 'section') {\n                $tmpParams[$key] = $value;\n            }\n        }\n        $trackingObject = new stdClass();\n        $trackingObject->params = serialize($tmpParams);\n        if ($this->url_type == 'page' || $this->url_type == 'base') {\n            $trackingObject->section = $section;\n        } else {\n            $trackingObject->module = ($_SERVER['REQUEST_METHOD'] == 'POST') ? (empty($_POST['controller']) ? expString::sanitize($_POST['module']) : expString::sanitize($_POST['controller'])) : $this->url_parts[0];\n            $trackingObject->action = ($_SERVER['REQUEST_METHOD'] == 'POST') ? $_POST['action'] : $this->url_parts[1];\n        }\n        $trackingObject->referer = empty($_SERVER['HTTP_REFERER']) ? null : $_SERVER['HTTP_REFERER'];\n        $trackingObject->cookieUID = $cookieID;\n        $trackingObject->user_id = $user->id;\n        $trackingObject->timestamp = time();\n        $trackingObject->user_address = $_SERVER['REMOTE_ADDR'];\n        $trackingObject->user_agent = $_SERVER['HTTP_USER_AGENT'];\n        $trackingObject->session_id = $_COOKIE['PHPSESSID'];\n        $db->insertObject($trackingObject,'tracking_rawdata');\n    }\n\n    public function splitURL() {\n        global $db;\n\n        $this->url_parts = array();\n        $this->buildSEFPath();\n\n        if (!empty($this->sefPath)) {\n            $this->url_style = 'sef';\n            $this->url_parts = explode('/', $this->sefPath);     \n\n            // remove empty first and last url_parts if they exist\n            //if (empty($this->url_parts[count($this->url_parts)-1])) array_pop($this->url_parts);\n            if ($this->url_parts[count($this->url_parts)-1] == '') array_pop($this->url_parts);\n            if (empty($this->url_parts[0])) array_shift($this->url_parts);\n            \n            if (count($this->url_parts) < 1 || (empty($this->url_parts[0]) && count($this->url_parts) == 1) ) {\n                $this->url_type = 'base';  // no params\n            } elseif (count($this->url_parts) == 1 || $db->selectObject('section', \"sef_name='\" . substr($this->sefPath,1) . \"'\") != null) {\n                $this->url_type = 'page';  // single param is page name\n            } elseif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n                $this->url_type = 'post';  // params via form/post\n            } else {\n                // take a peek and see if a page exists with the same name as the first value...if so we probably have a page with\n                // extra perms...like printerfriendly=1 or ajax_action=1;\n                if (($db->selectObject('section', \"sef_name='\" . $this->url_parts[0] . \"'\") != null) && (in_array(array('printerfriendly','exportaspdf','ajax_action'), $this->url_parts))) {\n                    $this->url_type = 'page';\n                } else {\n                    $this->url_type = 'action';\n                }\n            }\n            $this->params = $this->convertPartsToParams();\n        } elseif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            $this->url_style = 'sef';\n            $this->url_type = 'post';\n            $this->params = $this->convertPartsToParams();\n        } elseif (isset($_SERVER['REQUEST_URI'])) {\n            // if we hit here, we don't really need to do much.  All the pertinent info will come thru in the POST/GET vars\n            // so we don't really need to worry about what the URL looks like.\n            if ($_SERVER['REQUEST_URI'] == PATH_RELATIVE) {\n                $this->url_type = 'base';\n                $this->params = array();\n            } else {\n                $sefPath = explode('%22%3E',$_SERVER['REQUEST_URI']);  // remove any attempts to close the command\n                $_SERVER['REQUEST_URI'] = $sefPath[0];\n                $this->url_style = 'query';\n            }\n        } else {\n            $this->url_type = 'base';\n            $this->params = array();\n        }\n                              \n        // Check if this was a printer friendly link request\n        define('PRINTER_FRIENDLY', (isset($_REQUEST['printerfriendly']) || isset($this->params['printerfriendly'])) ? 1 : 0);         \n        define('EXPORT_AS_PDF', (isset($_REQUEST['exportaspdf']) || isset($this->params['exportaspdf'])) ? 1 : 0);\n        define('EXPORT_AS_PDF_LANDSCAPE', (isset($_REQUEST['landscapepdf']) || isset($this->params['landscapepdf'])) ? 1 : 0);\n    }\n\n    public function routePageRequest() {        \n//        global $db;\n\n        if ($this->url_type == 'base') {\n            // if we made it in here this is a request for http://www.baseurl.com\n            if (expTheme::inAction()) {\n                $_REQUEST['section'] = (expSession::is_set('last_section') ? expSession::get('last_section') : SITE_DEFAULT_SECTION);\n            } else {\n                $_REQUEST['section'] = SITE_DEFAULT_SECTION;  \n            }\n        } else {\n            // Try to look up the page by sef_name first.  If that doesn't exist, strip out the dashes and\n            // check the regular page names.  If that still doesn't work then we'll redirect them to the \n            // search module using the page name as the search string.\n            $section = $this->getPageByName(substr($this->sefPath,1));\n            ########################################################\n            #FJD TODO:  this needs further refinement\n            #currently this requires a matching routerMap as such to work properly:\n            /*\n            $maps[] = array('controller'=>'store',\n                    'action'=>'showall',\n                    'url_parts'=>array(                \n                            'title'=>'(.*)'),\n            );\n            $maps[] = array('controller'=>'store',\n                    'action'=>'showByTitle',\n                    'url_parts'=>array(                \n                            'title'=>'(.*)'),\n            );\n            */\n            //if section is empty, we'll look for the page overrides first and route to \n            //routeActionRequest with some hand wacked variables. If we can't find an override\n            //then we'll return false as usual\n            // since we only received a single param and it wasn't a page, try for store category, or a product\n            if (empty($section)) {\n                $sef_url = $this->url_parts[0];\n                //check for a category\n                $c = new storeCategory();                \n                $cat = $c->findBy('sef_url', $sef_url);\n                if (empty($cat)) {\n                    //check for a product\n                    $p = new product();\n                    $prod = $p->findBy('sef_url', $sef_url);\n                    if(!empty($prod)) {\n                        //fake parts and route to action  \n                        $this->url_type = 'action';                   \n                        $this->url_parts[0] = 'store'; //controller\n                        $this->url_parts[1] = 'show'; //controller\n                        $this->url_parts[2] = 'title'; //controller\n                        $this->url_parts[3] = $sef_url; //controller\n                        //eDebug($this->url_parts,true);\n                        $this->params = $this->convertPartsToParams();\n                        return $this->routeActionRequest();\n                    }\n                    //else fall through\n                } else {\n                    //fake parts and route to action \n                    $this->url_type = 'action';                                      \n                    $this->url_parts[0] = 'store'; //controller\n                    $this->url_parts[1] = 'showall'; //controller\n                    $this->url_parts[2] = 'title'; //controller                    \n                    $this->url_parts[3] = $sef_url; //controller\n                    //eDebug($this->url_parts,true);\n                    $this->params = $this->convertPartsToParams();\n                    return $this->routeActionRequest();\n                }\n                return false;\n            }\n            #########################################################\n            //if (empty($section)) return false;  //couldnt find the page..let the calling action deal with it.\n            $_REQUEST['section'] = $section->id;\n        }\n        \n        expHistory::set('viewable', array('section'=>intval($_REQUEST['section'])));\n        return true;\n    }\n\n    /**\n     * figure out if this action is mapped via the mapping file (router_maps.php)\n     */\n    public function isMappedURL() {\n        $part_count = count($this->url_parts);\n        foreach ($this->maps as $map) {\n            $matched = true;\n            $pairs = array();\n            $i = 0;\n            if ($part_count == count($map['url_parts'])) {               \n                foreach($map['url_parts'] as $key=>$map_part) {\n                    $res = preg_match(\"/^$map_part/\", $this->url_parts[$i]);\n                    if ($res != 1) {\n                        $matched = false;\n                        break;\n                    } \n                    $pairs[$key] = $this->url_parts[$i];\n                    $i++;\n                }\n            } else {\n                $matched = false;\n            }            \n              \n            if ($matched) {\n                // safeguard against false matches when a real action was what the user really wanted.\n                if (count($this->url_parts) >= 2 && method_exists(expModules::getController($this->url_parts[0]), $this->url_parts[1]))\n                    return false;\n\n                $this->url_parts = array();\n                $this->url_parts[0] = $map['controller'];\n                $this->url_parts[1] = $map['action'];\n        \n                if (isset($map['view'])) {\n                    $this->url_parts[2] = 'view';\n                    $this->url_parts[3] = $map['view'];\n                }\n\n                foreach($map as $key=>$value) {\n                    if ($key != 'controller' && $key != 'action' && $key != 'view' && $key != 'url_parts') {\n                        $this->url_parts[] = $key;\n                        $this->url_parts[] = $value;\n                    }\n                }\n\n                foreach($pairs as $key=>$value) {\n                    if ($key != 'controller') {\n                        $this->url_parts[] = $key;\n                        $this->url_parts[] = $value;\n                    }\n                }\n                \n                $this->params = $this->convertPartsToParams();\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function routeActionRequest() {\n        $return_params = array('controller'=>'','action'=>'','url_parts'=>array());\n    \n        // If we have three url parts we assume they are controller->action->id, otherwise split them out into name<=>value pairs\n        $return_params['controller'] = $this->url_parts[0]; // set the controller/module\n        $return_params['action'] = $this->url_parts[1];     // set the action\n\n        // Figure out if this is module or controller request - WE ONLY NEED THIS CODE UNTIL WE PULL OUT THE OLD MODULES\n        if (expModules::controllerExists($return_params['controller'])) {\n            $requestType = 'controller';\n//        } elseif (is_dir(BASE.'framework/modules-1/'.$return_params['controller'])) {\n//            $requestType = 'module';\n        } else {\n            return false;  //this is an invalid url return an let the calling function deal with it.\n        }\n\n        // now figure out the name<=>value pairs\n        if (count($this->url_parts) == 3) {\n            if ( is_numeric($this->url_parts[2])) {\n                $return_params['url_parts']['id'] = $this->url_parts[2];\n            }\n        } else {\n            for ($i = 2, $iMax = count($this->url_parts); $i < $iMax; $i++) {\n                if ($i % 2 == 0) {\n                    $return_params['url_parts'][$this->url_parts[$i]] = isset($this->url_parts[$i+1]) ? $this->url_parts[$i+1] : '';\n                }\n            }\n        }        \n\n        // Set the module or controller - this how the actual routing happens\n        $_REQUEST[$requestType] = $return_params['controller']; //url_parts[0];\n        $_GET[$requestType] = $return_params['controller'];\n        $_POST[$requestType] = $return_params['controller'];\n    \n        // Set the action for this module or controller\n        if ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            // most of the time we can just grab the action outta the POST array since this is passed as a hidden field, \n            // but sometimes it is actually set as the action on the form itself...then we get it from the params array instead.\n            $action = !empty($_POST['action']) ? $_POST['action'] : $this->params['action'];\n        } else {\n            $action = $return_params['action'];\n        }\n    \n        $_REQUEST['action'] = $action;\n        $_GET['action'] = $action;\n        $_POST['action'] = $action;\n\n        // pass off the name<=>value pairs\n        foreach($return_params['url_parts'] as $key=>$value) {\n            $save_value = expString::sanitize($value);\n            $_REQUEST[$key] = $save_value;\n            $_GET[$key] = $save_value;\n        }\n\n        return true;\n    }\n\n    public function buildCurrentUrl() {\n        $url =  URL_BASE;\n        if ($this->url_style == 'sef') {\n            $url .= substr(PATH_RELATIVE,0,-1).$this->sefPath;\n        } else {\n            $url .= urldecode((empty($_SERVER['REQUEST_URI'])) ? $_ENV['REQUEST_URI'] : $_SERVER['REQUEST_URI']);\n        }\n        return expString::escape(expString::sanitize($url));\n    }\n\n    public static function encode($url) {\n        $url = str_replace('&', 'and', $url);\n        return preg_replace(\"/(-)$/\", \"\", preg_replace('/(-){2,}/', '-', strtolower(preg_replace(\"/([^0-9a-z-_\\+])/i\", '-', $url))));\n    }\n    \n    public static function decode($url) {\n        $url = str_replace('-', ' ', $url);\n        return str_replace('+', '-', $url);\n    }\n\n    public function getSefUrlByPageId($id=null) {  //FIXME this method is never called and doesn't do anything as written\n        if (!empty($id)) {\n            global $db;\n\n            $section = $db->selectObject('section', 'id='.intval($id));\n            $url = URL_FULL;\n            $url .= !empty($section->sef_name) ? $section->sef_name : $section->name;\n        }\n    }\n\n    public function buildUrlByPageId($id=null) {\n        global $db;\n\n        //$url = URL_FULL;\n        $url = '';\n        if (!empty($id)) {\n            if (SEF_URLS == 1) {\n                $section = $db->selectObject('section', 'id='.intval($id));\n                if ($section->id != SITE_DEFAULT_SECTION) {\n                    $url .= !empty($section->sef_name) ? $section->sef_name : $section->name;\n                }\n            } else {\n                $url .= 'index.php?section='.$id;\n            }\n        }\n        return $url;\n    }\n\n    public function printerFriendlyLink($link_text=\"Printer Friendly\", $class=null, $width=800, $height=600, $view='', $title_text = \"Printer Friendly\") {\n        $url = '';\n        if (PRINTER_FRIENDLY != 1 && EXPORT_AS_PDF != 1) {\n            $class = !empty($class) ? $class : 'printer-friendly-link';\n            $url =  '<a class=\"'.$class.'\" href=\"javascript:void(0)\" onclick=\"window.open(\\'';\n            if (!empty($_REQUEST['view']) && !empty($view) && $_REQUEST['view'] != $view) {\n                $_REQUEST['view'] = $view;\n            }\n            if ($this->url_style == 'sef') {\n                $url .= $this->convertToOldSchoolUrl();\n                if (empty($_REQUEST['view']) && !empty($view)) $url .= '&view='.$view;\n                if ($this->url_type=='base') $url .= '/index.php?section='.SITE_DEFAULT_SECTION;\n            } else {\n                $url .= $this->current_url;\n            }\n            $url .= '&printerfriendly=1\\' , \\'mywindow\\',\\'menubar=1,resizable=1,scrollbars=1,width='.$width.',height='.$height.'\\');\"';\n            $url .= ' title=\"'.$title_text.'\"';\n            $url .= '> '.$link_text.'</a>';\n            $url = str_replace('&ajax_action=1','',$url);\n        }\n        \n        return $url; \n    }\n\n    public function exportAsPDFLink($link_text=\"Export as PDF\", $class=null, $width=800, $height=600, $view='', $orientation=false, $limit='', $title_text=\"Export as PDF\") {\n        $url = '';\n        if (EXPORT_AS_PDF != 1 && PRINTER_FRIENDLY != 1) {\n            $class = !empty($class) ? $class : 'export-pdf-link';\n            $url =  '<a class=\"'.$class.'\" href=\"javascript:void(0)\" onclick=\"window.open(\\'';\n            if (!empty($_REQUEST['view']) && !empty($view) && $_REQUEST['view'] != $view) {\n                $_REQUEST['view'] = $view;\n            }\n            if ($this->url_style == 'sef') {\n                $url .= $this->convertToOldSchoolUrl();\n                if (empty($_REQUEST['view']) && !empty($view)) $url .= '&view='.$view;\n                if ($this->url_type=='base') $url .= '/index.php?section='.SITE_DEFAULT_SECTION;\n            } else {\n                $url .= $this->current_url;\n            }\n            if (!empty($orientation)) {\n                $orientation = '&landscapepdf='.$orientation;\n            }\n            if (!empty($limit)) {\n                $limit = '&limit='.$limit;\n            }\n            $url .= '&exportaspdf=1'.$orientation.$limit.'&\\' , \\'mywindow\\',\\'menubar=1,resizable=1,scrollbars=1,width='.$width.',height='.$height.'\\');\"';\n            $url .= ' title=\"'.$title_text.'\"';\n            $url .= '> '.$link_text.'</a>';\n            $url = str_replace('&ajax_action=1','',$url);\n        }\n\n        return $url;\n    }\n\n    public function convertToOldSchoolUrl() {\n        $params = $this->convertPartsToParams();\n        return $this->makeLink($params, true);\n    }\n\n    public function convertPartsToParams() {\n        $params = array();\n        if ($this->url_type == 'base') {\n            $params['section'] = SITE_DEFAULT_SECTION;\n        } elseif ($this->url_type == 'page') {\n            $section = $this->getPageByName(substr($this->sefPath,1));\n            $params['section'] = empty($section->id) ? null : $section->id;\n        } elseif ($this->url_type == 'action') {\n            $params['controller'] = $this->url_parts[0];\n            $params['action'] = !empty($this->url_parts[1]) ? $this->url_parts[1] : null;\n            for ($i = 2, $iMax = count($this->url_parts); $i < $iMax; $i++) {\n                if ($i % 2 == 0) {\n                    $params[$this->url_parts[$i]] = isset($this->url_parts[$i+1]) ? $this->url_parts[$i+1] : '';\n                }\n            }\n        } elseif ($this->url_type == 'post') {\n            if (isset($_REQUEST['PHPSESSID'])) unset($_REQUEST['PHPSESSID']);\n//            foreach($_REQUEST as $name=>$val) {\n////                if (get_magic_quotes_gpc()) $val = stripslashes($val);  // magic quotes fix??\n////                $params[$name] = $val;\n//                $params[$name] = expString::sanitize($val);  //FIXME need array sanitizer\n//            }\n//            if (empty($_REQUEST['route_sanitized']))\n                $params = expString::sanitize($_REQUEST);\n//            if (empty($data['route_sanitized'])) $_REQUEST['pre_sanitized'] = true;//FIXME debug test\n        }\n        //TODO: fully sanitize all params values here for ---We already do this!\n//        if (isset($params['src'])) $params['src'] = expString::sanitize(htmlspecialchars($params['src']));\n        return $params;\n    }\n\n    public function getPageByName($url_name) {\n        global $db;\n        \n        $section = null;\n        if (is_numeric($url_name)) {\n            $section = $db->selectObject('section', 'id=' . $url_name);\n            if ($section == null) $section = $db->selectObject('section', \"sef_name='\" . $url_name . \"'\");\n        } elseif ($this->url_type == 'base') {\n            // if we made it in here this is a request for http://www.baseurl.com\n            $section = $db->selectObject('section', 'id='.SITE_DEFAULT_SECTION);\n        } else {\n            $section = $db->selectObject('section', \"sef_name='\".$url_name.\"'\");\n        }\n        // if section is still empty then we should route the user to the search (cool new feature :-) )\n        // at some point we need to write a special action/view for the search module that lets the user\n        // know they were redirected to search since the page they tried to go to directly didn't exist.\n#       if (empty($section)) {\n#           header(\"Refresh: 0; url=\".$this->makeLink(array('module'=>'search', 'action'=>'search', 'search_string'=>$this->url_parts[0])), false, 404);\n#           exit();\n#       } else {\n#           return $section;\n#       }\n        return $section;\n    }\n    \n    private function buildSEFPath () {\n        // Apache\n        if (strpos($_SERVER['SERVER_SOFTWARE'],'Apache') !== false || strpos($_SERVER['SERVER_SOFTWARE'],'WebServerX') !== false) {\n            switch(php_sapi_name()) {\n                case \"cgi\":\n                    $this->sefPath = !empty($_SERVER['REQUEST_URI']) ? urldecode($_SERVER['REQUEST_URI']): null;\n                    break;\n                case \"cgi-fcgi\":\n                    if (isset($_SERVER['REDIRECT_URL']) && $_SERVER['REDIRECT_URL'] != PATH_RELATIVE.'index.php') {\n                        $this->sefPath = urldecode($_SERVER['REDIRECT_URL']);\n                    } elseif (!empty($_ENV['REQUEST_URI'])) {\n                        $this->sefPath = urldecode($_ENV['REQUEST_URI']);\n                    } else {\n                        $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n                    }\n                    break;\n                default:\n                    $this->sefPath = !empty($_SERVER['REDIRECT_URL']) ? urldecode($_SERVER['REDIRECT_URL']) : null;\n                    break;\n            }\n        // Lighty ???\n        } elseif (strpos(strtolower($_SERVER['SERVER_SOFTWARE']),'lighttpd') !== false) {\n            //FIXME, we still need a good lighttpd.conf rewrite config for sef_urls to work\n            if (isset($_SERVER['ORIG_PATH_INFO'])) {\n                $this->sefPath = urldecode($_SERVER['ORIG_PATH_INFO']);\n            } elseif (isset($_SERVER['REDIRECT_URI'])){\n                $this->sefPath = urldecode(substr($_SERVER['REDIRECT_URI'],9));\n            } elseif (isset($_SERVER['REQUEST_URI'])){\n                $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n            }\n        // Nginx ???\n        } elseif (strpos(strtolower($_SERVER['SERVER_SOFTWARE']),'nginx') !== false) {\n            $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n        } else {\n            $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n        }\n        \n        $this->sefPath = substr($this->sefPath,strlen(substr(PATH_RELATIVE,0,-1))); \n        if (strpos($this->sefPath,'/index.php') === 0) {\n            $this->sefPath = null;\n        }\n        \n\t\t//parse the ecommerce tracking code if present and include in the object\n        if(isset($_SERVER['argv']) && is_array($_SERVER['argv']))\n        {\n            foreach($_SERVER['argv'] as $set)\n            {\n                $s = explode(\"=\",$set);\n                if($s[0] == \"ectid\")\n                {\n                    $this->ectid = $s[1];    \n                }   \n            }            \n        }\n        if (substr($this->sefPath,-1) == \"/\") $this->sefPath = substr($this->sefPath,0,-1);\n        // sanitize it\n        $sefPath = explode('\">',$this->sefPath);  // remove any attempts to close the command\n        $this->sefPath = expString::escape(expString::sanitize($sefPath[0]));\n    }\n\n    public function getSection() {\n        global $db;\n\n        if (expTheme::inAction()) {\n            if (isset($_REQUEST['section'])) {\n                $section = $this->url_style==\"sef\" ? $this->getPageByName($_REQUEST['section'])->id : intval($_REQUEST['section']) ;\n            } else {\n                $section = (expSession::is_set('last_section') ? expSession::get('last_section') : SITE_DEFAULT_SECTION);\n            }\n        } else {\n            $section = (isset($_REQUEST['section']) ? intval($_REQUEST['section']) : SITE_DEFAULT_SECTION);\n        }\n        $testsection = $db->selectObject('section','id='.$section);\n        if (empty($testsection)) {\n            $section = SITE_DEFAULT_SECTION;\n        }\n        return $section;\n    }\n\n    public function getSectionObj($section) {\n        global $db;\n\n        if ($section == \"*\") {\n            $sectionObj = call_user_func(expModules::getModuleClassName($this->params['controller']) . \"::getSection\", $this->params);\n        } else {\n//            $sectionObj = $db->selectObject('section','id='. intval($section));\n            $sectionObj = new section(intval($section));\n        }\n//        $sectionObj = $db->selectObject('section','id='. intval($section));\n        if (!$sectionObj->canView()) {\n            define('AUTHORIZED_SECTION',0);\n        } else {\n            define('AUTHORIZED_SECTION',1);\n        }\n        if (!$sectionObj->isPublic()) {\n            define('PUBLIC_SECTION',0);\n        } else {\n            define('PUBLIC_SECTION',1);\n        }\n    \n        if (isset($_REQUEST['section'])) {\n            expSession::set('last_section', intval($_REQUEST['section']));\n        } elseif ($section == SITE_DEFAULT_SECTION) {\n            expSession::set('last_section', intval(SITE_DEFAULT_SECTION));\n        } else {\n            //expSession::unset('last_section');\n        }\n        return $sectionObj;\n    }\n    \n    public function getRouterMaps() {\n        $mapfile = BASE.'framework/core/router_maps.php';\n\t\tif (file_exists(BASE.'themes/'.DISPLAY_THEME.'/router_maps.php')) {\n\t\t\t$mapfile = BASE.'themes/'.DISPLAY_THEME.'/router_maps.php';\n        }\n\n        include_once($mapfile);\n        $this->maps = $maps;  // $maps is set by included $mapfile\n    }\n    \n    public function getTrackingId()\n    {        \n        if(isset($this->ectid)) return $this->ectid;\n        else return '';\n    }\n}\n\n?>"], "fixing_code": ["<?php\n##################################################\n#\n# Copyright (c) 2004-2016 OIC Group, Inc.\n#\n# This file is part of Exponent\n#\n# Exponent is free software; you can redistribute\n# it and/or modify it under the terms of the GNU\n# General Public License as published by the Free\n# Software Foundation; either version 2 of the\n# License, or (at your option) any later version.\n#\n# GPL: http://www.gnu.org/licenses/gpl.txt\n#\n##################################################\n\n/**\n * This is the class expRouter\n *\n * @package Subsystems\n * @subpackage Subsystems\n */\n\nclass expRouter {\n\n    private $maps = array();\n    public  $url_parts = '';\n    public  $current_url = '';\n    /**\n     * Type of url\n     * either 'base' (default page), 'page', 'action', or 'malformed'\n     * @var string\n     */\n    public  $url_type = '';\n    /**\n     * Style of url\n     * either 'sef' or 'query'\n     * @var string\n     */\n    public  $url_style = '';\n    public  $params = array();\n    public  $sefPath = null;\n    \n    function __construct() {\n        self::getRouterMaps();\n    }\n\n    /**\n     * remove trailing slash\n     *\n     * @param $fulllink\n     *\n     * @return string\n     */\n    public static function cleanLink($fulllink)\n    {           \n        if(substr($fulllink, -1) == '/') $fulllink = substr($fulllink, 0, -1);  \n        return $fulllink;                                   \n    }\n    \n    /**\n\t * Will build url to a module/page/etc (determined by what is passed to the $params array).\n\t *\n\t * @param array $params The params that are passed will determine what link is make\n\t *               section\n\t *               action\n\t *               sef_name\n\t *               module\n\t *               controller\n\t *               action\n\t *\n\t * @param bool $force_old_school Old School as in not SEF.\n\t *\n\t * @param bool $secure If you set $secure true but ENABLE_SSL is not turned on in the config this will be forced false\n\t *\n\t * @param bool $no_map Ignore router_maps\n     *\n\t * @return string A url\n\t */\n    public function makeLink($params, $force_old_school=false, $secure=false, $no_map=false) {\n        $secure = ENABLE_SSL == 1 ? $secure : false;  // check if this site can use SSL if not then force the link to not be secure\n        $linkbase =  $secure ? URL_BASE_SECURE : URL_BASE;\n        $linkbase .= SCRIPT_RELATIVE;\n                \n        if (isset($params['section']) && $params['section'] == SITE_DEFAULT_SECTION) {            \n            return self::cleanLink($linkbase);\n        }\n\n        // Check to see if SEF_URLS have been turned on in the site config\n        if (SEF_URLS == 1 && ($_SERVER[\"PHP_SELF\"] == PATH_RELATIVE.'index.php' || $_SERVER[\"PHP_SELF\"] == PATH_RELATIVE.'install/index.php') && $force_old_school == false) {\n            \n            if (isset($params['section']) && !isset($params['action'])) {                \n                if (empty($params['sef_name'])) {\n                    global $db;\n\n                    $params['sef_name'] = $db->selectValue('section', 'sef_name', 'id='.intval($params['section']));\n                }                               \n                return self::cleanLink($linkbase.$params['sef_name']);\n            } else {                \n                // initialize the link\n                $link = '';               \n        \n                // we need to add the change the module parameter to controller if it exists\n                // we can remove this snippit once the old modules are gone.\n                if (!empty($params['module']) && empty($params['controller'])) $params['controller'] = $params['module'];\n            \n                // check to see if we have a router mapping for this controller/action\n                if (empty($no_map)){\n                    for ($i = 0, $iMax = count($this->maps); $i < $iMax; $i++) {\n                        $missing_params = array(\"dump\");\n\n                        if ((!empty($params) && !empty($params['controller']) && !empty($params['action'])) && (in_array($params['controller'], $this->maps[$i]) && in_array($params['action'], $this->maps[$i]) && (!isset($this->maps[$i]['src']) || in_array($params['src'], $this->maps[$i])))) {\n                            $missing_params = array_diff_key($this->maps[$i]['url_parts'], $params);\n                        }\n\n                        if (count($missing_params) == 0) {\n                            foreach($this->maps[$i]['url_parts'] as $key=>$value) {\n                                if ($key == 'controller') {\n                                    $link .= urlencode($value).\"/\";\n                                } else {\n                                    $link .= urlencode($params[$key]).\"/\";\n                                }\n                            }\n                            break;  // if this hits then we've found a match\n                        }\n                    }\n                }\n\n                // if we found a mapping for this link then we can return it now.\n                //if ($link != '') return self::encode($linkbase.$link);\n                if ($link != '') return self::cleanLink($linkbase.$link);\n                \n                if (!empty($params['controller'])) $link .= $params['controller'].'/';\n                if (!empty($params['action'])) $link .= $params['action'].'/';\n                foreach ($params as $key=>$value) {\n                    if(!is_array($value) && strpos($key,'__') !== 0 && $key !== 'PHPSESSID') {\n                        $value = trim($value);\n                        $key = trim($key);\n                        if ($value != \"\") {\n                            if ($key != 'module' && $key != 'action' && $key != 'controller') {\n                                if ($key != 'src') {\n                                    $link .= urlencode($key).\"/\".urlencode($value).\"/\";\n                                } else {\n                                    $link .= $key.\"/\".$value.\"/\";\n                                }\n                            }\n                        }\n                    }\n                }\n                //trim last / off                 \n                return self::cleanLink($linkbase.$link);\n            }\n        } else {\n            // if the users don't have SEF URL's turned on then we make the link the old school way.\n            if (!empty($params['sef_name'])) unset($params['sef_name']);\n            $link = $linkbase . SCRIPT_FILENAME . \"?\";\n            foreach ($params as $key=>$value) {\n                if (!is_array($value) && strpos($key,'__') !== 0 && $key !== 'PHPSESSID'){\n                    $value = trim($value);\n                    $key = trim($key);\n                    if ($value != \"\") {\n                        if ($key != 'src') {\n                            $link .= urlencode($key).\"=\".urlencode($value).\"&\";\n                        } else {\n                            $link .= $key.\"=\".$value.\"&\";\n                        }                    \n                    }\n                }\n            }\n\n            $link = substr($link,0,-1);\n            return $link; // phillip: removed htmlspecialchars so that links return without parsing & to &amp; in URL strings\n            //return htmlspecialchars($link,ENT_QUOTES);\n        }\n    }\n\n    /**\n     * Returns a cleaner canonical link sans 'src' param\n     *\n     * @return string\n     */\n    public function plainPath() {\n        $params = $this->params;\n        unset($params['src']);\n        return $this->makeLink($params);\n    }\n\n    public function routeRequest() {\n        global $user;\n\n        // strip out possible xss exploits via url\n        foreach ($_GET as $key=>$var) {\n            if (is_string($var) && strpos($var,'\">')) {\n                unset(\n                    $_GET[$key],\n                    $_REQUEST[$key]\n                );\n            }\n        }\n        // conventional method to ensure the 'id' is only an id\n        if (isset($_REQUEST['id'])) {\n            if (isset($_GET['id']))\n                $_GET['id'] = intval($_GET['id']);\n            if (isset($_POST['id']))\n                $_POST['id'] = intval($_POST['id']);\n\n            $_REQUEST['id'] = intval($_REQUEST['id']);\n        }\n        // do the same for the other id's\n        foreach ($_REQUEST as $key=>$var) {\n            if (is_string($var) && strlen($key) >= 3 && strrpos($key,'_id',-3) !== false) {\n                if (isset($_GET[$key]))\n                    $_GET[$key] = intval($_GET[$key]);\n                if (isset($_POST[$key]))\n                    $_POST[$key] = intval($_POST[$key]);\n\n                $_REQUEST[$key] = intval($_REQUEST[$key]);\n            }\n        }\n        if (empty($user->id) || (!empty($user->id) && !$user->isAdmin())) {  //FIXME why would $user be empty here unless $db is down?\n//            $_REQUEST['route_sanitized'] = true;//FIXME debug test\n            expString::sanitize($_REQUEST);  // strip other exploits like sql injections\n        }\n\n        // start splitting the URL into it's different parts\n        $this->splitURL();\n        // edebug($this,1);\n\n        if ($this->url_style == 'sef') {\n            if ($this->url_type == 'page' || $this->url_type == 'base') {\n                $ret = $this->routePageRequest();               // if we hit this the formatting of the URL looks like the user is trying to go to a page.\n                if (!$ret) $this->url_type = 'malformed';\n            } elseif ($this->url_type == 'action') {\n                $this->isMappedURL();                       //check for a router map\n                $ret = $this->routeActionRequest();         // we didn't have a map for this URL.  Try to route it with this function.\n\n                // if this url wasn't a valid section, or action then kill it.  It might not actually be a \"bad\" url, \n                // but this is a precautionary measure against bad paths on images, css & js file, etc...with the new\n                // mod_rewrite rules these bad paths will not route thru here so we need to take them into account and\n                // deal with them accordingly.\n                if (!$ret) $this->url_type = 'malformed';  \n            } elseif ($this->url_type == 'post') {\n                // some forms aren't getting the controller field set right when the form is created\n                // we are putting this check here to safe guard against a controller being referred to as\n                // a module in the form.\n                if (!empty($_POST['controller']) || !empty($_POST['module'])) {\n                    $module = !empty($_POST['controller']) ? expString::sanitize($_POST['controller']) : expString::sanitize($_POST['module']);\n                    // Figure out if this is module or controller request - WE ONLY NEED THIS CODE UNTIL WE PULL OUT THE OLD MODULES\n                    if (expModules::controllerExists($module)) {\n                        $_POST['controller'] = $module;\n                        $_REQUEST['controller'] = $module;\n                    }\n                }\n            }\n        } elseif ($this->url_style == 'query' && SEF_URLS == 1 && !empty($_REQUEST['section']) && PRINTER_FRIENDLY != 1 && EXPORT_AS_PDF != 1) {\n            // if we hit this it's an old school url coming in and we're trying to use SEF's. \n            // we will send a permanent redirect so the search engines don't freak out about 2 links pointing\n            // to the same page.\n            header(\"Location: \".$this->makeLink(array('section'=>intval($_REQUEST['section']))),TRUE,301);          \n        }\n\n        // if this is a valid URL then we build out the current_url var which is used by flow, and possibly other places too\n        if ($this->url_type != 'malformed') {               \n            $this->current_url = $this->buildCurrentUrl();\n        } else {\n            // check if the URL is looking for a non-existent page or controller (we will check for bad action in renderAction())\n            // if page or controller is not found we will route to the not found controller.            \n            $_REQUEST['controller'] = 'notfound';\n            $_REQUEST['action'] = 'handle';\n        }\n    }\n\n    //FIXME what are we doing with this history? saving each page load\n    public function updateHistory($section=null) {\n        global $db,$user;\n\n        // if its not already set\n        // configurable tracking length\n        setcookie('UserUID',expSession::getTicketString(),86400 * TRACKING_COOKIE_EXPIRES);\n        $cookieID = (empty($_COOKIE['UserUID'])) ? expSession::getTicketString() : $_COOKIE['UserUID'];\n        // Build out the object to insert into the db.\n        // Get our parameters.\n        $tmpParams = array();\n        foreach ($this->params as $key=>$value) {\n            if ($key != 'module' && $key != 'action' && $key != 'controller' && $key != 'section') {\n                $tmpParams[$key] = $value;\n            }\n        }\n        $trackingObject = new stdClass();\n        $trackingObject->params = serialize($tmpParams);\n        if ($this->url_type == 'page' || $this->url_type == 'base') {\n            $trackingObject->section = $section;\n        } else {\n            $trackingObject->module = ($_SERVER['REQUEST_METHOD'] == 'POST') ? (empty($_POST['controller']) ? expString::sanitize($_POST['module']) : expString::sanitize($_POST['controller'])) : $this->url_parts[0];\n            $trackingObject->action = ($_SERVER['REQUEST_METHOD'] == 'POST') ? $_POST['action'] : $this->url_parts[1];\n        }\n        $trackingObject->referer = empty($_SERVER['HTTP_REFERER']) ? null : $_SERVER['HTTP_REFERER'];\n        $trackingObject->cookieUID = $cookieID;\n        $trackingObject->user_id = $user->id;\n        $trackingObject->timestamp = time();\n        $trackingObject->user_address = $_SERVER['REMOTE_ADDR'];\n        $trackingObject->user_agent = $_SERVER['HTTP_USER_AGENT'];\n        $trackingObject->session_id = $_COOKIE['PHPSESSID'];\n        $db->insertObject($trackingObject,'tracking_rawdata');\n    }\n\n    public function splitURL() {\n        global $db;\n\n        $this->url_parts = array();\n        $this->buildSEFPath();\n\n        if (!empty($this->sefPath)) {\n            $this->url_style = 'sef';\n            $this->url_parts = explode('/', $this->sefPath);     \n\n            // remove empty first and last url_parts if they exist\n            //if (empty($this->url_parts[count($this->url_parts)-1])) array_pop($this->url_parts);\n            if ($this->url_parts[count($this->url_parts)-1] == '') array_pop($this->url_parts);\n            if (empty($this->url_parts[0])) array_shift($this->url_parts);\n            \n            if (count($this->url_parts) < 1 || (empty($this->url_parts[0]) && count($this->url_parts) == 1) ) {\n                $this->url_type = 'base';  // no params\n            } elseif (count($this->url_parts) == 1 || $db->selectObject('section', \"sef_name='\" . substr($this->sefPath,1) . \"'\") != null) {\n                $this->url_type = 'page';  // single param is page name\n            } elseif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n                $this->url_type = 'post';  // params via form/post\n            } else {\n                // take a peek and see if a page exists with the same name as the first value...if so we probably have a page with\n                // extra perms...like printerfriendly=1 or ajax_action=1;\n                if (($db->selectObject('section', \"sef_name='\" . $this->url_parts[0] . \"'\") != null) && (in_array(array('printerfriendly','exportaspdf','ajax_action'), $this->url_parts))) {\n                    $this->url_type = 'page';\n                } else {\n                    $this->url_type = 'action';\n                }\n            }\n            $this->params = $this->convertPartsToParams();\n        } elseif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            $this->url_style = 'sef';\n            $this->url_type = 'post';\n            $this->params = $this->convertPartsToParams();\n        } elseif (isset($_SERVER['REQUEST_URI'])) {\n            // if we hit here, we don't really need to do much.  All the pertinent info will come thru in the POST/GET vars\n            // so we don't really need to worry about what the URL looks like.\n            if ($_SERVER['REQUEST_URI'] == PATH_RELATIVE) {\n                $this->url_type = 'base';\n                $this->params = array();\n            } else {\n                $sefPath = explode('%22%3E',$_SERVER['REQUEST_URI']);  // remove any attempts to close the command\n                $_SERVER['REQUEST_URI'] = $sefPath[0];\n                $this->url_style = 'query';\n            }\n        } else {\n            $this->url_type = 'base';\n            $this->params = array();\n        }\n                              \n        // Check if this was a printer friendly link request\n        define('PRINTER_FRIENDLY', (isset($_REQUEST['printerfriendly']) || isset($this->params['printerfriendly'])) ? 1 : 0);         \n        define('EXPORT_AS_PDF', (isset($_REQUEST['exportaspdf']) || isset($this->params['exportaspdf'])) ? 1 : 0);\n        define('EXPORT_AS_PDF_LANDSCAPE', (isset($_REQUEST['landscapepdf']) || isset($this->params['landscapepdf'])) ? 1 : 0);\n    }\n\n    public function routePageRequest() {        \n//        global $db;\n\n        if ($this->url_type == 'base') {\n            // if we made it in here this is a request for http://www.baseurl.com\n            if (expTheme::inAction()) {\n                $_REQUEST['section'] = (expSession::is_set('last_section') ? expSession::get('last_section') : SITE_DEFAULT_SECTION);\n            } else {\n                $_REQUEST['section'] = SITE_DEFAULT_SECTION;  \n            }\n        } else {\n            // Try to look up the page by sef_name first.  If that doesn't exist, strip out the dashes and\n            // check the regular page names.  If that still doesn't work then we'll redirect them to the \n            // search module using the page name as the search string.\n            $section = $this->getPageByName(substr($this->sefPath,1));\n            ########################################################\n            #FJD TODO:  this needs further refinement\n            #currently this requires a matching routerMap as such to work properly:\n            /*\n            $maps[] = array('controller'=>'store',\n                    'action'=>'showall',\n                    'url_parts'=>array(                \n                            'title'=>'(.*)'),\n            );\n            $maps[] = array('controller'=>'store',\n                    'action'=>'showByTitle',\n                    'url_parts'=>array(                \n                            'title'=>'(.*)'),\n            );\n            */\n            //if section is empty, we'll look for the page overrides first and route to \n            //routeActionRequest with some hand wacked variables. If we can't find an override\n            //then we'll return false as usual\n            // since we only received a single param and it wasn't a page, try for store category, or a product\n            if (empty($section)) {\n                $sef_url = $this->url_parts[0];\n                //check for a category\n                $c = new storeCategory();                \n                $cat = $c->findBy('sef_url', $sef_url);\n                if (empty($cat)) {\n                    //check for a product\n                    $p = new product();\n                    $prod = $p->findBy('sef_url', $sef_url);\n                    if(!empty($prod)) {\n                        //fake parts and route to action  \n                        $this->url_type = 'action';                   \n                        $this->url_parts[0] = 'store'; //controller\n                        $this->url_parts[1] = 'show'; //controller\n                        $this->url_parts[2] = 'title'; //controller\n                        $this->url_parts[3] = $sef_url; //controller\n                        //eDebug($this->url_parts,true);\n                        $this->params = $this->convertPartsToParams();\n                        return $this->routeActionRequest();\n                    }\n                    //else fall through\n                } else {\n                    //fake parts and route to action \n                    $this->url_type = 'action';                                      \n                    $this->url_parts[0] = 'store'; //controller\n                    $this->url_parts[1] = 'showall'; //controller\n                    $this->url_parts[2] = 'title'; //controller                    \n                    $this->url_parts[3] = $sef_url; //controller\n                    //eDebug($this->url_parts,true);\n                    $this->params = $this->convertPartsToParams();\n                    return $this->routeActionRequest();\n                }\n                return false;\n            }\n            #########################################################\n            //if (empty($section)) return false;  //couldnt find the page..let the calling action deal with it.\n            $_REQUEST['section'] = $section->id;\n        }\n        \n        expHistory::set('viewable', array('section'=>intval($_REQUEST['section'])));\n        return true;\n    }\n\n    /**\n     * figure out if this action is mapped via the mapping file (router_maps.php)\n     */\n    public function isMappedURL() {\n        $part_count = count($this->url_parts);\n        foreach ($this->maps as $map) {\n            $matched = true;\n            $pairs = array();\n            $i = 0;\n            if ($part_count == count($map['url_parts'])) {               \n                foreach($map['url_parts'] as $key=>$map_part) {\n                    $res = preg_match(\"/^$map_part/\", $this->url_parts[$i]);\n                    if ($res != 1) {\n                        $matched = false;\n                        break;\n                    } \n                    $pairs[$key] = $this->url_parts[$i];\n                    $i++;\n                }\n            } else {\n                $matched = false;\n            }            \n              \n            if ($matched) {\n                // safeguard against false matches when a real action was what the user really wanted.\n                if (count($this->url_parts) >= 2 && method_exists(expModules::getController($this->url_parts[0]), $this->url_parts[1]))\n                    return false;\n\n                $this->url_parts = array();\n                $this->url_parts[0] = $map['controller'];\n                $this->url_parts[1] = $map['action'];\n        \n                if (isset($map['view'])) {\n                    $this->url_parts[2] = 'view';\n                    $this->url_parts[3] = $map['view'];\n                }\n\n                foreach($map as $key=>$value) {\n                    if ($key != 'controller' && $key != 'action' && $key != 'view' && $key != 'url_parts') {\n                        $this->url_parts[] = $key;\n                        $this->url_parts[] = $value;\n                    }\n                }\n\n                foreach($pairs as $key=>$value) {\n                    if ($key != 'controller') {\n                        $this->url_parts[] = $key;\n                        $this->url_parts[] = $value;\n                    }\n                }\n                \n                $this->params = $this->convertPartsToParams();\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function routeActionRequest() {\n        $return_params = array('controller'=>'','action'=>'','url_parts'=>array());\n    \n        // If we have three url parts we assume they are controller->action->id, otherwise split them out into name<=>value pairs\n        $return_params['controller'] = $this->url_parts[0]; // set the controller/module\n        $return_params['action'] = $this->url_parts[1];     // set the action\n\n        // Figure out if this is module or controller request - WE ONLY NEED THIS CODE UNTIL WE PULL OUT THE OLD MODULES\n        if (expModules::controllerExists($return_params['controller'])) {\n            $requestType = 'controller';\n//        } elseif (is_dir(BASE.'framework/modules-1/'.$return_params['controller'])) {\n//            $requestType = 'module';\n        } else {\n            return false;  //this is an invalid url return an let the calling function deal with it.\n        }\n\n        // now figure out the name<=>value pairs\n        if (count($this->url_parts) == 3) {\n            if ( is_numeric($this->url_parts[2])) {\n                $return_params['url_parts']['id'] = $this->url_parts[2];\n            }\n        } else {\n            for ($i = 2, $iMax = count($this->url_parts); $i < $iMax; $i++) {\n                if ($i % 2 == 0) {\n                    $return_params['url_parts'][$this->url_parts[$i]] = isset($this->url_parts[$i+1]) ? $this->url_parts[$i+1] : '';\n                }\n            }\n        }        \n\n        // Set the module or controller - this how the actual routing happens\n        $_REQUEST[$requestType] = $return_params['controller']; //url_parts[0];\n        $_GET[$requestType] = $return_params['controller'];\n        $_POST[$requestType] = $return_params['controller'];\n    \n        // Set the action for this module or controller\n        if ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            // most of the time we can just grab the action outta the POST array since this is passed as a hidden field, \n            // but sometimes it is actually set as the action on the form itself...then we get it from the params array instead.\n            $action = !empty($_POST['action']) ? $_POST['action'] : $this->params['action'];\n        } else {\n            $action = $return_params['action'];\n        }\n    \n        $_REQUEST['action'] = $action;\n        $_GET['action'] = $action;\n        $_POST['action'] = $action;\n\n        // pass off the name<=>value pairs\n        foreach($return_params['url_parts'] as $key=>$value) {\n            $save_value = expString::sanitize($value);\n            $_REQUEST[$key] = $save_value;\n            $_GET[$key] = $save_value;\n        }\n\n        return true;\n    }\n\n    public function buildCurrentUrl() {\n        $url =  URL_BASE;\n        if ($this->url_style == 'sef') {\n            $url .= substr(PATH_RELATIVE,0,-1).$this->sefPath;\n        } else {\n            $url .= urldecode((empty($_SERVER['REQUEST_URI'])) ? $_ENV['REQUEST_URI'] : $_SERVER['REQUEST_URI']);\n        }\n        return expString::escape(expString::sanitize($url));\n    }\n\n    public static function encode($url) {\n        $url = str_replace('&', 'and', $url);\n        return preg_replace(\"/(-)$/\", \"\", preg_replace('/(-){2,}/', '-', strtolower(preg_replace(\"/([^0-9a-z-_\\+])/i\", '-', $url))));\n    }\n    \n    public static function decode($url) {\n        $url = str_replace('-', ' ', $url);\n        return str_replace('+', '-', $url);\n    }\n\n    public function getSefUrlByPageId($id=null) {  //FIXME this method is never called and doesn't do anything as written\n        if (!empty($id)) {\n            global $db;\n\n            $section = $db->selectObject('section', 'id='.intval($id));\n            $url = URL_FULL;\n            $url .= !empty($section->sef_name) ? $section->sef_name : $section->name;\n        }\n    }\n\n    public function buildUrlByPageId($id=null) {\n        global $db;\n\n        //$url = URL_FULL;\n        $url = '';\n        if (!empty($id)) {\n            if (SEF_URLS == 1) {\n                $section = $db->selectObject('section', 'id='.intval($id));\n                if ($section->id != SITE_DEFAULT_SECTION) {\n                    $url .= !empty($section->sef_name) ? $section->sef_name : $section->name;\n                }\n            } else {\n                $url .= 'index.php?section='.$id;\n            }\n        }\n        return $url;\n    }\n\n    public function printerFriendlyLink($link_text=\"Printer Friendly\", $class=null, $width=800, $height=600, $view='', $title_text = \"Printer Friendly\") {\n        $url = '';\n        if (PRINTER_FRIENDLY != 1 && EXPORT_AS_PDF != 1) {\n            $class = !empty($class) ? $class : 'printer-friendly-link';\n            $url =  '<a class=\"'.$class.'\" href=\"javascript:void(0)\" onclick=\"window.open(\\'';\n            if (!empty($_REQUEST['view']) && !empty($view) && $_REQUEST['view'] != $view) {\n                $_REQUEST['view'] = $view;\n            }\n            if ($this->url_style == 'sef') {\n                $url .= $this->convertToOldSchoolUrl();\n                if (empty($_REQUEST['view']) && !empty($view)) $url .= '&view='.$view;\n                if ($this->url_type=='base') $url .= '/index.php?section='.SITE_DEFAULT_SECTION;\n            } else {\n                $url .= $this->current_url;\n            }\n            $url .= '&printerfriendly=1\\' , \\'mywindow\\',\\'menubar=1,resizable=1,scrollbars=1,width='.$width.',height='.$height.'\\');\"';\n            $url .= ' title=\"'.$title_text.'\"';\n            $url .= '> '.$link_text.'</a>';\n            $url = str_replace('&ajax_action=1','',$url);\n        }\n        \n        return $url; \n    }\n\n    public function exportAsPDFLink($link_text=\"Export as PDF\", $class=null, $width=800, $height=600, $view='', $orientation=false, $limit='', $title_text=\"Export as PDF\") {\n        $url = '';\n        if (EXPORT_AS_PDF != 1 && PRINTER_FRIENDLY != 1) {\n            $class = !empty($class) ? $class : 'export-pdf-link';\n            $url =  '<a class=\"'.$class.'\" href=\"javascript:void(0)\" onclick=\"window.open(\\'';\n            if (!empty($_REQUEST['view']) && !empty($view) && $_REQUEST['view'] != $view) {\n                $_REQUEST['view'] = $view;\n            }\n            if ($this->url_style == 'sef') {\n                $url .= $this->convertToOldSchoolUrl();\n                if (empty($_REQUEST['view']) && !empty($view)) $url .= '&view='.$view;\n                if ($this->url_type=='base') $url .= '/index.php?section='.SITE_DEFAULT_SECTION;\n            } else {\n                $url .= $this->current_url;\n            }\n            if (!empty($orientation)) {\n                $orientation = '&landscapepdf='.$orientation;\n            }\n            if (!empty($limit)) {\n                $limit = '&limit='.$limit;\n            }\n            $url .= '&exportaspdf=1'.$orientation.$limit.'&\\' , \\'mywindow\\',\\'menubar=1,resizable=1,scrollbars=1,width='.$width.',height='.$height.'\\');\"';\n            $url .= ' title=\"'.$title_text.'\"';\n            $url .= '> '.$link_text.'</a>';\n            $url = str_replace('&ajax_action=1','',$url);\n        }\n\n        return $url;\n    }\n\n    public function convertToOldSchoolUrl() {\n        $params = $this->convertPartsToParams();\n        return $this->makeLink($params, true);\n    }\n\n    public function convertPartsToParams() {\n        $params = array();\n        if ($this->url_type == 'base') {\n            $params['section'] = SITE_DEFAULT_SECTION;\n        } elseif ($this->url_type == 'page') {\n            $section = $this->getPageByName(substr($this->sefPath,1));\n            $params['section'] = empty($section->id) ? null : $section->id;\n        } elseif ($this->url_type == 'action') {\n            $params['controller'] = $this->url_parts[0];\n            $params['action'] = !empty($this->url_parts[1]) ? $this->url_parts[1] : null;\n            for ($i = 2, $iMax = count($this->url_parts); $i < $iMax; $i++) {\n                if ($i % 2 == 0) {\n                    $params[$this->url_parts[$i]] = isset($this->url_parts[$i+1]) ? $this->url_parts[$i+1] : '';\n                }\n            }\n        } elseif ($this->url_type == 'post') {\n            if (isset($_REQUEST['PHPSESSID'])) unset($_REQUEST['PHPSESSID']);\n//            foreach($_REQUEST as $name=>$val) {\n////                if (get_magic_quotes_gpc()) $val = stripslashes($val);  // magic quotes fix??\n////                $params[$name] = $val;\n//                $params[$name] = expString::sanitize($val);  //FIXME need array sanitizer\n//            }\n//            if (empty($_REQUEST['route_sanitized']))\n                $params = expString::sanitize($_REQUEST);\n//            if (empty($data['route_sanitized'])) $_REQUEST['pre_sanitized'] = true;//FIXME debug test\n        }\n        //TODO: fully sanitize all params values here for ---We already do this!\n//        if (isset($params['src'])) $params['src'] = expString::sanitize(htmlspecialchars($params['src']));\n        return $params;\n    }\n\n    public function getPageByName($url_name) {\n        global $db;\n        \n        $section = null;\n        if (is_numeric($url_name)) {\n            $section = $db->selectObject('section', 'id=' . $url_name);\n            if ($section == null) $section = $db->selectObject('section', \"sef_name='\" . $url_name . \"'\");\n        } elseif ($this->url_type == 'base') {\n            // if we made it in here this is a request for http://www.baseurl.com\n            $section = $db->selectObject('section', 'id='.SITE_DEFAULT_SECTION);\n        } else {\n            $section = $db->selectObject('section', \"sef_name='\".$url_name.\"'\");\n        }\n        // if section is still empty then we should route the user to the search (cool new feature :-) )\n        // at some point we need to write a special action/view for the search module that lets the user\n        // know they were redirected to search since the page they tried to go to directly didn't exist.\n#       if (empty($section)) {\n#           header(\"Refresh: 0; url=\".$this->makeLink(array('module'=>'search', 'action'=>'search', 'search_string'=>$this->url_parts[0])), false, 404);\n#           exit();\n#       } else {\n#           return $section;\n#       }\n        return $section;\n    }\n    \n    private function buildSEFPath () {\n        // Apache\n        if (strpos($_SERVER['SERVER_SOFTWARE'],'Apache') !== false || strpos($_SERVER['SERVER_SOFTWARE'],'WebServerX') !== false) {\n            switch(php_sapi_name()) {\n                case \"cgi\":\n                    $this->sefPath = !empty($_SERVER['REQUEST_URI']) ? urldecode($_SERVER['REQUEST_URI']): null;\n                    break;\n                case \"cgi-fcgi\":\n                    if (isset($_SERVER['REDIRECT_URL']) && $_SERVER['REDIRECT_URL'] != PATH_RELATIVE.'index.php') {\n                        $this->sefPath = urldecode($_SERVER['REDIRECT_URL']);\n                    } elseif (!empty($_ENV['REQUEST_URI'])) {\n                        $this->sefPath = urldecode($_ENV['REQUEST_URI']);\n                    } else {\n                        $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n                    }\n                    break;\n                default:\n                    $this->sefPath = !empty($_SERVER['REDIRECT_URL']) ? urldecode($_SERVER['REDIRECT_URL']) : null;\n                    break;\n            }\n        // Lighty ???\n        } elseif (strpos(strtolower($_SERVER['SERVER_SOFTWARE']),'lighttpd') !== false) {\n            //FIXME, we still need a good lighttpd.conf rewrite config for sef_urls to work\n            if (isset($_SERVER['ORIG_PATH_INFO'])) {\n                $this->sefPath = urldecode($_SERVER['ORIG_PATH_INFO']);\n            } elseif (isset($_SERVER['REDIRECT_URI'])){\n                $this->sefPath = urldecode(substr($_SERVER['REDIRECT_URI'],9));\n            } elseif (isset($_SERVER['REQUEST_URI'])){\n                $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n            }\n        // Nginx ???\n        } elseif (strpos(strtolower($_SERVER['SERVER_SOFTWARE']),'nginx') !== false) {\n            $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n        } else {\n            $this->sefPath = urldecode($_SERVER['REQUEST_URI']);\n        }\n        \n        $this->sefPath = substr($this->sefPath,strlen(substr(PATH_RELATIVE,0,-1))); \n        if (strpos($this->sefPath,'/index.php') === 0) {\n            $this->sefPath = null;\n        }\n        \n\t\t//parse the ecommerce tracking code if present and include in the object\n        if(isset($_SERVER['argv']) && is_array($_SERVER['argv']))\n        {\n            foreach($_SERVER['argv'] as $set)\n            {\n                $s = explode(\"=\",$set);\n                if($s[0] == \"ectid\")\n                {\n                    $this->ectid = $s[1];    \n                }   \n            }            \n        }\n        if (substr($this->sefPath,-1) == \"/\") $this->sefPath = substr($this->sefPath,0,-1);\n        // sanitize it\n        $sefPath = explode('\">',$this->sefPath);  // remove any attempts to close the command\n        $this->sefPath = expString::escape(expString::sanitize($sefPath[0]));\n    }\n\n    public function getSection() {\n        global $db;\n\n        if (expTheme::inAction()) {\n            if (isset($_REQUEST['section'])) {\n                $section = $this->url_style==\"sef\" ? $this->getPageByName($_REQUEST['section'])->id : intval($_REQUEST['section']) ;\n            } else {\n                $section = (expSession::is_set('last_section') ? expSession::get('last_section') : SITE_DEFAULT_SECTION);\n            }\n        } else {\n            $section = (isset($_REQUEST['section']) ? intval($_REQUEST['section']) : SITE_DEFAULT_SECTION);\n        }\n        $testsection = $db->selectObject('section','id='.$section);\n        if (empty($testsection)) {\n            $section = SITE_DEFAULT_SECTION;\n        }\n        return $section;\n    }\n\n    public function getSectionObj($section) {\n        global $db;\n\n        if ($section == \"*\") {\n            $sectionObj = call_user_func(expModules::getModuleClassName($this->params['controller']) . \"::getSection\", $this->params);\n        } else {\n//            $sectionObj = $db->selectObject('section','id='. intval($section));\n            $sectionObj = new section(intval($section));\n        }\n//        $sectionObj = $db->selectObject('section','id='. intval($section));\n        if (!$sectionObj->canView()) {\n            define('AUTHORIZED_SECTION',0);\n        } else {\n            define('AUTHORIZED_SECTION',1);\n        }\n        if (!$sectionObj->isPublic()) {\n            define('PUBLIC_SECTION',0);\n        } else {\n            define('PUBLIC_SECTION',1);\n        }\n    \n        if (isset($_REQUEST['section'])) {\n            expSession::set('last_section', intval($_REQUEST['section']));\n        } elseif ($section == SITE_DEFAULT_SECTION) {\n            expSession::set('last_section', intval(SITE_DEFAULT_SECTION));\n        } else {\n            //expSession::unset('last_section');\n        }\n        return $sectionObj;\n    }\n    \n    public function getRouterMaps() {\n        $mapfile = BASE.'framework/core/router_maps.php';\n\t\tif (file_exists(BASE.'themes/'.DISPLAY_THEME.'/router_maps.php')) {\n\t\t\t$mapfile = BASE.'themes/'.DISPLAY_THEME.'/router_maps.php';\n        }\n\n        include_once($mapfile);\n        $this->maps = $maps;  // $maps is set by included $mapfile\n    }\n    \n    public function getTrackingId()\n    {        \n        if(isset($this->ectid)) return $this->ectid;\n        else return '';\n    }\n}\n\n?>"], "filenames": ["framework/core/subsystems/expRouter.php"], "buggy_code_start_loc": [212], "buggy_code_end_loc": [213], "fixing_code_start_loc": [212], "fixing_code_end_loc": [213], "type": "CWE-89", "message": "Exponent CMS version 2.3.9 suffers from a sql injection vulnerability in framework/modules/ecommerce/controllers/cartController.php.", "other": {"cve": {"id": "CVE-2016-8898", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-24T17:29:00.850", "lastModified": "2019-05-28T16:07:46.823", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exponent CMS version 2.3.9 suffers from a sql injection vulnerability in framework/modules/ecommerce/controllers/cartController.php."}, {"lang": "es", "value": "Existe una vulnerabilidad en el Exponent CMS versi\u00f3n 2.3.9, sufre una vulnerabilidad de inyecci\u00f3n de SQL en el archivo framework/modules/ecommerce/controllers/cartController.php."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exponentcms:exponent_cms:2.3.9:*:*:*:*:*:*:*", "matchCriteriaId": "12FDDF33-2B21-4F8A-AB9A-01857197E810"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/30/5", "source": "cve@mitre.org", "tags": ["Mailing List", "Exploit", "Third Party Advisory"]}, {"url": "https://github.com/exponentcms/exponent-cms/commit/99636b2118cd9af4eb9920f6b6c228bd824593d2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/exponentcms/exponent-cms/commit/99636b2118cd9af4eb9920f6b6c228bd824593d2"}}