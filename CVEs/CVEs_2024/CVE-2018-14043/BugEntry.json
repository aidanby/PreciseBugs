{"buggy_code": ["/* The MIT License (MIT)\n * \n * Copyright (c) 2015 Main Street Softworks, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"m_config.h\"\n\n#include <mstdlib/mstdlib.h>\n#include \"fs/m_fs_int.h\"\n#include \"platform/m_platform.h\"\n\n#ifndef _WIN32\n#  include <errno.h>\n#  include <unistd.h>\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/* Platform specific delete functions. */\n#ifdef _WIN32\nstatic M_fs_error_t M_fs_delete_file(const char *path)\n{\n\tif (!DeleteFile(path)) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* Requires the dir to be empty. Will fail if empty. */\nstatic M_fs_error_t M_fs_delete_dir(const char *path)\n{\n\tif (!RemoveDirectory(path)) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n#else\nstatic M_fs_error_t M_fs_delete_file(const char *path)\n{\n\tif (unlink(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* Requires the dir to be empty. Will fail if empty. */\nstatic M_fs_error_t M_fs_delete_dir(const char *path)\n{\n\tif (rmdir(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n#endif\n\nstatic M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n{\n\tM_fs_info_t *info1         = NULL;\n\tM_fs_info_t *info2         = NULL;\n\tchar        *bname;\n\tM_bool       file_info_dir = M_FALSE;\n\n\tif (M_str_isempty(p1) || M_str_isempty(p2) || new_p2 == NULL)\n\t\treturn M_FALSE;\n\n\tif (M_fs_info(&info1, p1, M_FS_PATH_INFO_FLAGS_BASIC) == M_FS_ERROR_SUCCESS     &&\n\t\t\tM_fs_info(&info2, p2, M_FS_PATH_INFO_FLAGS_BASIC) == M_FS_ERROR_SUCCESS &&\n\t\t\tM_fs_info_get_type(info1) != M_FS_TYPE_DIR                              &&\n\t\t\tM_fs_info_get_type(info2) == M_FS_TYPE_DIR)\n\t{\n\t\tfile_info_dir = M_TRUE;\n\t}\n\tM_fs_info_destroy(info1);\n\tM_fs_info_destroy(info2);\n\n\tif (!file_info_dir)\n\t\treturn M_FALSE;\n\n\tbname   = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\t*new_p2 = M_fs_path_join(p2, bname, M_FS_SYSTEM_AUTO);\n\tM_free(bname);\n\n\treturn M_TRUE;\n}\n\nstatic M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\n\t/* If we're not overwriting we need to verify existance.\n \t *\n \t * For files we need to check if the file name exists in the\n\t * directory it's being copied to.\n\t *\n\t * For directories we need to check if the directory name\n\t * exists in the directory it's being copied to.\n\t */\n\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\n\tif (type != M_FS_TYPE_DIR) {\n\t\t/* File exists at path. */\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Is dir */\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\n\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}\n\n/* Moves files and dirs.\n *\n * This will overwrite dest if it exists.\n *\n * The file and dir must be on the same volume for this to succeed. Unfortunately, \n * there isn't a good/easy way to know if the src and dest are on different volumes. The best solution\n * is to run this and check if the output fails with M_FS_ERROR_NOT_SAMEDEV and run a copy followed by\n * a delete if that is the case. */\nstatic M_fs_error_t M_fs_move_file(const char *path_old, const char *path_new)\n{\n\tM_fs_error_t  res;\n\n\t/* Try to move the file. This will (should) fail if the file is cross volume. */\n#ifdef _WIN32\n\tif (MoveFileEx(path_old, path_new, MOVEFILE_REPLACE_EXISTING))\n#else\n\tif (rename(path_old, path_new) == 0)\n#endif\n\t{\n\t\tres = M_FS_ERROR_SUCCESS;\n\t} else {\n#ifdef _WIN32\n\t\tres = M_fs_error_from_syserr(GetLastError());\n#else\n\t\tres = M_fs_error_from_syserr(errno);\n#endif\n\t}\n\n\treturn res;\n}\n\n/* Only copies files.\n *\n * This will overwrite dest if it exists.\n *\n * Uses the following process for a copy:\n *   - Open\n *   - Loop (while we hasn't read the entire file)\n *     - Read\n *     - Write\n *   - Close\n *\n * Note:\n * Unix does not have a copy equivalent of rename so we have to use this read/write approach. Windows\n * does have a copy function but we need progress reporting. Windows does have a progress reporting\n * callback but it uses a different prototype and doesn't report all the info we want so we're not\n * going to use it. */\nstatic M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)\n{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n \t * to new file. */\n\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n\t\t * between deleting and creating the file where someone could create the file and have access. However,\n\t\t * depending on the OS they may have access even if the file is created with no perms... */\n\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;\n\t\twhile (offset < read_len) {\n\t\t\tres          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);\n\t\t\toffset      += wrote_len;\n\t\t\twrote_total += wrote_len;\n\n\t\t\tif (cb) {\n\t\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\t\tM_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\t\tM_fs_progress_set_size_current_progress(progress, wrote_total);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t\t}\n\t\t\t\tif (!cb(progress)) {\n\t\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tM_fs_file_close(fd_old);\n\tM_fs_file_close(fd_new);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nM_fs_error_t M_fs_symlink(const char *target, const char *link_name)\n{\n\tif (target == NULL || *target == '\\0' || link_name == NULL || *link_name == '\\0')\n\t\treturn M_FS_ERROR_INVALID;\n\t\n#ifdef _WIN32\n\treturn M_FS_ERROR_GENERIC;\n#else\n\tif (symlink(link_name, target) == -1) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\nM_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar            *norm_path_old;\n\tchar            *norm_path_new;\n\tchar            *resolve_path;\n\tM_fs_info_t     *info;\n\tM_fs_progress_t *progress      = NULL;\n\tM_uint64         entry_size;\n\tM_fs_error_t     res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be moved \n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n \t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tif (cb) {\n\t\tentry_size = M_fs_info_get_size(info);\n\n\t\tM_fs_progress_set_path(progress, norm_path_new);\n\t\tM_fs_progress_set_type(progress, M_fs_info_get_type(info));\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, entry_size);\n\t\t\tM_fs_progress_set_size_total_progess(progress, entry_size);\n\t\t}\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, 1);\n\t\t\tM_fs_progress_set_count(progress, 1);\n\t\t}\n\t}\n\n\t/* Move the file. */\n\tif (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {\n\t\tres = M_fs_path_readlink(&resolve_path, norm_path_old);\n\t\tif (res == M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_fs_symlink(norm_path_new, resolve_path);\n\t\t}\n\t\tM_free(resolve_path);\n\t} else {\n\t\tres = M_fs_move_file(norm_path_old, norm_path_new);\n\t}\n\t/* Failure was because we're crossing mount points. */\n\tif (res == M_FS_ERROR_NOT_SAMEDEV) {\n\t\t/* Can't rename so copy and delete. */\n\t\tif (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {\n\t\t\t/* Success - Delete the original files since this is a move. */\n\t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t} else {\n\t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n\t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t\t}\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t} else {\n\t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_fs_info_destroy(info);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}\n\nM_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path_old;\n\tchar                   *norm_path_new;\n\tchar                   *join_path_old;\n\tchar                   *join_path_new;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_count         = 0;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\tM_fs_error_t            res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be copied\n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n \t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\ttype = M_fs_info_get_type(info);\n\n \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tentries = M_fs_dir_entries_create();\n\t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n\t * stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\tif (type == M_FS_TYPE_DIR) {\n\t\tif (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;\n\t\t} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\t/* Get all the files under the dir. */\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));\n\t}\n\n\t/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */\n\tM_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\ttotal_size = 0;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size += entry_size;\n\n\t\t\ttype = M_fs_dir_entry_get_type(entry);\n\t\t\t/* The total isn't the total number of files but the total number of operations. \n \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n\t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n\t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n\t\t\t * use that for the number of operations for the file. */\n\t\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\t\ttotal_count++;\n\t\t\t} else {\n\t\t\t\ttotal_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;\n\t\t\t}\n\t\t}\n\t\t/* Change the progress total size to reflect all entries. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, total_count);\n\t\t}\n\t}\n\tfor (i=0; i<len; i++) {\n\t\tentry         = M_fs_dir_entries_at(entries, i);\n\t\ttype          = M_fs_dir_entry_get_type(entry);\n\t\tjoin_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\tjoin_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\n\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\ttotal_size_progress += entry_size;\n\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_path(progress, join_path_new);\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t}\n\t\t}\n\n\t\t/* op */\n\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\tif (type == M_FS_TYPE_DIR) {\n\t\t\t\tres = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);\n\t\t\t} else if (type == M_FS_TYPE_SYMLINK) {\n\t\t\t\tres = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));\n\t\t\t} \n\t\t\tif (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {\n\t\t\t\tres = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);\n\t\t\t}\n\t\t} else {\n\t\t\tres = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));\n\t\t}\n\n\t\tM_free(join_path_old);\n\t\tM_free(join_path_new);\n\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res);\n\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t}\n\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n\tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}\n\nM_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path;\n\tchar                   *join_path;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\t/* The result that will be returned by this function. */\n\tM_fs_error_t            res;\n\t/* The result of the delete itself. */\n\tM_fs_error_t            res2;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\n\t/* Normalize the path we are going to delete so we have a valid path to pass around. */\n\tres = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We need the info to determine if the path is valid and because we need the type. */\n\tres = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We must know the type because there are different functions for deleting a file and deleting a directory. */\n\ttype = M_fs_info_get_type(info);\n\tif (type == M_FS_TYPE_UNKNOWN) {\n\t\tM_fs_info_destroy(info);\n\t\tM_free(norm_path);\n\t\treturn M_FS_ERROR_GENERIC;\n\t}\n\n\t/* Create a list of entries to store all the places we need to delete. */\n\tentries = M_fs_dir_entries_create();\n\n\t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n\t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n\t * directory is being walked. */\n\tif (type == M_FS_TYPE_DIR && remove_children) {\n\t\t/* We need to read the basic info if the we need to report the size totals to the cb. */\n\t\tif (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));\n\t}\n\n\t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n \t * it after a potential walk because we can't delete a directory that isn't empty.\n\t * Note: \n\t *   - The info will be owned by the entry and destroyed when it is destroyed. \n\t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n \t\t * new info as necessary. */\n\t\tprogress = M_fs_progress_create();\n\n\t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\t\ttotal_size += entry_size;\n\t\t\t}\n\t\t\t/* Change the progress total size to reflect all entries. */\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, len);\n\t\t}\n\t}\n\n\t/* Assume success. Set error if there is an error. */\n\tres = M_FS_ERROR_SUCCESS;\n\t/* Loop though all entries and delete. */\n\tfor (i=0; i<len; i++) {\n\t\tentry     = M_fs_dir_entries_at(entries, i);\n\t\tjoin_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\t/* Call the appropriate delete function. */\n\t\tif (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {\n\t\t\tres2 = M_fs_delete_dir(join_path);\n\t\t} else {\n\t\t\tres2 = M_fs_delete_file(join_path);\n\t\t}\n\t\t/* Set the return result to denote there was an error. The real error will be sent via the\n\t\t * progress callback for the entry. */\n\t\tif (res2 != M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t\t/* Set the progress data for the entry. */\n\t\tif (cb) {\n\t\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size_progress += entry_size;\n\n\t\t\tM_fs_progress_set_path(progress, join_path);\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res2);\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, i+1);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t}\n\t\tM_free(join_path);\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif (cb && !cb(progress)) {\n\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path);\n\treturn res;\n}\n", "/* The MIT License (MIT)\n *\n * Copyright (c) 2015 Main Street Softworks, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"m_config.h\"\n\n#include <mstdlib/mstdlib.h>\n#include \"fs/m_fs_int.h\"\n#include \"platform/m_platform.h\"\n\n#ifndef _WIN32\n#  include <errno.h>\n#  include <sys/types.h>\n#  include <unistd.h>\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic char M_fs_path_sep_win = '\\\\';\nstatic char M_fs_path_sep_unix = '/';\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic void M_fs_path_split(const char *path, char **dir, char **name, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tchar         *temp;\n\n\tif (dir == NULL && name == NULL)\n\t\treturn;\n\n\tif (dir != NULL)\n\t\t*dir = NULL;\n\tif (name != NULL)\n\t\t*name = NULL;\n\n\tif (path == NULL || *path == '\\0') {\n\t\tif (dir != NULL) {\n\t\t\t*dir = M_strdup(\".\");\n\t\t}\n\t\treturn;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts    = M_fs_path_componentize_path(path, sys_type);\n\ttemp     = M_list_str_take_at(parts, M_list_str_len(parts)-1);\n\n\tif (M_list_str_len(parts) == 0 && M_fs_path_isabs(path, sys_type)) {\n\t\tM_list_str_insert(parts, temp);\n\t\tM_free(temp);\n\t\ttemp = NULL;\n\t}\n\n\tif (temp != NULL && *temp == '\\0') {\n\t\tM_free(temp);\n\t\ttemp = NULL;\n\t}\n\n\tif (name != NULL) {\n\t\t*name = temp;\n\t} else {\n\t\tM_free(temp);\n\t}\n\n\tif (dir != NULL) {\n\t\t*dir = M_fs_path_join_parts(parts, sys_type);\n\t\tif (*dir == NULL) {\n\t\t\t*dir = M_strdup(\".\");\n\t\t}\n\t}\n\n\tM_list_str_destroy(parts);\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/* Figure out what system type to use for logic. */\nM_fs_system_t M_fs_path_get_system_type(M_fs_system_t sys_type)\n{\n\tif (sys_type == M_FS_SYSTEM_AUTO) {\n#ifdef _WIN32\n\t\treturn M_FS_SYSTEM_WINDOWS;\n#else\n\t\treturn M_FS_SYSTEM_UNIX;\n#endif\n\t}\n\treturn sys_type;\n}\n\n/* Get the appropriate separator for the system type. */\nchar M_fs_path_get_system_sep(M_fs_system_t sys_type)\n{\n\tif (M_fs_path_get_system_type(sys_type) == M_FS_SYSTEM_WINDOWS) {\n\t\treturn M_fs_path_sep_win;\n\t}\n\treturn M_fs_path_sep_unix;\n}\n\n\n/* Determine the max path length for the system. */\nsize_t M_fs_path_get_path_max(M_fs_system_t sys_type)\n{\n\tlong path_max = 0;\n\n\t/* Set some defaults based on the system type in case the path length isn't\n\t * actually defined anywhere. */\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Try to determine the path length */\n#ifdef PATH_MAX\n\tpath_max = PATH_MAX;\n#elif !defined(_WIN32)\n\tpath_max = pathconf(\"/\", _PC_PATH_MAX);\n#endif\n\n\t/* Ensure we didn't get an unreasonably long path. */\n\tif (path_max <= 0 || path_max > 65536) {\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\tpath_max = 260;\n\t\t} else {\n\t\t\tpath_max = 4096;\n\t\t}\n\t}\n\n\treturn (size_t)path_max;\n}\n\n/* Check if a path is an absolute path. A path is absolute if it's unix and\n * starrts with /. Or windows and starts with \\\\\\\\ (UNC) or a drive letter\n * followed by :. E.g. X:. */\nM_bool M_fs_path_isabs(const char *p, M_fs_system_t sys_type)\n{\n\tsize_t len;\n\n\tif (p == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\tlen = M_str_len(p);\n\tif (len == 0) {\n\t\treturn M_FALSE;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tif ((sys_type == M_FS_SYSTEM_WINDOWS && (M_fs_path_isunc(p) ||\n\t\t\t(len >= 2 && (p[1] == ':' || (p[0] == '\\\\' && p[1] == '\\\\'))))) ||\n\t\t(sys_type == M_FS_SYSTEM_UNIX && *p == '/'))\n\t{\n\t\treturn M_TRUE;\n\t}\n\n\treturn M_FALSE;\n}\n\nM_bool M_fs_path_isunc(const char *p)\n{\n\tif (p == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\tif (M_str_len(p) >= 2 && p[0] == '\\\\' && p[1] == '\\\\') {\n\t\treturn M_TRUE;\n\t}\n\n\treturn M_FALSE;\n}\n\n/* Take a path and split it into components. This will remove empty parts. An\n * absolute path starting with / will have the / replaced with an empty to\n * start the list. An empty at the start of the path list should be treated as\n * an abolute path. */\nM_list_str_t *M_fs_path_componentize_path(const char *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *list1;\n\tM_list_str_t *list2;\n\tM_list_str_t *list3;\n\tconst char   *const_temp;\n\tconst char   *const_temp2;\n\tsize_t len;\n\tsize_t len2;\n\tsize_t i;\n\tsize_t j;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\tlist1 = M_list_str_split('/', path, M_LIST_STR_NONE, M_FALSE);\n\tlist3 = M_list_str_create(M_LIST_STR_NONE);\n\tlen = M_list_str_len(list1);\n\tfor (i=0; i<len; i++) {\n\t\tconst_temp = M_list_str_at(list1, i);\n\t\tif (const_temp == NULL || *const_temp == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tlist2 = M_list_str_split('\\\\', const_temp, M_LIST_STR_NONE, M_FALSE);\n\t\tlen2 = M_list_str_len(list2);\n\t\tfor (j=0; j<len2; j++) {\n\t\t\tconst_temp2 = M_list_str_at(list2, j);\n\t\t\tif (const_temp2 == NULL || *const_temp2 == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tM_list_str_insert(list3, const_temp2);\n\t\t}\n\t\tM_list_str_destroy(list2);\n\t}\n\tM_list_str_destroy(list1);\n\n\tif ((sys_type == M_FS_SYSTEM_UNIX && M_fs_path_isabs(path, sys_type)) ||\n\t\t(sys_type == M_FS_SYSTEM_WINDOWS && M_fs_path_isunc(path)))\n\t{\n\t\tM_list_str_insert_at(list3, \"\", 0);\n\t}\n\n\treturn list3;\n}\n\n/* Take a list of path components and join them into a string separated by the\n * system path separator. */\nchar *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n \t * or a UNC path on Windows). */\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\n\tlen = M_list_str_len(parts);\n\n\t/* Join puts the sep between items. If there are no items then the sep\n\t * won't be written. */\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\n\t/* Handle windows abs path because they need two separators. */\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\t/* If we have 1 item we need to add two empties so we get the second separator. */\n\t\tcount = (len == 1) ? 2 : 1;\n\t\t/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\t/* We need to add an empty so we get a separator after the drive. */\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}\n\nchar *M_fs_path_join_vparts(M_fs_system_t sys_type, size_t num, ...)\n{\n\tM_list_str_t *parts;\n\tchar         *out;\n\tva_list       ap;\n\tsize_t        i;\n\n\tparts = M_list_str_create(M_LIST_STR_NONE);\n\tva_start(ap, num);\n\tfor (i=0; i<num; i++) {\n\t\tM_list_str_insert(parts, va_arg(ap, const char *));\n\t}\n\tva_end(ap);\n\n\tout = M_fs_path_join_parts(parts, sys_type);\n\tM_list_str_destroy(parts);\n\treturn out;\n}\n\n/* Combine two parts of a path into one. We don't use the M_fs_path_join_parts function because we are working exclusively\n * with relative paths. We don't want an empty p1 to put a dir sep for example. */\nchar *M_fs_path_join(const char *p1, const char *p2, M_fs_system_t sys_type)\n{\n\tM_buf_t *buf;\n\tchar     sep;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* If p2 is an absolute path we can't properly join it to another path... */\n\tif (M_fs_path_isabs(p2, sys_type))\n\t\treturn M_strdup(p2);\n\n\tbuf = M_buf_create();\n\tsep = M_fs_path_get_system_sep(sys_type);\n\n\t/* Don't add nothing if we have nothing. */\n\tif (p1 != NULL && *p1 != '\\0')\n\t\tM_buf_add_str(buf, p1);\n\t/* Only put a sep if we have two parts and we really need the sep (p1 doesn't end with a sep). */\n\tif (p1 != NULL && *p1 != '\\0' && p2 != NULL && *p2 != '\\0' && p1[M_str_len(p1)-1] != sep)\n\t\tM_buf_add_byte(buf, (unsigned char)sep);\n\t/* Don't add nothing if we have nothing. */\n\tif (p2 != NULL && *p2 != '\\0')\n\t\tM_buf_add_str(buf, p2);\n\n\treturn M_buf_finish_str(buf, NULL);\n}\n\nchar *M_fs_path_join_resolved(const char *path, const char *part, const char *resolved_name, M_fs_system_t sys_type)\n{\n\tchar *full_path;\n\tchar *dir;\n\tchar *rpath;\n\n\tif ((path == NULL || *path == '\\0') && (part == NULL || *part == '\\0') && (resolved_name == NULL || *resolved_name == '\\0'))\n\t\treturn NULL;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* If the resolved path is absolute we don't need to modify it. */\n\tif (M_fs_path_isabs(resolved_name, sys_type))\n\t\treturn M_strdup(resolved_name);\n\n\tfull_path = M_fs_path_join(path, part, sys_type);\n\tM_fs_path_split(full_path, &dir, NULL, sys_type);\n\tM_free(full_path);\n\n\trpath = M_fs_path_join(dir, resolved_name, sys_type);\n\tM_free(dir);\n\n\treturn rpath;\n}\n\n#ifdef _WIN32\nM_fs_error_t M_fs_path_readlink_int(char **out, const char *path, M_bool last, M_fs_path_norm_t flags, M_fs_system_t sys_type)\n{\n\t(void)path;\n\t(void)last;\n\t(void)flags;\n\t(void)sys_type;\n\t*out = NULL;\n\treturn M_FS_ERROR_SUCCESS;\n}\n#else\n#include <string.h>\nM_fs_error_t M_fs_path_readlink_int(char **out, const char *path, M_bool last, M_fs_path_norm_t flags, M_fs_system_t sys_type)\n{\n\tchar        *temp;\n\tssize_t      read_len;\n\tsize_t       path_max;\n\tint          errsv;\n\tM_fs_info_t *info;\n\n\tif (out == NULL || path == NULL) {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\t*out = NULL;\n\n\t/* Check if this is actually a symlink */\n\tif (M_fs_info(&info, path, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS) {\n\t\t/* Must not be a real path so it's not a symlink. */\n\t\treturn M_FS_ERROR_SUCCESS;\n\t}\n\tif (M_fs_info_get_type(info) != M_FS_TYPE_SYMLINK) {\n\t\t/* Real path but it's not a symlink. */\n\t\tM_fs_info_destroy(info);\n\t\treturn M_FS_ERROR_SUCCESS;\n\t}\n\tM_fs_info_destroy(info);\n\n\tpath_max = M_fs_path_get_path_max(sys_type);\n\ttemp     = M_malloc_zero(path_max);\n\n\t/* Try to follow the path as a symlink. */\n\tread_len = readlink(path, temp, path_max-1);\n\tif (read_len == -1) {\n\t\terrsv = errno;\n\t\tM_free(temp);\n\t\t/* Not a symlink. */\n\t\tif (errsv == EINVAL) {\n\t\t\treturn M_FS_ERROR_SUCCESS;\n\t\t}\n\t\t/* The location pointed to by the link does not exist. */\n\t\tif (errsv == ENOENT) {\n\t\t\tif ((flags & M_FS_PATH_NORM_SYMLINKS_FAILDNE && !last) || (flags & M_FS_PATH_NORM_SYMLINKS_FAILDNELAST && last)) {\n\t\t\t\treturn M_FS_ERROR_DNE;\n\t\t\t} else {\n\t\t\t\treturn M_FS_ERROR_SUCCESS;\n\t\t\t}\n\t\t}\n\t\treturn M_fs_error_from_syserr(errsv);\n\t} else {\n\t\t/* Appease coverity even though it is null termed on allocation */\n\t\ttemp[read_len] = '\\0';\n\t}\n\t/* this way out isn't massive if the path is small. */\n\t*out = M_strdup(temp);\n\tM_free(temp);\n\treturn M_FS_ERROR_SUCCESS;\n}\n#endif\n\nM_fs_error_t M_fs_path_readlink(char **out, const char *path)\n{\n\treturn M_fs_path_readlink_int(out, path, M_TRUE, M_FS_PATH_NORM_SYMLINKS_FAILDNELAST, M_FS_SYSTEM_AUTO);\n}\n\n\nM_fs_error_t M_fs_path_get_cwd(char **cwd)\n{\n\tchar   *temp;\n\tsize_t  path_max;\n#ifdef _WIN32\n\tDWORD   dpath_max;\n#endif\n\n\tif (cwd == NULL)\n\t\treturn M_FS_ERROR_INVALID;\n\t*cwd = NULL;\n\n\tpath_max = M_fs_path_get_path_max(M_FS_SYSTEM_AUTO)+1;\n\ttemp     = M_malloc(path_max);\n\n#ifdef _WIN32\n\tif (!M_win32_size_t_to_dword(path_max, &dpath_max))\n\t\treturn M_FS_ERROR_INVALID;\n\tif (GetCurrentDirectory(dpath_max, temp) == 0) {\n\t\tM_free(temp);\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n#else\n\tif (getcwd(temp, path_max) == NULL) {\n\t\tM_free(temp);\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\t*cwd = M_strdup(temp);\n\tM_free(temp);\n\treturn M_FS_ERROR_SUCCESS;\n}\n\nM_fs_error_t M_fs_path_set_cwd(const char *path)\n{\n\tif (path == NULL || *path == '\\0')\n\t\treturn M_FS_ERROR_INVALID;\n\n#ifdef _WIN32\n\tif (SetCurrentDirectory(path) == 0) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n#else\n\tif (chdir(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n#ifdef _WIN32\nM_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_bool have_info;\n\tM_bool ret;\n\n\tif ((path == NULL || *path == '\\0') && info == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\thave_info = (info == NULL) ? M_FALSE : M_TRUE;\n\tif (!have_info) {\n\t\tif (M_fs_info(&info, path, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS) {\n\t\t\treturn M_FALSE;\n\t\t}\n\t}\n\n\tret = M_fs_info_get_ishidden(info);\n\n\tif (!have_info) {\n\t\tM_fs_info_destroy(info);\n\t}\n\n\treturn ret;\n}\n#else\nM_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\n\t(void)info;\n\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\n\t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n \t * starts with a '.'. */\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\n\treturn ret;\n}\n#endif\n\nchar *M_fs_path_dirname(const char *path, M_fs_system_t sys_type)\n{\n\tchar *out;\n\n\tM_fs_path_split(path, &out, NULL, sys_type);\n\treturn out;\n}\n\nchar *M_fs_path_basename(const char *path, M_fs_system_t sys_type)\n{\n\tchar *out;\n\n\tM_fs_path_split(path, NULL, &out, sys_type);\n\treturn out;\n}\n\nchar *M_fs_path_user_confdir(M_fs_system_t sys_type)\n{\n\tchar         *out;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tres = M_fs_path_norm(&out, \"%APPDATA%\", M_FS_PATH_NORM_NONE, sys_type);\n#elif defined(__APPLE__)\n\tres = M_fs_path_norm(&out, \"~/Library/Application Support/\", M_FS_PATH_NORM_HOME, sys_type);\n#else\n\tres = M_fs_path_norm(&out, \"~/.config\", M_FS_PATH_NORM_HOME, sys_type);\n#endif\n\tif (res != M_FS_ERROR_SUCCESS)\n\t\treturn NULL;\n\treturn out;\n}\n\nchar *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Try Unix env var. */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\n\treturn out;\n}\n"], "fixing_code": ["/* The MIT License (MIT)\n * \n * Copyright (c) 2015 Main Street Softworks, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"m_config.h\"\n\n#include <mstdlib/mstdlib.h>\n#include \"fs/m_fs_int.h\"\n#include \"platform/m_platform.h\"\n\n#ifndef _WIN32\n#  include <errno.h>\n#  include <unistd.h>\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/* Platform specific delete functions. */\n#ifdef _WIN32\nstatic M_fs_error_t M_fs_delete_file(const char *path)\n{\n\tif (!DeleteFile(path)) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* Requires the dir to be empty. Will fail if empty. */\nstatic M_fs_error_t M_fs_delete_dir(const char *path)\n{\n\tif (!RemoveDirectory(path)) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n#else\nstatic M_fs_error_t M_fs_delete_file(const char *path)\n{\n\tif (unlink(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* Requires the dir to be empty. Will fail if empty. */\nstatic M_fs_error_t M_fs_delete_dir(const char *path)\n{\n\tif (rmdir(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n\treturn M_FS_ERROR_SUCCESS;\n}\n#endif\n\nstatic M_bool M_fs_isfileintodir(const char *p1, const char *p2, char **new_p2)\n{\n\tM_fs_info_t *info1         = NULL;\n\tM_fs_info_t *info2         = NULL;\n\tchar        *bname;\n\tM_bool       file_info_dir = M_FALSE;\n\n\tif (M_str_isempty(p1) || M_str_isempty(p2) || new_p2 == NULL)\n\t\treturn M_FALSE;\n\n\tif (M_fs_info(&info1, p1, M_FS_PATH_INFO_FLAGS_BASIC) == M_FS_ERROR_SUCCESS     &&\n\t\t\tM_fs_info(&info2, p2, M_FS_PATH_INFO_FLAGS_BASIC) == M_FS_ERROR_SUCCESS &&\n\t\t\tM_fs_info_get_type(info1) != M_FS_TYPE_DIR                              &&\n\t\t\tM_fs_info_get_type(info2) == M_FS_TYPE_DIR)\n\t{\n\t\tfile_info_dir = M_TRUE;\n\t}\n\tM_fs_info_destroy(info1);\n\tM_fs_info_destroy(info2);\n\n\tif (!file_info_dir)\n\t\treturn M_FALSE;\n\n\tbname   = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\t*new_p2 = M_fs_path_join(p2, bname, M_FS_SYSTEM_AUTO);\n\tM_free(bname);\n\n\treturn M_TRUE;\n}\n\n/* Used by copy and move to determine if we can write to the given path\n * based on a file already existing there or not.\n *\n * access is used to determine existence because we don't want to overwrite\n * if there already is a file. This is not guaranteed because if there is\n * a race condition where a file is created after this check it will be\n * overwritten. Not much we can do about that. It shouldn't pose a security\n * issue since this is more of a request than a requirement.\n */\nstatic M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\n\t/* If we're not overwriting we need to verify existance.\n \t *\n \t * For files we need to check if the file name exists in the\n\t * directory it's being copied to.\n\t *\n\t * For directories we need to check if the directory name\n\t * exists in the directory it's being copied to.\n\t */\n\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\n\tif (type != M_FS_TYPE_DIR) {\n\t\t/* File exists at path. */\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Is dir */\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\n\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}\n\n/* Moves files and dirs.\n *\n * This will overwrite dest if it exists.\n *\n * The file and dir must be on the same volume for this to succeed. Unfortunately, \n * there isn't a good/easy way to know if the src and dest are on different volumes. The best solution\n * is to run this and check if the output fails with M_FS_ERROR_NOT_SAMEDEV and run a copy followed by\n * a delete if that is the case. */\nstatic M_fs_error_t M_fs_move_file(const char *path_old, const char *path_new)\n{\n\tM_fs_error_t  res;\n\n\t/* Try to move the file. This will (should) fail if the file is cross volume. */\n#ifdef _WIN32\n\tif (MoveFileEx(path_old, path_new, MOVEFILE_REPLACE_EXISTING))\n#else\n\tif (rename(path_old, path_new) == 0)\n#endif\n\t{\n\t\tres = M_FS_ERROR_SUCCESS;\n\t} else {\n#ifdef _WIN32\n\t\tres = M_fs_error_from_syserr(GetLastError());\n#else\n\t\tres = M_fs_error_from_syserr(errno);\n#endif\n\t}\n\n\treturn res;\n}\n\n/* Only copies files.\n *\n * This will overwrite dest if it exists.\n *\n * Uses the following process for a copy:\n *   - Open\n *   - Loop (while we hasn't read the entire file)\n *     - Read\n *     - Write\n *   - Close\n *\n * Note:\n * Unix does not have a copy equivalent of rename so we have to use this read/write approach. Windows\n * does have a copy function but we need progress reporting. Windows does have a progress reporting\n * callback but it uses a different prototype and doesn't report all the info we want so we're not\n * going to use it. */\nstatic M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)\n{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n\t * to new file. */\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;\n\t\twhile (offset < read_len) {\n\t\t\tres          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);\n\t\t\toffset      += wrote_len;\n\t\t\twrote_total += wrote_len;\n\n\t\t\tif (cb) {\n\t\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\t\tM_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\t\tM_fs_progress_set_size_current_progress(progress, wrote_total);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t\t}\n\t\t\t\tif (!cb(progress)) {\n\t\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tM_fs_file_close(fd_old);\n\tM_fs_file_close(fd_new);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nM_fs_error_t M_fs_symlink(const char *target, const char *link_name)\n{\n\tif (target == NULL || *target == '\\0' || link_name == NULL || *link_name == '\\0')\n\t\treturn M_FS_ERROR_INVALID;\n\t\n#ifdef _WIN32\n\treturn M_FS_ERROR_GENERIC;\n#else\n\tif (symlink(link_name, target) == -1) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\nM_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar            *norm_path_old;\n\tchar            *norm_path_new;\n\tchar            *resolve_path;\n\tM_fs_info_t     *info;\n\tM_fs_progress_t *progress      = NULL;\n\tM_uint64         entry_size;\n\tM_fs_error_t     res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be moved \n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n\t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tif (cb) {\n\t\tentry_size = M_fs_info_get_size(info);\n\n\t\tM_fs_progress_set_path(progress, norm_path_new);\n\t\tM_fs_progress_set_type(progress, M_fs_info_get_type(info));\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, entry_size);\n\t\t\tM_fs_progress_set_size_total_progess(progress, entry_size);\n\t\t}\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, 1);\n\t\t\tM_fs_progress_set_count(progress, 1);\n\t\t}\n\t}\n\n\t/* Move the file. */\n\tif (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {\n\t\tres = M_fs_path_readlink(&resolve_path, norm_path_old);\n\t\tif (res == M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_fs_symlink(norm_path_new, resolve_path);\n\t\t}\n\t\tM_free(resolve_path);\n\t} else {\n\t\tres = M_fs_move_file(norm_path_old, norm_path_new);\n\t}\n\t/* Failure was because we're crossing mount points. */\n\tif (res == M_FS_ERROR_NOT_SAMEDEV) {\n\t\t/* Can't rename so copy and delete. */\n\t\tif (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {\n\t\t\t/* Success - Delete the original files since this is a move. */\n\t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t} else {\n\t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n\t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t\t}\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t} else {\n\t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_fs_info_destroy(info);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}\n\nM_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path_old;\n\tchar                   *norm_path_new;\n\tchar                   *join_path_old;\n\tchar                   *join_path_new;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_count         = 0;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\tM_fs_error_t            res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be copied\n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n\t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\ttype = M_fs_info_get_type(info);\n\n\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tentries = M_fs_dir_entries_create();\n\t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n\t * stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\tif (type == M_FS_TYPE_DIR) {\n\t\tif (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;\n\t\t} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\t/* Get all the files under the dir. */\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));\n\t}\n\n\t/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */\n\tM_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\ttotal_size = 0;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size += entry_size;\n\n\t\t\ttype = M_fs_dir_entry_get_type(entry);\n\t\t\t/* The total isn't the total number of files but the total number of operations. \n\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n\t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n\t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n\t\t\t * use that for the number of operations for the file. */\n\t\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\t\ttotal_count++;\n\t\t\t} else {\n\t\t\t\ttotal_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;\n\t\t\t}\n\t\t}\n\t\t/* Change the progress total size to reflect all entries. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, total_count);\n\t\t}\n\t}\n\tfor (i=0; i<len; i++) {\n\t\tentry         = M_fs_dir_entries_at(entries, i);\n\t\ttype          = M_fs_dir_entry_get_type(entry);\n\t\tjoin_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\tjoin_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\n\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\ttotal_size_progress += entry_size;\n\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_path(progress, join_path_new);\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t}\n\t\t}\n\n\t\t/* op */\n\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\tif (type == M_FS_TYPE_DIR) {\n\t\t\t\tres = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);\n\t\t\t} else if (type == M_FS_TYPE_SYMLINK) {\n\t\t\t\tres = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));\n\t\t\t} \n\t\t\tif (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {\n\t\t\t\tres = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);\n\t\t\t}\n\t\t} else {\n\t\t\tres = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));\n\t\t}\n\n\t\tM_free(join_path_old);\n\t\tM_free(join_path_new);\n\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res);\n\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t}\n\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n\tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}\n\nM_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path;\n\tchar                   *join_path;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\t/* The result that will be returned by this function. */\n\tM_fs_error_t            res;\n\t/* The result of the delete itself. */\n\tM_fs_error_t            res2;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\n\t/* Normalize the path we are going to delete so we have a valid path to pass around. */\n\tres = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We need the info to determine if the path is valid and because we need the type. */\n\tres = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We must know the type because there are different functions for deleting a file and deleting a directory. */\n\ttype = M_fs_info_get_type(info);\n\tif (type == M_FS_TYPE_UNKNOWN) {\n\t\tM_fs_info_destroy(info);\n\t\tM_free(norm_path);\n\t\treturn M_FS_ERROR_GENERIC;\n\t}\n\n\t/* Create a list of entries to store all the places we need to delete. */\n\tentries = M_fs_dir_entries_create();\n\n\t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n\t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n\t * directory is being walked. */\n\tif (type == M_FS_TYPE_DIR && remove_children) {\n\t\t/* We need to read the basic info if the we need to report the size totals to the cb. */\n\t\tif (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));\n\t}\n\n\t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n\t * it after a potential walk because we can't delete a directory that isn't empty.\n\t * Note: \n\t *   - The info will be owned by the entry and destroyed when it is destroyed. \n\t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n\t\t * new info as necessary. */\n\t\tprogress = M_fs_progress_create();\n\n\t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\t\ttotal_size += entry_size;\n\t\t\t}\n\t\t\t/* Change the progress total size to reflect all entries. */\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, len);\n\t\t}\n\t}\n\n\t/* Assume success. Set error if there is an error. */\n\tres = M_FS_ERROR_SUCCESS;\n\t/* Loop though all entries and delete. */\n\tfor (i=0; i<len; i++) {\n\t\tentry     = M_fs_dir_entries_at(entries, i);\n\t\tjoin_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\t/* Call the appropriate delete function. */\n\t\tif (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {\n\t\t\tres2 = M_fs_delete_dir(join_path);\n\t\t} else {\n\t\t\tres2 = M_fs_delete_file(join_path);\n\t\t}\n\t\t/* Set the return result to denote there was an error. The real error will be sent via the\n\t\t * progress callback for the entry. */\n\t\tif (res2 != M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t\t/* Set the progress data for the entry. */\n\t\tif (cb) {\n\t\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size_progress += entry_size;\n\n\t\t\tM_fs_progress_set_path(progress, join_path);\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res2);\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, i+1);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t}\n\t\tM_free(join_path);\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif (cb && !cb(progress)) {\n\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path);\n\treturn res;\n}\n", "/* The MIT License (MIT)\n *\n * Copyright (c) 2015 Main Street Softworks, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"m_config.h\"\n\n#include <mstdlib/mstdlib.h>\n#include \"fs/m_fs_int.h\"\n#include \"platform/m_platform.h\"\n\n#ifndef _WIN32\n#  include <errno.h>\n#  include <sys/types.h>\n#  include <unistd.h>\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic char M_fs_path_sep_win = '\\\\';\nstatic char M_fs_path_sep_unix = '/';\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic void M_fs_path_split(const char *path, char **dir, char **name, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tchar         *temp;\n\n\tif (dir == NULL && name == NULL)\n\t\treturn;\n\n\tif (dir != NULL)\n\t\t*dir = NULL;\n\tif (name != NULL)\n\t\t*name = NULL;\n\n\tif (path == NULL || *path == '\\0') {\n\t\tif (dir != NULL) {\n\t\t\t*dir = M_strdup(\".\");\n\t\t}\n\t\treturn;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts    = M_fs_path_componentize_path(path, sys_type);\n\ttemp     = M_list_str_take_at(parts, M_list_str_len(parts)-1);\n\n\tif (M_list_str_len(parts) == 0 && M_fs_path_isabs(path, sys_type)) {\n\t\tM_list_str_insert(parts, temp);\n\t\tM_free(temp);\n\t\ttemp = NULL;\n\t}\n\n\tif (temp != NULL && *temp == '\\0') {\n\t\tM_free(temp);\n\t\ttemp = NULL;\n\t}\n\n\tif (name != NULL) {\n\t\t*name = temp;\n\t} else {\n\t\tM_free(temp);\n\t}\n\n\tif (dir != NULL) {\n\t\t*dir = M_fs_path_join_parts(parts, sys_type);\n\t\tif (*dir == NULL) {\n\t\t\t*dir = M_strdup(\".\");\n\t\t}\n\t}\n\n\tM_list_str_destroy(parts);\n}\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n/* Figure out what system type to use for logic. */\nM_fs_system_t M_fs_path_get_system_type(M_fs_system_t sys_type)\n{\n\tif (sys_type == M_FS_SYSTEM_AUTO) {\n#ifdef _WIN32\n\t\treturn M_FS_SYSTEM_WINDOWS;\n#else\n\t\treturn M_FS_SYSTEM_UNIX;\n#endif\n\t}\n\treturn sys_type;\n}\n\n/* Get the appropriate separator for the system type. */\nchar M_fs_path_get_system_sep(M_fs_system_t sys_type)\n{\n\tif (M_fs_path_get_system_type(sys_type) == M_FS_SYSTEM_WINDOWS) {\n\t\treturn M_fs_path_sep_win;\n\t}\n\treturn M_fs_path_sep_unix;\n}\n\n\n/* Determine the max path length for the system. */\nsize_t M_fs_path_get_path_max(M_fs_system_t sys_type)\n{\n\tlong path_max = 0;\n\n\t/* Set some defaults based on the system type in case the path length isn't\n\t * actually defined anywhere. */\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Try to determine the path length */\n#ifdef PATH_MAX\n\tpath_max = PATH_MAX;\n#elif !defined(_WIN32)\n\tpath_max = pathconf(\"/\", _PC_PATH_MAX);\n#endif\n\n\t/* Ensure we didn't get an unreasonably long path. */\n\tif (path_max <= 0 || path_max > 65536) {\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\tpath_max = 260;\n\t\t} else {\n\t\t\tpath_max = 4096;\n\t\t}\n\t}\n\n\treturn (size_t)path_max;\n}\n\n/* Check if a path is an absolute path. A path is absolute if it's unix and\n * starrts with /. Or windows and starts with \\\\\\\\ (UNC) or a drive letter\n * followed by :. E.g. X:. */\nM_bool M_fs_path_isabs(const char *p, M_fs_system_t sys_type)\n{\n\tsize_t len;\n\n\tif (p == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\tlen = M_str_len(p);\n\tif (len == 0) {\n\t\treturn M_FALSE;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tif ((sys_type == M_FS_SYSTEM_WINDOWS && (M_fs_path_isunc(p) ||\n\t\t\t(len >= 2 && (p[1] == ':' || (p[0] == '\\\\' && p[1] == '\\\\'))))) ||\n\t\t(sys_type == M_FS_SYSTEM_UNIX && *p == '/'))\n\t{\n\t\treturn M_TRUE;\n\t}\n\n\treturn M_FALSE;\n}\n\nM_bool M_fs_path_isunc(const char *p)\n{\n\tif (p == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\tif (M_str_len(p) >= 2 && p[0] == '\\\\' && p[1] == '\\\\') {\n\t\treturn M_TRUE;\n\t}\n\n\treturn M_FALSE;\n}\n\n/* Take a path and split it into components. This will remove empty parts. An\n * absolute path starting with / will have the / replaced with an empty to\n * start the list. An empty at the start of the path list should be treated as\n * an abolute path. */\nM_list_str_t *M_fs_path_componentize_path(const char *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *list1;\n\tM_list_str_t *list2;\n\tM_list_str_t *list3;\n\tconst char   *const_temp;\n\tconst char   *const_temp2;\n\tsize_t len;\n\tsize_t len2;\n\tsize_t i;\n\tsize_t j;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\tlist1 = M_list_str_split('/', path, M_LIST_STR_NONE, M_FALSE);\n\tlist3 = M_list_str_create(M_LIST_STR_NONE);\n\tlen = M_list_str_len(list1);\n\tfor (i=0; i<len; i++) {\n\t\tconst_temp = M_list_str_at(list1, i);\n\t\tif (const_temp == NULL || *const_temp == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tlist2 = M_list_str_split('\\\\', const_temp, M_LIST_STR_NONE, M_FALSE);\n\t\tlen2 = M_list_str_len(list2);\n\t\tfor (j=0; j<len2; j++) {\n\t\t\tconst_temp2 = M_list_str_at(list2, j);\n\t\t\tif (const_temp2 == NULL || *const_temp2 == '\\0') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tM_list_str_insert(list3, const_temp2);\n\t\t}\n\t\tM_list_str_destroy(list2);\n\t}\n\tM_list_str_destroy(list1);\n\n\tif ((sys_type == M_FS_SYSTEM_UNIX && M_fs_path_isabs(path, sys_type)) ||\n\t\t(sys_type == M_FS_SYSTEM_WINDOWS && M_fs_path_isunc(path)))\n\t{\n\t\tM_list_str_insert_at(list3, \"\", 0);\n\t}\n\n\treturn list3;\n}\n\n/* Take a list of path components and join them into a string separated by the\n * system path separator. */\nchar *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n\t * or a UNC path on Windows). */\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\n\tlen = M_list_str_len(parts);\n\n\t/* Join puts the sep between items. If there are no items then the sep\n\t * won't be written. */\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\n\t/* Handle windows abs path because they need two separators. */\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\t/* If we have 1 item we need to add two empties so we get the second separator. */\n\t\tcount = (len == 1) ? 2 : 1;\n\t\t/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\t/* We need to add an empty so we get a separator after the drive. */\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}\n\nchar *M_fs_path_join_vparts(M_fs_system_t sys_type, size_t num, ...)\n{\n\tM_list_str_t *parts;\n\tchar         *out;\n\tva_list       ap;\n\tsize_t        i;\n\n\tparts = M_list_str_create(M_LIST_STR_NONE);\n\tva_start(ap, num);\n\tfor (i=0; i<num; i++) {\n\t\tM_list_str_insert(parts, va_arg(ap, const char *));\n\t}\n\tva_end(ap);\n\n\tout = M_fs_path_join_parts(parts, sys_type);\n\tM_list_str_destroy(parts);\n\treturn out;\n}\n\n/* Combine two parts of a path into one. We don't use the M_fs_path_join_parts function because we are working exclusively\n * with relative paths. We don't want an empty p1 to put a dir sep for example. */\nchar *M_fs_path_join(const char *p1, const char *p2, M_fs_system_t sys_type)\n{\n\tM_buf_t *buf;\n\tchar     sep;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* If p2 is an absolute path we can't properly join it to another path... */\n\tif (M_fs_path_isabs(p2, sys_type))\n\t\treturn M_strdup(p2);\n\n\tbuf = M_buf_create();\n\tsep = M_fs_path_get_system_sep(sys_type);\n\n\t/* Don't add nothing if we have nothing. */\n\tif (p1 != NULL && *p1 != '\\0')\n\t\tM_buf_add_str(buf, p1);\n\t/* Only put a sep if we have two parts and we really need the sep (p1 doesn't end with a sep). */\n\tif (p1 != NULL && *p1 != '\\0' && p2 != NULL && *p2 != '\\0' && p1[M_str_len(p1)-1] != sep)\n\t\tM_buf_add_byte(buf, (unsigned char)sep);\n\t/* Don't add nothing if we have nothing. */\n\tif (p2 != NULL && *p2 != '\\0')\n\t\tM_buf_add_str(buf, p2);\n\n\treturn M_buf_finish_str(buf, NULL);\n}\n\nchar *M_fs_path_join_resolved(const char *path, const char *part, const char *resolved_name, M_fs_system_t sys_type)\n{\n\tchar *full_path;\n\tchar *dir;\n\tchar *rpath;\n\n\tif ((path == NULL || *path == '\\0') && (part == NULL || *part == '\\0') && (resolved_name == NULL || *resolved_name == '\\0'))\n\t\treturn NULL;\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* If the resolved path is absolute we don't need to modify it. */\n\tif (M_fs_path_isabs(resolved_name, sys_type))\n\t\treturn M_strdup(resolved_name);\n\n\tfull_path = M_fs_path_join(path, part, sys_type);\n\tM_fs_path_split(full_path, &dir, NULL, sys_type);\n\tM_free(full_path);\n\n\trpath = M_fs_path_join(dir, resolved_name, sys_type);\n\tM_free(dir);\n\n\treturn rpath;\n}\n\n#ifdef _WIN32\nM_fs_error_t M_fs_path_readlink_int(char **out, const char *path, M_bool last, M_fs_path_norm_t flags, M_fs_system_t sys_type)\n{\n\t(void)path;\n\t(void)last;\n\t(void)flags;\n\t(void)sys_type;\n\t*out = NULL;\n\treturn M_FS_ERROR_SUCCESS;\n}\n#else\n#include <string.h>\nM_fs_error_t M_fs_path_readlink_int(char **out, const char *path, M_bool last, M_fs_path_norm_t flags, M_fs_system_t sys_type)\n{\n\tchar        *temp;\n\tssize_t      read_len;\n\tsize_t       path_max;\n\tint          errsv;\n\tM_fs_info_t *info;\n\n\tif (out == NULL || path == NULL) {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\t*out = NULL;\n\n\t/* Check if this is actually a symlink */\n\tif (M_fs_info(&info, path, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS) {\n\t\t/* Must not be a real path so it's not a symlink. */\n\t\treturn M_FS_ERROR_SUCCESS;\n\t}\n\tif (M_fs_info_get_type(info) != M_FS_TYPE_SYMLINK) {\n\t\t/* Real path but it's not a symlink. */\n\t\tM_fs_info_destroy(info);\n\t\treturn M_FS_ERROR_SUCCESS;\n\t}\n\tM_fs_info_destroy(info);\n\n\tpath_max = M_fs_path_get_path_max(sys_type);\n\ttemp     = M_malloc_zero(path_max);\n\n\t/* Try to follow the path as a symlink. */\n\tread_len = readlink(path, temp, path_max-1);\n\tif (read_len == -1) {\n\t\terrsv = errno;\n\t\tM_free(temp);\n\t\t/* Not a symlink. */\n\t\tif (errsv == EINVAL) {\n\t\t\treturn M_FS_ERROR_SUCCESS;\n\t\t}\n\t\t/* The location pointed to by the link does not exist. */\n\t\tif (errsv == ENOENT) {\n\t\t\tif ((flags & M_FS_PATH_NORM_SYMLINKS_FAILDNE && !last) || (flags & M_FS_PATH_NORM_SYMLINKS_FAILDNELAST && last)) {\n\t\t\t\treturn M_FS_ERROR_DNE;\n\t\t\t} else {\n\t\t\t\treturn M_FS_ERROR_SUCCESS;\n\t\t\t}\n\t\t}\n\t\treturn M_fs_error_from_syserr(errsv);\n\t} else {\n\t\t/* Appease coverity even though it is null termed on allocation */\n\t\ttemp[read_len] = '\\0';\n\t}\n\t/* this way out isn't massive if the path is small. */\n\t*out = M_strdup(temp);\n\tM_free(temp);\n\treturn M_FS_ERROR_SUCCESS;\n}\n#endif\n\nM_fs_error_t M_fs_path_readlink(char **out, const char *path)\n{\n\treturn M_fs_path_readlink_int(out, path, M_TRUE, M_FS_PATH_NORM_SYMLINKS_FAILDNELAST, M_FS_SYSTEM_AUTO);\n}\n\n\nM_fs_error_t M_fs_path_get_cwd(char **cwd)\n{\n\tchar   *temp;\n\tsize_t  path_max;\n#ifdef _WIN32\n\tDWORD   dpath_max;\n#endif\n\n\tif (cwd == NULL)\n\t\treturn M_FS_ERROR_INVALID;\n\t*cwd = NULL;\n\n\tpath_max = M_fs_path_get_path_max(M_FS_SYSTEM_AUTO)+1;\n\ttemp     = M_malloc(path_max);\n\n#ifdef _WIN32\n\tif (!M_win32_size_t_to_dword(path_max, &dpath_max))\n\t\treturn M_FS_ERROR_INVALID;\n\tif (GetCurrentDirectory(dpath_max, temp) == 0) {\n\t\tM_free(temp);\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n#else\n\tif (getcwd(temp, path_max) == NULL) {\n\t\tM_free(temp);\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\t*cwd = M_strdup(temp);\n\tM_free(temp);\n\treturn M_FS_ERROR_SUCCESS;\n}\n\nM_fs_error_t M_fs_path_set_cwd(const char *path)\n{\n\tif (path == NULL || *path == '\\0')\n\t\treturn M_FS_ERROR_INVALID;\n\n#ifdef _WIN32\n\tif (SetCurrentDirectory(path) == 0) {\n\t\treturn M_fs_error_from_syserr(GetLastError());\n\t}\n#else\n\tif (chdir(path) != 0) {\n\t\treturn M_fs_error_from_syserr(errno);\n\t}\n#endif\n\n\treturn M_FS_ERROR_SUCCESS;\n}\n\n#ifdef _WIN32\nM_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_bool have_info;\n\tM_bool ret;\n\n\tif ((path == NULL || *path == '\\0') && info == NULL) {\n\t\treturn M_FALSE;\n\t}\n\n\thave_info = (info == NULL) ? M_FALSE : M_TRUE;\n\tif (!have_info) {\n\t\tif (M_fs_info(&info, path, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS) {\n\t\t\treturn M_FALSE;\n\t\t}\n\t}\n\n\tret = M_fs_info_get_ishidden(info);\n\n\tif (!have_info) {\n\t\tM_fs_info_destroy(info);\n\t}\n\n\treturn ret;\n}\n#else\nM_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\n\t(void)info;\n\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\n\t/* Hidden. Check if the first character of the last part of the path. Either the file or directory name itself\n\t * starts with a '.'. */\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\n\treturn ret;\n}\n#endif\n\nchar *M_fs_path_dirname(const char *path, M_fs_system_t sys_type)\n{\n\tchar *out;\n\n\tM_fs_path_split(path, &out, NULL, sys_type);\n\treturn out;\n}\n\nchar *M_fs_path_basename(const char *path, M_fs_system_t sys_type)\n{\n\tchar *out;\n\n\tM_fs_path_split(path, NULL, &out, sys_type);\n\treturn out;\n}\n\nchar *M_fs_path_user_confdir(M_fs_system_t sys_type)\n{\n\tchar         *out;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tres = M_fs_path_norm(&out, \"%APPDATA%\", M_FS_PATH_NORM_NONE, sys_type);\n#elif defined(__APPLE__)\n\tres = M_fs_path_norm(&out, \"~/Library/Application Support/\", M_FS_PATH_NORM_HOME, sys_type);\n#else\n\tres = M_fs_path_norm(&out, \"~/.config\", M_FS_PATH_NORM_HOME, sys_type);\n#endif\n\tif (res != M_FS_ERROR_SUCCESS)\n\t\treturn NULL;\n\treturn out;\n}\n\nchar *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Unix doens't have a fancy function to get the standard\n\t * temporary directory an application can use. Instead there\n\t * is a convoluted set of possible paths that could be used.\n\t *\n\t * We're going to go though each one in a priority order and\n\t * verify if we can read and write the directory. If so then\n\t * that's the one that will be used. We are fine using access\n\t * here because it doesn't matter if the path ends up being\n\t * changed out from underneath us later on. When it's used\n\t * at that time it will fail. Right now we just want to get\n\t * a path that can be tried. */\n\n\t/* Try Unix env vars.\n\t *\n\t * This is not ideal but a valid way to set the temporary directory\n\t * for a user. Per Single Unix Specification 4 and probably other things.\n\t */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\n\treturn out;\n}\n"], "filenames": ["base/fs/m_fs.c", "base/fs/m_fs_path.c"], "buggy_code_start_loc": [103, 257], "buggy_code_end_loc": [684, 605], "fixing_code_start_loc": [104, 257], "fixing_code_end_loc": [682, 621], "type": "CWE-732", "message": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.", "other": {"cve": {"id": "CVE-2018-14043", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-13T14:29:00.370", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data."}, {"lang": "es", "value": "mstdlib (tambien conocida como M Standard Library for C) 1.2.0 tiene un control de accesos a archivos incorrecto en situaciones en las que M_fs_perms_can_access intenta eliminar un archivo existente (que carece de acceso de lectura/escritura p\u00fablico) durante una operaci\u00f3n de copia. Esto est\u00e1 relacionado con fs/m_fs.c y fs/m_fs_path.c. Un atacante podr\u00eda crear el archivo y lograr acceso a los datos."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:monetra:mstdlib:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8B8EA34D-08C9-49D2-8053-E08FCDAFFC81"}]}]}], "references": [{"url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Monetra/mstdlib/issues/2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7"}}