{"buggy_code": ["<?php\n/*\n * diag_packet_capture.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2023 Rubicon Communications, LLC (Netgate)\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-packetcapture\n##|*NAME=Diagnostics: Packet Capture\n##|*DESCR=Allow access to the 'Diagnostics: Packet Capture' page.\n##|*MATCH=diag_packet_capture.php*\n##|-PRIV\n\nrequire_once('util.inc');\nrequire_once('interfaces_fast.inc');\nrequire_once('guiconfig.inc');\nrequire_once('pfsense-utils.inc');\nrequire_once('live_logs.inc');\nrequire_once('diag_packet_capture.inc');\n\n// Directory path where .pcap and .plog files will be stored.\n$pcap_files_root = g_get('tmp_path');\n\n/* Include relevant files in the list, keyed by the date in the file name. Sort\n * the file lists from oldest to newest, and store the newest file name. These\n * lists are used when clearing the .pcap and .plog files. File name example:\n * packetcapture-igb0.20-20220701000101.pcap\n * packetcapture-normal-lookup-20220701000101.plog\n*/\n$pcap_files_list = [];\nforeach (array_filter(glob(\"{$pcap_files_root}/packetcapture-*.pcap\"), 'is_file') as $file) {\n\tif (preg_match('/^.*-\\d{14}\\.pcap/i', $file)) {\n\t\t$pcap_files_list[strtotime(substr($file, -19, 14))] = $file;\n\t}\n}\nksort($pcap_files_list, SORT_NUMERIC);\n$pcap_file_last = empty($pcap_files_list) ? null : $pcap_files_list[array_key_last($pcap_files_list)];\n\n$plog_files_list = [];\nforeach (array_filter(glob(\"{$pcap_files_root}/packetcapture-*.plog\"), 'is_file') as $file) {\n\tif (preg_match('/^.*-\\d{14}\\.plog/i', $file)) {\n\t\t$plog_files_list[strtotime(substr($file, -19, 14))] = $file;\n\t}\n}\nksort($plog_files_list, SORT_NUMERIC);\n$plog_file_current = empty($plog_files_list) ? null : $plog_files_list[array_key_last($plog_files_list)];\n\n/* The file name in the AJAX POST call must match the file name from\n * $plog_file_current to avoid spoofed requests providing unintended access to\n * system files. */\nif (isset($_REQUEST['ajaxLog']) && $_REQUEST['file'] == $plog_file_current) {\n\tcheckForAjaxLog($plog_file_current);\n\texit;\n}\n\n/* Handle AJAX POST call for the tcpdump process check. */\nif ($_REQUEST['isCaptureRunning']) {\n\t/* Check for any matching tcpdump processes currently running.\n \t * Handle multiple matches; assume the first match is correct. */\n\t$processes_check = get_pgrep_output('^\\/usr\\/sbin\\/tcpdump.*-w -');\n\t$process_running = empty($processes_check) ? false : true;\n\n\techo ($process_running ? \"true\" : \"false\");\n\texit;\n}\n\n// Page properties\n$allowautocomplete = true;\nif ($_POST['download_button'] != '') {\n\t$nocsrf = true;\n}\n$pgtitle = array(gettext('Diagnostics'), gettext('Packet Capture'));\n\n$available_interfaces = get_interfaces_sorted();\n$max_view_size = 50 * 1024 * 1024; // Avoid timeout by only requesting 50MB at a time.\n\n$run_capture = false;\n$expression_string = '';\n$input_error = [];\n\n/* Actions taken on form button click */\nif ($_POST) {\n\tif (isset($_POST['start_button'])) {\n\t\t$action = 'start';\n\t\t$run_capture = true;\n\t} elseif (isset($_POST['stop_button'])) {\n\t\t$action = 'stop';\n\t} elseif (isset($_POST['view_button'])) {\n\t\t$action = 'view';\n\t} elseif (isset($_POST['download_button'])) {\n\t\t$action = 'download';\n\t} elseif (isset($_POST['clear_button'])) {\n\t\t$action = 'clear';\n\t}\n\n\t/* Save previous input to use on page load after submission */\n\t// capture options\n\t$input_interface = $_POST['interface'];\n\tif (!array_key_exists($input_interface, $available_interfaces)) {\n\t\t$input_error[] = 'No valid interface selected.';\n\t}\n\t$input_filter = ($_POST['filter'] !== null) ? intval($_POST['filter']) : null;\n\tif ($_POST['count'] == '0') {\n\t\t$input_count = 0;\n\t} else {\n\t\t$input_count = empty($_POST['count']) ? 1000 : $_POST['count'];\n\t}\n\t$input_length = empty($_POST['length']) ? 0 : $_POST['length'];\n\t$input_promiscuous = empty($_POST['promiscuous']) ? false : $_POST['promiscuous'];\n\t// view options\n\t$input_viewdetail = empty($_POST['viewdetail']) ? 'normal' : $_POST['viewdetail'];\n\t$input_viewtype = empty($_POST['viewtype']) ? 'default' : $_POST['viewtype'];\n\t$input_lookup = empty($_POST['lookup']) ? false : $_POST['lookup'];\n\n\t// filter options\n\t$filterattributes = [];\n\tif ($input_filter == PCAP_FPRESET_CUSTOM) {\n\t\t// Variables to pre-fill form input based on POST data\n\t\tif (isset($_POST['tagged_taglevel'])) {\n\t\t\t$input_tagged_taglevel = $_POST['tagged_taglevel'];\n\t\t}\n\n\t\tforeach ($_POST as $key => $value) {\n\t\t\t/* Only the \"match\" select element values need to be checked. Determine\n\t\t\t * the corresponding Section and Type from the element ID. */\n\t\t\tif (preg_match('/^untagged_[a-z]+_match$/i', $key)) {\n\t\t\t\t$fa_section = PCAP_SECTION_UNTAGGED;\n\t\t\t\t$fa_type_name = substr_replace(substr($key, 9), '', -6);\n\t\t\t} elseif (preg_match('/^tagged_[a-z]+_match$/i', $key)) {\n\t\t\t\t// The Section is determined by the tag level\n\t\t\t\t$fa_section = empty($_POST['tagged_taglevel']) ? PCAP_SECTION_TAGGED_MIN : $_POST['tagged_taglevel'];\n\t\t\t\t$fa_type_name = substr_replace(substr($key, 7), '', -6);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch ($fa_type_name) {\n\t\t\t\tcase 'ethertype':\n\t\t\t\t\t$fa_type = PCAP_TYPE_ETHERTYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'protocol':\n\t\t\t\t\t$fa_type = PCAP_TYPE_PROTOCOL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipaddress':\n\t\t\t\t\t$fa_type = PCAP_TYPE_IPADDRESS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'macaddress':\n\t\t\t\t\t$fa_type = PCAP_TYPE_MACADDRESS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'port':\n\t\t\t\t\t$fa_type = PCAP_TYPE_PORT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tag':\n\t\t\t\t\t$fa_type = PCAP_TYPE_VLAN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'section':\n\t\t\t\t\t$fa_type = PCAP_TYPE_SMATCH;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Other Types don't need to be checked.\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get this match's corresponding input element ID to retrieve its value\n\t\t\t$fa_id = substr_replace($key, '', -6);\n\n\t\t\t/* A Section's \"match\" select element is used for both the input value\n\t\t\t * and match operator. */\n\t\t\tif ($fa_type == PCAP_TYPE_SMATCH) {\n\t\t\t\t$fa_input = $fa_match = $value;\n\t\t\t} else {\n\t\t\t\t/* Check whether this match's selected value is the match operator or\n\t\t\t\t * the input value. */\n\t\t\t\tif (in_array($value, PCAP_LIST_MATCH)) {\n\t\t\t\t\t/* Get the match operator from the match, and the input\n\t\t\t\t\t * value from the corresponding input field. */\n\t\t\t\t\t$fa_input = isset($_POST[$fa_id]) ? $_POST[$fa_id] : '';\n\t\t\t\t\t$fa_match = $value;\n\t\t\t\t} else {\n\t\t\t\t\t/* Get the input value from the match and explicitly set\n\t\t\t\t\t * the match operator. */\n\t\t\t\t\t$fa_input = $value;\n\t\t\t\t\t$fa_match = PCAP_MATCH_ATTR_ANYOF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Generate variable variables to pre-fill form input based on POST data\n\t\t\t${'input_' . $key} = $value;\n\t\t\t${'input_' . $fa_id} = $_POST[$fa_id];\n\n\t\t\ttry {\n\t\t\t\t// Create a FilterAttribute object for a Section or Type\n\t\t\t\t$fa = new FilterAttribute($fa_section, $fa_match, $fa_type);\n\t\t\t\t$fa->setInputString($fa_input);\n\t\t\t} catch (Exception $e) {\n\t\t\t\t$input_error[] = $e->getMessage();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$filterattributes[] = $fa;\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\t// Create a FilterAttribute object for the Filter Preset\n\t\t\tif (is_int($input_filter)) {\n\t\t\t\t$filterattributes[] = new FilterAttribute(PCAP_SECTION_FPRESET, $input_filter, PCAP_TYPE_APRESET);\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"Invalid filter option given.\");\n\t\t\t}\n\t\t} catch (Exception $e) {\n\t\t\t$input_error[] = $e->getMessage();\n\t\t}\n\t}\n\n\t$vlan_supported = !preg_match('/^(lo\\d+|gif\\d+|gre\\d+|ppp\\d+|pppoe\\d+|pptp\\d+|l2tp\\d+|enc\\d+|ipsec\\d+|ovpn[sc]\\d+|tun_wg\\d+)/i', $input_interface);\n\ttry {\n\t\t$expression_string = get_expression_string($filterattributes, $vlan_supported);\n\t} catch (Exception $e) {\n\t\t$input_error[] = $e->getMessage();\n\t}\n\n\tif (!empty($input_error)) {\n\t\t$run_capture = false;\n\t}\n}\n\n// Header page HTML\ninclude('head.inc');\n\n// Show input validation errors only when trying to start the packet capture\nif (!empty($input_error) && $action == 'start') {\n\tprint_input_errors($input_error);\n}\n\n// Prepare the form buttons\n$form_buttons = [\n\t'stop_button' => [\n\t\t'class' => 'btn-warning',\n\t\t'value' => 'Stop',\n\t\t'icon' => 'fa-stop-circle'\n\t],\n\t'start_button' => [\n\t\t'class' => 'btn-success',\n\t\t'value' => 'Start',\n\t\t'icon' => 'fa-play-circle'\n\t],\n\t'view_button' => [\n\t\t'class' => 'btn-primary',\n\t\t'value' => 'View',\n\t\t'icon' => 'fa-file-text-o'\n\t],\n\t'download_button' => [\n\t\t'class' => 'btn-primary',\n\t\t'value' => 'Download',\n\t\t'icon' => 'fa-download'\n\t],\n\t'clear_button' => [\n\t\t'class' => 'btn-danger',\n\t\t'value' => 'Clear Captures',\n\t\t'icon' => 'fa-trash'\n\t]\n];\n\n// Handle button actions before displaying the form\nif ($action == 'stop') {\n\t/* Kill relevant running tcpdump processes (don't defer to background),\n \t * then verify if it's running. */\n\tmwexec(\"/bin/pkill -f '^\\/usr\\/sbin\\/tcpdump.*-w -'\");\n}\n/* Check for any matching tcpdump processes currently running.\n * Handle multiple matches; assume the first match is correct. */\n$processes_check = get_pgrep_output('^\\/usr\\/sbin\\/tcpdump.*-w -');\n$process_running = empty($processes_check) ? false : true;\n\n$show_last_capture_details = false;\nif ($process_running || $run_capture) {\n\t// Only show the Stop button\n\t$form_buttons['start_button']['class'] .= ' hidden';\n\t$form_buttons['view_button']['class'] .= ' hidden';\n\t$form_buttons['download_button']['class'] .= ' hidden';\n\t$form_buttons['clear_button']['class'] .= ' hidden';\n} else {\n\t// Show the Start button\n\t$form_buttons['stop_button']['class'] .= ' hidden';\n\tif (file_exists($pcap_file_last)) {\n\t\tif ($action == 'clear') {\n\t\t\t// Hide file buttons when clearing related files\n\t\t\t$form_buttons['view_button']['class'] .= ' hidden';\n\t\t\t$form_buttons['download_button']['class'] .= ' hidden';\n\t\t\t$form_buttons['clear_button']['class'] .= ' hidden';\n\n\t\t\t// Clear related files\n\t\t\tforeach ($pcap_files_list as $pcap_file) {\n\t\t\t\tunlink_if_exists($pcap_file);\n\t\t\t}\n\t\t\tforeach ($plog_files_list as $plog_file) {\n\t\t\t\tunlink_if_exists($plog_file);\n\t\t\t}\n\t\t} else {\n\t\t\t$show_last_capture_details = true;\n\t\t\tif ($action == 'download') {\n\t\t\t\tsend_user_download('file', $pcap_file_last);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Hide file buttons when no related files exist\n\t\t$form_buttons['view_button']['class'] .= ' hidden';\n\t\t$form_buttons['download_button']['class'] .= ' hidden';\n\t\t$form_buttons['clear_button']['class'] .= ' hidden';\n\t}\n}\n\n// Prepare the form variables\n// Packet capture filter options\n$form_filters = array(\n\tPCAP_FPRESET_CUSTOM => gettext('Custom Filter'),\n\tPCAP_FPRESET_ANY => gettext('Everything'),\n\tPCAP_FPRESET_UNTAGGED => gettext('Only Untagged'),\n\tPCAP_FPRESET_TAGGED => gettext('Only Tagged')\n);\n// View detail options\n$form_viewdetail = array(\n\t'normal' => gettext('Normal'),\n\t'medium' => gettext('Medium'),\n\t'high' => gettext('High'),\n\t'full' => gettext('Full')\n);\n// View type options\n$form_viewtype = array(\n\t'default' => gettext('Default Type'),\n\t'aodv' => 'AODV',\n\t'carp' => 'CARP',\n\t'cnfp' => 'CNFP',\n\t'lmp' => 'LMP',\n\t'pgm' => 'PGM',\n\t'pgm_zmtp1' => 'PGM_ZMTP1',\n\t'resp' => 'RESP',\n\t'radius' => 'RADIUS',\n\t'rpc' => 'RPC',\n\t'rtp' => 'RTP',\n\t'rtcp' => 'RTCP',\n\t'snmp' => 'SNMP',\n\t'tftp' => 'TFTP',\n\t'vat' => 'VAT',\n\t'wb' => 'WB',\n\t'zmtp1' => 'ZMTP1',\n\t'vxlan' => 'VXLAN'\n);\n// Section match selection fields\n$form_fsmatch = array(\n\tPCAP_MATCH_SECT_NONE => gettext('exclude all'),\n\tPCAP_MATCH_SECT_ANYOF => gettext('include any of')\n);\n$form_fsmatch_tagged = array(\n\tPCAP_MATCH_SECT_NONE => gettext('exclude all'),\n\tPCAP_MATCH_SECT_ANYOF => gettext('include any of')\n);\n// Type match selection fields\n$form_match_ipaddress = $form_match_macaddress = $form_match_port = array(\n\tPCAP_MATCH_ATTR_ANYOF => gettext('any of'),\n\tPCAP_MATCH_ATTR_ALLOF => gettext('all of'),\n\tPCAP_MATCH_ATTR_NONEOF => gettext('none of'),\n\tPCAP_MATCH_TYPE_ALLOF => gettext('OR all of'),\n\tPCAP_MATCH_TYPE_ANYOF => gettext('OR any of')\n);\n$form_match_tag = $form_match_protocol = $form_match_ethertype = array(\n\tPCAP_MATCH_ATTR_ANYOF => gettext('any of'),\n\tPCAP_MATCH_ATTR_NONEOF => gettext('none of'),\n\tPCAP_MATCH_TYPE_ANYOF => gettext('OR any of')\n);\n$form_match_ethertype +=  array(\n\t'ipv4' => '[IPv4]',\n\t'ipv6' => '[IPv6]',\n\t'arp' => '[ARP]'\n);\n$form_match_protocol += array(\n\t'icmp' => '[ICMPv4]',\n\t'icmp6' => '[ICMPv6]',\n\t'tcp' => '[TCP]',\n\t'udp' => '[UDP]',\n\t'ipsec' => '[IPsec]',\n\t'carp' => '[CARP]',\n\t'pfsync' => '[pfsync]',\n\t'ospf' => '[OSPF]'\n);\n// Variables for each Section\n$form_filter_section_begin_row = array('ipaddress', 'protocol');\n$form_filter_section_end_row = array('taglevel', 'macaddress', 'ethertype');\n$form_filter_sections = array(\n\t0 => array(\n\t\t'name' => 'untagged',\n\t\t'sectionlabel' => gettext('Untagged Filter'),\n\t\t'sectiondescription' => gettext('Filter options for packets without any VLAN tags.'),\n\t\t'matchdescription' => gettext('UNTAGGED PACKETS')\n\t),\n\t1 => array(\n\t\t'name' => 'tagged',\n\t\t'sectionlabel' => gettext('Tagged Filter'),\n\t\t'sectiondescription' => gettext('Filter options for packets that have a VLAN tag set. ' .\n\t\t    'Specify a tag level to match stacked VLAN packets (such as QinQ).'),\n\t\t'matchdescription' => gettext('TAGGED PACKETS')\n\t)\n);\n$form_filter_section_attributes_properties = array(\n\t'tag' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 100 200'),\n\t\t'description' => gettext('VLAN TAG'),\n\t\t'width' => 3\n\t),\n\t'taglevel' => array(\n\t\t'placeholder' => 1,\n\t\t'description' => gettext('LEVEL'),\n\t\t'width' => 1\n\t),\n\t'ipaddress' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 10.1.1.0/24 192.168.1.1'),\n\t\t'description' => gettext('HOST IP ADDRESS OR SUBNET'),\n\t\t'width' => 6\n\t),\n\t'macaddress' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 00:02 11:22:33:44:55:66'),\n\t\t'description' => gettext('HOST MAC ADDRESS'),\n\t\t'width' => 4\n\t),\n\t'protocol' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 17 tcp'),\n\t\t'description' => gettext('PROTOCOL'),\n\t\t'width' => 3\n\t),\n\t'port' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 80 443'),\n\t\t'description' => gettext('PORT NUMBER'),\n\t\t'width' => 3\n\t),\n\t'ethertype' => array(\n\t\t'placeholder' => gettext('EXAMPLE: arp 8100 0x8200'),\n\t\t'description' => gettext('ETHERTYPE'),\n\t\t'width' => 4\n\t)\n);\n\n// Default form input values\nif (!isset($input_filter)) {\n\t$input_filter = PCAP_FPRESET_CUSTOM;\n}\nif (!isset($input_promiscuous)) {\n\t$input_promiscuous = true;\n}\nif (!isset($input_viewdetail)) {\n\t$input_viewdetail = 'normal';\n}\nif (!isset($input_viewtype)) {\n\t$input_viewtype = 'default';\n}\nif (!isset($input_lookup)) {\n\t$input_lookup = false;\n}\nif (!isset($input_untagged_section_match)) {\n\t$input_untagged_section_match = PCAP_MATCH_SECT_ANYOF;\n}\nif (!isset($input_untagged_ipaddress_match)) {\n\t$input_untagged_ipaddress_match = PCAP_MATCH_ATTR_ALLOF;\n}\nif (!isset($input_tagged_ipaddress_match)) {\n\t$input_tagged_ipaddress_match = PCAP_MATCH_ATTR_ALLOF;\n}\n\n// Create the form\n$form = new Form(false);\n// Main panel\n$section = new Form_Section('Packet Capture Options');\n$group = new Form_Group('Capture Options');\n$group->add(new Form_Select(\n\t'interface',\n\tnull,\n\t$input_interface,\n\t$available_interfaces\n))->setHelp('Interface to capture packets on.')->setWidth(4);\n$group->add(new Form_Select(\n\t'filter',\n\tnull,\n\t$input_filter,\n\t$form_filters\n))->setHelp('Filter preset.')->addClass('match-selection')->setWidth(2);\n$section->add($group);\n$group = new Form_Group('');\n$group->add(new Form_Input(\n\t'count',\n\t'Packet Count',\n\tnull,\n\t$input_count,\n\tarray('type' => 'number', 'min' => 0, 'step' => 1)\n))->setHelp('Max number of packets to capture (default 1000). ' .\n            'Enter 0 (zero) for no limit.')->setWidth(2);\n$group->add(new Form_Input(\n\t'length',\n\t'Packet Length',\n\tnull,\n\t$input_length,\n\tarray('type' => 'number', 'min' => 0, 'step' => 1)\n))->setHelp('Max bytes per packet (default 0). ' . \n            'Enter 0 (zero) for no limit.')->setWidth(2);\n$group->add(new Form_Checkbox(\n\t'promiscuous',\n\tnull,\n\t'Promiscuous Mode',\n\t$input_promiscuous\n))->setHelp('Capture all traffic seen by the interface. Disable this option ' .\n            'to only capture traffic to and from the interface, including ' .\n            'broadcast and multicast traffic.')->setWidth(5);\n$section->add($group);\n$group = new Form_Group('View Options');\n$group->add(new Form_Select(\n\t'viewdetail',\n\t'View Detail',\n\t$input_viewdetail,\n\t$form_viewdetail\n))->setHelp('The level of detail shown when viewing the packet capture.')->setWidth(2);\n$group->add(new Form_Select(\n\t'viewtype',\n\t'View Type',\n\t$input_viewtype,\n\t$form_viewtype\n))->setHelp('Force the captured traffic to be interpreted as a specified type.')->setWidth(2);\n$group->add(new Form_Checkbox(\n\t'lookup',\n\tnull,\n\t'Name Lookup',\n\t$input_lookup\n))->setHelp('Perform a name lookup for port, host, and MAC addresses when ' .\n            'viewing the packet capture. This can cause significant delays ' .\n\t\t\t'due to reverse DNS lookups.')->setWidth(5);\n$section->add($group);\n\n// Show the last capture details on the main form section\nif ($show_last_capture_details) {\n\t$section->addInput(new Form_StaticText(\n\t\t'Last capture start',\n\t\tdate('F jS, Y g:i:s a.', strtotime(substr($pcap_file_last, -19, 14)))\n\t));\n\n\t$section->addInput(new Form_StaticText(\n\t\t'Last capture stop',\n\t\tdate('F jS, Y g:i:s a.', filemtime($pcap_file_last))\n\t));\n}\n\n$form->add($section);\n\n// Hidden panel\n$section = new Form_Section('Custom Filter Options');\n$section->addClass('custom-options');\n$section->addInput(new Form_StaticText(\n\t'Hint',\n\tsprintf('All input is %1$sspace-separated%2$s. When selecting a match ' .\n\t        'that specifies \"%1$sOR%2$s\", at least two Types should be ' .\n\t        'specified (such as Ethertype and Port). This will capture packets ' .\n\t        'that match either Type instead of exclusively both.',\n\t\t\t'<b>', '</b>')\n));\n// Add each Section\nforeach ($form_filter_sections as $fs_key => $fs_var) {\n\t$fs_name = $fs_var['name'];\n\t$fs_match_id           =       \"{$fs_name}_section_match\";\n\t$fs_match_input_varvar = \"input_{$fs_name}_section_match\";\n\n\t// Section header\n\t$section->addInput(new Form_StaticText(\n\t\t$fs_var['sectionlabel'],\n\t\t$fs_var['sectiondescription']\n\t));\n\n\t// Section match field\n\t$group = new Form_Group('');\n\t$group->addClass('no-separator');\n\t$group->add(new Form_Select(\n\t\t$fs_match_id,\n\t\tnull,\n\t\t${$fs_match_input_varvar},\n\t\t($fs_key == array_key_first($form_filter_sections) ? $form_fsmatch : $form_fsmatch_tagged)\n\t))->setHelp($fs_var['matchdescription'])->addClass('match-selection inputselectcombo')->setWidth(3);\n\t$group->add(new Form_StaticText(\n\t\tnull,\n\t\tnull\n\t))->setWidth(3);\n\n\t// Type fields\n\tforeach ($form_filter_section_attributes_properties as $attribute_name => $attribute_strings) {\n\t\t// Don't add VLAN Types in an untagged Section\n\t\tif ($fs_key == array_key_first($form_filter_sections)) {\n\t\t\tif ($attribute_name == 'tag') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($attribute_name == 'taglevel') {\n\t\t\t\t$section->add($group);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t// Variable variables for the Type fields\n\t\t$attribute_input_id     =       \"{$fs_name}_{$attribute_name}\";       // input element ID\n\t\t$attribute_match_id     =       \"{$fs_name}_{$attribute_name}_match\"; // select element ID\n\t\t$attribute_input_varvar = \"input_{$fs_name}_{$attribute_name}\";       // input element value\n\t\t$attribute_match_varvar = \"input_{$fs_name}_{$attribute_name}_match\"; // select element selected value\n\t\t$form_match_varvar = \"form_match_{$attribute_name}\";                  // select element options\n\n\t\t// Start a new row within this Section\n\t\tif (in_array($attribute_name, $form_filter_section_begin_row)) {\n\t\t\t$group = new Form_Group('');\n\t\t\t// Hide the row seperator for all but the last row.\n\t\t\tif ($attribute_name != $form_filter_section_begin_row[array_key_last($form_filter_section_begin_row)]) {\n\t\t\t\t$group->addClass('no-separator');\n\t\t\t}\n\t\t}\n\n\t\t// Add the Type field to the group\n\t\tswitch ($attribute_name) {\n\t\t\tcase 'taglevel':\n\t\t\t\t$attribute_field = new Form_Input(\n\t\t\t\t\t$attribute_input_id,\n\t\t\t\t\t$attribute_strings['placeholder'],\n\t\t\t\t\tnull,\n\t\t\t\t\t${$attribute_input_varvar},\n\t\t\t\t\tarray('type' => 'number', 'min' => 1, 'max' => 9, 'step' => 1)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$attribute_field = new Form_SelectInputCombo(\n\t\t\t\t\t$attribute_input_id,\n\t\t\t\t\t$attribute_strings['placeholder'],\n\t\t\t\t\t${$attribute_input_varvar}\n\t\t\t\t);\n\t\t\t\t$attribute_field->addSelect($attribute_match_id, ${$attribute_match_varvar}, ${$form_match_varvar});\n\t\t\t\tbreak;\n\t\t}\n\t\t$attribute_field->setHelp($attribute_strings['description'])->setWidth($attribute_strings['width']);\n\t\t$group->add($attribute_field);\n\n\t\t// Add the fields group to the form section when on the last Type of the row\n\t\tif (in_array($attribute_name, $form_filter_section_end_row)) {\n\t\t\t$section->add($group);\n\t\t}\n\t}\n}\n$form->add($section);\n\n// Add the form buttons\nforeach ($form_buttons as $button_id => $button) {\n\t$form->addGlobal(new Form_Button(\n\t\t$button_id,\n\t\t$button['value'],\n\t\tnull,\n\t\t$button['icon']\n\t))->addClass($button['class']);\n}\n\n/* Show the form */\necho $form;\n\n/* Show the capture */\nif ($action == 'stop' || $action == 'view' || $process_running || $run_capture) :\n\t$cmd_part_lookup = $input_lookup ? '' : ' -n';\n\tswitch ($input_viewdetail) {\n\t\tcase 'full':\n\t\t\t$cmd_part_viewdetail = ' -vv -e';\n\t\t\tbreak;\n\t\tcase 'high':\n\t\t\t$cmd_part_viewdetail = ' -vv';\n\t\t\tbreak;\n\t\tcase 'medium':\n\t\t\t$cmd_part_viewdetail = ' -v';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$input_viewdetail = 'normal';\n\t\t\t$cmd_part_viewdetail = ' -q';\n\t\t\tbreak;\n\t}\n\tswitch ($input_viewtype) {\n\t\tcase 'aodv': // Ad-hoc On-demand Distance Vector protocol\n\t\t\t$cmd_part_viewtype = ' -T aodv';\n\t\t\tbreak;\n\t\tcase 'carp': // Common Address Redundancy Protocol\n\t\t\t$cmd_part_viewtype = ' -T carp';\n\t\t\tbreak;\n\t\tcase 'cnfp': // Cisco NetFlow Protocol\n\t\t\t$cmd_part_viewtype = ' -T cnfp';\n\t\t\tbreak;\n\t\tcase 'lmp': // Link Management Protocol\n\t\t\t$cmd_part_viewtype = ' -T lmp';\n\t\t\tbreak;\n\t\tcase 'pgm': // Pragmatic General Multicast\n\t\t\t$cmd_part_viewtype = ' -T pgm';\n\t\t\tbreak;\n\t\tcase 'pgm_zmtp1': // ZMTP/1.0 inside PGM/EPGM\n\t\t\t$cmd_part_viewtype = ' -T pgm_zmtp1';\n\t\t\tbreak;\n\t\tcase 'resp': // REdis Serialization Protocol\n\t\t\t$cmd_part_viewtype = ' -T resp';\n\t\t\tbreak;\n\t\tcase 'radius': // RADIUS\n\t\t\t$cmd_part_viewtype = ' -T radius';\n\t\t\tbreak;\n\t\tcase 'rpc': // Remote Procedure Call\n\t\t\t$cmd_part_viewtype = ' -T rpc';\n\t\t\tbreak;\n\t\tcase 'rtp': // Real-Time Applications Protocol\n\t\t\t$cmd_part_viewtype = ' -T rtp';\n\t\t\tbreak;\n\t\tcase 'rtcp': // Real-Time Applications control Protocol\n\t\t\t$cmd_part_viewtype = ' -T rtcp';\n\t\t\tbreak;\n\t\tcase 'snmp': // Simple Network Management Protocol\n\t\t\t$cmd_part_viewtype = ' -T snmp';\n\t\t\tbreak;\n\t\tcase 'tftp': // Trivial File Transfer Protocol\n\t\t\t$cmd_part_viewtype = ' -T tftp';\n\t\t\tbreak;\n\t\tcase 'vat': // Visual Audio Tool\n\t\t\t$cmd_part_viewtype = ' -T vat';\n\t\t\tbreak;\n\t\tcase 'wb': // distributed White Board\n\t\t\t$cmd_part_viewtype = ' -T wb';\n\t\t\tbreak;\n\t\tcase 'zmtp1': // ZeroMQ Message Transport Protocol 1.0\n\t\t\t$cmd_part_viewtype = ' -T zmtp1';\n\t\t\tbreak;\n\t\tcase 'vxlan': // Virtual eXtensible Local Area Network\n\t\t\t$cmd_part_viewtype = ' -T vxlan';\n\t\t\tbreak;\n\t\tdefault: // Do not force a view type\n\t\t\t$input_viewtype = 'default';\n\t\t\t$cmd_part_viewtype = '';\n\t\t\tbreak;\n\t}\n\n\t/* Run tcpdump */\n\t$pcap_file_suffix = '-' . date('YmdHis');\n\t$plog_file_current = $pcap_files_root . '/packetcapture-'. $input_viewdetail . (empty($cmd_part_lookup) ? '' : '-lookup') . (empty($cmd_part_viewtype) ? '' : '-' . $input_viewtype) . $pcap_file_suffix . '.plog';\n\tif ($run_capture) {\n\t\t// Generate the file name to write to\n\t\t$pcap_file_current = $pcap_files_root . '/packetcapture-' . $input_interface . $pcap_file_suffix . '.pcap';\n\t\tunlink_if_exists($pcap_file_current);\n\t\tunlink_if_exists($plog_file_current);\n\n\t\t// Handle capture options\n\t\t$cmd_part_promiscuous = $input_promiscuous ? '' : ' -p';\n\t\t$cmd_part_count = empty($input_count) ? '' : \" -c {$input_count}\";\n\t\t$cmd_part_length = empty($input_length) ? '' : \" -s {$input_length}\";\n\t\t$cmd_expression_string = $expression_string ? escapeshellarg($expression_string) : '';\n\n\t\t/* Output in binary format (use packet-buffered to avoid missing packets) to stdout,\n\t\t* use tee to write the binary file and pipe the output,\n\t\t* use a second tcpdump process to parse the binary output,\n\t\t* lastly save the parsed output to a text file to read later. */\n\t\t$cmd_run = sprintf('/usr/sbin/tcpdump -ni %1$s%2$s%3$s%4$s -U -w - %6$s | /usr/bin/tee %5$s | /usr/sbin/tcpdump -l%7$s%8$s%9$s -r - | /usr/bin/tee %10$s',\n\t\t                $input_interface, $cmd_part_promiscuous, $cmd_part_count,\n\t\t                $cmd_part_length, $pcap_file_current, $cmd_expression_string,\n\t\t                $cmd_part_lookup, $cmd_part_viewdetail, $cmd_part_viewtype,\n\t\t                $plog_file_current);\n\t\t$process_running_cmd = strstr($cmd_run, ' |', TRUE);\n\t\tmwexec_bg($cmd_run);\n\t} else {\n\t\t$pcap_file_current = $pcap_file_last;\n\t\tif (!$process_running && !file_exists($plog_file_current)) {\n\t\t\t// Make sure the pcap log file is generated\n\t\t\t$cmd_run = sprintf('/usr/sbin/tcpdump%1$s%2$s%3$s -r %4$s | /usr/bin/tee %5$s', $cmd_part_lookup, $cmd_part_viewdetail, $cmd_part_viewtype, $pcap_file_current, $plog_file_current);\n\t\t\tmwexec_bg($cmd_run);\n\t\t}\n\t}\n\n\tif ($process_running || $run_capture) {\n\t\tif (!isset($process_running_cmd) && !empty($processes_check)) {\n\t\t\t$process_running_cmd = $processes_check[array_key_first($processes_check)];\n\t\t}\n\t\tprint_info_box(gettext('Running packet capture:') . '<br/>' . htmlspecialchars($process_running_cmd), 'info');\n\t}\n?>\n\n<!-- Packet Capture View -->\n<div class=\"panel panel-default\">\n\t<div class=\"panel-heading\">\n\t\t<?php\n\t\tif ($process_running || $run_capture) {\n\t\t\techo '<div style=\"float: right;\"><input style=\"margin: 4px 4px 0;\" type=\"checkbox\" checked=\"true\" id=\"autoscroll\">Auto-scroll</div>';\n\t\t}\n\t\t?>\n\t\t<h2 class=\"panel-title\"><?=sprintf('%1$s: %2$s', gettext('Packet Capture Output'), $pcap_file_current)?></h2>\n\t</div>\n\t<div class=\"panel-body\">\n\t\t<div class=\"form-group\">\n\t<?php\n\t// View the packet capture file contents\n\t$refreshOutput = true;\n\techo '<textarea class=\"form-control\" id=\"pcap_output\" rows=\"20\" overflow=\"hidden\" style=\"font-size: 13px; ' .\n\t      'font-family: consolas, monaco, roboto mono, liberation mono, courier; contain:strict\"></textarea>';\n\n\t?>\n\t\t\t<script>\n\t\t\t\toverrideScroll = false;\n\n\t\t\t\tfunction checkProcess() {\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl: \"diag_packet_capture.php\",\n\t\t\t\t\t\ttype: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tisCaptureRunning: \"ajax\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsuccess: function(result) {\n\t\t\t\t\t\t\tvar isRunning = result === \"false\" ? false : true;\n\t\t\t\t\t\t\tif (!isRunning) {\n\t\t\t\t\t\t\t\t$(\"#stop_button\")[0].classList.add(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#start_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#view_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#download_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#clear_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\".clearfix\")[0].classList.add(\"hidden\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction refreshOutput(bytes = 0) {\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl: \"diag_packet_capture.php\",\n\t\t\t\t\t\ttype: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tajaxLog: \"ajax\",\n\t\t\t\t\t\t\t\tbyte: bytes,\n\t\t\t\t\t\t\t\tmaxRead: <?=$max_view_size?>,\n\t\t\t\t\t\t\t\tfile: \"<?=$plog_file_current?>\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsuccess: function(result) {\n\t\t\t\t\t\t\tconst response = JSON.parse(result);\n\t\t\t\t\t\t\tvar output = document.querySelector('#pcap_output');\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\tif (!$process_running && !$run_capture) {\n\t\t\t\t\t\t\t\techo \"if (response.bytesRead > 0) {\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\n\t\t\t\t\t\t\tif (bytes == 0  & response.bytesRead > 0) {\n\t\t\t\t\t\t\t\toutput.textContent = \"\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If read returns 0 bytes check if tcpdump is still running\n\t\t\t\t\t\t\tif (response.bytesRead == 0) {\n\t\t\t\t\t\t\t\tcheckProcess();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.textContent += response.output;\n\t\t\t\t\t\t\tbytesRead = bytes + response.bytesRead;\n\n\t\t\t\t\t\t\tif (document.querySelector('#autoscroll').checked) {\n\t\t\t\t\t\t\t\toverrideScroll = true;\n\t\t\t\t\t\t\t\toutput.scrollTop = output.scrollHeight;\n\t\t\t\t\t\t\t\toverrideScroll = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsetTimeout(function() { refreshOutput(bytesRead) }, 2500);\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\tif (!$process_running && !$run_capture) {\n\t\t\t\t\t\t\t\techo \"}\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction handleScroll() {\n\t\t\t\t\tif (!overrideScroll) {\n\t\t\t\t\t\tvar output = document.querySelector('#pcap_output');\n\t\t\t\t\t\tif (output.scrollHeight <= (output.scrollTop + output.clientHeight)) {\n\t\t\t\t\t\t\tdocument.querySelector('#autoscroll').checked = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.querySelector('#autoscroll').checked = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t<?php\n\t\t\t\tif ($refreshOutput) {\n\t\t\t\t\tif ($process_running || $run_capture) {\n\t\t\t\t?>\n\t\t\t\t\t\tdocument.querySelector('#pcap_output').addEventListener(\"scroll\", handleScroll);\n\t\t\t\t<?php\n\t\t\t\t\t}\n\t\t\t\t?>\n\t\t\t\tsetTimeout(refreshOutput, 500);\n\t\t\t\t<?php\n\t\t\t\t}\n\t\t\t\t?>\n\t\t\t</script>\n\t\t</div>\n\t</div>\n</div>\n<?php\nendif;\n?>\n\n<script type=\"text/javascript\">\n//<![CDATA[\nevents.push(function() {\n\tconst PCAP_FPRESET_CUSTOM = <?=PCAP_FPRESET_CUSTOM?>;\n\tconst PCAP_MATCH_SECT_NONE = <?=PCAP_MATCH_SECT_NONE?>;\n\tconst PCAP_MATCH_SECT_ALLOF = <?=PCAP_MATCH_SECT_ALLOF?>;\n\tconst PCAP_MATCH_SECT_ANYOF = <?=PCAP_MATCH_SECT_ANYOF?>;\n\tconst PCAP_MATCH_TYPE_ALLOF = <?=PCAP_MATCH_TYPE_ALLOF?>;\n\tconst PCAP_MATCH_TYPE_ANYOF = <?=PCAP_MATCH_TYPE_ANYOF?>;\n\tconst PCAP_MATCH_ATTR_ANYOF = <?=PCAP_MATCH_ATTR_ANYOF?>;\n\tconst PCAP_MATCH_ATTR_ALLOF = <?=PCAP_MATCH_ATTR_ALLOF?>;\n\tconst PCAP_MATCH_ATTR_NONEOF = <?=PCAP_MATCH_ATTR_NONEOF?>;\n\n\tconst idUntaggedList = ['untagged_section_match', 'untagged_ethertype_match', 'untagged_ethertype',\n\t    'untagged_protocol_match', 'untagged_protocol', 'untagged_ipaddress_match', 'untagged_ipaddress',\n\t    'untagged_macaddress_match', 'untagged_macaddress', 'untagged_port_match', 'untagged_port'];\n\n\tconst idTaggedList = ['tagged_section_match', 'tagged_taglevel', 'tagged_tag_match', 'tagged_tag',\n\t    'tagged_ethertype_match', 'tagged_ethertype', 'tagged_protocol_match',\n\t    'tagged_protocol', 'tagged_ipaddress_match', 'tagged_ipaddress',\n\t    'tagged_macaddress_match', 'tagged_macaddress', 'tagged_port_match', 'tagged_port'];\n\n\tconst idAllList = idUntaggedList.concat(idTaggedList);\n\n\t// Disables the given input element\n\tfunction disableElement(id, isDisabled) {\n\t\t$('#' + id).prop('disabled', isDisabled);\n\t}\n\n\t// Disable input elements depending on filter and match selections\n\tfunction disableInput(idList, isElementDisabled, isSectionDisabled) {\n\t\tfor (let element of idList) {\n\t\t\tif (element == 'untagged_section_match' || element == 'tagged_section_match') {\n\t\t\t\t// Handle the Section match\n\t\t\t\tdisableElement(element, isSectionDisabled);\n\t\t\t} else if (element.indexOf('_match') == -1 && $('#' + element + '_match').length > 0) {\n\t\t\t\t// Element ID does not contain \"_match\" - it must be an input field.\n\t\t\t\tvar elementMatch = '#' + element + '_match';\n\t\t\t\t// Disable the input field depending on the respective section and input match\n\t\t\t\tif (!isElementDisabled && ($(elementMatch).val() == PCAP_MATCH_ATTR_NONEOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_ATTR_ANYOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_ATTR_ALLOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_TYPE_ALLOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_TYPE_ANYOF)) {\n\t\t\t\t\tdisableElement(element, false);\n\t\t\t\t} else {\n\t\t\t\t\tdisableElement(element, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Element is an input match field\n\t\t\t\tdisableElement(element, isElementDisabled);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove focus on page load\n\tdocument.activeElement.blur()\n\n\t// Match selection handlers\n\t$('.match-selection').on('change', function() {\n\t\t// Validate that the element can be handled\n\t\tif ((this.id).indexOf('_match') != -1 || (this.id) == 'filter') {\n\t\t\tswitch (this.id) {\n\t\t\t\tcase 'filter':\n\t\t\t\t\t// On selecting a filter preset\n\t\t\t\t\thideClass('custom-options', (this.value != PCAP_FPRESET_CUSTOM));\n\t\t\t\t\tvar isDisableAll = (this.value != PCAP_FPRESET_CUSTOM);\n\t\t\t\t\tvar isDisableTagged = ($('#tagged_section_match').val() == PCAP_MATCH_SECT_NONE);\n\t\t\t\t\tdisableInput(idAllList, isDisableAll, isDisableAll);\n\t\t\t\t\tdisableInput(idTaggedList, isDisableTagged, false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'untagged_section_match':\n\t\t\t\t\t// On selecting an untagged Section match\n\t\t\t\t\tdisableInput(idUntaggedList, (this.value == PCAP_MATCH_SECT_NONE), false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tagged_section_match':\n\t\t\t\t\t// On selecting a tagged Section match\n\t\t\t\t\tdisableInput(idTaggedList, (this.value == PCAP_MATCH_SECT_NONE), false);\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\t// On selecting a Type Match, handle the respective input field\n\t\t\t\t\tdisableElement((this.id).replace('_match', ''), !(this.value == PCAP_MATCH_ATTR_NONEOF ||\n\t\t\t\t\t    this.value == PCAP_MATCH_ATTR_ANYOF || this.value == PCAP_MATCH_ATTR_ALLOF ||\n\t\t\t\t\t    this.value == PCAP_MATCH_TYPE_ALLOF || this.value == PCAP_MATCH_TYPE_ANYOF));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\n\t// On initial page load\n\tif ($('#filter').val() != PCAP_FPRESET_CUSTOM) {\n\t\thideClass('custom-options', true);\n\t\tdisableInput(idAllList, true, true);\n\t} else {\n\t\thideClass('custom-options', false);\n\t\tdisableInput(idUntaggedList, ($('#untagged_section_match').val() == PCAP_MATCH_SECT_NONE), false);\n\t\tdisableInput(idTaggedList, ($('#tagged_section_match').val() == PCAP_MATCH_SECT_NONE), false);\n\t}\n});\n//]]>\n</script>\n\n<?php\n\n// page footer\ninclude('foot.inc');\n"], "fixing_code": ["<?php\n/*\n * diag_packet_capture.php\n *\n * part of pfSense (https://www.pfsense.org)\n * Copyright (c) 2004-2013 BSD Perimeter\n * Copyright (c) 2013-2016 Electric Sheep Fencing\n * Copyright (c) 2014-2023 Rubicon Communications, LLC (Netgate)\n * All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n##|+PRIV\n##|*IDENT=page-diagnostics-packetcapture\n##|*NAME=Diagnostics: Packet Capture\n##|*DESCR=Allow access to the 'Diagnostics: Packet Capture' page.\n##|*MATCH=diag_packet_capture.php*\n##|-PRIV\n\nrequire_once('util.inc');\nrequire_once('interfaces_fast.inc');\nrequire_once('guiconfig.inc');\nrequire_once('pfsense-utils.inc');\nrequire_once('live_logs.inc');\nrequire_once('diag_packet_capture.inc');\n\n// Directory path where .pcap and .plog files will be stored.\n$pcap_files_root = g_get('tmp_path');\n\n/* Include relevant files in the list, keyed by the date in the file name. Sort\n * the file lists from oldest to newest, and store the newest file name. These\n * lists are used when clearing the .pcap and .plog files. File name example:\n * packetcapture-igb0.20-20220701000101.pcap\n * packetcapture-normal-lookup-20220701000101.plog\n*/\n$pcap_files_list = [];\nforeach (array_filter(glob(\"{$pcap_files_root}/packetcapture-*.pcap\"), 'is_file') as $file) {\n\tif (preg_match('/^.*-\\d{14}\\.pcap/i', $file)) {\n\t\t$pcap_files_list[strtotime(substr($file, -19, 14))] = $file;\n\t}\n}\nksort($pcap_files_list, SORT_NUMERIC);\n$pcap_file_last = empty($pcap_files_list) ? null : $pcap_files_list[array_key_last($pcap_files_list)];\n\n$plog_files_list = [];\nforeach (array_filter(glob(\"{$pcap_files_root}/packetcapture-*.plog\"), 'is_file') as $file) {\n\tif (preg_match('/^.*-\\d{14}\\.plog/i', $file)) {\n\t\t$plog_files_list[strtotime(substr($file, -19, 14))] = $file;\n\t}\n}\nksort($plog_files_list, SORT_NUMERIC);\n$plog_file_current = empty($plog_files_list) ? null : $plog_files_list[array_key_last($plog_files_list)];\n\n/* The file name in the AJAX POST call must match the file name from\n * $plog_file_current to avoid spoofed requests providing unintended access to\n * system files. */\nif (isset($_REQUEST['ajaxLog']) && $_REQUEST['file'] == $plog_file_current) {\n\tcheckForAjaxLog($plog_file_current);\n\texit;\n}\n\n/* Handle AJAX POST call for the tcpdump process check. */\nif ($_REQUEST['isCaptureRunning']) {\n\t/* Check for any matching tcpdump processes currently running.\n \t * Handle multiple matches; assume the first match is correct. */\n\t$processes_check = get_pgrep_output('^\\/usr\\/sbin\\/tcpdump.*-w -');\n\t$process_running = empty($processes_check) ? false : true;\n\n\techo ($process_running ? \"true\" : \"false\");\n\texit;\n}\n\n// Page properties\n$allowautocomplete = true;\nif ($_POST['download_button'] != '') {\n\t$nocsrf = true;\n}\n$pgtitle = array(gettext('Diagnostics'), gettext('Packet Capture'));\n\n$available_interfaces = get_interfaces_sorted();\n$max_view_size = 50 * 1024 * 1024; // Avoid timeout by only requesting 50MB at a time.\n\n$run_capture = false;\n$expression_string = '';\n$input_error = [];\n\n/* Actions taken on form button click */\nif ($_POST) {\n\tif (isset($_POST['start_button'])) {\n\t\t$action = 'start';\n\t\t$run_capture = true;\n\t} elseif (isset($_POST['stop_button'])) {\n\t\t$action = 'stop';\n\t} elseif (isset($_POST['view_button'])) {\n\t\t$action = 'view';\n\t} elseif (isset($_POST['download_button'])) {\n\t\t$action = 'download';\n\t} elseif (isset($_POST['clear_button'])) {\n\t\t$action = 'clear';\n\t}\n\n\t/* Save previous input to use on page load after submission */\n\t// capture options\n\t$input_interface = $_POST['interface'];\n\tif (!array_key_exists($input_interface, $available_interfaces)) {\n\t\t$input_error[] = 'No valid interface selected.';\n\t}\n\t$input_filter = ($_POST['filter'] !== null) ? intval($_POST['filter']) : null;\n\tif ($_POST['count'] == '0') {\n\t\t$input_count = 0;\n\t} elseif (empty($_POST['count'])) {\n\t\t$input_count = 1000;\n\t} elseif (!is_numericint($_POST['count'])) {\n\t\t$input_error[] = 'Invalid Packet Count.';\n\t} else {\n\t\t$input_count = intval($_POST['count']);\n\t}\n\tif (empty($_POST['length'])) {\n\t\t$input_length = 0;\n\t} elseif (!is_numericint($_POST['length'])) {\n\t\t$input_error[] = 'Invalid Packet Length.';\n\t} else {\n\t\t$input_length = intval($_POST['length']);\n\t}\n\t$input_promiscuous = empty($_POST['promiscuous']) ? false : $_POST['promiscuous'];\n\t// view options\n\t$input_viewdetail = empty($_POST['viewdetail']) ? 'normal' : $_POST['viewdetail'];\n\t$input_viewtype = empty($_POST['viewtype']) ? 'default' : $_POST['viewtype'];\n\t$input_lookup = empty($_POST['lookup']) ? false : $_POST['lookup'];\n\n\t// filter options\n\t$filterattributes = [];\n\tif ($input_filter == PCAP_FPRESET_CUSTOM) {\n\t\t// Variables to pre-fill form input based on POST data\n\t\tif (isset($_POST['tagged_taglevel'])) {\n\t\t\t$input_tagged_taglevel = $_POST['tagged_taglevel'];\n\t\t}\n\n\t\tforeach ($_POST as $key => $value) {\n\t\t\t/* Only the \"match\" select element values need to be checked. Determine\n\t\t\t * the corresponding Section and Type from the element ID. */\n\t\t\tif (preg_match('/^untagged_[a-z]+_match$/i', $key)) {\n\t\t\t\t$fa_section = PCAP_SECTION_UNTAGGED;\n\t\t\t\t$fa_type_name = substr_replace(substr($key, 9), '', -6);\n\t\t\t} elseif (preg_match('/^tagged_[a-z]+_match$/i', $key)) {\n\t\t\t\t// The Section is determined by the tag level\n\t\t\t\t$fa_section = empty($_POST['tagged_taglevel']) ? PCAP_SECTION_TAGGED_MIN : $_POST['tagged_taglevel'];\n\t\t\t\t$fa_type_name = substr_replace(substr($key, 7), '', -6);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch ($fa_type_name) {\n\t\t\t\tcase 'ethertype':\n\t\t\t\t\t$fa_type = PCAP_TYPE_ETHERTYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'protocol':\n\t\t\t\t\t$fa_type = PCAP_TYPE_PROTOCOL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ipaddress':\n\t\t\t\t\t$fa_type = PCAP_TYPE_IPADDRESS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'macaddress':\n\t\t\t\t\t$fa_type = PCAP_TYPE_MACADDRESS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'port':\n\t\t\t\t\t$fa_type = PCAP_TYPE_PORT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tag':\n\t\t\t\t\t$fa_type = PCAP_TYPE_VLAN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'section':\n\t\t\t\t\t$fa_type = PCAP_TYPE_SMATCH;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// Other Types don't need to be checked.\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Get this match's corresponding input element ID to retrieve its value\n\t\t\t$fa_id = substr_replace($key, '', -6);\n\n\t\t\t/* A Section's \"match\" select element is used for both the input value\n\t\t\t * and match operator. */\n\t\t\tif ($fa_type == PCAP_TYPE_SMATCH) {\n\t\t\t\t$fa_input = $fa_match = $value;\n\t\t\t} else {\n\t\t\t\t/* Check whether this match's selected value is the match operator or\n\t\t\t\t * the input value. */\n\t\t\t\tif (in_array($value, PCAP_LIST_MATCH)) {\n\t\t\t\t\t/* Get the match operator from the match, and the input\n\t\t\t\t\t * value from the corresponding input field. */\n\t\t\t\t\t$fa_input = isset($_POST[$fa_id]) ? $_POST[$fa_id] : '';\n\t\t\t\t\t$fa_match = $value;\n\t\t\t\t} else {\n\t\t\t\t\t/* Get the input value from the match and explicitly set\n\t\t\t\t\t * the match operator. */\n\t\t\t\t\t$fa_input = $value;\n\t\t\t\t\t$fa_match = PCAP_MATCH_ATTR_ANYOF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Generate variable variables to pre-fill form input based on POST data\n\t\t\t${'input_' . $key} = $value;\n\t\t\t${'input_' . $fa_id} = $_POST[$fa_id];\n\n\t\t\ttry {\n\t\t\t\t// Create a FilterAttribute object for a Section or Type\n\t\t\t\t$fa = new FilterAttribute($fa_section, $fa_match, $fa_type);\n\t\t\t\t$fa->setInputString($fa_input);\n\t\t\t} catch (Exception $e) {\n\t\t\t\t$input_error[] = $e->getMessage();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t$filterattributes[] = $fa;\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\t// Create a FilterAttribute object for the Filter Preset\n\t\t\tif (is_int($input_filter)) {\n\t\t\t\t$filterattributes[] = new FilterAttribute(PCAP_SECTION_FPRESET, $input_filter, PCAP_TYPE_APRESET);\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"Invalid filter option given.\");\n\t\t\t}\n\t\t} catch (Exception $e) {\n\t\t\t$input_error[] = $e->getMessage();\n\t\t}\n\t}\n\n\t$vlan_supported = !preg_match('/^(lo\\d+|gif\\d+|gre\\d+|ppp\\d+|pppoe\\d+|pptp\\d+|l2tp\\d+|enc\\d+|ipsec\\d+|ovpn[sc]\\d+|tun_wg\\d+)/i', $input_interface);\n\ttry {\n\t\t$expression_string = get_expression_string($filterattributes, $vlan_supported);\n\t} catch (Exception $e) {\n\t\t$input_error[] = $e->getMessage();\n\t}\n\n\tif (!empty($input_error)) {\n\t\t$run_capture = false;\n\t}\n}\n\n// Header page HTML\ninclude('head.inc');\n\n// Show input validation errors only when trying to start the packet capture\nif (!empty($input_error) && $action == 'start') {\n\tprint_input_errors($input_error);\n}\n\n// Prepare the form buttons\n$form_buttons = [\n\t'stop_button' => [\n\t\t'class' => 'btn-warning',\n\t\t'value' => 'Stop',\n\t\t'icon' => 'fa-stop-circle'\n\t],\n\t'start_button' => [\n\t\t'class' => 'btn-success',\n\t\t'value' => 'Start',\n\t\t'icon' => 'fa-play-circle'\n\t],\n\t'view_button' => [\n\t\t'class' => 'btn-primary',\n\t\t'value' => 'View',\n\t\t'icon' => 'fa-file-text-o'\n\t],\n\t'download_button' => [\n\t\t'class' => 'btn-primary',\n\t\t'value' => 'Download',\n\t\t'icon' => 'fa-download'\n\t],\n\t'clear_button' => [\n\t\t'class' => 'btn-danger',\n\t\t'value' => 'Clear Captures',\n\t\t'icon' => 'fa-trash'\n\t]\n];\n\n// Handle button actions before displaying the form\nif ($action == 'stop') {\n\t/* Kill relevant running tcpdump processes (don't defer to background),\n \t * then verify if it's running. */\n\tmwexec(\"/bin/pkill -f '^\\/usr\\/sbin\\/tcpdump.*-w -'\");\n}\n/* Check for any matching tcpdump processes currently running.\n * Handle multiple matches; assume the first match is correct. */\n$processes_check = get_pgrep_output('^\\/usr\\/sbin\\/tcpdump.*-w -');\n$process_running = empty($processes_check) ? false : true;\n\n$show_last_capture_details = false;\nif ($process_running || $run_capture) {\n\t// Only show the Stop button\n\t$form_buttons['start_button']['class'] .= ' hidden';\n\t$form_buttons['view_button']['class'] .= ' hidden';\n\t$form_buttons['download_button']['class'] .= ' hidden';\n\t$form_buttons['clear_button']['class'] .= ' hidden';\n} else {\n\t// Show the Start button\n\t$form_buttons['stop_button']['class'] .= ' hidden';\n\tif (file_exists($pcap_file_last)) {\n\t\tif ($action == 'clear') {\n\t\t\t// Hide file buttons when clearing related files\n\t\t\t$form_buttons['view_button']['class'] .= ' hidden';\n\t\t\t$form_buttons['download_button']['class'] .= ' hidden';\n\t\t\t$form_buttons['clear_button']['class'] .= ' hidden';\n\n\t\t\t// Clear related files\n\t\t\tforeach ($pcap_files_list as $pcap_file) {\n\t\t\t\tunlink_if_exists($pcap_file);\n\t\t\t}\n\t\t\tforeach ($plog_files_list as $plog_file) {\n\t\t\t\tunlink_if_exists($plog_file);\n\t\t\t}\n\t\t} else {\n\t\t\t$show_last_capture_details = true;\n\t\t\tif ($action == 'download') {\n\t\t\t\tsend_user_download('file', $pcap_file_last);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Hide file buttons when no related files exist\n\t\t$form_buttons['view_button']['class'] .= ' hidden';\n\t\t$form_buttons['download_button']['class'] .= ' hidden';\n\t\t$form_buttons['clear_button']['class'] .= ' hidden';\n\t}\n}\n\n// Prepare the form variables\n// Packet capture filter options\n$form_filters = array(\n\tPCAP_FPRESET_CUSTOM => gettext('Custom Filter'),\n\tPCAP_FPRESET_ANY => gettext('Everything'),\n\tPCAP_FPRESET_UNTAGGED => gettext('Only Untagged'),\n\tPCAP_FPRESET_TAGGED => gettext('Only Tagged')\n);\n// View detail options\n$form_viewdetail = array(\n\t'normal' => gettext('Normal'),\n\t'medium' => gettext('Medium'),\n\t'high' => gettext('High'),\n\t'full' => gettext('Full')\n);\n// View type options\n$form_viewtype = array(\n\t'default' => gettext('Default Type'),\n\t'aodv' => 'AODV',\n\t'carp' => 'CARP',\n\t'cnfp' => 'CNFP',\n\t'lmp' => 'LMP',\n\t'pgm' => 'PGM',\n\t'pgm_zmtp1' => 'PGM_ZMTP1',\n\t'resp' => 'RESP',\n\t'radius' => 'RADIUS',\n\t'rpc' => 'RPC',\n\t'rtp' => 'RTP',\n\t'rtcp' => 'RTCP',\n\t'snmp' => 'SNMP',\n\t'tftp' => 'TFTP',\n\t'vat' => 'VAT',\n\t'wb' => 'WB',\n\t'zmtp1' => 'ZMTP1',\n\t'vxlan' => 'VXLAN'\n);\n// Section match selection fields\n$form_fsmatch = array(\n\tPCAP_MATCH_SECT_NONE => gettext('exclude all'),\n\tPCAP_MATCH_SECT_ANYOF => gettext('include any of')\n);\n$form_fsmatch_tagged = array(\n\tPCAP_MATCH_SECT_NONE => gettext('exclude all'),\n\tPCAP_MATCH_SECT_ANYOF => gettext('include any of')\n);\n// Type match selection fields\n$form_match_ipaddress = $form_match_macaddress = $form_match_port = array(\n\tPCAP_MATCH_ATTR_ANYOF => gettext('any of'),\n\tPCAP_MATCH_ATTR_ALLOF => gettext('all of'),\n\tPCAP_MATCH_ATTR_NONEOF => gettext('none of'),\n\tPCAP_MATCH_TYPE_ALLOF => gettext('OR all of'),\n\tPCAP_MATCH_TYPE_ANYOF => gettext('OR any of')\n);\n$form_match_tag = $form_match_protocol = $form_match_ethertype = array(\n\tPCAP_MATCH_ATTR_ANYOF => gettext('any of'),\n\tPCAP_MATCH_ATTR_NONEOF => gettext('none of'),\n\tPCAP_MATCH_TYPE_ANYOF => gettext('OR any of')\n);\n$form_match_ethertype +=  array(\n\t'ipv4' => '[IPv4]',\n\t'ipv6' => '[IPv6]',\n\t'arp' => '[ARP]'\n);\n$form_match_protocol += array(\n\t'icmp' => '[ICMPv4]',\n\t'icmp6' => '[ICMPv6]',\n\t'tcp' => '[TCP]',\n\t'udp' => '[UDP]',\n\t'ipsec' => '[IPsec]',\n\t'carp' => '[CARP]',\n\t'pfsync' => '[pfsync]',\n\t'ospf' => '[OSPF]'\n);\n// Variables for each Section\n$form_filter_section_begin_row = array('ipaddress', 'protocol');\n$form_filter_section_end_row = array('taglevel', 'macaddress', 'ethertype');\n$form_filter_sections = array(\n\t0 => array(\n\t\t'name' => 'untagged',\n\t\t'sectionlabel' => gettext('Untagged Filter'),\n\t\t'sectiondescription' => gettext('Filter options for packets without any VLAN tags.'),\n\t\t'matchdescription' => gettext('UNTAGGED PACKETS')\n\t),\n\t1 => array(\n\t\t'name' => 'tagged',\n\t\t'sectionlabel' => gettext('Tagged Filter'),\n\t\t'sectiondescription' => gettext('Filter options for packets that have a VLAN tag set. ' .\n\t\t    'Specify a tag level to match stacked VLAN packets (such as QinQ).'),\n\t\t'matchdescription' => gettext('TAGGED PACKETS')\n\t)\n);\n$form_filter_section_attributes_properties = array(\n\t'tag' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 100 200'),\n\t\t'description' => gettext('VLAN TAG'),\n\t\t'width' => 3\n\t),\n\t'taglevel' => array(\n\t\t'placeholder' => 1,\n\t\t'description' => gettext('LEVEL'),\n\t\t'width' => 1\n\t),\n\t'ipaddress' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 10.1.1.0/24 192.168.1.1'),\n\t\t'description' => gettext('HOST IP ADDRESS OR SUBNET'),\n\t\t'width' => 6\n\t),\n\t'macaddress' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 00:02 11:22:33:44:55:66'),\n\t\t'description' => gettext('HOST MAC ADDRESS'),\n\t\t'width' => 4\n\t),\n\t'protocol' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 17 tcp'),\n\t\t'description' => gettext('PROTOCOL'),\n\t\t'width' => 3\n\t),\n\t'port' => array(\n\t\t'placeholder' => gettext('EXAMPLE: 80 443'),\n\t\t'description' => gettext('PORT NUMBER'),\n\t\t'width' => 3\n\t),\n\t'ethertype' => array(\n\t\t'placeholder' => gettext('EXAMPLE: arp 8100 0x8200'),\n\t\t'description' => gettext('ETHERTYPE'),\n\t\t'width' => 4\n\t)\n);\n\n// Default form input values\nif (!isset($input_filter)) {\n\t$input_filter = PCAP_FPRESET_CUSTOM;\n}\nif (!isset($input_promiscuous)) {\n\t$input_promiscuous = true;\n}\nif (!isset($input_viewdetail)) {\n\t$input_viewdetail = 'normal';\n}\nif (!isset($input_viewtype)) {\n\t$input_viewtype = 'default';\n}\nif (!isset($input_lookup)) {\n\t$input_lookup = false;\n}\nif (!isset($input_untagged_section_match)) {\n\t$input_untagged_section_match = PCAP_MATCH_SECT_ANYOF;\n}\nif (!isset($input_untagged_ipaddress_match)) {\n\t$input_untagged_ipaddress_match = PCAP_MATCH_ATTR_ALLOF;\n}\nif (!isset($input_tagged_ipaddress_match)) {\n\t$input_tagged_ipaddress_match = PCAP_MATCH_ATTR_ALLOF;\n}\n\n// Create the form\n$form = new Form(false);\n// Main panel\n$section = new Form_Section('Packet Capture Options');\n$group = new Form_Group('Capture Options');\n$group->add(new Form_Select(\n\t'interface',\n\tnull,\n\t$input_interface,\n\t$available_interfaces\n))->setHelp('Interface to capture packets on.')->setWidth(4);\n$group->add(new Form_Select(\n\t'filter',\n\tnull,\n\t$input_filter,\n\t$form_filters\n))->setHelp('Filter preset.')->addClass('match-selection')->setWidth(2);\n$section->add($group);\n$group = new Form_Group('');\n$group->add(new Form_Input(\n\t'count',\n\t'Packet Count',\n\tnull,\n\t$input_count,\n\tarray('type' => 'number', 'min' => 0, 'step' => 1)\n))->setHelp('Max number of packets to capture (default 1000). ' .\n            'Enter 0 (zero) for no limit.')->setWidth(2);\n$group->add(new Form_Input(\n\t'length',\n\t'Packet Length',\n\tnull,\n\t$input_length,\n\tarray('type' => 'number', 'min' => 0, 'step' => 1)\n))->setHelp('Max bytes per packet (default 0). ' . \n            'Enter 0 (zero) for no limit.')->setWidth(2);\n$group->add(new Form_Checkbox(\n\t'promiscuous',\n\tnull,\n\t'Promiscuous Mode',\n\t$input_promiscuous\n))->setHelp('Capture all traffic seen by the interface. Disable this option ' .\n            'to only capture traffic to and from the interface, including ' .\n            'broadcast and multicast traffic.')->setWidth(5);\n$section->add($group);\n$group = new Form_Group('View Options');\n$group->add(new Form_Select(\n\t'viewdetail',\n\t'View Detail',\n\t$input_viewdetail,\n\t$form_viewdetail\n))->setHelp('The level of detail shown when viewing the packet capture.')->setWidth(2);\n$group->add(new Form_Select(\n\t'viewtype',\n\t'View Type',\n\t$input_viewtype,\n\t$form_viewtype\n))->setHelp('Force the captured traffic to be interpreted as a specified type.')->setWidth(2);\n$group->add(new Form_Checkbox(\n\t'lookup',\n\tnull,\n\t'Name Lookup',\n\t$input_lookup\n))->setHelp('Perform a name lookup for port, host, and MAC addresses when ' .\n            'viewing the packet capture. This can cause significant delays ' .\n\t\t\t'due to reverse DNS lookups.')->setWidth(5);\n$section->add($group);\n\n// Show the last capture details on the main form section\nif ($show_last_capture_details) {\n\t$section->addInput(new Form_StaticText(\n\t\t'Last capture start',\n\t\tdate('F jS, Y g:i:s a.', strtotime(substr($pcap_file_last, -19, 14)))\n\t));\n\n\t$section->addInput(new Form_StaticText(\n\t\t'Last capture stop',\n\t\tdate('F jS, Y g:i:s a.', filemtime($pcap_file_last))\n\t));\n}\n\n$form->add($section);\n\n// Hidden panel\n$section = new Form_Section('Custom Filter Options');\n$section->addClass('custom-options');\n$section->addInput(new Form_StaticText(\n\t'Hint',\n\tsprintf('All input is %1$sspace-separated%2$s. When selecting a match ' .\n\t        'that specifies \"%1$sOR%2$s\", at least two Types should be ' .\n\t        'specified (such as Ethertype and Port). This will capture packets ' .\n\t        'that match either Type instead of exclusively both.',\n\t\t\t'<b>', '</b>')\n));\n// Add each Section\nforeach ($form_filter_sections as $fs_key => $fs_var) {\n\t$fs_name = $fs_var['name'];\n\t$fs_match_id           =       \"{$fs_name}_section_match\";\n\t$fs_match_input_varvar = \"input_{$fs_name}_section_match\";\n\n\t// Section header\n\t$section->addInput(new Form_StaticText(\n\t\t$fs_var['sectionlabel'],\n\t\t$fs_var['sectiondescription']\n\t));\n\n\t// Section match field\n\t$group = new Form_Group('');\n\t$group->addClass('no-separator');\n\t$group->add(new Form_Select(\n\t\t$fs_match_id,\n\t\tnull,\n\t\t${$fs_match_input_varvar},\n\t\t($fs_key == array_key_first($form_filter_sections) ? $form_fsmatch : $form_fsmatch_tagged)\n\t))->setHelp($fs_var['matchdescription'])->addClass('match-selection inputselectcombo')->setWidth(3);\n\t$group->add(new Form_StaticText(\n\t\tnull,\n\t\tnull\n\t))->setWidth(3);\n\n\t// Type fields\n\tforeach ($form_filter_section_attributes_properties as $attribute_name => $attribute_strings) {\n\t\t// Don't add VLAN Types in an untagged Section\n\t\tif ($fs_key == array_key_first($form_filter_sections)) {\n\t\t\tif ($attribute_name == 'tag') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ($attribute_name == 'taglevel') {\n\t\t\t\t$section->add($group);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t// Variable variables for the Type fields\n\t\t$attribute_input_id     =       \"{$fs_name}_{$attribute_name}\";       // input element ID\n\t\t$attribute_match_id     =       \"{$fs_name}_{$attribute_name}_match\"; // select element ID\n\t\t$attribute_input_varvar = \"input_{$fs_name}_{$attribute_name}\";       // input element value\n\t\t$attribute_match_varvar = \"input_{$fs_name}_{$attribute_name}_match\"; // select element selected value\n\t\t$form_match_varvar = \"form_match_{$attribute_name}\";                  // select element options\n\n\t\t// Start a new row within this Section\n\t\tif (in_array($attribute_name, $form_filter_section_begin_row)) {\n\t\t\t$group = new Form_Group('');\n\t\t\t// Hide the row seperator for all but the last row.\n\t\t\tif ($attribute_name != $form_filter_section_begin_row[array_key_last($form_filter_section_begin_row)]) {\n\t\t\t\t$group->addClass('no-separator');\n\t\t\t}\n\t\t}\n\n\t\t// Add the Type field to the group\n\t\tswitch ($attribute_name) {\n\t\t\tcase 'taglevel':\n\t\t\t\t$attribute_field = new Form_Input(\n\t\t\t\t\t$attribute_input_id,\n\t\t\t\t\t$attribute_strings['placeholder'],\n\t\t\t\t\tnull,\n\t\t\t\t\t${$attribute_input_varvar},\n\t\t\t\t\tarray('type' => 'number', 'min' => 1, 'max' => 9, 'step' => 1)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t$attribute_field = new Form_SelectInputCombo(\n\t\t\t\t\t$attribute_input_id,\n\t\t\t\t\t$attribute_strings['placeholder'],\n\t\t\t\t\t${$attribute_input_varvar}\n\t\t\t\t);\n\t\t\t\t$attribute_field->addSelect($attribute_match_id, ${$attribute_match_varvar}, ${$form_match_varvar});\n\t\t\t\tbreak;\n\t\t}\n\t\t$attribute_field->setHelp($attribute_strings['description'])->setWidth($attribute_strings['width']);\n\t\t$group->add($attribute_field);\n\n\t\t// Add the fields group to the form section when on the last Type of the row\n\t\tif (in_array($attribute_name, $form_filter_section_end_row)) {\n\t\t\t$section->add($group);\n\t\t}\n\t}\n}\n$form->add($section);\n\n// Add the form buttons\nforeach ($form_buttons as $button_id => $button) {\n\t$form->addGlobal(new Form_Button(\n\t\t$button_id,\n\t\t$button['value'],\n\t\tnull,\n\t\t$button['icon']\n\t))->addClass($button['class']);\n}\n\n/* Show the form */\necho $form;\n\n/* Show the capture */\nif ($action == 'stop' || $action == 'view' || $process_running || $run_capture) :\n\t$cmd_part_lookup = $input_lookup ? '' : ' -n';\n\tswitch ($input_viewdetail) {\n\t\tcase 'full':\n\t\t\t$cmd_part_viewdetail = ' -vv -e';\n\t\t\tbreak;\n\t\tcase 'high':\n\t\t\t$cmd_part_viewdetail = ' -vv';\n\t\t\tbreak;\n\t\tcase 'medium':\n\t\t\t$cmd_part_viewdetail = ' -v';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t$input_viewdetail = 'normal';\n\t\t\t$cmd_part_viewdetail = ' -q';\n\t\t\tbreak;\n\t}\n\tswitch ($input_viewtype) {\n\t\tcase 'aodv': // Ad-hoc On-demand Distance Vector protocol\n\t\t\t$cmd_part_viewtype = ' -T aodv';\n\t\t\tbreak;\n\t\tcase 'carp': // Common Address Redundancy Protocol\n\t\t\t$cmd_part_viewtype = ' -T carp';\n\t\t\tbreak;\n\t\tcase 'cnfp': // Cisco NetFlow Protocol\n\t\t\t$cmd_part_viewtype = ' -T cnfp';\n\t\t\tbreak;\n\t\tcase 'lmp': // Link Management Protocol\n\t\t\t$cmd_part_viewtype = ' -T lmp';\n\t\t\tbreak;\n\t\tcase 'pgm': // Pragmatic General Multicast\n\t\t\t$cmd_part_viewtype = ' -T pgm';\n\t\t\tbreak;\n\t\tcase 'pgm_zmtp1': // ZMTP/1.0 inside PGM/EPGM\n\t\t\t$cmd_part_viewtype = ' -T pgm_zmtp1';\n\t\t\tbreak;\n\t\tcase 'resp': // REdis Serialization Protocol\n\t\t\t$cmd_part_viewtype = ' -T resp';\n\t\t\tbreak;\n\t\tcase 'radius': // RADIUS\n\t\t\t$cmd_part_viewtype = ' -T radius';\n\t\t\tbreak;\n\t\tcase 'rpc': // Remote Procedure Call\n\t\t\t$cmd_part_viewtype = ' -T rpc';\n\t\t\tbreak;\n\t\tcase 'rtp': // Real-Time Applications Protocol\n\t\t\t$cmd_part_viewtype = ' -T rtp';\n\t\t\tbreak;\n\t\tcase 'rtcp': // Real-Time Applications control Protocol\n\t\t\t$cmd_part_viewtype = ' -T rtcp';\n\t\t\tbreak;\n\t\tcase 'snmp': // Simple Network Management Protocol\n\t\t\t$cmd_part_viewtype = ' -T snmp';\n\t\t\tbreak;\n\t\tcase 'tftp': // Trivial File Transfer Protocol\n\t\t\t$cmd_part_viewtype = ' -T tftp';\n\t\t\tbreak;\n\t\tcase 'vat': // Visual Audio Tool\n\t\t\t$cmd_part_viewtype = ' -T vat';\n\t\t\tbreak;\n\t\tcase 'wb': // distributed White Board\n\t\t\t$cmd_part_viewtype = ' -T wb';\n\t\t\tbreak;\n\t\tcase 'zmtp1': // ZeroMQ Message Transport Protocol 1.0\n\t\t\t$cmd_part_viewtype = ' -T zmtp1';\n\t\t\tbreak;\n\t\tcase 'vxlan': // Virtual eXtensible Local Area Network\n\t\t\t$cmd_part_viewtype = ' -T vxlan';\n\t\t\tbreak;\n\t\tdefault: // Do not force a view type\n\t\t\t$input_viewtype = 'default';\n\t\t\t$cmd_part_viewtype = '';\n\t\t\tbreak;\n\t}\n\n\t/* Run tcpdump */\n\t$pcap_file_suffix = '-' . date('YmdHis');\n\t$plog_file_current = $pcap_files_root . '/packetcapture-'. $input_viewdetail . (empty($cmd_part_lookup) ? '' : '-lookup') . (empty($cmd_part_viewtype) ? '' : '-' . $input_viewtype) . $pcap_file_suffix . '.plog';\n\tif ($run_capture) {\n\t\t// Generate the file name to write to\n\t\t$pcap_file_current = $pcap_files_root . '/packetcapture-' . $input_interface . $pcap_file_suffix . '.pcap';\n\t\tunlink_if_exists($pcap_file_current);\n\t\tunlink_if_exists($plog_file_current);\n\n\t\t// Handle capture options\n\t\t$cmd_part_promiscuous = $input_promiscuous ? '' : ' -p';\n\t\t$cmd_part_count = empty($input_count) ? '' : \" -c \" . escapeshellarg($input_count);\n\t\t$cmd_part_length = empty($input_length) ? '' : \" -s \" . escapeshellarg($input_length);\n\t\t$cmd_expression_string = $expression_string ? escapeshellarg($expression_string) : '';\n\n\t\t/* Output in binary format (use packet-buffered to avoid missing packets) to stdout,\n\t\t* use tee to write the binary file and pipe the output,\n\t\t* use a second tcpdump process to parse the binary output,\n\t\t* lastly save the parsed output to a text file to read later. */\n\t\t$cmd_run = sprintf('/usr/sbin/tcpdump -ni %1$s%2$s%3$s%4$s -U -w - %6$s | /usr/bin/tee %5$s | /usr/sbin/tcpdump -l%7$s%8$s%9$s -r - | /usr/bin/tee %10$s',\n\t\t                $input_interface, $cmd_part_promiscuous, $cmd_part_count,\n\t\t                $cmd_part_length, $pcap_file_current, $cmd_expression_string,\n\t\t                $cmd_part_lookup, $cmd_part_viewdetail, $cmd_part_viewtype,\n\t\t                $plog_file_current);\n\t\t$process_running_cmd = strstr($cmd_run, ' |', TRUE);\n\t\tmwexec_bg($cmd_run);\n\t} else {\n\t\t$pcap_file_current = $pcap_file_last;\n\t\tif (!$process_running && !file_exists($plog_file_current)) {\n\t\t\t// Make sure the pcap log file is generated\n\t\t\t$cmd_run = sprintf('/usr/sbin/tcpdump%1$s%2$s%3$s -r %4$s | /usr/bin/tee %5$s', $cmd_part_lookup, $cmd_part_viewdetail, $cmd_part_viewtype, $pcap_file_current, $plog_file_current);\n\t\t\tmwexec_bg($cmd_run);\n\t\t}\n\t}\n\n\tif ($process_running || $run_capture) {\n\t\tif (!isset($process_running_cmd) && !empty($processes_check)) {\n\t\t\t$process_running_cmd = $processes_check[array_key_first($processes_check)];\n\t\t}\n\t\tprint_info_box(gettext('Running packet capture:') . '<br/>' . htmlspecialchars($process_running_cmd), 'info');\n\t}\n?>\n\n<!-- Packet Capture View -->\n<div class=\"panel panel-default\">\n\t<div class=\"panel-heading\">\n\t\t<?php\n\t\tif ($process_running || $run_capture) {\n\t\t\techo '<div style=\"float: right;\"><input style=\"margin: 4px 4px 0;\" type=\"checkbox\" checked=\"true\" id=\"autoscroll\">Auto-scroll</div>';\n\t\t}\n\t\t?>\n\t\t<h2 class=\"panel-title\"><?=sprintf('%1$s: %2$s', gettext('Packet Capture Output'), $pcap_file_current)?></h2>\n\t</div>\n\t<div class=\"panel-body\">\n\t\t<div class=\"form-group\">\n\t<?php\n\t// View the packet capture file contents\n\t$refreshOutput = true;\n\techo '<textarea class=\"form-control\" id=\"pcap_output\" rows=\"20\" overflow=\"hidden\" style=\"font-size: 13px; ' .\n\t      'font-family: consolas, monaco, roboto mono, liberation mono, courier; contain:strict\"></textarea>';\n\n\t?>\n\t\t\t<script>\n\t\t\t\toverrideScroll = false;\n\n\t\t\t\tfunction checkProcess() {\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl: \"diag_packet_capture.php\",\n\t\t\t\t\t\ttype: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tisCaptureRunning: \"ajax\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsuccess: function(result) {\n\t\t\t\t\t\t\tvar isRunning = result === \"false\" ? false : true;\n\t\t\t\t\t\t\tif (!isRunning) {\n\t\t\t\t\t\t\t\t$(\"#stop_button\")[0].classList.add(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#start_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#view_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#download_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\"#clear_button\")[0].classList.remove(\"hidden\");\n\t\t\t\t\t\t\t\t$(\".clearfix\")[0].classList.add(\"hidden\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction refreshOutput(bytes = 0) {\n\t\t\t\t\t$.ajax({\n\t\t\t\t\t\turl: \"diag_packet_capture.php\",\n\t\t\t\t\t\ttype: \"post\",\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tajaxLog: \"ajax\",\n\t\t\t\t\t\t\t\tbyte: bytes,\n\t\t\t\t\t\t\t\tmaxRead: <?=$max_view_size?>,\n\t\t\t\t\t\t\t\tfile: \"<?=$plog_file_current?>\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsuccess: function(result) {\n\t\t\t\t\t\t\tconst response = JSON.parse(result);\n\t\t\t\t\t\t\tvar output = document.querySelector('#pcap_output');\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\tif (!$process_running && !$run_capture) {\n\t\t\t\t\t\t\t\techo \"if (response.bytesRead > 0) {\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\n\t\t\t\t\t\t\tif (bytes == 0  & response.bytesRead > 0) {\n\t\t\t\t\t\t\t\toutput.textContent = \"\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If read returns 0 bytes check if tcpdump is still running\n\t\t\t\t\t\t\tif (response.bytesRead == 0) {\n\t\t\t\t\t\t\t\tcheckProcess();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.textContent += response.output;\n\t\t\t\t\t\t\tbytesRead = bytes + response.bytesRead;\n\n\t\t\t\t\t\t\tif (document.querySelector('#autoscroll').checked) {\n\t\t\t\t\t\t\t\toverrideScroll = true;\n\t\t\t\t\t\t\t\toutput.scrollTop = output.scrollHeight;\n\t\t\t\t\t\t\t\toverrideScroll = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsetTimeout(function() { refreshOutput(bytesRead) }, 2500);\n\t\t\t\t\t\t\t<?php\n\t\t\t\t\t\t\tif (!$process_running && !$run_capture) {\n\t\t\t\t\t\t\t\techo \"}\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t?>\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction handleScroll() {\n\t\t\t\t\tif (!overrideScroll) {\n\t\t\t\t\t\tvar output = document.querySelector('#pcap_output');\n\t\t\t\t\t\tif (output.scrollHeight <= (output.scrollTop + output.clientHeight)) {\n\t\t\t\t\t\t\tdocument.querySelector('#autoscroll').checked = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdocument.querySelector('#autoscroll').checked = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t<?php\n\t\t\t\tif ($refreshOutput) {\n\t\t\t\t\tif ($process_running || $run_capture) {\n\t\t\t\t?>\n\t\t\t\t\t\tdocument.querySelector('#pcap_output').addEventListener(\"scroll\", handleScroll);\n\t\t\t\t<?php\n\t\t\t\t\t}\n\t\t\t\t?>\n\t\t\t\tsetTimeout(refreshOutput, 500);\n\t\t\t\t<?php\n\t\t\t\t}\n\t\t\t\t?>\n\t\t\t</script>\n\t\t</div>\n\t</div>\n</div>\n<?php\nendif;\n?>\n\n<script type=\"text/javascript\">\n//<![CDATA[\nevents.push(function() {\n\tconst PCAP_FPRESET_CUSTOM = <?=PCAP_FPRESET_CUSTOM?>;\n\tconst PCAP_MATCH_SECT_NONE = <?=PCAP_MATCH_SECT_NONE?>;\n\tconst PCAP_MATCH_SECT_ALLOF = <?=PCAP_MATCH_SECT_ALLOF?>;\n\tconst PCAP_MATCH_SECT_ANYOF = <?=PCAP_MATCH_SECT_ANYOF?>;\n\tconst PCAP_MATCH_TYPE_ALLOF = <?=PCAP_MATCH_TYPE_ALLOF?>;\n\tconst PCAP_MATCH_TYPE_ANYOF = <?=PCAP_MATCH_TYPE_ANYOF?>;\n\tconst PCAP_MATCH_ATTR_ANYOF = <?=PCAP_MATCH_ATTR_ANYOF?>;\n\tconst PCAP_MATCH_ATTR_ALLOF = <?=PCAP_MATCH_ATTR_ALLOF?>;\n\tconst PCAP_MATCH_ATTR_NONEOF = <?=PCAP_MATCH_ATTR_NONEOF?>;\n\n\tconst idUntaggedList = ['untagged_section_match', 'untagged_ethertype_match', 'untagged_ethertype',\n\t    'untagged_protocol_match', 'untagged_protocol', 'untagged_ipaddress_match', 'untagged_ipaddress',\n\t    'untagged_macaddress_match', 'untagged_macaddress', 'untagged_port_match', 'untagged_port'];\n\n\tconst idTaggedList = ['tagged_section_match', 'tagged_taglevel', 'tagged_tag_match', 'tagged_tag',\n\t    'tagged_ethertype_match', 'tagged_ethertype', 'tagged_protocol_match',\n\t    'tagged_protocol', 'tagged_ipaddress_match', 'tagged_ipaddress',\n\t    'tagged_macaddress_match', 'tagged_macaddress', 'tagged_port_match', 'tagged_port'];\n\n\tconst idAllList = idUntaggedList.concat(idTaggedList);\n\n\t// Disables the given input element\n\tfunction disableElement(id, isDisabled) {\n\t\t$('#' + id).prop('disabled', isDisabled);\n\t}\n\n\t// Disable input elements depending on filter and match selections\n\tfunction disableInput(idList, isElementDisabled, isSectionDisabled) {\n\t\tfor (let element of idList) {\n\t\t\tif (element == 'untagged_section_match' || element == 'tagged_section_match') {\n\t\t\t\t// Handle the Section match\n\t\t\t\tdisableElement(element, isSectionDisabled);\n\t\t\t} else if (element.indexOf('_match') == -1 && $('#' + element + '_match').length > 0) {\n\t\t\t\t// Element ID does not contain \"_match\" - it must be an input field.\n\t\t\t\tvar elementMatch = '#' + element + '_match';\n\t\t\t\t// Disable the input field depending on the respective section and input match\n\t\t\t\tif (!isElementDisabled && ($(elementMatch).val() == PCAP_MATCH_ATTR_NONEOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_ATTR_ANYOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_ATTR_ALLOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_TYPE_ALLOF ||\n\t\t\t\t    $(elementMatch).val() == PCAP_MATCH_TYPE_ANYOF)) {\n\t\t\t\t\tdisableElement(element, false);\n\t\t\t\t} else {\n\t\t\t\t\tdisableElement(element, true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Element is an input match field\n\t\t\t\tdisableElement(element, isElementDisabled);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove focus on page load\n\tdocument.activeElement.blur()\n\n\t// Match selection handlers\n\t$('.match-selection').on('change', function() {\n\t\t// Validate that the element can be handled\n\t\tif ((this.id).indexOf('_match') != -1 || (this.id) == 'filter') {\n\t\t\tswitch (this.id) {\n\t\t\t\tcase 'filter':\n\t\t\t\t\t// On selecting a filter preset\n\t\t\t\t\thideClass('custom-options', (this.value != PCAP_FPRESET_CUSTOM));\n\t\t\t\t\tvar isDisableAll = (this.value != PCAP_FPRESET_CUSTOM);\n\t\t\t\t\tvar isDisableTagged = ($('#tagged_section_match').val() == PCAP_MATCH_SECT_NONE);\n\t\t\t\t\tdisableInput(idAllList, isDisableAll, isDisableAll);\n\t\t\t\t\tdisableInput(idTaggedList, isDisableTagged, false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'untagged_section_match':\n\t\t\t\t\t// On selecting an untagged Section match\n\t\t\t\t\tdisableInput(idUntaggedList, (this.value == PCAP_MATCH_SECT_NONE), false);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'tagged_section_match':\n\t\t\t\t\t// On selecting a tagged Section match\n\t\t\t\t\tdisableInput(idTaggedList, (this.value == PCAP_MATCH_SECT_NONE), false);\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\t// On selecting a Type Match, handle the respective input field\n\t\t\t\t\tdisableElement((this.id).replace('_match', ''), !(this.value == PCAP_MATCH_ATTR_NONEOF ||\n\t\t\t\t\t    this.value == PCAP_MATCH_ATTR_ANYOF || this.value == PCAP_MATCH_ATTR_ALLOF ||\n\t\t\t\t\t    this.value == PCAP_MATCH_TYPE_ALLOF || this.value == PCAP_MATCH_TYPE_ANYOF));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\n\t// On initial page load\n\tif ($('#filter').val() != PCAP_FPRESET_CUSTOM) {\n\t\thideClass('custom-options', true);\n\t\tdisableInput(idAllList, true, true);\n\t} else {\n\t\thideClass('custom-options', false);\n\t\tdisableInput(idUntaggedList, ($('#untagged_section_match').val() == PCAP_MATCH_SECT_NONE), false);\n\t\tdisableInput(idTaggedList, ($('#tagged_section_match').val() == PCAP_MATCH_SECT_NONE), false);\n\t}\n});\n//]]>\n</script>\n\n<?php\n\n// page footer\ninclude('foot.inc');\n"], "filenames": ["src/usr/local/www/diag_packet_capture.php"], "buggy_code_start_loc": [121], "buggy_code_end_loc": [764], "fixing_code_start_loc": [122], "fixing_code_end_loc": [774], "type": "NVD-CWE-noinfo", "message": "An issue in Netgate pfSense Plus v.23.05.1 and before and pfSense CE v.2.7.0 allows a remote attacker to execute arbitrary code via a crafted request to the packet_capture.php file.", "other": {"cve": {"id": "CVE-2023-48123", "sourceIdentifier": "cve@mitre.org", "published": "2023-12-06T20:15:07.240", "lastModified": "2023-12-12T16:11:35.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue in Netgate pfSense Plus v.23.05.1 and before and pfSense CE v.2.7.0 allows a remote attacker to execute arbitrary code via a crafted request to the packet_capture.php file."}, {"lang": "es", "value": "Un problema en Netgate pfSense Plus v.23.05.1 y anteriores y pfSense CE v.2.7.0 permite a un atacante remoto ejecutar c\u00f3digo arbitrario a trav\u00e9s de una solicitud manipulada al archivo packet_capture.php."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.7.0", "matchCriteriaId": "B58A09CC-355B-49BD-908B-ED3058794307"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netgate:pfsense_plus:*:*:*:*:*:*:*:*", "versionEndIncluding": "23.05.1", "matchCriteriaId": "D1309A70-521F-4F6C-8BE7-AE9460C039A6"}]}]}], "references": [{"url": "https://docs.netgate.com/downloads/pfSense-SA-23_11.webgui.asc", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/pfsense/pfsense/commit/f72618c4abb61ea6346938d0c93df9078736b775", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://redmine.pfsense.org/issues/14809", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/pfsense/pfsense/commit/f72618c4abb61ea6346938d0c93df9078736b775"}}