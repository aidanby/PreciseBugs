{"buggy_code": ["#!/usr/bin/env python3\n# -*-coding:UTF-8 -*\n\"\"\"\nThe ZMQ_Feed_Q Module\n=====================\n\nThis module is consuming the Redis-list created by the ZMQ_Feed_Q Module,\nAnd save the paste on disk to allow others modules to work on them.\n\n..todo:: Be able to choose to delete or not the saved paste after processing.\n..todo:: Store the empty paste (unprocessed) somewhere in Redis.\n\n..note:: Module ZMQ_Something_Q and ZMQ_Something are closely bound, always put\nthe same Subscriber name in both of them.\n\nRequirements\n------------\n\n*Need running Redis instances.\n*Need the ZMQ_Feed_Q Module running to be able to work properly.\n\n\"\"\"\nimport base64\nimport os\nimport time\nimport uuid\nfrom pubsublogger import publisher\n\nfrom Helper import Process\n\nimport magic\n\ndef rreplace(s, old, new, occurrence):\n    li = s.rsplit(old, occurrence)\n    return new.join(li)\n\n\nif __name__ == '__main__':\n    publisher.port = 6380\n    publisher.channel = 'Script'\n    processed_paste = 0\n    time_1 = time.time()\n\n    config_section = 'Global'\n\n    p = Process(config_section)\n\n    PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))\n    PASTES_FOLDERS = PASTES_FOLDER + '/'\n\n    # LOGGING #\n    publisher.info(\"Feed Script started to receive & publish.\")\n\n    while True:\n\n        message = p.get_from_set()\n        # Recovering the streamed message informations.\n        if message is not None:\n            splitted = message.split()\n            if len(splitted) == 2:\n                paste, gzip64encoded = splitted\n            else:\n                # TODO Store the name of the empty paste inside a Redis-list.\n                print(\"Empty Paste: not processed\")\n                publisher.debug(\"Empty Paste: {0} not processed\".format(message))\n                continue\n        else:\n            print(\"Empty Queues: Waiting...\")\n            if int(time.time() - time_1) > 30:\n                to_print = 'Global; ; ; ;glob Processed {0} paste(s)'.format(processed_paste)\n                print(to_print)\n                #publisher.info(to_print)\n                time_1 = time.time()\n                processed_paste = 0\n            time.sleep(1)\n            continue\n\n        file_name_paste = paste.split('/')[-1]\n        if len(file_name_paste)>255:\n            new_file_name_paste = '{}{}.gz'.format(file_name_paste[:215], str(uuid.uuid4()))\n            paste = rreplace(paste, file_name_paste, new_file_name_paste, 1)\n\n        # Creating the full filepath\n        filename = os.path.join(PASTES_FOLDER, paste)\n\n        dirname = os.path.dirname(filename)\n        if not os.path.exists(dirname):\n            os.makedirs(dirname)\n\n        decoded = base64.standard_b64decode(gzip64encoded)\n\n        with open(filename, 'wb') as f:\n            f.write(decoded)\n        '''try:\n            decoded2 = gunzip_bytes_obj(decoded)\n        except:\n            decoded2 =''\n\n        type = magic.from_buffer(decoded2, mime=True)\n\n        if type!= 'text/x-c++' and type!= 'text/html' and type!= 'text/x-c' and type!= 'text/x-python' and type!= 'text/x-php' and type!= 'application/xml' and type!= 'text/x-shellscript' and type!= 'text/plain' and type!= 'text/x-diff' and type!= 'text/x-ruby':\n\n            print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')\n            print(filename)\n            print(type)\n            print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')\n        '''\n\n        # remove PASTES_FOLDER from item path (crawled item + submited)\n        if PASTES_FOLDERS in paste:\n            paste = paste.replace(PASTES_FOLDERS, '', 1)\n\n        p.populate_set_out(paste)\n        processed_paste+=1\n"], "fixing_code": ["#!/usr/bin/env python3\n# -*-coding:UTF-8 -*\n\"\"\"\nThe ZMQ_Feed_Q Module\n=====================\n\nThis module is consuming the Redis-list created by the ZMQ_Feed_Q Module,\nAnd save the paste on disk to allow others modules to work on them.\n\n..todo:: Be able to choose to delete or not the saved paste after processing.\n..todo:: Store the empty paste (unprocessed) somewhere in Redis.\n\n..note:: Module ZMQ_Something_Q and ZMQ_Something are closely bound, always put\nthe same Subscriber name in both of them.\n\nRequirements\n------------\n\n*Need running Redis instances.\n*Need the ZMQ_Feed_Q Module running to be able to work properly.\n\n\"\"\"\nimport base64\nimport os\nimport time\nimport uuid\nfrom pubsublogger import publisher\n\nfrom Helper import Process\n\nimport magic\n\ndef rreplace(s, old, new, occurrence):\n    li = s.rsplit(old, occurrence)\n    return new.join(li)\n\n\nif __name__ == '__main__':\n    publisher.port = 6380\n    publisher.channel = 'Script'\n    processed_paste = 0\n    time_1 = time.time()\n\n    config_section = 'Global'\n\n    p = Process(config_section)\n\n    # get and sanityze PASTE DIRECTORY\n    PASTES_FOLDER = os.path.join(os.environ['AIL_HOME'], p.config.get(\"Directories\", \"pastes\"))\n    PASTES_FOLDERS = PASTES_FOLDER + '/'\n    PASTES_FOLDERS = os.path.join(os.path.realpath(PASTES_FOLDERS), '')\n\n    # LOGGING #\n    publisher.info(\"Feed Script started to receive & publish.\")\n\n    while True:\n\n        message = p.get_from_set()\n        # Recovering the streamed message informations.\n        if message is not None:\n            splitted = message.split()\n            if len(splitted) == 2:\n                paste, gzip64encoded = splitted\n            else:\n                # TODO Store the name of the empty paste inside a Redis-list.\n                print(\"Empty Paste: not processed\")\n                publisher.debug(\"Empty Paste: {0} not processed\".format(message))\n                continue\n        else:\n            print(\"Empty Queues: Waiting...\")\n            if int(time.time() - time_1) > 30:\n                to_print = 'Global; ; ; ;glob Processed {0} paste(s)'.format(processed_paste)\n                print(to_print)\n                #publisher.info(to_print)\n                time_1 = time.time()\n                processed_paste = 0\n            time.sleep(1)\n            continue\n\n        # remove PASTES_FOLDER from item path (crawled item + submited)\n        if PASTES_FOLDERS in paste:\n            paste = paste.replace(PASTES_FOLDERS, '', 1)\n\n        file_name_paste = paste.split('/')[-1]\n        if len(file_name_paste)>255:\n            new_file_name_paste = '{}{}.gz'.format(file_name_paste[:215], str(uuid.uuid4()))\n            paste = rreplace(paste, file_name_paste, new_file_name_paste, 1)\n\n        # Creating the full filepath\n        filename = os.path.join(PASTES_FOLDER, paste)\n        filename = os.path.realpath(filename)\n\n        # incorrect filename\n        if not os.path.commonprefix([filename, PASTES_FOLDER]) == PASTES_FOLDER:\n            print('Path traversal detected {}'.format(filename))\n            publisher.warning('Global; Path traversal detected')\n        else:\n            dirname = os.path.dirname(filename)\n            if not os.path.exists(dirname):\n                os.makedirs(dirname)\n\n            decoded = base64.standard_b64decode(gzip64encoded)\n\n            with open(filename, 'wb') as f:\n                f.write(decoded)\n            '''try:\n                decoded2 = gunzip_bytes_obj(decoded)\n            except:\n                decoded2 =''\n\n            type = magic.from_buffer(decoded2, mime=True)\n\n            if type!= 'text/x-c++' and type!= 'text/html' and type!= 'text/x-c' and type!= 'text/x-python' and type!= 'text/x-php' and type!= 'application/xml' and type!= 'text/x-shellscript' and type!= 'text/plain' and type!= 'text/x-diff' and type!= 'text/x-ruby':\n\n                print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')\n                print(filename)\n                print(type)\n                print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------')\n            '''\n\n            p.populate_set_out(paste)\n            processed_paste+=1\n"], "filenames": ["bin/Global.py"], "buggy_code_start_loc": [47], "buggy_code_end_loc": [115], "fixing_code_start_loc": [48], "fixing_code_end_loc": [123], "type": "CWE-22", "message": "Global.py in AIL framework 2.8 allows path traversal.", "other": {"cve": {"id": "CVE-2020-8545", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-03T16:15:11.997", "lastModified": "2020-02-06T17:31:09.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Global.py in AIL framework 2.8 allows path traversal."}, {"lang": "es", "value": "El archivo Global.py en AIL framework versi\u00f3n 2.8, permite el recorrido de la ruta."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:circl:ail_framework:2.8:*:*:*:*:*:*:*", "matchCriteriaId": "896751FC-D1E1-496A-905C-45469F29EF8B"}]}]}], "references": [{"url": "https://github.com/CIRCL/AIL-framework/commit/e808840f957c810b8e3944cba808716dc722581b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CIRCL/AIL-framework/commit/e808840f957c810b8e3944cba808716dc722581b"}}