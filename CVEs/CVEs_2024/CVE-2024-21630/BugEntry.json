{"buggy_code": ["import re\nfrom datetime import datetime, timedelta\nfrom typing import TYPE_CHECKING, List, Optional, Sequence, Union\nfrom unittest.mock import patch\nfrom urllib.parse import quote, urlencode\n\nimport orjson\nimport time_machine\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.http import HttpRequest\nfrom django.test import override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom returns.curry import partial\nfrom typing_extensions import override\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    create_confirmation_link,\n    get_object_from_key,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.actions.create_realm import do_change_realm_subdomain, do_create_realm\nfrom zerver.actions.create_user import (\n    do_create_user,\n    process_new_human_user,\n    set_up_streams_for_new_human_user,\n)\nfrom zerver.actions.default_streams import do_add_default_stream\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_revoke_multi_use_invite,\n    too_many_recent_realm_invites,\n)\nfrom zerver.actions.realm_settings import (\n    do_change_realm_permission_group_setting,\n    do_change_realm_plan_type,\n    do_set_realm_property,\n)\nfrom zerver.actions.user_settings import do_change_full_name\nfrom zerver.actions.users import change_user_is_active\nfrom zerver.context_processors import common_context\nfrom zerver.lib.create_user import create_user\nfrom zerver.lib.default_streams import get_default_streams_for_realm_as_dicts\nfrom zerver.lib.send_email import FromAddress, deliver_scheduled_emails, send_future_email\nfrom zerver.lib.streams import ensure_stream\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import find_key_by_email\nfrom zerver.models import (\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    ScheduledEmail,\n    Stream,\n    UserGroup,\n    UserMessage,\n    UserProfile,\n)\nfrom zerver.models.groups import SystemGroups\nfrom zerver.models.realms import get_realm\nfrom zerver.models.streams import get_stream\nfrom zerver.models.users import get_user_by_delivery_email\nfrom zerver.views.invite import INVITATION_LINK_VALIDITY_MINUTES, get_invitee_emails_set\nfrom zerver.views.registration import accounts_home\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass StreamSetupTest(ZulipTestCase):\n    def add_messages_to_stream(self, stream_name: str) -> None:\n        # Make sure that add_new_user_history has some messages\n        # to process, so that we get consistent query counts.\n        user = self.example_user(\"hamlet\")\n        self.subscribe(user, stream_name)\n\n        for i in range(5):\n            self.send_stream_message(user, stream_name, f\"test {i}\")\n\n    def create_simple_new_user(self, realm: Realm, email: str) -> UserProfile:\n        # We don't need to get bogged down in all the details of creating\n        # full users to test how to set up streams.\n        return create_user(\n            email=email,\n            password=None,\n            realm=realm,\n            full_name=\"full_name\",\n        )\n\n    def test_query_counts_for_new_user_using_default_streams(self) -> None:\n        DefaultStream.objects.all().delete()\n        realm = get_realm(\"zulip\")\n\n        for i in range(25):\n            stream = ensure_stream(realm, f\"stream{i}\", acting_user=None)\n            do_add_default_stream(stream)\n\n        self.add_messages_to_stream(\"stream5\")\n\n        new_user = self.create_simple_new_user(realm, \"alice@zulip.com\")\n\n        with self.assert_database_query_count(12):\n            set_up_streams_for_new_human_user(\n                user_profile=new_user,\n                prereg_user=None,\n                default_stream_groups=[],\n            )\n\n    def test_query_counts_when_admin_assigns_streams(self) -> None:\n        admin = self.example_user(\"iago\")\n        realm = admin.realm\n\n        streams = [\n            get_stream(\"Denmark\", realm),\n            get_stream(\"Rome\", realm),\n            get_stream(\"Scotland\", realm),\n            get_stream(\"Scotland\", realm),\n            get_stream(\"Verona\", realm),\n            get_stream(\"Venice\", realm),\n        ]\n\n        self.add_messages_to_stream(\"Rome\")\n\n        new_user_email = \"bob@zulip.com\"\n\n        do_invite_users(\n            admin,\n            [new_user_email],\n            streams,\n            invite_expires_in_minutes=1000,\n        )\n\n        prereg_user = PreregistrationUser.objects.get(email=new_user_email)\n\n        new_user = self.create_simple_new_user(realm, new_user_email)\n\n        with self.assert_database_query_count(13):\n            set_up_streams_for_new_human_user(\n                user_profile=new_user,\n                prereg_user=prereg_user,\n                default_stream_groups=[],\n            )\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str], clear: bool = False) -> None:\n        self.assert_length(mail.outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in mail.outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(mail.outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(mail.outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(mail.outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(mail.outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        if clear:\n            mail.outbox = []\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_minutes: Optional[int] = INVITATION_LINK_VALIDITY_MINUTES,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n        realm: Optional[Realm] = None,\n    ) -> \"TestHttpResponse\":\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = [self.get_stream_id(stream_name, realm=realm) for stream_name in stream_names]\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_minutes\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_minutes\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n            subdomain=realm.string_id if realm else \"zulip\",\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        self.login_user(user_profile)\n\n        def try_invite(\n            num_invitees: int,\n            *,\n            default_realm_max: int,\n            new_realm_max: int,\n            realm_max: int,\n            open_realm_creation: bool = True,\n            realm: Optional[Realm] = None,\n            stream_name: str = \"Denmark\",\n        ) -> \"TestHttpResponse\":\n            if realm is None:\n                realm = get_realm(\"zulip\")\n            invitees = \",\".join(\n                [f\"{realm.string_id}-{i:02}@zulip.com\" for i in range(num_invitees)]\n            )\n            with self.settings(\n                OPEN_REALM_CREATION=open_realm_creation,\n                INVITES_DEFAULT_REALM_DAILY_MAX=default_realm_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=[(1, new_realm_max)],\n            ):\n                realm.max_invites = realm_max\n                realm.save()\n                return self.invite(invitees, [stream_name], realm=realm)\n\n        # Trip the \"new realm\" limits\n        realm.date_created = timezone_now()\n        realm.save()\n        result = try_invite(30, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # If some other realm consumes some invites, it affects our realm.  Invite 20 users in lear:\n        lear_realm = get_realm(\"lear\")\n        lear_realm.date_created = timezone_now()\n        lear_realm.save()\n        self.login_user(self.lear_user(\"king\"))\n        result = try_invite(\n            20,\n            default_realm_max=50,\n            new_realm_max=20,\n            realm_max=40,\n            realm=lear_realm,\n            stream_name=\"general\",\n        )\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"lear-{i:02}@zulip.com\" for i in range(20)], clear=True)\n\n        # Which prevents inviting 1 in our realm:\n        self.login_user(user_profile)\n        result = try_invite(1, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # If our realm max is over the default realm's, we're exempt from INVITES_NEW_REALM_LIMIT_DAYS\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 10 invites.  Trying to invite 15 people, even if\n        # 10 of them are the same, still trips the limit (10 previous\n        # + 15 in this submission > 20 realm max)\n        result = try_invite(15, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # Inviting 10 more people (to the realm max of 20) works, and\n        # sends emails to the same 10 users again.\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 20 invites.  The 10 we just sent do count against\n        # us if we send to them again, since we did send mail\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # We've sent 20 invites.  The realm is exempt from the new realm max\n        # (INVITES_NEW_REALM_LIMIT_DAYS) if it is old enough\n        realm.date_created = timezone_now() - timedelta(days=8)\n        realm.save()\n        result = try_invite(10, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 30 invites.  None of the limits matter if open\n        # realm creation is disabled.\n        result = try_invite(\n            10, default_realm_max=30, new_realm_max=20, realm_max=10, open_realm_creation=False\n        )\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 40 invites \"today\".  Fast-forward 48 hours\n        # and ensure that we can invite more people\n        with time_machine.travel(timezone_now() + timedelta(hours=48), tick=False):\n            result = try_invite(5, default_realm_max=30, new_realm_max=20, realm_max=10)\n            self.assert_json_success(result)\n            self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(5)], clear=True)\n\n            # We've sent 5 invites.  Ensure we can trip the fresh \"today\" limit for the realm\n            result = try_invite(10, default_realm_max=30, new_realm_max=20, realm_max=10)\n            self.assert_json_error_contains(result, \"reached the limit\")\n            self.check_sent_emails([])\n\n            # We've sent 5 invites.  Reset the realm to be \"recently\"\n            # created, and ensure that we can trip the whole-server\n            # limit\n            realm.date_created = timezone_now() - timedelta(days=3)\n            realm.save()\n            result = try_invite(10, default_realm_max=50, new_realm_max=10, realm_max=40)\n            self.assert_json_error_contains(result, \"reached the limit\")\n            self.check_sent_emails([])\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_limited_plan_heuristics(self) -> None:\n        # There additional limits only apply if OPEN_REALM_CREATION is\n        # True and the plan is \"limited,\" which is primarily only\n        # relevant on Zulip Cloud.\n\n        realm = do_create_realm(\"sdfoijt23489fuskdfjhksdf\", \"Totally Normal\")\n        realm.plan_type = Realm.PLAN_TYPE_LIMITED\n        realm.invite_required = False\n        realm.save()\n\n        # Create a first user\n        admin_user = do_create_user(\n            \"someone@example.com\",\n            \"password\",\n            realm,\n            \"full name\",\n            role=UserProfile.ROLE_REALM_OWNER,\n            realm_creation=True,\n            acting_user=None,\n        )\n\n        # Inviting would work at all\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 1))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 1 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 1.0, 2 allowed\"\n                )\n            ],\n        )\n\n        # This realm is currently very suspicious, so can only invite\n        # 2 users at once (2x current 1 user)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 2))\n            self.assertTrue(too_many_recent_realm_invites(realm, 3))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 2 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 2.0, 2 allowed\"\n                ),\n                (\n                    \"WARNING:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 3 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 3.0, 2 allowed\"\n                ),\n            ],\n        )\n\n        # Having another user makes it slightly less suspicious, and\n        # also able to invite more in ratio with the current count of\n        # users (3x current 2 users)\n        self.register(\"other@example.com\", \"test\", subdomain=realm.string_id)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 6))\n            self.assertTrue(too_many_recent_realm_invites(realm, 7))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,no-messages-sent) \"\n                    \"inviting 6 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 3.0, 3 allowed\"\n                ),\n                (\n                    \"WARNING:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,no-messages-sent) \"\n                    \"inviting 7 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 3.5, 3 allowed\"\n                ),\n            ],\n        )\n\n        # Remove some more warning flags\n        do_change_realm_subdomain(realm, \"reasonable\", acting_user=None)\n        realm.description = \"A real place\"\n        realm.date_created = timezone_now() - timedelta(hours=2)\n        realm.save()\n\n        # This is now more allowable (5x current 2 users)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 10))\n            self.assertTrue(too_many_recent_realm_invites(realm, 11))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 10 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.0, 5 allowed\"\n                ),\n                (\n                    \"WARNING:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 11 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.5, 5 allowed\"\n                ),\n            ],\n        )\n\n        # If we have a different max_invites on the realm that kicks in, though\n        realm.max_invites = 8\n        realm.save()\n        self.assertFalse(too_many_recent_realm_invites(realm, 8))\n        self.assertTrue(too_many_recent_realm_invites(realm, 9))\n\n        # And if we have a non-default max invite then that applies\n        # but not the heuristics (which would limit us to 10, here)\n        realm.max_invites = 12\n        realm.save()\n        self.assertFalse(too_many_recent_realm_invites(realm, 12))\n        self.assertTrue(too_many_recent_realm_invites(realm, 13))\n\n        # Not being a limited plan also opens us up from the\n        # heuristics.  First, set us back to the default invite limit\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 10))\n            self.assertTrue(too_many_recent_realm_invites(realm, 11))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 10 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.0, 5 allowed\"\n                ),\n                (\n                    \"WARNING:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 11 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.5, 5 allowed\"\n                ),\n            ],\n        )\n        # Become a Standard plan\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_STANDARD, acting_user=admin_user)\n        self.assertFalse(too_many_recent_realm_invites(realm, 3000))\n        self.assertTrue(too_many_recent_realm_invites(realm, 3001))\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_STANDARD_FREE, acting_user=admin_user)\n        self.assertFalse(too_many_recent_realm_invites(realm, 3000))\n        self.assertTrue(too_many_recent_realm_invites(realm, 3001))\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(\n                self.nonreg_email(\"bob\"),\n                [\"Denmark\"],\n                invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n            )\n        self.assert_json_success(result)\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = f\"{cross_realm_bot_email},{legit_new_email}\"\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            (\n                \"Some of those addresses are already using Zulip, so we didn't send them an\"\n                \" invitation. We did send invitations to everyone else!\"\n            ),\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Invalid invite_as\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_users_with_specified_streams(self) -> None:\n        invitee = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, realm) for stream_name in stream_names]\n        self.assert_json_success(self.invite(invitee, stream_names))\n        self.assertTrue(find_key_by_email(invitee))\n        self.submit_reg_form_for_user(invitee, \"password\")\n        self.check_user_subscribed_only_to_streams(\"alice\", streams)\n\n        invitee = self.nonreg_email(\"bob\")\n        self.assert_json_success(self.invite(invitee, []))\n        self.assertTrue(find_key_by_email(invitee))\n\n        default_streams = get_default_streams_for_realm_as_dicts(realm.id)\n        self.assert_length(default_streams, 1)\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        # If no streams are provided, user is not subscribed to\n        # default streams as well.\n        self.check_user_subscribed_only_to_streams(\"bob\", [])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            return user_profile.can_invite_users_by_email()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - timedelta(days=realm.waiting_period_threshold - 1)\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"@_**{invitee_profile.full_name}|{invitee_profile.id}** accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        Names are escaped in the emails which are sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        assert isinstance(mail.outbox[0], EmailMultiAlternatives)\n        assert isinstance(mail.outbox[0].alternatives[0][0], str)\n        body = self.normalize_string(mail.outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color: #5f5ec7;text-decoration: underline;\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                partial(PreregistrationUser.objects.get, email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\n            \"does not allow signups using emails with your email domain\", result\n        )\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"does not allow signups using disposable email addresses.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response('does not allow signups using emails that contain \"+\".', result)\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invite_without_permission_to_subscribe_others(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        invitee = self.nonreg_email(\"alice\")\n\n        self.login(\"hamlet\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_error(\n            result, \"You do not have permission to subscribe other users to streams.\"\n        )\n\n        result = self.invite(invitee, [])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"bob\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"test\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_invitation_reminder_email(self) -> None:\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_minutes = 2 * 24 * 60\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_minutes=validity_in_minutes\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(mail.outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(mail.outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(mail.outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(mail.outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=4 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address=\"alice@zulip.com\", type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=3 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address=\"bob@zulip.com\", type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            0,\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyError) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION], mark_object_used=True)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyError.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - timedelta(weeks=3)\n        with time_machine.travel(date_sent, tick=False):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_object(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_minutes=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = [\n            get_stream(stream_name, self.user_profile.realm)\n            for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_minutes=invite_expires_in_minutes\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        created_user = do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_USED\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n        self.assertEqual(accepted_invite[0].created_user, created_user)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n        with self.assertRaises(AssertionError):\n            process_new_human_user(created_user, prereg_user)\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response(\n            [\"Enter your account details to complete registration.\"], response\n        )\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        new_prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        new_confirmation_link = create_confirmation_link(\n            new_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        new_registration_key = new_confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": new_registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response[\"Location\"],\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_key_cant_be_reused(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        prereg_user.refresh_from_db()\n        self.assertIsNotNone(prereg_user.created_user)\n\n        # Now attempt to reuse the same key.\n        result = self.client_post(\"/accounts/register/\", {\"key\": registration_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n        # We want to simulate the organization having exactly all their licenses\n        # used, to verify that joining as a regular user is not allowed,\n        # but as a guest still works (guests are free up to a certain number).\n        current_seat_count = get_latest_seat_count(realm)\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            realm, current_seat_count, current_seat_count\n        )\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"Organization cannot accept new members right now\"], response\n        )\n\n        guest_prereg_user = PreregistrationUser.objects.create(\n            email=email,\n            referred_by=inviter,\n            realm=realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n        )\n        confirmation_link = create_confirmation_link(\n            guest_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            hamlet,\n            [\"TestThree@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            othello,\n            [\"TestFour@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 6)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 2)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_USED\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        with time_machine.travel((timezone_now() - timedelta(days=3)), tick=False):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=invite_expires_in_minutes,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three,\n            Confirmation.INVITATION,\n            validity_in_minutes=invite_expires_in_minutes,\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        with time_machine.travel((timezone_now() - timedelta(days=1000)), tick=False):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=100 * 24 * 60,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Invitation has already been revoked\")\n\n        # Test deleting owner multiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_minutes = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test non-admins can only delete invitations created by them.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n\n        self.login(\"cordelia\")\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n        self.login(\"hamlet\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite_in_mit,\n            Confirmation.MULTIUSE_INVITE,\n            validity_in_minutes=validity_in_minutes,\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        non_existent_id = MultiuseInvite.objects.count() + 9999\n        error_result = self.client_delete(f\"/json/invites/multiuse/{non_existent_id}\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_USED)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    @override\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    @override\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_minutes = 2 * 24 * 60\n        with time_machine.travel(date_sent, tick=False):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].endswith(f\"/accounts/send_confirm/?email={quote(email)}\")\n        )\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"check your email\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        # Verify the PreregistrationUser object was set up as expected.\n        prereg_user = PreregistrationUser.objects.last()\n        multiuse_invite = MultiuseInvite.objects.last()\n\n        assert prereg_user is not None\n        self.assertEqual(prereg_user.email, email)\n        self.assertEqual(prereg_user.multiuse_invite, multiuse_invite)\n\n        mail.outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - timedelta(days=1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS + 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_revoked_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = self.generate_multiuse_invite_link()\n        multiuse_invite = MultiuseInvite.objects.last()\n        assert multiuse_invite is not None\n        do_revoke_multi_use_invite(multiuse_invite)\n\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link in the system.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        name3 = \"alice\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n        email3 = self.nonreg_email(name3)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n        streams = []\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email3, invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm_as_dicts(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(name3, [])\n\n    def test_multiuse_link_different_realms(self) -> None:\n        \"\"\"\n        Verify that an invitation generated for one realm can't be used\n        to join another.\n        \"\"\"\n        lear_realm = get_realm(\"lear\")\n        self.realm = lear_realm\n        invite_link = self.generate_multiuse_invite_link(streams=[])\n        key = invite_link.split(\"/\")[-2]\n\n        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n        # Now we want to test the accounts_home function, which can't be used\n        # for the multiuse invite case via an HTTP request, but is still supposed\n        # to do its own verification that the realms match as a hardening measure\n        # against a caller that fails to do that.\n        request = HttpRequest()\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n        multiuse_object = confirmation.content_object\n        with patch(\n            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n        ), self.assertRaises(AssertionError):\n            accounts_home(request, multiuse_object=multiuse_object)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n        self.login(\"iago\")\n        stream_ids = []\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"alice\"), invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm_as_dicts(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(\"alice\", [])\n\n    def test_create_multiuse_invite_group_setting(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n        nobody_system_group = UserGroup.objects.get(\n            name=SystemGroups.NOBODY, realm=realm, is_system_group=True\n        )\n\n        # Default value of create_multiuse_invite_group is administrators\n        self.login(\"shiva\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        self.login(\"iago\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test1\"), invite_link)\n\n        self.login(\"desdemona\")\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", nobody_system_group, acting_user=None\n        )\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_only_owner_can_change_create_multiuse_invite_group(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        self.login(\"iago\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"create_multiuse_invite_group\": orjson.dumps(full_members_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"create_multiuse_invite_group\": orjson.dumps(full_members_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.create_multiuse_invite_group_id, full_members_system_group.id)\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_multiuse_link_for_inviting_as_admin(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_multiuse_link_for_inviting_as_moderator(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"MODERATOR\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"shiva\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"MODERATOR\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps([54321]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID 54321. No invites were sent.\")\n\n    def test_create_multiuse_link_invalid_invite_as_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"GUEST_USER\"] + 1).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid invite_as\")\n", "import re\nfrom typing import List, Optional, Sequence, Set\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import gettext as _\n\nfrom confirmation import settings as confirmation_settings\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_resend_user_invite_email,\n    do_revoke_multi_use_invite,\n    do_revoke_user_invite,\n)\nfrom zerver.decorator import require_member_or_admin\nfrom zerver.lib.exceptions import JsonableError, OrganizationOwnerRequiredError\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.response import json_success\nfrom zerver.lib.streams import access_stream_by_id\nfrom zerver.lib.validator import check_int, check_int_in, check_list, check_none_or\nfrom zerver.models import MultiuseInvite, PreregistrationUser, Stream, UserProfile\n\n# Convert INVITATION_LINK_VALIDITY_DAYS into minutes.\n# Because mypy fails to correctly infer the type of the validator, we want this constant\n# to be Optional[int] to avoid a mypy error when using it as the default value.\n# https://github.com/python/mypy/issues/13234\nINVITATION_LINK_VALIDITY_MINUTES: Optional[int] = 24 * 60 * settings.INVITATION_LINK_VALIDITY_DAYS\n\n\ndef check_role_based_permissions(\n    invited_as: int, user_profile: UserProfile, *, require_admin: bool\n) -> None:\n    if (\n        invited_as == PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        and not user_profile.is_realm_owner\n    ):\n        raise OrganizationOwnerRequiredError\n\n    if require_admin and not user_profile.is_realm_admin:\n        raise JsonableError(_(\"Must be an organization administrator\"))\n\n\n@require_member_or_admin\n@has_request_variables\ndef invite_users_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    invitee_emails_raw: str = REQ(\"invitee_emails\"),\n    invite_expires_in_minutes: Optional[int] = REQ(\n        json_validator=check_none_or(check_int), default=INVITATION_LINK_VALIDITY_MINUTES\n    ),\n    invite_as: int = REQ(\n        json_validator=check_int_in(\n            list(PreregistrationUser.INVITE_AS.values()),\n        ),\n        default=PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ),\n    stream_ids: List[int] = REQ(json_validator=check_list(check_int)),\n) -> HttpResponse:\n    if not user_profile.can_invite_users_by_email():\n        # Guest users case will not be handled here as it will\n        # be handled by the decorator above.\n        raise JsonableError(_(\"Insufficient permission\"))\n\n    require_admin = invite_as in [\n        # Owners can only be invited by owners, checked by separate\n        # logic in check_role_based_permissions.\n        PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        PreregistrationUser.INVITE_AS[\"MODERATOR\"],\n    ]\n    check_role_based_permissions(invite_as, user_profile, require_admin=require_admin)\n\n    if not invitee_emails_raw:\n        raise JsonableError(_(\"You must specify at least one email address.\"))\n\n    invitee_emails = get_invitee_emails_set(invitee_emails_raw)\n\n    streams: List[Stream] = []\n    for stream_id in stream_ids:\n        try:\n            (stream, sub) = access_stream_by_id(user_profile, stream_id)\n        except JsonableError:\n            raise JsonableError(\n                _(\"Stream does not exist with id: {stream_id}. No invites were sent.\").format(\n                    stream_id=stream_id\n                )\n            )\n        streams.append(stream)\n\n    if len(streams) and not user_profile.can_subscribe_other_users():\n        raise JsonableError(_(\"You do not have permission to subscribe other users to streams.\"))\n\n    do_invite_users(\n        user_profile,\n        invitee_emails,\n        streams,\n        invite_expires_in_minutes=invite_expires_in_minutes,\n        invite_as=invite_as,\n    )\n    return json_success(request)\n\n\ndef get_invitee_emails_set(invitee_emails_raw: str) -> Set[str]:\n    invitee_emails_list = set(re.split(r\"[,\\n]\", invitee_emails_raw))\n    invitee_emails = set()\n    for email in invitee_emails_list:\n        is_email_with_name = re.search(r\"<(?P<email>.*)>\", email)\n        if is_email_with_name:\n            email = is_email_with_name.group(\"email\")\n        invitee_emails.add(email.strip())\n    return invitee_emails\n\n\n@require_member_or_admin\ndef get_user_invites(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    all_users = do_get_invites_controlled_by_user(user_profile)\n    return json_success(request, data={\"invites\": all_users})\n\n\n@require_member_or_admin\n@has_request_variables\ndef revoke_user_invite(\n    request: HttpRequest, user_profile: UserProfile, prereg_id: int\n) -> HttpResponse:\n    try:\n        prereg_user = PreregistrationUser.objects.get(id=prereg_id)\n    except PreregistrationUser.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.referred_by_id != user_profile.id:\n        check_role_based_permissions(prereg_user.invited_as, user_profile, require_admin=True)\n\n    do_revoke_user_invite(prereg_user)\n    return json_success(request)\n\n\n@require_member_or_admin\n@has_request_variables\ndef revoke_multiuse_invite(\n    request: HttpRequest, user_profile: UserProfile, invite_id: int\n) -> HttpResponse:\n    try:\n        invite = MultiuseInvite.objects.get(id=invite_id)\n    except MultiuseInvite.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if invite.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if invite.referred_by_id != user_profile.id:\n        check_role_based_permissions(invite.invited_as, user_profile, require_admin=True)\n\n    if invite.status == confirmation_settings.STATUS_REVOKED:\n        raise JsonableError(_(\"Invitation has already been revoked\"))\n\n    do_revoke_multi_use_invite(invite)\n    return json_success(request)\n\n\n@require_member_or_admin\n@has_request_variables\ndef resend_user_invite_email(\n    request: HttpRequest, user_profile: UserProfile, prereg_id: int\n) -> HttpResponse:\n    try:\n        prereg_user = PreregistrationUser.objects.get(id=prereg_id)\n    except PreregistrationUser.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    # Structurally, any invitation the user can actually access should\n    # have a referred_by set for the user who created it.\n    if prereg_user.referred_by is None or prereg_user.referred_by.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.referred_by_id != user_profile.id:\n        check_role_based_permissions(prereg_user.invited_as, user_profile, require_admin=True)\n\n    timestamp = do_resend_user_invite_email(prereg_user)\n    return json_success(request, data={\"timestamp\": timestamp})\n\n\n@require_member_or_admin\n@has_request_variables\ndef generate_multiuse_invite_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    invite_expires_in_minutes: Optional[int] = REQ(\n        json_validator=check_none_or(check_int), default=INVITATION_LINK_VALIDITY_MINUTES\n    ),\n    invite_as: int = REQ(\n        json_validator=check_int_in(\n            list(PreregistrationUser.INVITE_AS.values()),\n        ),\n        default=PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ),\n    stream_ids: Sequence[int] = REQ(json_validator=check_list(check_int), default=[]),\n) -> HttpResponse:\n    if not user_profile.can_create_multiuse_invite_to_realm():\n        # Guest users case will not be handled here as it will\n        # be handled by the decorator above.\n        raise JsonableError(_(\"Insufficient permission\"))\n\n    require_admin = invite_as in [\n        # Owners can only be invited by owners, checked by separate\n        # logic in check_role_based_permissions.\n        PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        PreregistrationUser.INVITE_AS[\"MODERATOR\"],\n    ]\n    check_role_based_permissions(invite_as, user_profile, require_admin=require_admin)\n\n    streams = []\n    for stream_id in stream_ids:\n        try:\n            (stream, sub) = access_stream_by_id(user_profile, stream_id)\n        except JsonableError:\n            raise JsonableError(\n                _(\"Invalid stream ID {stream_id}. No invites were sent.\").format(\n                    stream_id=stream_id\n                )\n            )\n        streams.append(stream)\n\n    invite_link = do_create_multiuse_invite_link(\n        user_profile, invite_as, invite_expires_in_minutes, streams\n    )\n    return json_success(request, data={\"invite_link\": invite_link})\n"], "fixing_code": ["import re\nfrom datetime import datetime, timedelta\nfrom typing import TYPE_CHECKING, List, Optional, Sequence, Union\nfrom unittest.mock import patch\nfrom urllib.parse import quote, urlencode\n\nimport orjson\nimport time_machine\nfrom django.conf import settings\nfrom django.core import mail\nfrom django.core.mail.message import EmailMultiAlternatives\nfrom django.http import HttpRequest\nfrom django.test import override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom returns.curry import partial\nfrom typing_extensions import override\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyError,\n    create_confirmation_link,\n    get_object_from_key,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.actions.create_realm import do_change_realm_subdomain, do_create_realm\nfrom zerver.actions.create_user import (\n    do_create_user,\n    process_new_human_user,\n    set_up_streams_for_new_human_user,\n)\nfrom zerver.actions.default_streams import do_add_default_stream\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_revoke_multi_use_invite,\n    too_many_recent_realm_invites,\n)\nfrom zerver.actions.realm_settings import (\n    do_change_realm_permission_group_setting,\n    do_change_realm_plan_type,\n    do_set_realm_property,\n)\nfrom zerver.actions.user_settings import do_change_full_name\nfrom zerver.actions.users import change_user_is_active\nfrom zerver.context_processors import common_context\nfrom zerver.lib.create_user import create_user\nfrom zerver.lib.default_streams import get_default_streams_for_realm_as_dicts\nfrom zerver.lib.send_email import FromAddress, deliver_scheduled_emails, send_future_email\nfrom zerver.lib.streams import ensure_stream\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import find_key_by_email\nfrom zerver.models import (\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    ScheduledEmail,\n    Stream,\n    UserGroup,\n    UserMessage,\n    UserProfile,\n)\nfrom zerver.models.groups import SystemGroups\nfrom zerver.models.realms import get_realm\nfrom zerver.models.streams import get_stream\nfrom zerver.models.users import get_user_by_delivery_email\nfrom zerver.views.invite import INVITATION_LINK_VALIDITY_MINUTES, get_invitee_emails_set\nfrom zerver.views.registration import accounts_home\n\nif TYPE_CHECKING:\n    from django.test.client import _MonkeyPatchedWSGIResponse as TestHttpResponse\n\n\nclass StreamSetupTest(ZulipTestCase):\n    def add_messages_to_stream(self, stream_name: str) -> None:\n        # Make sure that add_new_user_history has some messages\n        # to process, so that we get consistent query counts.\n        user = self.example_user(\"hamlet\")\n        self.subscribe(user, stream_name)\n\n        for i in range(5):\n            self.send_stream_message(user, stream_name, f\"test {i}\")\n\n    def create_simple_new_user(self, realm: Realm, email: str) -> UserProfile:\n        # We don't need to get bogged down in all the details of creating\n        # full users to test how to set up streams.\n        return create_user(\n            email=email,\n            password=None,\n            realm=realm,\n            full_name=\"full_name\",\n        )\n\n    def test_query_counts_for_new_user_using_default_streams(self) -> None:\n        DefaultStream.objects.all().delete()\n        realm = get_realm(\"zulip\")\n\n        for i in range(25):\n            stream = ensure_stream(realm, f\"stream{i}\", acting_user=None)\n            do_add_default_stream(stream)\n\n        self.add_messages_to_stream(\"stream5\")\n\n        new_user = self.create_simple_new_user(realm, \"alice@zulip.com\")\n\n        with self.assert_database_query_count(12):\n            set_up_streams_for_new_human_user(\n                user_profile=new_user,\n                prereg_user=None,\n                default_stream_groups=[],\n            )\n\n    def test_query_counts_when_admin_assigns_streams(self) -> None:\n        admin = self.example_user(\"iago\")\n        realm = admin.realm\n\n        streams = [\n            get_stream(\"Denmark\", realm),\n            get_stream(\"Rome\", realm),\n            get_stream(\"Scotland\", realm),\n            get_stream(\"Scotland\", realm),\n            get_stream(\"Verona\", realm),\n            get_stream(\"Venice\", realm),\n        ]\n\n        self.add_messages_to_stream(\"Rome\")\n\n        new_user_email = \"bob@zulip.com\"\n\n        do_invite_users(\n            admin,\n            [new_user_email],\n            streams,\n            invite_expires_in_minutes=1000,\n        )\n\n        prereg_user = PreregistrationUser.objects.get(email=new_user_email)\n\n        new_user = self.create_simple_new_user(realm, new_user_email)\n\n        with self.assert_database_query_count(13):\n            set_up_streams_for_new_human_user(\n                user_profile=new_user,\n                prereg_user=prereg_user,\n                default_stream_groups=[],\n            )\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str], clear: bool = False) -> None:\n        self.assert_length(mail.outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in mail.outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(mail.outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(mail.outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(mail.outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(mail.outbox[0]), rf\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        if clear:\n            mail.outbox = []\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_minutes: Optional[int] = INVITATION_LINK_VALIDITY_MINUTES,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n        realm: Optional[Realm] = None,\n    ) -> \"TestHttpResponse\":\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = [self.get_stream_id(stream_name, realm=realm) for stream_name in stream_names]\n\n        invite_expires_in: Union[str, Optional[int]] = invite_expires_in_minutes\n        if invite_expires_in is None:\n            invite_expires_in = orjson.dumps(None).decode()\n\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_minutes\": invite_expires_in,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n            subdomain=realm.string_id if realm else \"zulip\",\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        self.login_user(user_profile)\n\n        def try_invite(\n            num_invitees: int,\n            *,\n            default_realm_max: int,\n            new_realm_max: int,\n            realm_max: int,\n            open_realm_creation: bool = True,\n            realm: Optional[Realm] = None,\n            stream_name: str = \"Denmark\",\n        ) -> \"TestHttpResponse\":\n            if realm is None:\n                realm = get_realm(\"zulip\")\n            invitees = \",\".join(\n                [f\"{realm.string_id}-{i:02}@zulip.com\" for i in range(num_invitees)]\n            )\n            with self.settings(\n                OPEN_REALM_CREATION=open_realm_creation,\n                INVITES_DEFAULT_REALM_DAILY_MAX=default_realm_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=[(1, new_realm_max)],\n            ):\n                realm.max_invites = realm_max\n                realm.save()\n                return self.invite(invitees, [stream_name], realm=realm)\n\n        # Trip the \"new realm\" limits\n        realm.date_created = timezone_now()\n        realm.save()\n        result = try_invite(30, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # If some other realm consumes some invites, it affects our realm.  Invite 20 users in lear:\n        lear_realm = get_realm(\"lear\")\n        lear_realm.date_created = timezone_now()\n        lear_realm.save()\n        self.login_user(self.lear_user(\"king\"))\n        result = try_invite(\n            20,\n            default_realm_max=50,\n            new_realm_max=20,\n            realm_max=40,\n            realm=lear_realm,\n            stream_name=\"general\",\n        )\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"lear-{i:02}@zulip.com\" for i in range(20)], clear=True)\n\n        # Which prevents inviting 1 in our realm:\n        self.login_user(user_profile)\n        result = try_invite(1, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # If our realm max is over the default realm's, we're exempt from INVITES_NEW_REALM_LIMIT_DAYS\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 10 invites.  Trying to invite 15 people, even if\n        # 10 of them are the same, still trips the limit (10 previous\n        # + 15 in this submission > 20 realm max)\n        result = try_invite(15, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # Inviting 10 more people (to the realm max of 20) works, and\n        # sends emails to the same 10 users again.\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 20 invites.  The 10 we just sent do count against\n        # us if we send to them again, since we did send mail\n        result = try_invite(10, default_realm_max=15, new_realm_max=5, realm_max=20)\n        self.assert_json_error_contains(result, \"reached the limit\")\n        self.check_sent_emails([])\n\n        # We've sent 20 invites.  The realm is exempt from the new realm max\n        # (INVITES_NEW_REALM_LIMIT_DAYS) if it is old enough\n        realm.date_created = timezone_now() - timedelta(days=8)\n        realm.save()\n        result = try_invite(10, default_realm_max=50, new_realm_max=20, realm_max=40)\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 30 invites.  None of the limits matter if open\n        # realm creation is disabled.\n        result = try_invite(\n            10, default_realm_max=30, new_realm_max=20, realm_max=10, open_realm_creation=False\n        )\n        self.assert_json_success(result)\n        self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(10)], clear=True)\n\n        # We've sent 40 invites \"today\".  Fast-forward 48 hours\n        # and ensure that we can invite more people\n        with time_machine.travel(timezone_now() + timedelta(hours=48), tick=False):\n            result = try_invite(5, default_realm_max=30, new_realm_max=20, realm_max=10)\n            self.assert_json_success(result)\n            self.check_sent_emails([f\"zulip-{i:02}@zulip.com\" for i in range(5)], clear=True)\n\n            # We've sent 5 invites.  Ensure we can trip the fresh \"today\" limit for the realm\n            result = try_invite(10, default_realm_max=30, new_realm_max=20, realm_max=10)\n            self.assert_json_error_contains(result, \"reached the limit\")\n            self.check_sent_emails([])\n\n            # We've sent 5 invites.  Reset the realm to be \"recently\"\n            # created, and ensure that we can trip the whole-server\n            # limit\n            realm.date_created = timezone_now() - timedelta(days=3)\n            realm.save()\n            result = try_invite(10, default_realm_max=50, new_realm_max=10, realm_max=40)\n            self.assert_json_error_contains(result, \"reached the limit\")\n            self.check_sent_emails([])\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_limited_plan_heuristics(self) -> None:\n        # There additional limits only apply if OPEN_REALM_CREATION is\n        # True and the plan is \"limited,\" which is primarily only\n        # relevant on Zulip Cloud.\n\n        realm = do_create_realm(\"sdfoijt23489fuskdfjhksdf\", \"Totally Normal\")\n        realm.plan_type = Realm.PLAN_TYPE_LIMITED\n        realm.invite_required = False\n        realm.save()\n\n        # Create a first user\n        admin_user = do_create_user(\n            \"someone@example.com\",\n            \"password\",\n            realm,\n            \"full name\",\n            role=UserProfile.ROLE_REALM_OWNER,\n            realm_creation=True,\n            acting_user=None,\n        )\n\n        # Inviting would work at all\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 1))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 1 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 1.0, 2 allowed\"\n                )\n            ],\n        )\n\n        # This realm is currently very suspicious, so can only invite\n        # 2 users at once (2x current 1 user)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 2))\n            self.assertTrue(too_many_recent_realm_invites(realm, 3))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 2 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 2.0, 2 allowed\"\n                ),\n                (\n                    \"WARNING:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,only-one-user,no-messages-sent) \"\n                    \"inviting 3 more, have 0 recent, but only 1 current users.  \"\n                    \"Ratio 3.0, 2 allowed\"\n                ),\n            ],\n        )\n\n        # Having another user makes it slightly less suspicious, and\n        # also able to invite more in ratio with the current count of\n        # users (3x current 2 users)\n        self.register(\"other@example.com\", \"test\", subdomain=realm.string_id)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 6))\n            self.assertTrue(too_many_recent_realm_invites(realm, 7))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,no-messages-sent) \"\n                    \"inviting 6 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 3.0, 3 allowed\"\n                ),\n                (\n                    \"WARNING:root:sdfoijt23489fuskdfjhksdf \"\n                    \"(!: random-realm-name,no-realm-description,no-realm-icon,realm-created-in-last-hour,no-messages-sent) \"\n                    \"inviting 7 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 3.5, 3 allowed\"\n                ),\n            ],\n        )\n\n        # Remove some more warning flags\n        do_change_realm_subdomain(realm, \"reasonable\", acting_user=None)\n        realm.description = \"A real place\"\n        realm.date_created = timezone_now() - timedelta(hours=2)\n        realm.save()\n\n        # This is now more allowable (5x current 2 users)\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 10))\n            self.assertTrue(too_many_recent_realm_invites(realm, 11))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 10 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.0, 5 allowed\"\n                ),\n                (\n                    \"WARNING:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 11 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.5, 5 allowed\"\n                ),\n            ],\n        )\n\n        # If we have a different max_invites on the realm that kicks in, though\n        realm.max_invites = 8\n        realm.save()\n        self.assertFalse(too_many_recent_realm_invites(realm, 8))\n        self.assertTrue(too_many_recent_realm_invites(realm, 9))\n\n        # And if we have a non-default max invite then that applies\n        # but not the heuristics (which would limit us to 10, here)\n        realm.max_invites = 12\n        realm.save()\n        self.assertFalse(too_many_recent_realm_invites(realm, 12))\n        self.assertTrue(too_many_recent_realm_invites(realm, 13))\n\n        # Not being a limited plan also opens us up from the\n        # heuristics.  First, set us back to the default invite limit\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n        with self.assertLogs(level=\"INFO\") as m:\n            self.assertFalse(too_many_recent_realm_invites(realm, 10))\n            self.assertTrue(too_many_recent_realm_invites(realm, 11))\n        self.assertEqual(\n            m.output,\n            [\n                (\n                    \"INFO:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 10 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.0, 5 allowed\"\n                ),\n                (\n                    \"WARNING:root:reasonable \"\n                    \"(!: no-realm-icon,no-messages-sent) \"\n                    \"inviting 11 more, have 0 recent, but only 2 current users.  \"\n                    \"Ratio 5.5, 5 allowed\"\n                ),\n            ],\n        )\n        # Become a Standard plan\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_STANDARD, acting_user=admin_user)\n        self.assertFalse(too_many_recent_realm_invites(realm, 3000))\n        self.assertTrue(too_many_recent_realm_invites(realm, 3001))\n        do_change_realm_plan_type(realm, Realm.PLAN_TYPE_STANDARD_FREE, acting_user=admin_user)\n        self.assertFalse(too_many_recent_realm_invites(realm, 3000))\n        self.assertTrue(too_many_recent_realm_invites(realm, 3001))\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(\n                self.nonreg_email(\"bob\"),\n                [\"Denmark\"],\n                invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n            )\n        self.assert_json_success(result)\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = f\"{cross_realm_bot_email},{legit_new_email}\"\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            (\n                \"Some of those addresses are already using Zulip, so we didn't send them an\"\n                \" invitation. We did send invitations to everyone else!\"\n            ),\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_invite_from_now_deactivated_user(self) -> None:\n        \"\"\"\n        While accepting an invitation from a user,\n        processing for a new user account will only\n        be completed if the inviter is not deactivated\n        after sending the invite.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n        invitee = self.nonreg_email(\"alice\")\n\n        result = self.invite(invitee, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        change_user_is_active(inviter, False)\n        do_create_user(\n            invitee,\n            \"password\",\n            inviter.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Invalid invite_as\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n        self.check_user_added_in_system_group(invitee_profile)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_successful_invite_users_with_specified_streams(self) -> None:\n        invitee = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        self.login(\"hamlet\")\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, realm) for stream_name in stream_names]\n        self.assert_json_success(self.invite(invitee, stream_names))\n        self.assertTrue(find_key_by_email(invitee))\n        self.submit_reg_form_for_user(invitee, \"password\")\n        self.check_user_subscribed_only_to_streams(\"alice\", streams)\n\n        invitee = self.nonreg_email(\"bob\")\n        self.assert_json_success(self.invite(invitee, []))\n        self.assertTrue(find_key_by_email(invitee))\n\n        default_streams = get_default_streams_for_realm_as_dicts(realm.id)\n        self.assert_length(default_streams, 1)\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        # If no streams are provided, user is not subscribed to\n        # default streams as well.\n        self.check_user_subscribed_only_to_streams(\"bob\", [])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            return user_profile.can_invite_users_by_email()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - timedelta(days=realm.waiting_period_threshold - 1)\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"@_**{invitee_profile.full_name}|{invitee_profile.id}** accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        Names are escaped in the emails which are sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        assert isinstance(mail.outbox[0], EmailMultiAlternatives)\n        assert isinstance(mail.outbox[0].alternatives[0][0], str)\n        body = self.normalize_string(mail.outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color: #5f5ec7;text-decoration: underline;\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                partial(PreregistrationUser.objects.get, email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\n            \"does not allow signups using emails with your email domain\", result\n        )\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"does not allow signups using disposable email addresses.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response('does not allow signups using emails that contain \"+\".', result)\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invite_without_permission_to_subscribe_others(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        invitee = self.nonreg_email(\"alice\")\n\n        self.login(\"hamlet\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_error(\n            result, \"You do not have permission to subscribe other users to streams.\"\n        )\n\n        result = self.invite(invitee, [])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"bob\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"test\")\n        result = self.invite(invitee, [\"Denmark\", \"Scotland\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_invitation_reminder_email(self) -> None:\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_minutes = 2 * 24 * 60\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_minutes=validity_in_minutes\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(mail.outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(mail.outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(mail.outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(mail.outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=4 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address=\"alice@zulip.com\", type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_minutes=3 * 24 * 60)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address=\"bob@zulip.com\", type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            0,\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyError) as cm:\n            get_object_from_key(registration_key, [Confirmation.INVITATION], mark_object_used=True)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyError.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - timedelta(weeks=3)\n        with time_machine.travel(date_sent, tick=False):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_never_expire_confirmation_object(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        activation_url = create_confirmation_link(\n            prereg_user, Confirmation.INVITATION, validity_in_minutes=None\n        )\n        confirmation = Confirmation.objects.last()\n        assert confirmation is not None\n        self.assertEqual(confirmation.expiry_date, None)\n        activation_key = activation_url.split(\"/\")[-1]\n        response = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": activation_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"},\n        )\n        self.assertEqual(response.status_code, 200)\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = [\n            get_stream(stream_name, self.user_profile.realm)\n            for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_minutes=invite_expires_in_minutes\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        created_user = do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_USED\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n        self.assertEqual(accepted_invite[0].created_user, created_user)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n        with self.assertRaises(AssertionError):\n            process_new_human_user(created_user, prereg_user)\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the link_expired page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assert_in_success_response(\n            [\"Enter your account details to complete registration.\"], response\n        )\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        new_prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        new_confirmation_link = create_confirmation_link(\n            new_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        new_registration_key = new_confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": new_registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response[\"Location\"],\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_key_cant_be_reused(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        prereg_user.refresh_from_db()\n        self.assertIsNotNone(prereg_user.created_user)\n\n        # Now attempt to reuse the same key.\n        result = self.client_post(\"/accounts/register/\", {\"key\": registration_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n        # We want to simulate the organization having exactly all their licenses\n        # used, to verify that joining as a regular user is not allowed,\n        # but as a guest still works (guests are free up to a certain number).\n        current_seat_count = get_latest_seat_count(realm)\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            realm, current_seat_count, current_seat_count\n        )\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"Organization cannot accept new members right now\"], response\n        )\n\n        guest_prereg_user = PreregistrationUser.objects.create(\n            email=email,\n            referred_by=inviter,\n            realm=realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"],\n        )\n        confirmation_link = create_confirmation_link(\n            guest_prereg_user, Confirmation.USER_REGISTRATION\n        )\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver/\")\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_invites_controlled_by_user(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            hamlet,\n            [\"TestThree@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            othello,\n            [\"TestFour@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n        self.assert_length(do_get_invites_controlled_by_user(user_profile), 6)\n        self.assert_length(do_get_invites_controlled_by_user(hamlet), 2)\n        self.assert_length(do_get_invites_controlled_by_user(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_USED\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        invite_expires_in_minutes = 2 * 24 * 60\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_minutes=invite_expires_in_minutes,\n        )\n\n        with time_machine.travel((timezone_now() - timedelta(days=3)), tick=False):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=invite_expires_in_minutes,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three,\n            Confirmation.INVITATION,\n            validity_in_minutes=invite_expires_in_minutes,\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_minutes\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_get_never_expiring_invitations(self) -> None:\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n\n        streams = [\n            get_stream(stream_name, user_profile.realm) for stream_name in [\"Denmark\", \"Scotland\"]\n        ]\n\n        with time_machine.travel((timezone_now() - timedelta(days=1000)), tick=False):\n            # Testing the invitation with expiry date set to \"None\" exists\n            # after a large amount of days.\n            do_invite_users(\n                user_profile,\n                [\"TestOne@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=None,\n            )\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_minutes=100 * 24 * 60,\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], None\n            )\n            do_create_multiuse_invite_link(\n                user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], 100\n            )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        # We only get invitations that will never expire because we have mocked time such\n        # that the other invitations are created in the deep past.\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertEqual(invites[0][\"expiry_date\"], None)\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], user_profile.id)\n        self.assertEqual(invites[1][\"expiry_date\"], None)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Invitation has already been revoked\")\n\n        # Test deleting owner multiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_minutes = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test non-admins can only delete invitations created by them.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n        )\n\n        self.login(\"cordelia\")\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n        self.login(\"hamlet\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(\n            MultiuseInvite.objects.get(id=multiuse_invite.id).status,\n            confirmation_settings.STATUS_REVOKED,\n        )\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_minutes = 2 * 24 * 60\n        create_confirmation_link(\n            multiuse_invite_in_mit,\n            Confirmation.MULTIUSE_INVITE,\n            validity_in_minutes=validity_in_minutes,\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        non_existent_id = MultiuseInvite.objects.count() + 9999\n        error_result = self.client_delete(f\"/json/invites/multiuse/{non_existent_id}\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_resend_never_expiring_invitation(self) -> None:\n        self.login(\"iago\")\n        invitee = \"resend@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"], None))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        mail.outbox.pop()\n\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n        self.check_sent_emails([invitee])\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_USED)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    @override\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    @override\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_minutes = 2 * 24 * 60\n        with time_machine.travel(date_sent, tick=False):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_minutes=validity_in_minutes\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].endswith(f\"/accounts/send_confirm/?email={quote(email)}\")\n        )\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"check your email\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        # Verify the PreregistrationUser object was set up as expected.\n        prereg_user = PreregistrationUser.objects.last()\n        multiuse_invite = MultiuseInvite.objects.last()\n\n        assert prereg_user is not None\n        self.assertEqual(prereg_user.email, email)\n        self.assertEqual(prereg_user.multiuse_invite, multiuse_invite)\n\n        mail.outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        date_sent = timezone_now() - timedelta(days=1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - timedelta(days=settings.INVITATION_LINK_VALIDITY_DAYS + 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_revoked_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = self.generate_multiuse_invite_link()\n        multiuse_invite = MultiuseInvite.objects.last()\n        assert multiuse_invite is not None\n        do_revoke_multi_use_invite(multiuse_invite)\n\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link in the system.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        name3 = \"alice\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n        email3 = self.nonreg_email(name3)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n        streams = []\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email3, invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm_as_dicts(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(name3, [])\n\n    def test_multiuse_link_different_realms(self) -> None:\n        \"\"\"\n        Verify that an invitation generated for one realm can't be used\n        to join another.\n        \"\"\"\n        lear_realm = get_realm(\"lear\")\n        self.realm = lear_realm\n        invite_link = self.generate_multiuse_invite_link(streams=[])\n        key = invite_link.split(\"/\")[-2]\n\n        result = self.client_get(f\"/join/{key}/\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n        # Now we want to test the accounts_home function, which can't be used\n        # for the multiuse invite case via an HTTP request, but is still supposed\n        # to do its own verification that the realms match as a hardening measure\n        # against a caller that fails to do that.\n        request = HttpRequest()\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n        multiuse_object = confirmation.content_object\n        with patch(\n            \"zerver.views.registration.get_subdomain\", return_value=\"zulip\"\n        ), self.assertRaises(AssertionError):\n            accounts_home(request, multiuse_object=multiuse_object)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\n            \"/json/invites/multiuse\", {\"invite_expires_in_minutes\": 2 * 24 * 60}\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n        self.login(\"iago\")\n        stream_ids = []\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"alice\"), invite_link)\n        # User is not subscribed to default streams as well.\n        self.assert_length(get_default_streams_for_realm_as_dicts(self.realm.id), 1)\n        self.check_user_subscribed_only_to_streams(\"alice\", [])\n\n    def test_multiuse_invite_without_permission_to_subscribe_others(self) -> None:\n        realm = get_realm(\"zulip\")\n        members_group = UserGroup.objects.get(\n            name=SystemGroups.MEMBERS, realm=realm, is_system_group=True\n        )\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", members_group, acting_user=None\n        )\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(\n            result, \"You do not have permission to subscribe other users to streams.\"\n        )\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps([]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_success(result)\n\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_success(result)\n\n        do_set_realm_property(\n            realm, \"invite_to_stream_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_success(result)\n\n    def test_create_multiuse_invite_group_setting(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n        nobody_system_group = UserGroup.objects.get(\n            name=SystemGroups.NOBODY, realm=realm, is_system_group=True\n        )\n\n        # Default value of create_multiuse_invite_group is administrators\n        self.login(\"shiva\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n        self.login(\"iago\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test1\"), invite_link)\n\n        self.login(\"desdemona\")\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", nobody_system_group, acting_user=None\n        )\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Insufficient permission\")\n\n    def test_only_owner_can_change_create_multiuse_invite_group(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        self.login(\"iago\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"create_multiuse_invite_group\": orjson.dumps(full_members_system_group.id).decode()},\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_patch(\n            \"/json/realm\",\n            {\"create_multiuse_invite_group\": orjson.dumps(full_members_system_group.id).decode()},\n        )\n        self.assert_json_success(result)\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.create_multiuse_invite_group_id, full_members_system_group.id)\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_multiuse_link_for_inviting_as_admin(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_multiuse_link_for_inviting_as_moderator(self) -> None:\n        realm = get_realm(\"zulip\")\n        full_members_system_group = UserGroup.objects.get(\n            name=SystemGroups.FULL_MEMBERS, realm=realm, is_system_group=True\n        )\n\n        do_change_realm_permission_group_setting(\n            realm, \"create_multiuse_invite_group\", full_members_system_group, acting_user=None\n        )\n\n        self.login(\"hamlet\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"MODERATOR\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"shiva\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"MODERATOR\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        invite_link = self.assert_json_success(result)[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"stream_ids\": orjson.dumps([54321]).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid stream ID 54321. No invites were sent.\")\n\n    def test_create_multiuse_link_invalid_invite_as_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"GUEST_USER\"] + 1).decode(),\n                \"invite_expires_in_minutes\": 2 * 24 * 60,\n            },\n        )\n        self.assert_json_error(result, \"Invalid invite_as\")\n", "import re\nfrom typing import List, Optional, Sequence, Set\n\nfrom django.conf import settings\nfrom django.http import HttpRequest, HttpResponse\nfrom django.utils.translation import gettext as _\n\nfrom confirmation import settings as confirmation_settings\nfrom zerver.actions.invites import (\n    do_create_multiuse_invite_link,\n    do_get_invites_controlled_by_user,\n    do_invite_users,\n    do_resend_user_invite_email,\n    do_revoke_multi_use_invite,\n    do_revoke_user_invite,\n)\nfrom zerver.decorator import require_member_or_admin\nfrom zerver.lib.exceptions import JsonableError, OrganizationOwnerRequiredError\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.response import json_success\nfrom zerver.lib.streams import access_stream_by_id\nfrom zerver.lib.validator import check_int, check_int_in, check_list, check_none_or\nfrom zerver.models import MultiuseInvite, PreregistrationUser, Stream, UserProfile\n\n# Convert INVITATION_LINK_VALIDITY_DAYS into minutes.\n# Because mypy fails to correctly infer the type of the validator, we want this constant\n# to be Optional[int] to avoid a mypy error when using it as the default value.\n# https://github.com/python/mypy/issues/13234\nINVITATION_LINK_VALIDITY_MINUTES: Optional[int] = 24 * 60 * settings.INVITATION_LINK_VALIDITY_DAYS\n\n\ndef check_role_based_permissions(\n    invited_as: int, user_profile: UserProfile, *, require_admin: bool\n) -> None:\n    if (\n        invited_as == PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        and not user_profile.is_realm_owner\n    ):\n        raise OrganizationOwnerRequiredError\n\n    if require_admin and not user_profile.is_realm_admin:\n        raise JsonableError(_(\"Must be an organization administrator\"))\n\n\n@require_member_or_admin\n@has_request_variables\ndef invite_users_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    invitee_emails_raw: str = REQ(\"invitee_emails\"),\n    invite_expires_in_minutes: Optional[int] = REQ(\n        json_validator=check_none_or(check_int), default=INVITATION_LINK_VALIDITY_MINUTES\n    ),\n    invite_as: int = REQ(\n        json_validator=check_int_in(\n            list(PreregistrationUser.INVITE_AS.values()),\n        ),\n        default=PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ),\n    stream_ids: List[int] = REQ(json_validator=check_list(check_int)),\n) -> HttpResponse:\n    if not user_profile.can_invite_users_by_email():\n        # Guest users case will not be handled here as it will\n        # be handled by the decorator above.\n        raise JsonableError(_(\"Insufficient permission\"))\n\n    require_admin = invite_as in [\n        # Owners can only be invited by owners, checked by separate\n        # logic in check_role_based_permissions.\n        PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        PreregistrationUser.INVITE_AS[\"MODERATOR\"],\n    ]\n    check_role_based_permissions(invite_as, user_profile, require_admin=require_admin)\n\n    if not invitee_emails_raw:\n        raise JsonableError(_(\"You must specify at least one email address.\"))\n\n    invitee_emails = get_invitee_emails_set(invitee_emails_raw)\n\n    streams: List[Stream] = []\n    for stream_id in stream_ids:\n        try:\n            (stream, sub) = access_stream_by_id(user_profile, stream_id)\n        except JsonableError:\n            raise JsonableError(\n                _(\"Stream does not exist with id: {stream_id}. No invites were sent.\").format(\n                    stream_id=stream_id\n                )\n            )\n        streams.append(stream)\n\n    if len(streams) and not user_profile.can_subscribe_other_users():\n        raise JsonableError(_(\"You do not have permission to subscribe other users to streams.\"))\n\n    do_invite_users(\n        user_profile,\n        invitee_emails,\n        streams,\n        invite_expires_in_minutes=invite_expires_in_minutes,\n        invite_as=invite_as,\n    )\n    return json_success(request)\n\n\ndef get_invitee_emails_set(invitee_emails_raw: str) -> Set[str]:\n    invitee_emails_list = set(re.split(r\"[,\\n]\", invitee_emails_raw))\n    invitee_emails = set()\n    for email in invitee_emails_list:\n        is_email_with_name = re.search(r\"<(?P<email>.*)>\", email)\n        if is_email_with_name:\n            email = is_email_with_name.group(\"email\")\n        invitee_emails.add(email.strip())\n    return invitee_emails\n\n\n@require_member_or_admin\ndef get_user_invites(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    all_users = do_get_invites_controlled_by_user(user_profile)\n    return json_success(request, data={\"invites\": all_users})\n\n\n@require_member_or_admin\n@has_request_variables\ndef revoke_user_invite(\n    request: HttpRequest, user_profile: UserProfile, prereg_id: int\n) -> HttpResponse:\n    try:\n        prereg_user = PreregistrationUser.objects.get(id=prereg_id)\n    except PreregistrationUser.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.referred_by_id != user_profile.id:\n        check_role_based_permissions(prereg_user.invited_as, user_profile, require_admin=True)\n\n    do_revoke_user_invite(prereg_user)\n    return json_success(request)\n\n\n@require_member_or_admin\n@has_request_variables\ndef revoke_multiuse_invite(\n    request: HttpRequest, user_profile: UserProfile, invite_id: int\n) -> HttpResponse:\n    try:\n        invite = MultiuseInvite.objects.get(id=invite_id)\n    except MultiuseInvite.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if invite.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if invite.referred_by_id != user_profile.id:\n        check_role_based_permissions(invite.invited_as, user_profile, require_admin=True)\n\n    if invite.status == confirmation_settings.STATUS_REVOKED:\n        raise JsonableError(_(\"Invitation has already been revoked\"))\n\n    do_revoke_multi_use_invite(invite)\n    return json_success(request)\n\n\n@require_member_or_admin\n@has_request_variables\ndef resend_user_invite_email(\n    request: HttpRequest, user_profile: UserProfile, prereg_id: int\n) -> HttpResponse:\n    try:\n        prereg_user = PreregistrationUser.objects.get(id=prereg_id)\n    except PreregistrationUser.DoesNotExist:\n        raise JsonableError(_(\"No such invitation\"))\n\n    # Structurally, any invitation the user can actually access should\n    # have a referred_by set for the user who created it.\n    if prereg_user.referred_by is None or prereg_user.referred_by.realm != user_profile.realm:\n        raise JsonableError(_(\"No such invitation\"))\n\n    if prereg_user.referred_by_id != user_profile.id:\n        check_role_based_permissions(prereg_user.invited_as, user_profile, require_admin=True)\n\n    timestamp = do_resend_user_invite_email(prereg_user)\n    return json_success(request, data={\"timestamp\": timestamp})\n\n\n@require_member_or_admin\n@has_request_variables\ndef generate_multiuse_invite_backend(\n    request: HttpRequest,\n    user_profile: UserProfile,\n    invite_expires_in_minutes: Optional[int] = REQ(\n        json_validator=check_none_or(check_int), default=INVITATION_LINK_VALIDITY_MINUTES\n    ),\n    invite_as: int = REQ(\n        json_validator=check_int_in(\n            list(PreregistrationUser.INVITE_AS.values()),\n        ),\n        default=PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ),\n    stream_ids: Sequence[int] = REQ(json_validator=check_list(check_int), default=[]),\n) -> HttpResponse:\n    if not user_profile.can_create_multiuse_invite_to_realm():\n        # Guest users case will not be handled here as it will\n        # be handled by the decorator above.\n        raise JsonableError(_(\"Insufficient permission\"))\n\n    require_admin = invite_as in [\n        # Owners can only be invited by owners, checked by separate\n        # logic in check_role_based_permissions.\n        PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"],\n        PreregistrationUser.INVITE_AS[\"MODERATOR\"],\n    ]\n    check_role_based_permissions(invite_as, user_profile, require_admin=require_admin)\n\n    streams = []\n    for stream_id in stream_ids:\n        try:\n            (stream, sub) = access_stream_by_id(user_profile, stream_id)\n        except JsonableError:\n            raise JsonableError(\n                _(\"Invalid stream ID {stream_id}. No invites were sent.\").format(\n                    stream_id=stream_id\n                )\n            )\n        streams.append(stream)\n\n    if len(streams) and not user_profile.can_subscribe_other_users():\n        raise JsonableError(_(\"You do not have permission to subscribe other users to streams.\"))\n\n    invite_link = do_create_multiuse_invite_link(\n        user_profile, invite_as, invite_expires_in_minutes, streams\n    )\n    return json_success(request, data={\"invite_link\": invite_link})\n"], "filenames": ["zerver/tests/test_invite.py", "zerver/views/invite.py"], "buggy_code_start_loc": [2465, 229], "buggy_code_end_loc": [2465, 229], "fixing_code_start_loc": [2466, 230], "fixing_code_end_loc": [2525, 233], "type": "CWE-862", "message": "Zulip is an open-source team collaboration tool. A vulnerability in version 8.0 is similar to CVE-2023-32677, but applies to multi-use invitations, not single-use invitation links as in the prior CVE. Specifically, it applies when the installation has configured non-admins to be able to invite users and create multi-use invitations, and has also configured only admins to be able to invite users to streams. As in CVE-2023-32677, this does not let users invite new users to arbitrary streams, only to streams that the inviter can already see. Version 8.1 fixes this issue. As a workaround, administrators can limit sending of invitations down to users who also have the permission to add users to streams.", "other": {"cve": {"id": "CVE-2024-21630", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-25T20:15:40.423", "lastModified": "2024-01-31T23:45:38.600", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open-source team collaboration tool. A vulnerability in version 8.0 is similar to CVE-2023-32677, but applies to multi-use invitations, not single-use invitation links as in the prior CVE. Specifically, it applies when the installation has configured non-admins to be able to invite users and create multi-use invitations, and has also configured only admins to be able to invite users to streams. As in CVE-2023-32677, this does not let users invite new users to arbitrary streams, only to streams that the inviter can already see. Version 8.1 fixes this issue. As a workaround, administrators can limit sending of invitations down to users who also have the permission to add users to streams."}, {"lang": "es", "value": "Zulip es una herramienta de colaboraci\u00f3n en equipo de c\u00f3digo abierto. Una vulnerabilidad en la versi\u00f3n 8.0 es similar a CVE-2023-32677, pero se aplica a invitaciones de usos m\u00faltiples, no a enlaces de invitaci\u00f3n de un solo uso como en el CVE anterior. Espec\u00edficamente, se aplica cuando la instalaci\u00f3n ha configurado no administradores para poder invitar a usuarios y crear invitaciones de usos m\u00faltiples, y tambi\u00e9n ha configurado solo administradores para poder invitar a usuarios a transmisiones. Al igual que en CVE-2023-32677, esto no permite a los usuarios invitar a nuevos usuarios a transmisiones arbitrarias, solo a transmisiones que quien invita ya puede ver. La versi\u00f3n 8.1 soluciona este problema. Como workaround, los administradores pueden limitar el env\u00edo de invitaciones a los usuarios que tambi\u00e9n tienen permiso para agregar usuarios a las transmisiones."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.9.0", "versionEndExcluding": "6.2", "matchCriteriaId": "5D9282FA-F4D4-4667-ADC6-6A3C7C83BB52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0", "versionEndExcluding": "8.1", "matchCriteriaId": "85FB7719-4DA4-4E4A-B229-6827E35EEF32"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/0df7bd71f32f3b772e2646c6ab0d60c9b610addf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-87p9-wprh-7rm6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-mrvp-96q6-jpvc", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://zulip.com/help/configure-who-can-invite-to-streams", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://zulip.com/help/restrict-account-creation#change-who-can-send-invitations", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/0df7bd71f32f3b772e2646c6ab0d60c9b610addf"}}