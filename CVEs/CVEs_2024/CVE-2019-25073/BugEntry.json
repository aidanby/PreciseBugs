{"buggy_code": ["package goa\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/dimfeld/httptreemux\"\n)\n\ntype (\n\t// Service is the data structure supporting goa services.\n\t// It provides methods for configuring a service and running it.\n\t// At the basic level a service consists of a set of controllers, each implementing a given\n\t// resource actions. goagen generates global functions - one per resource - that make it\n\t// possible to mount the corresponding controller onto a service. A service contains the\n\t// middleware, not found handler, encoders and muxes shared by all its controllers.\n\tService struct {\n\t\t// Name of service used for logging, tracing etc.\n\t\tName string\n\t\t// Mux is the service request mux\n\t\tMux ServeMux\n\t\t// Server is the service HTTP server.\n\t\tServer *http.Server\n\t\t// Context is the root context from which all request contexts are derived.\n\t\t// Set values in the root context prior to starting the server to make these values\n\t\t// available to all request handlers.\n\t\tContext context.Context\n\t\t// Request body decoder\n\t\tDecoder *HTTPDecoder\n\t\t// Response body encoder\n\t\tEncoder *HTTPEncoder\n\n\t\tmiddleware []Middleware       // Middleware chain\n\t\tcancel     context.CancelFunc // Service context cancel signal trigger\n\t}\n\n\t// Controller defines the common fields and behavior of generated controllers.\n\tController struct {\n\t\t// Controller resource name\n\t\tName string\n\t\t// Service that exposes the controller\n\t\tService *Service\n\t\t// Controller root context\n\t\tContext context.Context\n\t\t// MaxRequestBodyLength is the maximum length read from request bodies.\n\t\t// Set to 0 to remove the limit altogether. Defaults to 1GB.\n\t\tMaxRequestBodyLength int64\n\t\t// FileSystem is used in FileHandler to open files. By default it returns\n\t\t// http.Dir but you can override it with another one that implements http.FileSystem.\n\t\t// For example using github.com/elazarl/go-bindata-assetfs is like below.\n\t\t//\n\t\t//\tctrl.FileSystem = func(dir string) http.FileSystem {\n\t\t//\t\treturn &assetfs.AssetFS{\n\t\t//\t\t\tAsset: Asset,\n\t\t//\t\t\tAssetDir: AssetDir,\n\t\t//\t\t\tAssetInfo: AssetInfo,\n\t\t//\t\t\tPrefix: dir,\n\t\t//\t\t}\n\t\t//\t}\n\t\tFileSystem func(string) http.FileSystem\n\n\t\tmiddleware []Middleware // Controller specific middleware if any\n\t}\n\n\t// FileServer is the interface implemented by controllers that can serve static files.\n\tFileServer interface {\n\t\t// FileHandler returns a handler that serves files under the given request path.\n\t\tFileHandler(path, filename string) Handler\n\t}\n\n\t// Handler defines the request handler signatures.\n\tHandler func(context.Context, http.ResponseWriter, *http.Request) error\n\n\t// Unmarshaler defines the request payload unmarshaler signatures.\n\tUnmarshaler func(context.Context, *Service, *http.Request) error\n\n\t// DecodeFunc is the function that initialize the unmarshaled payload from the request body.\n\tDecodeFunc func(context.Context, io.ReadCloser, interface{}) error\n)\n\n// New instantiates a service with the given name.\nfunc New(name string) *Service {\n\tvar (\n\t\tstdlog       = log.New(os.Stderr, \"\", log.LstdFlags)\n\t\tctx          = WithLogger(context.Background(), NewLogger(stdlog))\n\t\tcctx, cancel = context.WithCancel(ctx)\n\t\tmux          = NewMux()\n\t\tservice      = &Service{\n\t\t\tName:    name,\n\t\t\tContext: cctx,\n\t\t\tMux:     mux,\n\t\t\tServer: &http.Server{\n\t\t\t\tHandler: mux,\n\t\t\t},\n\t\t\tDecoder: NewHTTPDecoder(),\n\t\t\tEncoder: NewHTTPEncoder(),\n\n\t\t\tcancel: cancel,\n\t\t}\n\t\tnotFoundHandler         Handler\n\t\tmethodNotAllowedHandler Handler\n\t)\n\n\t// Setup default NotFound handler\n\tmux.HandleNotFound(func(rw http.ResponseWriter, req *http.Request, params url.Values) {\n\t\tif resp := ContextResponse(ctx); resp != nil && resp.Written() {\n\t\t\treturn\n\t\t}\n\t\t// Use closure to do lazy computation of middleware chain so all middlewares are\n\t\t// registered.\n\t\tif notFoundHandler == nil {\n\t\t\tnotFoundHandler = func(_ context.Context, _ http.ResponseWriter, req *http.Request) error {\n\t\t\t\treturn ErrNotFound(req.URL.Path)\n\t\t\t}\n\t\t\tchain := service.middleware\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\tnotFoundHandler = chain[ml-i-1](notFoundHandler)\n\t\t\t}\n\t\t}\n\t\tctx := NewContext(service.Context, rw, req, params)\n\t\terr := notFoundHandler(ctx, ContextResponse(ctx), req)\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\tservice.Send(ctx, 404, err)\n\t\t}\n\t})\n\n\t// Setup default MethodNotAllowed handler\n\tmux.HandleMethodNotAllowed(func(rw http.ResponseWriter, req *http.Request, params url.Values, methods map[string]httptreemux.HandlerFunc) {\n\t\tif resp := ContextResponse(ctx); resp != nil && resp.Written() {\n\t\t\treturn\n\t\t}\n\t\t// Use closure to do lazy computation of middleware chain so all middlewares are\n\t\t// registered.\n\t\tif methodNotAllowedHandler == nil {\n\t\t\tmethodNotAllowedHandler = func(_ context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t\t\tallowedMethods := make([]string, len(methods))\n\t\t\t\ti := 0\n\t\t\t\tfor k := range methods {\n\t\t\t\t\tallowedMethods[i] = k\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\trw.Header().Set(\"Allow\", strings.Join(allowedMethods, \", \"))\n\t\t\t\treturn MethodNotAllowedError(req.Method, allowedMethods)\n\t\t\t}\n\t\t\tchain := service.middleware\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\tmethodNotAllowedHandler = chain[ml-i-1](methodNotAllowedHandler)\n\t\t\t}\n\t\t}\n\t\tctx := NewContext(service.Context, rw, req, params)\n\t\terr := methodNotAllowedHandler(ctx, ContextResponse(ctx), req)\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\tservice.Send(ctx, 405, err)\n\t\t}\n\t})\n\n\treturn service\n}\n\n// CancelAll sends a cancel signals to all request handlers via the context.\n// See https://golang.org/pkg/context/ for details on how to handle the signal.\nfunc (service *Service) CancelAll() {\n\tservice.cancel()\n}\n\n// Use adds a middleware to the service wide middleware chain.\n// goa comes with a set of commonly used middleware, see the middleware package.\n// Controller specific middleware should be mounted using the Controller struct Use method instead.\nfunc (service *Service) Use(m Middleware) {\n\tservice.middleware = append(service.middleware, m)\n}\n\n// WithLogger sets the logger used internally by the service and by Log.\nfunc (service *Service) WithLogger(logger LogAdapter) {\n\tservice.Context = WithLogger(service.Context, logger)\n}\n\n// LogInfo logs the message and values at odd indeces using the keys at even indeces of the keyvals slice.\nfunc (service *Service) LogInfo(msg string, keyvals ...interface{}) {\n\tLogInfo(service.Context, msg, keyvals...)\n}\n\n// LogError logs the error and values at odd indeces using the keys at even indeces of the keyvals slice.\nfunc (service *Service) LogError(msg string, keyvals ...interface{}) {\n\tLogError(service.Context, msg, keyvals...)\n}\n\n// ListenAndServe starts a HTTP server and sets up a listener on the given host/port.\nfunc (service *Service) ListenAndServe(addr string) error {\n\tservice.LogInfo(\"listen\", \"transport\", \"http\", \"addr\", addr)\n\tservice.Server.Addr = addr\n\treturn service.Server.ListenAndServe()\n}\n\n// ListenAndServeTLS starts a HTTPS server and sets up a listener on the given host/port.\nfunc (service *Service) ListenAndServeTLS(addr, certFile, keyFile string) error {\n\tservice.LogInfo(\"listen\", \"transport\", \"https\", \"addr\", addr)\n\tservice.Server.Addr = addr\n\treturn service.Server.ListenAndServeTLS(certFile, keyFile)\n}\n\n// Serve accepts incoming HTTP connections on the listener l, invoking the service mux handler for each.\nfunc (service *Service) Serve(l net.Listener) error {\n\treturn service.Server.Serve(l)\n}\n\n// NewController returns a controller for the given resource. This method is mainly intended for\n// use by the generated code. User code shouldn't have to call it directly.\nfunc (service *Service) NewController(name string) *Controller {\n\treturn &Controller{\n\t\tName:                 name,\n\t\tService:              service,\n\t\tContext:              context.WithValue(service.Context, ctrlKey, name),\n\t\tMaxRequestBodyLength: 1073741824, // 1 GB\n\t\tFileSystem: func(dir string) http.FileSystem {\n\t\t\treturn http.Dir(dir)\n\t\t},\n\t}\n}\n\n// Send serializes the given body matching the request Accept header against the service\n// encoders. It uses the default service encoder if no match is found.\nfunc (service *Service) Send(ctx context.Context, code int, body interface{}) error {\n\tr := ContextResponse(ctx)\n\tif r == nil {\n\t\treturn fmt.Errorf(\"no response data in context\")\n\t}\n\tr.WriteHeader(code)\n\treturn service.EncodeResponse(ctx, body)\n}\n\n// ServeFiles create a \"FileServer\" controller and calls ServerFiles on it.\nfunc (service *Service) ServeFiles(path, filename string) error {\n\tctrl := service.NewController(\"FileServer\")\n\treturn ctrl.ServeFiles(path, filename)\n}\n\n// DecodeRequest uses the HTTP decoder to unmarshal the request body into the provided value based\n// on the request Content-Type header.\nfunc (service *Service) DecodeRequest(req *http.Request, v interface{}) error {\n\tbody, contentType := req.Body, req.Header.Get(\"Content-Type\")\n\tdefer body.Close()\n\n\tif err := service.Decoder.Decode(v, body, contentType); err != nil {\n\t\treturn fmt.Errorf(\"failed to decode request body with content type %#v: %s\", contentType, err)\n\t}\n\n\treturn nil\n}\n\n// EncodeResponse uses the HTTP encoder to marshal and write the response body based on the request\n// Accept header.\nfunc (service *Service) EncodeResponse(ctx context.Context, v interface{}) error {\n\taccept := ContextRequest(ctx).Header.Get(\"Accept\")\n\treturn service.Encoder.Encode(v, ContextResponse(ctx), accept)\n}\n\n// ServeFiles replies to the request with the contents of the named file or directory. See\n// FileHandler for details.\nfunc (ctrl *Controller) ServeFiles(path, filename string) error {\n\tif strings.Contains(path, \":\") {\n\t\treturn fmt.Errorf(\"path may only include wildcards that match the entire end of the URL (e.g. *filepath)\")\n\t}\n\tLogInfo(ctrl.Context, \"mount file\", \"name\", filename, \"route\", fmt.Sprintf(\"GET %s\", path))\n\thandler := func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\treturn ctrl.FileHandler(path, filename)(ctx, rw, req)\n\t\t}\n\t\treturn nil\n\t}\n\tctrl.Service.Mux.Handle(\"GET\", path, ctrl.MuxHandler(\"serve\", handler, nil))\n\treturn nil\n}\n\n// Use adds a middleware to the controller.\n// Service-wide middleware should be added via the Service Use method instead.\nfunc (ctrl *Controller) Use(m Middleware) {\n\tctrl.middleware = append(ctrl.middleware, m)\n}\n\n// MuxHandler wraps a request handler into a MuxHandler. The MuxHandler initializes the request\n// context by loading the request state, invokes the handler and in case of error invokes the\n// controller (if there is one) or Service error handler.\n// This function is intended for the controller generated code. User code should not need to call\n// it directly.\nfunc (ctrl *Controller) MuxHandler(name string, hdlr Handler, unm Unmarshaler) MuxHandler {\n\t// Use closure to enable late computation of handlers to ensure all middleware has been\n\t// registered.\n\tvar handler Handler\n\tvar initHandler sync.Once\n\n\treturn func(rw http.ResponseWriter, req *http.Request, params url.Values) {\n\t\t// Build handler middleware chains on first invocation\n\t\tinitHandler.Do(func() {\n\t\t\thandler = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t\t\tif !ContextResponse(ctx).Written() {\n\t\t\t\t\treturn hdlr(ctx, rw, req)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tmwLen := len(ctrl.Service.middleware)\n\t\t\tchain := append(ctrl.Service.middleware[:mwLen:mwLen], ctrl.middleware...)\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\thandler = chain[ml-i-1](handler)\n\t\t\t}\n\t\t})\n\n\t\t// Build context\n\t\tctx := NewContext(WithAction(ctrl.Context, name), rw, req, params)\n\n\t\t// Protect against request bodies with unreasonable length\n\t\tif ctrl.MaxRequestBodyLength > 0 {\n\t\t\treq.Body = http.MaxBytesReader(rw, req.Body, ctrl.MaxRequestBodyLength)\n\t\t}\n\n\t\t// Load body if any\n\t\tif req.ContentLength > 0 && unm != nil {\n\t\t\tif err := unm(ctx, ctrl.Service, req); err != nil {\n\t\t\t\tif err.Error() == \"http: request body too large\" {\n\t\t\t\t\tmsg := fmt.Sprintf(\"request body length exceeds %d bytes\", ctrl.MaxRequestBodyLength)\n\t\t\t\t\terr = ErrRequestBodyTooLarge(msg)\n\t\t\t\t} else {\n\t\t\t\t\terr = ErrBadRequest(err)\n\t\t\t\t}\n\t\t\t\tctx = WithError(ctx, err)\n\t\t\t}\n\t\t}\n\n\t\t// Invoke handler\n\t\tif err := handler(ctx, ContextResponse(ctx), req); err != nil {\n\t\t\tLogError(ctx, \"uncaught error\", \"err\", err)\n\t\t\trespBody := fmt.Sprintf(\"Internal error: %s\", err) // Sprintf catches panics\n\t\t\tctrl.Service.Send(ctx, 500, respBody)\n\t\t}\n\t}\n}\n\n// FileHandler returns a handler that serves files under the given filename for the given route path.\n// The logic for what to do when the filename points to a file vs. a directory is the same as the\n// standard http package ServeFile function. The path may end with a wildcard that matches the rest\n// of the URL (e.g. *filepath). If it does the matching path is appended to filename to form the\n// full file path, so:\n//\n// \tc.FileHandler(\"/index.html\", \"/www/data/index.html\")\n//\n// Returns the content of the file \"/www/data/index.html\" when requests are sent to \"/index.html\"\n// and:\n//\n//\tc.FileHandler(\"/assets/*filepath\", \"/www/data/assets\")\n//\n// returns the content of the file \"/www/data/assets/x/y/z\" when requests are sent to\n// \"/assets/x/y/z\".\nfunc (ctrl *Controller) FileHandler(path, filename string) Handler {\n\tvar wc string\n\tif idx := strings.LastIndex(path, \"/*\"); idx > -1 && idx < len(path)-1 {\n\t\twc = path[idx+2:]\n\t\tif strings.Contains(wc, \"/\") {\n\t\t\twc = \"\"\n\t\t}\n\t}\n\treturn func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\tfname := filename\n\t\tif len(wc) > 0 {\n\t\t\tif m, ok := ContextRequest(ctx).Params[wc]; ok {\n\t\t\t\tfname = filepath.Join(filename, m[0])\n\t\t\t}\n\t\t}\n\t\tLogInfo(ctx, \"serve file\", \"name\", fname, \"route\", req.URL.Path)\n\t\tdir, name := filepath.Split(fname)\n\t\tfs := ctrl.FileSystem(dir)\n\t\tf, err := fs.Open(name)\n\t\tif err != nil {\n\t\t\treturn ErrInvalidFile(err)\n\t\t}\n\t\tdefer f.Close()\n\t\td, err := f.Stat()\n\t\tif err != nil {\n\t\t\treturn ErrInvalidFile(err)\n\t\t}\n\t\t// use contents of index.html for directory, if present\n\t\tif d.IsDir() {\n\t\t\tindex := strings.TrimSuffix(name, \"/\") + \"/index.html\"\n\t\t\tff, err := fs.Open(index)\n\t\t\tif err == nil {\n\t\t\t\tdefer ff.Close()\n\t\t\t\tdd, err := ff.Stat()\n\t\t\t\tif err == nil {\n\t\t\t\t\tname = index\n\t\t\t\t\td = dd\n\t\t\t\t\tf = ff\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// serveContent will check modification time\n\t\t// Still a directory? (we didn't find an index.html file)\n\t\tif d.IsDir() {\n\t\t\treturn dirList(rw, f)\n\t\t}\n\t\thttp.ServeContent(rw, req, d.Name(), d.ModTime(), f)\n\t\treturn nil\n\t}\n}\n\nvar replacer = strings.NewReplacer(\n\t\"&\", \"&amp;\",\n\t\"<\", \"&lt;\",\n\t\">\", \"&gt;\",\n\t// \"&#34;\" is shorter than \"&quot;\".\n\t`\"`, \"&#34;\",\n\t// \"&#39;\" is shorter than \"&apos;\" and apos was not in HTML until HTML5.\n\t\"'\", \"&#39;\",\n)\n\nfunc dirList(w http.ResponseWriter, f http.File) error {\n\tdirs, err := f.Readdir(-1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsort.Sort(byName(dirs))\n\n\tw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\tfmt.Fprintf(w, \"<pre>\\n\")\n\tfor _, d := range dirs {\n\t\tname := d.Name()\n\t\tif d.IsDir() {\n\t\t\tname += \"/\"\n\t\t}\n\t\t// name may contain '?' or '#', which must be escaped to remain\n\t\t// part of the URL path, and not indicate the start of a query\n\t\t// string or fragment.\n\t\turl := url.URL{Path: name}\n\t\tfmt.Fprintf(w, \"<a href=\\\"%s\\\">%s</a>\\n\", url.String(), replacer.Replace(name))\n\t}\n\tfmt.Fprintf(w, \"</pre>\\n\")\n\treturn nil\n}\n\ntype byName []os.FileInfo\n\nfunc (s byName) Len() int           { return len(s) }\nfunc (s byName) Less(i, j int) bool { return s[i].Name() < s[j].Name() }\nfunc (s byName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n"], "fixing_code": ["package goa\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/dimfeld/httptreemux\"\n)\n\ntype (\n\t// Service is the data structure supporting goa services.\n\t// It provides methods for configuring a service and running it.\n\t// At the basic level a service consists of a set of controllers, each implementing a given\n\t// resource actions. goagen generates global functions - one per resource - that make it\n\t// possible to mount the corresponding controller onto a service. A service contains the\n\t// middleware, not found handler, encoders and muxes shared by all its controllers.\n\tService struct {\n\t\t// Name of service used for logging, tracing etc.\n\t\tName string\n\t\t// Mux is the service request mux\n\t\tMux ServeMux\n\t\t// Server is the service HTTP server.\n\t\tServer *http.Server\n\t\t// Context is the root context from which all request contexts are derived.\n\t\t// Set values in the root context prior to starting the server to make these values\n\t\t// available to all request handlers.\n\t\tContext context.Context\n\t\t// Request body decoder\n\t\tDecoder *HTTPDecoder\n\t\t// Response body encoder\n\t\tEncoder *HTTPEncoder\n\n\t\tmiddleware []Middleware       // Middleware chain\n\t\tcancel     context.CancelFunc // Service context cancel signal trigger\n\t}\n\n\t// Controller defines the common fields and behavior of generated controllers.\n\tController struct {\n\t\t// Controller resource name\n\t\tName string\n\t\t// Service that exposes the controller\n\t\tService *Service\n\t\t// Controller root context\n\t\tContext context.Context\n\t\t// MaxRequestBodyLength is the maximum length read from request bodies.\n\t\t// Set to 0 to remove the limit altogether. Defaults to 1GB.\n\t\tMaxRequestBodyLength int64\n\t\t// FileSystem is used in FileHandler to open files. By default it returns\n\t\t// http.Dir but you can override it with another one that implements http.FileSystem.\n\t\t// For example using github.com/elazarl/go-bindata-assetfs is like below.\n\t\t//\n\t\t//\tctrl.FileSystem = func(dir string) http.FileSystem {\n\t\t//\t\treturn &assetfs.AssetFS{\n\t\t//\t\t\tAsset: Asset,\n\t\t//\t\t\tAssetDir: AssetDir,\n\t\t//\t\t\tAssetInfo: AssetInfo,\n\t\t//\t\t\tPrefix: dir,\n\t\t//\t\t}\n\t\t//\t}\n\t\tFileSystem func(string) http.FileSystem\n\n\t\tmiddleware []Middleware // Controller specific middleware if any\n\t}\n\n\t// FileServer is the interface implemented by controllers that can serve static files.\n\tFileServer interface {\n\t\t// FileHandler returns a handler that serves files under the given request path.\n\t\tFileHandler(path, filename string) Handler\n\t}\n\n\t// Handler defines the request handler signatures.\n\tHandler func(context.Context, http.ResponseWriter, *http.Request) error\n\n\t// Unmarshaler defines the request payload unmarshaler signatures.\n\tUnmarshaler func(context.Context, *Service, *http.Request) error\n\n\t// DecodeFunc is the function that initialize the unmarshaled payload from the request body.\n\tDecodeFunc func(context.Context, io.ReadCloser, interface{}) error\n)\n\n// New instantiates a service with the given name.\nfunc New(name string) *Service {\n\tvar (\n\t\tstdlog       = log.New(os.Stderr, \"\", log.LstdFlags)\n\t\tctx          = WithLogger(context.Background(), NewLogger(stdlog))\n\t\tcctx, cancel = context.WithCancel(ctx)\n\t\tmux          = NewMux()\n\t\tservice      = &Service{\n\t\t\tName:    name,\n\t\t\tContext: cctx,\n\t\t\tMux:     mux,\n\t\t\tServer: &http.Server{\n\t\t\t\tHandler: mux,\n\t\t\t},\n\t\t\tDecoder: NewHTTPDecoder(),\n\t\t\tEncoder: NewHTTPEncoder(),\n\n\t\t\tcancel: cancel,\n\t\t}\n\t\tnotFoundHandler         Handler\n\t\tmethodNotAllowedHandler Handler\n\t)\n\n\t// Setup default NotFound handler\n\tmux.HandleNotFound(func(rw http.ResponseWriter, req *http.Request, params url.Values) {\n\t\tif resp := ContextResponse(ctx); resp != nil && resp.Written() {\n\t\t\treturn\n\t\t}\n\t\t// Use closure to do lazy computation of middleware chain so all middlewares are\n\t\t// registered.\n\t\tif notFoundHandler == nil {\n\t\t\tnotFoundHandler = func(_ context.Context, _ http.ResponseWriter, req *http.Request) error {\n\t\t\t\treturn ErrNotFound(req.URL.Path)\n\t\t\t}\n\t\t\tchain := service.middleware\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\tnotFoundHandler = chain[ml-i-1](notFoundHandler)\n\t\t\t}\n\t\t}\n\t\tctx := NewContext(service.Context, rw, req, params)\n\t\terr := notFoundHandler(ctx, ContextResponse(ctx), req)\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\tservice.Send(ctx, 404, err)\n\t\t}\n\t})\n\n\t// Setup default MethodNotAllowed handler\n\tmux.HandleMethodNotAllowed(func(rw http.ResponseWriter, req *http.Request, params url.Values, methods map[string]httptreemux.HandlerFunc) {\n\t\tif resp := ContextResponse(ctx); resp != nil && resp.Written() {\n\t\t\treturn\n\t\t}\n\t\t// Use closure to do lazy computation of middleware chain so all middlewares are\n\t\t// registered.\n\t\tif methodNotAllowedHandler == nil {\n\t\t\tmethodNotAllowedHandler = func(_ context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t\t\tallowedMethods := make([]string, len(methods))\n\t\t\t\ti := 0\n\t\t\t\tfor k := range methods {\n\t\t\t\t\tallowedMethods[i] = k\n\t\t\t\t\ti++\n\t\t\t\t}\n\t\t\t\trw.Header().Set(\"Allow\", strings.Join(allowedMethods, \", \"))\n\t\t\t\treturn MethodNotAllowedError(req.Method, allowedMethods)\n\t\t\t}\n\t\t\tchain := service.middleware\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\tmethodNotAllowedHandler = chain[ml-i-1](methodNotAllowedHandler)\n\t\t\t}\n\t\t}\n\t\tctx := NewContext(service.Context, rw, req, params)\n\t\terr := methodNotAllowedHandler(ctx, ContextResponse(ctx), req)\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\tservice.Send(ctx, 405, err)\n\t\t}\n\t})\n\n\treturn service\n}\n\n// CancelAll sends a cancel signals to all request handlers via the context.\n// See https://golang.org/pkg/context/ for details on how to handle the signal.\nfunc (service *Service) CancelAll() {\n\tservice.cancel()\n}\n\n// Use adds a middleware to the service wide middleware chain.\n// goa comes with a set of commonly used middleware, see the middleware package.\n// Controller specific middleware should be mounted using the Controller struct Use method instead.\nfunc (service *Service) Use(m Middleware) {\n\tservice.middleware = append(service.middleware, m)\n}\n\n// WithLogger sets the logger used internally by the service and by Log.\nfunc (service *Service) WithLogger(logger LogAdapter) {\n\tservice.Context = WithLogger(service.Context, logger)\n}\n\n// LogInfo logs the message and values at odd indeces using the keys at even indeces of the keyvals slice.\nfunc (service *Service) LogInfo(msg string, keyvals ...interface{}) {\n\tLogInfo(service.Context, msg, keyvals...)\n}\n\n// LogError logs the error and values at odd indeces using the keys at even indeces of the keyvals slice.\nfunc (service *Service) LogError(msg string, keyvals ...interface{}) {\n\tLogError(service.Context, msg, keyvals...)\n}\n\n// ListenAndServe starts a HTTP server and sets up a listener on the given host/port.\nfunc (service *Service) ListenAndServe(addr string) error {\n\tservice.LogInfo(\"listen\", \"transport\", \"http\", \"addr\", addr)\n\tservice.Server.Addr = addr\n\treturn service.Server.ListenAndServe()\n}\n\n// ListenAndServeTLS starts a HTTPS server and sets up a listener on the given host/port.\nfunc (service *Service) ListenAndServeTLS(addr, certFile, keyFile string) error {\n\tservice.LogInfo(\"listen\", \"transport\", \"https\", \"addr\", addr)\n\tservice.Server.Addr = addr\n\treturn service.Server.ListenAndServeTLS(certFile, keyFile)\n}\n\n// Serve accepts incoming HTTP connections on the listener l, invoking the service mux handler for each.\nfunc (service *Service) Serve(l net.Listener) error {\n\treturn service.Server.Serve(l)\n}\n\n// NewController returns a controller for the given resource. This method is mainly intended for\n// use by the generated code. User code shouldn't have to call it directly.\nfunc (service *Service) NewController(name string) *Controller {\n\treturn &Controller{\n\t\tName:                 name,\n\t\tService:              service,\n\t\tContext:              context.WithValue(service.Context, ctrlKey, name),\n\t\tMaxRequestBodyLength: 1073741824, // 1 GB\n\t\tFileSystem: func(dir string) http.FileSystem {\n\t\t\treturn http.Dir(dir)\n\t\t},\n\t}\n}\n\n// Send serializes the given body matching the request Accept header against the service\n// encoders. It uses the default service encoder if no match is found.\nfunc (service *Service) Send(ctx context.Context, code int, body interface{}) error {\n\tr := ContextResponse(ctx)\n\tif r == nil {\n\t\treturn fmt.Errorf(\"no response data in context\")\n\t}\n\tr.WriteHeader(code)\n\treturn service.EncodeResponse(ctx, body)\n}\n\n// ServeFiles create a \"FileServer\" controller and calls ServerFiles on it.\nfunc (service *Service) ServeFiles(path, filename string) error {\n\tctrl := service.NewController(\"FileServer\")\n\treturn ctrl.ServeFiles(path, filename)\n}\n\n// DecodeRequest uses the HTTP decoder to unmarshal the request body into the provided value based\n// on the request Content-Type header.\nfunc (service *Service) DecodeRequest(req *http.Request, v interface{}) error {\n\tbody, contentType := req.Body, req.Header.Get(\"Content-Type\")\n\tdefer body.Close()\n\n\tif err := service.Decoder.Decode(v, body, contentType); err != nil {\n\t\treturn fmt.Errorf(\"failed to decode request body with content type %#v: %s\", contentType, err)\n\t}\n\n\treturn nil\n}\n\n// EncodeResponse uses the HTTP encoder to marshal and write the response body based on the request\n// Accept header.\nfunc (service *Service) EncodeResponse(ctx context.Context, v interface{}) error {\n\taccept := ContextRequest(ctx).Header.Get(\"Accept\")\n\treturn service.Encoder.Encode(v, ContextResponse(ctx), accept)\n}\n\n// ServeFiles replies to the request with the contents of the named file or directory. See\n// FileHandler for details.\nfunc (ctrl *Controller) ServeFiles(path, filename string) error {\n\tif strings.Contains(path, \":\") {\n\t\treturn fmt.Errorf(\"path may only include wildcards that match the entire end of the URL (e.g. *filepath)\")\n\t}\n\tLogInfo(ctrl.Context, \"mount file\", \"name\", filename, \"route\", fmt.Sprintf(\"GET %s\", path))\n\thandler := func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\tif !ContextResponse(ctx).Written() {\n\t\t\treturn ctrl.FileHandler(path, filename)(ctx, rw, req)\n\t\t}\n\t\treturn nil\n\t}\n\tctrl.Service.Mux.Handle(\"GET\", path, ctrl.MuxHandler(\"serve\", handler, nil))\n\treturn nil\n}\n\n// Use adds a middleware to the controller.\n// Service-wide middleware should be added via the Service Use method instead.\nfunc (ctrl *Controller) Use(m Middleware) {\n\tctrl.middleware = append(ctrl.middleware, m)\n}\n\n// MuxHandler wraps a request handler into a MuxHandler. The MuxHandler initializes the request\n// context by loading the request state, invokes the handler and in case of error invokes the\n// controller (if there is one) or Service error handler.\n// This function is intended for the controller generated code. User code should not need to call\n// it directly.\nfunc (ctrl *Controller) MuxHandler(name string, hdlr Handler, unm Unmarshaler) MuxHandler {\n\t// Use closure to enable late computation of handlers to ensure all middleware has been\n\t// registered.\n\tvar handler Handler\n\tvar initHandler sync.Once\n\n\treturn func(rw http.ResponseWriter, req *http.Request, params url.Values) {\n\t\t// Build handler middleware chains on first invocation\n\t\tinitHandler.Do(func() {\n\t\t\thandler = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t\t\tif !ContextResponse(ctx).Written() {\n\t\t\t\t\treturn hdlr(ctx, rw, req)\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tmwLen := len(ctrl.Service.middleware)\n\t\t\tchain := append(ctrl.Service.middleware[:mwLen:mwLen], ctrl.middleware...)\n\t\t\tml := len(chain)\n\t\t\tfor i := range chain {\n\t\t\t\thandler = chain[ml-i-1](handler)\n\t\t\t}\n\t\t})\n\n\t\t// Build context\n\t\tctx := NewContext(WithAction(ctrl.Context, name), rw, req, params)\n\n\t\t// Protect against request bodies with unreasonable length\n\t\tif ctrl.MaxRequestBodyLength > 0 {\n\t\t\treq.Body = http.MaxBytesReader(rw, req.Body, ctrl.MaxRequestBodyLength)\n\t\t}\n\n\t\t// Load body if any\n\t\tif req.ContentLength > 0 && unm != nil {\n\t\t\tif err := unm(ctx, ctrl.Service, req); err != nil {\n\t\t\t\tif err.Error() == \"http: request body too large\" {\n\t\t\t\t\tmsg := fmt.Sprintf(\"request body length exceeds %d bytes\", ctrl.MaxRequestBodyLength)\n\t\t\t\t\terr = ErrRequestBodyTooLarge(msg)\n\t\t\t\t} else {\n\t\t\t\t\terr = ErrBadRequest(err)\n\t\t\t\t}\n\t\t\t\tctx = WithError(ctx, err)\n\t\t\t}\n\t\t}\n\n\t\t// Invoke handler\n\t\tif err := handler(ctx, ContextResponse(ctx), req); err != nil {\n\t\t\tLogError(ctx, \"uncaught error\", \"err\", err)\n\t\t\trespBody := fmt.Sprintf(\"Internal error: %s\", err) // Sprintf catches panics\n\t\t\tctrl.Service.Send(ctx, 500, respBody)\n\t\t}\n\t}\n}\n\n// FileHandler returns a handler that serves files under the given filename for the given route path.\n// The logic for what to do when the filename points to a file vs. a directory is the same as the\n// standard http package ServeFile function. The path may end with a wildcard that matches the rest\n// of the URL (e.g. *filepath). If it does the matching path is appended to filename to form the\n// full file path, so:\n//\n// \tc.FileHandler(\"/index.html\", \"/www/data/index.html\")\n//\n// Returns the content of the file \"/www/data/index.html\" when requests are sent to \"/index.html\"\n// and:\n//\n//\tc.FileHandler(\"/assets/*filepath\", \"/www/data/assets\")\n//\n// returns the content of the file \"/www/data/assets/x/y/z\" when requests are sent to\n// \"/assets/x/y/z\".\nfunc (ctrl *Controller) FileHandler(path, filename string) Handler {\n\tvar wc string\n\tif idx := strings.LastIndex(path, \"/*\"); idx > -1 && idx < len(path)-1 {\n\t\twc = path[idx+2:]\n\t\tif strings.Contains(wc, \"/\") {\n\t\t\twc = \"\"\n\t\t}\n\t}\n\treturn func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t// prevent path traversal\n\t\tif attemptsPathTraversal(req.URL.Path, path) {\n\t\t\treturn ErrNotFound(req.URL.Path)\n\t\t}\n\t\tfname := filename\n\t\tif len(wc) > 0 {\n\t\t\tif m, ok := ContextRequest(ctx).Params[wc]; ok {\n\t\t\t\tfname = filepath.Join(filename, m[0])\n\t\t\t}\n\t\t}\n\t\tLogInfo(ctx, \"serve file\", \"name\", fname, \"route\", req.URL.Path)\n\t\tdir, name := filepath.Split(fname)\n\t\tfs := ctrl.FileSystem(dir)\n\t\tf, err := fs.Open(name)\n\t\tif err != nil {\n\t\t\treturn ErrInvalidFile(err)\n\t\t}\n\t\tdefer f.Close()\n\t\td, err := f.Stat()\n\t\tif err != nil {\n\t\t\treturn ErrInvalidFile(err)\n\t\t}\n\t\t// use contents of index.html for directory, if present\n\t\tif d.IsDir() {\n\t\t\tindex := strings.TrimSuffix(name, \"/\") + \"/index.html\"\n\t\t\tff, err := fs.Open(index)\n\t\t\tif err == nil {\n\t\t\t\tdefer ff.Close()\n\t\t\t\tdd, err := ff.Stat()\n\t\t\t\tif err == nil {\n\t\t\t\t\tname = index\n\t\t\t\t\td = dd\n\t\t\t\t\tf = ff\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// serveContent will check modification time\n\t\t// Still a directory? (we didn't find an index.html file)\n\t\tif d.IsDir() {\n\t\t\treturn dirList(rw, f)\n\t\t}\n\t\thttp.ServeContent(rw, req, d.Name(), d.ModTime(), f)\n\t\treturn nil\n\t}\n}\n\nfunc attemptsPathTraversal(req string, path string) bool {\n\tif !strings.Contains(req, \"..\") {\n\t\treturn false\n\t}\n\n\tcurrentPathIdx := 0\n\tif idx := strings.LastIndex(path, \"/*\"); idx > -1 && idx < len(path)-1 {\n\t\treq = req[idx+1:]\n\t}\n\tfor _, runeValue := range strings.FieldsFunc(req, isSlashRune) {\n\t\tif runeValue == \"..\" {\n\t\t\tcurrentPathIdx--\n\t\t\tif currentPathIdx < 0 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentPathIdx++\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isSlashRune(r rune) bool {\n\treturn os.IsPathSeparator(uint8(r))\n}\n\nvar replacer = strings.NewReplacer(\n\t\"&\", \"&amp;\",\n\t\"<\", \"&lt;\",\n\t\">\", \"&gt;\",\n\t// \"&#34;\" is shorter than \"&quot;\".\n\t`\"`, \"&#34;\",\n\t// \"&#39;\" is shorter than \"&apos;\" and apos was not in HTML until HTML5.\n\t\"'\", \"&#39;\",\n)\n\nfunc dirList(w http.ResponseWriter, f http.File) error {\n\tdirs, err := f.Readdir(-1)\n\tif err != nil {\n\t\treturn err\n\t}\n\tsort.Sort(byName(dirs))\n\n\tw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n\tfmt.Fprintf(w, \"<pre>\\n\")\n\tfor _, d := range dirs {\n\t\tname := d.Name()\n\t\tif d.IsDir() {\n\t\t\tname += \"/\"\n\t\t}\n\t\t// name may contain '?' or '#', which must be escaped to remain\n\t\t// part of the URL path, and not indicate the start of a query\n\t\t// string or fragment.\n\t\turl := url.URL{Path: name}\n\t\tfmt.Fprintf(w, \"<a href=\\\"%s\\\">%s</a>\\n\", url.String(), replacer.Replace(name))\n\t}\n\tfmt.Fprintf(w, \"</pre>\\n\")\n\treturn nil\n}\n\ntype byName []os.FileInfo\n\nfunc (s byName) Len() int           { return len(s) }\nfunc (s byName) Less(i, j int) bool { return s[i].Name() < s[j].Name() }\nfunc (s byName) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }\n"], "filenames": ["service.go"], "buggy_code_start_loc": [374], "buggy_code_end_loc": [417], "fixing_code_start_loc": [375], "fixing_code_end_loc": [448], "type": "CWE-22", "message": "Improper path sanitization in github.com/goadesign/goa before v3.0.9, v2.0.10, or v1.4.3 allow remote attackers to read files outside of the intended directory.", "other": {"cve": {"id": "CVE-2019-25073", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.397", "lastModified": "2023-06-08T21:15:15.307", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Improper path sanitization in github.com/goadesign/goa before v3.0.9, v2.0.10, or v1.4.3 allow remote attackers to read files outside of the intended directory."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:goa.design:goa:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "582B45BB-E80A-48AB-A34B-38B1BD3BBB35"}, {"vulnerable": true, "criteria": "cpe:2.3:a:goa.design:goa:*:*:*:*:*:go:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.10", "matchCriteriaId": "75C6F03D-BA0C-4C98-9A68-DEF5CA00979B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:goa.design:goa:*:*:*:*:*:go:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.9", "matchCriteriaId": "38E49757-1AA2-4B70-A3E4-CF7DA5E785AC"}]}]}], "references": [{"url": "https://github.com/goadesign/goa/commit/70b5a199d0f813d74423993832c424e1fc73fb39", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/goadesign/goa/pull/2388", "source": "security@golang.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0032", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/goadesign/goa/commit/70b5a199d0f813d74423993832c424e1fc73fb39"}}