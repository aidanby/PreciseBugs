{"buggy_code": ["/*\n * Encryption policy functions for per-file encryption support.\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility.\n *\n * Written by Michael Halcrow, 2015.\n * Modified by Jaegeuk Kim, 2015.\n */\n\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fscrypto.h>\n\nstatic int inode_has_encryption_context(struct inode *inode)\n{\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn 0;\n\treturn (inode->i_sb->s_cop->get_context(inode, NULL, 0L) > 0);\n}\n\n/*\n * check whether the policy is consistent with the encryption context\n * for the inode\n */\nstatic int is_encryption_context_consistent_with_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn 0;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res != sizeof(ctx))\n\t\treturn 0;\n\n\treturn (memcmp(ctx.master_key_descriptor, policy->master_key_descriptor,\n\t\t\tFS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t\t(ctx.flags == policy->flags) &&\n\t\t\t(ctx.contents_encryption_mode ==\n\t\t\t policy->contents_encryption_mode) &&\n\t\t\t(ctx.filenames_encryption_mode ==\n\t\t\t policy->filenames_encryption_mode));\n}\n\nstatic int create_encryption_context_from_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->set_context)\n\t\treturn -EOPNOTSUPP;\n\n\tif (inode->i_sb->s_cop->prepare_context) {\n\t\tres = inode->i_sb->s_cop->prepare_context(inode);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\tmemcpy(ctx.master_key_descriptor, policy->master_key_descriptor,\n\t\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\n\tif (!fscrypt_valid_contents_enc_mode(\n\t\t\t\tpolicy->contents_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: Invalid contents encryption mode %d\\n\", __func__,\n\t\t\tpolicy->contents_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fscrypt_valid_filenames_enc_mode(\n\t\t\t\tpolicy->filenames_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Invalid filenames encryption mode %d\\n\", __func__,\n\t\t\tpolicy->filenames_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (policy->flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tctx.contents_encryption_mode = policy->contents_encryption_mode;\n\tctx.filenames_encryption_mode = policy->filenames_encryption_mode;\n\tctx.flags = policy->flags;\n\tBUILD_BUG_ON(sizeof(ctx.nonce) != FS_KEY_DERIVATION_NONCE_SIZE);\n\tget_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);\n\n\treturn inode->i_sb->s_cop->set_context(inode, &ctx, sizeof(ctx), NULL);\n}\n\nint fscrypt_process_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tif (policy->version != 0)\n\t\treturn -EINVAL;\n\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fscrypt_process_policy);\n\nint fscrypt_get_policy(struct inode *inode, struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->get_context ||\n\t\t\t!inode->i_sb->s_cop->is_encrypted(inode))\n\t\treturn -ENODATA;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res != sizeof(ctx))\n\t\treturn -ENODATA;\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tpolicy->version = 0;\n\tpolicy->contents_encryption_mode = ctx.contents_encryption_mode;\n\tpolicy->filenames_encryption_mode = ctx.filenames_encryption_mode;\n\tpolicy->flags = ctx.flags;\n\tmemcpy(&policy->master_key_descriptor, ctx.master_key_descriptor,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_get_policy);\n\nint fscrypt_has_permitted_context(struct inode *parent, struct inode *child)\n{\n\tstruct fscrypt_info *parent_ci, *child_ci;\n\tint res;\n\n\tif ((parent == NULL) || (child == NULL)) {\n\t\tprintk(KERN_ERR\t\"parent %p child %p\\n\", parent, child);\n\t\tBUG_ON(1);\n\t}\n\n\t/* no restrictions if the parent directory is not encrypted */\n\tif (!parent->i_sb->s_cop->is_encrypted(parent))\n\t\treturn 1;\n\t/* if the child directory is not encrypted, this is always a problem */\n\tif (!parent->i_sb->s_cop->is_encrypted(child))\n\t\treturn 0;\n\tres = fscrypt_get_encryption_info(parent);\n\tif (res)\n\t\treturn 0;\n\tres = fscrypt_get_encryption_info(child);\n\tif (res)\n\t\treturn 0;\n\tparent_ci = parent->i_crypt_info;\n\tchild_ci = child->i_crypt_info;\n\tif (!parent_ci && !child_ci)\n\t\treturn 1;\n\tif (!parent_ci || !child_ci)\n\t\treturn 0;\n\n\treturn (memcmp(parent_ci->ci_master_key,\n\t\t\tchild_ci->ci_master_key,\n\t\t\tFS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t(parent_ci->ci_data_mode == child_ci->ci_data_mode) &&\n\t\t(parent_ci->ci_filename_mode == child_ci->ci_filename_mode) &&\n\t\t(parent_ci->ci_flags == child_ci->ci_flags));\n}\nEXPORT_SYMBOL(fscrypt_has_permitted_context);\n\n/**\n * fscrypt_inherit_context() - Sets a child context from its parent\n * @parent: Parent inode from which the context is inherited.\n * @child:  Child inode that inherits the context from @parent.\n * @fs_data:  private data given by FS.\n * @preload:  preload child i_crypt_info\n *\n * Return: Zero on success, non-zero otherwise\n */\nint fscrypt_inherit_context(struct inode *parent, struct inode *child,\n\t\t\t\t\t\tvoid *fs_data, bool preload)\n{\n\tstruct fscrypt_context ctx;\n\tstruct fscrypt_info *ci;\n\tint res;\n\n\tif (!parent->i_sb->s_cop->set_context)\n\t\treturn -EOPNOTSUPP;\n\n\tres = fscrypt_get_encryption_info(parent);\n\tif (res < 0)\n\t\treturn res;\n\n\tci = parent->i_crypt_info;\n\tif (ci == NULL)\n\t\treturn -ENOKEY;\n\n\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\tif (fscrypt_dummy_context_enabled(parent)) {\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tctx.flags = 0;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t\tres = 0;\n\t} else {\n\t\tctx.contents_encryption_mode = ci->ci_data_mode;\n\t\tctx.filenames_encryption_mode = ci->ci_filename_mode;\n\t\tctx.flags = ci->ci_flags;\n\t\tmemcpy(ctx.master_key_descriptor, ci->ci_master_key,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\t}\n\tget_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);\n\tres = parent->i_sb->s_cop->set_context(child, &ctx,\n\t\t\t\t\t\tsizeof(ctx), fs_data);\n\tif (res)\n\t\treturn res;\n\treturn preload ? fscrypt_get_encryption_info(child): 0;\n}\nEXPORT_SYMBOL(fscrypt_inherit_context);\n"], "fixing_code": ["/*\n * Encryption policy functions for per-file encryption support.\n *\n * Copyright (C) 2015, Google, Inc.\n * Copyright (C) 2015, Motorola Mobility.\n *\n * Written by Michael Halcrow, 2015.\n * Modified by Jaegeuk Kim, 2015.\n */\n\n#include <linux/random.h>\n#include <linux/string.h>\n#include <linux/fscrypto.h>\n\nstatic int inode_has_encryption_context(struct inode *inode)\n{\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn 0;\n\treturn (inode->i_sb->s_cop->get_context(inode, NULL, 0L) > 0);\n}\n\n/*\n * check whether the policy is consistent with the encryption context\n * for the inode\n */\nstatic int is_encryption_context_consistent_with_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->get_context)\n\t\treturn 0;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res != sizeof(ctx))\n\t\treturn 0;\n\n\treturn (memcmp(ctx.master_key_descriptor, policy->master_key_descriptor,\n\t\t\tFS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t\t(ctx.flags == policy->flags) &&\n\t\t\t(ctx.contents_encryption_mode ==\n\t\t\t policy->contents_encryption_mode) &&\n\t\t\t(ctx.filenames_encryption_mode ==\n\t\t\t policy->filenames_encryption_mode));\n}\n\nstatic int create_encryption_context_from_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->set_context)\n\t\treturn -EOPNOTSUPP;\n\n\tif (inode->i_sb->s_cop->prepare_context) {\n\t\tres = inode->i_sb->s_cop->prepare_context(inode);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\tmemcpy(ctx.master_key_descriptor, policy->master_key_descriptor,\n\t\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\n\tif (!fscrypt_valid_contents_enc_mode(\n\t\t\t\tpolicy->contents_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: Invalid contents encryption mode %d\\n\", __func__,\n\t\t\tpolicy->contents_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fscrypt_valid_filenames_enc_mode(\n\t\t\t\tpolicy->filenames_encryption_mode)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s: Invalid filenames encryption mode %d\\n\", __func__,\n\t\t\tpolicy->filenames_encryption_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (policy->flags & ~FS_POLICY_FLAGS_VALID)\n\t\treturn -EINVAL;\n\n\tctx.contents_encryption_mode = policy->contents_encryption_mode;\n\tctx.filenames_encryption_mode = policy->filenames_encryption_mode;\n\tctx.flags = policy->flags;\n\tBUILD_BUG_ON(sizeof(ctx.nonce) != FS_KEY_DERIVATION_NONCE_SIZE);\n\tget_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);\n\n\treturn inode->i_sb->s_cop->set_context(inode, &ctx, sizeof(ctx), NULL);\n}\n\nint fscrypt_process_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\n\tif (policy->version != 0)\n\t\treturn -EINVAL;\n\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(fscrypt_process_policy);\n\nint fscrypt_get_policy(struct inode *inode, struct fscrypt_policy *policy)\n{\n\tstruct fscrypt_context ctx;\n\tint res;\n\n\tif (!inode->i_sb->s_cop->get_context ||\n\t\t\t!inode->i_sb->s_cop->is_encrypted(inode))\n\t\treturn -ENODATA;\n\n\tres = inode->i_sb->s_cop->get_context(inode, &ctx, sizeof(ctx));\n\tif (res != sizeof(ctx))\n\t\treturn -ENODATA;\n\tif (ctx.format != FS_ENCRYPTION_CONTEXT_FORMAT_V1)\n\t\treturn -EINVAL;\n\n\tpolicy->version = 0;\n\tpolicy->contents_encryption_mode = ctx.contents_encryption_mode;\n\tpolicy->filenames_encryption_mode = ctx.filenames_encryption_mode;\n\tpolicy->flags = ctx.flags;\n\tmemcpy(&policy->master_key_descriptor, ctx.master_key_descriptor,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\treturn 0;\n}\nEXPORT_SYMBOL(fscrypt_get_policy);\n\nint fscrypt_has_permitted_context(struct inode *parent, struct inode *child)\n{\n\tstruct fscrypt_info *parent_ci, *child_ci;\n\tint res;\n\n\tif ((parent == NULL) || (child == NULL)) {\n\t\tprintk(KERN_ERR\t\"parent %p child %p\\n\", parent, child);\n\t\tBUG_ON(1);\n\t}\n\n\t/* no restrictions if the parent directory is not encrypted */\n\tif (!parent->i_sb->s_cop->is_encrypted(parent))\n\t\treturn 1;\n\t/* if the child directory is not encrypted, this is always a problem */\n\tif (!parent->i_sb->s_cop->is_encrypted(child))\n\t\treturn 0;\n\tres = fscrypt_get_encryption_info(parent);\n\tif (res)\n\t\treturn 0;\n\tres = fscrypt_get_encryption_info(child);\n\tif (res)\n\t\treturn 0;\n\tparent_ci = parent->i_crypt_info;\n\tchild_ci = child->i_crypt_info;\n\tif (!parent_ci && !child_ci)\n\t\treturn 1;\n\tif (!parent_ci || !child_ci)\n\t\treturn 0;\n\n\treturn (memcmp(parent_ci->ci_master_key,\n\t\t\tchild_ci->ci_master_key,\n\t\t\tFS_KEY_DESCRIPTOR_SIZE) == 0 &&\n\t\t(parent_ci->ci_data_mode == child_ci->ci_data_mode) &&\n\t\t(parent_ci->ci_filename_mode == child_ci->ci_filename_mode) &&\n\t\t(parent_ci->ci_flags == child_ci->ci_flags));\n}\nEXPORT_SYMBOL(fscrypt_has_permitted_context);\n\n/**\n * fscrypt_inherit_context() - Sets a child context from its parent\n * @parent: Parent inode from which the context is inherited.\n * @child:  Child inode that inherits the context from @parent.\n * @fs_data:  private data given by FS.\n * @preload:  preload child i_crypt_info\n *\n * Return: Zero on success, non-zero otherwise\n */\nint fscrypt_inherit_context(struct inode *parent, struct inode *child,\n\t\t\t\t\t\tvoid *fs_data, bool preload)\n{\n\tstruct fscrypt_context ctx;\n\tstruct fscrypt_info *ci;\n\tint res;\n\n\tif (!parent->i_sb->s_cop->set_context)\n\t\treturn -EOPNOTSUPP;\n\n\tres = fscrypt_get_encryption_info(parent);\n\tif (res < 0)\n\t\treturn res;\n\n\tci = parent->i_crypt_info;\n\tif (ci == NULL)\n\t\treturn -ENOKEY;\n\n\tctx.format = FS_ENCRYPTION_CONTEXT_FORMAT_V1;\n\tif (fscrypt_dummy_context_enabled(parent)) {\n\t\tctx.contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS;\n\t\tctx.filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS;\n\t\tctx.flags = 0;\n\t\tmemset(ctx.master_key_descriptor, 0x42, FS_KEY_DESCRIPTOR_SIZE);\n\t\tres = 0;\n\t} else {\n\t\tctx.contents_encryption_mode = ci->ci_data_mode;\n\t\tctx.filenames_encryption_mode = ci->ci_filename_mode;\n\t\tctx.flags = ci->ci_flags;\n\t\tmemcpy(ctx.master_key_descriptor, ci->ci_master_key,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE);\n\t}\n\tget_random_bytes(ctx.nonce, FS_KEY_DERIVATION_NONCE_SIZE);\n\tres = parent->i_sb->s_cop->set_context(child, &ctx,\n\t\t\t\t\t\tsizeof(ctx), fs_data);\n\tif (res)\n\t\treturn res;\n\treturn preload ? fscrypt_get_encryption_info(child): 0;\n}\nEXPORT_SYMBOL(fscrypt_inherit_context);\n"], "filenames": ["fs/crypto/policy.c"], "buggy_code_start_loc": [97], "buggy_code_end_loc": [97], "fixing_code_start_loc": [98], "fixing_code_end_loc": [101], "type": "CWE-264", "message": "A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service.", "other": {"cve": {"id": "CVE-2016-10318", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-04T16:59:00.157", "lastModified": "2017-04-11T15:32:38.110", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A missing authorization check in the fscrypt_process_policy function in fs/crypto/policy.c in the ext4 and f2fs filesystem encryption support in the Linux kernel before 4.7.4 allows a user to assign an encryption policy to a directory owned by a different user, potentially creating a denial of service."}, {"lang": "es", "value": "Una comprobaci\u00f3n de autorizaci\u00f3n que falta en la funci\u00f3n fscrypt_process_policy en fs/crypto/policy.c en el soporte de cifrado del sistema de archivos ext4 y f2fs en el kernel de Linux en versiones anteriores a 4.7.4 permite a un usuario asignar una pol\u00edtica de cifrado a un directorio propiedad de un usuario diferente, potencialmente creando una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.7.3", "matchCriteriaId": "1BCDE368-0E94-493A-B378-0B347ED4EC90"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=163ae1c6ad6299b19e22b4a35d5ab24a89791a98", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.7.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/97404", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/163ae1c6ad6299b19e22b4a35d5ab24a89791a98"}}