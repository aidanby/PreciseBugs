{"buggy_code": ["/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n\n/* inverse of 'pcRel' */\n#define invpcRel(pc, p)\t\t((p)->code + (pc) + 1)\n\nstatic const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                    const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** For that, search the array of absolute line info for the largest saved\n** instruction smaller or equal to the wanted instruction. A special\n** case is when there is no absolute info or the instruction is before\n** the first absolute one.\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    unsigned int i;\n    if (pc >= f->abslineinfo[f->sizeabslineinfo - 1].pc)\n      i = f->sizeabslineinfo - 1;  /* instruction is after last saved one */\n    else {  /* binary search */\n      unsigned int j = f->sizeabslineinfo - 1;  /* pc < anchorlines[j] */\n      i = 0;  /* abslineinfo[i] <= pc */\n      while (i < j - 1) {\n        unsigned int m = (j + i) / 2;\n        if (pc >= f->abslineinfo[m].pc)\n          i = m;\n        else\n          j = m;\n      }\n    }\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getstr(p->source);\n      ar->srclen = tsslen(p->source);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(s2v(L->top));\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top, t);  /* push it on stack */\n    api_incr_top(L);\n    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n    for (i = 0; i < p->sizelineinfo; i++) {  /* for all lines with code */\n      currentline = nextline(p, currentline, i);\n      luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  if (ci == NULL)  /* no 'ci'? */\n    return NULL;  /* no info */\n  else if (ci->callstatus & CIST_FIN) {  /* is this a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  /* calling function is a known Lua function? */\n  else if (!(ci->callstatus & CIST_TAIL) && isLua(ci->previous))\n    return funcnamefromcode(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_TRAN))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = ci->u2.transferinfo.ftransfer;\n          ar->ntransfer = ci->u2.transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic void kname (const Proto *p, int c, const char **name) {\n  TValue *kvalue = &p->k[c];\n  *name = (ttisstring(kvalue)) ? svalue(kvalue) : \"?\";\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = getobjname(p, pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *gxf (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is an upvalue? */\n    name = upvalname(p, t);\n  else\n    getobjname(p, pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, pc, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        rkname(p, pc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                     const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  const Proto *p = ci_func(ci)->p;  /* calling function */\n  int pc = currentpc(ci);  /* calling instruction index */\n  Instruction i = p->code[pc];  /* calling instruction */\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    case OP_LT: case OP_LE: case OP_LTI: case OP_LEI:\n      *name = \"order\";  /* '<=' can call '__lt', etc. */\n      return \"metamethod\";\n    case OP_CLOSE: case OP_RETURN:\n      *name = \"close\";\n      return \"metamethod\";\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n/* }====================================================== */\n\n\n\n/*\n** The subtraction of two potentially unrelated pointers is\n** not ISO C, but it should not crash a program; the subsequent\n** checks are ISO C and ensure a correct result.\n*/\nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId base = ci->func + 1;\n  ptrdiff_t i = cast(StkId, o) - base;\n  return (0 <= i && i < (ci->top - base) && s2v(base + i) == o);\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  const char *name = NULL;  /* to avoid warnings */\n  CallInfo *ci = L->ci;\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind && isinstack(ci, o))  /* no? try a register */\n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(cast(StkId, o) - (ci->func + 1)), &name);\n  }\n  return (kind) ? luaO_pushfstring(L, \" (%s '%s')\", kind, name) : \"\";\n}\n\n\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, varinfo(L, o));\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!tointegerns(p1, &temp))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src)\n    luaO_chunkid(buff, getstr(src), tsslen(src));\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  /* no line changes in the way */\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line without\n** the need for 'oldpc'; so, 'oldpc' does not need to be initialized\n** before. Some exceptional conditions may return to a function without\n** updating 'oldpc'. In that case, 'oldpc' may be invalid; if so, it is\n** reset to zero.  (A wrong but valid 'oldpc' at most causes an extra\n** call to a line hook.)\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  /* 'L->oldpc' may be invalid; reset it in this case */\n  int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  /* prepare top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  /* call linehook when enter a new function, */\n        pc <= invpcRel(oldpc, p) ||  /* when jump back (loop), or when */\n        changedline(p, oldpc, npci)) {  /* enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n", "-- $Id: testes/db.lua $\n-- See Copyright Notice in file all.lua\n\n-- testing debug library\n\nlocal debug = require \"debug\"\n\nlocal function dostring(s) return assert(load(s))() end\n\nprint\"testing debug library and debug information\"\n\ndo\nlocal a=1\nend\n\nassert(not debug.gethook())\n\nlocal testline = 19         -- line where 'test' is defined\nfunction test (s, l, p)     -- this must be line 19\n  collectgarbage()   -- avoid gc during trace\n  local function f (event, line)\n    assert(event == 'line')\n    local l = table.remove(l, 1)\n    if p then print(l, line) end\n    assert(l == line, \"wrong trace!!\")\n  end\n  debug.sethook(f,\"l\"); load(s)(); debug.sethook()\n  assert(#l == 0)\nend\n\n\ndo\n  assert(not pcall(debug.getinfo, print, \"X\"))   -- invalid option\n  assert(not debug.getinfo(1000))   -- out of range level\n  assert(not debug.getinfo(-1))     -- out of range level\n  local a = debug.getinfo(print)\n  assert(a.what == \"C\" and a.short_src == \"[C]\")\n  a = debug.getinfo(print, \"L\")\n  assert(a.activelines == nil)\n  local b = debug.getinfo(test, \"SfL\")\n  assert(b.name == nil and b.what == \"Lua\" and b.linedefined == testline and\n         b.lastlinedefined == b.linedefined + 10 and\n         b.func == test and not string.find(b.short_src, \"%[\"))\n  assert(b.activelines[b.linedefined + 1] and\n         b.activelines[b.lastlinedefined])\n  assert(not b.activelines[b.linedefined] and\n         not b.activelines[b.lastlinedefined + 1])\nend\n\n\n-- test file and string names truncation\na = \"function f () end\"\nlocal function dostring (s, x) return load(s, x)() end\ndostring(a)\nassert(debug.getinfo(f).short_src == string.format('[string \"%s\"]', a))\ndostring(a..string.format(\"; %s\\n=1\", string.rep('p', 400)))\nassert(string.find(debug.getinfo(f).short_src, '^%[string [^\\n]*%.%.%.\"%]$'))\ndostring(a..string.format(\"; %s=1\", string.rep('p', 400)))\nassert(string.find(debug.getinfo(f).short_src, '^%[string [^\\n]*%.%.%.\"%]$'))\ndostring(\"\\n\"..a)\nassert(debug.getinfo(f).short_src == '[string \"...\"]')\ndostring(a, \"\")\nassert(debug.getinfo(f).short_src == '[string \"\"]')\ndostring(a, \"@xuxu\")\nassert(debug.getinfo(f).short_src == \"xuxu\")\ndostring(a, \"@\"..string.rep('p', 1000)..'t')\nassert(string.find(debug.getinfo(f).short_src, \"^%.%.%.p*t$\"))\ndostring(a, \"=xuxu\")\nassert(debug.getinfo(f).short_src == \"xuxu\")\ndostring(a, string.format(\"=%s\", string.rep('x', 500)))\nassert(string.find(debug.getinfo(f).short_src, \"^x*$\"))\ndostring(a, \"=\")\nassert(debug.getinfo(f).short_src == \"\")\na = nil; f = nil;\n\n\nrepeat\n  local g = {x = function ()\n    local a = debug.getinfo(2)\n    assert(a.name == 'f' and a.namewhat == 'local')\n    a = debug.getinfo(1)\n    assert(a.name == 'x' and a.namewhat == 'field')\n    return 'xixi'\n  end}\n  local f = function () return 1+1 and (not 1 or g.x()) end\n  assert(f() == 'xixi')\n  g = debug.getinfo(f)\n  assert(g.what == \"Lua\" and g.func == f and g.namewhat == \"\" and not g.name)\n\n  function f (x, name)   -- local!\n    name = name or 'f'\n    local a = debug.getinfo(1)\n    assert(a.name == name and a.namewhat == 'local')\n    return x\n  end\n\n  -- breaks in different conditions\n  if 3>4 then break end; f()\n  if 3<4 then a=1 else break end; f()\n  while 1 do local x=10; break end; f()\n  local b = 1\n  if 3>4 then return math.sin(1) end; f()\n  a = 3<4; f()\n  a = 3<4 or 1; f()\n  repeat local x=20; if 4>3 then f() else break end; f() until 1\n  g = {}\n  f(g).x = f(2) and f(10)+f(9)\n  assert(g.x == f(19))\n  function g(x) if not x then return 3 end return (x('a', 'x')) end\n  assert(g(f) == 'a')\nuntil 1\n\ntest([[if\nmath.sin(1)\nthen\n  a=1\nelse\n  a=2\nend\n]], {2,3,4,7})\n\ntest([[--\nif nil then\n  a=1\nelse\n  a=2\nend\n]], {2,5,6})\n\ntest([[a=1\nrepeat\n  a=a+1\nuntil a==3\n]], {1,3,4,3,4})\n\ntest([[ do\n  return\nend\n]], {2})\n\ntest([[local a\na=1\nwhile a<=3 do\n  a=a+1\nend\n]], {1,2,3,4,3,4,3,4,3,5})\n\ntest([[while math.sin(1) do\n  if math.sin(1)\n  then break\n  end\nend\na=1]], {1,2,3,6})\n\ntest([[for i=1,3 do\n  a=i\nend\n]], {1,2,1,2,1,2,1,3})\n\ntest([[for i,v in pairs{'a','b'} do\n  a=tostring(i) .. v\nend\n]], {1,2,1,2,1,3})\n\ntest([[for i=1,4 do a=1 end]], {1,1,1,1})\n\n\ndo   -- testing line info/trace with large gaps in source\n\n  local a = {1, 2, 3, 10, 124, 125, 126, 127, 128, 129, 130,\n             255, 256, 257, 500, 1000}\n  local s = [[\n     local b = {10}\n     a = b[1] X + Y b[1]\n     b = 4\n  ]]\n  for _, i in ipairs(a) do\n    local subs = {X = string.rep(\"\\n\", i)}\n    for _, j in ipairs(a) do\n      subs.Y = string.rep(\"\\n\", j)\n      local s = string.gsub(s, \"[XY]\", subs)\n      test(s, {1, 2 + i, 2 + i + j, 2 + i, 2 + i + j, 3 + i + j})\n    end\n  end\nend\n\nprint'+'\n\n-- invalid levels in [gs]etlocal\nassert(not pcall(debug.getlocal, 20, 1))\nassert(not pcall(debug.setlocal, -1, 1, 10))\n\n\n-- parameter names\nlocal function foo (a,b,...) local d, e end\nlocal co = coroutine.create(foo)\n\nassert(debug.getlocal(foo, 1) == 'a')\nassert(debug.getlocal(foo, 2) == 'b')\nassert(not debug.getlocal(foo, 3))\nassert(debug.getlocal(co, foo, 1) == 'a')\nassert(debug.getlocal(co, foo, 2) == 'b')\nassert(not debug.getlocal(co, foo, 3))\n\nassert(not debug.getlocal(print, 1))\n\n\nlocal function foo () return (debug.getlocal(1, -1)) end\nassert(not foo(10))\n\n\n-- varargs\nlocal function foo (a, ...)\n  local t = table.pack(...)\n  for i = 1, t.n do\n    local n, v = debug.getlocal(1, -i)\n    assert(n == \"(vararg)\" and v == t[i])\n  end\n  assert(not debug.getlocal(1, -(t.n + 1)))\n  assert(not debug.setlocal(1, -(t.n + 1), 30))\n  if t.n > 0 then\n    (function (x)\n      assert(debug.setlocal(2, -1, x) == \"(vararg)\")\n      assert(debug.setlocal(2, -t.n, x) == \"(vararg)\")\n     end)(430)\n     assert(... == 430)\n  end\nend\n\nfoo()\nfoo(print)\nfoo(200, 3, 4)\nlocal a = {}\nfor i = 1, (_soft and 100 or 1000) do a[i] = i end\nfoo(table.unpack(a))\na = nil\n\n\n\ndo   -- test hook presence in debug info\n  assert(not debug.gethook())\n  local count = 0\n  local function f ()\n    assert(debug.getinfo(1).namewhat == \"hook\")\n    local sndline = string.match(debug.traceback(), \"\\n(.-)\\n\")\n    assert(string.find(sndline, \"hook\"))\n    count = count + 1\n  end\n  debug.sethook(f, \"l\")\n  local a = 0\n  _ENV.a = a\n  a = 1\n  debug.sethook()\n  assert(count == 4)\nend\n\n\n-- hook table has weak keys\nassert(getmetatable(debug.getregistry()._HOOKKEY).__mode == 'k')\n\n\na = {}; L = nil\nlocal glob = 1\nlocal oldglob = glob\ndebug.sethook(function (e,l)\n  collectgarbage()   -- force GC during a hook\n  local f, m, c = debug.gethook()\n  assert(m == 'crl' and c == 0)\n  if e == \"line\" then\n    if glob ~= oldglob then\n      L = l-1   -- get the first line where \"glob\" has changed\n      oldglob = glob\n    end\n  elseif e == \"call\" then\n      local f = debug.getinfo(2, \"f\").func\n      a[f] = 1\n  else assert(e == \"return\")\n  end\nend, \"crl\")\n\n\nfunction f(a,b)\n  collectgarbage()\n  local _, x = debug.getlocal(1, 1)\n  local _, y = debug.getlocal(1, 2)\n  assert(x == a and y == b)\n  assert(debug.setlocal(2, 3, \"pera\") == \"AA\"..\"AA\")\n  assert(debug.setlocal(2, 4, \"ma\ufffd\ufffd\") == \"B\")\n  x = debug.getinfo(2)\n  assert(x.func == g and x.what == \"Lua\" and x.name == 'g' and\n         x.nups == 2 and string.find(x.source, \"^@.*db%.lua$\"))\n  glob = glob+1\n  assert(debug.getinfo(1, \"l\").currentline == L+1)\n  assert(debug.getinfo(1, \"l\").currentline == L+2)\nend\n\nfunction foo()\n  glob = glob+1\n  assert(debug.getinfo(1, \"l\").currentline == L+1)\nend; foo()  -- set L\n-- check line counting inside strings and empty lines\n\n_ = 'alo\\\nalo' .. [[\n\n]]\n--[[\n]]\nassert(debug.getinfo(1, \"l\").currentline == L+11)  -- check count of lines\n\n\nfunction g (...)\n  local arg = {...}\n  do local a,b,c; a=math.sin(40); end\n  local feijao\n  local AAAA,B = \"xuxu\", \"mam\ufffdo\"\n  f(AAAA,B)\n  assert(AAAA == \"pera\" and B == \"ma\ufffd\ufffd\")\n  do\n     local B = 13\n     local x,y = debug.getlocal(1,5)\n     assert(x == 'B' and y == 13)\n  end\nend\n\ng()\n\n\nassert(a[f] and a[g] and a[assert] and a[debug.getlocal] and not a[print])\n\n\n-- tests for manipulating non-registered locals (C and Lua temporaries)\n\nlocal n, v = debug.getlocal(0, 1)\nassert(v == 0 and n == \"(C temporary)\")\nlocal n, v = debug.getlocal(0, 2)\nassert(v == 2 and n == \"(C temporary)\")\nassert(not debug.getlocal(0, 3))\nassert(not debug.getlocal(0, 0))\n\nfunction f()\n  assert(select(2, debug.getlocal(2,3)) == 1)\n  assert(not debug.getlocal(2,4))\n  debug.setlocal(2, 3, 10)\n  return 20\nend\n\nfunction g(a,b) return (a+1) + f() end\n\nassert(g(0,0) == 30)\n \n\ndebug.sethook(nil);\nassert(not debug.gethook())\n\n\n-- minimal tests for setuservalue/getuservalue\ndo\n  assert(not debug.setuservalue(io.stdin, 10))\n  local a, b = debug.getuservalue(io.stdin, 10)\n  assert(a == nil and not b)\nend\n\n-- testing iteraction between multiple values x hooks\ndo\n  local function f(...) return 3, ... end\n  local count = 0\n  local a = {}\n  for i = 1, 100 do a[i] = i end\n  debug.sethook(function () count = count + 1 end, \"\", 1)\n  local t = {table.unpack(a)}\n  assert(#t == 100)\n  t = {table.unpack(a, 1, 3)}\n  assert(#t == 3)\n  t = {f(table.unpack(a, 1, 30))}\n  assert(#t == 31)\nend\n\n\n-- testing access to function arguments\n\nlocal function collectlocals (level)\n  local tab = {}\n  for i = 1, math.huge do\n    local n, v = debug.getlocal(level + 1, i)\n    if not (n and string.find(n, \"^[a-zA-Z0-9_]+$\")) then\n       break   -- consider only real variables\n    end\n    tab[n] = v\n  end\n  return tab\nend\n\n\nX = nil\na = {}\nfunction a:f (a, b, ...) local arg = {...}; local c = 13 end\ndebug.sethook(function (e)\n  assert(e == \"call\")\n  dostring(\"XX = 12\")  -- test dostring inside hooks\n  -- testing errors inside hooks\n  assert(not pcall(load(\"a='joao'+1\")))\n  debug.sethook(function (e, l) \n    assert(debug.getinfo(2, \"l\").currentline == l)\n    local f,m,c = debug.gethook()\n    assert(e == \"line\")\n    assert(m == 'l' and c == 0)\n    debug.sethook(nil)  -- hook is called only once\n    assert(not X)       -- check that\n    X = collectlocals(2)\n  end, \"l\")\nend, \"c\")\n\na:f(1,2,3,4,5)\nassert(X.self == a and X.a == 1   and X.b == 2 and X.c == nil)\nassert(XX == 12)\nassert(not debug.gethook())\n\n\n-- testing access to local variables in return hook (bug in 5.2)\ndo\n  local X = false\n\n  local function foo (a, b, ...)\n    do local x,y,z end\n    local c, d = 10, 20\n    return\n  end\n\n  local function aux ()\n    if debug.getinfo(2).name == \"foo\" then\n      X = true   -- to signal that it found 'foo'\n      local tab = {a = 100, b = 200, c = 10, d = 20}\n      for n, v in pairs(collectlocals(2)) do\n        assert(tab[n] == v)\n        tab[n] = undef\n      end\n      assert(next(tab) == nil)    -- 'tab' must be empty\n    end\n  end\n\n  debug.sethook(aux, \"r\"); foo(100, 200); debug.sethook()\n  assert(X)\n\nend\n\n\nlocal function eqseq (t1, t2)\n  assert(#t1 == #t2)\n  for i = 1, #t1 do\n    assert(t1[i] == t2[i])\n  end\nend\n\n\ndo  print(\"testing inspection of parameters/returned values\")\n  local on = false\n  local inp, out\n\n  local function hook (event)\n    if not on then return end\n    local ar = debug.getinfo(2, \"ruS\")\n    local t = {}\n    for i = ar.ftransfer, ar.ftransfer + ar.ntransfer - 1 do\n      local _, v = debug.getlocal(2, i)\n      t[#t + 1] = v \n    end\n    if event == \"return\" then\n      out = t\n    else\n      inp = t\n    end\n  end\n\n  debug.sethook(hook, \"cr\")\n\n  on = true; math.sin(3); on = false\n  eqseq(inp, {3}); eqseq(out, {math.sin(3)})\n\n  on = true; select(2, 10, 20, 30, 40); on = false\n  eqseq(inp, {2, 10, 20, 30, 40}); eqseq(out, {20, 30, 40})\n\n  local function foo (a, ...) return ... end\n  local function foo1 () on = not on; return foo(20, 10, 0) end\n  foo1(); on = false\n  eqseq(inp, {20}); eqseq(out, {10, 0})\n\n  debug.sethook()\nend\n\n\n\n-- testing upvalue access\nlocal function getupvalues (f)\n  local t = {}\n  local i = 1\n  while true do\n    local name, value = debug.getupvalue(f, i)\n    if not name then break end\n    assert(not t[name])\n    t[name] = value\n    i = i + 1\n  end\n  return t\nend\n\nlocal a,b,c = 1,2,3\nlocal function foo1 (a) b = a; return c end\nlocal function foo2 (x) a = x; return c+b end\nassert(not debug.getupvalue(foo1, 3))\nassert(not debug.getupvalue(foo1, 0))\nassert(not debug.setupvalue(foo1, 3, \"xuxu\"))\nlocal t = getupvalues(foo1)\nassert(t.a == nil and t.b == 2 and t.c == 3)\nt = getupvalues(foo2)\nassert(t.a == 1 and t.b == 2 and t.c == 3)\nassert(debug.setupvalue(foo1, 1, \"xuxu\") == \"b\")\nassert(({debug.getupvalue(foo2, 3)})[2] == \"xuxu\")\n-- upvalues of C functions are allways \"called\" \"\" (the empty string)\nassert(debug.getupvalue(string.gmatch(\"x\", \"x\"), 1) == \"\")  \n\n\n-- testing count hooks\nlocal a=0\ndebug.sethook(function (e) a=a+1 end, \"\", 1)\na=0; for i=1,1000 do end; assert(1000 < a and a < 1012)\ndebug.sethook(function (e) a=a+1 end, \"\", 4)\na=0; for i=1,1000 do end; assert(250 < a and a < 255)\nlocal f,m,c = debug.gethook()\nassert(m == \"\" and c == 4)\ndebug.sethook(function (e) a=a+1 end, \"\", 4000)\na=0; for i=1,1000 do end; assert(a == 0)\n\ndo\n  debug.sethook(print, \"\", 2^24 - 1)   -- count upperbound\n  local f,m,c = debug.gethook()\n  assert(({debug.gethook()})[3] == 2^24 - 1)\nend\n\ndebug.sethook()\n\n\n-- tests for tail calls\nlocal function f (x)\n  if x then\n    assert(debug.getinfo(1, \"S\").what == \"Lua\")\n    assert(debug.getinfo(1, \"t\").istailcall == true)\n    local tail = debug.getinfo(2)\n    assert(tail.func == g1 and tail.istailcall == true)\n    assert(debug.getinfo(3, \"S\").what == \"main\")\n    print\"+\"\n    end\nend\n\nfunction g(x) return f(x) end\n\nfunction g1(x) g(x) end\n\nlocal function h (x) local f=g1; return f(x) end\n\nh(true)\n\nlocal b = {}\ndebug.sethook(function (e) table.insert(b, e) end, \"cr\")\nh(false)\ndebug.sethook()\nlocal res = {\"return\",   -- first return (from sethook)\n  \"call\", \"tail call\", \"call\", \"tail call\",\n  \"return\", \"return\",\n  \"call\",    -- last call (to sethook)\n}\nfor i = 1, #res do assert(res[i] == table.remove(b, 1)) end\n\nb = 0\ndebug.sethook(function (e)\n                if e == \"tail call\" then\n                  b = b + 1\n                  assert(debug.getinfo(2, \"t\").istailcall == true)\n                else\n                  assert(debug.getinfo(2, \"t\").istailcall == false)\n                end\n              end, \"c\")\nh(false)\ndebug.sethook()\nassert(b == 2)   -- two tail calls\n\nlim = _soft and 3000 or 30000\nlocal function foo (x)\n  if x==0 then\n    assert(debug.getinfo(2).what == \"main\")\n    local info = debug.getinfo(1)\n    assert(info.istailcall == true and info.func == foo)\n  else return foo(x-1)\n  end\nend\n\nfoo(lim)\n\n\nprint\"+\"\n\n\n-- testing local function information\nco = load[[\n  local A = function ()\n    return x\n  end\n  return\n]]\n\nlocal a = 0\n-- 'A' should be visible to debugger only after its complete definition\ndebug.sethook(function (e, l)\n  if l == 3 then a = a + 1; assert(debug.getlocal(2, 1) == \"(temporary)\")\n  elseif l == 4 then a = a + 1; assert(debug.getlocal(2, 1) == \"A\")\n  end\nend, \"l\")\nco()  -- run local function definition\ndebug.sethook()  -- turn off hook\nassert(a == 2)   -- ensure all two lines where hooked\n\n-- testing traceback\n\nassert(debug.traceback(print) == print)\nassert(debug.traceback(print, 4) == print)\nassert(string.find(debug.traceback(\"hi\", 4), \"^hi\\n\"))\nassert(string.find(debug.traceback(\"hi\"), \"^hi\\n\"))\nassert(not string.find(debug.traceback(\"hi\"), \"'debug.traceback'\"))\nassert(string.find(debug.traceback(\"hi\", 0), \"'debug.traceback'\"))\nassert(string.find(debug.traceback(), \"^stack traceback:\\n\"))\n\ndo  -- C-function names in traceback\n  local st, msg = (function () return pcall end)()(debug.traceback)\n  assert(st == true and string.find(msg, \"pcall\"))\nend\n\n\n-- testing nparams, nups e isvararg\nlocal t = debug.getinfo(print, \"u\")\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 0)\n\nt = debug.getinfo(function (a,b,c) end, \"u\")\nassert(t.isvararg == false and t.nparams == 3 and t.nups == 0)\n\nt = debug.getinfo(function (a,b,...) return t[a] end, \"u\")\nassert(t.isvararg == true and t.nparams == 2 and t.nups == 1)\n\nt = debug.getinfo(1)   -- main\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 1 and\n       debug.getupvalue(t.func, 1) == \"_ENV\")\n\nt = debug.getinfo(math.sin)   -- C function\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 0)\n\nt = debug.getinfo(string.gmatch(\"abc\", \"a\"))   -- C closure\nassert(t.isvararg == true and t.nparams == 0 and t.nups > 0)\n\n\n\n-- testing debugging of coroutines\n\nlocal function checktraceback (co, p, level)\n  local tb = debug.traceback(co, nil, level)\n  local i = 0\n  for l in string.gmatch(tb, \"[^\\n]+\\n?\") do\n    assert(i == 0 or string.find(l, p[i]))\n    i = i+1\n  end\n  assert(p[i] == undef)\nend\n\n\nlocal function f (n)\n  if n > 0 then f(n-1)\n  else coroutine.yield() end\nend\n\nlocal co = coroutine.create(f)\ncoroutine.resume(co, 3)\nchecktraceback(co, {\"yield\", \"db.lua\", \"db.lua\", \"db.lua\", \"db.lua\"})\nchecktraceback(co, {\"db.lua\", \"db.lua\", \"db.lua\", \"db.lua\"}, 1)\nchecktraceback(co, {\"db.lua\", \"db.lua\", \"db.lua\"}, 2)\nchecktraceback(co, {\"db.lua\"}, 4)\nchecktraceback(co, {}, 40)\n\n\nco = coroutine.create(function (x)\n       local a = 1\n       coroutine.yield(debug.getinfo(1, \"l\"))\n       coroutine.yield(debug.getinfo(1, \"l\").currentline)\n       return a\n     end)\n\nlocal tr = {}\nlocal foo = function (e, l) if l then table.insert(tr, l) end end\ndebug.sethook(co, foo, \"lcr\")\n\nlocal _, l = coroutine.resume(co, 10)\nlocal x = debug.getinfo(co, 1, \"lfLS\")\nassert(x.currentline == l.currentline and x.activelines[x.currentline])\nassert(type(x.func) == \"function\")\nfor i=x.linedefined + 1, x.lastlinedefined do\n  assert(x.activelines[i])\n  x.activelines[i] = undef\nend\nassert(next(x.activelines) == nil)   -- no 'extra' elements\nassert(not debug.getinfo(co, 2))\nlocal a,b = debug.getlocal(co, 1, 1)\nassert(a == \"x\" and b == 10)\na,b = debug.getlocal(co, 1, 2)\nassert(a == \"a\" and b == 1)\ndebug.setlocal(co, 1, 2, \"hi\")\nassert(debug.gethook(co) == foo)\nassert(#tr == 2 and\n       tr[1] == l.currentline-1 and tr[2] == l.currentline)\n\na,b,c = pcall(coroutine.resume, co)\nassert(a and b and c == l.currentline+1)\nchecktraceback(co, {\"yield\", \"in function <\"})\n\na,b = coroutine.resume(co)\nassert(a and b == \"hi\")\nassert(#tr == 4 and tr[4] == l.currentline+2)\nassert(debug.gethook(co) == foo)\nassert(not debug.gethook())\nchecktraceback(co, {})\n\n\n-- check get/setlocal in coroutines\nco = coroutine.create(function (x)\n  local a, b = coroutine.yield(x)\n  assert(a == 100 and b == nil)\n  return x\nend)\na, b = coroutine.resume(co, 10)\nassert(a and b == 10)\na, b = debug.getlocal(co, 1, 1)\nassert(a == \"x\" and b == 10)\nassert(not debug.getlocal(co, 1, 5))\nassert(debug.setlocal(co, 1, 1, 30) == \"x\")\nassert(not debug.setlocal(co, 1, 5, 40))\na, b = coroutine.resume(co, 100)\nassert(a and b == 30)\n\n\n-- check traceback of suspended (or dead with error) coroutines\n\nfunction f(i)\n  if i == 0 then error(i)\n  else coroutine.yield(); f(i-1)\n  end\nend\n\n\nco = coroutine.create(function (x) f(x) end)\na, b = coroutine.resume(co, 3)\nt = {\"'coroutine.yield'\", \"'f'\", \"in function <\"}\nwhile coroutine.status(co) == \"suspended\" do\n  checktraceback(co, t)\n  a, b = coroutine.resume(co)\n  table.insert(t, 2, \"'f'\")   -- one more recursive call to 'f'\nend\nt[1] = \"'error'\"\nchecktraceback(co, t)\n\n\n-- test acessing line numbers of a coroutine from a resume inside\n-- a C function (this is a known bug in Lua 5.0)\n\nlocal function g(x)\n    coroutine.yield(x)\nend\n\nlocal function f (i)\n  debug.sethook(function () end, \"l\")\n  for j=1,1000 do\n    g(i+j)\n  end\nend\n\nlocal co = coroutine.wrap(f)\nco(10)\npcall(co)\npcall(co)\n\n\nassert(type(debug.getregistry()) == \"table\")\n\n\n-- test tagmethod information\nlocal a = {}\nlocal function f (t)\n  local info = debug.getinfo(1);\n  assert(info.namewhat == \"metamethod\")\n  a.op = info.name\n  return info.name\nend\nsetmetatable(a, {\n  __index = f; __add = f; __div = f; __mod = f; __concat = f; __pow = f;\n  __mul = f; __idiv = f; __unm = f; __len = f; __sub = f;\n  __shl = f; __shr = f; __bor = f; __bxor = f;\n  __eq = f; __le = f; __lt = f; __unm = f; __len = f; __band = f;\n  __bnot = f;\n})\n\nlocal b = setmetatable({}, getmetatable(a))\n\nassert(a[3] == \"index\" and a^3 == \"pow\" and a..a == \"concat\")\nassert(a/3 == \"div\" and 3%a == \"mod\")\nassert(a+3 == \"add\" and 3-a == \"sub\" and a*3 == \"mul\" and\n       -a == \"unm\" and #a == \"len\" and a&3 == \"band\")\nassert(a + 30000 == \"add\" and a - 3.0 == \"sub\" and a * 3.0 == \"mul\" and\n       -a == \"unm\" and #a == \"len\" and a & 3 == \"band\")\nassert(a|3 == \"bor\" and 3~a == \"bxor\" and a<<3 == \"shl\" and a>>1 == \"shr\")\nassert (a==b and a.op == \"eq\")\nassert (a>=b and a.op == \"order\")\nassert (a>b and a.op == \"order\")\nassert(~a == \"bnot\")\n\ndo   -- testing for-iterator name\n  local function f()\n    assert(debug.getinfo(1).name == \"for iterator\")\n  end\n\n  for i in f do end\nend\n\n\ndo   -- testing debug info for finalizers\n  local name = nil\n\n  -- create a piece of garbage with a finalizer\n  setmetatable({}, {__gc = function ()\n    local t = debug.getinfo(2)   -- get callee information\n    assert(t.namewhat == \"metamethod\")\n    name = t.name\n  end})\n\n  -- repeat until previous finalizer runs (setting 'name')\n  repeat local a = {} until name\n  assert(name == \"__gc\")\nend\n\n\ndo\n  print(\"testing traceback sizes\")\n\n  local function countlines (s)\n    return select(2, string.gsub(s, \"\\n\", \"\"))\n  end\n\n  local function deep (lvl, n)\n    if lvl == 0 then\n      return (debug.traceback(\"message\", n))\n    else\n      return (deep(lvl-1, n))\n    end\n  end\n\n  local function checkdeep (total, start)\n    local s = deep(total, start)\n    local rest = string.match(s, \"^message\\nstack traceback:\\n(.*)$\")\n    local cl = countlines(rest)\n    -- at most 10 lines in first part, 11 in second, plus '...'\n    assert(cl <= 10 + 11 + 1)\n    local brk = string.find(rest, \"%.%.%.\")\n    if brk then   -- does message have '...'?\n      local rest1 = string.sub(rest, 1, brk)\n      local rest2 = string.sub(rest, brk, #rest)\n      assert(countlines(rest1) == 10 and countlines(rest2) == 11)\n    else\n      assert(cl == total - start + 2)\n    end\n  end\n\n  for d = 1, 51, 10 do\n    for l = 1, d do\n      -- use coroutines to ensure complete control of the stack\n      coroutine.wrap(checkdeep)(d, l)\n    end\n  end\n\nend\n\n\nprint(\"testing debug functions on chunk without debug info\")\nprog = [[-- program to be loaded without debug information\nlocal debug = require'debug'\nlocal a = 12  -- a local variable\n\nlocal n, v = debug.getlocal(1, 1)\nassert(n == \"(temporary)\" and v == debug)   -- unkown name but known value\nn, v = debug.getlocal(1, 2)\nassert(n == \"(temporary)\" and v == 12)   -- unkown name but known value\n\n-- a function with an upvalue\nlocal f = function () local x; return a end\nn, v = debug.getupvalue(f, 1)\nassert(n == \"(no name)\" and v == 12)\nassert(debug.setupvalue(f, 1, 13) == \"(no name)\")\nassert(a == 13)\n\nlocal t = debug.getinfo(f)\nassert(t.name == nil and t.linedefined > 0 and\n       t.lastlinedefined == t.linedefined and\n       t.short_src == \"?\")\nassert(debug.getinfo(1).currentline == -1)\n\nt = debug.getinfo(f, \"L\").activelines\nassert(next(t) == nil)    -- active lines are empty\n\n-- dump/load a function without debug info\nf = load(string.dump(f))\n\nt = debug.getinfo(f)\nassert(t.name == nil and t.linedefined > 0 and\n       t.lastlinedefined == t.linedefined and\n       t.short_src == \"?\")\nassert(debug.getinfo(1).currentline == -1)\n\nreturn a\n]]\n\n\n-- load 'prog' without debug info\nlocal f = assert(load(string.dump(load(prog), true)))\n\nassert(f() == 13)\n\ndo   -- tests for 'source' in binary dumps\n  local prog = [[\n    return function (x)\n      return function (y) \n        return x + y\n      end\n    end\n  ]]\n  local name = string.rep(\"x\", 1000)\n  local p = assert(load(prog, name))\n  -- load 'p' as a binary chunk with debug information\n  local c = string.dump(p)\n  assert(#c > 1000 and #c < 2000)   -- no repetition of 'source' in dump\n  local f = assert(load(c))\n  local g = f()\n  local h = g(3)\n  assert(h(5) == 8)\n  assert(debug.getinfo(f).source == name and   -- all functions have 'source'\n         debug.getinfo(g).source == name and \n         debug.getinfo(h).source == name)\n  -- again, without debug info\n  local c = string.dump(p, true)\n  assert(#c < 500)   -- no 'source' in dump\n  local f = assert(load(c))\n  local g = f()\n  local h = g(30)\n  assert(h(50) == 80)\n  assert(debug.getinfo(f).source == '=?' and   -- no function has 'source'\n         debug.getinfo(g).source == '=?' and \n         debug.getinfo(h).source == '=?')\nend\n\nprint\"OK\"\n\n"], "fixing_code": ["/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define noLuaClosure(f)\t\t((f) == NULL || (f)->c.tt == LUA_VCCL)\n\n/* inverse of 'pcRel' */\n#define invpcRel(pc, p)\t\t((p)->code + (pc) + 1)\n\nstatic const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                    const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** For that, search the array of absolute line info for the largest saved\n** instruction smaller or equal to the wanted instruction. A special\n** case is when there is no absolute info or the instruction is before\n** the first absolute one.\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    unsigned int i;\n    if (pc >= f->abslineinfo[f->sizeabslineinfo - 1].pc)\n      i = f->sizeabslineinfo - 1;  /* instruction is after last saved one */\n    else {  /* binary search */\n      unsigned int j = f->sizeabslineinfo - 1;  /* pc < anchorlines[j] */\n      i = 0;  /* abslineinfo[i] <= pc */\n      while (i < j - 1) {\n        unsigned int m = (j + i) / 2;\n        if (pc >= f->abslineinfo[m].pc)\n          i = m;\n        else\n          j = m;\n      }\n    }\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    setobjs2s(L, pos, L->top - 1);\n    L->top--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (noLuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getstr(p->source);\n      ar->srclen = tsslen(p->source);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (noLuaClosure(f)) {\n    setnilvalue(s2v(L->top));\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    TValue v;\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top, t);  /* push it on stack */\n    api_incr_top(L);\n    setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n    for (i = 0; i < p->sizelineinfo; i++) {  /* for all lines with code */\n      currentline = nextline(p, currentline, i);\n      luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  if (ci == NULL)  /* no 'ci'? */\n    return NULL;  /* no info */\n  else if (ci->callstatus & CIST_FIN) {  /* is this a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  /* calling function is a known Lua function? */\n  else if (!(ci->callstatus & CIST_TAIL) && isLua(ci->previous))\n    return funcnamefromcode(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (noLuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = f->l.p->is_vararg;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        ar->istailcall = (ci) ? ci->callstatus & CIST_TAIL : 0;\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_TRAN))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = ci->u2.transferinfo.ftransfer;\n          ar->ntransfer = ci->u2.transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name);\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic void kname (const Proto *p, int c, const char **name) {\n  TValue *kvalue = &p->k[c];\n  *name = (ttisstring(kvalue)) ? svalue(kvalue) : \"?\";\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = getobjname(p, pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *gxf (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is an upvalue? */\n    name = upvalname(p, t);\n  else\n    getobjname(p, pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  int pc;\n  *name = luaF_getlocalname(p, reg + 1, lastpc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  pc = findsetreg(p, lastpc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return getobjname(p, pc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, pc, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return gxf(p, pc, i, 0);\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK:\n      case OP_LOADKX: {\n        int b = (op == OP_LOADK) ? GETARG_Bx(i)\n                                 : GETARG_Ax(p->code[pc + 1]);\n        if (ttisstring(&p->k[b])) {\n          *name = svalue(&p->k[b]);\n          return \"constant\";\n        }\n        break;\n      }\n      case OP_SELF: {\n        rkname(p, pc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, CallInfo *ci,\n                                     const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  const Proto *p = ci_func(ci)->p;  /* calling function */\n  int pc = currentpc(ci);  /* calling instruction index */\n  Instruction i = p->code[pc];  /* calling instruction */\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    case OP_LT: case OP_LE: case OP_LTI: case OP_LEI:\n      *name = \"order\";  /* '<=' can call '__lt', etc. */\n      return \"metamethod\";\n    case OP_CLOSE: case OP_RETURN:\n      *name = \"close\";\n      return \"metamethod\";\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n/* }====================================================== */\n\n\n\n/*\n** The subtraction of two potentially unrelated pointers is\n** not ISO C, but it should not crash a program; the subsequent\n** checks are ISO C and ensure a correct result.\n*/\nstatic int isinstack (CallInfo *ci, const TValue *o) {\n  StkId base = ci->func + 1;\n  ptrdiff_t i = cast(StkId, o) - base;\n  return (0 <= i && i < (ci->top - base) && s2v(base + i) == o);\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  const char *name = NULL;  /* to avoid warnings */\n  CallInfo *ci = L->ci;\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind && isinstack(ci, o))  /* no? try a register */\n      kind = getobjname(ci_func(ci)->p, currentpc(ci),\n                        cast_int(cast(StkId, o) - (ci->func + 1)), &name);\n  }\n  return (kind) ? luaO_pushfstring(L, \" (%s '%s')\", kind, name) : \"\";\n}\n\n\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, varinfo(L, o));\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!tointegerns(p1, &temp))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src)\n    luaO_chunkid(buff, getstr(src), tsslen(src));\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top, L->top - 1);  /* move argument */\n    setobjs2s(L, L->top - 1, errfunc);  /* push function */\n    L->top++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (isLua(ci))  /* if Lua function, add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  /* no line changes between positions */\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line without\n** the need for 'oldpc'; so, 'oldpc' does not need to be initialized\n** before. Some exceptional conditions may return to a function without\n** updating 'oldpc'. In that case, 'oldpc' may be invalid; if so, it is\n** reset to zero.  (A wrong but valid 'oldpc' at most causes an extra\n** call to a line hook.)\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  /* 'L->oldpc' may be invalid; reset it in this case */\n  int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* called hook last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  /* prepare top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  /* call linehook when enter a new function, */\n        pc <= invpcRel(oldpc, p) ||  /* when jump back (loop), or when */\n        changedline(p, oldpc, npci)) {  /* enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->u.l.savedpc--;  /* undo increment (resume will increment it again) */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n", "-- $Id: testes/db.lua $\n-- See Copyright Notice in file all.lua\n\n-- testing debug library\n\nlocal debug = require \"debug\"\n\nlocal function dostring(s) return assert(load(s))() end\n\nprint\"testing debug library and debug information\"\n\ndo\nlocal a=1\nend\n\nassert(not debug.gethook())\n\nlocal testline = 19         -- line where 'test' is defined\nfunction test (s, l, p)     -- this must be line 19\n  collectgarbage()   -- avoid gc during trace\n  local function f (event, line)\n    assert(event == 'line')\n    local l = table.remove(l, 1)\n    if p then print(l, line) end\n    assert(l == line, \"wrong trace!!\")\n  end\n  debug.sethook(f,\"l\"); load(s)(); debug.sethook()\n  assert(#l == 0)\nend\n\n\ndo\n  assert(not pcall(debug.getinfo, print, \"X\"))   -- invalid option\n  assert(not debug.getinfo(1000))   -- out of range level\n  assert(not debug.getinfo(-1))     -- out of range level\n  local a = debug.getinfo(print)\n  assert(a.what == \"C\" and a.short_src == \"[C]\")\n  a = debug.getinfo(print, \"L\")\n  assert(a.activelines == nil)\n  local b = debug.getinfo(test, \"SfL\")\n  assert(b.name == nil and b.what == \"Lua\" and b.linedefined == testline and\n         b.lastlinedefined == b.linedefined + 10 and\n         b.func == test and not string.find(b.short_src, \"%[\"))\n  assert(b.activelines[b.linedefined + 1] and\n         b.activelines[b.lastlinedefined])\n  assert(not b.activelines[b.linedefined] and\n         not b.activelines[b.lastlinedefined + 1])\nend\n\n\n-- test file and string names truncation\na = \"function f () end\"\nlocal function dostring (s, x) return load(s, x)() end\ndostring(a)\nassert(debug.getinfo(f).short_src == string.format('[string \"%s\"]', a))\ndostring(a..string.format(\"; %s\\n=1\", string.rep('p', 400)))\nassert(string.find(debug.getinfo(f).short_src, '^%[string [^\\n]*%.%.%.\"%]$'))\ndostring(a..string.format(\"; %s=1\", string.rep('p', 400)))\nassert(string.find(debug.getinfo(f).short_src, '^%[string [^\\n]*%.%.%.\"%]$'))\ndostring(\"\\n\"..a)\nassert(debug.getinfo(f).short_src == '[string \"...\"]')\ndostring(a, \"\")\nassert(debug.getinfo(f).short_src == '[string \"\"]')\ndostring(a, \"@xuxu\")\nassert(debug.getinfo(f).short_src == \"xuxu\")\ndostring(a, \"@\"..string.rep('p', 1000)..'t')\nassert(string.find(debug.getinfo(f).short_src, \"^%.%.%.p*t$\"))\ndostring(a, \"=xuxu\")\nassert(debug.getinfo(f).short_src == \"xuxu\")\ndostring(a, string.format(\"=%s\", string.rep('x', 500)))\nassert(string.find(debug.getinfo(f).short_src, \"^x*$\"))\ndostring(a, \"=\")\nassert(debug.getinfo(f).short_src == \"\")\na = nil; f = nil;\n\n\nrepeat\n  local g = {x = function ()\n    local a = debug.getinfo(2)\n    assert(a.name == 'f' and a.namewhat == 'local')\n    a = debug.getinfo(1)\n    assert(a.name == 'x' and a.namewhat == 'field')\n    return 'xixi'\n  end}\n  local f = function () return 1+1 and (not 1 or g.x()) end\n  assert(f() == 'xixi')\n  g = debug.getinfo(f)\n  assert(g.what == \"Lua\" and g.func == f and g.namewhat == \"\" and not g.name)\n\n  function f (x, name)   -- local!\n    name = name or 'f'\n    local a = debug.getinfo(1)\n    assert(a.name == name and a.namewhat == 'local')\n    return x\n  end\n\n  -- breaks in different conditions\n  if 3>4 then break end; f()\n  if 3<4 then a=1 else break end; f()\n  while 1 do local x=10; break end; f()\n  local b = 1\n  if 3>4 then return math.sin(1) end; f()\n  a = 3<4; f()\n  a = 3<4 or 1; f()\n  repeat local x=20; if 4>3 then f() else break end; f() until 1\n  g = {}\n  f(g).x = f(2) and f(10)+f(9)\n  assert(g.x == f(19))\n  function g(x) if not x then return 3 end return (x('a', 'x')) end\n  assert(g(f) == 'a')\nuntil 1\n\ntest([[if\nmath.sin(1)\nthen\n  a=1\nelse\n  a=2\nend\n]], {2,3,4,7})\n\ntest([[--\nif nil then\n  a=1\nelse\n  a=2\nend\n]], {2,5,6})\n\ntest([[a=1\nrepeat\n  a=a+1\nuntil a==3\n]], {1,3,4,3,4})\n\ntest([[ do\n  return\nend\n]], {2})\n\ntest([[local a\na=1\nwhile a<=3 do\n  a=a+1\nend\n]], {1,2,3,4,3,4,3,4,3,5})\n\ntest([[while math.sin(1) do\n  if math.sin(1)\n  then break\n  end\nend\na=1]], {1,2,3,6})\n\ntest([[for i=1,3 do\n  a=i\nend\n]], {1,2,1,2,1,2,1,3})\n\ntest([[for i,v in pairs{'a','b'} do\n  a=tostring(i) .. v\nend\n]], {1,2,1,2,1,3})\n\ntest([[for i=1,4 do a=1 end]], {1,1,1,1})\n\n\ndo   -- testing line info/trace with large gaps in source\n\n  local a = {1, 2, 3, 10, 124, 125, 126, 127, 128, 129, 130,\n             255, 256, 257, 500, 1000}\n  local s = [[\n     local b = {10}\n     a = b[1] X + Y b[1]\n     b = 4\n  ]]\n  for _, i in ipairs(a) do\n    local subs = {X = string.rep(\"\\n\", i)}\n    for _, j in ipairs(a) do\n      subs.Y = string.rep(\"\\n\", j)\n      local s = string.gsub(s, \"[XY]\", subs)\n      test(s, {1, 2 + i, 2 + i + j, 2 + i, 2 + i + j, 3 + i + j})\n    end\n  end\nend\n\nprint'+'\n\n-- invalid levels in [gs]etlocal\nassert(not pcall(debug.getlocal, 20, 1))\nassert(not pcall(debug.setlocal, -1, 1, 10))\n\n\n-- parameter names\nlocal function foo (a,b,...) local d, e end\nlocal co = coroutine.create(foo)\n\nassert(debug.getlocal(foo, 1) == 'a')\nassert(debug.getlocal(foo, 2) == 'b')\nassert(not debug.getlocal(foo, 3))\nassert(debug.getlocal(co, foo, 1) == 'a')\nassert(debug.getlocal(co, foo, 2) == 'b')\nassert(not debug.getlocal(co, foo, 3))\n\nassert(not debug.getlocal(print, 1))\n\n\nlocal function foo () return (debug.getlocal(1, -1)) end\nassert(not foo(10))\n\n\n-- varargs\nlocal function foo (a, ...)\n  local t = table.pack(...)\n  for i = 1, t.n do\n    local n, v = debug.getlocal(1, -i)\n    assert(n == \"(vararg)\" and v == t[i])\n  end\n  assert(not debug.getlocal(1, -(t.n + 1)))\n  assert(not debug.setlocal(1, -(t.n + 1), 30))\n  if t.n > 0 then\n    (function (x)\n      assert(debug.setlocal(2, -1, x) == \"(vararg)\")\n      assert(debug.setlocal(2, -t.n, x) == \"(vararg)\")\n     end)(430)\n     assert(... == 430)\n  end\nend\n\nfoo()\nfoo(print)\nfoo(200, 3, 4)\nlocal a = {}\nfor i = 1, (_soft and 100 or 1000) do a[i] = i end\nfoo(table.unpack(a))\na = nil\n\n\n\ndo   -- test hook presence in debug info\n  assert(not debug.gethook())\n  local count = 0\n  local function f ()\n    assert(debug.getinfo(1).namewhat == \"hook\")\n    local sndline = string.match(debug.traceback(), \"\\n(.-)\\n\")\n    assert(string.find(sndline, \"hook\"))\n    count = count + 1\n  end\n  debug.sethook(f, \"l\")\n  local a = 0\n  _ENV.a = a\n  a = 1\n  debug.sethook()\n  assert(count == 4)\nend\n\n\n-- hook table has weak keys\nassert(getmetatable(debug.getregistry()._HOOKKEY).__mode == 'k')\n\n\na = {}; L = nil\nlocal glob = 1\nlocal oldglob = glob\ndebug.sethook(function (e,l)\n  collectgarbage()   -- force GC during a hook\n  local f, m, c = debug.gethook()\n  assert(m == 'crl' and c == 0)\n  if e == \"line\" then\n    if glob ~= oldglob then\n      L = l-1   -- get the first line where \"glob\" has changed\n      oldglob = glob\n    end\n  elseif e == \"call\" then\n      local f = debug.getinfo(2, \"f\").func\n      a[f] = 1\n  else assert(e == \"return\")\n  end\nend, \"crl\")\n\n\nfunction f(a,b)\n  collectgarbage()\n  local _, x = debug.getlocal(1, 1)\n  local _, y = debug.getlocal(1, 2)\n  assert(x == a and y == b)\n  assert(debug.setlocal(2, 3, \"pera\") == \"AA\"..\"AA\")\n  assert(debug.setlocal(2, 4, \"ma\ufffd\ufffd\") == \"B\")\n  x = debug.getinfo(2)\n  assert(x.func == g and x.what == \"Lua\" and x.name == 'g' and\n         x.nups == 2 and string.find(x.source, \"^@.*db%.lua$\"))\n  glob = glob+1\n  assert(debug.getinfo(1, \"l\").currentline == L+1)\n  assert(debug.getinfo(1, \"l\").currentline == L+2)\nend\n\nfunction foo()\n  glob = glob+1\n  assert(debug.getinfo(1, \"l\").currentline == L+1)\nend; foo()  -- set L\n-- check line counting inside strings and empty lines\n\n_ = 'alo\\\nalo' .. [[\n\n]]\n--[[\n]]\nassert(debug.getinfo(1, \"l\").currentline == L+11)  -- check count of lines\n\n\nfunction g (...)\n  local arg = {...}\n  do local a,b,c; a=math.sin(40); end\n  local feijao\n  local AAAA,B = \"xuxu\", \"mam\ufffdo\"\n  f(AAAA,B)\n  assert(AAAA == \"pera\" and B == \"ma\ufffd\ufffd\")\n  do\n     local B = 13\n     local x,y = debug.getlocal(1,5)\n     assert(x == 'B' and y == 13)\n  end\nend\n\ng()\n\n\nassert(a[f] and a[g] and a[assert] and a[debug.getlocal] and not a[print])\n\n\n-- tests for manipulating non-registered locals (C and Lua temporaries)\n\nlocal n, v = debug.getlocal(0, 1)\nassert(v == 0 and n == \"(C temporary)\")\nlocal n, v = debug.getlocal(0, 2)\nassert(v == 2 and n == \"(C temporary)\")\nassert(not debug.getlocal(0, 3))\nassert(not debug.getlocal(0, 0))\n\nfunction f()\n  assert(select(2, debug.getlocal(2,3)) == 1)\n  assert(not debug.getlocal(2,4))\n  debug.setlocal(2, 3, 10)\n  return 20\nend\n\nfunction g(a,b) return (a+1) + f() end\n\nassert(g(0,0) == 30)\n \n\ndebug.sethook(nil);\nassert(not debug.gethook())\n\n\n-- minimal tests for setuservalue/getuservalue\ndo\n  assert(not debug.setuservalue(io.stdin, 10))\n  local a, b = debug.getuservalue(io.stdin, 10)\n  assert(a == nil and not b)\nend\n\n-- testing iteraction between multiple values x hooks\ndo\n  local function f(...) return 3, ... end\n  local count = 0\n  local a = {}\n  for i = 1, 100 do a[i] = i end\n  debug.sethook(function () count = count + 1 end, \"\", 1)\n  local t = {table.unpack(a)}\n  assert(#t == 100)\n  t = {table.unpack(a, 1, 3)}\n  assert(#t == 3)\n  t = {f(table.unpack(a, 1, 30))}\n  assert(#t == 31)\nend\n\n\n-- testing access to function arguments\n\nlocal function collectlocals (level)\n  local tab = {}\n  for i = 1, math.huge do\n    local n, v = debug.getlocal(level + 1, i)\n    if not (n and string.find(n, \"^[a-zA-Z0-9_]+$\")) then\n       break   -- consider only real variables\n    end\n    tab[n] = v\n  end\n  return tab\nend\n\n\nX = nil\na = {}\nfunction a:f (a, b, ...) local arg = {...}; local c = 13 end\ndebug.sethook(function (e)\n  assert(e == \"call\")\n  dostring(\"XX = 12\")  -- test dostring inside hooks\n  -- testing errors inside hooks\n  assert(not pcall(load(\"a='joao'+1\")))\n  debug.sethook(function (e, l) \n    assert(debug.getinfo(2, \"l\").currentline == l)\n    local f,m,c = debug.gethook()\n    assert(e == \"line\")\n    assert(m == 'l' and c == 0)\n    debug.sethook(nil)  -- hook is called only once\n    assert(not X)       -- check that\n    X = collectlocals(2)\n  end, \"l\")\nend, \"c\")\n\na:f(1,2,3,4,5)\nassert(X.self == a and X.a == 1   and X.b == 2 and X.c == nil)\nassert(XX == 12)\nassert(not debug.gethook())\n\n\n-- testing access to local variables in return hook (bug in 5.2)\ndo\n  local X = false\n\n  local function foo (a, b, ...)\n    do local x,y,z end\n    local c, d = 10, 20\n    return\n  end\n\n  local function aux ()\n    if debug.getinfo(2).name == \"foo\" then\n      X = true   -- to signal that it found 'foo'\n      local tab = {a = 100, b = 200, c = 10, d = 20}\n      for n, v in pairs(collectlocals(2)) do\n        assert(tab[n] == v)\n        tab[n] = undef\n      end\n      assert(next(tab) == nil)    -- 'tab' must be empty\n    end\n  end\n\n  debug.sethook(aux, \"r\"); foo(100, 200); debug.sethook()\n  assert(X)\n\nend\n\n\nlocal function eqseq (t1, t2)\n  assert(#t1 == #t2)\n  for i = 1, #t1 do\n    assert(t1[i] == t2[i])\n  end\nend\n\n\ndo  print(\"testing inspection of parameters/returned values\")\n  local on = false\n  local inp, out\n\n  local function hook (event)\n    if not on then return end\n    local ar = debug.getinfo(2, \"ruS\")\n    local t = {}\n    for i = ar.ftransfer, ar.ftransfer + ar.ntransfer - 1 do\n      local _, v = debug.getlocal(2, i)\n      t[#t + 1] = v \n    end\n    if event == \"return\" then\n      out = t\n    else\n      inp = t\n    end\n  end\n\n  debug.sethook(hook, \"cr\")\n\n  on = true; math.sin(3); on = false\n  eqseq(inp, {3}); eqseq(out, {math.sin(3)})\n\n  on = true; select(2, 10, 20, 30, 40); on = false\n  eqseq(inp, {2, 10, 20, 30, 40}); eqseq(out, {20, 30, 40})\n\n  local function foo (a, ...) return ... end\n  local function foo1 () on = not on; return foo(20, 10, 0) end\n  foo1(); on = false\n  eqseq(inp, {20}); eqseq(out, {10, 0})\n\n  debug.sethook()\nend\n\n\n\n-- testing upvalue access\nlocal function getupvalues (f)\n  local t = {}\n  local i = 1\n  while true do\n    local name, value = debug.getupvalue(f, i)\n    if not name then break end\n    assert(not t[name])\n    t[name] = value\n    i = i + 1\n  end\n  return t\nend\n\nlocal a,b,c = 1,2,3\nlocal function foo1 (a) b = a; return c end\nlocal function foo2 (x) a = x; return c+b end\nassert(not debug.getupvalue(foo1, 3))\nassert(not debug.getupvalue(foo1, 0))\nassert(not debug.setupvalue(foo1, 3, \"xuxu\"))\nlocal t = getupvalues(foo1)\nassert(t.a == nil and t.b == 2 and t.c == 3)\nt = getupvalues(foo2)\nassert(t.a == 1 and t.b == 2 and t.c == 3)\nassert(debug.setupvalue(foo1, 1, \"xuxu\") == \"b\")\nassert(({debug.getupvalue(foo2, 3)})[2] == \"xuxu\")\n-- upvalues of C functions are allways \"called\" \"\" (the empty string)\nassert(debug.getupvalue(string.gmatch(\"x\", \"x\"), 1) == \"\")  \n\n\n-- testing count hooks\nlocal a=0\ndebug.sethook(function (e) a=a+1 end, \"\", 1)\na=0; for i=1,1000 do end; assert(1000 < a and a < 1012)\ndebug.sethook(function (e) a=a+1 end, \"\", 4)\na=0; for i=1,1000 do end; assert(250 < a and a < 255)\nlocal f,m,c = debug.gethook()\nassert(m == \"\" and c == 4)\ndebug.sethook(function (e) a=a+1 end, \"\", 4000)\na=0; for i=1,1000 do end; assert(a == 0)\n\ndo\n  debug.sethook(print, \"\", 2^24 - 1)   -- count upperbound\n  local f,m,c = debug.gethook()\n  assert(({debug.gethook()})[3] == 2^24 - 1)\nend\n\ndebug.sethook()\n\n\n-- tests for tail calls\nlocal function f (x)\n  if x then\n    assert(debug.getinfo(1, \"S\").what == \"Lua\")\n    assert(debug.getinfo(1, \"t\").istailcall == true)\n    local tail = debug.getinfo(2)\n    assert(tail.func == g1 and tail.istailcall == true)\n    assert(debug.getinfo(3, \"S\").what == \"main\")\n    print\"+\"\n    end\nend\n\nfunction g(x) return f(x) end\n\nfunction g1(x) g(x) end\n\nlocal function h (x) local f=g1; return f(x) end\n\nh(true)\n\nlocal b = {}\ndebug.sethook(function (e) table.insert(b, e) end, \"cr\")\nh(false)\ndebug.sethook()\nlocal res = {\"return\",   -- first return (from sethook)\n  \"call\", \"tail call\", \"call\", \"tail call\",\n  \"return\", \"return\",\n  \"call\",    -- last call (to sethook)\n}\nfor i = 1, #res do assert(res[i] == table.remove(b, 1)) end\n\nb = 0\ndebug.sethook(function (e)\n                if e == \"tail call\" then\n                  b = b + 1\n                  assert(debug.getinfo(2, \"t\").istailcall == true)\n                else\n                  assert(debug.getinfo(2, \"t\").istailcall == false)\n                end\n              end, \"c\")\nh(false)\ndebug.sethook()\nassert(b == 2)   -- two tail calls\n\nlim = _soft and 3000 or 30000\nlocal function foo (x)\n  if x==0 then\n    assert(debug.getinfo(2).what == \"main\")\n    local info = debug.getinfo(1)\n    assert(info.istailcall == true and info.func == foo)\n  else return foo(x-1)\n  end\nend\n\nfoo(lim)\n\n\nprint\"+\"\n\n\n-- testing local function information\nco = load[[\n  local A = function ()\n    return x\n  end\n  return\n]]\n\nlocal a = 0\n-- 'A' should be visible to debugger only after its complete definition\ndebug.sethook(function (e, l)\n  if l == 3 then a = a + 1; assert(debug.getlocal(2, 1) == \"(temporary)\")\n  elseif l == 4 then a = a + 1; assert(debug.getlocal(2, 1) == \"A\")\n  end\nend, \"l\")\nco()  -- run local function definition\ndebug.sethook()  -- turn off hook\nassert(a == 2)   -- ensure all two lines where hooked\n\n-- testing traceback\n\nassert(debug.traceback(print) == print)\nassert(debug.traceback(print, 4) == print)\nassert(string.find(debug.traceback(\"hi\", 4), \"^hi\\n\"))\nassert(string.find(debug.traceback(\"hi\"), \"^hi\\n\"))\nassert(not string.find(debug.traceback(\"hi\"), \"'debug.traceback'\"))\nassert(string.find(debug.traceback(\"hi\", 0), \"'debug.traceback'\"))\nassert(string.find(debug.traceback(), \"^stack traceback:\\n\"))\n\ndo  -- C-function names in traceback\n  local st, msg = (function () return pcall end)()(debug.traceback)\n  assert(st == true and string.find(msg, \"pcall\"))\nend\n\n\n-- testing nparams, nups e isvararg\nlocal t = debug.getinfo(print, \"u\")\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 0)\n\nt = debug.getinfo(function (a,b,c) end, \"u\")\nassert(t.isvararg == false and t.nparams == 3 and t.nups == 0)\n\nt = debug.getinfo(function (a,b,...) return t[a] end, \"u\")\nassert(t.isvararg == true and t.nparams == 2 and t.nups == 1)\n\nt = debug.getinfo(1)   -- main\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 1 and\n       debug.getupvalue(t.func, 1) == \"_ENV\")\n\nt = debug.getinfo(math.sin)   -- C function\nassert(t.isvararg == true and t.nparams == 0 and t.nups == 0)\n\nt = debug.getinfo(string.gmatch(\"abc\", \"a\"))   -- C closure\nassert(t.isvararg == true and t.nparams == 0 and t.nups > 0)\n\n\n\n-- testing debugging of coroutines\n\nlocal function checktraceback (co, p, level)\n  local tb = debug.traceback(co, nil, level)\n  local i = 0\n  for l in string.gmatch(tb, \"[^\\n]+\\n?\") do\n    assert(i == 0 or string.find(l, p[i]))\n    i = i+1\n  end\n  assert(p[i] == undef)\nend\n\n\nlocal function f (n)\n  if n > 0 then f(n-1)\n  else coroutine.yield() end\nend\n\nlocal co = coroutine.create(f)\ncoroutine.resume(co, 3)\nchecktraceback(co, {\"yield\", \"db.lua\", \"db.lua\", \"db.lua\", \"db.lua\"})\nchecktraceback(co, {\"db.lua\", \"db.lua\", \"db.lua\", \"db.lua\"}, 1)\nchecktraceback(co, {\"db.lua\", \"db.lua\", \"db.lua\"}, 2)\nchecktraceback(co, {\"db.lua\"}, 4)\nchecktraceback(co, {}, 40)\n\n\nco = coroutine.create(function (x)\n       local a = 1\n       coroutine.yield(debug.getinfo(1, \"l\"))\n       coroutine.yield(debug.getinfo(1, \"l\").currentline)\n       return a\n     end)\n\nlocal tr = {}\nlocal foo = function (e, l) if l then table.insert(tr, l) end end\ndebug.sethook(co, foo, \"lcr\")\n\nlocal _, l = coroutine.resume(co, 10)\nlocal x = debug.getinfo(co, 1, \"lfLS\")\nassert(x.currentline == l.currentline and x.activelines[x.currentline])\nassert(type(x.func) == \"function\")\nfor i=x.linedefined + 1, x.lastlinedefined do\n  assert(x.activelines[i])\n  x.activelines[i] = undef\nend\nassert(next(x.activelines) == nil)   -- no 'extra' elements\nassert(not debug.getinfo(co, 2))\nlocal a,b = debug.getlocal(co, 1, 1)\nassert(a == \"x\" and b == 10)\na,b = debug.getlocal(co, 1, 2)\nassert(a == \"a\" and b == 1)\ndebug.setlocal(co, 1, 2, \"hi\")\nassert(debug.gethook(co) == foo)\nassert(#tr == 2 and\n       tr[1] == l.currentline-1 and tr[2] == l.currentline)\n\na,b,c = pcall(coroutine.resume, co)\nassert(a and b and c == l.currentline+1)\nchecktraceback(co, {\"yield\", \"in function <\"})\n\na,b = coroutine.resume(co)\nassert(a and b == \"hi\")\nassert(#tr == 4 and tr[4] == l.currentline+2)\nassert(debug.gethook(co) == foo)\nassert(not debug.gethook())\nchecktraceback(co, {})\n\n\n-- check get/setlocal in coroutines\nco = coroutine.create(function (x)\n  local a, b = coroutine.yield(x)\n  assert(a == 100 and b == nil)\n  return x\nend)\na, b = coroutine.resume(co, 10)\nassert(a and b == 10)\na, b = debug.getlocal(co, 1, 1)\nassert(a == \"x\" and b == 10)\nassert(not debug.getlocal(co, 1, 5))\nassert(debug.setlocal(co, 1, 1, 30) == \"x\")\nassert(not debug.setlocal(co, 1, 5, 40))\na, b = coroutine.resume(co, 100)\nassert(a and b == 30)\n\n\n-- check traceback of suspended (or dead with error) coroutines\n\nfunction f(i)\n  if i == 0 then error(i)\n  else coroutine.yield(); f(i-1)\n  end\nend\n\n\nco = coroutine.create(function (x) f(x) end)\na, b = coroutine.resume(co, 3)\nt = {\"'coroutine.yield'\", \"'f'\", \"in function <\"}\nwhile coroutine.status(co) == \"suspended\" do\n  checktraceback(co, t)\n  a, b = coroutine.resume(co)\n  table.insert(t, 2, \"'f'\")   -- one more recursive call to 'f'\nend\nt[1] = \"'error'\"\nchecktraceback(co, t)\n\n\n-- test acessing line numbers of a coroutine from a resume inside\n-- a C function (this is a known bug in Lua 5.0)\n\nlocal function g(x)\n    coroutine.yield(x)\nend\n\nlocal function f (i)\n  debug.sethook(function () end, \"l\")\n  for j=1,1000 do\n    g(i+j)\n  end\nend\n\nlocal co = coroutine.wrap(f)\nco(10)\npcall(co)\npcall(co)\n\n\nassert(type(debug.getregistry()) == \"table\")\n\n\n-- test tagmethod information\nlocal a = {}\nlocal function f (t)\n  local info = debug.getinfo(1);\n  assert(info.namewhat == \"metamethod\")\n  a.op = info.name\n  return info.name\nend\nsetmetatable(a, {\n  __index = f; __add = f; __div = f; __mod = f; __concat = f; __pow = f;\n  __mul = f; __idiv = f; __unm = f; __len = f; __sub = f;\n  __shl = f; __shr = f; __bor = f; __bxor = f;\n  __eq = f; __le = f; __lt = f; __unm = f; __len = f; __band = f;\n  __bnot = f;\n})\n\nlocal b = setmetatable({}, getmetatable(a))\n\nassert(a[3] == \"index\" and a^3 == \"pow\" and a..a == \"concat\")\nassert(a/3 == \"div\" and 3%a == \"mod\")\nassert(a+3 == \"add\" and 3-a == \"sub\" and a*3 == \"mul\" and\n       -a == \"unm\" and #a == \"len\" and a&3 == \"band\")\nassert(a + 30000 == \"add\" and a - 3.0 == \"sub\" and a * 3.0 == \"mul\" and\n       -a == \"unm\" and #a == \"len\" and a & 3 == \"band\")\nassert(a|3 == \"bor\" and 3~a == \"bxor\" and a<<3 == \"shl\" and a>>1 == \"shr\")\nassert (a==b and a.op == \"eq\")\nassert (a>=b and a.op == \"order\")\nassert (a>b and a.op == \"order\")\nassert(~a == \"bnot\")\n\ndo   -- testing for-iterator name\n  local function f()\n    assert(debug.getinfo(1).name == \"for iterator\")\n  end\n\n  for i in f do end\nend\n\n\ndo   -- testing debug info for finalizers\n  local name = nil\n\n  -- create a piece of garbage with a finalizer\n  setmetatable({}, {__gc = function ()\n    local t = debug.getinfo(2)   -- get callee information\n    assert(t.namewhat == \"metamethod\")\n    name = t.name\n  end})\n\n  -- repeat until previous finalizer runs (setting 'name')\n  repeat local a = {} until name\n  assert(name == \"__gc\")\nend\n\n\ndo\n  print(\"testing traceback sizes\")\n\n  local function countlines (s)\n    return select(2, string.gsub(s, \"\\n\", \"\"))\n  end\n\n  local function deep (lvl, n)\n    if lvl == 0 then\n      return (debug.traceback(\"message\", n))\n    else\n      return (deep(lvl-1, n))\n    end\n  end\n\n  local function checkdeep (total, start)\n    local s = deep(total, start)\n    local rest = string.match(s, \"^message\\nstack traceback:\\n(.*)$\")\n    local cl = countlines(rest)\n    -- at most 10 lines in first part, 11 in second, plus '...'\n    assert(cl <= 10 + 11 + 1)\n    local brk = string.find(rest, \"%.%.%.\")\n    if brk then   -- does message have '...'?\n      local rest1 = string.sub(rest, 1, brk)\n      local rest2 = string.sub(rest, brk, #rest)\n      assert(countlines(rest1) == 10 and countlines(rest2) == 11)\n    else\n      assert(cl == total - start + 2)\n    end\n  end\n\n  for d = 1, 51, 10 do\n    for l = 1, d do\n      -- use coroutines to ensure complete control of the stack\n      coroutine.wrap(checkdeep)(d, l)\n    end\n  end\n\nend\n\n\nprint(\"testing debug functions on chunk without debug info\")\nprog = [[-- program to be loaded without debug information (strip)\nlocal debug = require'debug'\nlocal a = 12  -- a local variable\n\nlocal n, v = debug.getlocal(1, 1)\nassert(n == \"(temporary)\" and v == debug)   -- unkown name but known value\nn, v = debug.getlocal(1, 2)\nassert(n == \"(temporary)\" and v == 12)   -- unkown name but known value\n\n-- a function with an upvalue\nlocal f = function () local x; return a end\nn, v = debug.getupvalue(f, 1)\nassert(n == \"(no name)\" and v == 12)\nassert(debug.setupvalue(f, 1, 13) == \"(no name)\")\nassert(a == 13)\n\nlocal t = debug.getinfo(f)\nassert(t.name == nil and t.linedefined > 0 and\n       t.lastlinedefined == t.linedefined and\n       t.short_src == \"?\")\nassert(debug.getinfo(1).currentline == -1)\n\nt = debug.getinfo(f, \"L\").activelines\nassert(next(t) == nil)    -- active lines are empty\n\n-- dump/load a function without debug info\nf = load(string.dump(f))\n\nt = debug.getinfo(f)\nassert(t.name == nil and t.linedefined > 0 and\n       t.lastlinedefined == t.linedefined and\n       t.short_src == \"?\")\nassert(debug.getinfo(1).currentline == -1)\n\nreturn a\n]]\n\n\n-- load 'prog' without debug info\nlocal f = assert(load(string.dump(load(prog), true)))\n\nassert(f() == 13)\n\ndo   -- bug in 5.4.0: line hooks in stripped code\n  local function foo ()\n    local a = 1\n    local b = 2\n    return b\n  end\n\n  local s = load(string.dump(foo, true))\n  local line = true\n  debug.sethook(function (e, l)\n    assert(e == \"line\")\n    line = l\n  end, \"l\")\n  assert(s() == 2); debug.sethook(nil)\n  assert(line == nil)  -- hook called withoug debug info for 1st instruction\nend\n\ndo   -- tests for 'source' in binary dumps\n  local prog = [[\n    return function (x)\n      return function (y) \n        return x + y\n      end\n    end\n  ]]\n  local name = string.rep(\"x\", 1000)\n  local p = assert(load(prog, name))\n  -- load 'p' as a binary chunk with debug information\n  local c = string.dump(p)\n  assert(#c > 1000 and #c < 2000)   -- no repetition of 'source' in dump\n  local f = assert(load(c))\n  local g = f()\n  local h = g(3)\n  assert(h(5) == 8)\n  assert(debug.getinfo(f).source == name and   -- all functions have 'source'\n         debug.getinfo(g).source == name and \n         debug.getinfo(h).source == name)\n  -- again, without debug info\n  local c = string.dump(p, true)\n  assert(#c < 500)   -- no 'source' in dump\n  local f = assert(load(c))\n  local g = f()\n  local h = g(30)\n  assert(h(50) == 80)\n  assert(debug.getinfo(f).source == '=?' and   -- no function has 'source'\n         debug.getinfo(g).source == '=?' and \n         debug.getinfo(h).source == '=?')\nend\n\nprint\"OK\"\n\n"], "filenames": ["ldebug.c", "testes/db.lua"], "buggy_code_start_loc": [785, 887], "buggy_code_end_loc": [791, 928], "fixing_code_start_loc": [786, 887], "fixing_code_end_loc": [793, 946], "type": "CWE-476", "message": "ldebug.c in Lua 5.4.0 attempts to access debug information via the line hook of a stripped function, leading to a NULL pointer dereference.", "other": {"cve": {"id": "CVE-2020-24369", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-17T17:15:13.817", "lastModified": "2020-08-24T18:26:59.020", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ldebug.c in Lua 5.4.0 attempts to access debug information via the line hook of a stripped function, leading to a NULL pointer dereference."}, {"lang": "es", "value": "El archivo ldebug.c en Lua versi\u00f3n 5.4.0, intenta acceder a la informaci\u00f3n de depuraci\u00f3n por medio del enlace de l\u00ednea de una funci\u00f3n despojada, conllevando a una desreferencia del puntero NULL."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lua:lua:5.4.0:-:*:*:*:*:*:*", "matchCriteriaId": "E9F78BF8-B73C-42C6-AF54-2CD935670053"}]}]}], "references": [{"url": "https://github.com/lua/lua/commit/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.lua.org/bugs.html#5.4.0-12", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lua/lua/commit/ae5b5ba529753c7a653901ffc29b5ea24c3fdf3a"}}