{"buggy_code": ["/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert;\n\nimport io.micronaut.core.annotation.AnnotationMetadataProvider;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.TypeVariableResolver;\nimport io.micronaut.core.util.ArgumentUtils;\nimport io.micronaut.core.util.ArrayUtils;\n\nimport javax.annotation.Nullable;\nimport java.lang.annotation.Annotation;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\n/**\n * A conversion context is a context object supplied to a {@link TypeConverter} that allows more accurate conversion.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConversionContext extends AnnotationMetadataProvider, TypeVariableResolver, ErrorsContext {\n\n    /**\n     * The default conversion context.\n     */\n    ConversionContext DEFAULT = new ConversionContext() {\n    };\n\n    /**\n     * In the case where the type to be converted contains generic type arguments this map will return\n     * the concrete types of those arguments. For example for the {@link Map} type two keys will be present\n     * called 'K' and 'V' with the actual types of the key and value.\n     *\n     * @return A map of type variables\n     */\n    @Override\n    default Map<String, Argument<?>> getTypeVariables() {\n        return Collections.emptyMap();\n    }\n\n    /**\n     * @return The locale to use\n     */\n    default Locale getLocale() {\n        return Locale.getDefault();\n    }\n\n    /**\n     * @return The standard charset used in conversion\n     */\n    default Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n\n    /**\n     * Augment this context with data for the given argument.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    @SuppressWarnings(\"unchecked\")\n    default <T> ArgumentConversionContext<T> with(Argument<T> argument) {\n\n        ConversionContext childContext = ConversionContext.of(argument);\n        ConversionContext thisContext = this;\n        return new DefaultArgumentConversionContext(argument, thisContext.getLocale(), thisContext.getCharset()) {\n            @Override\n            public <T extends Annotation> T synthesize(Class<T> annotationClass) {\n                T annotation = childContext.synthesize(annotationClass);\n                if (annotation == null) {\n                    return thisContext.synthesize(annotationClass);\n                }\n                return annotation;\n            }\n\n            @Override\n            public Annotation[] synthesizeAll() {\n                return ArrayUtils.concat(childContext.synthesizeAll(), thisContext.synthesizeAll());\n            }\n\n            @Override\n            public Annotation[] synthesizeDeclared() {\n                return ArrayUtils.concat(childContext.synthesizeDeclared(), thisContext.synthesizeDeclared());\n            }\n\n            @Override\n            public void reject(Exception exception) {\n                thisContext.reject(exception);\n            }\n\n            @Override\n            public Iterator<ConversionError> iterator() {\n                return thisContext.iterator();\n            }\n\n            @Override\n            public Optional<ConversionError> getLastError() {\n                return thisContext.getLastError();\n            }\n        };\n    }\n\n\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param typeVariables The type variables\n     * @return The conversion context\n     */\n    static ConversionContext of(Map<String, Argument<?>> typeVariables) {\n        return new ConversionContext() {\n            @Override\n            public Map<String, Argument<?>> getTypeVariables() {\n                return typeVariables;\n            }\n\n        };\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Argument<T> argument) {\n        return of(argument, null, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Class<T> argument) {\n        ArgumentUtils.requireNonNull(\"argument\", argument);\n        return of(Argument.of(argument), null, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @param locale   The locale\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext of(Argument<T> argument, @Nullable Locale locale) {\n        return of(argument, locale, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @param locale   The locale\n     * @param charset  The charset\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Argument<T> argument, @Nullable Locale locale, @Nullable Charset charset) {\n        ArgumentUtils.requireNonNull(\"argument\", argument);\n        Charset finalCharset = charset != null ? charset : StandardCharsets.UTF_8;\n        Locale finalLocale = locale != null ? locale : Locale.getDefault();\n        return new DefaultArgumentConversionContext<>(argument, finalLocale, finalCharset);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.type.Argument;\n\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * Default implementation of the {@link ConversionContext} interface.\n *\n * @param <T> type Generic\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\nclass DefaultArgumentConversionContext<T> implements ArgumentConversionContext<T> {\n    private final Argument<T> argument;\n    private final Locale finalLocale;\n    private final Charset finalCharset;\n    private final List<ConversionError> conversionErrors = new ArrayList<>();\n\n    /**\n     * @param argument     The argument\n     * @param finalLocale  The final locale\n     * @param finalCharset The final charset\n     */\n    DefaultArgumentConversionContext(Argument<T> argument, Locale finalLocale, Charset finalCharset) {\n        this.argument = argument;\n        this.finalLocale = finalLocale;\n        this.finalCharset = finalCharset;\n    }\n\n    @Override\n    public Argument[] getTypeParameters() {\n        return argument.getTypeParameters();\n    }\n\n    @Override\n    public Map<String, Argument<?>> getTypeVariables() {\n        return argument.getTypeVariables();\n    }\n\n    @Override\n    public Locale getLocale() {\n        return finalLocale;\n    }\n\n    @Override\n    public Charset getCharset() {\n        return finalCharset;\n    }\n\n    @Override\n    public void reject(Exception exception) {\n        if (exception != null) {\n            conversionErrors.add(() -> exception);\n        }\n    }\n\n    @Override\n    public void reject(Object value, Exception exception) {\n        if (exception != null) {\n            conversionErrors.add(new ConversionError() {\n                @Override\n                public Optional<Object> getOriginalValue() {\n                    return value != null ? Optional.of(value) : Optional.empty();\n                }\n\n                @Override\n                public Exception getCause() {\n                    return exception;\n                }\n            });\n        }\n    }\n\n    @Override\n    public Optional<ConversionError> getLastError() {\n        if (!conversionErrors.isEmpty()) {\n            return Optional.of(conversionErrors.get(conversionErrors.size() - 1));\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public Iterator<ConversionError> iterator() {\n        return Collections.unmodifiableCollection(conversionErrors).iterator();\n    }\n\n    @Override\n    public Argument<T> getArgument() {\n        return argument;\n    }\n\n    @Override\n    public String toString() {\n        return argument.toString();\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert.value;\n\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.reflect.GenericTypeUtils;\nimport io.micronaut.core.type.Argument;\n\nimport javax.annotation.Nullable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.BiConsumer;\n\n/**\n * Specialization of {@link ConvertibleValues} where each name has multiple possible values.\n *\n * @param <V> The generic value\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConvertibleMultiValues<V> extends ConvertibleValues<List<V>> {\n    /**\n     * Get all the values for the given name without applying conversion.\n     *\n     * @param name The header name\n     * @return All the values\n     */\n    List<V> getAll(CharSequence name);\n\n    /**\n     * Get a value without applying any conversion.\n     *\n     * @param name The name of the value\n     * @return The raw value or null\n     * @see #getFirst(CharSequence)\n     */\n    @Nullable V get(CharSequence name);\n\n    /**\n     * @return Whether this values is empty\n     */\n    @Override\n    default boolean isEmpty() {\n        return this == ConvertibleMultiValuesMap.EMPTY || names().isEmpty();\n    }\n\n    /**\n     * Performs the given action for each header. Note that in the case\n     * where multiple values exist for the same header then the consumer will be invoked\n     * multiple times for the same key.\n     *\n     * @param action The action to be performed for each entry\n     * @throws NullPointerException if the specified action is null\n     * @since 1.0\n     */\n    default void forEachValue(BiConsumer<String, V> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> names = names();\n        for (String headerName : names) {\n            Collection<V> values = getAll(headerName);\n            for (V value : values) {\n                action.accept(headerName, value);\n            }\n        }\n    }\n\n    @Override\n    default void forEach(BiConsumer<String, List<V>> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> names = names();\n        for (String headerName : names) {\n            List<V> values = getAll(headerName);\n            action.accept(headerName, values);\n        }\n    }\n\n    @Override\n    default Iterator<Map.Entry<String, List<V>>> iterator() {\n        Iterator<String> headerNames = names().iterator();\n        return new Iterator<Map.Entry<String, List<V>>>() {\n            @Override\n            public boolean hasNext() {\n                return headerNames.hasNext();\n            }\n\n            @Override\n            public Map.Entry<String, List<V>> next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n\n                String name = headerNames.next();\n                return new Map.Entry<String, List<V>>() {\n                    @Override\n                    public String getKey() {\n                        return name;\n                    }\n\n                    @Override\n                    public List<V> getValue() {\n                        return getAll(name);\n                    }\n\n                    @Override\n                    public List<V> setValue(List<V> value) {\n                        throw new UnsupportedOperationException(\"Not mutable\");\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Get the first value of the given header.\n     *\n     * @param name The header name\n     * @return The first value or null if it is present\n     */\n    default Optional<V> getFirst(CharSequence name) {\n        Optional<Class> type = GenericTypeUtils.resolveInterfaceTypeArgument(getClass(), ConvertibleMultiValues.class);\n        return getFirst(name, type.orElse(Object.class));\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param <T>          The generic type\n     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n     */\n    default <T> Optional<T> getFirst(CharSequence name, Class<T> requiredType) {\n        return getFirst(name, Argument.of(requiredType));\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param <T>          The generic type\n     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n     */\n    default <T> Optional<T> getFirst(CharSequence name, Argument<T> requiredType) {\n        V v = get(name);\n        if (v != null) {\n            return ConversionService.SHARED.convert(v, ConversionContext.of(requiredType));\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param defaultValue The default value\n     * @param <T>          The generic type\n     * @return The first value of the default supplied value if it is isn't present\n     */\n    default <T> T getFirst(CharSequence name, Class<T> requiredType, T defaultValue) {\n        return getFirst(name, requiredType).orElse(defaultValue);\n    }\n\n    /**\n     * Creates a new {@link io.micronaut.core.value.OptionalValues} for the given type and values.\n     *\n     * @param values A map of values\n     * @param <T>    The target generic type\n     * @return The values\n     */\n    static <T> ConvertibleMultiValues<T> of(Map<CharSequence, List<T>> values) {\n        return new ConvertibleMultiValuesMap<>(values);\n    }\n\n    /**\n     * An empty {@link ConvertibleValues}.\n     *\n     * @param <V> The generic type\n     * @return The empty {@link ConvertibleValues}\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <V> ConvertibleMultiValues<V> empty() {\n        return ConvertibleMultiValuesMap.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert.value;\n\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.reflect.GenericTypeUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.value.ValueResolver;\n\nimport java.util.*;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Collectors;\n\n/**\n * An interface for classes that represent a map-like structure of values that can be converted.\n *\n * @param <V> The generic value\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConvertibleValues<V> extends ValueResolver<CharSequence>, Iterable<Map.Entry<String, V>> {\n\n    ConvertibleValues EMPTY = new ConvertibleValuesMap<>(Collections.emptyMap());\n\n    /**\n     * @return The names of the values\n     */\n    Set<String> names();\n\n    /**\n     * @return The values\n     */\n    Collection<V> values();\n\n    /**\n     * @return Whether this values is empty\n     */\n    default boolean isEmpty() {\n        return this == ConvertibleValues.EMPTY || names().isEmpty();\n    }\n\n    /**\n     * @return The concrete type of the value\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Class<V> getValueType() {\n        Optional<Class> type = GenericTypeUtils.resolveInterfaceTypeArgument(getClass(), ConvertibleValues.class);\n        return type.orElse(Object.class);\n    }\n\n    /**\n     * Whether the given key is contained within these values.\n     *\n     * @param name The key name\n     * @return True if it is\n     */\n    default boolean contains(String name) {\n        return get(name, Object.class).isPresent();\n    }\n\n    /**\n     * Performs the given action for each value. Note that in the case\n     * where multiple values exist for the same header then the consumer will be invoked\n     * multiple times for the same key.\n     *\n     * @param action The action to be performed for each entry\n     * @throws NullPointerException if the specified action is null\n     * @since 1.0\n     */\n    default void forEach(BiConsumer<String, V> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> headerNames = names();\n        for (String headerName : headerNames) {\n            Optional<V> vOptional = this.get(headerName, getValueType());\n            vOptional.ifPresent(v -> action.accept(headerName, v));\n        }\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a map for the given key type and value type. The map represents a copy of the data held by this instance.\n     *\n     * @return The values\n     */\n    default Map<String, V> asMap() {\n        Map<String, V> newMap = new LinkedHashMap<>();\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            newMap.put(key, entry.getValue());\n        }\n        return newMap;\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a map for the given key type and value type. If any entry cannot be\n     * converted to the target key/value type then the entry is simply excluded, hence the size of the map returned\n     * may not match the size of this {@link ConvertibleValues}.\n     *\n     * @param keyType   The key type\n     * @param valueType The value type\n     * @param <KT>      The key type\n     * @param <VT>      The value type\n     * @return The values with the key converted to the given key type and the value to the given value type.\n     */\n    default <KT, VT> Map<KT, VT> asMap(Class<KT> keyType, Class<VT> valueType) {\n        Map<KT, VT> newMap = new LinkedHashMap<>();\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            Optional<KT> convertedKey = ConversionService.SHARED.convert(key, keyType);\n            if (convertedKey.isPresent()) {\n                Optional<VT> convertedValue = ConversionService.SHARED.convert(entry.getValue(), valueType);\n                convertedValue.ifPresent(vt -> newMap.put(convertedKey.get(), vt));\n            }\n        }\n        return newMap;\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a {@link Properties} object returning only keys and values that\n     * can be represented as a string.\n     *\n     * @return The values with the key converted to the given key type and the value to the given value type.\n     * @since 1.0.3\n     */\n    default Properties asProperties() {\n        Properties props = new Properties();\n\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            V value = entry.getValue();\n            if (value instanceof CharSequence || value instanceof Number) {\n                props.setProperty(key, value.toString());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, Class<V> valueType) {\n        return subMap(prefix, Argument.of(valueType));\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, Argument<V> valueType) {\n        return subMap(prefix, ConversionContext.of(valueType));\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, ArgumentConversionContext<V> valueType) {\n        // special handling for maps for resolving sub keys\n        String finalPrefix = prefix + '.';\n        return names().stream()\n            .filter(name -> name.startsWith(finalPrefix))\n            .collect(Collectors.toMap((name) -> name.substring(finalPrefix.length()), (name) -> get(name, valueType).orElse(null)));\n    }\n\n    @SuppressWarnings(\"NullableProblems\")\n    @Override\n    default Iterator<Map.Entry<String, V>> iterator() {\n        Iterator<String> names = names().iterator();\n        return new Iterator<Map.Entry<String, V>>() {\n            @Override\n            public boolean hasNext() {\n                return names.hasNext();\n            }\n\n            @Override\n            public Map.Entry<String, V> next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n\n                String name = names.next();\n                return new Map.Entry<String, V>() {\n                    @Override\n                    public String getKey() {\n                        return name;\n                    }\n\n                    @Override\n                    public V getValue() {\n                        return get(name, getValueType()).orElse(null);\n                    }\n\n                    @Override\n                    public V setValue(V value) {\n                        throw new UnsupportedOperationException(\"Not mutable\");\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Creates a new {@link ConvertibleValues} for the values.\n     *\n     * @param values A map of values\n     * @param <T>    The target generic type\n     * @return The values\n     */\n    static <T> ConvertibleValues<T> of(Map<? extends CharSequence, T> values) {\n        if (values == null) {\n            return ConvertibleValuesMap.empty();\n        } else {\n            return new ConvertibleValuesMap<>(values);\n        }\n    }\n\n    /**\n     * An empty {@link ConvertibleValues}.\n     *\n     * @param <V> The generic type\n     * @return The empty {@link ConvertibleValues}\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <V> ConvertibleValues<V> empty() {\n        return ConvertibleValues.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.type;\n\nimport io.micronaut.core.annotation.AnnotatedElement;\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.UsedByGeneratedCode;\nimport io.micronaut.core.naming.NameUtils;\nimport io.micronaut.core.reflect.ReflectionUtils;\nimport io.micronaut.core.util.ArrayUtils;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Represents an argument to a method or constructor or type.\n *\n * @param <T> The argument type\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface Argument<T> extends TypeVariableResolver, AnnotatedElement, Type {\n\n    /**\n     * Constant for int argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument INT = Argument.of(int.class);\n\n    /**\n     * Constant for long argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument LONG = Argument.of(long.class);\n\n    /**\n     * Constant for float argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument FLOAT = Argument.of(float.class);\n\n    /**\n     * Constant for double argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument DOUBLE = Argument.of(double.class);\n\n    /**\n     * Constant for void argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument VOID = Argument.of(void.class);\n\n    /**\n     * Constant for byte argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument BYTE = Argument.of(byte.class);\n\n    /**\n     * Constant for boolean argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument BOOLEAN = Argument.of(boolean.class);\n\n    /**\n     * Constant char argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument CHAR = Argument.of(char.class);\n\n    /**\n     * Constant short argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument SHORT = Argument.of(short.class);\n\n    /**\n     * Constant representing zero arguments. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    @UsedByGeneratedCode\n    Argument[] ZERO_ARGUMENTS = new Argument[0];\n\n    /**\n     * Default Object argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Object> OBJECT_ARGUMENT = of(Object.class);\n\n    /**\n     * @return The name of the argument\n     */\n    @Nonnull String getName();\n\n    @Override\n    @Nonnull\n    default String getTypeName() {\n        return getName();\n    }\n\n    /**\n     * @return The type of the argument\n     */\n    @Nonnull Class<T> getType();\n\n    /**\n     * Whether the types are equivalent. The regular {@link Object#equals(Object)} implementation includes the argument\n     * name within the comparison so this method offers a variation that just compares types.\n     *\n     * @param other The type type\n     * @return True if they are equal\n     */\n    boolean equalsType(Argument<?> other);\n\n    /**\n     * The hash code including only the types. The regular {@link Object#hashCode()} implementation includes the\n     * argument name within the comparison so this method offers a variation that just compares types.\n     *\n     * @return The type hash code\n     */\n    int typeHashCode();\n\n    /**\n     * Whether the given argument is an instance.\n     * @param o The object\n     * @return True if it is an instance of this type\n     */\n    default boolean isInstance(@Nullable Object o) {\n        if (o == null) {\n            return false;\n        }\n        return getType().isInstance(o);\n    }\n\n    /**\n     * Returns the string representation of the argument type, including generics.\n     *\n     * @param simple If true, output the simple name of types\n     * @return The type string representation\n     */\n    default String getTypeString(boolean simple) {\n        Class<T> type = getType();\n        StringBuilder returnType = new StringBuilder(simple ? type.getSimpleName() : type.getName());\n        Map<String, Argument<?>> generics = getTypeVariables();\n        if (!generics.isEmpty()) {\n            returnType\n                    .append(\"<\")\n                    .append(generics.values()\n                            .stream()\n                            .map(arg -> arg.getTypeString(simple))\n                            .collect(Collectors.joining(\", \")))\n                    .append(\">\");\n        }\n        return returnType.toString();\n    }\n\n    /**\n     * @return Whether the argument has any type variables\n     */\n    default boolean hasTypeVariables() {\n        return !getTypeVariables().isEmpty();\n    }\n\n    /**\n     * Convert an argument array to a class array.\n     *\n     * @param arguments The arguments\n     * @return The class array\n     */\n    static @Nonnull Class[] toClassArray(Argument... arguments) {\n        if (ArrayUtils.isEmpty(arguments)) {\n            return ReflectionUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class[] types = new Class[arguments.length];\n        for (int i = 0; i < arguments.length; i++) {\n            Argument argument = arguments[i];\n            types[i] = argument.getType();\n        }\n        return types;\n    }\n\n    /**\n     * Convert the arguments to a string representation.\n     *\n     * @param arguments The arguments\n     * @return The String representation\n     */\n    static @Nonnull String toString(Argument... arguments) {\n        StringBuilder baseString = new StringBuilder();\n        if (ArrayUtils.isNotEmpty(arguments)) {\n            for (int i = 0; i < arguments.length; i++) {\n                Argument argument = arguments[i];\n                baseString.append(argument.toString());\n                if (i != arguments.length - 1) {\n                    baseString.append(',');\n                }\n            }\n        }\n        return baseString.toString();\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param name           The name\n     * @param typeParameters the type parameters\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name,\n        @Nullable Argument... typeParameters) {\n        return new DefaultArgument<>(type, name, AnnotationMetadata.EMPTY_METADATA, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata the annotation metadata\n     * @param typeParameters     the type parameters\n     * @param <T>                The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name,\n        AnnotationMetadata annotationMetadata,\n        @Nullable Argument... typeParameters) {\n        return new DefaultArgument<>(type, name, annotationMetadata, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type The type\n     * @param name The name\n     * @param <T>  The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name) {\n        return new DefaultArgument<>(type, name, AnnotationMetadata.EMPTY_METADATA, Argument.ZERO_ARGUMENTS);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param typeParameters The parameters type\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type, @Nullable Argument... typeParameters) {\n        if (ArrayUtils.isEmpty(typeParameters)) {\n            return of(type);\n        }\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type The type\n     * @param <T>  The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type) {\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, Argument.ZERO_ARGUMENTS);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param typeParameters the parameters type\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(Class<T> type, @Nullable Class<?>... typeParameters) {\n        if (ArrayUtils.isEmpty(typeParameters)) {\n            return of(type);\n        }\n\n        TypeVariable<Class<T>>[] parameters = type.getTypeParameters();\n        int len = typeParameters.length;\n        if (parameters.length != len) {\n            throw new IllegalArgumentException(\"Type parameter length does not match. Required: \" + parameters.length + \", Specified: \" + len);\n        }\n        Argument[] typeArguments = new Argument[len];\n        for (int i = 0; i < parameters.length; i++) {\n            TypeVariable<Class<T>> parameter = parameters[i];\n            typeArguments[i] = Argument.of(typeParameters[i], parameter.getName());\n        }\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, typeArguments);\n    }\n\n    /**\n     * Creates a new argument representing a generic list.\n     *\n     * @param type list element type\n     * @param <T>  list element type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <T> Argument<List<T>> listOf(Class<T> type) {\n        //noinspection unchecked\n        return of((Class<List<T>>) ((Class) List.class), type);\n    }\n\n    /**\n     * Creates a new argument representing a generic set.\n     *\n     * @param type set element type\n     * @param <T>  set element type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <T> Argument<Set<T>> setOf(Class<T> type) {\n        //noinspection unchecked\n        return of((Class<Set<T>>) ((Class) Set.class), type);\n    }\n\n    /**\n     * Creates a new argument representing a generic map.\n     *\n     * @param keyType The key type\n     * @param valueType The value type\n     * @param <K>  The map key type\n     * @param <V> The map value type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <K, V> Argument<Map<K, V>> mapOf(Class<K> keyType, Class<V> valueType) {\n        //noinspection unchecked\n        return of((Class<Map<K, V>>) ((Class) Map.class), keyType, valueType);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.type;\n\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.naming.NameUtils;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\n/**\n * Represents an argument to a constructor or method.\n *\n * @param <T> The argument type\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\npublic class DefaultArgument<T> implements Argument<T> {\n\n    private final Class<T> type;\n    private final String name;\n    private final Map<String, Argument<?>> typeParameters;\n    private final Argument[] typeParameterArray;\n    private final AnnotationMetadata annotationMetadata;\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     * @param genericTypes       The generic types\n     */\n    public DefaultArgument(Class<T> type, String name, AnnotationMetadata annotationMetadata, Argument... genericTypes) {\n        this.type = type;\n        this.name = name;\n        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n        this.typeParameters = initializeTypeParameters(genericTypes);\n        this.typeParameterArray = genericTypes;\n    }\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     * @param typeParameters     The map of parameters\n     * @param typeParameterArray The array of arguments\n     */\n    public DefaultArgument(Class<T> type, String name, AnnotationMetadata annotationMetadata, Map<String, Argument<?>> typeParameters, Argument[] typeParameterArray) {\n        this.type = type;\n        this.name = name;\n        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n        this.typeParameters = typeParameters;\n        this.typeParameterArray = typeParameterArray;\n    }\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     */\n    public DefaultArgument(Type type, String name, AnnotationMetadata annotationMetadata) {\n        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n        if (type == null) {\n            type = getClass().getGenericSuperclass();\n            if (type instanceof ParameterizedType) {\n                type = ((ParameterizedType) type).getActualTypeArguments()[0];\n            } else {\n                throw new IllegalArgumentException(type + \" is not parameterized\");\n            }\n        }\n        if (type instanceof Class) {\n            //noinspection unchecked\n            this.type = (Class<T>) type;\n            this.typeParameterArray = Argument.ZERO_ARGUMENTS;\n        } else if (type instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) type;\n            //noinspection unchecked\n            this.type = (Class<T>) parameterizedType.getRawType();\n            TypeVariable<Class<T>>[] params = this.type.getTypeParameters();\n            Type[] paramValues = parameterizedType.getActualTypeArguments();\n            typeParameterArray = new Argument[params.length];\n            for (int i = 0; i < params.length; i++) {\n                TypeVariable param = params[i];\n                Type value = paramValues[i];\n                typeParameterArray[i] = new DefaultArgument(value, param.getName(), AnnotationMetadata.EMPTY_METADATA);\n            }\n        } else {\n            throw new IllegalArgumentException(type.getClass().getSimpleName() + \" types are not supported\");\n        }\n        if (name == null) {\n            name = NameUtils.decapitalize(this.type.getSimpleName());\n        }\n        this.name = name;\n        this.typeParameters = initializeTypeParameters(this.typeParameterArray);\n    }\n\n    @Override\n    public AnnotationMetadata getAnnotationMetadata() {\n        return annotationMetadata;\n    }\n\n    @Override\n    public Optional<Argument<?>> getFirstTypeVariable() {\n        if (!typeParameters.isEmpty()) {\n            return typeParameters.values().stream().findFirst();\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public Argument[] getTypeParameters() {\n        return typeParameterArray;\n    }\n\n    @Override\n    public Map<String, Argument<?>> getTypeVariables() {\n        return this.typeParameters;\n    }\n\n    @Override\n    public Class<T> getType() {\n        return type;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return type.getSimpleName() + \" \" + name;\n    }\n\n    @Override\n    public boolean equalsType(Argument<?> o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null) {\n            return false;\n        }\n        return Objects.equals(type, o.getType()) &&\n            Objects.equals(typeParameters, o.getTypeVariables());\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof DefaultArgument)) {\n            return false;\n        }\n        DefaultArgument<?> that = (DefaultArgument<?>) o;\n        return Objects.equals(type, that.type) &&\n            Objects.equals(name, that.name) &&\n            Objects.equals(typeParameters, that.typeParameters);\n    }\n\n    @Override\n    public int typeHashCode() {\n        return Objects.hash(type, typeParameters);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(type, name, typeParameters);\n    }\n\n    private Map<String, Argument<?>> initializeTypeParameters(Argument[] genericTypes) {\n        Map<String, Argument<?>> typeParameters;\n        if (genericTypes != null && genericTypes.length > 0) {\n            typeParameters = new LinkedHashMap<>(genericTypes.length);\n            for (Argument genericType : genericTypes) {\n                typeParameters.put(genericType.getName(), genericType);\n            }\n        } else {\n            typeParameters = Collections.emptyMap();\n        }\n        return typeParameters;\n    }\n\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.client.exceptions;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.naming.Described;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.hateoas.JsonError;\nimport io.micronaut.http.hateoas.VndError;\n\nimport java.util.Optional;\n\n/**\n * Strategy interface for decoding the error from a server respponse.\n *\n * @author graemerocher\n * @since 1.0\n */\n@Internal\npublic interface HttpClientErrorDecoder {\n\n    /**\n     * The default implementation.\n     */\n    HttpClientErrorDecoder DEFAULT = new HttpClientErrorDecoder() { };\n\n    /**\n     * Default message decoder.\n     *\n     * @param error The error object\n     * @return The message\n     */\n    default Optional<String> getMessage(Object error) {\n        if (error == null) {\n            return Optional.empty();\n        }\n        if (error instanceof JsonError) {\n            return Optional.ofNullable(((JsonError) error).getMessage());\n        } else {\n            if (error instanceof Described) {\n                return Optional.ofNullable(((Described) error).getDescription());\n            } else {\n                return Optional.of(error.toString());\n            }\n        }\n    }\n\n    /**\n     * Gets the error type for the given media type.\n     *\n     * @param mediaType The media type\n     * @return The error type\n     */\n    default Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.of(String.class);\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty;\n\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.context.event.ApplicationEventPublisher;\nimport io.micronaut.context.exceptions.BeanInstantiationException;\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.async.subscriber.CompletionAwareSubscriber;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.io.Writable;\nimport io.micronaut.core.io.buffer.ByteBuffer;\nimport io.micronaut.core.io.buffer.ReferenceCounted;\nimport io.micronaut.core.reflect.ClassUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.ReturnType;\nimport io.micronaut.http.HttpAttributes;\nimport io.micronaut.http.HttpHeaders;\nimport io.micronaut.http.HttpMethod;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.HttpResponse;\nimport io.micronaut.http.HttpStatus;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.MutableHttpHeaders;\nimport io.micronaut.http.MutableHttpResponse;\nimport io.micronaut.http.annotation.Produces;\nimport io.micronaut.http.annotation.Status;\nimport io.micronaut.http.codec.MediaTypeCodec;\nimport io.micronaut.http.codec.MediaTypeCodecRegistry;\nimport io.micronaut.http.context.event.HttpRequestTerminatedEvent;\nimport io.micronaut.http.exceptions.HttpStatusException;\nimport io.micronaut.http.filter.HttpFilter;\nimport io.micronaut.http.filter.HttpServerFilter;\nimport io.micronaut.http.filter.OncePerRequestHttpServerFilter;\nimport io.micronaut.http.filter.ServerFilterChain;\nimport io.micronaut.http.hateoas.JsonError;\nimport io.micronaut.http.hateoas.Link;\nimport io.micronaut.http.multipart.PartData;\nimport io.micronaut.http.multipart.StreamingFileUpload;\nimport io.micronaut.http.netty.NettyMutableHttpResponse;\nimport io.micronaut.buffer.netty.NettyByteBufferFactory;\nimport io.micronaut.http.netty.content.HttpContentUtil;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.http.server.binding.RequestArgumentSatisfier;\nimport io.micronaut.http.server.exceptions.ExceptionHandler;\nimport io.micronaut.http.server.exceptions.InternalServerException;\nimport io.micronaut.http.server.netty.async.ContextCompletionAwareSubscriber;\nimport io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;\nimport io.micronaut.http.server.netty.multipart.NettyPartData;\nimport io.micronaut.http.server.netty.multipart.NettyStreamingFileUpload;\nimport io.micronaut.http.server.netty.types.NettyCustomizableResponseTypeHandler;\nimport io.micronaut.http.server.netty.types.NettyCustomizableResponseTypeHandlerRegistry;\nimport io.micronaut.http.server.netty.types.files.NettyStreamedFileCustomizableResponseType;\nimport io.micronaut.http.server.netty.types.files.NettySystemFileCustomizableResponseType;\nimport io.micronaut.http.server.types.files.FileCustomizableResponseType;\nimport io.micronaut.inject.BeanType;\nimport io.micronaut.inject.MethodExecutionHandle;\nimport io.micronaut.inject.qualifiers.Qualifiers;\nimport io.micronaut.runtime.http.codec.TextPlainCodec;\nimport io.micronaut.scheduling.executor.ExecutorSelector;\nimport io.micronaut.web.router.*;\nimport io.micronaut.web.router.exceptions.DuplicateRouteException;\nimport io.micronaut.web.router.exceptions.UnsatisfiedRouteException;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport io.micronaut.web.router.resource.StaticResourceResolver;\nimport io.micronaut.websocket.annotation.OnMessage;\nimport io.micronaut.websocket.annotation.OnOpen;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufHolder;\nimport io.netty.buffer.ByteBufOutputStream;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandler.Sharable;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.FileUpload;\nimport io.netty.handler.codec.http.multipart.HttpData;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.reactivex.BackpressureStrategy;\nimport io.reactivex.Completable;\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.LongConsumer;\nimport io.reactivex.processors.UnicastProcessor;\nimport io.reactivex.schedulers.Schedulers;\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Paths;\nimport java.time.LocalDateTime;\nimport java.util.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Internal implementation of the {@link io.netty.channel.ChannelInboundHandler} for Micronaut.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\n@Sharable\nclass RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);\n    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(\n            \"^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$\", Pattern.CASE_INSENSITIVE);\n\n    private final Router router;\n    private final ExecutorSelector executorSelector;\n    private final StaticResourceResolver staticResourceResolver;\n    private final ExecutorService ioExecutor;\n    private final BeanLocator beanLocator;\n    private final NettyHttpServerConfiguration serverConfiguration;\n    private final RequestArgumentSatisfier requestArgumentSatisfier;\n    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;\n    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;\n\n    /**\n     * @param beanLocator                             The bean locator\n     * @param router                                  The router\n     * @param mediaTypeCodecRegistry                  The media type codec registry\n     * @param customizableResponseTypeHandlerRegistry The customizable response type handler registry\n     * @param staticResourceResolver                  The static resource resolver\n     * @param serverConfiguration                     The Netty HTTP server configuration\n     * @param requestArgumentSatisfier                The Request argument satisfier\n     * @param executorSelector                        The executor selector\n     * @param ioExecutor                              The IO executor\n     */\n    RoutingInBoundHandler(\n        BeanLocator beanLocator,\n        Router router,\n        MediaTypeCodecRegistry mediaTypeCodecRegistry,\n        NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry,\n        StaticResourceResolver staticResourceResolver,\n        NettyHttpServerConfiguration serverConfiguration,\n        RequestArgumentSatisfier requestArgumentSatisfier,\n        ExecutorSelector executorSelector,\n        ExecutorService ioExecutor) {\n\n        this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;\n        this.customizableResponseTypeHandlerRegistry = customizableResponseTypeHandlerRegistry;\n        this.beanLocator = beanLocator;\n        this.staticResourceResolver = staticResourceResolver;\n        this.ioExecutor = ioExecutor;\n        this.executorSelector = executorSelector;\n        this.router = router;\n        this.requestArgumentSatisfier = requestArgumentSatisfier;\n        this.serverConfiguration = serverConfiguration;\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);\n        if (ctx.channel().isWritable()) {\n            ctx.flush();\n        }\n        NettyHttpRequest request = NettyHttpRequest.remove(ctx);\n        if (request != null) {\n            try {\n                request.release();\n            } finally {\n                if (beanLocator instanceof ApplicationEventPublisher) {\n                    ctx.executor().execute(() -> {\n                        try {\n                            ((ApplicationEventPublisher) beanLocator).publishEvent(\n                                    new HttpRequestTerminatedEvent(\n                                            request\n                                    )\n                            );\n                        } catch (Exception e) {\n                            if (LOG.isErrorEnabled()) {\n                                LOG.error(\"Error publishing request terminated event: \" + e.getMessage(), e);\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        try {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent idleStateEvent = (IdleStateEvent) evt;\n                IdleState state = idleStateEvent.state();\n                if (state == IdleState.ALL_IDLE) {\n                    ctx.close();\n                }\n            }\n        } finally {\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        NettyHttpRequest nettyHttpRequest = NettyHttpRequest.remove(ctx);\n        if (nettyHttpRequest == null) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Micronaut Server Error - No request state present. Cause: \" + cause.getMessage(), cause);\n            }\n            ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR));\n            return;\n        }\n\n        exceptionCaughtInternal(ctx, cause, nettyHttpRequest, true);\n    }\n\n    private void exceptionCaughtInternal(ChannelHandlerContext ctx,\n                                         Throwable cause,\n                                         NettyHttpRequest nettyHttpRequest,\n                                         boolean nettyException) {\n        RouteMatch<?> errorRoute = null;\n        // find the origination of of the route\n        RouteMatch<?> originalRoute = nettyHttpRequest.getMatchedRoute();\n        Class declaringType = null;\n        if (originalRoute instanceof MethodExecutionHandle) {\n            declaringType = ((MethodExecutionHandle) originalRoute).getDeclaringType();\n        }\n\n        // when arguments do not match, then there is UnsatisfiedRouteException, we can handle this with a routed bad request\n        if (cause instanceof UnsatisfiedRouteException) {\n            if (declaringType != null) {\n                // handle error with a method that is non global with bad request\n                errorRoute = router.route(declaringType, HttpStatus.BAD_REQUEST).orElse(null);\n            }\n            if (errorRoute == null) {\n                // handle error with a method that is global with bad request\n                errorRoute = router.route(HttpStatus.BAD_REQUEST).orElse(null);\n            }\n        } else if (cause instanceof HttpStatusException) {\n            HttpStatusException statusException = (HttpStatusException) cause;\n            if (declaringType != null) {\n                // handle error with a method that is non global with bad request\n                errorRoute = router.route(declaringType, statusException.getStatus()).orElse(null);\n            }\n            if (errorRoute == null) {\n                // handle error with a method that is global with bad request\n                errorRoute = router.route(statusException.getStatus()).orElse(null);\n            }\n        } else if (cause instanceof BeanInstantiationException && declaringType != null) {\n            // If the controller could not be instantiated, don't look for a local error route\n            Optional<Class> rootBeanType = ((BeanInstantiationException) cause).getRootBeanType().map(BeanType::getBeanType);\n            if (rootBeanType.isPresent() && declaringType == rootBeanType.get()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Failed to instantiate [{}]. Skipping lookup of a local error route\", declaringType.getName());\n                }\n                declaringType = null;\n            }\n        }\n\n        // any another other exception may arise. handle these with non global exception marked method or a global exception marked method.\n        if (errorRoute == null) {\n            if (declaringType != null) {\n                errorRoute = router.route(declaringType, cause).orElse(null);\n            }\n            if (errorRoute == null) {\n                errorRoute = router.route(cause).orElse(null);\n            }\n        }\n\n        if (errorRoute != null) {\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Found matching exception handler for exception [{}]: {}\", cause.getMessage(), errorRoute);\n            }\n            errorRoute = requestArgumentSatisfier.fulfillArgumentRequirements(errorRoute, nettyHttpRequest, false);\n            MediaType defaultResponseMediaType = errorRoute.getProduces().stream().findFirst().orElse(MediaType.APPLICATION_JSON_TYPE);\n            try {\n                final MethodBasedRouteMatch<?, ?> methodBasedRoute = (MethodBasedRouteMatch) errorRoute;\n                Class<?> javaReturnType = errorRoute.getReturnType().getType();\n                boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);\n                boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;\n                Flowable resultFlowable = Flowable.defer(() -> {\n                      Object result = methodBasedRoute.execute();\n                      MutableHttpResponse<?> response = errorResultToResponse(result);\n                      response.setAttribute(HttpAttributes.ROUTE_MATCH, methodBasedRoute);\n                      return Flowable.just(response);\n                });\n\n                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                        methodBasedRoute.getDeclaringType(),\n                        methodBasedRoute.getReturnType(),\n                        isReactiveReturnType,\n                        methodBasedRoute.getAnnotationMetadata(),\n                        requestReference,\n                        resultFlowable);\n\n                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                        requestReference,\n                        routePublisher,\n                        ctx.channel().eventLoop(),\n                        nettyException);\n\n                subscribeToResponsePublisher(\n                        ctx,\n                        defaultResponseMediaType,\n                        requestReference,\n                        filteredPublisher\n                );\n\n                if (serverConfiguration.isLogHandledExceptions()) {\n                    logException(cause);\n                }\n\n            } catch (Throwable e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(\"Exception occurred executing error handler. Falling back to default error handling: \" + e.getMessage(), e);\n                }\n                writeDefaultErrorResponse(ctx, nettyHttpRequest, e);\n            }\n        } else {\n\n            Optional<ExceptionHandler> exceptionHandler = beanLocator\n                    .findBean(ExceptionHandler.class, Qualifiers.byTypeArgumentsClosest(cause.getClass(), Object.class));\n\n            if (exceptionHandler.isPresent()) {\n                ExceptionHandler handler = exceptionHandler.get();\n                MediaType defaultResponseMediaType = MediaType.fromType(handler.getClass()).orElse(MediaType.APPLICATION_JSON_TYPE);\n                try {\n                    Flowable resultFlowable = Flowable.defer(() -> {\n                        Object result = handler.handle(nettyHttpRequest, cause);\n                        MutableHttpResponse<?> response = errorResultToResponse(result);\n                        return Flowable.just(response);\n                    });\n\n                    AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                    Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                            handler.getClass(),\n                            ReturnType.of(HttpResponse.class),\n                            false,\n                            AnnotationMetadata.EMPTY_METADATA,\n                            requestReference,\n                            resultFlowable);\n\n                    Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                            requestReference,\n                            routePublisher,\n                            ctx.channel().eventLoop(),\n                            nettyException);\n\n                    subscribeToResponsePublisher(\n                            ctx,\n                            defaultResponseMediaType,\n                            requestReference,\n                            filteredPublisher\n                    );\n\n                    if (serverConfiguration.isLogHandledExceptions()) {\n                        logException(cause);\n                    }\n                } catch (Throwable e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Exception occurred executing error handler. Falling back to default error handling.\");\n                    }\n                    writeDefaultErrorResponse(ctx, nettyHttpRequest, e);\n                }\n            } else {\n                logException(cause);\n\n                Flowable resultFlowable = Flowable.defer(() ->\n                        Flowable.just(HttpResponse.serverError().body(new JsonError(\"Internal Server Error: \" + cause.getMessage())))\n                );\n\n                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                        null,\n                        ReturnType.of(HttpResponse.class),\n                        false,\n                        AnnotationMetadata.EMPTY_METADATA,\n                        requestReference,\n                        resultFlowable);\n\n                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                        requestReference,\n                        routePublisher,\n                        ctx.channel().eventLoop(),\n                        nettyException);\n\n                subscribeToResponsePublisher(\n                        ctx,\n                        MediaType.APPLICATION_JSON_TYPE,\n                        requestReference,\n                        filteredPublisher\n                );\n            }\n        }\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, io.micronaut.http.HttpRequest<?> request) {\n        ctx.channel().config().setAutoRead(false);\n        io.micronaut.http.HttpMethod httpMethod = request.getMethod();\n        String requestPath = request.getPath();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Matching route {} - {}\", httpMethod, requestPath);\n        }\n\n        NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) request;\n        io.netty.handler.codec.http.HttpRequest nativeRequest = nettyHttpRequest.getNativeRequest();\n        // handle decoding failure\n        DecoderResult decoderResult = nativeRequest.decoderResult();\n        if (decoderResult.isFailure()) {\n            Throwable cause = decoderResult.cause();\n            HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;\n            handleStatusError(\n                    ctx,\n                    request,\n                    nettyHttpRequest,\n                    HttpResponse.status(status),\n                    status.getReason()\n            );\n            return;\n        }\n        Optional<UriRouteMatch<Object, Object>> routeMatch = Optional.empty();\n\n        List<UriRouteMatch<Object, Object>> uriRoutes = router.findAllClosest(request);\n\n        if (uriRoutes.size() > 1) {\n            throw new DuplicateRouteException(requestPath, uriRoutes);\n        } else if (uriRoutes.size() == 1) {\n            UriRouteMatch<Object, Object> establishedRoute = uriRoutes.get(0);\n            request.setAttribute(HttpAttributes.ROUTE, establishedRoute.getRoute());\n            request.setAttribute(HttpAttributes.ROUTE_MATCH, establishedRoute);\n            request.setAttribute(HttpAttributes.URI_TEMPLATE, establishedRoute.getRoute().getUriMatchTemplate().toString());\n            routeMatch = Optional.of(establishedRoute);\n        }\n\n        RouteMatch<?> route;\n\n        if (!routeMatch.isPresent()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No matching route found for URI {} and method {}\", request.getUri(), httpMethod);\n            }\n\n            // if there is no route present try to locate a route that matches a different content type\n            Set<MediaType> existingRouteConsumes = router\n                    .find(httpMethod, requestPath)\n                    .map(UriRouteMatch::getRoute)\n                    .flatMap(r -> r.getConsumes().stream())\n                    .collect(Collectors.toSet());\n\n            if (!existingRouteConsumes.isEmpty() && !existingRouteConsumes.contains(MediaType.ALL_TYPE)) {\n                MediaType contentType = request.getContentType().orElse(null);\n                if (contentType != null) {\n                    if (!existingRouteConsumes.contains(contentType)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Content type not allowed for URI {}, method {}, and content type {}\", request.getUri(), httpMethod, contentType);\n                        }\n\n                        handleStatusError(\n                                ctx,\n                                request,\n                                nettyHttpRequest,\n                                HttpResponse.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE),\n                                \"Content Type [\" + contentType + \"] not allowed. Allowed types: \" + existingRouteConsumes);\n                        return;\n                    }\n                }\n            }\n\n            // if there is no route present try to locate a route that matches a different HTTP method\n            Set<io.micronaut.http.HttpMethod> existingRouteMethods = router\n                    .findAny(request.getUri().toString())\n                    .map(UriRouteMatch::getHttpMethod)\n                    .collect(Collectors.toSet());\n\n            if (!existingRouteMethods.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Method not allowed for URI {} and method {}\", request.getUri(), httpMethod);\n                }\n\n                handleStatusError(\n                        ctx,\n                        request,\n                        nettyHttpRequest,\n                        HttpResponse.notAllowed(existingRouteMethods),\n                        \"Method [\" + httpMethod + \"] not allowed for URI [\" + request.getUri() + \"]. Allowed methods: \" + existingRouteMethods);\n                return;\n            }\n\n            Optional<? extends FileCustomizableResponseType> optionalFile = matchFile(requestPath);\n\n            if (optionalFile.isPresent()) {\n                route = new BasicObjectRouteMatch(optionalFile.get());\n            } else {\n                Optional<RouteMatch<Object>> statusRoute = router.route(HttpStatus.NOT_FOUND);\n                if (statusRoute.isPresent()) {\n                    route = statusRoute.get();\n                } else {\n                    emitDefaultNotFoundResponse(ctx, request);\n                    return;\n                }\n            }\n\n        } else {\n            route = routeMatch.get();\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (route instanceof MethodBasedRouteMatch) {\n                LOG.debug(\"Matched route {} - {} to controller {}\", httpMethod, requestPath, route.getDeclaringType());\n            } else {\n                LOG.debug(\"Matched route {} - {}\", httpMethod, requestPath);\n            }\n        }\n        // all ok proceed to try and execute the route\n        if (route.isAnnotationPresent(OnMessage.class) || route.isAnnotationPresent(OnOpen.class)) {\n            handleStatusError(\n                    ctx,\n                    request,\n                    nettyHttpRequest,\n                    HttpResponse.status(HttpStatus.BAD_REQUEST),\n                    \"Not a WebSocket request\");\n        } else {\n            handleRouteMatch(route, nettyHttpRequest, ctx);\n        }\n    }\n\n    private void handleStatusError(\n            ChannelHandlerContext ctx,\n            HttpRequest<?> request,\n            NettyHttpRequest nettyHttpRequest,\n            MutableHttpResponse<Object> defaultResponse,\n            String message) {\n        Optional<RouteMatch<Object>> statusRoute = router.route(defaultResponse.status());\n        if (statusRoute.isPresent()) {\n            RouteMatch<Object> routeMatch = statusRoute.get();\n            handleRouteMatch(routeMatch, nettyHttpRequest, ctx);\n        } else {\n\n            if (HttpMethod.permitsRequestBody(request.getMethod())) {\n                JsonError error = newError(request, message);\n                defaultResponse.body(error);\n            }\n\n\n            AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(request);\n            Flowable<? extends MutableHttpResponse<?>> responsePublisher = filterPublisher(\n                    requestReference,\n                    Flowable.just(defaultResponse),\n                    ctx.channel().eventLoop(),\n                    false\n            );\n            subscribeToResponsePublisher(\n                    ctx,\n                    MediaType.APPLICATION_JSON_TYPE,\n                    requestReference,\n                    responsePublisher\n            );\n        }\n    }\n\n    private Optional<? extends FileCustomizableResponseType> matchFile(String path) {\n        Optional<URL> optionalUrl = staticResourceResolver.resolve(path);\n\n        if (optionalUrl.isPresent()) {\n            try {\n                URL url = optionalUrl.get();\n                if (url.getProtocol().equals(\"file\")) {\n                    File file = Paths.get(url.toURI()).toFile();\n                    if (file.exists() && !file.isDirectory() && file.canRead()) {\n                        return Optional.of(new NettySystemFileCustomizableResponseType(file));\n                    }\n                }\n\n                return Optional.of(new NettyStreamedFileCustomizableResponseType(url));\n            } catch (URISyntaxException e) {\n                //no-op\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    private void emitDefaultNotFoundResponse(ChannelHandlerContext ctx, io.micronaut.http.HttpRequest<?> request) {\n        MutableHttpResponse<Object> res = newNotFoundError(request);\n        AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(request);\n        Flowable<? extends MutableHttpResponse<?>> responsePublisher = filterPublisher(\n                requestReference,\n                Flowable.just(res),\n                ctx.channel().eventLoop(),\n                false\n        );\n        subscribeToResponsePublisher(\n                ctx,\n                MediaType.APPLICATION_JSON_TYPE,\n                requestReference,\n                responsePublisher\n        );\n    }\n\n    private MutableHttpResponse<Object> newNotFoundError(HttpRequest<?> request) {\n        JsonError error = newError(request, \"Page Not Found\");\n        return HttpResponse.notFound()\n                .body(error);\n    }\n\n    private JsonError newError(io.micronaut.http.HttpRequest<?> request, String message) {\n        URI uri = request.getUri();\n        return new JsonError(message)\n                .link(Link.SELF, Link.of(uri));\n    }\n\n    private MutableHttpResponse errorResultToResponse(Object result) {\n        MutableHttpResponse<?> response;\n        if (result == null) {\n            response = io.micronaut.http.HttpResponse.serverError();\n        } else if (result instanceof io.micronaut.http.HttpResponse) {\n            response = (MutableHttpResponse) result;\n        } else {\n            response = io.micronaut.http.HttpResponse.serverError()\n                .body(result);\n            MediaType.fromType(result.getClass()).ifPresent(response::contentType);\n        }\n        return response;\n    }\n\n    private void handleRouteMatch(\n        RouteMatch<?> route,\n        NettyHttpRequest<?> request,\n        ChannelHandlerContext context) {\n        // Set the matched route on the request\n        request.setMatchedRoute(route);\n\n        // try to fulfill the argument requirements of the route\n        route = requestArgumentSatisfier.fulfillArgumentRequirements(route, request, false);\n\n        // If it is not executable and the body is not required send back 400 - BAD REQUEST\n\n        // decorate the execution of the route so that it runs an async executor\n        request.setMatchedRoute(route);\n\n        // The request body is required, so at this point we must have a StreamedHttpRequest\n        io.netty.handler.codec.http.HttpRequest nativeRequest = request.getNativeRequest();\n        if (!route.isExecutable() && io.micronaut.http.HttpMethod.permitsRequestBody(request.getMethod()) && nativeRequest instanceof StreamedHttpRequest) {\n            Optional<MediaType> contentType = request.getContentType();\n            HttpContentProcessor<?> processor = contentType\n                .flatMap(type ->\n                    beanLocator.findBean(HttpContentSubscriberFactory.class,\n                        new ConsumesMediaTypeQualifier<>(type))\n                ).map(factory ->\n                    factory.build(request)\n                ).orElse(new DefaultHttpContentProcessor(request, serverConfiguration));\n\n            processor.subscribe(buildSubscriber(request, context, route));\n        } else {\n            context.read();\n            route = prepareRouteForExecution(route, request);\n            route.execute();\n        }\n    }\n\n    private boolean isJsonFormattable(Class javaType) {\n        return !(javaType == byte[].class\n                || ByteBuffer.class.isAssignableFrom(javaType)\n                || ByteBuf.class.isAssignableFrom(javaType));\n    }\n\n    private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> request,\n                                               ChannelHandlerContext context,\n                                               RouteMatch<?> finalRoute) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean alwaysAddContent = request.getContentType()\n                    .map(type -> type.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> routeMatch = finalRoute;\n            AtomicBoolean executed = new AtomicBoolean(false);\n            AtomicLong pressureRequested = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> subjects = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> dataReferences = new ConcurrentHashMap<>();\n            ConversionService conversionService = ConversionService.SHARED;\n            Subscription s;\n            LongConsumer onRequest = (num) -> pressureRequested.updateAndGet((p) -> {\n                long newVal = p - num;\n                if (newVal < 0) {\n                    s.request(num - p);\n                    return 0;\n                } else {\n                    return newVal;\n                }\n            });\n\n            Flowable processFlowable(Flowable flowable, Integer dataKey, boolean controlsFlow) {\n                if (controlsFlow) {\n                    flowable = flowable.doOnRequest(onRequest);\n                }\n                return flowable\n                        .doAfterTerminate(() -> {\n                            if (controlsFlow) {\n                                HttpDataReference dataReference = dataReferences.get(dataKey);\n                                dataReference.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription subscription) {\n                this.s = subscription;\n                subscription.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object message) {\n                boolean executed = this.executed.get();\n                if (message instanceof ByteBufHolder) {\n                    if (message instanceof HttpData) {\n                        HttpData data = (HttpData) message;\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Received HTTP Data for request [{}]: {}\", request, message);\n                        }\n\n                        String name = data.getName();\n                        Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);\n\n                        if (requiredInput.isPresent()) {\n                            Argument<?> argument = requiredInput.get();\n                            Supplier<Object> value;\n                            boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());\n                            boolean chunkedProcessing = false;\n\n                            if (isPublisher) {\n                                Integer dataKey = System.identityHashCode(data);\n                                HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {\n                                    return new HttpDataReference(data);\n                                });\n                                Argument typeVariable;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    typeVariable = Argument.of(PartData.class);\n                                } else {\n                                    typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                }\n                                Class typeVariableType = typeVariable.getType();\n\n                                UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());\n\n                                chunkedProcessing = PartData.class.equals(typeVariableType) ||\n                                        Publishers.isConvertibleToPublisher(typeVariableType) ||\n                                        ClassUtils.isJavaLangType(typeVariableType);\n\n                                if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                    boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                    if (streamingFileUpload) {\n                                        typeVariable = Argument.of(PartData.class);\n                                    } else {\n                                        typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                    }\n                                    dataReference.subject.getAndUpdate(subject -> {\n                                        if (subject == null) {\n                                            UnicastProcessor childSubject = UnicastProcessor.create();\n                                            Flowable flowable = processFlowable(childSubject, dataKey, true);\n                                            if (streamingFileUpload && data instanceof FileUpload) {\n                                                namedSubject.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) data,\n                                                        serverConfiguration.getMultipart(),\n                                                        ioExecutor,\n                                                        flowable));\n                                            } else {\n                                                namedSubject.onNext(flowable);\n                                            }\n\n                                            return childSubject;\n                                        }\n                                        return subject;\n                                    });\n\n                                }\n\n                                UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);\n\n                                Object part = data;\n\n                                if (chunkedProcessing) {\n                                    HttpDataReference.Component component = dataReference.addComponent((e) -> {\n                                        subject.onError(e);\n                                        s.cancel();\n                                    });\n                                    if (component == null) {\n                                        return;\n                                    }\n                                    part = new NettyPartData(dataReference, component);\n                                }\n\n                                if (data instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    dataReference.upload.getAndUpdate(upload -> {\n                                        if (upload == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) data,\n                                                    serverConfiguration.getMultipart(),\n                                                    ioExecutor,\n                                                    processFlowable(subject, dataKey, true));\n                                        }\n                                        return upload;\n                                    });\n                                }\n\n                                Optional<?> converted = conversionService.convert(part, typeVariable);\n\n                                converted.ifPresent(subject::onNext);\n\n                                if (data.isCompleted() && chunkedProcessing) {\n                                    subject.onComplete();\n                                }\n\n                                value = () -> {\n                                    StreamingFileUpload upload = dataReference.upload.get();\n                                    if (upload != null) {\n                                        return upload;\n                                    } else {\n                                        return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (data instanceof Attribute && !data.isCompleted()) {\n                                    request.addContent(data);\n                                    s.request(1);\n                                    return;\n                                } else {\n                                    value = () -> {\n                                        if (data.refCnt() > 0) {\n                                            return data;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!executed) {\n                                String argumentName = argument.getName();\n                                if (!routeMatch.isSatisfied(argumentName)) {\n                                    routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));\n                                }\n                                if (isPublisher && chunkedProcessing) {\n                                    //accounting for the previous request\n                                    pressureRequested.incrementAndGet();\n                                }\n                                if (routeMatch.isExecutable() || message instanceof LastHttpContent) {\n                                    executeRoute();\n                                    executed = true;\n                                }\n                            }\n\n                            if (alwaysAddContent) {\n                                request.addContent(data);\n                            }\n\n                            if (!executed || !chunkedProcessing) {\n                                s.request(1);\n                            }\n\n                        } else {\n                            request.addContent(data);\n                            s.request(1);\n                        }\n                    } else {\n                        request.addContent((ByteBufHolder) message);\n                        s.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) request).setBody(message);\n                    s.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                try {\n                    s.cancel();\n                    exceptionCaught(context, t);\n                } catch (Exception e) {\n                    // should never happen\n                    writeDefaultErrorResponse(context, request, e);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor subject: subjects.values()) {\n                    if (!subject.hasComplete()) {\n                        subject.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (executed.compareAndSet(false, true)) {\n                    try {\n                        routeMatch = prepareRouteForExecution(routeMatch, request);\n                        routeMatch.execute();\n                    } catch (Exception e) {\n                        context.pipeline().fireExceptionCaught(e);\n                    }\n                }\n            }\n        };\n    }\n\n    private RouteMatch<?> prepareRouteForExecution(RouteMatch<?> route, NettyHttpRequest<?> request) {\n        ChannelHandlerContext context = request.getChannelHandlerContext();\n        // Select the most appropriate Executor\n        ExecutorService executor;\n        if (route instanceof MethodBasedRouteMatch) {\n            executor = executorSelector.select((MethodBasedRouteMatch) route).orElse(context.channel().eventLoop());\n        } else {\n            executor = context.channel().eventLoop();\n        }\n\n        route = route.decorate(finalRoute -> {\n            MediaType defaultResponseMediaType = finalRoute\n                .getProduces()\n                .stream()\n                .findFirst()\n                .orElse(MediaType.APPLICATION_JSON_TYPE);\n\n\n            ReturnType<?> genericReturnType = finalRoute.getReturnType();\n            Class<?> javaReturnType = genericReturnType.getType();\n\n            AtomicReference<io.micronaut.http.HttpRequest<?>> requestReference = new AtomicReference<>(request);\n            boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);\n            boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;\n            boolean isSingle =\n                    isReactiveReturnType && Publishers.isSingle(javaReturnType) ||\n                            isResponsePublisher(genericReturnType, javaReturnType) ||\n                                isFuture ||\n                                    finalRoute.getAnnotationMetadata().booleanValue(Produces.class, \"single\").orElse(false);\n\n            // build the result emitter. This result emitter emits the response from a controller action\n            Flowable<?> resultEmitter = buildResultEmitter(\n                    context,\n                    finalRoute,\n                    requestReference,\n                    isReactiveReturnType,\n                    isSingle\n            );\n\n            // here we transform the result of the controller action into a MutableHttpResponse\n            Flowable<MutableHttpResponse<?>> routePublisher = resultEmitter.map((message) -> {\n                RouteMatch<?> routeMatch = finalRoute;\n                MutableHttpResponse<?> finalResponse = messageToResponse(routeMatch, message);\n                if (requestReference.get().getMethod().equals(HttpMethod.HEAD)) {\n                    finalResponse.getBody()\n                            .filter(ReferenceCounted.class::isInstance)\n                            .map(ReferenceCounted.class::cast)\n                            .ifPresent(ReferenceCounted::release);\n                    finalResponse.body(null);\n                }\n                HttpStatus status = finalResponse.getStatus();\n\n                if (status.getCode() >= HttpStatus.BAD_REQUEST.getCode()) {\n                    Class declaringType = ((MethodBasedRouteMatch) routeMatch).getDeclaringType();\n                    // handle re-mapping of errors\n                    Optional<RouteMatch<Object>> statusRoute = Optional.empty();\n                    // if declaringType is not null, this means its a locally marked method handler\n                    if (declaringType != null) {\n                        statusRoute = router.route(declaringType, status);\n                    }\n                    if (!statusRoute.isPresent()) {\n                        statusRoute = router.route(status);\n                    }\n                    io.micronaut.http.HttpRequest<?> httpRequest = requestReference.get();\n\n                    if (statusRoute.isPresent()) {\n                        routeMatch = statusRoute.get();\n                        httpRequest.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);\n\n                        routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);\n\n                        if (routeMatch.isExecutable()) {\n                            Object result;\n                            try {\n                                result = routeMatch.execute();\n                                finalResponse = messageToResponse(routeMatch, result);\n                            } catch (Throwable e) {\n                                throw new InternalServerException(\"Error executing status route [\" + routeMatch + \"]: \" + e.getMessage(), e);\n                            }\n                        } else {\n                            if (LOG.isWarnEnabled()) {\n                                LOG.warn(\"Matched status route [\" + routeMatch + \"] not executed because one or more arguments could not be bound. Returning the original response.\");\n                            }\n                        }\n                    }\n\n                }\n                finalResponse.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);\n                return finalResponse;\n            });\n\n            routePublisher = buildRoutePublisher(\n                    finalRoute.getDeclaringType(),\n                    genericReturnType,\n                    isReactiveReturnType,\n                    finalRoute.getAnnotationMetadata(),\n                    requestReference,\n                    routePublisher\n            );\n\n            // process the publisher through the available filters\n            Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                    requestReference,\n                    routePublisher,\n                    executor,\n                    false\n            );\n\n            boolean isStreaming = isReactiveReturnType && !isSingle;\n\n            Optional<Class<?>> javaPayloadType = genericReturnType.getFirstTypeVariable().map(arg -> arg.getType());\n\n            if (!isStreaming) {\n                if (HttpResponse.class.isAssignableFrom(javaReturnType)) {\n                    Optional<Argument<?>> generic = genericReturnType.getFirstTypeVariable();\n                    if (generic.isPresent()) {\n                        // Unwrap response type information\n                        Class genericType = generic.get().getType();\n                        isStreaming = Publishers.isConvertibleToPublisher(genericType) && !Publishers.isSingle(genericType);\n\n                        if (isStreaming) {\n                            javaPayloadType = generic.get().getFirstTypeVariable().map(Argument::getType);\n                        }\n                    }\n                }\n            }\n\n            Class finalJavaPayloadType = javaPayloadType.orElse(Object.class);\n            boolean finalIsStreaming = isStreaming;\n            filteredPublisher  = filteredPublisher.switchMap((response) -> {\n                Optional<?> responseBody = response.getBody();\n                if (responseBody.isPresent()) {\n                    Object body = responseBody.get();\n                    if (finalIsStreaming) {\n                        // handled downstream\n                        return Flowable.just(response);\n                    } else if (Publishers.isConvertibleToPublisher(body)) {\n                        Flowable<?> bodyFlowable = Publishers.convertPublisher(body, Flowable.class);\n                        Flowable<MutableHttpResponse<?>> bodyToResponse = bodyFlowable.map((bodyContent) ->\n                                setBodyContent(response, bodyContent)\n                        );\n                        return bodyToResponse.switchIfEmpty(Flowable.just(response));\n                    }\n                }\n\n                return Flowable.just(response);\n            });\n\n            if (!isStreaming) {\n                subscribeToResponsePublisher(context, defaultResponseMediaType, requestReference, filteredPublisher);\n            } else {\n                filteredPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {\n                    @Override\n                    protected void onComplete(MutableHttpResponse<?> response) {\n                        Optional<?> responseBody = response.getBody();\n                        @SuppressWarnings(\"unchecked\")\n                        Flowable<Object> bodyFlowable = responseBody.map(o -> Publishers.convertPublisher(o, Flowable.class)).orElse(Flowable.empty());\n\n                        NettyMutableHttpResponse nettyHttpResponse = (NettyMutableHttpResponse) response;\n                        FullHttpResponse nettyResponse = nettyHttpResponse.getNativeResponse();\n                        Optional<MediaType> specifiedMediaType = response.getContentType();\n                        MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);\n\n                        applyConfiguredHeaders(response.getHeaders());\n\n                        boolean isJson = responseMediaType.getExtension().equals(MediaType.EXTENSION_JSON) &&\n                                isJsonFormattable(finalJavaPayloadType);\n\n                        streamHttpContentChunkByChunk(\n                                context,\n                                request,\n                                nettyResponse,\n                                responseMediaType,\n                                isJson,\n                                bodyFlowable);\n                    }\n                });\n            }\n\n            return null;\n        });\n        return route;\n    }\n\n    private Flowable<MutableHttpResponse<?>> buildRoutePublisher(\n            Class<?> declaringType,\n            ReturnType<?> genericReturnType,\n            boolean isReactiveReturnType,\n            AnnotationMetadata annotationMetadata,\n            AtomicReference<HttpRequest<?>> requestReference,\n            Flowable<MutableHttpResponse<?>> routePublisher) {\n        // In the case of an empty reactive type we switch handling so that\n        // a 404 NOT_FOUND is returned\n        routePublisher = routePublisher.switchIfEmpty(Flowable.create((emitter) -> {\n            HttpRequest<?> httpRequest = requestReference.get();\n            MutableHttpResponse<?> response;\n            Class<?> javaReturnType = genericReturnType.getType();\n            boolean isVoid = javaReturnType == void.class ||\n                    Completable.class.isAssignableFrom(javaReturnType) ||\n                    (isReactiveReturnType && genericReturnType.getFirstTypeVariable()\n                            .filter(arg -> arg.getType() == Void.class).isPresent());\n\n            if (isVoid) {\n                // void return type with no response, nothing else to do\n                response = forStatus(annotationMetadata);\n            } else {\n                // handle re-mapping of errors\n                Optional<RouteMatch<Object>> statusRoute = Optional.empty();\n                // if declaringType is not null, this means its a locally marked method handler\n                if (declaringType != null) {\n                    statusRoute = router.route(declaringType, HttpStatus.NOT_FOUND);\n                }\n                if (!statusRoute.isPresent()) {\n                    statusRoute = router.route(HttpStatus.NOT_FOUND);\n                }\n\n                if (statusRoute.isPresent()) {\n                    RouteMatch<?> newRoute = requestArgumentSatisfier.fulfillArgumentRequirements(statusRoute.get(), httpRequest, true);\n\n                    if (newRoute.isExecutable()) {\n                        try {\n                            Object result = newRoute.execute();\n                            response = messageToResponse(newRoute, result);\n                        } catch (Throwable e) {\n                            emitter.onError(new InternalServerException(\"Error executing status route [\" + newRoute + \"]: \" + e.getMessage(), e));\n                            return;\n                        }\n\n                    } else {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(\"Matched status route [\" + newRoute + \"] not executed because one or more arguments could not be bound. Returning a default response.\");\n                        }\n                        response = newNotFoundError(httpRequest);\n                    }\n                    response.setAttribute(HttpAttributes.ROUTE_MATCH, newRoute);\n                } else {\n                    response = newNotFoundError(httpRequest);\n                }\n            }\n\n            try {\n                emitter.onNext(response);\n                emitter.onComplete();\n            } catch (Throwable e) {\n                emitter.onError(new InternalServerException(\"Error executing Error route [\" + response.getStatus() + \"]: \" + e.getMessage(), e));\n            }\n        }, BackpressureStrategy.ERROR));\n        return routePublisher;\n    }\n\n    private void subscribeToResponsePublisher(\n            ChannelHandlerContext context,\n            MediaType defaultResponseMediaType,\n            AtomicReference<HttpRequest<?>> requestReference,\n            Flowable<? extends MutableHttpResponse<?>> finalPublisher) {\n        finalPublisher =  finalPublisher.map((response) -> {\n            Optional<MediaType> specifiedMediaType = response.getContentType();\n            MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);\n\n            applyConfiguredHeaders(response.getHeaders());\n\n            Optional<?> responseBody = response.getBody();\n            if (responseBody.isPresent()) {\n\n                Object body = responseBody.get();\n\n                Optional<NettyCustomizableResponseTypeHandler> typeHandler = customizableResponseTypeHandlerRegistry\n                        .findTypeHandler(body.getClass());\n                if (typeHandler.isPresent()) {\n                    NettyCustomizableResponseTypeHandler th = typeHandler.get();\n                    setBodyContent(response, new NettyCustomizableResponseTypeHandlerInvoker(th, body));\n                    return response;\n                }\n\n                if (specifiedMediaType.isPresent())  {\n\n                    Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(responseMediaType, body.getClass());\n                    if (registeredCodec.isPresent()) {\n                        MediaTypeCodec codec = registeredCodec.get();\n                        return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);\n                    }\n                }\n\n                Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(defaultResponseMediaType, body.getClass());\n                if (registeredCodec.isPresent()) {\n                    MediaTypeCodec codec = registeredCodec.get();\n                    return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);\n                }\n\n                MediaTypeCodec defaultCodec = new TextPlainCodec(serverConfiguration.getDefaultCharset());\n\n                return encodeBodyWithCodec(response, body, defaultCodec, responseMediaType,  context, requestReference);\n            } else {\n                return response;\n            }\n        });\n\n        finalPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {\n            @Override\n            protected void onComplete(MutableHttpResponse<?> message) {\n                writeFinalNettyResponse(message, requestReference, context);\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                exceptionCaughtInternal(context, t, (NettyHttpRequest) requestReference.get(), false);\n            }\n        });\n    }\n\n    private void writeFinalNettyResponse(MutableHttpResponse<?> message, AtomicReference<HttpRequest<?>> requestReference, ChannelHandlerContext context) {\n        NettyMutableHttpResponse nettyHttpResponse = (NettyMutableHttpResponse) message;\n        FullHttpResponse nettyResponse = nettyHttpResponse.getNativeResponse();\n\n        HttpRequest<?> httpRequest = requestReference.get();\n        io.netty.handler.codec.http.HttpHeaders nettyHeaders = nettyResponse.headers();\n\n        // default Connection header if not set explicitly\n        if (!nettyHeaders.contains(HttpHeaderNames.CONNECTION)) {\n            boolean expectKeepAlive = nettyResponse.protocolVersion().isKeepAliveDefault() || httpRequest.getHeaders().isKeepAlive();\n            HttpStatus status = nettyHttpResponse.status();\n            if (!expectKeepAlive || status.getCode() > 299) {\n                nettyHeaders.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            } else {\n                nettyHeaders.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            }\n        }\n\n        final Object body = message.body();\n        if (body instanceof NettyCustomizableResponseTypeHandlerInvoker) {\n            NettyCustomizableResponseTypeHandlerInvoker handler = (NettyCustomizableResponseTypeHandlerInvoker) body;\n            handler.invoke(httpRequest, nettyHttpResponse, context);\n        } else {\n            // default to Transfer-Encoding: chunked if Content-Length not set or not already set\n            if (!nettyHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) && !nettyHeaders.contains(HttpHeaderNames.TRANSFER_ENCODING)) {\n                nettyHeaders.add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            }\n            // close handled by HttpServerKeepAliveHandler\n            context.writeAndFlush(nettyResponse);\n            context.read();\n        }\n    }\n\n    private MutableHttpResponse<?> encodeBodyWithCodec(MutableHttpResponse<?> response,\n                                                       Object body,\n                                                       MediaTypeCodec codec,\n                                                       MediaType mediaType,\n                                                       ChannelHandlerContext context,\n                                                       AtomicReference<HttpRequest<?>> requestReference) {\n        ByteBuf byteBuf;\n        try {\n            byteBuf = encodeBodyAsByteBuf(body, codec, context, requestReference);\n            int len = byteBuf.readableBytes();\n            MutableHttpHeaders headers = response.getHeaders();\n            if (!headers.contains(HttpHeaders.CONTENT_TYPE)) {\n                headers.add(HttpHeaderNames.CONTENT_TYPE, mediaType);\n            }\n            headers.remove(HttpHeaders.CONTENT_LENGTH);\n            headers.add(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(len));\n\n            setBodyContent(response, byteBuf);\n            return response;\n        } catch (LinkageError e) {\n            // rxjava swallows linkage errors for some reasons so if one occurs, rethrow as a internal error\n            throw new InternalServerException(\"Fatal error encoding bytebuf: \" + e.getMessage() , e);\n        }\n    }\n\n    private MutableHttpResponse<?> setBodyContent(MutableHttpResponse response, Object bodyContent) {\n        @SuppressWarnings(\"unchecked\")\n        MutableHttpResponse<?> res = response.body(bodyContent);\n        return res;\n    }\n\n    private ByteBuf encodeBodyAsByteBuf(Object body, MediaTypeCodec codec, ChannelHandlerContext context, AtomicReference<HttpRequest<?>> requestReference) {\n        ByteBuf byteBuf;\n        if (body instanceof ByteBuf) {\n            byteBuf = (ByteBuf) body;\n        } else if (body instanceof ByteBuffer) {\n            ByteBuffer byteBuffer = (ByteBuffer) body;\n            Object nativeBuffer = byteBuffer.asNativeBuffer();\n            if (nativeBuffer instanceof ByteBuf) {\n                byteBuf = (ByteBuf) nativeBuffer;\n            } else {\n                byteBuf = Unpooled.wrappedBuffer(byteBuffer.asNioBuffer());\n            }\n        } else if (body instanceof byte[]) {\n            byteBuf = Unpooled.wrappedBuffer((byte[]) body);\n\n        } else if (body instanceof Writable) {\n            byteBuf = context.alloc().ioBuffer(128);\n            ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf);\n            Writable writable = (Writable) body;\n            try {\n                writable.writeTo(outputStream, requestReference.get().getCharacterEncoding());\n            } catch (IOException e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(e.getMessage());\n                }\n            }\n\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Encoding emitted response object [{}] using codec: {}\", body, codec);\n            }\n            byteBuf = (ByteBuf) codec.encode(body, new NettyByteBufferFactory(context.alloc())).asNativeBuffer();\n        }\n        return byteBuf;\n    }\n\n    // builds the result emitter for a given route action\n    private Flowable<?> buildResultEmitter(\n            ChannelHandlerContext context, RouteMatch<?> finalRoute,\n            AtomicReference<HttpRequest<?>> requestReference,\n            boolean isReactiveReturnType,\n            boolean isSingleResult) {\n        Flowable<?> resultEmitter;\n        if (isReactiveReturnType) {\n            // if the return type is reactive, execute the action and obtain the Observable\n            try {\n                if (isSingleResult) {\n                    // for a single result we are fine as is\n                    resultEmitter = Flowable.defer(() -> {\n                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;\n                        Object result = routeMatch.execute();\n                        return Publishers.convertPublisher(result, Publisher.class);\n                    });\n                } else {\n                    // for a streaming response we wrap the result on an HttpResponse so that a single result is received\n                    // then the result can be streamed chunk by chunk\n                    resultEmitter = Flowable.create((emitter) -> {\n                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;\n                        Object result = routeMatch.execute();\n                        MutableHttpResponse<Object> chunkedResponse = HttpResponse.ok(result);\n                        chunkedResponse.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n                        emitter.onNext(chunkedResponse);\n                        emitter.onComplete();\n                        // should be no back pressure\n                    }, BackpressureStrategy.ERROR);\n                }\n            } catch (Throwable e) {\n                resultEmitter = Flowable.error(new InternalServerException(\"Error executing route [\" + finalRoute + \"]: \" + e.getMessage(), e));\n            }\n        } else {\n            // for non-reactive results we build flowable that executes the\n            // route\n            resultEmitter = Flowable.create((emitter) -> {\n                HttpRequest<?> httpRequest = requestReference.get();\n                RouteMatch<?> routeMatch = finalRoute;\n                if (!routeMatch.isExecutable()) {\n                    routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);\n                }\n                Object result;\n                try {\n                    result = routeMatch.execute();\n                } catch (Throwable e) {\n                    emitter.onError(e);\n                    return;\n                }\n\n                if (result instanceof Optional) {\n                    result = ((Optional<?>) result).orElse(null);\n                }\n\n                if (result == null) {\n                    // empty flowable\n                    emitter.onComplete();\n                } else {\n                    // emit the result\n                    if (result instanceof Writable) {\n                        ByteBuf byteBuf = context.alloc().ioBuffer(128);\n                        ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf);\n                        Writable writable = (Writable) result;\n                        writable.writeTo(outputStream, requestReference.get().getCharacterEncoding());\n                        emitter.onNext(byteBuf);\n                    } else {\n                        emitter.onNext(result);\n                    }\n                    emitter.onComplete();\n                }\n\n                // should be no back pressure\n            }, BackpressureStrategy.ERROR);\n        }\n        return resultEmitter;\n    }\n\n    private MutableHttpResponse<?> messageToResponse(RouteMatch<?> finalRoute, Object message) {\n        MutableHttpResponse<?> response;\n        if (message instanceof HttpResponse) {\n            response = ConversionService.SHARED.convert(message, NettyMutableHttpResponse.class)\n                    .orElseThrow(() -> new InternalServerException(\"Emitted response is not mutable\"));\n        } else {\n            if (message instanceof HttpStatus) {\n                response = HttpResponse.status((HttpStatus) message);\n            } else {\n                response = forStatus(finalRoute.getAnnotationMetadata()).body(message);\n            }\n        }\n        return response;\n    }\n\n    private MutableHttpResponse<Object> forStatus(AnnotationMetadata annotationMetadata) {\n        HttpStatus status = HttpStatus.OK;\n\n        if (annotationMetadata.hasAnnotation(Status.class)) {\n            status = annotationMetadata.stringValue(Status.class).map(HttpStatus::valueOf).orElse(status);\n        }\n\n        return HttpResponse.status(status);\n    }\n\n    private boolean isResponsePublisher(ReturnType<?> genericReturnType, Class<?> javaReturnType) {\n        return Publishers.isConvertibleToPublisher(javaReturnType) && genericReturnType.getFirstTypeVariable().map(arg -> HttpResponse.class.isAssignableFrom(arg.getType())).orElse(false);\n    }\n\n    private Flowable<? extends MutableHttpResponse<?>> filterPublisher(\n            AtomicReference<HttpRequest<?>> requestReference,\n            Publisher<MutableHttpResponse<?>> routePublisher,\n            ExecutorService executor,\n            boolean skipOncePerRequest) {\n        Publisher<? extends io.micronaut.http.MutableHttpResponse<?>> finalPublisher;\n        List<HttpFilter> filters = new ArrayList<>(router.findFilters(requestReference.get()));\n        if (skipOncePerRequest) {\n            filters.removeIf(filter -> filter instanceof OncePerRequestHttpServerFilter);\n        }\n        if (!filters.isEmpty()) {\n            // make the action executor the last filter in the chain\n            filters.add((HttpServerFilter) (req, chain) -> routePublisher);\n\n            AtomicInteger integer = new AtomicInteger();\n            int len = filters.size();\n            ServerFilterChain filterChain = new ServerFilterChain() {\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public Publisher<MutableHttpResponse<?>> proceed(io.micronaut.http.HttpRequest<?> request) {\n                    int pos = integer.incrementAndGet();\n                    if (pos > len) {\n                        throw new IllegalStateException(\"The FilterChain.proceed(..) method should be invoked exactly once per filter execution. The method has instead been invoked multiple times by an erroneous filter definition.\");\n                    }\n                    HttpFilter httpFilter = filters.get(pos);\n                    return (Publisher<MutableHttpResponse<?>>) httpFilter.doFilter(requestReference.getAndSet(request), this);\n                }\n            };\n            HttpFilter httpFilter = filters.get(0);\n            Publisher<? extends HttpResponse<?>> resultingPublisher = httpFilter.doFilter(requestReference.get(), filterChain);\n            finalPublisher = (Publisher<? extends MutableHttpResponse<?>>) resultingPublisher;\n        } else {\n            finalPublisher = routePublisher;\n        }\n\n        // Handle the scheduler to subscribe on\n        if (finalPublisher instanceof Flowable) {\n            return ((Flowable<MutableHttpResponse<?>>) finalPublisher)\n                    .subscribeOn(Schedulers.from(executor));\n        } else {\n            return Flowable.fromPublisher(finalPublisher)\n                    .subscribeOn(Schedulers.from(executor));\n        }\n    }\n\n    private void streamHttpContentChunkByChunk(\n        ChannelHandlerContext context,\n        NettyHttpRequest<?> request,\n        FullHttpResponse nativeResponse,\n        MediaType mediaType,\n        boolean isJson,\n        Publisher<Object> publisher) {\n\n        NettyByteBufferFactory byteBufferFactory = new NettyByteBufferFactory(context.alloc());\n\n        Publisher<HttpContent> httpContentPublisher = Publishers.map(publisher, new Function<Object, HttpContent>() {\n            boolean first = true;\n\n            @Override\n            public HttpContent apply(Object message) {\n                HttpContent httpContent;\n                if (message instanceof ByteBuf) {\n                    httpContent = new DefaultHttpContent((ByteBuf) message);\n                } else if (message instanceof ByteBuffer) {\n                    ByteBuffer byteBuffer = (ByteBuffer) message;\n                    Object nativeBuffer = byteBuffer.asNativeBuffer();\n                    if (nativeBuffer instanceof ByteBuf) {\n                        httpContent = new DefaultHttpContent((ByteBuf) nativeBuffer);\n                    } else {\n                        httpContent = new DefaultHttpContent(Unpooled.copiedBuffer(byteBuffer.asNioBuffer()));\n                    }\n                } else if (message instanceof byte[]) {\n                    httpContent = new DefaultHttpContent(Unpooled.copiedBuffer((byte[]) message));\n                } else if (message instanceof HttpContent) {\n                    httpContent = (HttpContent) message;\n                } else {\n\n                    MediaTypeCodec codec = mediaTypeCodecRegistry.findCodec(mediaType, message.getClass()).orElse(\n                        new TextPlainCodec(serverConfiguration.getDefaultCharset()));\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Encoding emitted response object [{}] using codec: {}\", message, codec);\n                    }\n                    ByteBuffer encoded = codec.encode(message, byteBufferFactory);\n                    httpContent = new DefaultHttpContent((ByteBuf) encoded.asNativeBuffer());\n                }\n                if (!isJson || first) {\n                    first = false;\n                    return httpContent;\n                } else {\n                    return HttpContentUtil.prefixComma(httpContent);\n                }\n            }\n        });\n\n        if (isJson && !Publishers.isSingle(publisher.getClass())) {\n            // if the Publisher is returning JSON then in order for it to be valid JSON for each emitted element\n            // we must wrap the JSON in array and delimit the emitted items\n            httpContentPublisher = Flowable.concat(\n                Flowable.fromCallable(HttpContentUtil::openBracket),\n                httpContentPublisher,\n                Flowable.fromCallable(HttpContentUtil::closeBracket)\n            );\n        }\n\n        if (mediaType.equals(MediaType.TEXT_EVENT_STREAM_TYPE)) {\n            httpContentPublisher = Publishers.onComplete(httpContentPublisher, () -> {\n                CompletableFuture<Void> future = new CompletableFuture<>();\n                if (request == null || !request.getHeaders().isKeepAlive()) {\n                    if (context.channel().isOpen()) {\n                        context.pipeline()\n                            .writeAndFlush(new DefaultLastHttpContent())\n                            .addListener(f -> {\n                                    if (f.isSuccess()) {\n                                        future.complete(null);\n                                    } else {\n                                        future.completeExceptionally(f.cause());\n                                    }\n                                }\n                            );\n                    }\n                }\n                return future;\n            });\n        }\n\n        httpContentPublisher = Publishers.then(httpContentPublisher, httpContent -> {\n            // once an http content is written, read the next item if it is available\n            context.read();\n        });\n\n        DelegateStreamedHttpResponse streamedResponse = new DelegateStreamedHttpResponse(nativeResponse, httpContentPublisher);\n        io.netty.handler.codec.http.HttpHeaders headers = streamedResponse.headers();\n        headers.add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n        headers.add(HttpHeaderNames.CONTENT_TYPE, mediaType);\n        context.writeAndFlush(streamedResponse);\n        context.read();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void writeDefaultErrorResponse(ChannelHandlerContext ctx, NettyHttpRequest nettyHttpRequest, Throwable cause) {\n        logException(cause);\n\n        MutableHttpResponse<?> error = io.micronaut.http.HttpResponse.serverError()\n                .body(new JsonError(\"Internal Server Error: \" + cause.getMessage()));\n        subscribeToResponsePublisher(\n                ctx,\n                MediaType.APPLICATION_JSON_TYPE,\n                new AtomicReference<>(nettyHttpRequest),\n                Flowable.just(error)\n        );\n    }\n\n    private void logException(Throwable cause) {\n        //handling connection reset by peer exceptions\n        String message = cause.getMessage();\n        if (cause instanceof IOException && message != null && IGNORABLE_ERROR_MESSAGE.matcher(message).matches()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Swallowed an IOException caused by client connectivity: \" + cause.getMessage(), cause);\n            }\n        } else {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Unexpected error occurred: \" + cause.getMessage(), cause);\n            }\n        }\n    }\n\n    private void applyConfiguredHeaders(MutableHttpHeaders headers) {\n        if (serverConfiguration.isDateHeader() && !headers.contains(\"Date\")) {\n            headers.date(LocalDateTime.now());\n        }\n        serverConfiguration.getServerHeader().ifPresent((server) -> {\n            if (!headers.contains(\"Server\")) {\n                headers.add(\"Server\", server);\n            }\n        });\n    }\n\n    /**\n     * Used as a handle to the {@link NettyCustomizableResponseTypeHandler}.\n     */\n    private static class NettyCustomizableResponseTypeHandlerInvoker {\n        final NettyCustomizableResponseTypeHandler handler;\n        final Object body;\n\n        NettyCustomizableResponseTypeHandlerInvoker(NettyCustomizableResponseTypeHandler handler, Object body) {\n            this.handler = handler;\n            this.body = body;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        void invoke(HttpRequest<?> request, NettyMutableHttpResponse response, ChannelHandlerContext channelHandlerContext) {\n            this.handler.handle(body, request, response, channelHandlerContext);\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.binders;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.core.async.subscriber.CompletionAwareSubscriber;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.DefaultBodyAnnotationBinder;\nimport io.micronaut.http.bind.binders.NonBlockingBodyArgumentBinder;\nimport io.micronaut.http.server.netty.DefaultHttpContentProcessor;\nimport io.micronaut.http.server.netty.HttpContentProcessor;\nimport io.micronaut.http.server.netty.HttpContentSubscriberFactory;\nimport io.micronaut.http.server.netty.NettyHttpRequest;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport org.reactivestreams.Subscription;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\n\n/**\n * A {@link NonBlockingBodyArgumentBinder} that handles {@link CompletableFuture} instances.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n@Internal\npublic class CompletableFutureBodyBinder extends DefaultBodyAnnotationBinder<CompletableFuture>\n    implements NonBlockingBodyArgumentBinder<CompletableFuture> {\n\n    private final BeanLocator beanLocator;\n    private final HttpServerConfiguration httpServerConfiguration;\n\n    /**\n     * @param beanLocator             The bean locator\n     * @param httpServerConfiguration The Http server configuration\n     * @param conversionService       The conversion service\n     */\n    public CompletableFutureBodyBinder(BeanLocator beanLocator, HttpServerConfiguration httpServerConfiguration, ConversionService conversionService) {\n        super(conversionService);\n        this.beanLocator = beanLocator;\n        this.httpServerConfiguration = httpServerConfiguration;\n    }\n\n    @Override\n    public Argument<CompletableFuture> argumentType() {\n        return Argument.of(CompletableFuture.class);\n    }\n\n    @Override\n    public BindingResult<CompletableFuture> bind(ArgumentConversionContext<CompletableFuture> context, HttpRequest<?> source) {\n        if (source instanceof NettyHttpRequest) {\n            NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) source;\n            io.netty.handler.codec.http.HttpRequest nativeRequest = ((NettyHttpRequest) source).getNativeRequest();\n            if (nativeRequest instanceof StreamedHttpRequest) {\n\n                CompletableFuture future = new CompletableFuture();\n                Optional<MediaType> contentType = source.getContentType();\n                HttpContentProcessor<?> processor = contentType\n                    .flatMap(type -> beanLocator.findBean(HttpContentSubscriberFactory.class, new ConsumesMediaTypeQualifier<>(type)))\n                    .map(factory -> factory.build(nettyHttpRequest))\n                    .orElse(new DefaultHttpContentProcessor(nettyHttpRequest, httpServerConfiguration));\n\n                processor.subscribe(new CompletionAwareSubscriber<Object>() {\n                    @Override\n                    protected void doOnSubscribe(Subscription subscription) {\n                        subscription.request(1);\n                    }\n\n                    @Override\n                    protected void doOnNext(Object message) {\n                        nettyHttpRequest.setBody(message);\n                        subscription.request(1);\n                    }\n\n                    @Override\n                    protected void doOnError(Throwable t) {\n                        future.completeExceptionally(t);\n                    }\n\n                    @Override\n                    protected void doOnComplete() {\n                        Optional<Argument<?>> firstTypeParameter = context.getFirstTypeVariable();\n                        Optional body = nettyHttpRequest.getBody();\n                        if (body.isPresent()) {\n\n                            if (firstTypeParameter.isPresent()) {\n                                Argument<?> arg = firstTypeParameter.get();\n                                Class targetType = arg.getType();\n                                Optional converted = conversionService.convert(body.get(), context.with(arg));\n                                if (converted.isPresent()) {\n                                    future.complete(converted.get());\n                                } else {\n                                    future.completeExceptionally(new IllegalArgumentException(\"Cannot bind JSON to argument type: \" + targetType.getName()));\n                                }\n                            } else {\n                                future.complete(body.get());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                });\n\n                return () -> Optional.of(future);\n            } else {\n                return BindingResult.EMPTY;\n            }\n        } else {\n            return BindingResult.EMPTY;\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.binders;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.core.async.subscriber.TypedSubscriber;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionError;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.convert.exceptions.ConversionErrorException;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.DefaultBodyAnnotationBinder;\nimport io.micronaut.http.bind.binders.NonBlockingBodyArgumentBinder;\nimport io.micronaut.http.server.netty.*;\nimport io.micronaut.web.router.exceptions.UnsatisfiedRouteException;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport io.netty.buffer.ByteBufHolder;\nimport io.netty.buffer.EmptyByteBuf;\nimport io.netty.util.ReferenceCounted;\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscription;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\n\n/**\n * A {@link io.micronaut.http.annotation.Body} argument binder for a reactive streams {@link Publisher}.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n@Internal\npublic class PublisherBodyBinder extends DefaultBodyAnnotationBinder<Publisher> implements NonBlockingBodyArgumentBinder<Publisher> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyHttpServer.class);\n\n    private final BeanLocator beanLocator;\n    private final HttpServerConfiguration httpServerConfiguration;\n\n    /**\n     * @param conversionService       The conversion service\n     * @param beanLocator             The bean locator\n     * @param httpServerConfiguration The Http server configuration\n     */\n    public PublisherBodyBinder(ConversionService conversionService, BeanLocator beanLocator, HttpServerConfiguration httpServerConfiguration) {\n        super(conversionService);\n        this.beanLocator = beanLocator;\n        this.httpServerConfiguration = httpServerConfiguration;\n    }\n\n    @Override\n    public Argument<Publisher> argumentType() {\n        return Argument.of(Publisher.class);\n    }\n\n    @Override\n    public BindingResult<Publisher> bind(ArgumentConversionContext<Publisher> context, HttpRequest<?> source) {\n        if (source instanceof NettyHttpRequest) {\n            NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) source;\n            io.netty.handler.codec.http.HttpRequest nativeRequest = nettyHttpRequest.getNativeRequest();\n            if (nativeRequest instanceof StreamedHttpRequest) {\n                Optional<MediaType> contentType = source.getContentType();\n                Argument<?> targetType = context.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                HttpContentProcessor<?> processor = contentType\n                    .flatMap(type -> beanLocator.findBean(HttpContentSubscriberFactory.class, new ConsumesMediaTypeQualifier<>(type)))\n                    .map(factory -> factory.build(nettyHttpRequest))\n                    .orElse(new DefaultHttpContentProcessor(nettyHttpRequest, httpServerConfiguration));\n\n                //noinspection unchecked\n                return () -> Optional.of(subscriber -> processor.subscribe(new TypedSubscriber<Object>((Argument) context.getArgument()) {\n\n                    Subscription s;\n\n                    @Override\n                    protected void doOnSubscribe(Subscription subscription) {\n                        this.s = subscription;\n                        subscriber.onSubscribe(subscription);\n                    }\n\n                    @Override\n                    protected void doOnNext(Object message) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Server received streaming message for argument [{}]: {}\", context.getArgument(), message);\n                        }\n                        ArgumentConversionContext<?> conversionContext = context.with(targetType);\n                        if (message instanceof ByteBufHolder) {\n                            message = ((ByteBufHolder) message).content();\n                            if (message instanceof EmptyByteBuf) {\n                                return;\n                            }\n                        }\n\n                        Optional<?> converted = conversionService.convert(message, conversionContext);\n\n                        if (converted.isPresent()) {\n                            subscriber.onNext(converted.get());\n                        } else {\n\n                            try {\n                                Optional<ConversionError> lastError = conversionContext.getLastError();\n                                if (lastError.isPresent()) {\n                                    if (LOG.isDebugEnabled()) {\n                                        LOG.debug(\"Cannot convert message for argument [\" + context.getArgument() + \"] and value: \" + message, lastError.get());\n                                    }\n                                    subscriber.onError(new ConversionErrorException(context.getArgument(), lastError.get()));\n                                } else {\n                                    if (LOG.isDebugEnabled()) {\n                                        LOG.debug(\"Cannot convert message for argument [{}] and value: {}\", context.getArgument(), message);\n                                    }\n                                    subscriber.onError(new UnsatisfiedRouteException(context.getArgument()));\n                                }\n                            } finally {\n                                s.cancel();\n                            }\n                        }\n\n                        if (message instanceof ReferenceCounted) {\n                            ((ReferenceCounted) message).release();\n                        }\n                    }\n\n                    @Override\n                    protected void doOnError(Throwable t) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Server received error for argument [\" + context.getArgument() + \"]: \" + t.getMessage(), t);\n                        }\n                        try {\n                            subscriber.onError(t);\n                        } finally {\n                            s.cancel();\n                        }\n                    }\n\n                    @Override\n                    protected void doOnComplete() {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Done receiving messages for argument: {}\", context.getArgument());\n                        }\n                        subscriber.onComplete();\n                    }\n\n                }));\n            }\n        }\n        return BindingResult.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.cors\n\nimport io.micronaut.core.type.Argument\nimport io.micronaut.http.HttpHeaders\nimport io.micronaut.http.HttpMethod\nimport io.micronaut.http.HttpRequest\nimport io.micronaut.http.HttpResponse\nimport io.micronaut.http.HttpStatus\nimport io.micronaut.http.MutableHttpResponse\nimport io.micronaut.http.server.cors.CorsFilter\nimport io.micronaut.http.server.cors.CorsOriginConfiguration\nimport io.micronaut.http.server.HttpServerConfiguration\nimport spock.lang.Specification\n\nimport static io.micronaut.http.HttpHeaders.*\n\nclass CorsFilterSpec extends Specification {\n\n    CorsFilter buildCorsHandler(HttpServerConfiguration.CorsConfiguration config) {\n        new CorsFilter(config ?: new HttpServerConfiguration.CorsConfiguration())\n    }\n\n    void \"test handleRequest for non CORS request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.empty()\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through\"\n        !result.isPresent()\n    }\n\n    void \"test handleRequest with no matching configuration\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because no configuration matches the origin\"\n        2 * headers.getOrigin() >> Optional.of('http://www.bar.com')\n        !result.isPresent()\n    }\n\n    void \"test handleRequest with regex matching configuration\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = regex\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because no configuration matches the origin\"\n        2 * headers.getOrigin() >> Optional.of(origin)\n        !result.isPresent()\n\n        where:\n        regex                               | origin\n        ['.*']                              | 'http://www.bar.com'\n        ['^http://www\\\\.(foo|bar)\\\\.com$']  | 'http://www.bar.com'\n        ['^http://www\\\\.(foo|bar)\\\\.com$']  | 'http://www.foo.com'\n        ['.*bar$', '.*foo$']                | 'asdfasdf foo'\n        ['.*bar$', '.*foo$']                | 'asdfasdf bar'\n    }\n\n    void \"test handleRequest with disallowed method\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is rejected because the method is not in the list of allowedMethods\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * request.getMethod() >> HttpMethod.POST\n        result.isPresent()\n        result.get().status == HttpStatus.FORBIDDEN\n    }\n\n    void \"test handleRequest with disallowed header (not preflight)\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because allowed headers are only checked for preflight requests\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * request.getMethod() >> HttpMethod.GET\n        !result.isPresent()\n        0 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String))\n    }\n\n    void \"test preflight handleRequest with disallowed header\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        originConfig.allowedHeaders = ['foo']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        request.getMethod() >> HttpMethod.OPTIONS\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is rejected because bar is not allowed\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n        1 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> ['foo', 'bar']\n        result.get().status == HttpStatus.FORBIDDEN\n    }\n\n    void \"test preflight handleRequest with allowed header\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        originConfig.allowedHeaders = ['foo', 'bar']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        request.getMethod() >> HttpMethod.OPTIONS\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is successful\"\n        4 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        2 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['foo'])\n        result.get().status == HttpStatus.OK\n    }\n\n    void \"test handleResponse when configuration not present\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the response is not modified\"\n        2 * headers.getOrigin() >> Optional.of('http://www.bar.com')\n        notThrown(NullPointerException)\n        !result.isPresent()\n    }\n\n    void \"test handleResponse for normal request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then:\n        !result.isPresent()\n\n        when:\n        MutableHttpResponse response = HttpResponse.ok()\n        corsHandler.handleResponse(request, response)\n\n        then: \"the response is not modified\"\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_EXPOSE_HEADERS) == ['Foo-Header', 'Bar-Header' ]// Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n    }\n\n    void \"test handleResponse for preflight request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n        request.getMethod() >> HttpMethod.OPTIONS\n\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        HttpResponse response = corsHandler.handleRequest(request).get()\n\n        then: \"the response is not modified\"\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['X-Header', 'Y-Header'])\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_EXPOSE_HEADERS) == ['Foo-Header', 'Bar-Header'] // Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_ALLOW_HEADERS) == ['X-Header', 'Y-Header'] // Allow headers are echo'd from the request\n        response.getHeaders().get(ACCESS_CONTROL_MAX_AGE) == '1800' // Max age is set from config\n    }\n\n    void \"test handleResponse for preflight request with single header\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration(singleHeader: true)\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n        request.getMethod() >> HttpMethod.OPTIONS\n\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        HttpResponse response = corsHandler.handleRequest(request).get()\n\n        then: \"the response is not modified\"\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List,String)) >> Optional.of(['X-Header', 'Y-Header'])\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class) >> Optional.of(HttpMethod.GET)\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().get(ACCESS_CONTROL_EXPOSE_HEADERS) == 'Foo-Header,Bar-Header' // Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_HEADERS) == 'X-Header,Y-Header' // Allow headers are echo'd from the request\n        response.getHeaders().get(ACCESS_CONTROL_MAX_AGE) == '1800' // Max age is set from config\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.cors;\n\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_MAX_AGE;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD;\nimport static io.micronaut.http.HttpHeaders.ORIGIN;\nimport static io.micronaut.http.HttpHeaders.VARY;\n\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.order.Ordered;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.http.HttpHeaders;\nimport io.micronaut.http.HttpMethod;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.HttpResponse;\nimport io.micronaut.http.HttpStatus;\nimport io.micronaut.http.MutableHttpResponse;\nimport io.micronaut.http.annotation.Filter;\nimport io.micronaut.http.filter.HttpServerFilter;\nimport io.micronaut.http.filter.ServerFilterChain;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport org.reactivestreams.Publisher;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Responsible for handling CORS requests and responses.\n *\n * @author James Kleeh\n * @author Graeme Rocher\n * @since 1.0\n */\n@Filter(\"/**\")\npublic class CorsFilter implements HttpServerFilter {\n\n    protected final HttpServerConfiguration.CorsConfiguration corsConfiguration;\n\n    /**\n     * @param corsConfiguration The {@link CorsOriginConfiguration} instance\n     */\n    public CorsFilter(HttpServerConfiguration.CorsConfiguration corsConfiguration) {\n        this.corsConfiguration = corsConfiguration;\n    }\n\n    @Override\n    public Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {\n        boolean originHeaderPresent = request.getHeaders().getOrigin().isPresent();\n        if (originHeaderPresent) {\n            Optional<MutableHttpResponse<?>> response = handleRequest(request);\n            if (response.isPresent()) {\n                return Publishers.just(response.get());\n            } else {\n                return Publishers.map(chain.proceed(request), mutableHttpResponse -> {\n                    handleResponse(request, mutableHttpResponse);\n                    return mutableHttpResponse;\n                });\n            }\n        } else {\n            return chain.proceed(request);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n\n    /**\n     * Handles a CORS response.\n     *\n     * @param request  The {@link HttpRequest} object\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void handleResponse(HttpRequest<?> request, MutableHttpResponse<?> response) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        originHeader.ifPresent(requestOrigin -> {\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                if (CorsUtil.isPreflightRequest(request)) {\n                    Optional<HttpMethod> result = headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class);\n                    setAllowMethods(result.get(), response);\n                    Optional<List> allowedHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.of(List.class, String.class));\n                    allowedHeaders.ifPresent(val ->\n                        setAllowHeaders(val, response)\n                    );\n\n                    setMaxAge(config.getMaxAge(), response);\n                }\n\n                setOrigin(requestOrigin, response);\n                setVary(response);\n                setExposeHeaders(config.getExposedHeaders(), response);\n                setAllowCredentials(config, response);\n            }\n        });\n    }\n\n    /**\n     * Handles a CORS {@link HttpRequest}.\n     *\n     * @param request The {@link HttpRequest} object\n     * @return An optional {@link MutableHttpResponse}. The request should proceed normally if empty\n     */\n    protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest request) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        if (originHeader.isPresent()) {\n\n            String requestOrigin = originHeader.get();\n            boolean preflight = CorsUtil.isPreflightRequest(request);\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                HttpMethod requestMethod = request.getMethod();\n\n                List<HttpMethod> allowedMethods = config.getAllowedMethods();\n\n                if (!isAnyMethod(allowedMethods)) {\n                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.class).orElse(requestMethod) : requestMethod;\n                    if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                        return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                    }\n                }\n\n                if (preflight) {\n                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, Argument.listOf(String.class));\n\n                    List<String> allowedHeaders = config.getAllowedHeaders();\n\n                    if (!isAny(allowedHeaders) && accessControlHeaders.isPresent()) {\n                        if (!accessControlHeaders.get().stream()\n                            .allMatch(header -> allowedHeaders.stream()\n                                .anyMatch(allowedHeader -> allowedHeader.equals(header.trim())))) {\n                            return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> ok = HttpResponse.ok();\n                    handleResponse(request, ok);\n                    return Optional.of(ok);\n                }\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    /**\n     * @param config   The {@link CorsOriginConfiguration} instance\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setAllowCredentials(CorsOriginConfiguration config, MutableHttpResponse<?> response) {\n        if (config.isAllowCredentials()) {\n            response.header(ACCESS_CONTROL_ALLOW_CREDENTIALS, Boolean.toString(true));\n        }\n    }\n\n    /**\n     * @param exposedHeaders A list of the exposed headers\n     * @param response       The {@link MutableHttpResponse} object\n     */\n    protected void setExposeHeaders(List<String> exposedHeaders, MutableHttpResponse<?> response) {\n        if (corsConfiguration.isSingleHeader()) {\n            String headerValue = String.join(\",\", exposedHeaders);\n            if (StringUtils.isNotEmpty(headerValue)) {\n                response.header(ACCESS_CONTROL_EXPOSE_HEADERS, headerValue);\n            }\n        } else {\n            exposedHeaders.forEach(header -> response.header(ACCESS_CONTROL_EXPOSE_HEADERS, header));\n        }\n    }\n\n    /**\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setVary(MutableHttpResponse<?> response) {\n        response.header(VARY, ORIGIN);\n    }\n\n\n    /**\n     * @param origin   The origin\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setOrigin(String origin, MutableHttpResponse response) {\n        response.header(ACCESS_CONTROL_ALLOW_ORIGIN, origin);\n    }\n\n    /**\n     * @param method   The {@link HttpMethod} object\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setAllowMethods(HttpMethod method, MutableHttpResponse response) {\n        response.header(ACCESS_CONTROL_ALLOW_METHODS, method);\n    }\n\n    /**\n     * @param optionalAllowHeaders A list with optional allow headers\n     * @param response             The {@link MutableHttpResponse} object\n     */\n    protected void setAllowHeaders(List<?> optionalAllowHeaders, MutableHttpResponse response) {\n        List<String> allowHeaders = optionalAllowHeaders.stream().map(Object::toString).collect(Collectors.toList());\n        if (corsConfiguration.isSingleHeader()) {\n            String headerValue = String.join(\",\", allowHeaders);\n            if (StringUtils.isNotEmpty(headerValue)) {\n                response.header(ACCESS_CONTROL_ALLOW_HEADERS, headerValue);\n            }\n        } else {\n            allowHeaders.forEach(header -> response.header(ACCESS_CONTROL_ALLOW_HEADERS, header));\n        }\n    }\n\n    /**\n     * @param maxAge   The max age\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setMaxAge(long maxAge, MutableHttpResponse response) {\n        if (maxAge > -1) {\n            response.header(ACCESS_CONTROL_MAX_AGE, Long.toString(maxAge));\n        }\n    }\n\n    private Optional<CorsOriginConfiguration> getConfiguration(String requestOrigin) {\n        Map<String, CorsOriginConfiguration> corsConfigurations = corsConfiguration.getConfigurations();\n        for (Map.Entry<String, CorsOriginConfiguration> config : corsConfigurations.entrySet()) {\n            List<String> allowedOrigins = config.getValue().getAllowedOrigins();\n            if (!allowedOrigins.isEmpty()) {\n                boolean matches = false;\n                if (isAny(allowedOrigins)) {\n                    matches = true;\n                }\n                if (!matches) {\n                    matches = allowedOrigins.stream().anyMatch(origin -> {\n                        if (origin.equals(requestOrigin)) {\n                            return true;\n                        }\n                        Pattern p = Pattern.compile(origin);\n                        Matcher m = p.matcher(requestOrigin);\n                        return m.matches();\n                    });\n                }\n\n                if (matches) {\n                    return Optional.of(config.getValue());\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    private boolean isAny(List<String> values) {\n        return values == CorsOriginConfiguration.ANY;\n    }\n\n    private boolean isAnyMethod(List<HttpMethod> allowedMethods) {\n        return allowedMethods == CorsOriginConfiguration.ANY_METHOD;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.cors;\n\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.TypeConverter;\nimport io.micronaut.core.convert.value.ConvertibleValues;\nimport io.micronaut.core.convert.value.ConvertibleValuesMap;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpMethod;\n\nimport javax.inject.Singleton;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * Responsible for converting a map of configuration to an instance of {@link CorsOriginConfiguration}.\n *\n * @author James Kleeh\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\npublic class CorsOriginConverter implements TypeConverter<Object, CorsOriginConfiguration> {\n\n    private static final String ALLOWED_ORIGINS = \"allowedOrigins\";\n    private static final String ALLOWED_METHODS = \"allowedMethods\";\n    private static final String ALLOWED_HEADERS = \"allowedHeaders\";\n    private static final String EXPOSED_HEADERS = \"exposedHeaders\";\n    private static final String ALLOW_CREDENTIALS = \"allowCredentials\";\n    private static final String MAX_AGE = \"maxAge\";\n\n    @Override\n    public Optional<CorsOriginConfiguration> convert(Object object, Class<CorsOriginConfiguration> targetType, ConversionContext context) {\n        CorsOriginConfiguration configuration = new CorsOriginConfiguration();\n        if (object instanceof Map) {\n            Map mapConfig = (Map) object;\n            ConvertibleValues<Object> convertibleValues = new ConvertibleValuesMap<>(mapConfig);\n\n            convertibleValues\n                .get(ALLOWED_ORIGINS, Argument.listOf(String.class))\n                .ifPresent(configuration::setAllowedOrigins);\n\n            convertibleValues\n                .get(ALLOWED_METHODS, Argument.listOf(HttpMethod.class))\n                .ifPresent(configuration::setAllowedMethods);\n\n            convertibleValues\n                .get(ALLOWED_HEADERS, Argument.listOf(String.class))\n                .ifPresent(configuration::setAllowedHeaders);\n\n            convertibleValues\n                .get(EXPOSED_HEADERS, Argument.listOf(String.class))\n                .ifPresent(configuration::setExposedHeaders);\n\n            convertibleValues\n                .get(ALLOW_CREDENTIALS, Boolean.class)\n                .ifPresent(configuration::setAllowCredentials);\n\n            convertibleValues\n                .get(MAX_AGE, Long.class)\n                .ifPresent(configuration::setMaxAge);\n        }\n        return Optional.of(configuration);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http;\n\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.type.Headers;\n\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * Constants for common HTTP headers. See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface HttpHeaders extends Headers {\n\n    /**\n     * {@code \"Accept\"}.\n     */\n    String ACCEPT = \"Accept\";\n\n    /**\n     * {@code \"Accept-Charset\"}.\n     */\n    String ACCEPT_CHARSET = \"Accept-Charset\";\n\n    /**\n     * {@code \"Accept-Encoding\"}.\n     */\n    String ACCEPT_ENCODING = \"Accept-Encoding\";\n\n    /**\n     * {@code \"Accept-Language\"}.\n     */\n    String ACCEPT_LANGUAGE = \"Accept-Language\";\n\n    /**\n     * {@code \"Accept-Ranges\"}.\n     */\n    String ACCEPT_RANGES = \"Accept-Ranges\";\n\n    /**\n     * {@code \"Accept-Patch\"}.\n     */\n    String ACCEPT_PATCH = \"Accept-Patch\";\n\n    /**\n     * {@code \"Access-Control-Allow-Credentials\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_CREDENTIALS = \"Access-Control-Allow-Credentials\";\n\n    /**\n     * {@code \"Access-Control-Allow-Headers\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_HEADERS = \"Access-Control-Allow-Headers\";\n\n    /**\n     * {@code \"Access-Control-Allow-Methods\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_METHODS = \"Access-Control-Allow-Methods\";\n\n    /**\n     * {@code \"Access-Control-Allow-Origin\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_ORIGIN = \"Access-Control-Allow-Origin\";\n\n    /**\n     * {@code \"Access-Control-Expose-Headers\"}.\n     */\n    String ACCESS_CONTROL_EXPOSE_HEADERS = \"Access-Control-Expose-Headers\";\n\n    /**\n     * {@code \"Access-Control-Max-Age\"}.\n     */\n    String ACCESS_CONTROL_MAX_AGE = \"Access-Control-Max-Age\";\n\n    /**\n     * {@code \"Access-Control-Request-Headers\"}.\n     */\n    String ACCESS_CONTROL_REQUEST_HEADERS = \"Access-Control-Request-Headers\";\n\n    /**\n     * {@code \"Access-Control-Request-Method\"}.\n     */\n    String ACCESS_CONTROL_REQUEST_METHOD = \"Access-Control-Request-Method\";\n\n    /**\n     * {@code \"Age\"}.\n     */\n    String AGE = \"Age\";\n\n    /**\n     * {@code \"Allow\"}.\n     */\n    String ALLOW = \"Allow\";\n\n    /**\n     * {@code \"Authorization\"}.\n     */\n    String AUTHORIZATION = \"Authorization\";\n\n    /**\n     * {@code \"Authorization\"}.\n     */\n    String AUTHORIZATION_INFO = \"Authorization-Info\";\n\n    /**\n     * {@code \"Cache-Control\"}.\n     */\n    String CACHE_CONTROL = \"Cache-Control\";\n\n    /**\n     * {@code \"Connection\"}.\n     */\n    String CONNECTION = \"Connection\";\n\n    /**\n     * {@code \"Content-Base\"}.\n     */\n    String CONTENT_BASE = \"Content-Base\";\n\n    /**\n     * {@code \"Content-Disposition\"}.\n     */\n    String CONTENT_DISPOSITION = \"Content-Disposition\";\n\n    /**\n     * {@code \"Content-Encoding\"}.\n     */\n    String CONTENT_ENCODING = \"Content-Encoding\";\n\n    /**\n     * {@code \"Content-Language\"}.\n     */\n    String CONTENT_LANGUAGE = \"Content-Language\";\n\n    /**\n     * {@code \"Content-Length\"}.\n     */\n    String CONTENT_LENGTH = \"Content-Length\";\n\n    /**\n     * {@code \"Content-Location\"}.\n     */\n    String CONTENT_LOCATION = \"Content-Location\";\n\n    /**\n     * {@code \"Content-Transfer-Encoding\"}.\n     */\n    String CONTENT_TRANSFER_ENCODING = \"Content-Transfer-Encoding\";\n\n    /**\n     * {@code \"Content-MD5\"}.\n     */\n    String CONTENT_MD5 = \"Content-MD5\";\n\n    /**\n     * {@code \"Content-Range\"}.\n     */\n    String CONTENT_RANGE = \"Content-Range\";\n\n    /**\n     * {@code \"Content-Type\"}.\n     */\n    String CONTENT_TYPE = \"Content-Type\";\n\n    /**\n     * {@code \"Cookie\"}.\n     */\n    String COOKIE = \"Cookie\";\n\n    /**\n     * {@code \"Date\"}.\n     */\n    String DATE = \"Date\";\n\n    /**\n     * {@code \"ETag\"}.\n     */\n    String ETAG = \"ETag\";\n\n    /**\n     * {@code \"Expect\"}.\n     */\n    String EXPECT = \"Expect\";\n\n    /**\n     * {@code \"Expires\"}.\n     */\n    String EXPIRES = \"Expires\";\n\n    /**\n     * {@code \"Forwarded\"}.\n     */\n    String FORWARDED = \"Forwarded\";\n\n    /**\n     * {@code \"From\"}.\n     */\n    String FROM = \"From\";\n\n    /**\n     * {@code \"Host\"}.\n     */\n    String HOST = \"Host\";\n\n    /**\n     * {@code \"If-Match\"}.\n     */\n    String IF_MATCH = \"If-Match\";\n\n    /**\n     * {@code \"If-Modified-Since\"}.\n     */\n    String IF_MODIFIED_SINCE = \"If-Modified-Since\";\n\n    /**\n     * {@code \"If-None-Match\"}.\n     */\n    String IF_NONE_MATCH = \"If-None-Match\";\n\n    /**\n     * {@code \"If-Range\"}.\n     */\n    String IF_RANGE = \"If-Range\";\n\n    /**\n     * {@code \"If-Unmodified-Since\"}.\n     */\n    String IF_UNMODIFIED_SINCE = \"If-Unmodified-Since\";\n\n    /**\n     * {@code \"Last-Modified\"}.\n     */\n    String LAST_MODIFIED = \"Last-Modified\";\n\n    /**\n     * {@code \"Location\"}.\n     */\n    String LOCATION = \"Location\";\n\n    /**\n     * {@code \"Max-Forwards\"}.\n     */\n    String MAX_FORWARDS = \"Max-Forwards\";\n\n    /**\n     * {@code \"Origin\"}.\n     */\n    String ORIGIN = \"Origin\";\n\n    /**\n     * {@code \"Pragma\"}.\n     */\n    String PRAGMA = \"Pragma\";\n\n    /**\n     * {@code \"Proxy-Authenticate\"}.\n     */\n    String PROXY_AUTHENTICATE = \"Proxy-Authenticate\";\n\n    /**\n     * {@code \"Proxy-Authorization\"}.\n     */\n    String PROXY_AUTHORIZATION = \"Proxy-Authorization\";\n\n    /**\n     * {@code \"Range\"}.\n     */\n    String RANGE = \"Range\";\n\n    /**\n     * {@code \"Referer\"}.\n     */\n    String REFERER = \"Referer\";\n\n    /**\n     * {@code \"Retry-After\"}.\n     */\n    String RETRY_AFTER = \"Retry-After\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key1\"}.\n     */\n    String SEC_WEBSOCKET_KEY1 = \"Sec-WebSocket-Key1\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key2\"}.\n     */\n    String SEC_WEBSOCKET_KEY2 = \"Sec-WebSocket-Key2\";\n\n    /**\n     * {@code \"Sec-WebSocket-Location\"}.\n     */\n    String SEC_WEBSOCKET_LOCATION = \"Sec-WebSocket-Location\";\n\n    /**\n     * {@code \"Sec-WebSocket-Origin\"}.\n     */\n    String SEC_WEBSOCKET_ORIGIN = \"Sec-WebSocket-Origin\";\n\n    /**\n     * {@code \"Sec-WebSocket-Protocol\"}.\n     */\n    String SEC_WEBSOCKET_PROTOCOL = \"Sec-WebSocket-Protocol\";\n\n    /**\n     * {@code \"Sec-WebSocket-Version\"}.\n     */\n    String SEC_WEBSOCKET_VERSION = \"Sec-WebSocket-Version\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key\"}.\n     */\n    String SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\n\n    /**\n     * {@code \"Sec-WebSocket-Accept\"}.\n     */\n    String SEC_WEBSOCKET_ACCEPT = \"Sec-WebSocket-Accept\";\n\n    /**\n     * {@code \"Server\"}.\n     */\n    String SERVER = \"Server\";\n\n    /**\n     * {@code \"Set-Cookie\"}.\n     */\n    String SET_COOKIE = \"Set-Cookie\";\n\n    /**\n     * {@code \"Set-Cookie2\"}.\n     */\n    String SET_COOKIE2 = \"Set-Cookie2\";\n\n    /**\n     * {@code \"TE\"}.\n     */\n    String TE = \"TE\";\n\n    /**\n     * {@code \"Trailer\"}.\n     */\n    String TRAILER = \"Trailer\";\n\n    /**\n     * {@code \"Transfer-Encoding\"}.\n     */\n    String TRANSFER_ENCODING = \"Transfer-Encoding\";\n\n    /**\n     * {@code \"Upgrade\"}.\n     */\n    String UPGRADE = \"Upgrade\";\n\n    /**\n     * {@code \"User-Agent\"}.\n     */\n    String USER_AGENT = \"User-Agent\";\n\n    /**\n     * {@code \"Vary\"}.\n     */\n    String VARY = \"Vary\";\n\n    /**\n     * {@code \"Via\"}.\n     */\n    String VIA = \"Via\";\n\n    /**\n     * {@code \"Warning\"}.\n     */\n    String WARNING = \"Warning\";\n\n    /**\n     * {@code \"WebSocket-Location\"}.\n     */\n    String WEBSOCKET_LOCATION = \"WebSocket-Location\";\n\n    /**\n     * {@code \"WebSocket-Origin\"}.\n     */\n    String WEBSOCKET_ORIGIN = \"WebSocket-Origin\";\n\n    /**\n     * {@code \"WebSocket-Protocol\"}.\n     */\n    String WEBSOCKET_PROTOCOL = \"WebSocket-Protocol\";\n\n    /**\n     * {@code \"WWW-Authenticate\"}.\n     */\n    String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n\n    /**\n     * {@code \"X-Auth-Token\"}.\n     */\n    String X_AUTH_TOKEN = \"X-Auth-Token\";\n\n    /**\n     * Obtain the date header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed\n     * {@link Optional#empty()}\n     */\n    default Optional<ZonedDateTime> findDate(CharSequence name) {\n        try {\n            return findFirst(name).map((str) -> {\n                    LocalDateTime localDateTime = LocalDateTime.parse(str, DateTimeFormatter.RFC_1123_DATE_TIME);\n                    return ZonedDateTime.of(localDateTime, ZoneId.of(\"GMT\"));\n                }\n\n            );\n        } catch (DateTimeParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Obtain the date header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed null\n     */\n    default ZonedDateTime getDate(CharSequence name) {\n        return findDate(name).orElse(null);\n    }\n\n    /**\n     * Obtain an integer header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed null\n     */\n    default Integer getInt(CharSequence name) {\n        return findInt(name).orElse(null);\n    }\n\n    /**\n     * Find an integer header.\n     *\n     * @param name The name of the header\n     * @return An {@link Optional} of {@link Integer}\n     */\n    default Optional<Integer> findInt(CharSequence name) {\n        return get(name, Integer.class);\n    }\n\n    /**\n     * Get the first value of the given header.\n     *\n     * @param name The header name\n     * @return The first value or null if it is present\n     */\n    default Optional<String> findFirst(CharSequence name) {\n        return getFirst(name, String.class);\n    }\n\n    /**\n     * The request or response content type.\n     *\n     * @return The content type\n     */\n    default Optional<MediaType> contentType() {\n        return getFirst(HttpHeaders.CONTENT_TYPE, MediaType.class);\n    }\n\n    /**\n     * The request or response content type.\n     *\n     * @return The content type\n     */\n    default OptionalLong contentLength() {\n        Optional<Long> optional = getFirst(HttpHeaders.CONTENT_LENGTH, Long.class);\n        return optional.map(OptionalLong::of).orElseGet(OptionalLong::empty);\n    }\n\n    /**\n     * A list of accepted {@link MediaType} instances.\n     *\n     * @return A list of zero or many {@link MediaType} instances\n     */\n    default List<MediaType> accept() {\n        return getAll(HttpHeaders.ACCEPT)\n            .stream()\n            .flatMap(x -> Arrays.stream(x.split(\",\")))\n            .flatMap(s -> ConversionService.SHARED.convert(s, MediaType.class).map(Stream::of).orElse(Stream.empty()))\n            .distinct()\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * @return Whether the {@link HttpHeaders#CONNECTION} header is set to Keep-Alive\n     */\n    default boolean isKeepAlive() {\n        return getFirst(CONNECTION, String.class).map(val -> val.equalsIgnoreCase(\"keep-alive\")).orElse(false);\n    }\n\n    /**\n     * @return The {@link #ORIGIN} header\n     */\n    default Optional<String> getOrigin() {\n        return findFirst(ORIGIN);\n    }\n\n    /**\n     * @return The {@link #AUTHORIZATION} header\n     */\n    default Optional<String> getAuthorization() {\n        return findFirst(AUTHORIZATION);\n    }\n\n    /**\n     * @return The {@link #CONTENT_TYPE} header\n     */\n    default Optional<String> getContentType() {\n        return findFirst(CONTENT_TYPE);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http;\n\nimport io.micronaut.core.annotation.TypeHint;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.naming.NameUtils;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.core.value.OptionalValues;\nimport io.micronaut.http.annotation.Produces;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Represents a media type.\n * See https://www.iana.org/assignments/media-types/media-types.xhtml and https://tools.ietf.org/html/rfc2046\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@TypeHint(value = MediaType[].class)\npublic class MediaType implements CharSequence {\n\n    /**\n     * Default file extension used for JSON.\n     */\n    public static final String EXTENSION_JSON = \"json\";\n\n    /**\n     * Default file extension used for XML.\n     */\n    public static final String EXTENSION_XML = \"xml\";\n\n    /**\n     * Default empty media type array.\n     */\n    public static final MediaType[] EMPTY_ARRAY = new MediaType[0];\n\n    /**\n     * A wildcard media type representing all types.\n     */\n    public static final String ALL = \"*/*\";\n\n    /**\n     * A wildcard media type representing all types.\n     */\n    public static final MediaType ALL_TYPE = new MediaType(ALL, \"all\");\n\n    /**\n     * Form encoded data: application/x-www-form-urlencoded.\n     */\n    public static final String APPLICATION_FORM_URLENCODED = \"application/x-www-form-urlencoded\";\n\n    /**\n     * Form encoded data: application/x-www-form-urlencoded.\n     */\n    public static final MediaType APPLICATION_FORM_URLENCODED_TYPE = new MediaType(APPLICATION_FORM_URLENCODED);\n\n    /**\n     * Short cut for {@link #APPLICATION_FORM_URLENCODED_TYPE}.\n     */\n    public static final MediaType FORM = APPLICATION_FORM_URLENCODED_TYPE;\n\n    /**\n     * Multi part form data: multipart/form-data.\n     */\n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n\n    /**\n     * Multi part form data: multipart/form-data.\n     */\n    public static final MediaType MULTIPART_FORM_DATA_TYPE = new MediaType(MULTIPART_FORM_DATA);\n\n    /**\n     * HTML: text/html.\n     */\n    public static final String TEXT_HTML = \"text/html\";\n\n    /**\n     * HTML: text/html.\n     */\n    public static final MediaType TEXT_HTML_TYPE = new MediaType(TEXT_HTML);\n\n    /**\n     * XHTML: application/xhtml+xml.\n     */\n    public static final String APPLICATION_XHTML = \"application/xhtml+xml\";\n\n    /**\n     * XHTML: application/xhtml+xml.\n     */\n    public static final MediaType APPLICATION_XHTML_TYPE = new MediaType(APPLICATION_XHTML, \"html\");\n\n    /**\n     * XML: application/xml.\n     */\n    public static final String APPLICATION_XML = \"application/xml\";\n\n    /**\n     * XML: application/xml.\n     */\n    public static final MediaType APPLICATION_XML_TYPE = new MediaType(APPLICATION_XML);\n\n    /**\n     * JSON: application/json.\n     */\n    public static final String APPLICATION_JSON = \"application/json\";\n\n    /**\n     * JSON: application/json.\n     */\n    public static final MediaType APPLICATION_JSON_TYPE = new MediaType(MediaType.APPLICATION_JSON);\n\n    /**\n     * YAML: application/x-yaml.\n     */\n    public static final String APPLICATION_YAML = \"application/x-yaml\";\n\n    /**\n     * YAML: application/x-yaml.\n     */\n    public static final MediaType APPLICATION_YAML_TYPE = new MediaType(MediaType.APPLICATION_YAML);\n\n    /**\n     * XML: text/xml.\n     */\n    public static final String TEXT_XML = \"text/xml\";\n\n    /**\n     * XML: text/xml.\n     */\n    public static final MediaType TEXT_XML_TYPE = new MediaType(TEXT_XML);\n\n    /**\n     * JSON: text/json.\n     */\n    public static final String TEXT_JSON = \"text/json\";\n\n    /**\n     * JSON: text/json.\n     */\n    public static final MediaType TEXT_JSON_TYPE = new MediaType(TEXT_JSON);\n\n    /**\n     * Plain Text: text/plain.\n     */\n    public static final String TEXT_PLAIN = \"text/plain\";\n\n    /**\n     * Plain Text: text/plain.\n     */\n    public static final MediaType TEXT_PLAIN_TYPE = new MediaType(TEXT_PLAIN);\n\n    /**\n     * HAL JSON: application/hal+json.\n     */\n    public static final String APPLICATION_HAL_JSON = \"application/hal+json\";\n\n    /**\n     * HAL JSON: application/hal+json.\n     */\n    public static final MediaType APPLICATION_HAL_JSON_TYPE = new MediaType(APPLICATION_HAL_JSON);\n\n    /**\n     * HAL XML: application/hal+xml.\n     */\n    public static final String APPLICATION_HAL_XML = \"application/hal+xml\";\n\n    /**\n     * HAL XML: application/hal+xml.\n     */\n    public static final MediaType APPLICATION_HAL_XML_TYPE = new MediaType(APPLICATION_HAL_XML);\n\n    /**\n     * Atom: application/atom+xml.\n     */\n    public static final String APPLICATION_ATOM_XML = \"application/atom+xml\";\n\n    /**\n     * Atom: application/atom+xml.\n     */\n    public static final MediaType APPLICATION_ATOM_XML_TYPE = new MediaType(APPLICATION_ATOM_XML);\n\n    /**\n     * VND Error: application/vnd.error+json.\n     */\n    public static final String APPLICATION_VND_ERROR = \"application/vnd.error+json\";\n\n    /**\n     * VND Error: application/vnd.error+json.\n     */\n    public static final MediaType APPLICATION_VND_ERROR_TYPE = new MediaType(APPLICATION_VND_ERROR);\n\n    /**\n     * Server Sent Event: text/event-stream.\n     */\n    public static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n\n    /**\n     * Server Sent Event: text/event-stream.\n     */\n    public static final MediaType TEXT_EVENT_STREAM_TYPE = new MediaType(TEXT_EVENT_STREAM);\n\n    /**\n     * JSON Stream: application/x-json-stream.\n     */\n    public static final String APPLICATION_JSON_STREAM = \"application/x-json-stream\";\n\n    /**\n     * JSON Stream: application/x-json-stream.\n     */\n    public static final MediaType APPLICATION_JSON_STREAM_TYPE = new MediaType(APPLICATION_JSON_STREAM);\n\n    /**\n     * BINARY: application/octet-stream.\n     */\n    public static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n\n    /**\n     * BINARY: application/octet-stream.\n     */\n    public static final MediaType APPLICATION_OCTET_STREAM_TYPE = new MediaType(APPLICATION_OCTET_STREAM);\n\n    /**\n     * GraphQL: application/graphql.\n     */\n    public static final String APPLICATION_GRAPHQL = \"application/graphql\";\n\n    /**\n     * GraphQL: application/graphql.\n     */\n    public static final MediaType APPLICATION_GRAPHQL_TYPE = new MediaType(APPLICATION_GRAPHQL);\n\n    /**\n     * Png Image: image/png.\n     */\n    public static final String IMAGE_PNG = \"image/png\";\n\n    /**\n     * Png Image: image/png.\n     */\n    public static final MediaType IMAGE_PNG_TYPE = new MediaType(IMAGE_PNG);\n\n    /**\n     * Jpeg Image: image/jpeg.\n     */\n    public static final String IMAGE_JPEG = \"image/jpeg\";\n\n    /**\n     * Jpeg Image: image/jpeg.\n     */\n    public static final MediaType IMAGE_JPEG_TYPE = new MediaType(IMAGE_JPEG);\n\n    /**\n     * Gif Image: image/gif.\n     */\n    public static final String IMAGE_GIF = \"image/gif\";\n\n    /**\n     * Gif Image: image/gif.\n     */\n    public static final MediaType IMAGE_GIF_TYPE = new MediaType(IMAGE_GIF);\n\n    /**\n     * Webp Image: image/webp.\n     */\n    public static final String IMAGE_WEBP = \"image/webp\";\n\n    /**\n     * Webp Image: image/webp.\n     */\n    public static final MediaType IMAGE_WEBP_TYPE = new MediaType(IMAGE_WEBP);\n\n    /**\n     * Parameter {@code \"charset\"}.\n     */\n    public static final String CHARSET_PARAMETER = \"charset\";\n\n    /**\n     * Parameter {@code \"q\"}.\n     */\n    public static final String Q_PARAMETER = \"q\";\n\n    /**\n     * Parameter {@code \"v\"}.\n     */\n    public static final String V_PARAMETER = \"v\";\n\n    private static final BigDecimal QUALITY_RATING_NUMBER = new BigDecimal(\"1.0\");\n    private static final String QUALITY_RATING = \"1.0\";\n    private static final String SEMICOLON = \";\";\n\n    @SuppressWarnings(\"ConstantName\")\n    private static final Logger LOG = LoggerFactory.getLogger(MediaType.class);\n    private static final String MIME_TYPES_FILE_NAME = \"META-INF/http/mime.types\";\n    private static Map<String, String> mediaTypeFileExtensions;\n    @SuppressWarnings(\"ConstantName\")\n    private static final List<Pattern> textTypePatterns = new ArrayList<>(4);\n\n    protected final String name;\n    protected final String subtype;\n    protected final String type;\n    protected final String extension;\n    protected final Map<CharSequence, String> parameters;\n    private final String strRepr;\n\n    private BigDecimal qualityNumberField;\n\n    static {\n        ConversionService.SHARED.addConverter(CharSequence.class, MediaType.class, (Function<CharSequence, MediaType>) charSequence -> {\n                    if (StringUtils.isNotEmpty(charSequence)) {\n                        return new MediaType(charSequence.toString());\n                    }\n                    return null;\n                }\n        );\n        textTypePatterns.add(Pattern.compile(\"^text/.*$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+json$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+text$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+xml$\"));\n        textTypePatterns.add(Pattern.compile(\"^application/javascript$\"));\n    }\n\n    /**\n     * Constructs a new media type for the given string.\n     *\n     * @param name The name of the media type. For example application/json\n     */\n    public MediaType(String name) {\n        this(name, null, Collections.emptyMap());\n    }\n\n    /**\n     * Constructs a new media type for the given string and parameters.\n     *\n     * @param name   The name of the media type. For example application/json\n     * @param params The parameters\n     */\n    public MediaType(String name, Map<String, String> params) {\n        this(name, null, params);\n    }\n\n    /**\n     * Constructs a new media type for the given string and extension.\n     *\n     * @param name      The name of the media type. For example application/json\n     * @param extension The extension of the file using this media type if it differs from the subtype\n     */\n    public MediaType(String name, String extension) {\n        this(name, extension, Collections.emptyMap());\n    }\n\n    /**\n     * Constructs a new media type for the given string and extension.\n     *\n     * @param name      The name of the media type. For example application/json\n     * @param extension The extension of the file using this media type if it differs from the subtype\n     * @param params    The parameters\n     */\n    public MediaType(String name, String extension, Map<String, String> params) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Argument [name] cannot be null\");\n        }\n        String withoutArgs;\n        if (name.contains(SEMICOLON)) {\n            this.parameters = new LinkedHashMap<>();\n            String[] tokenWithArgs = name.split(SEMICOLON);\n            withoutArgs = tokenWithArgs[0];\n            String[] paramsList = Arrays.copyOfRange(tokenWithArgs, 1, tokenWithArgs.length);\n            for (String param : paramsList) {\n                int i = param.indexOf('=');\n                if (i > -1) {\n                    parameters.put(param.substring(0, i).trim(), param.substring(i + 1).trim());\n                }\n            }\n        } else {\n            this.parameters = Collections.emptyMap();\n            withoutArgs = name;\n        }\n        this.name = withoutArgs;\n        int i = withoutArgs.indexOf('/');\n        if (i > -1) {\n            this.type = withoutArgs.substring(0, i);\n            this.subtype = withoutArgs.substring(i + 1);\n        } else {\n            throw new IllegalArgumentException(\"Invalid mime type: \" + name);\n        }\n\n        if (extension != null) {\n            this.extension = extension;\n        } else {\n            int j = subtype.indexOf('+');\n            if (j > -1) {\n                this.extension = subtype.substring(j + 1);\n            } else {\n                this.extension = subtype;\n            }\n        }\n        if (params != null) {\n            parameters.putAll(params);\n        }\n\n        this.strRepr = toString0();\n    }\n\n    /**\n     * @return The name of the mime type without any parameters\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return The type of the media type. For example for application/hal+json this would return \"application\"\n     */\n    public String getType() {\n        return this.type;\n    }\n\n    /**\n     * @return The subtype. For example for application/hal+json this would return \"hal+json\"\n     */\n    public String getSubtype() {\n        return this.subtype;\n    }\n\n    /**\n     * @return The extension. For example for application/hal+json this would return \"json\"\n     */\n    public String getExtension() {\n        return extension;\n    }\n\n    /**\n     * @return The parameters to the media type\n     */\n    public OptionalValues<String> getParameters() {\n        return OptionalValues.of(String.class, parameters);\n    }\n\n    /**\n     * @return The quality of the Mime type\n     */\n    public String getQuality() {\n        return parameters.getOrDefault(\"q\", QUALITY_RATING);\n    }\n\n    /**\n     * @return The quality in BigDecimal form\n     */\n    public BigDecimal getQualityAsNumber() {\n        if (this.qualityNumberField == null) {\n            this.qualityNumberField = getOrConvertQualityParameterToBigDecimal(this);\n        }\n        return this.qualityNumberField;\n    }\n\n    /**\n     * @return The version of the Mime type\n     */\n    public String getVersion() {\n        return parameters.getOrDefault(V_PARAMETER, null);\n    }\n\n    /**\n     * @return The charset of the media type if specified\n     */\n    public Optional<Charset> getCharset() {\n        return getParameters().get(\"charset\").map(Charset::forName);\n    }\n\n    @Override\n    public int length() {\n        return strRepr.length();\n    }\n\n    @Override\n    public char charAt(int index) {\n        return strRepr.charAt(index);\n    }\n\n    @Override\n    public CharSequence subSequence(int start, int end) {\n        return strRepr.subSequence(start, end);\n    }\n\n    /**\n     * @return Whether the media type is text based\n     */\n    public boolean isTextBased() {\n        boolean matches = textTypePatterns.stream().anyMatch((p) -> p.matcher(name).matches());\n        if (!matches) {\n            matches = subtype.equalsIgnoreCase(\"json\") || subtype.equalsIgnoreCase(\"xml\");\n        }\n        return matches;\n    }\n\n    /**\n     * @param contentType The content type\n     * @return Whether the content type is text based\n     */\n    public static boolean isTextBased(String contentType) {\n        if (StringUtils.isEmpty(contentType)) {\n            return false;\n        }\n        MediaType mediaType = new MediaType(contentType);\n        return mediaType.isTextBased();\n    }\n\n    @Override\n    public String toString() {\n        return strRepr;\n    }\n\n    private String toString0() {\n        if (parameters.isEmpty()) {\n            return name;\n        } else {\n            return name + \";\" + parameters.entrySet().stream().map(Object::toString)\n                    .collect(Collectors.joining(\";\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the name is matched. Parameters are not included.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        MediaType mediaType = (MediaType) o;\n\n        return name.equalsIgnoreCase(mediaType.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    /**\n     * Create a new {@link MediaType} from the given text.\n     *\n     * @param mediaType The text\n     * @return The {@link MediaType}\n     */\n    public static MediaType of(CharSequence mediaType) {\n        return new MediaType(mediaType.toString());\n    }\n\n    /**\n     * Create a new {@link MediaType} from the given text.\n     *\n     * @param mediaType The text\n     * @return The {@link MediaType}\n     */\n    public static MediaType[] of(CharSequence... mediaType) {\n        return Arrays.stream(mediaType).map(txt -> new MediaType(txt.toString())).toArray(MediaType[]::new);\n    }\n\n    /**\n     * Resolve the {@link MediaType} produced by the given type based on the {@link Produces} annotation.\n     *\n     * @param type The type\n     * @return An {@link Optional} {@link MediaType}\n     */\n    public static Optional<MediaType> fromType(Class<?> type) {\n        Produces producesAnn = type.getAnnotation(Produces.class);\n        if (producesAnn != null) {\n            return Arrays.stream(producesAnn.value()).findFirst().map(MediaType::new);\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Resolve the {@link MediaType} for the given file extension.\n     *\n     * @param extension The file extension\n     * @return The {@link MediaType}\n     */\n    public static Optional<MediaType> forExtension(String extension) {\n        if (StringUtils.isNotEmpty(extension)) {\n            String type = getMediaTypeFileExtensions().get(extension);\n            if (type != null) {\n                return Optional.of(new MediaType(type, extension));\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Resolve the {@link MediaType} for the given file name. Defaults\n     * to text/plain.\n     *\n     * @param filename The file name\n     * @return The {@link MediaType}\n     */\n    public static MediaType forFilename(String filename) {\n        if (StringUtils.isNotEmpty(filename)) {\n            return forExtension(NameUtils.extension(filename)).orElse(MediaType.TEXT_PLAIN_TYPE);\n        }\n        return MediaType.TEXT_PLAIN_TYPE;\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private static Map<String, String> getMediaTypeFileExtensions() {\n        Map<String, String> extensions = mediaTypeFileExtensions;\n        if (extensions == null) {\n            synchronized (MediaType.class) { // double check\n                extensions = mediaTypeFileExtensions;\n                if (extensions == null) {\n                    try {\n                        extensions = loadMimeTypes();\n                        mediaTypeFileExtensions = extensions;\n                    } catch (Exception e) {\n                        mediaTypeFileExtensions = Collections.emptyMap();\n                    }\n                }\n            }\n        }\n        return extensions;\n    }\n\n    private BigDecimal getOrConvertQualityParameterToBigDecimal(MediaType mt) {\n        BigDecimal bd;\n        try {\n            String q = mt.parameters.getOrDefault(Q_PARAMETER, null);\n            if (q == null) {\n                return QUALITY_RATING_NUMBER;\n            } else {\n                bd = new BigDecimal(q);\n            }\n            return bd;\n        } catch (NumberFormatException e) {\n            bd = QUALITY_RATING_NUMBER;\n            return bd;\n        }\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private static Map<String, String> loadMimeTypes() {\n        try (InputStream is = MediaType.class.getClassLoader().getResourceAsStream(MIME_TYPES_FILE_NAME)) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.US_ASCII));\n            Map<String, String> result = new LinkedHashMap<>(100);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.isEmpty() || line.charAt(0) == '#') {\n                    continue;\n                }\n                String formattedLine = line.trim().replaceAll(\"\\\\s{2,}\", \" \").replaceAll(\"\\\\s\", \"|\");\n                String[] tokens = formattedLine.split(\"\\\\|\");\n                for (int i = 1; i < tokens.length; i++) {\n                    String fileExtension = tokens[i].toLowerCase(Locale.ENGLISH);\n                    result.put(fileExtension, tokens[0]);\n                }\n            }\n            return result;\n        } catch (IOException ex) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Failed to load mime types for file extension detection!\");\n            }\n        }\n\n        return Collections.emptyMap();\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.cache.interceptor;\n\nimport io.micronaut.aop.InterceptPhase;\nimport io.micronaut.aop.MethodInterceptor;\nimport io.micronaut.aop.MethodInvocationContext;\nimport io.micronaut.cache.*;\nimport io.micronaut.cache.annotation.CacheConfig;\nimport io.micronaut.cache.annotation.CacheInvalidate;\nimport io.micronaut.cache.annotation.CachePut;\nimport io.micronaut.cache.annotation.Cacheable;\nimport io.micronaut.cache.exceptions.CacheSystemException;\nimport io.micronaut.context.BeanContext;\nimport io.micronaut.core.annotation.AnnotationValue;\nimport io.micronaut.core.async.annotation.SingleResult;\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.reflect.InstantiationUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.MutableArgumentValue;\nimport io.micronaut.core.type.ReturnType;\nimport io.micronaut.core.util.ArrayUtils;\nimport io.micronaut.core.util.CollectionUtils;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.scheduling.TaskExecutors;\nimport io.reactivex.BackpressureStrategy;\nimport io.reactivex.Flowable;\nimport io.reactivex.Maybe;\nimport io.reactivex.Single;\nimport io.reactivex.functions.Function;\nimport org.reactivestreams.Publisher;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.function.BiConsumer;\n\n/**\n * <p>An AOP {@link MethodInterceptor} implementation for the Cache annotations {@link Cacheable},\n * {@link CachePut} and {@link CacheInvalidate}.</p>\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n\npublic class CacheInterceptor implements MethodInterceptor<Object, Object> {\n    /**\n     * The position on the interceptor in the chain.\n     */\n    public static final int POSITION = InterceptPhase.CACHE.getPosition();\n\n    private static final String MEMBER_CACHE_NAMES = \"cacheNames\";\n    private static final String MEMBER_ASYNC = \"async\";\n    private static final Logger LOG = LoggerFactory.getLogger(CacheInterceptor.class);\n    private static final String MEMBER_ATOMIC = \"atomic\";\n    private static final String MEMBER_PARAMETERS = \"parameters\";\n    private static final String MEMBER_ALL = \"all\";\n    private static final String MEMBER_KEY_GENERATOR = \"keyGenerator\";\n\n    private final CacheManager cacheManager;\n    private final Map<Class<? extends CacheKeyGenerator>, CacheKeyGenerator> keyGenerators = new ConcurrentHashMap<>();\n    private final BeanContext beanContext;\n    private final ExecutorService ioExecutor;\n    private final CacheErrorHandler errorHandler;\n    private final AsyncCacheErrorHandler asyncCacheErrorHandler;\n\n    /**\n     * Create Cache Interceptor with given arguments.\n     *\n     * @param cacheManager           The cache manager\n     * @param errorHandler           Cache error handler\n     * @param asyncCacheErrorHandler Async cache error handlers\n     * @param ioExecutor             The executor to create tasks\n     * @param beanContext            The bean context to allow DI\n     */\n    public CacheInterceptor(CacheManager cacheManager,\n                            CacheErrorHandler errorHandler,\n                            AsyncCacheErrorHandler asyncCacheErrorHandler,\n                            @Named(TaskExecutors.IO) ExecutorService ioExecutor,\n                            BeanContext beanContext) {\n        this.cacheManager = cacheManager;\n        this.errorHandler = errorHandler;\n        this.asyncCacheErrorHandler = asyncCacheErrorHandler;\n        this.beanContext = beanContext;\n        this.ioExecutor = ioExecutor;\n    }\n\n    @Override\n    public int getOrder() {\n        return POSITION;\n    }\n\n    @Override\n    public Object intercept(MethodInvocationContext<Object, Object> context) {\n        if (context.hasStereotype(CacheConfig.class)) {\n            ReturnType returnTypeObject = context.getReturnType();\n            Class returnType = returnTypeObject.getType();\n            if (CompletionStage.class.isAssignableFrom(returnType)) {\n                return interceptCompletableFuture(context, returnTypeObject, returnType);\n            } else if (Publishers.isConvertibleToPublisher(returnType)) {\n                return interceptPublisher(context, returnTypeObject, returnType);\n            } else {\n                return interceptSync(context, returnTypeObject, returnType);\n            }\n        } else {\n            return context.proceed();\n        }\n    }\n\n    /**\n     * Intercept the annotated method invocation with sync.\n     *\n     * @param context          Contains information about method invocation\n     * @param returnTypeObject The return type of the method in Micronaut\n     * @param returnType       The return type class\n     * @return The value from the cache\n     */\n    protected Object interceptSync(MethodInvocationContext context, ReturnType returnTypeObject, Class returnType) {\n        final ValueWrapper wrapper = new ValueWrapper();\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n\n        AnnotationValue<Cacheable> cacheConfig = cacheOperation.cacheable;\n        if (cacheConfig != null) {\n            CacheKeyGenerator defaultKeyGenerator = cacheOperation.defaultKeyGenerator;\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(defaultKeyGenerator, cacheConfig);\n            Object[] parameterValues = resolveParams(context, cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, parameterValues);\n            Argument returnArgument = returnTypeObject.asArgument();\n            if (cacheConfig.getRequiredValue(MEMBER_ATOMIC, Boolean.class)) {\n                SyncCache syncCache = cacheManager.getCache(cacheOperation.cacheableCacheName);\n\n                try {\n                    wrapper.value = syncCache.get(key, returnArgument, () -> {\n                        try {\n                            doProceed(context, wrapper);\n                            return wrapper.value;\n                        } catch (RuntimeException e) {\n                            throw new ValueSupplierException(key, e);\n                        }\n                    });\n                } catch (ValueSupplierException e) {\n                    throw e.getCause();\n                } catch (RuntimeException e) {\n                    errorHandler.handleLoadError(syncCache, key, e);\n                    throw e;\n                }\n            } else {\n                String[] cacheNames = resolveCacheNames(cacheOperation.defaultConfig, cacheConfig);\n                boolean cacheHit = false;\n                for (String cacheName : cacheNames) {\n                    SyncCache syncCache = cacheManager.getCache(cacheName);\n                    try {\n                        Optional optional = syncCache.get(key, returnArgument);\n                        if (optional.isPresent()) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Value found in cache [\" + cacheName + \"] for invocation: \" + context);\n                            }\n                            cacheHit = true;\n                            wrapper.value = optional.get();\n                            break;\n                        }\n                    } catch (RuntimeException e) {\n                        if (errorHandler.handleLoadError(syncCache, key, e)) {\n                            throw e;\n                        }\n                    }\n                }\n                if (!cacheHit) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value not found in cache for invocation: \" + context);\n                    }\n                    doProceed(context, wrapper);\n                    syncPut(cacheNames, key, wrapper.value);\n                }\n            }\n        } else {\n            if (!cacheOperation.hasWriteOperations()) {\n                return context.proceed();\n            } else {\n                doProceed(context, wrapper);\n            }\n        }\n\n        List<AnnotationValue<CachePut>> cachePuts = cacheOperation.putOperations;\n        if (cachePuts != null) {\n\n            for (AnnotationValue<CachePut> cachePut : cachePuts) {\n                boolean async = cachePut.get(MEMBER_ASYNC, Boolean.class, false);\n                if (async) {\n                    ioExecutor.submit(() ->\n                            processCachePut(context, wrapper, cachePut, cacheOperation)\n                    );\n                } else {\n                    processCachePut(context, wrapper, cachePut, cacheOperation);\n                }\n            }\n        }\n\n        List<AnnotationValue<CacheInvalidate>> cacheInvalidates = cacheOperation.invalidateOperations;\n        if (cacheInvalidates != null) {\n            for (AnnotationValue<CacheInvalidate> cacheInvalidate : cacheInvalidates) {\n                boolean async = cacheInvalidate.get(MEMBER_ASYNC, Boolean.class, false);\n                if (async) {\n                    ioExecutor.submit(() -> {\n                                try {\n                                    processCacheEvict(context, cacheInvalidate, cacheOperation, async);\n                                } catch (Exception e) {\n                                    throw new CacheSystemException(\"Cache invalidate operation failed: \" + e.getMessage(), e);\n                                }\n                            }\n                    );\n                } else {\n                    processCacheEvict(context, cacheInvalidate, cacheOperation, async);\n                }\n            }\n        }\n\n        return wrapper.optional ? Optional.ofNullable(wrapper.value) : wrapper.value;\n    }\n\n    /**\n     * Intercept the aync method invocation.\n     *\n     * @param context          Contains information about method invocation\n     * @param returnTypeObject The return type of the method in Micronaut\n     * @param returnType       The return type class\n     * @return The value from the cache\n     */\n    protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> context, ReturnType<?> returnTypeObject, Class returnType) {\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        CompletableFuture<Object> returnFuture;\n        if (cacheable != null) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n            Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, params);\n            CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n            asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                if (throwable == null && o.isPresent()) {\n                    // cache hit, return result\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                    }\n                    thisFuture.complete(o.get());\n                } else {\n                    // cache miss proceed with original future\n                    try {\n                        if (throwable != null) {\n                            if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                                thisFuture.completeExceptionally(throwable);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> completableFuture = (CompletableFuture) context.proceed();\n                        if (completableFuture == null) {\n                            thisFuture.complete(null);\n                        } else {\n                            completableFuture.whenComplete((BiConsumer<Object, Throwable>) (o1, t2) -> {\n                                if (t2 != null) {\n                                    thisFuture.completeExceptionally(t2);\n                                } else {\n                                    // new cacheable result, cache it\n                                    asyncCache.put(key, o1).whenComplete((aBoolean, throwable1) -> {\n                                        if (throwable1 == null) {\n                                            thisFuture.complete(o1);\n                                        } else {\n                                            thisFuture.completeExceptionally(throwable1);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException e) {\n                        thisFuture.completeExceptionally(e);\n                    }\n                }\n            });\n            returnFuture = thisFuture;\n        } else {\n            returnFuture = (CompletableFuture<Object>) context.proceed();\n        }\n        if (cacheOperation.hasWriteOperations()) {\n            returnFuture = processFuturePutOperations(context, cacheOperation, returnFuture);\n        }\n        return returnFuture;\n    }\n\n    /**\n     * Saving inside the cache.\n     *\n     * @param context Contains information about method invocation\n     * @return The operations to cause the return value to be cached within the given cache name.\n     */\n    protected List<AnnotationValue<CachePut>> putOperations(MethodInvocationContext context) {\n        return context.getAnnotationValuesByType(CachePut.class);\n    }\n\n    /**\n     * Evict from the cache.\n     *\n     * @param context Extended version of {@link io.micronaut.aop.InvocationContext} for {@link MethodInterceptor} instances\n     * @return The operations to cause the eviction of the given caches\n     */\n    protected List<AnnotationValue<CacheInvalidate>> invalidateOperations(MethodInvocationContext context) {\n        return context.getAnnotationValuesByType(CacheInvalidate.class);\n    }\n\n    private Object interceptPublisher(MethodInvocationContext<Object, Object> context, ReturnType returnTypeObject, Class returnType) {\n        if (!Publishers.isSingle(returnType) && !context.isAnnotationPresent(SingleResult.class)) {\n            throw new CacheSystemException(\"Only Reactive types that emit a single result can currently be cached. Use either Single, Maybe or Mono for operations that cache.\");\n        }\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        if (cacheable != null) {\n\n            Publisher<Object> publisher = buildCacheablePublisher(context, returnTypeObject, cacheOperation, cacheable);\n            return Publishers.convertPublisher(publisher, returnType);\n        } else {\n            final List<AnnotationValue<CachePut>> putOperations = cacheOperation.putOperations;\n            if (CollectionUtils.isNotEmpty(putOperations)) {\n                final Publisher<Object> publisher = buildCachePutPublisher(context, cacheOperation, putOperations);\n                return Publishers.convertPublisher(publisher, returnType);\n            } else {\n                final List<AnnotationValue<CacheInvalidate>> invalidateOperations = cacheOperation.invalidateOperations;\n                if (CollectionUtils.isNotEmpty(invalidateOperations)) {\n                    final Publisher<Object> publisher = buildCacheInvalidatePublisher(context, cacheOperation, invalidateOperations);\n                    return Publishers.convertPublisher(publisher, returnType);\n                } else {\n                    return context.proceed();\n                }\n            }\n        }\n    }\n\n    private Publisher<Object> buildCacheInvalidatePublisher(\n            MethodInvocationContext<Object, Object> context,\n            CacheOperation cacheOperation,\n            List<AnnotationValue<CacheInvalidate>> invalidateOperations) {\n        final Flowable<Object> originalFlowable = Publishers.convertPublisher(context.proceed(), Flowable.class);\n\n        return originalFlowable.flatMap((o) -> {\n            List<Flowable<?>> cacheInvalidates = new ArrayList<>();\n            for (AnnotationValue<CacheInvalidate> invalidateOperation : invalidateOperations) {\n                String[] cacheNames = cacheOperation.getCacheInvalidateNames(invalidateOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean invalidateAll = invalidateOperation.getRequiredValue(MEMBER_ALL, Boolean.class);\n                    boolean isAsync = invalidateOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (isAsync) {\n                        if (invalidateAll) {\n                            for (String cacheName : cacheNames) {\n                                AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n                                asyncCache.invalidateAll().whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        asyncCacheErrorHandler.handleInvalidateError(asyncCache, asRuntimeException(throwable));\n                                    }\n                                }, ioExecutor);\n                            }\n                        } else {\n                            CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(invalidateOperation);\n                            String[] parameterNames = invalidateOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n                            Object[] parameterValues = resolveParams(context, parameterNames);\n                            Object key = keyGenerator.generateKey(context, parameterValues);\n                            for (String cacheName : cacheNames) {\n                                AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n                                asyncCache.invalidate(key).whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        asyncCacheErrorHandler.handleInvalidateError(asyncCache, asRuntimeException(throwable));\n                                    }\n                                }, ioExecutor);\n                            }\n                        }\n                    } else {\n\n                        final Flowable<Object> cacheInvalidateFlowable = Flowable.create(emitter -> {\n                            if (invalidateAll) {\n                                final CompletableFuture<Void> allFutures = buildInvalidateAllFutures(cacheNames);\n                                allFutures.whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                        if (asyncCacheErrorHandler.handleInvalidateError(cache, asRuntimeException(throwable))) {\n                                            emitter.onError(throwable);\n                                            return;\n                                        }\n                                        emitter.onNext(true);\n                                        emitter.onComplete();\n                                    } else {\n                                        emitter.onNext(o);\n                                        emitter.onComplete();\n                                    }\n                                }, ioExecutor);\n                            } else {\n                                CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(invalidateOperation);\n                                String[] parameterNames = invalidateOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n                                Object[] parameterValues = resolveParams(context, parameterNames);\n                                Object key = keyGenerator.generateKey(context, parameterValues);\n                                final CompletableFuture<Void> allFutures = buildInvalidateFutures(cacheNames, key);\n                                allFutures.whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                        if (asyncCacheErrorHandler.handleInvalidateError(cache, key, asRuntimeException(throwable))) {\n                                            emitter.onError(throwable);\n                                            return;\n                                        }\n                                    }\n                                    emitter.onNext(o);\n                                    emitter.onComplete();\n                                }, ioExecutor);\n                            }\n                        }, BackpressureStrategy.ERROR);\n                        cacheInvalidates.add(cacheInvalidateFlowable);\n                    }\n                }\n            }\n            if (!cacheInvalidates.isEmpty()) {\n                return Flowable.merge(cacheInvalidates).lastOrError().toFlowable();\n            } else {\n                return Flowable.just(o);\n            }\n        });\n    }\n\n    private Publisher<Object> buildCachePutPublisher(\n            MethodInvocationContext<Object, Object> context,\n            CacheOperation cacheOperation,\n            List<AnnotationValue<CachePut>> putOperations) {\n        final Flowable<?> originalFlowable = Publishers.convertPublisher(context.proceed(), Flowable.class);\n        return originalFlowable.flatMap((Function<Object, Publisher<?>>) o -> {\n            List<Flowable<?>> cachePuts = new ArrayList<>();\n            for (AnnotationValue<CachePut> putOperation : putOperations) {\n                String[] cacheNames = cacheOperation.getCachePutNames(putOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean isAsync = putOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (isAsync) {\n                        putResultAsync(context, cacheOperation, putOperation, cacheNames, o);\n                    } else {\n                        final Flowable<Object> cachePutFlowable = Flowable.create(emitter -> {\n                            CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n                            Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n                            Object key = keyGenerator.generateKey(context, parameterValues);\n                            CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, o, key);\n                            putOperationFuture.whenComplete((aVoid, throwable) -> {\n                                if (throwable == null) {\n                                    emitter.onNext(o);\n                                    emitter.onComplete();\n                                } else {\n                                    SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                    if (errorHandler.handlePutError(cache, key, o, asRuntimeException(throwable))) {\n                                        emitter.onError(throwable);\n                                    } else {\n                                        emitter.onNext(o);\n                                        emitter.onComplete();\n                                    }\n                                }\n                            });\n                        }, BackpressureStrategy.ERROR);\n                        cachePuts.add(cachePutFlowable);\n                    }\n                }\n            }\n\n            if (!cachePuts.isEmpty()) {\n                return Flowable.merge(cachePuts).lastOrError().toFlowable();\n            } else {\n                return Flowable.just(o);\n            }\n        });\n    }\n\n    private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> context,\n            ReturnType returnTypeObject,\n            CacheOperation cacheOperation,\n            AnnotationValue<Cacheable> cacheable) {\n        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n        Object key = keyGenerator.generateKey(context, params);\n        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.of(Object.class));\n\n        Maybe<Object> maybe = Maybe.create(emitter -> {\n            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {\n               if (throwable != null) {\n                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                       emitter.onError(throwable);\n                   } else {\n                       emitter.onComplete();\n                   }\n                   emitter.onError(throwable);\n               } else if (opt.isPresent()) {\n                   if (LOG.isDebugEnabled()) {\n                       LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                   }\n                   emitter.onSuccess(opt.get());\n               } else {\n                   emitter.onComplete();\n               }\n            });\n        });\n\n        return maybe.isEmpty().flatMapPublisher(empty -> {\n            if (empty) {\n               return Publishers.convertPublisher(\n                       context.proceed(), Flowable.class)\n                       .flatMap(o -> {\n                           return Single.create(emitter -> {\n                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {\n                                   if (throwable1 == null) {\n                                       emitter.onSuccess(o);\n                                   } else {\n                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {\n\n                                           emitter.onError(throwable1);\n                                       } else {\n                                           emitter.onSuccess(o);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return maybe.toFlowable();\n            }\n        });\n    }\n\n    private CompletableFuture<Object> processFuturePutOperations(MethodInvocationContext<Object, Object> context, CacheOperation cacheOperation, CompletableFuture<Object> returnFuture) {\n        List<AnnotationValue<CachePut>> putOperations = cacheOperation.putOperations;\n        if (putOperations != null) {\n            for (AnnotationValue<CachePut> putOperation : putOperations) {\n                String[] cacheNames = cacheOperation.getCachePutNames(putOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean isAsync = putOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (!isAsync) {\n                        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n                        returnFuture.whenComplete((result, throwable) -> {\n                            if (throwable == null) {\n                                try {\n                                    CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n                                    Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n                                    Object key = keyGenerator.generateKey(context, parameterValues);\n                                    CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, result, key);\n\n                                    putOperationFuture.whenComplete((aVoid, error) -> {\n                                        if (error != null) {\n                                            SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                            if (errorHandler.handlePutError(cache, key, result, asRuntimeException(error))) {\n                                                newFuture.completeExceptionally(error);\n                                            } else {\n                                                newFuture.complete(result);\n                                            }\n                                        } else {\n                                            newFuture.complete(result);\n                                        }\n                                    });\n                                } catch (Exception e) {\n                                    newFuture.completeExceptionally(e);\n                                }\n                            } else {\n                                newFuture.completeExceptionally(throwable);\n                            }\n                        });\n                        returnFuture = newFuture;\n                    } else {\n                        returnFuture.whenCompleteAsync((result, throwable) -> {\n                            if (throwable == null) {\n                                putResultAsync(context, cacheOperation, putOperation, cacheNames, result);\n                            }\n                        }, ioExecutor);\n                    }\n                }\n            }\n        }\n        return returnFuture;\n    }\n\n    private void putResultAsync(MethodInvocationContext<Object, Object> context, CacheOperation cacheOperation, AnnotationValue<CachePut> putOperation, String[] cacheNames, Object result) {\n        try {\n            CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n            Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, parameterValues);\n            CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, result, key);\n\n            putOperationFuture.whenComplete((aVoid, error) -> {\n                if (error != null) {\n                    SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                    asyncCacheErrorHandler.handlePutError(cache, key, result, asRuntimeException(error));\n                }\n            });\n        } catch (Exception e) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Cache put operation failed: \" + e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Resolve the cache key generator from the give type.\n     *\n     * @param type The key generator\n     * @return The cache key generator\n     */\n    protected CacheKeyGenerator resolveKeyGenerator(Class<? extends CacheKeyGenerator> type) {\n        if (type == null) {\n            type = DefaultCacheKeyGenerator.class;\n        }\n\n        return keyGenerators.computeIfAbsent(type, aClass -> {\n            if (beanContext.containsBean(aClass)) {\n                return beanContext.getBean(aClass);\n            }\n            return InstantiationUtils.instantiate(aClass);\n        });\n    }\n\n    private CompletableFuture<Void> buildPutFutures(String[] cacheNames, Object result, Object key) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.put(key, result));\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CompletableFuture<Void> buildInvalidateFutures(String[] cacheNames, Object key) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.invalidate(key));\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CompletableFuture<Void> buildInvalidateAllFutures(String[] cacheNames) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.invalidateAll());\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CacheKeyGenerator resolveKeyGenerator(CacheKeyGenerator defaultKeyGenerator, AnnotationValue<Cacheable> cacheConfig) {\n        CacheKeyGenerator keyGenerator = defaultKeyGenerator;\n        final CacheKeyGenerator altKeyGenInstance = cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElse(null);\n        if (altKeyGenInstance != null) {\n            return altKeyGenInstance;\n        } else {\n            Class<? extends CacheKeyGenerator> alternateKeyGen = cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null);\n            if (alternateKeyGen != null && keyGenerator.getClass() != alternateKeyGen) {\n                keyGenerator = resolveKeyGenerator(alternateKeyGen);\n            }\n            if (keyGenerator == null) {\n                return new DefaultCacheKeyGenerator();\n            }\n            return keyGenerator;\n        }\n\n    }\n\n    private String[] resolveCacheNames(AnnotationValue<CacheConfig> defaultConfig, AnnotationValue<Cacheable> cacheConfig) {\n        String[] cacheNames = cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(null);\n        if (ArrayUtils.isEmpty(cacheNames)) {\n            cacheNames = defaultConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY);\n        }\n        return cacheNames;\n    }\n\n    private void doProceed(MethodInvocationContext context, ValueWrapper wrapper) {\n        Object result = context.proceed();\n        if (result instanceof Optional) {\n            Optional optional = (Optional) result;\n            wrapper.optional = true;\n            if (optional.isPresent()) {\n                wrapper.value = optional.get();\n            }\n        } else {\n            wrapper.value = result;\n        }\n    }\n\n    private void processCachePut(MethodInvocationContext<?, ?> context, ValueWrapper wrapper, AnnotationValue<CachePut> cacheConfig, CacheOperation cacheOperation) {\n        String[] cacheNames = cacheOperation.getCachePutNames(cacheConfig);\n        CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(cacheConfig);\n        String[] parameterNames = cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n        Object[] parameterValues = resolveParams(context, parameterNames);\n        boolean isAsync = cacheConfig.get(MEMBER_ASYNC, Boolean.class, false);\n\n\n        processCachePut(context, wrapper, cacheNames, keyGenerator, parameterValues, isAsync);\n    }\n\n    private void processCachePut(MethodInvocationContext<?, ?> context, ValueWrapper wrapper, String[] cacheNames, CacheKeyGenerator keyGenerator, Object[] parameterValues, boolean isAsync) {\n        if (!ArrayUtils.isEmpty(cacheNames)) {\n            Object v = wrapper.value;\n            if (isAsync) {\n                ioExecutor.submit(() -> {\n                    try {\n                        Object key = keyGenerator.generateKey(context, parameterValues);\n                        for (String cacheName : cacheNames) {\n                            SyncCache cache = cacheManager.getCache(cacheName);\n                            AsyncCache<?> asyncCache = cache.async();\n                            CompletableFuture<Boolean> putFuture = asyncCache.put(key, v);\n                            putFuture.whenCompleteAsync((aBoolean, throwable) -> {\n                                if (throwable != null) {\n                                    asyncCacheErrorHandler.handlePutError(cache, key, v, asRuntimeException(throwable));\n                                }\n                            }, ioExecutor);\n                        }\n                    } catch (Exception e) {\n                        throw new CacheSystemException(\"Cache put operation failed: \" + e.getMessage(), e);\n                    }\n                });\n            } else {\n                Object key = keyGenerator.generateKey(context, parameterValues);\n                syncPut(cacheNames, key, v);\n            }\n        }\n    }\n\n    private void syncPut(String[] cacheNames, Object key, Object value) {\n        for (String cacheName : cacheNames) {\n            SyncCache syncCache = cacheManager.getCache(cacheName);\n            try {\n                syncCache.put(key, value);\n            } catch (RuntimeException e) {\n                if (errorHandler.handlePutError(syncCache, key, value, e)) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    private void processCacheEvict(\n            MethodInvocationContext context,\n            AnnotationValue<CacheInvalidate> cacheConfig,\n            CacheOperation cacheOperation,\n            boolean async) {\n\n        String[] cacheNames = cacheOperation.getCacheInvalidateNames(cacheConfig);\n        CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(cacheConfig);\n        boolean invalidateAll = cacheConfig.getRequiredValue(MEMBER_ALL, Boolean.class);\n        Object key = null;\n        String[] parameterNames = cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n        Object[] parameterValues = resolveParams(context, parameterNames);\n\n        if (!invalidateAll) {\n            key = keyGenerator.generateKey(context, parameterValues);\n        }\n\n        if (!ArrayUtils.isEmpty(cacheNames)) {\n            for (String cacheName : cacheNames) {\n                SyncCache syncCache = cacheManager.getCache(cacheName);\n                if (async) {\n                    AsyncCache<?> asyncCache = syncCache.async();\n                    if (invalidateAll) {\n                        CompletableFuture<Boolean> future = asyncCache.invalidateAll();\n                        future.whenCompleteAsync((aBoolean, throwable) -> {\n                            if (throwable != null) {\n                                asyncCacheErrorHandler.handleInvalidateError(syncCache, asRuntimeException(throwable));\n                            }\n                        }, ioExecutor);\n                    } else {\n                        Object finalKey = key;\n                        CompletableFuture<Boolean> future = asyncCache.invalidate(key);\n                        future.whenCompleteAsync((aBoolean, throwable) -> {\n                            if (throwable != null) {\n                                asyncCacheErrorHandler.handleInvalidateError(syncCache, finalKey, asRuntimeException(throwable));\n                            }\n                        }, ioExecutor);\n                    }\n                } else {\n                    if (invalidateAll) {\n                        try {\n                            syncCache.invalidateAll();\n                        } catch (RuntimeException e) {\n                            if (errorHandler.handleInvalidateError(syncCache, e)) {\n                                throw e;\n                            }\n                        }\n                    } else {\n                        try {\n                            syncCache.invalidate(key);\n                        } catch (RuntimeException e) {\n                            if (errorHandler.handleInvalidateError(syncCache, key, e)) {\n                                throw e;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private RuntimeException asRuntimeException(Throwable throwable) {\n        if (throwable instanceof RuntimeException) {\n            return (RuntimeException) throwable;\n        } else {\n            return new RuntimeException(throwable);\n        }\n    }\n\n    private Object[] resolveParams(MethodInvocationContext<?, ?> context, String[] parameterNames) {\n        Object[] parameterValues;\n        if (ArrayUtils.isEmpty(parameterNames)) {\n            parameterValues = context.getParameterValues();\n        } else {\n            List list = new ArrayList();\n            Map<String, MutableArgumentValue<?>> parameters = context.getParameters();\n            for (String name : parameterNames) {\n                list.add(parameters.get(name).getValue());\n            }\n            parameterValues = list.toArray();\n        }\n        return parameterValues;\n    }\n\n    /**\n     *\n     */\n    private class CacheOperation {\n        final Class returnType;\n        final MethodInvocationContext<?, ?> context;\n        final CacheKeyGenerator defaultKeyGenerator;\n        final AnnotationValue<CacheConfig> defaultConfig;\n        String cacheableCacheName;\n        AnnotationValue<Cacheable> cacheable;\n        List<AnnotationValue<CachePut>> putOperations;\n        List<AnnotationValue<CacheInvalidate>> invalidateOperations;\n\n        CacheOperation(MethodInvocationContext<?, ?> context, Class returnType) {\n            this.context = context;\n            this.returnType = returnType;\n\n            this.defaultConfig = context.getAnnotation(CacheConfig.class);\n            this.defaultKeyGenerator = resolveKeyGenerator(defaultConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null));\n            boolean isVoid = isVoid();\n            this.putOperations = isVoid ? null : putOperations(context);\n            this.invalidateOperations = invalidateOperations(context);\n            if (!isVoid && context.hasStereotype(Cacheable.class)) {\n                AnnotationValue<Cacheable> cacheable = context.getAnnotation(Cacheable.class);\n                String[] names = resolveCacheNames(defaultConfig, cacheable);\n                if (ArrayUtils.isNotEmpty(names)) {\n                    this.cacheableCacheName = names[0];\n                    this.cacheable = cacheable;\n                }\n            }\n        }\n\n        boolean hasWriteOperations() {\n            return putOperations != null || invalidateOperations != null;\n        }\n\n        boolean isVoid() {\n            return void.class == returnType;\n        }\n\n        String[] getCachePutNames(AnnotationValue<CachePut> cacheConfig) {\n            return getCacheNames(cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY));\n        }\n\n        String[] getCacheInvalidateNames(AnnotationValue<CacheInvalidate> cacheConfig) {\n            return getCacheNames(cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY));\n        }\n\n        CacheKeyGenerator getCacheInvalidateKeyGenerator(AnnotationValue<CacheInvalidate> cacheConfig) {\n            return cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElseGet(() ->\n                getKeyGenerator(cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null))\n            );\n        }\n\n        CacheKeyGenerator getCachePutKeyGenerator(AnnotationValue<CachePut> cacheConfig) {\n            return cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElseGet(() ->\n                getKeyGenerator(cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null))\n            );\n        }\n\n        private String[] getCacheNames(String[] cacheNames) {\n            if (ArrayUtils.isEmpty(cacheNames)) {\n                return defaultConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY);\n            } else {\n                return cacheNames;\n            }\n        }\n\n        private CacheKeyGenerator getKeyGenerator(Class<? extends CacheKeyGenerator> alternateKeyGen) {\n            CacheKeyGenerator keyGenerator = defaultKeyGenerator;\n            if (alternateKeyGen != null && defaultKeyGenerator.getClass() != alternateKeyGen) {\n                keyGenerator = resolveKeyGenerator(alternateKeyGen);\n            }\n            return keyGenerator;\n        }\n    }\n\n    /**\n     * The value wrapper.\n     */\n    private class ValueWrapper {\n        Object value;\n        boolean optional;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.scheduling.io.watch;\n\nimport io.micronaut.context.ApplicationContext;\nimport io.micronaut.context.BeanContext;\nimport io.micronaut.context.condition.Condition;\nimport io.micronaut.context.condition.ConditionContext;\nimport io.micronaut.core.annotation.Introspected;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.util.CollectionUtils;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * Custom condition to only enable file watch if the watch paths exist.\n *\n * @author graemerocher\n * @since 1.2.0\n */\n@Introspected\npublic class FileWatchCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context) {\n        BeanContext beanContext = context.getBeanContext();\n        if (beanContext instanceof ApplicationContext) {\n            List<String> paths = ((ApplicationContext) beanContext)\n                    .getEnvironment()\n                    .getProperty(FileWatchConfiguration.PATHS, Argument.listOf(String.class))\n                    .orElse(null);\n\n            if (CollectionUtils.isNotEmpty(paths)) {\n\n\n                boolean matchedPaths = paths.stream().anyMatch(p -> new File(p).exists());\n                if (!matchedPaths) {\n                    context.fail(\"File watch disabled because no paths matching the watch pattern exist (Paths: \" + paths + \")\");\n                }\n                return matchedPaths;\n            }\n        }\n\n        context.fail(\"File watch disabled because no watch paths specified\");\n        return false;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.session.binder;\n\nimport io.micronaut.context.annotation.Requires;\nimport io.micronaut.core.bind.ArgumentBinder;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.value.MutableConvertibleValues;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.filter.OncePerRequestHttpServerFilter;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.TypedRequestArgumentBinder;\nimport io.micronaut.session.Session;\nimport io.micronaut.session.SessionStore;\nimport io.micronaut.session.http.HttpSessionFilter;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\n\n/**\n * Binds an argument of type {@link Session} for controllers.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@SuppressWarnings(\"unused\")\n@Singleton\n@Requires(classes = HttpServerConfiguration.class)\npublic class SessionArgumentBinder implements TypedRequestArgumentBinder<Session> {\n\n    private final SessionStore<Session> sessionStore;\n\n    /**\n     * Constructor.\n     *\n     * @param sessionStore The session store\n     */\n    public SessionArgumentBinder(SessionStore<Session> sessionStore) {\n        this.sessionStore = sessionStore;\n    }\n\n    @Override\n    public Argument<Session> argumentType() {\n        return Argument.of(Session.class);\n    }\n\n    @Override\n    public ArgumentBinder.BindingResult<Session> bind(ArgumentConversionContext<Session> context, HttpRequest<?> source) {\n        if (!source.getAttributes().contains(OncePerRequestHttpServerFilter.getKey(HttpSessionFilter.class))) {\n            // the filter hasn't been executed\n            //noinspection unchecked\n            return ArgumentBinder.BindingResult.EMPTY;\n        }\n\n        MutableConvertibleValues<Object> attrs = source.getAttributes();\n        Optional<Session> existing = attrs.get(HttpSessionFilter.SESSION_ATTRIBUTE, Session.class);\n        if (existing.isPresent()) {\n            return () -> existing;\n        } else {\n            // create a new session store it in the attribute\n            if (!context.getArgument().isNullable()) {\n                Session newSession = sessionStore.newSession();\n                attrs.put(HttpSessionFilter.SESSION_ATTRIBUTE, newSession);\n                return () -> Optional.of(newSession);\n            } else {\n                //noinspection unchecked\n                return BindingResult.EMPTY;\n            }\n        }\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert;\n\nimport io.micronaut.core.annotation.AnnotationMetadataProvider;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.TypeVariableResolver;\nimport io.micronaut.core.util.ArgumentUtils;\nimport io.micronaut.core.util.ArrayUtils;\n\nimport javax.annotation.Nullable;\nimport java.lang.annotation.Annotation;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\n/**\n * A conversion context is a context object supplied to a {@link TypeConverter} that allows more accurate conversion.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConversionContext extends AnnotationMetadataProvider, TypeVariableResolver, ErrorsContext {\n\n    /**\n     * The default conversion context.\n     */\n    ConversionContext DEFAULT = new ConversionContext() {\n    };\n\n    /**\n     * Constant for Boolean argument.\n     */\n    ArgumentConversionContext<Boolean> BOOLEAN = ConversionContext.of(Argument.BOOLEAN);\n\n    /**\n     * Constant for Integer argument.\n     */\n    ArgumentConversionContext<Integer> INT = ConversionContext.of(Argument.INT);\n\n    /**\n     * Constant for Long argument.\n     */\n    ArgumentConversionContext<Long> LONG = ConversionContext.of(Argument.LONG);\n\n    /**\n     * Constant for String argument.\n     */\n    ArgumentConversionContext<String> STRING = ConversionContext.of(Argument.STRING);\n\n    /**\n     * Constant for List<String> argument.\n     */\n    ArgumentConversionContext<List<String>> LIST_OF_STRING = ConversionContext.of(Argument.LIST_OF_STRING);\n\n    /**\n     * In the case where the type to be converted contains generic type arguments this map will return\n     * the concrete types of those arguments. For example for the {@link Map} type two keys will be present\n     * called 'K' and 'V' with the actual types of the key and value.\n     *\n     * @return A map of type variables\n     */\n    @Override\n    default Map<String, Argument<?>> getTypeVariables() {\n        return Collections.emptyMap();\n    }\n\n    /**\n     * @return The locale to use\n     */\n    default Locale getLocale() {\n        return Locale.getDefault();\n    }\n\n    /**\n     * @return The standard charset used in conversion\n     */\n    default Charset getCharset() {\n        return StandardCharsets.UTF_8;\n    }\n\n    /**\n     * Augment this context with data for the given argument.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    @SuppressWarnings(\"unchecked\")\n    default <T> ArgumentConversionContext<T> with(Argument<T> argument) {\n\n        ConversionContext childContext = ConversionContext.of(argument);\n        ConversionContext thisContext = this;\n        return new DefaultArgumentConversionContext(argument, thisContext.getLocale(), thisContext.getCharset()) {\n            @Override\n            public <T extends Annotation> T synthesize(Class<T> annotationClass) {\n                T annotation = childContext.synthesize(annotationClass);\n                if (annotation == null) {\n                    return thisContext.synthesize(annotationClass);\n                }\n                return annotation;\n            }\n\n            @Override\n            public Annotation[] synthesizeAll() {\n                return ArrayUtils.concat(childContext.synthesizeAll(), thisContext.synthesizeAll());\n            }\n\n            @Override\n            public Annotation[] synthesizeDeclared() {\n                return ArrayUtils.concat(childContext.synthesizeDeclared(), thisContext.synthesizeDeclared());\n            }\n\n            @Override\n            public void reject(Exception exception) {\n                thisContext.reject(exception);\n            }\n\n            @Override\n            public Iterator<ConversionError> iterator() {\n                return thisContext.iterator();\n            }\n\n            @Override\n            public Optional<ConversionError> getLastError() {\n                return thisContext.getLastError();\n            }\n        };\n    }\n\n\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param typeVariables The type variables\n     * @return The conversion context\n     */\n    static ConversionContext of(Map<String, Argument<?>> typeVariables) {\n        return new ConversionContext() {\n            @Override\n            public Map<String, Argument<?>> getTypeVariables() {\n                return typeVariables;\n            }\n\n        };\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Argument<T> argument) {\n        return of(argument, null, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Class<T> argument) {\n        ArgumentUtils.requireNonNull(\"argument\", argument);\n        return of(Argument.of(argument), null, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @param locale   The locale\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext of(Argument<T> argument, @Nullable Locale locale) {\n        return of(argument, locale, null);\n    }\n\n    /**\n     * Create a simple {@link ConversionContext} for the given generic type variables.\n     *\n     * @param <T>      type Generic\n     * @param argument The argument\n     * @param locale   The locale\n     * @param charset  The charset\n     * @return The conversion context\n     */\n    static <T> ArgumentConversionContext<T> of(Argument<T> argument, @Nullable Locale locale, @Nullable Charset charset) {\n        ArgumentUtils.requireNonNull(\"argument\", argument);\n        Charset finalCharset = charset != null ? charset : StandardCharsets.UTF_8;\n        Locale finalLocale = locale != null ? locale : Locale.getDefault();\n        return new DefaultArgumentConversionContext<>(argument, finalLocale, finalCharset);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.type.Argument;\n\nimport java.nio.charset.Charset;\nimport java.util.*;\n\n/**\n * Default implementation of the {@link ConversionContext} interface.\n *\n * @param <T> type Generic\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\nclass DefaultArgumentConversionContext<T> implements ArgumentConversionContext<T> {\n    private final Argument<T> argument;\n    private final Locale finalLocale;\n    private final Charset finalCharset;\n    private final List<ConversionError> conversionErrors = new ArrayList<>();\n\n    /**\n     * @param argument     The argument\n     * @param finalLocale  The final locale\n     * @param finalCharset The final charset\n     */\n    DefaultArgumentConversionContext(Argument<T> argument, Locale finalLocale, Charset finalCharset) {\n        this.argument = argument;\n        this.finalLocale = finalLocale;\n        this.finalCharset = finalCharset;\n    }\n\n    @Override\n    public Argument[] getTypeParameters() {\n        return argument.getTypeParameters();\n    }\n\n    @Override\n    public Map<String, Argument<?>> getTypeVariables() {\n        return argument.getTypeVariables();\n    }\n\n    @Override\n    public Locale getLocale() {\n        return finalLocale;\n    }\n\n    @Override\n    public Charset getCharset() {\n        return finalCharset;\n    }\n\n    @Override\n    public void reject(Exception exception) {\n        if (exception != null) {\n            conversionErrors.add(() -> exception);\n        }\n    }\n\n    @Override\n    public void reject(Object value, Exception exception) {\n        if (exception != null) {\n            conversionErrors.add(new ConversionError() {\n                @Override\n                public Optional<Object> getOriginalValue() {\n                    return value != null ? Optional.of(value) : Optional.empty();\n                }\n\n                @Override\n                public Exception getCause() {\n                    return exception;\n                }\n            });\n        }\n    }\n\n    @Override\n    public Optional<ConversionError> getLastError() {\n        if (!conversionErrors.isEmpty()) {\n            return Optional.of(conversionErrors.get(conversionErrors.size() - 1));\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public Iterator<ConversionError> iterator() {\n        return Collections.unmodifiableCollection(conversionErrors).iterator();\n    }\n\n    @Override\n    public Argument<T> getArgument() {\n        return argument;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        DefaultArgumentConversionContext<?> that = (DefaultArgumentConversionContext<?>) o;\n        return Objects.equals(getArgument(), that.getArgument()) &&\n            Objects.equals(finalLocale, that.finalLocale) &&\n            Objects.equals(finalCharset, that.finalCharset);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(argument, finalLocale, finalCharset);\n    }\n\n    @Override\n    public String toString() {\n        return argument.toString();\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert.value;\n\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.reflect.GenericTypeUtils;\nimport io.micronaut.core.type.Argument;\n\nimport javax.annotation.Nullable;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.function.BiConsumer;\n\n/**\n * Specialization of {@link ConvertibleValues} where each name has multiple possible values.\n *\n * @param <V> The generic value\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConvertibleMultiValues<V> extends ConvertibleValues<List<V>> {\n    /**\n     * Get all the values for the given name without applying conversion.\n     *\n     * @param name The header name\n     * @return All the values\n     */\n    List<V> getAll(CharSequence name);\n\n    /**\n     * Get a value without applying any conversion.\n     *\n     * @param name The name of the value\n     * @return The raw value or null\n     * @see #getFirst(CharSequence)\n     */\n    @Nullable V get(CharSequence name);\n\n    /**\n     * @return Whether this values is empty\n     */\n    @Override\n    default boolean isEmpty() {\n        return this == ConvertibleMultiValuesMap.EMPTY || names().isEmpty();\n    }\n\n    /**\n     * Performs the given action for each header. Note that in the case\n     * where multiple values exist for the same header then the consumer will be invoked\n     * multiple times for the same key.\n     *\n     * @param action The action to be performed for each entry\n     * @throws NullPointerException if the specified action is null\n     * @since 1.0\n     */\n    default void forEachValue(BiConsumer<String, V> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> names = names();\n        for (String headerName : names) {\n            Collection<V> values = getAll(headerName);\n            for (V value : values) {\n                action.accept(headerName, value);\n            }\n        }\n    }\n\n    @Override\n    default void forEach(BiConsumer<String, List<V>> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> names = names();\n        for (String headerName : names) {\n            List<V> values = getAll(headerName);\n            action.accept(headerName, values);\n        }\n    }\n\n    @Override\n    default Iterator<Map.Entry<String, List<V>>> iterator() {\n        Iterator<String> headerNames = names().iterator();\n        return new Iterator<Map.Entry<String, List<V>>>() {\n            @Override\n            public boolean hasNext() {\n                return headerNames.hasNext();\n            }\n\n            @Override\n            public Map.Entry<String, List<V>> next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n\n                String name = headerNames.next();\n                return new Map.Entry<String, List<V>>() {\n                    @Override\n                    public String getKey() {\n                        return name;\n                    }\n\n                    @Override\n                    public List<V> getValue() {\n                        return getAll(name);\n                    }\n\n                    @Override\n                    public List<V> setValue(List<V> value) {\n                        throw new UnsupportedOperationException(\"Not mutable\");\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Get the first value of the given header.\n     *\n     * @param name The header name\n     * @return The first value or null if it is present\n     */\n    default Optional<V> getFirst(CharSequence name) {\n        Optional<Class> type = GenericTypeUtils.resolveInterfaceTypeArgument(getClass(), ConvertibleMultiValues.class);\n        return getFirst(name, type.orElse(Object.class));\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param <T>          The generic type\n     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n     */\n    default <T> Optional<T> getFirst(CharSequence name, Class<T> requiredType) {\n        return getFirst(name, Argument.of(requiredType));\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param <T>          The generic type\n     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n     */\n    default <T> Optional<T> getFirst(CharSequence name, Argument<T> requiredType) {\n        V v = get(name);\n        if (v != null) {\n            return ConversionService.SHARED.convert(v, ConversionContext.of(requiredType));\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name              The name of the header\n     * @param conversionContext The conversion context\n     * @param <T>               The generic type\n     * @return If the header is presented and can be converted an optional of the value otherwise {@link Optional#empty()}\n     */\n    default <T> Optional<T> getFirst(CharSequence name, ArgumentConversionContext<T> conversionContext) {\n        V v = get(name);\n        if (v != null) {\n            return ConversionService.SHARED.convert(v, conversionContext);\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Find a header and convert it to the given type.\n     *\n     * @param name         The name of the header\n     * @param requiredType The required type\n     * @param defaultValue The default value\n     * @param <T>          The generic type\n     * @return The first value of the default supplied value if it is isn't present\n     */\n    default <T> T getFirst(CharSequence name, Class<T> requiredType, T defaultValue) {\n        return getFirst(name, requiredType).orElse(defaultValue);\n    }\n\n    /**\n     * Creates a new {@link io.micronaut.core.value.OptionalValues} for the given type and values.\n     *\n     * @param values A map of values\n     * @param <T>    The target generic type\n     * @return The values\n     */\n    static <T> ConvertibleMultiValues<T> of(Map<CharSequence, List<T>> values) {\n        return new ConvertibleMultiValuesMap<>(values);\n    }\n\n    /**\n     * An empty {@link ConvertibleValues}.\n     *\n     * @param <V> The generic type\n     * @return The empty {@link ConvertibleValues}\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <V> ConvertibleMultiValues<V> empty() {\n        return ConvertibleMultiValuesMap.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.convert.value;\n\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.reflect.GenericTypeUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.value.ValueResolver;\n\nimport java.util.*;\nimport java.util.function.BiConsumer;\nimport java.util.stream.Collectors;\n\n/**\n * An interface for classes that represent a map-like structure of values that can be converted.\n *\n * @param <V> The generic value\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface ConvertibleValues<V> extends ValueResolver<CharSequence>, Iterable<Map.Entry<String, V>> {\n\n    ConvertibleValues EMPTY = new ConvertibleValuesMap<>(Collections.emptyMap());\n\n    /**\n     * @return The names of the values\n     */\n    Set<String> names();\n\n    /**\n     * @return The values\n     */\n    Collection<V> values();\n\n    /**\n     * @return Whether this values is empty\n     */\n    default boolean isEmpty() {\n        return this == ConvertibleValues.EMPTY || names().isEmpty();\n    }\n\n    /**\n     * @return The concrete type of the value\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Class<V> getValueType() {\n        Optional<Class> type = GenericTypeUtils.resolveInterfaceTypeArgument(getClass(), ConvertibleValues.class);\n        return type.orElse(Object.class);\n    }\n\n    /**\n     * Whether the given key is contained within these values.\n     *\n     * @param name The key name\n     * @return True if it is\n     */\n    default boolean contains(String name) {\n        return get(name, Argument.OBJECT_ARGUMENT).isPresent();\n    }\n\n    /**\n     * Performs the given action for each value. Note that in the case\n     * where multiple values exist for the same header then the consumer will be invoked\n     * multiple times for the same key.\n     *\n     * @param action The action to be performed for each entry\n     * @throws NullPointerException if the specified action is null\n     * @since 1.0\n     */\n    default void forEach(BiConsumer<String, V> action) {\n        Objects.requireNonNull(action, \"Consumer cannot be null\");\n\n        Collection<String> headerNames = names();\n        for (String headerName : headerNames) {\n            Optional<V> vOptional = this.get(headerName, getValueType());\n            vOptional.ifPresent(v -> action.accept(headerName, v));\n        }\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a map for the given key type and value type. The map represents a copy of the data held by this instance.\n     *\n     * @return The values\n     */\n    default Map<String, V> asMap() {\n        Map<String, V> newMap = new LinkedHashMap<>();\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            newMap.put(key, entry.getValue());\n        }\n        return newMap;\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a map for the given key type and value type. If any entry cannot be\n     * converted to the target key/value type then the entry is simply excluded, hence the size of the map returned\n     * may not match the size of this {@link ConvertibleValues}.\n     *\n     * @param keyType   The key type\n     * @param valueType The value type\n     * @param <KT>      The key type\n     * @param <VT>      The value type\n     * @return The values with the key converted to the given key type and the value to the given value type.\n     */\n    default <KT, VT> Map<KT, VT> asMap(Class<KT> keyType, Class<VT> valueType) {\n        Map<KT, VT> newMap = new LinkedHashMap<>();\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            Optional<KT> convertedKey = ConversionService.SHARED.convert(key, keyType);\n            if (convertedKey.isPresent()) {\n                Optional<VT> convertedValue = ConversionService.SHARED.convert(entry.getValue(), valueType);\n                convertedValue.ifPresent(vt -> newMap.put(convertedKey.get(), vt));\n            }\n        }\n        return newMap;\n    }\n\n    /**\n     * Return this {@link ConvertibleValues} as a {@link Properties} object returning only keys and values that\n     * can be represented as a string.\n     *\n     * @return The values with the key converted to the given key type and the value to the given value type.\n     * @since 1.0.3\n     */\n    default Properties asProperties() {\n        Properties props = new Properties();\n\n        for (Map.Entry<String, V> entry : this) {\n            String key = entry.getKey();\n            V value = entry.getValue();\n            if (value instanceof CharSequence || value instanceof Number) {\n                props.setProperty(key, value.toString());\n            }\n        }\n        return props;\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, Class<V> valueType) {\n        return subMap(prefix, Argument.of(valueType));\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, Argument<V> valueType) {\n        return subMap(prefix, ConversionContext.of(valueType));\n    }\n\n    /**\n     * Returns a submap for all the keys with the given prefix.\n     *\n     * @param prefix    The prefix\n     * @param valueType The value type\n     * @return The submap\n     */\n    @SuppressWarnings(\"unchecked\")\n    default Map<String, V> subMap(String prefix, ArgumentConversionContext<V> valueType) {\n        // special handling for maps for resolving sub keys\n        String finalPrefix = prefix + '.';\n        return names().stream()\n            .filter(name -> name.startsWith(finalPrefix))\n            .collect(Collectors.toMap((name) -> name.substring(finalPrefix.length()), (name) -> get(name, valueType).orElse(null)));\n    }\n\n    @SuppressWarnings(\"NullableProblems\")\n    @Override\n    default Iterator<Map.Entry<String, V>> iterator() {\n        Iterator<String> names = names().iterator();\n        return new Iterator<Map.Entry<String, V>>() {\n            @Override\n            public boolean hasNext() {\n                return names.hasNext();\n            }\n\n            @Override\n            public Map.Entry<String, V> next() {\n                if (!hasNext()) {\n                    throw new NoSuchElementException();\n                }\n\n                String name = names.next();\n                return new Map.Entry<String, V>() {\n                    @Override\n                    public String getKey() {\n                        return name;\n                    }\n\n                    @Override\n                    public V getValue() {\n                        return get(name, getValueType()).orElse(null);\n                    }\n\n                    @Override\n                    public V setValue(V value) {\n                        throw new UnsupportedOperationException(\"Not mutable\");\n                    }\n                };\n            }\n        };\n    }\n\n    /**\n     * Creates a new {@link ConvertibleValues} for the values.\n     *\n     * @param values A map of values\n     * @param <T>    The target generic type\n     * @return The values\n     */\n    static <T> ConvertibleValues<T> of(Map<? extends CharSequence, T> values) {\n        if (values == null) {\n            return ConvertibleValuesMap.empty();\n        } else {\n            return new ConvertibleValuesMap<>(values);\n        }\n    }\n\n    /**\n     * An empty {@link ConvertibleValues}.\n     *\n     * @param <V> The generic type\n     * @return The empty {@link ConvertibleValues}\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <V> ConvertibleValues<V> empty() {\n        return ConvertibleValues.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.type;\n\nimport io.micronaut.core.annotation.AnnotatedElement;\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.UsedByGeneratedCode;\nimport io.micronaut.core.naming.NameUtils;\nimport io.micronaut.core.reflect.ReflectionUtils;\nimport io.micronaut.core.util.ArrayUtils;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Represents an argument to a method or constructor or type.\n *\n * @param <T> The argument type\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface Argument<T> extends TypeVariableResolver, AnnotatedElement, Type {\n\n    /**\n     * Constant for string argument.\n     */\n    Argument<String> STRING = Argument.of(String.class);\n\n    /**\n     * Constant for int argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Integer> INT = Argument.of(int.class);\n\n    /**\n     * Constant for long argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Long> LONG = Argument.of(long.class);\n\n    /**\n     * Constant for float argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Float> FLOAT = Argument.of(float.class);\n\n    /**\n     * Constant for double argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Double> DOUBLE = Argument.of(double.class);\n\n    /**\n     * Constant for void argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Void> VOID = Argument.of(void.class);\n\n    /**\n     * Constant for byte argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Byte> BYTE = Argument.of(byte.class);\n\n    /**\n     * Constant for boolean argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Boolean> BOOLEAN = Argument.of(boolean.class);\n\n    /**\n     * Constant char argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Character> CHAR = Argument.of(char.class);\n\n    /**\n     * Constant short argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Short> SHORT = Argument.of(short.class);\n\n    /**\n     * Constant representing zero arguments. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    @UsedByGeneratedCode\n    Argument[] ZERO_ARGUMENTS = new Argument[0];\n\n    /**\n     * Default Object argument. Used by generated code, do not remove.\n     */\n    @SuppressWarnings(\"unused\")\n    Argument<Object> OBJECT_ARGUMENT = of(Object.class);\n\n    /**\n     * Constant for List<String> argument.\n     */\n    Argument<List<String>> LIST_OF_STRING = Argument.listOf(String.class);\n\n    /**\n     * @return The name of the argument\n     */\n    @Nonnull String getName();\n\n    @Override\n    @Nonnull\n    default String getTypeName() {\n        return getName();\n    }\n\n    /**\n     * @return The type of the argument\n     */\n    @Nonnull Class<T> getType();\n\n    /**\n     * Whether the types are equivalent. The regular {@link Object#equals(Object)} implementation includes the argument\n     * name within the comparison so this method offers a variation that just compares types.\n     *\n     * @param other The type type\n     * @return True if they are equal\n     */\n    boolean equalsType(Argument<?> other);\n\n    /**\n     * The hash code including only the types. The regular {@link Object#hashCode()} implementation includes the\n     * argument name within the comparison so this method offers a variation that just compares types.\n     *\n     * @return The type hash code\n     */\n    int typeHashCode();\n\n    /**\n     * Whether the given argument is an instance.\n     * @param o The object\n     * @return True if it is an instance of this type\n     */\n    default boolean isInstance(@Nullable Object o) {\n        if (o == null) {\n            return false;\n        }\n        return getType().isInstance(o);\n    }\n\n    /**\n     * Returns the string representation of the argument type, including generics.\n     *\n     * @param simple If true, output the simple name of types\n     * @return The type string representation\n     */\n    default String getTypeString(boolean simple) {\n        Class<T> type = getType();\n        StringBuilder returnType = new StringBuilder(simple ? type.getSimpleName() : type.getName());\n        Map<String, Argument<?>> generics = getTypeVariables();\n        if (!generics.isEmpty()) {\n            returnType\n                    .append(\"<\")\n                    .append(generics.values()\n                            .stream()\n                            .map(arg -> arg.getTypeString(simple))\n                            .collect(Collectors.joining(\", \")))\n                    .append(\">\");\n        }\n        return returnType.toString();\n    }\n\n    /**\n     * @return Whether the argument has any type variables\n     */\n    default boolean hasTypeVariables() {\n        return !getTypeVariables().isEmpty();\n    }\n\n    /**\n     * Convert an argument array to a class array.\n     *\n     * @param arguments The arguments\n     * @return The class array\n     */\n    static @Nonnull Class[] toClassArray(Argument... arguments) {\n        if (ArrayUtils.isEmpty(arguments)) {\n            return ReflectionUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class[] types = new Class[arguments.length];\n        for (int i = 0; i < arguments.length; i++) {\n            Argument argument = arguments[i];\n            types[i] = argument.getType();\n        }\n        return types;\n    }\n\n    /**\n     * Convert the arguments to a string representation.\n     *\n     * @param arguments The arguments\n     * @return The String representation\n     */\n    static @Nonnull String toString(Argument... arguments) {\n        StringBuilder baseString = new StringBuilder();\n        if (ArrayUtils.isNotEmpty(arguments)) {\n            for (int i = 0; i < arguments.length; i++) {\n                Argument argument = arguments[i];\n                baseString.append(argument.toString());\n                if (i != arguments.length - 1) {\n                    baseString.append(',');\n                }\n            }\n        }\n        return baseString.toString();\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param name           The name\n     * @param typeParameters the type parameters\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name,\n        @Nullable Argument... typeParameters) {\n        return new DefaultArgument<>(type, name, AnnotationMetadata.EMPTY_METADATA, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata the annotation metadata\n     * @param typeParameters     the type parameters\n     * @param <T>                The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name,\n        AnnotationMetadata annotationMetadata,\n        @Nullable Argument... typeParameters) {\n        return new DefaultArgument<>(type, name, annotationMetadata, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type The type\n     * @param name The name\n     * @param <T>  The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type,\n        String name) {\n        return new DefaultArgument<>(type, name, AnnotationMetadata.EMPTY_METADATA, Argument.ZERO_ARGUMENTS);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param typeParameters The parameters type\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type, @Nullable Argument... typeParameters) {\n        if (ArrayUtils.isEmpty(typeParameters)) {\n            return of(type);\n        }\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, typeParameters);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type The type\n     * @param <T>  The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(\n        Class<T> type) {\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, Argument.ZERO_ARGUMENTS);\n    }\n\n    /**\n     * Creates a new argument for the given type and name.\n     *\n     * @param type           The type\n     * @param typeParameters the parameters type\n     * @param <T>            The generic type\n     * @return The argument instance\n     */\n    @UsedByGeneratedCode\n    @Nonnull\n    static <T> Argument<T> of(Class<T> type, @Nullable Class<?>... typeParameters) {\n        if (ArrayUtils.isEmpty(typeParameters)) {\n            return of(type);\n        }\n\n        TypeVariable<Class<T>>[] parameters = type.getTypeParameters();\n        int len = typeParameters.length;\n        if (parameters.length != len) {\n            throw new IllegalArgumentException(\"Type parameter length does not match. Required: \" + parameters.length + \", Specified: \" + len);\n        }\n        Argument[] typeArguments = new Argument[len];\n        for (int i = 0; i < parameters.length; i++) {\n            TypeVariable<Class<T>> parameter = parameters[i];\n            typeArguments[i] = Argument.of(typeParameters[i], parameter.getName());\n        }\n        return new DefaultArgument<>(type, NameUtils.decapitalize(type.getSimpleName()), AnnotationMetadata.EMPTY_METADATA, typeArguments);\n    }\n\n    /**\n     * Creates a new argument representing a generic list.\n     *\n     * @param type list element type\n     * @param <T>  list element type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <T> Argument<List<T>> listOf(Class<T> type) {\n        //noinspection unchecked\n        return of((Class<List<T>>) ((Class) List.class), type);\n    }\n\n    /**\n     * Creates a new argument representing a generic set.\n     *\n     * @param type set element type\n     * @param <T>  set element type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <T> Argument<Set<T>> setOf(Class<T> type) {\n        //noinspection unchecked\n        return of((Class<Set<T>>) ((Class) Set.class), type);\n    }\n\n    /**\n     * Creates a new argument representing a generic map.\n     *\n     * @param keyType The key type\n     * @param valueType The value type\n     * @param <K>  The map key type\n     * @param <V> The map value type\n     * @return The argument instance\n     */\n    @Nonnull\n    static <K, V> Argument<Map<K, V>> mapOf(Class<K> keyType, Class<V> valueType) {\n        //noinspection unchecked\n        return of((Class<Map<K, V>>) ((Class) Map.class), keyType, valueType);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.core.type;\n\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.naming.NameUtils;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.*;\n\n/**\n * Represents an argument to a constructor or method.\n *\n * @param <T> The argument type\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\npublic class DefaultArgument<T> implements Argument<T> {\n\n    private final Class<T> type;\n    private final String name;\n    private final Map<String, Argument<?>> typeParameters;\n    private final Argument[] typeParameterArray;\n    private final AnnotationMetadata annotationMetadata;\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     * @param genericTypes       The generic types\n     */\n    public DefaultArgument(Class<T> type, String name, AnnotationMetadata annotationMetadata, Argument... genericTypes) {\n        this(type, name, annotationMetadata, initializeTypeParameters(genericTypes), genericTypes);\n    }\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     * @param typeParameters     The map of parameters\n     * @param typeParameterArray The array of arguments\n     */\n    public DefaultArgument(Class<T> type, String name, AnnotationMetadata annotationMetadata, Map<String, Argument<?>> typeParameters, Argument[] typeParameterArray) {\n        this.type = type;\n        this.name = name;\n        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n        this.typeParameters = typeParameters;\n        this.typeParameterArray = typeParameterArray;\n    }\n\n    /**\n     * @param type               The type\n     * @param name               The name\n     * @param annotationMetadata The annotation metadata\n     */\n    public DefaultArgument(Type type, String name, AnnotationMetadata annotationMetadata) {\n        this.annotationMetadata = annotationMetadata != null ? annotationMetadata : AnnotationMetadata.EMPTY_METADATA;\n        if (type == null) {\n            type = getClass().getGenericSuperclass();\n            if (type instanceof ParameterizedType) {\n                type = ((ParameterizedType) type).getActualTypeArguments()[0];\n            } else {\n                throw new IllegalArgumentException(type + \" is not parameterized\");\n            }\n        }\n        if (type instanceof Class) {\n            //noinspection unchecked\n            this.type = (Class<T>) type;\n            this.typeParameterArray = Argument.ZERO_ARGUMENTS;\n        } else if (type instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) type;\n            //noinspection unchecked\n            this.type = (Class<T>) parameterizedType.getRawType();\n            TypeVariable<Class<T>>[] params = this.type.getTypeParameters();\n            Type[] paramValues = parameterizedType.getActualTypeArguments();\n            typeParameterArray = new Argument[params.length];\n            for (int i = 0; i < params.length; i++) {\n                TypeVariable param = params[i];\n                Type value = paramValues[i];\n                typeParameterArray[i] = new DefaultArgument(value, param.getName(), AnnotationMetadata.EMPTY_METADATA);\n            }\n        } else {\n            throw new IllegalArgumentException(type.getClass().getSimpleName() + \" types are not supported\");\n        }\n        if (name == null) {\n            name = NameUtils.decapitalize(this.type.getSimpleName());\n        }\n        this.name = name;\n        this.typeParameters = initializeTypeParameters(this.typeParameterArray);\n    }\n\n    @Override\n    public AnnotationMetadata getAnnotationMetadata() {\n        return annotationMetadata;\n    }\n\n    @Override\n    public Optional<Argument<?>> getFirstTypeVariable() {\n        if (!typeParameters.isEmpty()) {\n            return typeParameters.values().stream().findFirst();\n        }\n        return Optional.empty();\n    }\n\n    @Override\n    public Argument[] getTypeParameters() {\n        return typeParameterArray;\n    }\n\n    @Override\n    public Map<String, Argument<?>> getTypeVariables() {\n        return this.typeParameters;\n    }\n\n    @Override\n    public Class<T> getType() {\n        return type;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public String toString() {\n        return type.getSimpleName() + \" \" + name;\n    }\n\n    @Override\n    public boolean equalsType(Argument<?> o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null) {\n            return false;\n        }\n        return Objects.equals(type, o.getType()) &&\n            Objects.equals(typeParameters, o.getTypeVariables());\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof DefaultArgument)) {\n            return false;\n        }\n        DefaultArgument<?> that = (DefaultArgument<?>) o;\n        return Objects.equals(type, that.type) &&\n            Objects.equals(name, that.name) &&\n            Objects.equals(typeParameters, that.typeParameters);\n    }\n\n    @Override\n    public int typeHashCode() {\n        return Objects.hash(type, typeParameters);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(type, name, typeParameters);\n    }\n\n    private static Map<String, Argument<?>> initializeTypeParameters(Argument[] genericTypes) {\n        Map<String, Argument<?>> typeParameters;\n        if (genericTypes != null && genericTypes.length > 0) {\n            typeParameters = new LinkedHashMap<>(genericTypes.length);\n            for (Argument genericType : genericTypes) {\n                typeParameters.put(genericType.getName(), genericType);\n            }\n        } else {\n            typeParameters = Collections.emptyMap();\n        }\n        return typeParameters;\n    }\n\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.client.exceptions;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.naming.Described;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.hateoas.JsonError;\nimport io.micronaut.http.hateoas.VndError;\n\nimport java.util.Optional;\n\n/**\n * Strategy interface for decoding the error from a server respponse.\n *\n * @author graemerocher\n * @since 1.0\n */\n@Internal\npublic interface HttpClientErrorDecoder {\n\n    /**\n     * The default implementation.\n     */\n    HttpClientErrorDecoder DEFAULT = new HttpClientErrorDecoder() { };\n\n    /**\n     * Default message decoder.\n     *\n     * @param error The error object\n     * @return The message\n     */\n    default Optional<String> getMessage(Object error) {\n        if (error == null) {\n            return Optional.empty();\n        }\n        if (error instanceof JsonError) {\n            return Optional.ofNullable(((JsonError) error).getMessage());\n        } else {\n            if (error instanceof Described) {\n                return Optional.ofNullable(((Described) error).getDescription());\n            } else {\n                return Optional.of(error.toString());\n            }\n        }\n    }\n\n    /**\n     * Gets the error type for the given media type.\n     *\n     * @param mediaType The media type\n     * @return The error type\n     */\n    default Argument<?> getErrorType(MediaType mediaType) {\n        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {\n            return Argument.of(JsonError.class);\n        } else if (mediaType.equals(MediaType.APPLICATION_VND_ERROR_TYPE)) {\n            return Argument.of(VndError.class);\n        } else {\n            return Argument.STRING;\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty;\n\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.context.event.ApplicationEventPublisher;\nimport io.micronaut.context.exceptions.BeanInstantiationException;\nimport io.micronaut.core.annotation.AnnotationMetadata;\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.async.subscriber.CompletionAwareSubscriber;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.io.Writable;\nimport io.micronaut.core.io.buffer.ByteBuffer;\nimport io.micronaut.core.io.buffer.ReferenceCounted;\nimport io.micronaut.core.reflect.ClassUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.ReturnType;\nimport io.micronaut.http.HttpAttributes;\nimport io.micronaut.http.HttpHeaders;\nimport io.micronaut.http.HttpMethod;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.HttpResponse;\nimport io.micronaut.http.HttpStatus;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.MutableHttpHeaders;\nimport io.micronaut.http.MutableHttpResponse;\nimport io.micronaut.http.annotation.Produces;\nimport io.micronaut.http.annotation.Status;\nimport io.micronaut.http.codec.MediaTypeCodec;\nimport io.micronaut.http.codec.MediaTypeCodecRegistry;\nimport io.micronaut.http.context.event.HttpRequestTerminatedEvent;\nimport io.micronaut.http.exceptions.HttpStatusException;\nimport io.micronaut.http.filter.HttpFilter;\nimport io.micronaut.http.filter.HttpServerFilter;\nimport io.micronaut.http.filter.OncePerRequestHttpServerFilter;\nimport io.micronaut.http.filter.ServerFilterChain;\nimport io.micronaut.http.hateoas.JsonError;\nimport io.micronaut.http.hateoas.Link;\nimport io.micronaut.http.multipart.PartData;\nimport io.micronaut.http.multipart.StreamingFileUpload;\nimport io.micronaut.http.netty.NettyMutableHttpResponse;\nimport io.micronaut.buffer.netty.NettyByteBufferFactory;\nimport io.micronaut.http.netty.content.HttpContentUtil;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.http.server.binding.RequestArgumentSatisfier;\nimport io.micronaut.http.server.exceptions.ExceptionHandler;\nimport io.micronaut.http.server.exceptions.InternalServerException;\nimport io.micronaut.http.server.netty.async.ContextCompletionAwareSubscriber;\nimport io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;\nimport io.micronaut.http.server.netty.multipart.NettyPartData;\nimport io.micronaut.http.server.netty.multipart.NettyStreamingFileUpload;\nimport io.micronaut.http.server.netty.types.NettyCustomizableResponseTypeHandler;\nimport io.micronaut.http.server.netty.types.NettyCustomizableResponseTypeHandlerRegistry;\nimport io.micronaut.http.server.netty.types.files.NettyStreamedFileCustomizableResponseType;\nimport io.micronaut.http.server.netty.types.files.NettySystemFileCustomizableResponseType;\nimport io.micronaut.http.server.types.files.FileCustomizableResponseType;\nimport io.micronaut.inject.BeanType;\nimport io.micronaut.inject.MethodExecutionHandle;\nimport io.micronaut.inject.qualifiers.Qualifiers;\nimport io.micronaut.runtime.http.codec.TextPlainCodec;\nimport io.micronaut.scheduling.executor.ExecutorSelector;\nimport io.micronaut.web.router.*;\nimport io.micronaut.web.router.exceptions.DuplicateRouteException;\nimport io.micronaut.web.router.exceptions.UnsatisfiedRouteException;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport io.micronaut.web.router.resource.StaticResourceResolver;\nimport io.micronaut.websocket.annotation.OnMessage;\nimport io.micronaut.websocket.annotation.OnOpen;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufHolder;\nimport io.netty.buffer.ByteBufOutputStream;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandler.Sharable;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.handler.codec.http.*;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.FileUpload;\nimport io.netty.handler.codec.http.multipart.HttpData;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.reactivex.BackpressureStrategy;\nimport io.reactivex.Completable;\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.LongConsumer;\nimport io.reactivex.processors.UnicastProcessor;\nimport io.reactivex.schedulers.Schedulers;\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscriber;\nimport org.reactivestreams.Subscription;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Paths;\nimport java.time.LocalDateTime;\nimport java.util.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Internal implementation of the {@link io.netty.channel.ChannelInboundHandler} for Micronaut.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Internal\n@Sharable\nclass RoutingInBoundHandler extends SimpleChannelInboundHandler<io.micronaut.http.HttpRequest<?>> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(RoutingInBoundHandler.class);\n    private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern.compile(\n            \"^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$\", Pattern.CASE_INSENSITIVE);\n    private static final Argument ARGUMENT_PART_DATA = Argument.of(PartData.class);\n\n    private final Router router;\n    private final ExecutorSelector executorSelector;\n    private final StaticResourceResolver staticResourceResolver;\n    private final ExecutorService ioExecutor;\n    private final BeanLocator beanLocator;\n    private final NettyHttpServerConfiguration serverConfiguration;\n    private final RequestArgumentSatisfier requestArgumentSatisfier;\n    private final MediaTypeCodecRegistry mediaTypeCodecRegistry;\n    private final NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry;\n\n    /**\n     * @param beanLocator                             The bean locator\n     * @param router                                  The router\n     * @param mediaTypeCodecRegistry                  The media type codec registry\n     * @param customizableResponseTypeHandlerRegistry The customizable response type handler registry\n     * @param staticResourceResolver                  The static resource resolver\n     * @param serverConfiguration                     The Netty HTTP server configuration\n     * @param requestArgumentSatisfier                The Request argument satisfier\n     * @param executorSelector                        The executor selector\n     * @param ioExecutor                              The IO executor\n     */\n    RoutingInBoundHandler(\n        BeanLocator beanLocator,\n        Router router,\n        MediaTypeCodecRegistry mediaTypeCodecRegistry,\n        NettyCustomizableResponseTypeHandlerRegistry customizableResponseTypeHandlerRegistry,\n        StaticResourceResolver staticResourceResolver,\n        NettyHttpServerConfiguration serverConfiguration,\n        RequestArgumentSatisfier requestArgumentSatisfier,\n        ExecutorSelector executorSelector,\n        ExecutorService ioExecutor) {\n\n        this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;\n        this.customizableResponseTypeHandlerRegistry = customizableResponseTypeHandlerRegistry;\n        this.beanLocator = beanLocator;\n        this.staticResourceResolver = staticResourceResolver;\n        this.ioExecutor = ioExecutor;\n        this.executorSelector = executorSelector;\n        this.router = router;\n        this.requestArgumentSatisfier = requestArgumentSatisfier;\n        this.serverConfiguration = serverConfiguration;\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);\n        if (ctx.channel().isWritable()) {\n            ctx.flush();\n        }\n        NettyHttpRequest request = NettyHttpRequest.remove(ctx);\n        if (request != null) {\n            try {\n                request.release();\n            } finally {\n                if (beanLocator instanceof ApplicationEventPublisher) {\n                    ctx.executor().execute(() -> {\n                        try {\n                            ((ApplicationEventPublisher) beanLocator).publishEvent(\n                                    new HttpRequestTerminatedEvent(\n                                            request\n                                    )\n                            );\n                        } catch (Exception e) {\n                            if (LOG.isErrorEnabled()) {\n                                LOG.error(\"Error publishing request terminated event: \" + e.getMessage(), e);\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        try {\n            if (evt instanceof IdleStateEvent) {\n                IdleStateEvent idleStateEvent = (IdleStateEvent) evt;\n                IdleState state = idleStateEvent.state();\n                if (state == IdleState.ALL_IDLE) {\n                    ctx.close();\n                }\n            }\n        } finally {\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        NettyHttpRequest nettyHttpRequest = NettyHttpRequest.remove(ctx);\n        if (nettyHttpRequest == null) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Micronaut Server Error - No request state present. Cause: \" + cause.getMessage(), cause);\n            }\n            ctx.writeAndFlush(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR));\n            return;\n        }\n\n        exceptionCaughtInternal(ctx, cause, nettyHttpRequest, true);\n    }\n\n    private void exceptionCaughtInternal(ChannelHandlerContext ctx,\n                                         Throwable cause,\n                                         NettyHttpRequest nettyHttpRequest,\n                                         boolean nettyException) {\n        RouteMatch<?> errorRoute = null;\n        // find the origination of of the route\n        RouteMatch<?> originalRoute = nettyHttpRequest.getMatchedRoute();\n        Class declaringType = null;\n        if (originalRoute instanceof MethodExecutionHandle) {\n            declaringType = ((MethodExecutionHandle) originalRoute).getDeclaringType();\n        }\n\n        // when arguments do not match, then there is UnsatisfiedRouteException, we can handle this with a routed bad request\n        if (cause instanceof UnsatisfiedRouteException) {\n            if (declaringType != null) {\n                // handle error with a method that is non global with bad request\n                errorRoute = router.route(declaringType, HttpStatus.BAD_REQUEST).orElse(null);\n            }\n            if (errorRoute == null) {\n                // handle error with a method that is global with bad request\n                errorRoute = router.route(HttpStatus.BAD_REQUEST).orElse(null);\n            }\n        } else if (cause instanceof HttpStatusException) {\n            HttpStatusException statusException = (HttpStatusException) cause;\n            if (declaringType != null) {\n                // handle error with a method that is non global with bad request\n                errorRoute = router.route(declaringType, statusException.getStatus()).orElse(null);\n            }\n            if (errorRoute == null) {\n                // handle error with a method that is global with bad request\n                errorRoute = router.route(statusException.getStatus()).orElse(null);\n            }\n        } else if (cause instanceof BeanInstantiationException && declaringType != null) {\n            // If the controller could not be instantiated, don't look for a local error route\n            Optional<Class> rootBeanType = ((BeanInstantiationException) cause).getRootBeanType().map(BeanType::getBeanType);\n            if (rootBeanType.isPresent() && declaringType == rootBeanType.get()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Failed to instantiate [{}]. Skipping lookup of a local error route\", declaringType.getName());\n                }\n                declaringType = null;\n            }\n        }\n\n        // any another other exception may arise. handle these with non global exception marked method or a global exception marked method.\n        if (errorRoute == null) {\n            if (declaringType != null) {\n                errorRoute = router.route(declaringType, cause).orElse(null);\n            }\n            if (errorRoute == null) {\n                errorRoute = router.route(cause).orElse(null);\n            }\n        }\n\n        if (errorRoute != null) {\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Found matching exception handler for exception [{}]: {}\", cause.getMessage(), errorRoute);\n            }\n            errorRoute = requestArgumentSatisfier.fulfillArgumentRequirements(errorRoute, nettyHttpRequest, false);\n            MediaType defaultResponseMediaType = errorRoute.getProduces().stream().findFirst().orElse(MediaType.APPLICATION_JSON_TYPE);\n            try {\n                final MethodBasedRouteMatch<?, ?> methodBasedRoute = (MethodBasedRouteMatch) errorRoute;\n                Class<?> javaReturnType = errorRoute.getReturnType().getType();\n                boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);\n                boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;\n                Flowable resultFlowable = Flowable.defer(() -> {\n                      Object result = methodBasedRoute.execute();\n                      MutableHttpResponse<?> response = errorResultToResponse(result);\n                      response.setAttribute(HttpAttributes.ROUTE_MATCH, methodBasedRoute);\n                      return Flowable.just(response);\n                });\n\n                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                        methodBasedRoute.getDeclaringType(),\n                        methodBasedRoute.getReturnType(),\n                        isReactiveReturnType,\n                        methodBasedRoute.getAnnotationMetadata(),\n                        requestReference,\n                        resultFlowable);\n\n                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                        requestReference,\n                        routePublisher,\n                        ctx.channel().eventLoop(),\n                        nettyException);\n\n                subscribeToResponsePublisher(\n                        ctx,\n                        defaultResponseMediaType,\n                        requestReference,\n                        filteredPublisher\n                );\n\n                if (serverConfiguration.isLogHandledExceptions()) {\n                    logException(cause);\n                }\n\n            } catch (Throwable e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(\"Exception occurred executing error handler. Falling back to default error handling: \" + e.getMessage(), e);\n                }\n                writeDefaultErrorResponse(ctx, nettyHttpRequest, e);\n            }\n        } else {\n\n            Optional<ExceptionHandler> exceptionHandler = beanLocator\n                    .findBean(ExceptionHandler.class, Qualifiers.byTypeArgumentsClosest(cause.getClass(), Object.class));\n\n            if (exceptionHandler.isPresent()) {\n                ExceptionHandler handler = exceptionHandler.get();\n                MediaType defaultResponseMediaType = MediaType.fromType(handler.getClass()).orElse(MediaType.APPLICATION_JSON_TYPE);\n                try {\n                    Flowable resultFlowable = Flowable.defer(() -> {\n                        Object result = handler.handle(nettyHttpRequest, cause);\n                        MutableHttpResponse<?> response = errorResultToResponse(result);\n                        return Flowable.just(response);\n                    });\n\n                    AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                    Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                            handler.getClass(),\n                            ReturnType.of(HttpResponse.class),\n                            false,\n                            AnnotationMetadata.EMPTY_METADATA,\n                            requestReference,\n                            resultFlowable);\n\n                    Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                            requestReference,\n                            routePublisher,\n                            ctx.channel().eventLoop(),\n                            nettyException);\n\n                    subscribeToResponsePublisher(\n                            ctx,\n                            defaultResponseMediaType,\n                            requestReference,\n                            filteredPublisher\n                    );\n\n                    if (serverConfiguration.isLogHandledExceptions()) {\n                        logException(cause);\n                    }\n                } catch (Throwable e) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Exception occurred executing error handler. Falling back to default error handling.\");\n                    }\n                    writeDefaultErrorResponse(ctx, nettyHttpRequest, e);\n                }\n            } else {\n                logException(cause);\n\n                Flowable resultFlowable = Flowable.defer(() ->\n                        Flowable.just(HttpResponse.serverError().body(new JsonError(\"Internal Server Error: \" + cause.getMessage())))\n                );\n\n                AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(nettyHttpRequest);\n                Flowable<MutableHttpResponse<?>> routePublisher = buildRoutePublisher(\n                        null,\n                        ReturnType.of(HttpResponse.class),\n                        false,\n                        AnnotationMetadata.EMPTY_METADATA,\n                        requestReference,\n                        resultFlowable);\n\n                Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                        requestReference,\n                        routePublisher,\n                        ctx.channel().eventLoop(),\n                        nettyException);\n\n                subscribeToResponsePublisher(\n                        ctx,\n                        MediaType.APPLICATION_JSON_TYPE,\n                        requestReference,\n                        filteredPublisher\n                );\n            }\n        }\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, io.micronaut.http.HttpRequest<?> request) {\n        ctx.channel().config().setAutoRead(false);\n        io.micronaut.http.HttpMethod httpMethod = request.getMethod();\n        String requestPath = request.getPath();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Matching route {} - {}\", httpMethod, requestPath);\n        }\n\n        NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) request;\n        io.netty.handler.codec.http.HttpRequest nativeRequest = nettyHttpRequest.getNativeRequest();\n        // handle decoding failure\n        DecoderResult decoderResult = nativeRequest.decoderResult();\n        if (decoderResult.isFailure()) {\n            Throwable cause = decoderResult.cause();\n            HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;\n            handleStatusError(\n                    ctx,\n                    request,\n                    nettyHttpRequest,\n                    HttpResponse.status(status),\n                    status.getReason()\n            );\n            return;\n        }\n        Optional<UriRouteMatch<Object, Object>> routeMatch = Optional.empty();\n\n        List<UriRouteMatch<Object, Object>> uriRoutes = router.findAllClosest(request);\n\n        if (uriRoutes.size() > 1) {\n            throw new DuplicateRouteException(requestPath, uriRoutes);\n        } else if (uriRoutes.size() == 1) {\n            UriRouteMatch<Object, Object> establishedRoute = uriRoutes.get(0);\n            request.setAttribute(HttpAttributes.ROUTE, establishedRoute.getRoute());\n            request.setAttribute(HttpAttributes.ROUTE_MATCH, establishedRoute);\n            request.setAttribute(HttpAttributes.URI_TEMPLATE, establishedRoute.getRoute().getUriMatchTemplate().toString());\n            routeMatch = Optional.of(establishedRoute);\n        }\n\n        RouteMatch<?> route;\n\n        if (!routeMatch.isPresent()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"No matching route found for URI {} and method {}\", request.getUri(), httpMethod);\n            }\n\n            // if there is no route present try to locate a route that matches a different content type\n            Set<MediaType> existingRouteConsumes = router\n                    .find(httpMethod, requestPath)\n                    .map(UriRouteMatch::getRoute)\n                    .flatMap(r -> r.getConsumes().stream())\n                    .collect(Collectors.toSet());\n\n            if (!existingRouteConsumes.isEmpty() && !existingRouteConsumes.contains(MediaType.ALL_TYPE)) {\n                MediaType contentType = request.getContentType().orElse(null);\n                if (contentType != null) {\n                    if (!existingRouteConsumes.contains(contentType)) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Content type not allowed for URI {}, method {}, and content type {}\", request.getUri(), httpMethod, contentType);\n                        }\n\n                        handleStatusError(\n                                ctx,\n                                request,\n                                nettyHttpRequest,\n                                HttpResponse.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE),\n                                \"Content Type [\" + contentType + \"] not allowed. Allowed types: \" + existingRouteConsumes);\n                        return;\n                    }\n                }\n            }\n\n            // if there is no route present try to locate a route that matches a different HTTP method\n            Set<io.micronaut.http.HttpMethod> existingRouteMethods = router\n                    .findAny(request.getUri().toString())\n                    .map(UriRouteMatch::getHttpMethod)\n                    .collect(Collectors.toSet());\n\n            if (!existingRouteMethods.isEmpty()) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Method not allowed for URI {} and method {}\", request.getUri(), httpMethod);\n                }\n\n                handleStatusError(\n                        ctx,\n                        request,\n                        nettyHttpRequest,\n                        HttpResponse.notAllowed(existingRouteMethods),\n                        \"Method [\" + httpMethod + \"] not allowed for URI [\" + request.getUri() + \"]. Allowed methods: \" + existingRouteMethods);\n                return;\n            }\n\n            Optional<? extends FileCustomizableResponseType> optionalFile = matchFile(requestPath);\n\n            if (optionalFile.isPresent()) {\n                route = new BasicObjectRouteMatch(optionalFile.get());\n            } else {\n                Optional<RouteMatch<Object>> statusRoute = router.route(HttpStatus.NOT_FOUND);\n                if (statusRoute.isPresent()) {\n                    route = statusRoute.get();\n                } else {\n                    emitDefaultNotFoundResponse(ctx, request);\n                    return;\n                }\n            }\n\n        } else {\n            route = routeMatch.get();\n        }\n\n        if (LOG.isDebugEnabled()) {\n            if (route instanceof MethodBasedRouteMatch) {\n                LOG.debug(\"Matched route {} - {} to controller {}\", httpMethod, requestPath, route.getDeclaringType());\n            } else {\n                LOG.debug(\"Matched route {} - {}\", httpMethod, requestPath);\n            }\n        }\n        // all ok proceed to try and execute the route\n        if (route.isAnnotationPresent(OnMessage.class) || route.isAnnotationPresent(OnOpen.class)) {\n            handleStatusError(\n                    ctx,\n                    request,\n                    nettyHttpRequest,\n                    HttpResponse.status(HttpStatus.BAD_REQUEST),\n                    \"Not a WebSocket request\");\n        } else {\n            handleRouteMatch(route, nettyHttpRequest, ctx);\n        }\n    }\n\n    private void handleStatusError(\n            ChannelHandlerContext ctx,\n            HttpRequest<?> request,\n            NettyHttpRequest nettyHttpRequest,\n            MutableHttpResponse<Object> defaultResponse,\n            String message) {\n        Optional<RouteMatch<Object>> statusRoute = router.route(defaultResponse.status());\n        if (statusRoute.isPresent()) {\n            RouteMatch<Object> routeMatch = statusRoute.get();\n            handleRouteMatch(routeMatch, nettyHttpRequest, ctx);\n        } else {\n\n            if (HttpMethod.permitsRequestBody(request.getMethod())) {\n                JsonError error = newError(request, message);\n                defaultResponse.body(error);\n            }\n\n\n            AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(request);\n            Flowable<? extends MutableHttpResponse<?>> responsePublisher = filterPublisher(\n                    requestReference,\n                    Flowable.just(defaultResponse),\n                    ctx.channel().eventLoop(),\n                    false\n            );\n            subscribeToResponsePublisher(\n                    ctx,\n                    MediaType.APPLICATION_JSON_TYPE,\n                    requestReference,\n                    responsePublisher\n            );\n        }\n    }\n\n    private Optional<? extends FileCustomizableResponseType> matchFile(String path) {\n        Optional<URL> optionalUrl = staticResourceResolver.resolve(path);\n\n        if (optionalUrl.isPresent()) {\n            try {\n                URL url = optionalUrl.get();\n                if (url.getProtocol().equals(\"file\")) {\n                    File file = Paths.get(url.toURI()).toFile();\n                    if (file.exists() && !file.isDirectory() && file.canRead()) {\n                        return Optional.of(new NettySystemFileCustomizableResponseType(file));\n                    }\n                }\n\n                return Optional.of(new NettyStreamedFileCustomizableResponseType(url));\n            } catch (URISyntaxException e) {\n                //no-op\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    private void emitDefaultNotFoundResponse(ChannelHandlerContext ctx, io.micronaut.http.HttpRequest<?> request) {\n        MutableHttpResponse<Object> res = newNotFoundError(request);\n        AtomicReference<HttpRequest<?>> requestReference = new AtomicReference<>(request);\n        Flowable<? extends MutableHttpResponse<?>> responsePublisher = filterPublisher(\n                requestReference,\n                Flowable.just(res),\n                ctx.channel().eventLoop(),\n                false\n        );\n        subscribeToResponsePublisher(\n                ctx,\n                MediaType.APPLICATION_JSON_TYPE,\n                requestReference,\n                responsePublisher\n        );\n    }\n\n    private MutableHttpResponse<Object> newNotFoundError(HttpRequest<?> request) {\n        JsonError error = newError(request, \"Page Not Found\");\n        return HttpResponse.notFound()\n                .body(error);\n    }\n\n    private JsonError newError(io.micronaut.http.HttpRequest<?> request, String message) {\n        URI uri = request.getUri();\n        return new JsonError(message)\n                .link(Link.SELF, Link.of(uri));\n    }\n\n    private MutableHttpResponse errorResultToResponse(Object result) {\n        MutableHttpResponse<?> response;\n        if (result == null) {\n            response = io.micronaut.http.HttpResponse.serverError();\n        } else if (result instanceof io.micronaut.http.HttpResponse) {\n            response = (MutableHttpResponse) result;\n        } else {\n            response = io.micronaut.http.HttpResponse.serverError()\n                .body(result);\n            MediaType.fromType(result.getClass()).ifPresent(response::contentType);\n        }\n        return response;\n    }\n\n    private void handleRouteMatch(\n        RouteMatch<?> route,\n        NettyHttpRequest<?> request,\n        ChannelHandlerContext context) {\n        // Set the matched route on the request\n        request.setMatchedRoute(route);\n\n        // try to fulfill the argument requirements of the route\n        route = requestArgumentSatisfier.fulfillArgumentRequirements(route, request, false);\n\n        // If it is not executable and the body is not required send back 400 - BAD REQUEST\n\n        // decorate the execution of the route so that it runs an async executor\n        request.setMatchedRoute(route);\n\n        // The request body is required, so at this point we must have a StreamedHttpRequest\n        io.netty.handler.codec.http.HttpRequest nativeRequest = request.getNativeRequest();\n        if (!route.isExecutable() && io.micronaut.http.HttpMethod.permitsRequestBody(request.getMethod()) && nativeRequest instanceof StreamedHttpRequest) {\n            Optional<MediaType> contentType = request.getContentType();\n            HttpContentProcessor<?> processor = contentType\n                .flatMap(type ->\n                    beanLocator.findBean(HttpContentSubscriberFactory.class,\n                        new ConsumesMediaTypeQualifier<>(type))\n                ).map(factory ->\n                    factory.build(request)\n                ).orElse(new DefaultHttpContentProcessor(request, serverConfiguration));\n\n            processor.subscribe(buildSubscriber(request, context, route));\n        } else {\n            context.read();\n            route = prepareRouteForExecution(route, request);\n            route.execute();\n        }\n    }\n\n    private boolean isJsonFormattable(Class javaType) {\n        return !(javaType == byte[].class\n                || ByteBuffer.class.isAssignableFrom(javaType)\n                || ByteBuf.class.isAssignableFrom(javaType));\n    }\n\n    private Subscriber<Object> buildSubscriber(NettyHttpRequest<?> request,\n                                               ChannelHandlerContext context,\n                                               RouteMatch<?> finalRoute) {\n        return new CompletionAwareSubscriber<Object>() {\n            Boolean alwaysAddContent = request.getContentType()\n                    .map(type -> type.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE))\n                    .orElse(false);\n            RouteMatch<?> routeMatch = finalRoute;\n            AtomicBoolean executed = new AtomicBoolean(false);\n            AtomicLong pressureRequested = new AtomicLong(0);\n            ConcurrentHashMap<String, UnicastProcessor> subjects = new ConcurrentHashMap<>();\n            ConcurrentHashMap<Integer, HttpDataReference> dataReferences = new ConcurrentHashMap<>();\n            ConversionService conversionService = ConversionService.SHARED;\n            Subscription s;\n            LongConsumer onRequest = (num) -> pressureRequested.updateAndGet((p) -> {\n                long newVal = p - num;\n                if (newVal < 0) {\n                    s.request(num - p);\n                    return 0;\n                } else {\n                    return newVal;\n                }\n            });\n\n            Flowable processFlowable(Flowable flowable, Integer dataKey, boolean controlsFlow) {\n                if (controlsFlow) {\n                    flowable = flowable.doOnRequest(onRequest);\n                }\n                return flowable\n                        .doAfterTerminate(() -> {\n                            if (controlsFlow) {\n                                HttpDataReference dataReference = dataReferences.get(dataKey);\n                                dataReference.destroy();\n                            }\n                        });\n            }\n\n            @Override\n            protected void doOnSubscribe(Subscription subscription) {\n                this.s = subscription;\n                subscription.request(1);\n            }\n\n            @Override\n            protected void doOnNext(Object message) {\n                boolean executed = this.executed.get();\n                if (message instanceof ByteBufHolder) {\n                    if (message instanceof HttpData) {\n                        HttpData data = (HttpData) message;\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Received HTTP Data for request [{}]: {}\", request, message);\n                        }\n\n                        String name = data.getName();\n                        Optional<Argument<?>> requiredInput = routeMatch.getRequiredInput(name);\n\n                        if (requiredInput.isPresent()) {\n                            Argument<?> argument = requiredInput.get();\n                            Supplier<Object> value;\n                            boolean isPublisher = Publishers.isConvertibleToPublisher(argument.getType());\n                            boolean chunkedProcessing = false;\n\n                            if (isPublisher) {\n                                Integer dataKey = System.identityHashCode(data);\n                                HttpDataReference dataReference = dataReferences.computeIfAbsent(dataKey, (key) -> {\n                                    return new HttpDataReference(data);\n                                });\n                                Argument typeVariable;\n\n                                if (StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    typeVariable = ARGUMENT_PART_DATA;\n                                } else {\n                                    typeVariable = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                }\n                                Class typeVariableType = typeVariable.getType();\n\n                                UnicastProcessor namedSubject = subjects.computeIfAbsent(name, (key) -> UnicastProcessor.create());\n\n                                chunkedProcessing = PartData.class.equals(typeVariableType) ||\n                                        Publishers.isConvertibleToPublisher(typeVariableType) ||\n                                        ClassUtils.isJavaLangType(typeVariableType);\n\n                                if (Publishers.isConvertibleToPublisher(typeVariableType)) {\n                                    boolean streamingFileUpload = StreamingFileUpload.class.isAssignableFrom(typeVariableType);\n                                    if (streamingFileUpload) {\n                                        typeVariable = ARGUMENT_PART_DATA;\n                                    } else {\n                                        typeVariable = typeVariable.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                                    }\n                                    dataReference.subject.getAndUpdate(subject -> {\n                                        if (subject == null) {\n                                            UnicastProcessor childSubject = UnicastProcessor.create();\n                                            Flowable flowable = processFlowable(childSubject, dataKey, true);\n                                            if (streamingFileUpload && data instanceof FileUpload) {\n                                                namedSubject.onNext(new NettyStreamingFileUpload(\n                                                        (FileUpload) data,\n                                                        serverConfiguration.getMultipart(),\n                                                        ioExecutor,\n                                                        flowable));\n                                            } else {\n                                                namedSubject.onNext(flowable);\n                                            }\n\n                                            return childSubject;\n                                        }\n                                        return subject;\n                                    });\n\n                                }\n\n                                UnicastProcessor subject = Optional.ofNullable(dataReference.subject.get()).orElse(namedSubject);\n\n                                Object part = data;\n\n                                if (chunkedProcessing) {\n                                    HttpDataReference.Component component = dataReference.addComponent((e) -> {\n                                        subject.onError(e);\n                                        s.cancel();\n                                    });\n                                    if (component == null) {\n                                        return;\n                                    }\n                                    part = new NettyPartData(dataReference, component);\n                                }\n\n                                if (data instanceof FileUpload &&\n                                        StreamingFileUpload.class.isAssignableFrom(argument.getType())) {\n                                    dataReference.upload.getAndUpdate(upload -> {\n                                        if (upload == null) {\n                                            return new NettyStreamingFileUpload(\n                                                    (FileUpload) data,\n                                                    serverConfiguration.getMultipart(),\n                                                    ioExecutor,\n                                                    processFlowable(subject, dataKey, true));\n                                        }\n                                        return upload;\n                                    });\n                                }\n\n                                Optional<?> converted = conversionService.convert(part, typeVariable);\n\n                                converted.ifPresent(subject::onNext);\n\n                                if (data.isCompleted() && chunkedProcessing) {\n                                    subject.onComplete();\n                                }\n\n                                value = () -> {\n                                    StreamingFileUpload upload = dataReference.upload.get();\n                                    if (upload != null) {\n                                        return upload;\n                                    } else {\n                                        return processFlowable(namedSubject, dataKey, dataReference.subject.get() == null);\n                                    }\n                                };\n\n                            } else {\n                                if (data instanceof Attribute && !data.isCompleted()) {\n                                    request.addContent(data);\n                                    s.request(1);\n                                    return;\n                                } else {\n                                    value = () -> {\n                                        if (data.refCnt() > 0) {\n                                            return data;\n                                        } else {\n                                            return null;\n                                        }\n                                    };\n                                }\n                            }\n\n                            if (!executed) {\n                                String argumentName = argument.getName();\n                                if (!routeMatch.isSatisfied(argumentName)) {\n                                    routeMatch = routeMatch.fulfill(Collections.singletonMap(argumentName, value.get()));\n                                }\n                                if (isPublisher && chunkedProcessing) {\n                                    //accounting for the previous request\n                                    pressureRequested.incrementAndGet();\n                                }\n                                if (routeMatch.isExecutable() || message instanceof LastHttpContent) {\n                                    executeRoute();\n                                    executed = true;\n                                }\n                            }\n\n                            if (alwaysAddContent) {\n                                request.addContent(data);\n                            }\n\n                            if (!executed || !chunkedProcessing) {\n                                s.request(1);\n                            }\n\n                        } else {\n                            request.addContent(data);\n                            s.request(1);\n                        }\n                    } else {\n                        request.addContent((ByteBufHolder) message);\n                        s.request(1);\n                    }\n                } else {\n                    ((NettyHttpRequest) request).setBody(message);\n                    s.request(1);\n                }\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                try {\n                    s.cancel();\n                    exceptionCaught(context, t);\n                } catch (Exception e) {\n                    // should never happen\n                    writeDefaultErrorResponse(context, request, e);\n                }\n            }\n\n            @Override\n            protected void doOnComplete() {\n                for (UnicastProcessor subject: subjects.values()) {\n                    if (!subject.hasComplete()) {\n                        subject.onComplete();\n                    }\n                }\n                executeRoute();\n            }\n\n            private void executeRoute() {\n                if (executed.compareAndSet(false, true)) {\n                    try {\n                        routeMatch = prepareRouteForExecution(routeMatch, request);\n                        routeMatch.execute();\n                    } catch (Exception e) {\n                        context.pipeline().fireExceptionCaught(e);\n                    }\n                }\n            }\n        };\n    }\n\n    private RouteMatch<?> prepareRouteForExecution(RouteMatch<?> route, NettyHttpRequest<?> request) {\n        ChannelHandlerContext context = request.getChannelHandlerContext();\n        // Select the most appropriate Executor\n        ExecutorService executor;\n        if (route instanceof MethodBasedRouteMatch) {\n            executor = executorSelector.select((MethodBasedRouteMatch) route).orElse(context.channel().eventLoop());\n        } else {\n            executor = context.channel().eventLoop();\n        }\n\n        route = route.decorate(finalRoute -> {\n            MediaType defaultResponseMediaType = finalRoute\n                .getProduces()\n                .stream()\n                .findFirst()\n                .orElse(MediaType.APPLICATION_JSON_TYPE);\n\n\n            ReturnType<?> genericReturnType = finalRoute.getReturnType();\n            Class<?> javaReturnType = genericReturnType.getType();\n\n            AtomicReference<io.micronaut.http.HttpRequest<?>> requestReference = new AtomicReference<>(request);\n            boolean isFuture = CompletionStage.class.isAssignableFrom(javaReturnType);\n            boolean isReactiveReturnType = Publishers.isConvertibleToPublisher(javaReturnType) || isFuture;\n            boolean isSingle =\n                    isReactiveReturnType && Publishers.isSingle(javaReturnType) ||\n                            isResponsePublisher(genericReturnType, javaReturnType) ||\n                                isFuture ||\n                                    finalRoute.getAnnotationMetadata().booleanValue(Produces.class, \"single\").orElse(false);\n\n            // build the result emitter. This result emitter emits the response from a controller action\n            Flowable<?> resultEmitter = buildResultEmitter(\n                    context,\n                    finalRoute,\n                    requestReference,\n                    isReactiveReturnType,\n                    isSingle\n            );\n\n            // here we transform the result of the controller action into a MutableHttpResponse\n            Flowable<MutableHttpResponse<?>> routePublisher = resultEmitter.map((message) -> {\n                RouteMatch<?> routeMatch = finalRoute;\n                MutableHttpResponse<?> finalResponse = messageToResponse(routeMatch, message);\n                if (requestReference.get().getMethod().equals(HttpMethod.HEAD)) {\n                    finalResponse.getBody()\n                            .filter(ReferenceCounted.class::isInstance)\n                            .map(ReferenceCounted.class::cast)\n                            .ifPresent(ReferenceCounted::release);\n                    finalResponse.body(null);\n                }\n                HttpStatus status = finalResponse.getStatus();\n\n                if (status.getCode() >= HttpStatus.BAD_REQUEST.getCode()) {\n                    Class declaringType = ((MethodBasedRouteMatch) routeMatch).getDeclaringType();\n                    // handle re-mapping of errors\n                    Optional<RouteMatch<Object>> statusRoute = Optional.empty();\n                    // if declaringType is not null, this means its a locally marked method handler\n                    if (declaringType != null) {\n                        statusRoute = router.route(declaringType, status);\n                    }\n                    if (!statusRoute.isPresent()) {\n                        statusRoute = router.route(status);\n                    }\n                    io.micronaut.http.HttpRequest<?> httpRequest = requestReference.get();\n\n                    if (statusRoute.isPresent()) {\n                        routeMatch = statusRoute.get();\n                        httpRequest.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);\n\n                        routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);\n\n                        if (routeMatch.isExecutable()) {\n                            Object result;\n                            try {\n                                result = routeMatch.execute();\n                                finalResponse = messageToResponse(routeMatch, result);\n                            } catch (Throwable e) {\n                                throw new InternalServerException(\"Error executing status route [\" + routeMatch + \"]: \" + e.getMessage(), e);\n                            }\n                        } else {\n                            if (LOG.isWarnEnabled()) {\n                                LOG.warn(\"Matched status route [\" + routeMatch + \"] not executed because one or more arguments could not be bound. Returning the original response.\");\n                            }\n                        }\n                    }\n\n                }\n                finalResponse.setAttribute(HttpAttributes.ROUTE_MATCH, routeMatch);\n                return finalResponse;\n            });\n\n            routePublisher = buildRoutePublisher(\n                    finalRoute.getDeclaringType(),\n                    genericReturnType,\n                    isReactiveReturnType,\n                    finalRoute.getAnnotationMetadata(),\n                    requestReference,\n                    routePublisher\n            );\n\n            // process the publisher through the available filters\n            Flowable<? extends MutableHttpResponse<?>> filteredPublisher = filterPublisher(\n                    requestReference,\n                    routePublisher,\n                    executor,\n                    false\n            );\n\n            boolean isStreaming = isReactiveReturnType && !isSingle;\n\n            Optional<Class<?>> javaPayloadType = genericReturnType.getFirstTypeVariable().map(arg -> arg.getType());\n\n            if (!isStreaming) {\n                if (HttpResponse.class.isAssignableFrom(javaReturnType)) {\n                    Optional<Argument<?>> generic = genericReturnType.getFirstTypeVariable();\n                    if (generic.isPresent()) {\n                        // Unwrap response type information\n                        Class genericType = generic.get().getType();\n                        isStreaming = Publishers.isConvertibleToPublisher(genericType) && !Publishers.isSingle(genericType);\n\n                        if (isStreaming) {\n                            javaPayloadType = generic.get().getFirstTypeVariable().map(Argument::getType);\n                        }\n                    }\n                }\n            }\n\n            Class finalJavaPayloadType = javaPayloadType.orElse(Object.class);\n            boolean finalIsStreaming = isStreaming;\n            filteredPublisher  = filteredPublisher.switchMap((response) -> {\n                Optional<?> responseBody = response.getBody();\n                if (responseBody.isPresent()) {\n                    Object body = responseBody.get();\n                    if (finalIsStreaming) {\n                        // handled downstream\n                        return Flowable.just(response);\n                    } else if (Publishers.isConvertibleToPublisher(body)) {\n                        Flowable<?> bodyFlowable = Publishers.convertPublisher(body, Flowable.class);\n                        Flowable<MutableHttpResponse<?>> bodyToResponse = bodyFlowable.map((bodyContent) ->\n                                setBodyContent(response, bodyContent)\n                        );\n                        return bodyToResponse.switchIfEmpty(Flowable.just(response));\n                    }\n                }\n\n                return Flowable.just(response);\n            });\n\n            if (!isStreaming) {\n                subscribeToResponsePublisher(context, defaultResponseMediaType, requestReference, filteredPublisher);\n            } else {\n                filteredPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {\n                    @Override\n                    protected void onComplete(MutableHttpResponse<?> response) {\n                        Optional<?> responseBody = response.getBody();\n                        @SuppressWarnings(\"unchecked\")\n                        Flowable<Object> bodyFlowable = responseBody.map(o -> Publishers.convertPublisher(o, Flowable.class)).orElse(Flowable.empty());\n\n                        NettyMutableHttpResponse nettyHttpResponse = (NettyMutableHttpResponse) response;\n                        FullHttpResponse nettyResponse = nettyHttpResponse.getNativeResponse();\n                        Optional<MediaType> specifiedMediaType = response.getContentType();\n                        MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);\n\n                        applyConfiguredHeaders(response.getHeaders());\n\n                        boolean isJson = responseMediaType.getExtension().equals(MediaType.EXTENSION_JSON) &&\n                                isJsonFormattable(finalJavaPayloadType);\n\n                        streamHttpContentChunkByChunk(\n                                context,\n                                request,\n                                nettyResponse,\n                                responseMediaType,\n                                isJson,\n                                bodyFlowable);\n                    }\n                });\n            }\n\n            return null;\n        });\n        return route;\n    }\n\n    private Flowable<MutableHttpResponse<?>> buildRoutePublisher(\n            Class<?> declaringType,\n            ReturnType<?> genericReturnType,\n            boolean isReactiveReturnType,\n            AnnotationMetadata annotationMetadata,\n            AtomicReference<HttpRequest<?>> requestReference,\n            Flowable<MutableHttpResponse<?>> routePublisher) {\n        // In the case of an empty reactive type we switch handling so that\n        // a 404 NOT_FOUND is returned\n        routePublisher = routePublisher.switchIfEmpty(Flowable.create((emitter) -> {\n            HttpRequest<?> httpRequest = requestReference.get();\n            MutableHttpResponse<?> response;\n            Class<?> javaReturnType = genericReturnType.getType();\n            boolean isVoid = javaReturnType == void.class ||\n                    Completable.class.isAssignableFrom(javaReturnType) ||\n                    (isReactiveReturnType && genericReturnType.getFirstTypeVariable()\n                            .filter(arg -> arg.getType() == Void.class).isPresent());\n\n            if (isVoid) {\n                // void return type with no response, nothing else to do\n                response = forStatus(annotationMetadata);\n            } else {\n                // handle re-mapping of errors\n                Optional<RouteMatch<Object>> statusRoute = Optional.empty();\n                // if declaringType is not null, this means its a locally marked method handler\n                if (declaringType != null) {\n                    statusRoute = router.route(declaringType, HttpStatus.NOT_FOUND);\n                }\n                if (!statusRoute.isPresent()) {\n                    statusRoute = router.route(HttpStatus.NOT_FOUND);\n                }\n\n                if (statusRoute.isPresent()) {\n                    RouteMatch<?> newRoute = requestArgumentSatisfier.fulfillArgumentRequirements(statusRoute.get(), httpRequest, true);\n\n                    if (newRoute.isExecutable()) {\n                        try {\n                            Object result = newRoute.execute();\n                            response = messageToResponse(newRoute, result);\n                        } catch (Throwable e) {\n                            emitter.onError(new InternalServerException(\"Error executing status route [\" + newRoute + \"]: \" + e.getMessage(), e));\n                            return;\n                        }\n\n                    } else {\n                        if (LOG.isWarnEnabled()) {\n                            LOG.warn(\"Matched status route [\" + newRoute + \"] not executed because one or more arguments could not be bound. Returning a default response.\");\n                        }\n                        response = newNotFoundError(httpRequest);\n                    }\n                    response.setAttribute(HttpAttributes.ROUTE_MATCH, newRoute);\n                } else {\n                    response = newNotFoundError(httpRequest);\n                }\n            }\n\n            try {\n                emitter.onNext(response);\n                emitter.onComplete();\n            } catch (Throwable e) {\n                emitter.onError(new InternalServerException(\"Error executing Error route [\" + response.getStatus() + \"]: \" + e.getMessage(), e));\n            }\n        }, BackpressureStrategy.ERROR));\n        return routePublisher;\n    }\n\n    private void subscribeToResponsePublisher(\n            ChannelHandlerContext context,\n            MediaType defaultResponseMediaType,\n            AtomicReference<HttpRequest<?>> requestReference,\n            Flowable<? extends MutableHttpResponse<?>> finalPublisher) {\n        finalPublisher =  finalPublisher.map((response) -> {\n            Optional<MediaType> specifiedMediaType = response.getContentType();\n            MediaType responseMediaType = specifiedMediaType.orElse(defaultResponseMediaType);\n\n            applyConfiguredHeaders(response.getHeaders());\n\n            Optional<?> responseBody = response.getBody();\n            if (responseBody.isPresent()) {\n\n                Object body = responseBody.get();\n\n                Optional<NettyCustomizableResponseTypeHandler> typeHandler = customizableResponseTypeHandlerRegistry\n                        .findTypeHandler(body.getClass());\n                if (typeHandler.isPresent()) {\n                    NettyCustomizableResponseTypeHandler th = typeHandler.get();\n                    setBodyContent(response, new NettyCustomizableResponseTypeHandlerInvoker(th, body));\n                    return response;\n                }\n\n                if (specifiedMediaType.isPresent())  {\n\n                    Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(responseMediaType, body.getClass());\n                    if (registeredCodec.isPresent()) {\n                        MediaTypeCodec codec = registeredCodec.get();\n                        return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);\n                    }\n                }\n\n                Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(defaultResponseMediaType, body.getClass());\n                if (registeredCodec.isPresent()) {\n                    MediaTypeCodec codec = registeredCodec.get();\n                    return encodeBodyWithCodec(response, body, codec, responseMediaType, context, requestReference);\n                }\n\n                MediaTypeCodec defaultCodec = new TextPlainCodec(serverConfiguration.getDefaultCharset());\n\n                return encodeBodyWithCodec(response, body, defaultCodec, responseMediaType,  context, requestReference);\n            } else {\n                return response;\n            }\n        });\n\n        finalPublisher.subscribe(new ContextCompletionAwareSubscriber<MutableHttpResponse<?>>(context) {\n            @Override\n            protected void onComplete(MutableHttpResponse<?> message) {\n                writeFinalNettyResponse(message, requestReference, context);\n            }\n\n            @Override\n            protected void doOnError(Throwable t) {\n                exceptionCaughtInternal(context, t, (NettyHttpRequest) requestReference.get(), false);\n            }\n        });\n    }\n\n    private void writeFinalNettyResponse(MutableHttpResponse<?> message, AtomicReference<HttpRequest<?>> requestReference, ChannelHandlerContext context) {\n        NettyMutableHttpResponse nettyHttpResponse = (NettyMutableHttpResponse) message;\n        FullHttpResponse nettyResponse = nettyHttpResponse.getNativeResponse();\n\n        HttpRequest<?> httpRequest = requestReference.get();\n        io.netty.handler.codec.http.HttpHeaders nettyHeaders = nettyResponse.headers();\n\n        // default Connection header if not set explicitly\n        if (!nettyHeaders.contains(HttpHeaderNames.CONNECTION)) {\n            boolean expectKeepAlive = nettyResponse.protocolVersion().isKeepAliveDefault() || httpRequest.getHeaders().isKeepAlive();\n            HttpStatus status = nettyHttpResponse.status();\n            if (!expectKeepAlive || status.getCode() > 299) {\n                nettyHeaders.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            } else {\n                nettyHeaders.add(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            }\n        }\n\n        final Object body = message.body();\n        if (body instanceof NettyCustomizableResponseTypeHandlerInvoker) {\n            NettyCustomizableResponseTypeHandlerInvoker handler = (NettyCustomizableResponseTypeHandlerInvoker) body;\n            handler.invoke(httpRequest, nettyHttpResponse, context);\n        } else {\n            // default to Transfer-Encoding: chunked if Content-Length not set or not already set\n            if (!nettyHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) && !nettyHeaders.contains(HttpHeaderNames.TRANSFER_ENCODING)) {\n                nettyHeaders.add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            }\n            // close handled by HttpServerKeepAliveHandler\n            context.writeAndFlush(nettyResponse);\n            context.read();\n        }\n    }\n\n    private MutableHttpResponse<?> encodeBodyWithCodec(MutableHttpResponse<?> response,\n                                                       Object body,\n                                                       MediaTypeCodec codec,\n                                                       MediaType mediaType,\n                                                       ChannelHandlerContext context,\n                                                       AtomicReference<HttpRequest<?>> requestReference) {\n        ByteBuf byteBuf;\n        try {\n            byteBuf = encodeBodyAsByteBuf(body, codec, context, requestReference);\n            int len = byteBuf.readableBytes();\n            MutableHttpHeaders headers = response.getHeaders();\n            if (!headers.contains(HttpHeaders.CONTENT_TYPE)) {\n                headers.add(HttpHeaderNames.CONTENT_TYPE, mediaType);\n            }\n            headers.remove(HttpHeaders.CONTENT_LENGTH);\n            headers.add(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(len));\n\n            setBodyContent(response, byteBuf);\n            return response;\n        } catch (LinkageError e) {\n            // rxjava swallows linkage errors for some reasons so if one occurs, rethrow as a internal error\n            throw new InternalServerException(\"Fatal error encoding bytebuf: \" + e.getMessage() , e);\n        }\n    }\n\n    private MutableHttpResponse<?> setBodyContent(MutableHttpResponse response, Object bodyContent) {\n        @SuppressWarnings(\"unchecked\")\n        MutableHttpResponse<?> res = response.body(bodyContent);\n        return res;\n    }\n\n    private ByteBuf encodeBodyAsByteBuf(Object body, MediaTypeCodec codec, ChannelHandlerContext context, AtomicReference<HttpRequest<?>> requestReference) {\n        ByteBuf byteBuf;\n        if (body instanceof ByteBuf) {\n            byteBuf = (ByteBuf) body;\n        } else if (body instanceof ByteBuffer) {\n            ByteBuffer byteBuffer = (ByteBuffer) body;\n            Object nativeBuffer = byteBuffer.asNativeBuffer();\n            if (nativeBuffer instanceof ByteBuf) {\n                byteBuf = (ByteBuf) nativeBuffer;\n            } else {\n                byteBuf = Unpooled.wrappedBuffer(byteBuffer.asNioBuffer());\n            }\n        } else if (body instanceof byte[]) {\n            byteBuf = Unpooled.wrappedBuffer((byte[]) body);\n\n        } else if (body instanceof Writable) {\n            byteBuf = context.alloc().ioBuffer(128);\n            ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf);\n            Writable writable = (Writable) body;\n            try {\n                writable.writeTo(outputStream, requestReference.get().getCharacterEncoding());\n            } catch (IOException e) {\n                if (LOG.isErrorEnabled()) {\n                    LOG.error(e.getMessage());\n                }\n            }\n\n        } else {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Encoding emitted response object [{}] using codec: {}\", body, codec);\n            }\n            byteBuf = (ByteBuf) codec.encode(body, new NettyByteBufferFactory(context.alloc())).asNativeBuffer();\n        }\n        return byteBuf;\n    }\n\n    // builds the result emitter for a given route action\n    private Flowable<?> buildResultEmitter(\n            ChannelHandlerContext context, RouteMatch<?> finalRoute,\n            AtomicReference<HttpRequest<?>> requestReference,\n            boolean isReactiveReturnType,\n            boolean isSingleResult) {\n        Flowable<?> resultEmitter;\n        if (isReactiveReturnType) {\n            // if the return type is reactive, execute the action and obtain the Observable\n            try {\n                if (isSingleResult) {\n                    // for a single result we are fine as is\n                    resultEmitter = Flowable.defer(() -> {\n                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;\n                        Object result = routeMatch.execute();\n                        return Publishers.convertPublisher(result, Publisher.class);\n                    });\n                } else {\n                    // for a streaming response we wrap the result on an HttpResponse so that a single result is received\n                    // then the result can be streamed chunk by chunk\n                    resultEmitter = Flowable.create((emitter) -> {\n                        final RouteMatch<?> routeMatch = !finalRoute.isExecutable() ? requestArgumentSatisfier.fulfillArgumentRequirements(finalRoute, requestReference.get(), true) : finalRoute;\n                        Object result = routeMatch.execute();\n                        MutableHttpResponse<Object> chunkedResponse = HttpResponse.ok(result);\n                        chunkedResponse.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n                        emitter.onNext(chunkedResponse);\n                        emitter.onComplete();\n                        // should be no back pressure\n                    }, BackpressureStrategy.ERROR);\n                }\n            } catch (Throwable e) {\n                resultEmitter = Flowable.error(new InternalServerException(\"Error executing route [\" + finalRoute + \"]: \" + e.getMessage(), e));\n            }\n        } else {\n            // for non-reactive results we build flowable that executes the\n            // route\n            resultEmitter = Flowable.create((emitter) -> {\n                HttpRequest<?> httpRequest = requestReference.get();\n                RouteMatch<?> routeMatch = finalRoute;\n                if (!routeMatch.isExecutable()) {\n                    routeMatch = requestArgumentSatisfier.fulfillArgumentRequirements(routeMatch, httpRequest, true);\n                }\n                Object result;\n                try {\n                    result = routeMatch.execute();\n                } catch (Throwable e) {\n                    emitter.onError(e);\n                    return;\n                }\n\n                if (result instanceof Optional) {\n                    result = ((Optional<?>) result).orElse(null);\n                }\n\n                if (result == null) {\n                    // empty flowable\n                    emitter.onComplete();\n                } else {\n                    // emit the result\n                    if (result instanceof Writable) {\n                        ByteBuf byteBuf = context.alloc().ioBuffer(128);\n                        ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf);\n                        Writable writable = (Writable) result;\n                        writable.writeTo(outputStream, requestReference.get().getCharacterEncoding());\n                        emitter.onNext(byteBuf);\n                    } else {\n                        emitter.onNext(result);\n                    }\n                    emitter.onComplete();\n                }\n\n                // should be no back pressure\n            }, BackpressureStrategy.ERROR);\n        }\n        return resultEmitter;\n    }\n\n    private MutableHttpResponse<?> messageToResponse(RouteMatch<?> finalRoute, Object message) {\n        MutableHttpResponse<?> response;\n        if (message instanceof HttpResponse) {\n            response = ConversionService.SHARED.convert(message, NettyMutableHttpResponse.class)\n                    .orElseThrow(() -> new InternalServerException(\"Emitted response is not mutable\"));\n        } else {\n            if (message instanceof HttpStatus) {\n                response = HttpResponse.status((HttpStatus) message);\n            } else {\n                response = forStatus(finalRoute.getAnnotationMetadata()).body(message);\n            }\n        }\n        return response;\n    }\n\n    private MutableHttpResponse<Object> forStatus(AnnotationMetadata annotationMetadata) {\n        HttpStatus status = HttpStatus.OK;\n\n        if (annotationMetadata.hasAnnotation(Status.class)) {\n            status = annotationMetadata.stringValue(Status.class).map(HttpStatus::valueOf).orElse(status);\n        }\n\n        return HttpResponse.status(status);\n    }\n\n    private boolean isResponsePublisher(ReturnType<?> genericReturnType, Class<?> javaReturnType) {\n        return Publishers.isConvertibleToPublisher(javaReturnType) && genericReturnType.getFirstTypeVariable().map(arg -> HttpResponse.class.isAssignableFrom(arg.getType())).orElse(false);\n    }\n\n    private Flowable<? extends MutableHttpResponse<?>> filterPublisher(\n            AtomicReference<HttpRequest<?>> requestReference,\n            Publisher<MutableHttpResponse<?>> routePublisher,\n            ExecutorService executor,\n            boolean skipOncePerRequest) {\n        Publisher<? extends io.micronaut.http.MutableHttpResponse<?>> finalPublisher;\n        List<HttpFilter> filters = new ArrayList<>(router.findFilters(requestReference.get()));\n        if (skipOncePerRequest) {\n            filters.removeIf(filter -> filter instanceof OncePerRequestHttpServerFilter);\n        }\n        if (!filters.isEmpty()) {\n            // make the action executor the last filter in the chain\n            filters.add((HttpServerFilter) (req, chain) -> routePublisher);\n\n            AtomicInteger integer = new AtomicInteger();\n            int len = filters.size();\n            ServerFilterChain filterChain = new ServerFilterChain() {\n                @SuppressWarnings(\"unchecked\")\n                @Override\n                public Publisher<MutableHttpResponse<?>> proceed(io.micronaut.http.HttpRequest<?> request) {\n                    int pos = integer.incrementAndGet();\n                    if (pos > len) {\n                        throw new IllegalStateException(\"The FilterChain.proceed(..) method should be invoked exactly once per filter execution. The method has instead been invoked multiple times by an erroneous filter definition.\");\n                    }\n                    HttpFilter httpFilter = filters.get(pos);\n                    return (Publisher<MutableHttpResponse<?>>) httpFilter.doFilter(requestReference.getAndSet(request), this);\n                }\n            };\n            HttpFilter httpFilter = filters.get(0);\n            Publisher<? extends HttpResponse<?>> resultingPublisher = httpFilter.doFilter(requestReference.get(), filterChain);\n            finalPublisher = (Publisher<? extends MutableHttpResponse<?>>) resultingPublisher;\n        } else {\n            finalPublisher = routePublisher;\n        }\n\n        // Handle the scheduler to subscribe on\n        if (finalPublisher instanceof Flowable) {\n            return ((Flowable<MutableHttpResponse<?>>) finalPublisher)\n                    .subscribeOn(Schedulers.from(executor));\n        } else {\n            return Flowable.fromPublisher(finalPublisher)\n                    .subscribeOn(Schedulers.from(executor));\n        }\n    }\n\n    private void streamHttpContentChunkByChunk(\n        ChannelHandlerContext context,\n        NettyHttpRequest<?> request,\n        FullHttpResponse nativeResponse,\n        MediaType mediaType,\n        boolean isJson,\n        Publisher<Object> publisher) {\n\n        NettyByteBufferFactory byteBufferFactory = new NettyByteBufferFactory(context.alloc());\n\n        Publisher<HttpContent> httpContentPublisher = Publishers.map(publisher, new Function<Object, HttpContent>() {\n            boolean first = true;\n\n            @Override\n            public HttpContent apply(Object message) {\n                HttpContent httpContent;\n                if (message instanceof ByteBuf) {\n                    httpContent = new DefaultHttpContent((ByteBuf) message);\n                } else if (message instanceof ByteBuffer) {\n                    ByteBuffer byteBuffer = (ByteBuffer) message;\n                    Object nativeBuffer = byteBuffer.asNativeBuffer();\n                    if (nativeBuffer instanceof ByteBuf) {\n                        httpContent = new DefaultHttpContent((ByteBuf) nativeBuffer);\n                    } else {\n                        httpContent = new DefaultHttpContent(Unpooled.copiedBuffer(byteBuffer.asNioBuffer()));\n                    }\n                } else if (message instanceof byte[]) {\n                    httpContent = new DefaultHttpContent(Unpooled.copiedBuffer((byte[]) message));\n                } else if (message instanceof HttpContent) {\n                    httpContent = (HttpContent) message;\n                } else {\n\n                    MediaTypeCodec codec = mediaTypeCodecRegistry.findCodec(mediaType, message.getClass()).orElse(\n                        new TextPlainCodec(serverConfiguration.getDefaultCharset()));\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Encoding emitted response object [{}] using codec: {}\", message, codec);\n                    }\n                    ByteBuffer encoded = codec.encode(message, byteBufferFactory);\n                    httpContent = new DefaultHttpContent((ByteBuf) encoded.asNativeBuffer());\n                }\n                if (!isJson || first) {\n                    first = false;\n                    return httpContent;\n                } else {\n                    return HttpContentUtil.prefixComma(httpContent);\n                }\n            }\n        });\n\n        if (isJson && !Publishers.isSingle(publisher.getClass())) {\n            // if the Publisher is returning JSON then in order for it to be valid JSON for each emitted element\n            // we must wrap the JSON in array and delimit the emitted items\n            httpContentPublisher = Flowable.concat(\n                Flowable.fromCallable(HttpContentUtil::openBracket),\n                httpContentPublisher,\n                Flowable.fromCallable(HttpContentUtil::closeBracket)\n            );\n        }\n\n        if (mediaType.equals(MediaType.TEXT_EVENT_STREAM_TYPE)) {\n            httpContentPublisher = Publishers.onComplete(httpContentPublisher, () -> {\n                CompletableFuture<Void> future = new CompletableFuture<>();\n                if (request == null || !request.getHeaders().isKeepAlive()) {\n                    if (context.channel().isOpen()) {\n                        context.pipeline()\n                            .writeAndFlush(new DefaultLastHttpContent())\n                            .addListener(f -> {\n                                    if (f.isSuccess()) {\n                                        future.complete(null);\n                                    } else {\n                                        future.completeExceptionally(f.cause());\n                                    }\n                                }\n                            );\n                    }\n                }\n                return future;\n            });\n        }\n\n        httpContentPublisher = Publishers.then(httpContentPublisher, httpContent -> {\n            // once an http content is written, read the next item if it is available\n            context.read();\n        });\n\n        DelegateStreamedHttpResponse streamedResponse = new DelegateStreamedHttpResponse(nativeResponse, httpContentPublisher);\n        io.netty.handler.codec.http.HttpHeaders headers = streamedResponse.headers();\n        headers.add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n        headers.add(HttpHeaderNames.CONTENT_TYPE, mediaType);\n        context.writeAndFlush(streamedResponse);\n        context.read();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void writeDefaultErrorResponse(ChannelHandlerContext ctx, NettyHttpRequest nettyHttpRequest, Throwable cause) {\n        logException(cause);\n\n        MutableHttpResponse<?> error = io.micronaut.http.HttpResponse.serverError()\n                .body(new JsonError(\"Internal Server Error: \" + cause.getMessage()));\n        subscribeToResponsePublisher(\n                ctx,\n                MediaType.APPLICATION_JSON_TYPE,\n                new AtomicReference<>(nettyHttpRequest),\n                Flowable.just(error)\n        );\n    }\n\n    private void logException(Throwable cause) {\n        //handling connection reset by peer exceptions\n        String message = cause.getMessage();\n        if (cause instanceof IOException && message != null && IGNORABLE_ERROR_MESSAGE.matcher(message).matches()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Swallowed an IOException caused by client connectivity: \" + cause.getMessage(), cause);\n            }\n        } else {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Unexpected error occurred: \" + cause.getMessage(), cause);\n            }\n        }\n    }\n\n    private void applyConfiguredHeaders(MutableHttpHeaders headers) {\n        if (serverConfiguration.isDateHeader() && !headers.contains(\"Date\")) {\n            headers.date(LocalDateTime.now());\n        }\n        serverConfiguration.getServerHeader().ifPresent((server) -> {\n            if (!headers.contains(\"Server\")) {\n                headers.add(\"Server\", server);\n            }\n        });\n    }\n\n    /**\n     * Used as a handle to the {@link NettyCustomizableResponseTypeHandler}.\n     */\n    private static class NettyCustomizableResponseTypeHandlerInvoker {\n        final NettyCustomizableResponseTypeHandler handler;\n        final Object body;\n\n        NettyCustomizableResponseTypeHandlerInvoker(NettyCustomizableResponseTypeHandler handler, Object body) {\n            this.handler = handler;\n            this.body = body;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        void invoke(HttpRequest<?> request, NettyMutableHttpResponse response, ChannelHandlerContext channelHandlerContext) {\n            this.handler.handle(body, request, response, channelHandlerContext);\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.binders;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.core.async.subscriber.CompletionAwareSubscriber;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.DefaultBodyAnnotationBinder;\nimport io.micronaut.http.bind.binders.NonBlockingBodyArgumentBinder;\nimport io.micronaut.http.server.netty.DefaultHttpContentProcessor;\nimport io.micronaut.http.server.netty.HttpContentProcessor;\nimport io.micronaut.http.server.netty.HttpContentSubscriberFactory;\nimport io.micronaut.http.server.netty.NettyHttpRequest;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport org.reactivestreams.Subscription;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\n\n/**\n * A {@link NonBlockingBodyArgumentBinder} that handles {@link CompletableFuture} instances.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n@Internal\npublic class CompletableFutureBodyBinder extends DefaultBodyAnnotationBinder<CompletableFuture>\n    implements NonBlockingBodyArgumentBinder<CompletableFuture> {\n\n    private static final Argument<CompletableFuture> TYPE = Argument.of(CompletableFuture.class);\n\n    private final BeanLocator beanLocator;\n    private final HttpServerConfiguration httpServerConfiguration;\n\n    /**\n     * @param beanLocator             The bean locator\n     * @param httpServerConfiguration The Http server configuration\n     * @param conversionService       The conversion service\n     */\n    public CompletableFutureBodyBinder(BeanLocator beanLocator, HttpServerConfiguration httpServerConfiguration, ConversionService conversionService) {\n        super(conversionService);\n        this.beanLocator = beanLocator;\n        this.httpServerConfiguration = httpServerConfiguration;\n    }\n\n    @Override\n    public Argument<CompletableFuture> argumentType() {\n        return TYPE;\n    }\n\n    @Override\n    public BindingResult<CompletableFuture> bind(ArgumentConversionContext<CompletableFuture> context, HttpRequest<?> source) {\n        if (source instanceof NettyHttpRequest) {\n            NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) source;\n            io.netty.handler.codec.http.HttpRequest nativeRequest = ((NettyHttpRequest) source).getNativeRequest();\n            if (nativeRequest instanceof StreamedHttpRequest) {\n\n                CompletableFuture future = new CompletableFuture();\n                Optional<MediaType> contentType = source.getContentType();\n                HttpContentProcessor<?> processor = contentType\n                    .flatMap(type -> beanLocator.findBean(HttpContentSubscriberFactory.class, new ConsumesMediaTypeQualifier<>(type)))\n                    .map(factory -> factory.build(nettyHttpRequest))\n                    .orElse(new DefaultHttpContentProcessor(nettyHttpRequest, httpServerConfiguration));\n\n                processor.subscribe(new CompletionAwareSubscriber<Object>() {\n                    @Override\n                    protected void doOnSubscribe(Subscription subscription) {\n                        subscription.request(1);\n                    }\n\n                    @Override\n                    protected void doOnNext(Object message) {\n                        nettyHttpRequest.setBody(message);\n                        subscription.request(1);\n                    }\n\n                    @Override\n                    protected void doOnError(Throwable t) {\n                        future.completeExceptionally(t);\n                    }\n\n                    @Override\n                    protected void doOnComplete() {\n                        Optional<Argument<?>> firstTypeParameter = context.getFirstTypeVariable();\n                        Optional body = nettyHttpRequest.getBody();\n                        if (body.isPresent()) {\n\n                            if (firstTypeParameter.isPresent()) {\n                                Argument<?> arg = firstTypeParameter.get();\n                                Class targetType = arg.getType();\n                                Optional converted = conversionService.convert(body.get(), context.with(arg));\n                                if (converted.isPresent()) {\n                                    future.complete(converted.get());\n                                } else {\n                                    future.completeExceptionally(new IllegalArgumentException(\"Cannot bind JSON to argument type: \" + targetType.getName()));\n                                }\n                            } else {\n                                future.complete(body.get());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                });\n\n                return () -> Optional.of(future);\n            } else {\n                return BindingResult.EMPTY;\n            }\n        } else {\n            return BindingResult.EMPTY;\n        }\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.binders;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.http.netty.stream.StreamedHttpRequest;\nimport io.micronaut.context.BeanLocator;\nimport io.micronaut.core.async.subscriber.TypedSubscriber;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionError;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.convert.exceptions.ConversionErrorException;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.MediaType;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.DefaultBodyAnnotationBinder;\nimport io.micronaut.http.bind.binders.NonBlockingBodyArgumentBinder;\nimport io.micronaut.http.server.netty.*;\nimport io.micronaut.web.router.exceptions.UnsatisfiedRouteException;\nimport io.micronaut.web.router.qualifier.ConsumesMediaTypeQualifier;\nimport io.netty.buffer.ByteBufHolder;\nimport io.netty.buffer.EmptyByteBuf;\nimport io.netty.util.ReferenceCounted;\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscription;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\n\n/**\n * A {@link io.micronaut.http.annotation.Body} argument binder for a reactive streams {@link Publisher}.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n@Internal\npublic class PublisherBodyBinder extends DefaultBodyAnnotationBinder<Publisher> implements NonBlockingBodyArgumentBinder<Publisher> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyHttpServer.class);\n    private static final Argument<Publisher> TYPE = Argument.of(Publisher.class);\n\n    private final BeanLocator beanLocator;\n    private final HttpServerConfiguration httpServerConfiguration;\n\n    /**\n     * @param conversionService       The conversion service\n     * @param beanLocator             The bean locator\n     * @param httpServerConfiguration The Http server configuration\n     */\n    public PublisherBodyBinder(ConversionService conversionService, BeanLocator beanLocator, HttpServerConfiguration httpServerConfiguration) {\n        super(conversionService);\n        this.beanLocator = beanLocator;\n        this.httpServerConfiguration = httpServerConfiguration;\n    }\n\n    @Override\n    public Argument<Publisher> argumentType() {\n        return TYPE;\n    }\n\n    @Override\n    public BindingResult<Publisher> bind(ArgumentConversionContext<Publisher> context, HttpRequest<?> source) {\n        if (source instanceof NettyHttpRequest) {\n            NettyHttpRequest nettyHttpRequest = (NettyHttpRequest) source;\n            io.netty.handler.codec.http.HttpRequest nativeRequest = nettyHttpRequest.getNativeRequest();\n            if (nativeRequest instanceof StreamedHttpRequest) {\n                Optional<MediaType> contentType = source.getContentType();\n                Argument<?> targetType = context.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n                HttpContentProcessor<?> processor = contentType\n                    .flatMap(type -> beanLocator.findBean(HttpContentSubscriberFactory.class, new ConsumesMediaTypeQualifier<>(type)))\n                    .map(factory -> factory.build(nettyHttpRequest))\n                    .orElse(new DefaultHttpContentProcessor(nettyHttpRequest, httpServerConfiguration));\n\n                //noinspection unchecked\n                return () -> Optional.of(subscriber -> processor.subscribe(new TypedSubscriber<Object>((Argument) context.getArgument()) {\n\n                    Subscription s;\n\n                    @Override\n                    protected void doOnSubscribe(Subscription subscription) {\n                        this.s = subscription;\n                        subscriber.onSubscribe(subscription);\n                    }\n\n                    @Override\n                    protected void doOnNext(Object message) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Server received streaming message for argument [{}]: {}\", context.getArgument(), message);\n                        }\n                        ArgumentConversionContext<?> conversionContext = context.with(targetType);\n                        if (message instanceof ByteBufHolder) {\n                            message = ((ByteBufHolder) message).content();\n                            if (message instanceof EmptyByteBuf) {\n                                return;\n                            }\n                        }\n\n                        Optional<?> converted = conversionService.convert(message, conversionContext);\n\n                        if (converted.isPresent()) {\n                            subscriber.onNext(converted.get());\n                        } else {\n\n                            try {\n                                Optional<ConversionError> lastError = conversionContext.getLastError();\n                                if (lastError.isPresent()) {\n                                    if (LOG.isDebugEnabled()) {\n                                        LOG.debug(\"Cannot convert message for argument [\" + context.getArgument() + \"] and value: \" + message, lastError.get());\n                                    }\n                                    subscriber.onError(new ConversionErrorException(context.getArgument(), lastError.get()));\n                                } else {\n                                    if (LOG.isDebugEnabled()) {\n                                        LOG.debug(\"Cannot convert message for argument [{}] and value: {}\", context.getArgument(), message);\n                                    }\n                                    subscriber.onError(new UnsatisfiedRouteException(context.getArgument()));\n                                }\n                            } finally {\n                                s.cancel();\n                            }\n                        }\n\n                        if (message instanceof ReferenceCounted) {\n                            ((ReferenceCounted) message).release();\n                        }\n                    }\n\n                    @Override\n                    protected void doOnError(Throwable t) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Server received error for argument [\" + context.getArgument() + \"]: \" + t.getMessage(), t);\n                        }\n                        try {\n                            subscriber.onError(t);\n                        } finally {\n                            s.cancel();\n                        }\n                    }\n\n                    @Override\n                    protected void doOnComplete() {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Done receiving messages for argument: {}\", context.getArgument());\n                        }\n                        subscriber.onComplete();\n                    }\n\n                }));\n            }\n        }\n        return BindingResult.EMPTY;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.netty.cors\n\nimport io.micronaut.core.convert.ConversionContext\nimport io.micronaut.core.type.Argument\nimport io.micronaut.http.HttpHeaders\nimport io.micronaut.http.HttpMethod\nimport io.micronaut.http.HttpRequest\nimport io.micronaut.http.HttpResponse\nimport io.micronaut.http.HttpStatus\nimport io.micronaut.http.MutableHttpResponse\nimport io.micronaut.http.server.cors.CorsFilter\nimport io.micronaut.http.server.cors.CorsOriginConfiguration\nimport io.micronaut.http.server.HttpServerConfiguration\nimport spock.lang.Specification\n\nimport static io.micronaut.http.HttpHeaders.*\n\nclass CorsFilterSpec extends Specification {\n\n    CorsFilter buildCorsHandler(HttpServerConfiguration.CorsConfiguration config) {\n        new CorsFilter(config ?: new HttpServerConfiguration.CorsConfiguration())\n    }\n\n    void \"test handleRequest for non CORS request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.empty()\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through\"\n        !result.isPresent()\n    }\n\n    void \"test handleRequest with no matching configuration\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because no configuration matches the origin\"\n        2 * headers.getOrigin() >> Optional.of('http://www.bar.com')\n        !result.isPresent()\n    }\n\n    void \"test handleRequest with regex matching configuration\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = regex\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because no configuration matches the origin\"\n        2 * headers.getOrigin() >> Optional.of(origin)\n        !result.isPresent()\n\n        where:\n        regex                               | origin\n        ['.*']                              | 'http://www.bar.com'\n        ['^http://www\\\\.(foo|bar)\\\\.com$']  | 'http://www.bar.com'\n        ['^http://www\\\\.(foo|bar)\\\\.com$']  | 'http://www.foo.com'\n        ['.*bar$', '.*foo$']                | 'asdfasdf foo'\n        ['.*bar$', '.*foo$']                | 'asdfasdf bar'\n    }\n\n    void \"test handleRequest with disallowed method\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is rejected because the method is not in the list of allowedMethods\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * request.getMethod() >> HttpMethod.POST\n        result.isPresent()\n        result.get().status == HttpStatus.FORBIDDEN\n    }\n\n    void \"test handleRequest with disallowed header (not preflight)\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is passed through because allowed headers are only checked for preflight requests\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * request.getMethod() >> HttpMethod.GET\n        !result.isPresent()\n        0 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String)))\n    }\n\n    void \"test preflight handleRequest with disallowed header\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        originConfig.allowedHeaders = ['foo']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        request.getMethod() >> HttpMethod.OPTIONS\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is rejected because bar is not allowed\"\n        2 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n        1 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> ['foo', 'bar']\n        result.get().status == HttpStatus.FORBIDDEN\n    }\n\n    void \"test preflight handleRequest with allowed header\"() {\n        given:\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        originConfig.allowedMethods = [HttpMethod.GET]\n        originConfig.allowedHeaders = ['foo', 'bar']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        request.getMethod() >> HttpMethod.OPTIONS\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the request is successful\"\n        4 * headers.getOrigin() >> Optional.of('http://www.foo.com')\n        2 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['foo'])\n        result.get().status == HttpStatus.OK\n    }\n\n    void \"test handleResponse when configuration not present\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.allowedOrigins = ['http://www.foo.com']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n\n\n        when:\n        def result = corsHandler.handleRequest(request)\n\n        then: \"the response is not modified\"\n        2 * headers.getOrigin() >> Optional.of('http://www.bar.com')\n        notThrown(NullPointerException)\n        !result.isPresent()\n    }\n\n    void \"test handleResponse for normal request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        def result = corsHandler.handleRequest(request)\n\n        then:\n        !result.isPresent()\n\n        when:\n        MutableHttpResponse response = HttpResponse.ok()\n        corsHandler.handleResponse(request, response)\n\n        then: \"the response is not modified\"\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_EXPOSE_HEADERS) == ['Foo-Header', 'Bar-Header' ]// Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n    }\n\n    void \"test handleResponse for preflight request\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration()\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n        request.getMethod() >> HttpMethod.OPTIONS\n\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        HttpResponse response = corsHandler.handleRequest(request).get()\n\n        then: \"the response is not modified\"\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['X-Header', 'Y-Header'])\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_EXPOSE_HEADERS) == ['Foo-Header', 'Bar-Header'] // Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n        response.getHeaders().getAll(ACCESS_CONTROL_ALLOW_HEADERS) == ['X-Header', 'Y-Header'] // Allow headers are echo'd from the request\n        response.getHeaders().get(ACCESS_CONTROL_MAX_AGE) == '1800' // Max age is set from config\n    }\n\n    void \"test handleResponse for preflight request with single header\"() {\n        given:\n        def config = new HttpServerConfiguration.CorsConfiguration(singleHeader: true)\n        CorsOriginConfiguration originConfig = new CorsOriginConfiguration()\n        originConfig.exposedHeaders = ['Foo-Header', 'Bar-Header']\n        config.configurations = new LinkedHashMap<String, CorsOriginConfiguration>()\n        config.configurations.put('foo', originConfig)\n        CorsFilter corsHandler = buildCorsHandler(config)\n        HttpRequest request = Mock(HttpRequest)\n        HttpHeaders headers = Mock(HttpHeaders)\n        request.getHeaders() >> headers\n        headers.getOrigin() >> Optional.of('http://www.foo.com')\n        request.getMethod() >> HttpMethod.OPTIONS\n\n\n        when:\n        headers.contains(ACCESS_CONTROL_REQUEST_METHOD) >> true\n        HttpResponse response = corsHandler.handleRequest(request).get()\n\n        then: \"the response is not modified\"\n        2 * headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.of(Argument.of(List,String))) >> Optional.of(['X-Header', 'Y-Header'])\n        1 * headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, ConversionContext.of(HttpMethod.class)) >> Optional.of(HttpMethod.GET)\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_METHODS) == 'GET'\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_ORIGIN) == 'http://www.foo.com' // The origin is echo'd\n        response.getHeaders().get(VARY) == 'Origin' // The vary header is set\n        response.getHeaders().get(ACCESS_CONTROL_EXPOSE_HEADERS) == 'Foo-Header,Bar-Header' // Expose headers are set from config\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_CREDENTIALS) == 'true' // Allow credentials header is set\n        response.getHeaders().get(ACCESS_CONTROL_ALLOW_HEADERS) == 'X-Header,Y-Header' // Allow headers are echo'd from the request\n        response.getHeaders().get(ACCESS_CONTROL_MAX_AGE) == '1800' // Max age is set from config\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.cors;\n\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_MAX_AGE;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS;\nimport static io.micronaut.http.HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD;\nimport static io.micronaut.http.HttpHeaders.ORIGIN;\nimport static io.micronaut.http.HttpHeaders.VARY;\n\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.order.Ordered;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.http.HttpHeaders;\nimport io.micronaut.http.HttpMethod;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.HttpResponse;\nimport io.micronaut.http.HttpStatus;\nimport io.micronaut.http.MutableHttpResponse;\nimport io.micronaut.http.annotation.Filter;\nimport io.micronaut.http.filter.HttpServerFilter;\nimport io.micronaut.http.filter.ServerFilterChain;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport org.reactivestreams.Publisher;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Responsible for handling CORS requests and responses.\n *\n * @author James Kleeh\n * @author Graeme Rocher\n * @since 1.0\n */\n@Filter(\"/**\")\npublic class CorsFilter implements HttpServerFilter {\n\n    private static final ArgumentConversionContext<HttpMethod> CONVERSION_CONTEXT_HTTP_METHOD = ConversionContext.of(HttpMethod.class);\n\n    protected final HttpServerConfiguration.CorsConfiguration corsConfiguration;\n\n    /**\n     * @param corsConfiguration The {@link CorsOriginConfiguration} instance\n     */\n    public CorsFilter(HttpServerConfiguration.CorsConfiguration corsConfiguration) {\n        this.corsConfiguration = corsConfiguration;\n    }\n\n    @Override\n    public Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {\n        boolean originHeaderPresent = request.getHeaders().getOrigin().isPresent();\n        if (originHeaderPresent) {\n            Optional<MutableHttpResponse<?>> response = handleRequest(request);\n            if (response.isPresent()) {\n                return Publishers.just(response.get());\n            } else {\n                return Publishers.map(chain.proceed(request), mutableHttpResponse -> {\n                    handleResponse(request, mutableHttpResponse);\n                    return mutableHttpResponse;\n                });\n            }\n        } else {\n            return chain.proceed(request);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n\n    /**\n     * Handles a CORS response.\n     *\n     * @param request  The {@link HttpRequest} object\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void handleResponse(HttpRequest<?> request, MutableHttpResponse<?> response) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        originHeader.ifPresent(requestOrigin -> {\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                if (CorsUtil.isPreflightRequest(request)) {\n                    Optional<HttpMethod> result = headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD);\n                    setAllowMethods(result.get(), response);\n                    Optional<List<String>> allowedHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n                    allowedHeaders.ifPresent(val ->\n                        setAllowHeaders(val, response)\n                    );\n\n                    setMaxAge(config.getMaxAge(), response);\n                }\n\n                setOrigin(requestOrigin, response);\n                setVary(response);\n                setExposeHeaders(config.getExposedHeaders(), response);\n                setAllowCredentials(config, response);\n            }\n        });\n    }\n\n    /**\n     * Handles a CORS {@link HttpRequest}.\n     *\n     * @param request The {@link HttpRequest} object\n     * @return An optional {@link MutableHttpResponse}. The request should proceed normally if empty\n     */\n    protected Optional<MutableHttpResponse<?>> handleRequest(HttpRequest request) {\n        HttpHeaders headers = request.getHeaders();\n        Optional<String> originHeader = headers.getOrigin();\n        if (originHeader.isPresent()) {\n\n            String requestOrigin = originHeader.get();\n            boolean preflight = CorsUtil.isPreflightRequest(request);\n\n            Optional<CorsOriginConfiguration> optionalConfig = getConfiguration(requestOrigin);\n\n            if (optionalConfig.isPresent()) {\n                CorsOriginConfiguration config = optionalConfig.get();\n\n                HttpMethod requestMethod = request.getMethod();\n\n                List<HttpMethod> allowedMethods = config.getAllowedMethods();\n\n                if (!isAnyMethod(allowedMethods)) {\n                    HttpMethod methodToMatch = preflight ? headers.getFirst(ACCESS_CONTROL_REQUEST_METHOD, CONVERSION_CONTEXT_HTTP_METHOD).orElse(requestMethod) : requestMethod;\n                    if (allowedMethods.stream().noneMatch(method -> method.equals(methodToMatch))) {\n                        return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                    }\n                }\n\n                if (preflight) {\n                    Optional<List<String>> accessControlHeaders = headers.get(ACCESS_CONTROL_REQUEST_HEADERS, ConversionContext.LIST_OF_STRING);\n\n                    List<String> allowedHeaders = config.getAllowedHeaders();\n\n                    if (!isAny(allowedHeaders) && accessControlHeaders.isPresent()) {\n                        if (!accessControlHeaders.get().stream()\n                            .allMatch(header -> allowedHeaders.stream()\n                                .anyMatch(allowedHeader -> allowedHeader.equals(header.trim())))) {\n                            return Optional.of(HttpResponse.status(HttpStatus.FORBIDDEN));\n                        }\n                    }\n\n                    MutableHttpResponse<Object> ok = HttpResponse.ok();\n                    handleResponse(request, ok);\n                    return Optional.of(ok);\n                }\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    /**\n     * @param config   The {@link CorsOriginConfiguration} instance\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setAllowCredentials(CorsOriginConfiguration config, MutableHttpResponse<?> response) {\n        if (config.isAllowCredentials()) {\n            response.header(ACCESS_CONTROL_ALLOW_CREDENTIALS, Boolean.toString(true));\n        }\n    }\n\n    /**\n     * @param exposedHeaders A list of the exposed headers\n     * @param response       The {@link MutableHttpResponse} object\n     */\n    protected void setExposeHeaders(List<String> exposedHeaders, MutableHttpResponse<?> response) {\n        if (corsConfiguration.isSingleHeader()) {\n            String headerValue = String.join(\",\", exposedHeaders);\n            if (StringUtils.isNotEmpty(headerValue)) {\n                response.header(ACCESS_CONTROL_EXPOSE_HEADERS, headerValue);\n            }\n        } else {\n            exposedHeaders.forEach(header -> response.header(ACCESS_CONTROL_EXPOSE_HEADERS, header));\n        }\n    }\n\n    /**\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setVary(MutableHttpResponse<?> response) {\n        response.header(VARY, ORIGIN);\n    }\n\n\n    /**\n     * @param origin   The origin\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setOrigin(String origin, MutableHttpResponse response) {\n        response.header(ACCESS_CONTROL_ALLOW_ORIGIN, origin);\n    }\n\n    /**\n     * @param method   The {@link HttpMethod} object\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setAllowMethods(HttpMethod method, MutableHttpResponse response) {\n        response.header(ACCESS_CONTROL_ALLOW_METHODS, method);\n    }\n\n    /**\n     * @param optionalAllowHeaders A list with optional allow headers\n     * @param response             The {@link MutableHttpResponse} object\n     */\n    protected void setAllowHeaders(List<?> optionalAllowHeaders, MutableHttpResponse response) {\n        List<String> allowHeaders = optionalAllowHeaders.stream().map(Object::toString).collect(Collectors.toList());\n        if (corsConfiguration.isSingleHeader()) {\n            String headerValue = String.join(\",\", allowHeaders);\n            if (StringUtils.isNotEmpty(headerValue)) {\n                response.header(ACCESS_CONTROL_ALLOW_HEADERS, headerValue);\n            }\n        } else {\n            allowHeaders.forEach(header -> response.header(ACCESS_CONTROL_ALLOW_HEADERS, header));\n        }\n    }\n\n    /**\n     * @param maxAge   The max age\n     * @param response The {@link MutableHttpResponse} object\n     */\n    protected void setMaxAge(long maxAge, MutableHttpResponse response) {\n        if (maxAge > -1) {\n            response.header(ACCESS_CONTROL_MAX_AGE, Long.toString(maxAge));\n        }\n    }\n\n    private Optional<CorsOriginConfiguration> getConfiguration(String requestOrigin) {\n        Map<String, CorsOriginConfiguration> corsConfigurations = corsConfiguration.getConfigurations();\n        for (Map.Entry<String, CorsOriginConfiguration> config : corsConfigurations.entrySet()) {\n            List<String> allowedOrigins = config.getValue().getAllowedOrigins();\n            if (!allowedOrigins.isEmpty()) {\n                boolean matches = false;\n                if (isAny(allowedOrigins)) {\n                    matches = true;\n                }\n                if (!matches) {\n                    matches = allowedOrigins.stream().anyMatch(origin -> {\n                        if (origin.equals(requestOrigin)) {\n                            return true;\n                        }\n                        Pattern p = Pattern.compile(origin);\n                        Matcher m = p.matcher(requestOrigin);\n                        return m.matches();\n                    });\n                }\n\n                if (matches) {\n                    return Optional.of(config.getValue());\n                }\n            }\n        }\n        return Optional.empty();\n    }\n\n    private boolean isAny(List<String> values) {\n        return values == CorsOriginConfiguration.ANY;\n    }\n\n    private boolean isAnyMethod(List<HttpMethod> allowedMethods) {\n        return allowedMethods == CorsOriginConfiguration.ANY_METHOD;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http.server.cors;\n\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.TypeConverter;\nimport io.micronaut.core.convert.value.ConvertibleValues;\nimport io.micronaut.core.convert.value.ConvertibleValuesMap;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpMethod;\n\nimport javax.inject.Singleton;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\n/**\n * Responsible for converting a map of configuration to an instance of {@link CorsOriginConfiguration}.\n *\n * @author James Kleeh\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\npublic class CorsOriginConverter implements TypeConverter<Object, CorsOriginConfiguration> {\n\n    private static final String ALLOWED_ORIGINS = \"allowedOrigins\";\n    private static final String ALLOWED_METHODS = \"allowedMethods\";\n    private static final String ALLOWED_HEADERS = \"allowedHeaders\";\n    private static final String EXPOSED_HEADERS = \"exposedHeaders\";\n    private static final String ALLOW_CREDENTIALS = \"allowCredentials\";\n    private static final String MAX_AGE = \"maxAge\";\n\n    private static final ArgumentConversionContext<List<HttpMethod>> CONVERSION_CONTEXT_LIST_OF_HTTP_METHOD = ConversionContext.of(Argument.listOf(HttpMethod.class));\n\n    @Override\n    public Optional<CorsOriginConfiguration> convert(Object object, Class<CorsOriginConfiguration> targetType, ConversionContext context) {\n        CorsOriginConfiguration configuration = new CorsOriginConfiguration();\n        if (object instanceof Map) {\n            Map mapConfig = (Map) object;\n            ConvertibleValues<Object> convertibleValues = new ConvertibleValuesMap<>(mapConfig);\n\n            convertibleValues\n                .get(ALLOWED_ORIGINS, ConversionContext.LIST_OF_STRING)\n                .ifPresent(configuration::setAllowedOrigins);\n\n            convertibleValues\n                .get(ALLOWED_METHODS, CONVERSION_CONTEXT_LIST_OF_HTTP_METHOD)\n                .ifPresent(configuration::setAllowedMethods);\n\n            convertibleValues\n                .get(ALLOWED_HEADERS, ConversionContext.LIST_OF_STRING)\n                .ifPresent(configuration::setAllowedHeaders);\n\n            convertibleValues\n                .get(EXPOSED_HEADERS, ConversionContext.LIST_OF_STRING)\n                .ifPresent(configuration::setExposedHeaders);\n\n            convertibleValues\n                .get(ALLOW_CREDENTIALS, ConversionContext.BOOLEAN)\n                .ifPresent(configuration::setAllowCredentials);\n\n            convertibleValues\n                .get(MAX_AGE, ConversionContext.LONG)\n                .ifPresent(configuration::setMaxAge);\n        }\n        return Optional.of(configuration);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http;\n\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.type.Headers;\n\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.OptionalLong;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n * Constants for common HTTP headers. See https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\npublic interface HttpHeaders extends Headers {\n\n    /**\n     * {@code \"Accept\"}.\n     */\n    String ACCEPT = \"Accept\";\n\n    /**\n     * {@code \"Accept-Charset\"}.\n     */\n    String ACCEPT_CHARSET = \"Accept-Charset\";\n\n    /**\n     * {@code \"Accept-Encoding\"}.\n     */\n    String ACCEPT_ENCODING = \"Accept-Encoding\";\n\n    /**\n     * {@code \"Accept-Language\"}.\n     */\n    String ACCEPT_LANGUAGE = \"Accept-Language\";\n\n    /**\n     * {@code \"Accept-Ranges\"}.\n     */\n    String ACCEPT_RANGES = \"Accept-Ranges\";\n\n    /**\n     * {@code \"Accept-Patch\"}.\n     */\n    String ACCEPT_PATCH = \"Accept-Patch\";\n\n    /**\n     * {@code \"Access-Control-Allow-Credentials\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_CREDENTIALS = \"Access-Control-Allow-Credentials\";\n\n    /**\n     * {@code \"Access-Control-Allow-Headers\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_HEADERS = \"Access-Control-Allow-Headers\";\n\n    /**\n     * {@code \"Access-Control-Allow-Methods\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_METHODS = \"Access-Control-Allow-Methods\";\n\n    /**\n     * {@code \"Access-Control-Allow-Origin\"}.\n     */\n    String ACCESS_CONTROL_ALLOW_ORIGIN = \"Access-Control-Allow-Origin\";\n\n    /**\n     * {@code \"Access-Control-Expose-Headers\"}.\n     */\n    String ACCESS_CONTROL_EXPOSE_HEADERS = \"Access-Control-Expose-Headers\";\n\n    /**\n     * {@code \"Access-Control-Max-Age\"}.\n     */\n    String ACCESS_CONTROL_MAX_AGE = \"Access-Control-Max-Age\";\n\n    /**\n     * {@code \"Access-Control-Request-Headers\"}.\n     */\n    String ACCESS_CONTROL_REQUEST_HEADERS = \"Access-Control-Request-Headers\";\n\n    /**\n     * {@code \"Access-Control-Request-Method\"}.\n     */\n    String ACCESS_CONTROL_REQUEST_METHOD = \"Access-Control-Request-Method\";\n\n    /**\n     * {@code \"Age\"}.\n     */\n    String AGE = \"Age\";\n\n    /**\n     * {@code \"Allow\"}.\n     */\n    String ALLOW = \"Allow\";\n\n    /**\n     * {@code \"Authorization\"}.\n     */\n    String AUTHORIZATION = \"Authorization\";\n\n    /**\n     * {@code \"Authorization\"}.\n     */\n    String AUTHORIZATION_INFO = \"Authorization-Info\";\n\n    /**\n     * {@code \"Cache-Control\"}.\n     */\n    String CACHE_CONTROL = \"Cache-Control\";\n\n    /**\n     * {@code \"Connection\"}.\n     */\n    String CONNECTION = \"Connection\";\n\n    /**\n     * {@code \"Content-Base\"}.\n     */\n    String CONTENT_BASE = \"Content-Base\";\n\n    /**\n     * {@code \"Content-Disposition\"}.\n     */\n    String CONTENT_DISPOSITION = \"Content-Disposition\";\n\n    /**\n     * {@code \"Content-Encoding\"}.\n     */\n    String CONTENT_ENCODING = \"Content-Encoding\";\n\n    /**\n     * {@code \"Content-Language\"}.\n     */\n    String CONTENT_LANGUAGE = \"Content-Language\";\n\n    /**\n     * {@code \"Content-Length\"}.\n     */\n    String CONTENT_LENGTH = \"Content-Length\";\n\n    /**\n     * {@code \"Content-Location\"}.\n     */\n    String CONTENT_LOCATION = \"Content-Location\";\n\n    /**\n     * {@code \"Content-Transfer-Encoding\"}.\n     */\n    String CONTENT_TRANSFER_ENCODING = \"Content-Transfer-Encoding\";\n\n    /**\n     * {@code \"Content-MD5\"}.\n     */\n    String CONTENT_MD5 = \"Content-MD5\";\n\n    /**\n     * {@code \"Content-Range\"}.\n     */\n    String CONTENT_RANGE = \"Content-Range\";\n\n    /**\n     * {@code \"Content-Type\"}.\n     */\n    String CONTENT_TYPE = \"Content-Type\";\n\n    /**\n     * {@code \"Cookie\"}.\n     */\n    String COOKIE = \"Cookie\";\n\n    /**\n     * {@code \"Date\"}.\n     */\n    String DATE = \"Date\";\n\n    /**\n     * {@code \"ETag\"}.\n     */\n    String ETAG = \"ETag\";\n\n    /**\n     * {@code \"Expect\"}.\n     */\n    String EXPECT = \"Expect\";\n\n    /**\n     * {@code \"Expires\"}.\n     */\n    String EXPIRES = \"Expires\";\n\n    /**\n     * {@code \"Forwarded\"}.\n     */\n    String FORWARDED = \"Forwarded\";\n\n    /**\n     * {@code \"From\"}.\n     */\n    String FROM = \"From\";\n\n    /**\n     * {@code \"Host\"}.\n     */\n    String HOST = \"Host\";\n\n    /**\n     * {@code \"If-Match\"}.\n     */\n    String IF_MATCH = \"If-Match\";\n\n    /**\n     * {@code \"If-Modified-Since\"}.\n     */\n    String IF_MODIFIED_SINCE = \"If-Modified-Since\";\n\n    /**\n     * {@code \"If-None-Match\"}.\n     */\n    String IF_NONE_MATCH = \"If-None-Match\";\n\n    /**\n     * {@code \"If-Range\"}.\n     */\n    String IF_RANGE = \"If-Range\";\n\n    /**\n     * {@code \"If-Unmodified-Since\"}.\n     */\n    String IF_UNMODIFIED_SINCE = \"If-Unmodified-Since\";\n\n    /**\n     * {@code \"Last-Modified\"}.\n     */\n    String LAST_MODIFIED = \"Last-Modified\";\n\n    /**\n     * {@code \"Location\"}.\n     */\n    String LOCATION = \"Location\";\n\n    /**\n     * {@code \"Max-Forwards\"}.\n     */\n    String MAX_FORWARDS = \"Max-Forwards\";\n\n    /**\n     * {@code \"Origin\"}.\n     */\n    String ORIGIN = \"Origin\";\n\n    /**\n     * {@code \"Pragma\"}.\n     */\n    String PRAGMA = \"Pragma\";\n\n    /**\n     * {@code \"Proxy-Authenticate\"}.\n     */\n    String PROXY_AUTHENTICATE = \"Proxy-Authenticate\";\n\n    /**\n     * {@code \"Proxy-Authorization\"}.\n     */\n    String PROXY_AUTHORIZATION = \"Proxy-Authorization\";\n\n    /**\n     * {@code \"Range\"}.\n     */\n    String RANGE = \"Range\";\n\n    /**\n     * {@code \"Referer\"}.\n     */\n    String REFERER = \"Referer\";\n\n    /**\n     * {@code \"Retry-After\"}.\n     */\n    String RETRY_AFTER = \"Retry-After\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key1\"}.\n     */\n    String SEC_WEBSOCKET_KEY1 = \"Sec-WebSocket-Key1\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key2\"}.\n     */\n    String SEC_WEBSOCKET_KEY2 = \"Sec-WebSocket-Key2\";\n\n    /**\n     * {@code \"Sec-WebSocket-Location\"}.\n     */\n    String SEC_WEBSOCKET_LOCATION = \"Sec-WebSocket-Location\";\n\n    /**\n     * {@code \"Sec-WebSocket-Origin\"}.\n     */\n    String SEC_WEBSOCKET_ORIGIN = \"Sec-WebSocket-Origin\";\n\n    /**\n     * {@code \"Sec-WebSocket-Protocol\"}.\n     */\n    String SEC_WEBSOCKET_PROTOCOL = \"Sec-WebSocket-Protocol\";\n\n    /**\n     * {@code \"Sec-WebSocket-Version\"}.\n     */\n    String SEC_WEBSOCKET_VERSION = \"Sec-WebSocket-Version\";\n\n    /**\n     * {@code \"Sec-WebSocket-Key\"}.\n     */\n    String SEC_WEBSOCKET_KEY = \"Sec-WebSocket-Key\";\n\n    /**\n     * {@code \"Sec-WebSocket-Accept\"}.\n     */\n    String SEC_WEBSOCKET_ACCEPT = \"Sec-WebSocket-Accept\";\n\n    /**\n     * {@code \"Server\"}.\n     */\n    String SERVER = \"Server\";\n\n    /**\n     * {@code \"Set-Cookie\"}.\n     */\n    String SET_COOKIE = \"Set-Cookie\";\n\n    /**\n     * {@code \"Set-Cookie2\"}.\n     */\n    String SET_COOKIE2 = \"Set-Cookie2\";\n\n    /**\n     * {@code \"TE\"}.\n     */\n    String TE = \"TE\";\n\n    /**\n     * {@code \"Trailer\"}.\n     */\n    String TRAILER = \"Trailer\";\n\n    /**\n     * {@code \"Transfer-Encoding\"}.\n     */\n    String TRANSFER_ENCODING = \"Transfer-Encoding\";\n\n    /**\n     * {@code \"Upgrade\"}.\n     */\n    String UPGRADE = \"Upgrade\";\n\n    /**\n     * {@code \"User-Agent\"}.\n     */\n    String USER_AGENT = \"User-Agent\";\n\n    /**\n     * {@code \"Vary\"}.\n     */\n    String VARY = \"Vary\";\n\n    /**\n     * {@code \"Via\"}.\n     */\n    String VIA = \"Via\";\n\n    /**\n     * {@code \"Warning\"}.\n     */\n    String WARNING = \"Warning\";\n\n    /**\n     * {@code \"WebSocket-Location\"}.\n     */\n    String WEBSOCKET_LOCATION = \"WebSocket-Location\";\n\n    /**\n     * {@code \"WebSocket-Origin\"}.\n     */\n    String WEBSOCKET_ORIGIN = \"WebSocket-Origin\";\n\n    /**\n     * {@code \"WebSocket-Protocol\"}.\n     */\n    String WEBSOCKET_PROTOCOL = \"WebSocket-Protocol\";\n\n    /**\n     * {@code \"WWW-Authenticate\"}.\n     */\n    String WWW_AUTHENTICATE = \"WWW-Authenticate\";\n\n    /**\n     * {@code \"X-Auth-Token\"}.\n     */\n    String X_AUTH_TOKEN = \"X-Auth-Token\";\n\n    /**\n     * Obtain the date header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed\n     * {@link Optional#empty()}\n     */\n    default Optional<ZonedDateTime> findDate(CharSequence name) {\n        try {\n            return findFirst(name).map((str) -> {\n                    LocalDateTime localDateTime = LocalDateTime.parse(str, DateTimeFormatter.RFC_1123_DATE_TIME);\n                    return ZonedDateTime.of(localDateTime, ZoneId.of(\"GMT\"));\n                }\n\n            );\n        } catch (DateTimeParseException e) {\n            return Optional.empty();\n        }\n    }\n\n    /**\n     * Obtain the date header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed null\n     */\n    default ZonedDateTime getDate(CharSequence name) {\n        return findDate(name).orElse(null);\n    }\n\n    /**\n     * Obtain an integer header.\n     *\n     * @param name The header name\n     * @return The date header as a {@link ZonedDateTime} otherwise if it is not present or cannot be parsed null\n     */\n    default Integer getInt(CharSequence name) {\n        return findInt(name).orElse(null);\n    }\n\n    /**\n     * Find an integer header.\n     *\n     * @param name The name of the header\n     * @return An {@link Optional} of {@link Integer}\n     */\n    default Optional<Integer> findInt(CharSequence name) {\n        return get(name, ConversionContext.INT);\n    }\n\n    /**\n     * Get the first value of the given header.\n     *\n     * @param name The header name\n     * @return The first value or null if it is present\n     */\n    default Optional<String> findFirst(CharSequence name) {\n        return getFirst(name, ConversionContext.STRING);\n    }\n\n    /**\n     * The request or response content type.\n     *\n     * @return The content type\n     */\n    default Optional<MediaType> contentType() {\n        return getFirst(HttpHeaders.CONTENT_TYPE, MediaType.CONVERSION_CONTEXT);\n    }\n\n    /**\n     * The request or response content type.\n     *\n     * @return The content type\n     */\n    default OptionalLong contentLength() {\n        Optional<Long> optional = getFirst(HttpHeaders.CONTENT_LENGTH, ConversionContext.LONG);\n        return optional.map(OptionalLong::of).orElseGet(OptionalLong::empty);\n    }\n\n    /**\n     * A list of accepted {@link MediaType} instances.\n     *\n     * @return A list of zero or many {@link MediaType} instances\n     */\n    default List<MediaType> accept() {\n        return getAll(HttpHeaders.ACCEPT)\n            .stream()\n            .flatMap(x -> Arrays.stream(x.split(\",\")))\n            .flatMap(s -> ConversionService.SHARED.convert(s, MediaType.CONVERSION_CONTEXT).map(Stream::of).orElse(Stream.empty()))\n            .distinct()\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * @return Whether the {@link HttpHeaders#CONNECTION} header is set to Keep-Alive\n     */\n    default boolean isKeepAlive() {\n        return getFirst(CONNECTION, ConversionContext.STRING).map(val -> val.equalsIgnoreCase(\"keep-alive\")).orElse(false);\n    }\n\n    /**\n     * @return The {@link #ORIGIN} header\n     */\n    default Optional<String> getOrigin() {\n        return findFirst(ORIGIN);\n    }\n\n    /**\n     * @return The {@link #AUTHORIZATION} header\n     */\n    default Optional<String> getAuthorization() {\n        return findFirst(AUTHORIZATION);\n    }\n\n    /**\n     * @return The {@link #CONTENT_TYPE} header\n     */\n    default Optional<String> getContentType() {\n        return findFirst(CONTENT_TYPE);\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.http;\n\nimport io.micronaut.core.annotation.Internal;\nimport io.micronaut.core.annotation.TypeHint;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.convert.ConversionService;\nimport io.micronaut.core.naming.NameUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.core.value.OptionalValues;\nimport io.micronaut.http.annotation.Produces;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\n/**\n * Represents a media type.\n * See https://www.iana.org/assignments/media-types/media-types.xhtml and https://tools.ietf.org/html/rfc2046\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@TypeHint(value = MediaType[].class)\npublic class MediaType implements CharSequence {\n\n    /**\n     * Default file extension used for JSON.\n     */\n    public static final String EXTENSION_JSON = \"json\";\n\n    /**\n     * Default file extension used for XML.\n     */\n    public static final String EXTENSION_XML = \"xml\";\n\n    /**\n     * Default empty media type array.\n     */\n    public static final MediaType[] EMPTY_ARRAY = new MediaType[0];\n\n    /**\n     * A wildcard media type representing all types.\n     */\n    public static final String ALL = \"*/*\";\n\n    /**\n     * A wildcard media type representing all types.\n     */\n    public static final MediaType ALL_TYPE = new MediaType(ALL, \"all\");\n\n    /**\n     * Form encoded data: application/x-www-form-urlencoded.\n     */\n    public static final String APPLICATION_FORM_URLENCODED = \"application/x-www-form-urlencoded\";\n\n    /**\n     * Form encoded data: application/x-www-form-urlencoded.\n     */\n    public static final MediaType APPLICATION_FORM_URLENCODED_TYPE = new MediaType(APPLICATION_FORM_URLENCODED);\n\n    /**\n     * Short cut for {@link #APPLICATION_FORM_URLENCODED_TYPE}.\n     */\n    public static final MediaType FORM = APPLICATION_FORM_URLENCODED_TYPE;\n\n    /**\n     * Multi part form data: multipart/form-data.\n     */\n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n\n    /**\n     * Multi part form data: multipart/form-data.\n     */\n    public static final MediaType MULTIPART_FORM_DATA_TYPE = new MediaType(MULTIPART_FORM_DATA);\n\n    /**\n     * HTML: text/html.\n     */\n    public static final String TEXT_HTML = \"text/html\";\n\n    /**\n     * HTML: text/html.\n     */\n    public static final MediaType TEXT_HTML_TYPE = new MediaType(TEXT_HTML);\n\n    /**\n     * XHTML: application/xhtml+xml.\n     */\n    public static final String APPLICATION_XHTML = \"application/xhtml+xml\";\n\n    /**\n     * XHTML: application/xhtml+xml.\n     */\n    public static final MediaType APPLICATION_XHTML_TYPE = new MediaType(APPLICATION_XHTML, \"html\");\n\n    /**\n     * XML: application/xml.\n     */\n    public static final String APPLICATION_XML = \"application/xml\";\n\n    /**\n     * XML: application/xml.\n     */\n    public static final MediaType APPLICATION_XML_TYPE = new MediaType(APPLICATION_XML);\n\n    /**\n     * JSON: application/json.\n     */\n    public static final String APPLICATION_JSON = \"application/json\";\n\n    /**\n     * JSON: application/json.\n     */\n    public static final MediaType APPLICATION_JSON_TYPE = new MediaType(MediaType.APPLICATION_JSON);\n\n    /**\n     * YAML: application/x-yaml.\n     */\n    public static final String APPLICATION_YAML = \"application/x-yaml\";\n\n    /**\n     * YAML: application/x-yaml.\n     */\n    public static final MediaType APPLICATION_YAML_TYPE = new MediaType(MediaType.APPLICATION_YAML);\n\n    /**\n     * XML: text/xml.\n     */\n    public static final String TEXT_XML = \"text/xml\";\n\n    /**\n     * XML: text/xml.\n     */\n    public static final MediaType TEXT_XML_TYPE = new MediaType(TEXT_XML);\n\n    /**\n     * JSON: text/json.\n     */\n    public static final String TEXT_JSON = \"text/json\";\n\n    /**\n     * JSON: text/json.\n     */\n    public static final MediaType TEXT_JSON_TYPE = new MediaType(TEXT_JSON);\n\n    /**\n     * Plain Text: text/plain.\n     */\n    public static final String TEXT_PLAIN = \"text/plain\";\n\n    /**\n     * Plain Text: text/plain.\n     */\n    public static final MediaType TEXT_PLAIN_TYPE = new MediaType(TEXT_PLAIN);\n\n    /**\n     * HAL JSON: application/hal+json.\n     */\n    public static final String APPLICATION_HAL_JSON = \"application/hal+json\";\n\n    /**\n     * HAL JSON: application/hal+json.\n     */\n    public static final MediaType APPLICATION_HAL_JSON_TYPE = new MediaType(APPLICATION_HAL_JSON);\n\n    /**\n     * HAL XML: application/hal+xml.\n     */\n    public static final String APPLICATION_HAL_XML = \"application/hal+xml\";\n\n    /**\n     * HAL XML: application/hal+xml.\n     */\n    public static final MediaType APPLICATION_HAL_XML_TYPE = new MediaType(APPLICATION_HAL_XML);\n\n    /**\n     * Atom: application/atom+xml.\n     */\n    public static final String APPLICATION_ATOM_XML = \"application/atom+xml\";\n\n    /**\n     * Atom: application/atom+xml.\n     */\n    public static final MediaType APPLICATION_ATOM_XML_TYPE = new MediaType(APPLICATION_ATOM_XML);\n\n    /**\n     * VND Error: application/vnd.error+json.\n     */\n    public static final String APPLICATION_VND_ERROR = \"application/vnd.error+json\";\n\n    /**\n     * VND Error: application/vnd.error+json.\n     */\n    public static final MediaType APPLICATION_VND_ERROR_TYPE = new MediaType(APPLICATION_VND_ERROR);\n\n    /**\n     * Server Sent Event: text/event-stream.\n     */\n    public static final String TEXT_EVENT_STREAM = \"text/event-stream\";\n\n    /**\n     * Server Sent Event: text/event-stream.\n     */\n    public static final MediaType TEXT_EVENT_STREAM_TYPE = new MediaType(TEXT_EVENT_STREAM);\n\n    /**\n     * JSON Stream: application/x-json-stream.\n     */\n    public static final String APPLICATION_JSON_STREAM = \"application/x-json-stream\";\n\n    /**\n     * JSON Stream: application/x-json-stream.\n     */\n    public static final MediaType APPLICATION_JSON_STREAM_TYPE = new MediaType(APPLICATION_JSON_STREAM);\n\n    /**\n     * BINARY: application/octet-stream.\n     */\n    public static final String APPLICATION_OCTET_STREAM = \"application/octet-stream\";\n\n    /**\n     * BINARY: application/octet-stream.\n     */\n    public static final MediaType APPLICATION_OCTET_STREAM_TYPE = new MediaType(APPLICATION_OCTET_STREAM);\n\n    /**\n     * GraphQL: application/graphql.\n     */\n    public static final String APPLICATION_GRAPHQL = \"application/graphql\";\n\n    /**\n     * GraphQL: application/graphql.\n     */\n    public static final MediaType APPLICATION_GRAPHQL_TYPE = new MediaType(APPLICATION_GRAPHQL);\n\n    /**\n     * Png Image: image/png.\n     */\n    public static final String IMAGE_PNG = \"image/png\";\n\n    /**\n     * Png Image: image/png.\n     */\n    public static final MediaType IMAGE_PNG_TYPE = new MediaType(IMAGE_PNG);\n\n    /**\n     * Jpeg Image: image/jpeg.\n     */\n    public static final String IMAGE_JPEG = \"image/jpeg\";\n\n    /**\n     * Jpeg Image: image/jpeg.\n     */\n    public static final MediaType IMAGE_JPEG_TYPE = new MediaType(IMAGE_JPEG);\n\n    /**\n     * Gif Image: image/gif.\n     */\n    public static final String IMAGE_GIF = \"image/gif\";\n\n    /**\n     * Gif Image: image/gif.\n     */\n    public static final MediaType IMAGE_GIF_TYPE = new MediaType(IMAGE_GIF);\n\n    /**\n     * Webp Image: image/webp.\n     */\n    public static final String IMAGE_WEBP = \"image/webp\";\n\n    /**\n     * Webp Image: image/webp.\n     */\n    public static final MediaType IMAGE_WEBP_TYPE = new MediaType(IMAGE_WEBP);\n\n    /**\n     * Parameter {@code \"charset\"}.\n     */\n    public static final String CHARSET_PARAMETER = \"charset\";\n\n    /**\n     * Parameter {@code \"q\"}.\n     */\n    public static final String Q_PARAMETER = \"q\";\n\n    /**\n     * Parameter {@code \"v\"}.\n     */\n    public static final String V_PARAMETER = \"v\";\n\n    @Internal\n    static final Argument<MediaType> ARGUMENT = Argument.of(MediaType.class);\n\n    @Internal\n    static final ArgumentConversionContext<MediaType> CONVERSION_CONTEXT = ConversionContext.of(ARGUMENT);\n\n    private static final BigDecimal QUALITY_RATING_NUMBER = new BigDecimal(\"1.0\");\n    private static final String QUALITY_RATING = \"1.0\";\n    private static final String SEMICOLON = \";\";\n\n    @SuppressWarnings(\"ConstantName\")\n    private static final Logger LOG = LoggerFactory.getLogger(MediaType.class);\n    private static final String MIME_TYPES_FILE_NAME = \"META-INF/http/mime.types\";\n    private static Map<String, String> mediaTypeFileExtensions;\n    @SuppressWarnings(\"ConstantName\")\n    private static final List<Pattern> textTypePatterns = new ArrayList<>(4);\n\n    protected final String name;\n    protected final String subtype;\n    protected final String type;\n    protected final String extension;\n    protected final Map<CharSequence, String> parameters;\n    private final String strRepr;\n\n    private BigDecimal qualityNumberField;\n\n    static {\n        ConversionService.SHARED.addConverter(CharSequence.class, MediaType.class, (Function<CharSequence, MediaType>) charSequence -> {\n                    if (StringUtils.isNotEmpty(charSequence)) {\n                        return new MediaType(charSequence.toString());\n                    }\n                    return null;\n                }\n        );\n        textTypePatterns.add(Pattern.compile(\"^text/.*$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+json$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+text$\"));\n        textTypePatterns.add(Pattern.compile(\"^.*\\\\+xml$\"));\n        textTypePatterns.add(Pattern.compile(\"^application/javascript$\"));\n    }\n\n    /**\n     * Constructs a new media type for the given string.\n     *\n     * @param name The name of the media type. For example application/json\n     */\n    public MediaType(String name) {\n        this(name, null, Collections.emptyMap());\n    }\n\n    /**\n     * Constructs a new media type for the given string and parameters.\n     *\n     * @param name   The name of the media type. For example application/json\n     * @param params The parameters\n     */\n    public MediaType(String name, Map<String, String> params) {\n        this(name, null, params);\n    }\n\n    /**\n     * Constructs a new media type for the given string and extension.\n     *\n     * @param name      The name of the media type. For example application/json\n     * @param extension The extension of the file using this media type if it differs from the subtype\n     */\n    public MediaType(String name, String extension) {\n        this(name, extension, Collections.emptyMap());\n    }\n\n    /**\n     * Constructs a new media type for the given string and extension.\n     *\n     * @param name      The name of the media type. For example application/json\n     * @param extension The extension of the file using this media type if it differs from the subtype\n     * @param params    The parameters\n     */\n    public MediaType(String name, String extension, Map<String, String> params) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"Argument [name] cannot be null\");\n        }\n        String withoutArgs;\n        if (name.contains(SEMICOLON)) {\n            this.parameters = new LinkedHashMap<>();\n            String[] tokenWithArgs = name.split(SEMICOLON);\n            withoutArgs = tokenWithArgs[0];\n            String[] paramsList = Arrays.copyOfRange(tokenWithArgs, 1, tokenWithArgs.length);\n            for (String param : paramsList) {\n                int i = param.indexOf('=');\n                if (i > -1) {\n                    parameters.put(param.substring(0, i).trim(), param.substring(i + 1).trim());\n                }\n            }\n        } else {\n            this.parameters = Collections.emptyMap();\n            withoutArgs = name;\n        }\n        this.name = withoutArgs;\n        int i = withoutArgs.indexOf('/');\n        if (i > -1) {\n            this.type = withoutArgs.substring(0, i);\n            this.subtype = withoutArgs.substring(i + 1);\n        } else {\n            throw new IllegalArgumentException(\"Invalid mime type: \" + name);\n        }\n\n        if (extension != null) {\n            this.extension = extension;\n        } else {\n            int j = subtype.indexOf('+');\n            if (j > -1) {\n                this.extension = subtype.substring(j + 1);\n            } else {\n                this.extension = subtype;\n            }\n        }\n        if (params != null) {\n            parameters.putAll(params);\n        }\n\n        this.strRepr = toString0();\n    }\n\n    /**\n     * @return The name of the mime type without any parameters\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * @return The type of the media type. For example for application/hal+json this would return \"application\"\n     */\n    public String getType() {\n        return this.type;\n    }\n\n    /**\n     * @return The subtype. For example for application/hal+json this would return \"hal+json\"\n     */\n    public String getSubtype() {\n        return this.subtype;\n    }\n\n    /**\n     * @return The extension. For example for application/hal+json this would return \"json\"\n     */\n    public String getExtension() {\n        return extension;\n    }\n\n    /**\n     * @return The parameters to the media type\n     */\n    public OptionalValues<String> getParameters() {\n        return OptionalValues.of(String.class, parameters);\n    }\n\n    /**\n     * @return The quality of the Mime type\n     */\n    public String getQuality() {\n        return parameters.getOrDefault(\"q\", QUALITY_RATING);\n    }\n\n    /**\n     * @return The quality in BigDecimal form\n     */\n    public BigDecimal getQualityAsNumber() {\n        if (this.qualityNumberField == null) {\n            this.qualityNumberField = getOrConvertQualityParameterToBigDecimal(this);\n        }\n        return this.qualityNumberField;\n    }\n\n    /**\n     * @return The version of the Mime type\n     */\n    public String getVersion() {\n        return parameters.getOrDefault(V_PARAMETER, null);\n    }\n\n    /**\n     * @return The charset of the media type if specified\n     */\n    public Optional<Charset> getCharset() {\n        return getParameters().get(\"charset\").map(Charset::forName);\n    }\n\n    @Override\n    public int length() {\n        return strRepr.length();\n    }\n\n    @Override\n    public char charAt(int index) {\n        return strRepr.charAt(index);\n    }\n\n    @Override\n    public CharSequence subSequence(int start, int end) {\n        return strRepr.subSequence(start, end);\n    }\n\n    /**\n     * @return Whether the media type is text based\n     */\n    public boolean isTextBased() {\n        boolean matches = textTypePatterns.stream().anyMatch((p) -> p.matcher(name).matches());\n        if (!matches) {\n            matches = subtype.equalsIgnoreCase(\"json\") || subtype.equalsIgnoreCase(\"xml\");\n        }\n        return matches;\n    }\n\n    /**\n     * @param contentType The content type\n     * @return Whether the content type is text based\n     */\n    public static boolean isTextBased(String contentType) {\n        if (StringUtils.isEmpty(contentType)) {\n            return false;\n        }\n        MediaType mediaType = new MediaType(contentType);\n        return mediaType.isTextBased();\n    }\n\n    @Override\n    public String toString() {\n        return strRepr;\n    }\n\n    private String toString0() {\n        if (parameters.isEmpty()) {\n            return name;\n        } else {\n            return name + \";\" + parameters.entrySet().stream().map(Object::toString)\n                    .collect(Collectors.joining(\";\"));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Only the name is matched. Parameters are not included.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        MediaType mediaType = (MediaType) o;\n\n        return name.equalsIgnoreCase(mediaType.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return name.hashCode();\n    }\n\n    /**\n     * Create a new {@link MediaType} from the given text.\n     *\n     * @param mediaType The text\n     * @return The {@link MediaType}\n     */\n    public static MediaType of(CharSequence mediaType) {\n        return new MediaType(mediaType.toString());\n    }\n\n    /**\n     * Create a new {@link MediaType} from the given text.\n     *\n     * @param mediaType The text\n     * @return The {@link MediaType}\n     */\n    public static MediaType[] of(CharSequence... mediaType) {\n        return Arrays.stream(mediaType).map(txt -> new MediaType(txt.toString())).toArray(MediaType[]::new);\n    }\n\n    /**\n     * Resolve the {@link MediaType} produced by the given type based on the {@link Produces} annotation.\n     *\n     * @param type The type\n     * @return An {@link Optional} {@link MediaType}\n     */\n    public static Optional<MediaType> fromType(Class<?> type) {\n        Produces producesAnn = type.getAnnotation(Produces.class);\n        if (producesAnn != null) {\n            return Arrays.stream(producesAnn.value()).findFirst().map(MediaType::new);\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Resolve the {@link MediaType} for the given file extension.\n     *\n     * @param extension The file extension\n     * @return The {@link MediaType}\n     */\n    public static Optional<MediaType> forExtension(String extension) {\n        if (StringUtils.isNotEmpty(extension)) {\n            String type = getMediaTypeFileExtensions().get(extension);\n            if (type != null) {\n                return Optional.of(new MediaType(type, extension));\n            }\n        }\n        return Optional.empty();\n    }\n\n    /**\n     * Resolve the {@link MediaType} for the given file name. Defaults\n     * to text/plain.\n     *\n     * @param filename The file name\n     * @return The {@link MediaType}\n     */\n    public static MediaType forFilename(String filename) {\n        if (StringUtils.isNotEmpty(filename)) {\n            return forExtension(NameUtils.extension(filename)).orElse(MediaType.TEXT_PLAIN_TYPE);\n        }\n        return MediaType.TEXT_PLAIN_TYPE;\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private static Map<String, String> getMediaTypeFileExtensions() {\n        Map<String, String> extensions = mediaTypeFileExtensions;\n        if (extensions == null) {\n            synchronized (MediaType.class) { // double check\n                extensions = mediaTypeFileExtensions;\n                if (extensions == null) {\n                    try {\n                        extensions = loadMimeTypes();\n                        mediaTypeFileExtensions = extensions;\n                    } catch (Exception e) {\n                        mediaTypeFileExtensions = Collections.emptyMap();\n                    }\n                }\n            }\n        }\n        return extensions;\n    }\n\n    private BigDecimal getOrConvertQualityParameterToBigDecimal(MediaType mt) {\n        BigDecimal bd;\n        try {\n            String q = mt.parameters.getOrDefault(Q_PARAMETER, null);\n            if (q == null) {\n                return QUALITY_RATING_NUMBER;\n            } else {\n                bd = new BigDecimal(q);\n            }\n            return bd;\n        } catch (NumberFormatException e) {\n            bd = QUALITY_RATING_NUMBER;\n            return bd;\n        }\n    }\n\n    @SuppressWarnings(\"MagicNumber\")\n    private static Map<String, String> loadMimeTypes() {\n        try (InputStream is = MediaType.class.getClassLoader().getResourceAsStream(MIME_TYPES_FILE_NAME)) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.US_ASCII));\n            Map<String, String> result = new LinkedHashMap<>(100);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                if (line.isEmpty() || line.charAt(0) == '#') {\n                    continue;\n                }\n                String formattedLine = line.trim().replaceAll(\"\\\\s{2,}\", \" \").replaceAll(\"\\\\s\", \"|\");\n                String[] tokens = formattedLine.split(\"\\\\|\");\n                for (int i = 1; i < tokens.length; i++) {\n                    String fileExtension = tokens[i].toLowerCase(Locale.ENGLISH);\n                    result.put(fileExtension, tokens[0]);\n                }\n            }\n            return result;\n        } catch (IOException ex) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Failed to load mime types for file extension detection!\");\n            }\n        }\n\n        return Collections.emptyMap();\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.cache.interceptor;\n\nimport io.micronaut.aop.InterceptPhase;\nimport io.micronaut.aop.MethodInterceptor;\nimport io.micronaut.aop.MethodInvocationContext;\nimport io.micronaut.cache.*;\nimport io.micronaut.cache.annotation.CacheConfig;\nimport io.micronaut.cache.annotation.CacheInvalidate;\nimport io.micronaut.cache.annotation.CachePut;\nimport io.micronaut.cache.annotation.Cacheable;\nimport io.micronaut.cache.exceptions.CacheSystemException;\nimport io.micronaut.context.BeanContext;\nimport io.micronaut.core.annotation.AnnotationValue;\nimport io.micronaut.core.async.annotation.SingleResult;\nimport io.micronaut.core.async.publisher.Publishers;\nimport io.micronaut.core.reflect.InstantiationUtils;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.core.type.MutableArgumentValue;\nimport io.micronaut.core.type.ReturnType;\nimport io.micronaut.core.util.ArrayUtils;\nimport io.micronaut.core.util.CollectionUtils;\nimport io.micronaut.core.util.StringUtils;\nimport io.micronaut.scheduling.TaskExecutors;\nimport io.reactivex.BackpressureStrategy;\nimport io.reactivex.Flowable;\nimport io.reactivex.Maybe;\nimport io.reactivex.Single;\nimport io.reactivex.functions.Function;\nimport org.reactivestreams.Publisher;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.function.BiConsumer;\n\n/**\n * <p>An AOP {@link MethodInterceptor} implementation for the Cache annotations {@link Cacheable},\n * {@link CachePut} and {@link CacheInvalidate}.</p>\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@Singleton\n\npublic class CacheInterceptor implements MethodInterceptor<Object, Object> {\n    /**\n     * The position on the interceptor in the chain.\n     */\n    public static final int POSITION = InterceptPhase.CACHE.getPosition();\n\n    private static final String MEMBER_CACHE_NAMES = \"cacheNames\";\n    private static final String MEMBER_ASYNC = \"async\";\n    private static final Logger LOG = LoggerFactory.getLogger(CacheInterceptor.class);\n    private static final String MEMBER_ATOMIC = \"atomic\";\n    private static final String MEMBER_PARAMETERS = \"parameters\";\n    private static final String MEMBER_ALL = \"all\";\n    private static final String MEMBER_KEY_GENERATOR = \"keyGenerator\";\n\n    private final CacheManager cacheManager;\n    private final Map<Class<? extends CacheKeyGenerator>, CacheKeyGenerator> keyGenerators = new ConcurrentHashMap<>();\n    private final BeanContext beanContext;\n    private final ExecutorService ioExecutor;\n    private final CacheErrorHandler errorHandler;\n    private final AsyncCacheErrorHandler asyncCacheErrorHandler;\n\n    /**\n     * Create Cache Interceptor with given arguments.\n     *\n     * @param cacheManager           The cache manager\n     * @param errorHandler           Cache error handler\n     * @param asyncCacheErrorHandler Async cache error handlers\n     * @param ioExecutor             The executor to create tasks\n     * @param beanContext            The bean context to allow DI\n     */\n    public CacheInterceptor(CacheManager cacheManager,\n                            CacheErrorHandler errorHandler,\n                            AsyncCacheErrorHandler asyncCacheErrorHandler,\n                            @Named(TaskExecutors.IO) ExecutorService ioExecutor,\n                            BeanContext beanContext) {\n        this.cacheManager = cacheManager;\n        this.errorHandler = errorHandler;\n        this.asyncCacheErrorHandler = asyncCacheErrorHandler;\n        this.beanContext = beanContext;\n        this.ioExecutor = ioExecutor;\n    }\n\n    @Override\n    public int getOrder() {\n        return POSITION;\n    }\n\n    @Override\n    public Object intercept(MethodInvocationContext<Object, Object> context) {\n        if (context.hasStereotype(CacheConfig.class)) {\n            ReturnType returnTypeObject = context.getReturnType();\n            Class returnType = returnTypeObject.getType();\n            if (CompletionStage.class.isAssignableFrom(returnType)) {\n                return interceptCompletableFuture(context, returnTypeObject, returnType);\n            } else if (Publishers.isConvertibleToPublisher(returnType)) {\n                return interceptPublisher(context, returnTypeObject, returnType);\n            } else {\n                return interceptSync(context, returnTypeObject, returnType);\n            }\n        } else {\n            return context.proceed();\n        }\n    }\n\n    /**\n     * Intercept the annotated method invocation with sync.\n     *\n     * @param context          Contains information about method invocation\n     * @param returnTypeObject The return type of the method in Micronaut\n     * @param returnType       The return type class\n     * @return The value from the cache\n     */\n    protected Object interceptSync(MethodInvocationContext context, ReturnType returnTypeObject, Class returnType) {\n        final ValueWrapper wrapper = new ValueWrapper();\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n\n        AnnotationValue<Cacheable> cacheConfig = cacheOperation.cacheable;\n        if (cacheConfig != null) {\n            CacheKeyGenerator defaultKeyGenerator = cacheOperation.defaultKeyGenerator;\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(defaultKeyGenerator, cacheConfig);\n            Object[] parameterValues = resolveParams(context, cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, parameterValues);\n            Argument returnArgument = returnTypeObject.asArgument();\n            if (cacheConfig.getRequiredValue(MEMBER_ATOMIC, Boolean.class)) {\n                SyncCache syncCache = cacheManager.getCache(cacheOperation.cacheableCacheName);\n\n                try {\n                    wrapper.value = syncCache.get(key, returnArgument, () -> {\n                        try {\n                            doProceed(context, wrapper);\n                            return wrapper.value;\n                        } catch (RuntimeException e) {\n                            throw new ValueSupplierException(key, e);\n                        }\n                    });\n                } catch (ValueSupplierException e) {\n                    throw e.getCause();\n                } catch (RuntimeException e) {\n                    errorHandler.handleLoadError(syncCache, key, e);\n                    throw e;\n                }\n            } else {\n                String[] cacheNames = resolveCacheNames(cacheOperation.defaultConfig, cacheConfig);\n                boolean cacheHit = false;\n                for (String cacheName : cacheNames) {\n                    SyncCache syncCache = cacheManager.getCache(cacheName);\n                    try {\n                        Optional optional = syncCache.get(key, returnArgument);\n                        if (optional.isPresent()) {\n                            if (LOG.isDebugEnabled()) {\n                                LOG.debug(\"Value found in cache [\" + cacheName + \"] for invocation: \" + context);\n                            }\n                            cacheHit = true;\n                            wrapper.value = optional.get();\n                            break;\n                        }\n                    } catch (RuntimeException e) {\n                        if (errorHandler.handleLoadError(syncCache, key, e)) {\n                            throw e;\n                        }\n                    }\n                }\n                if (!cacheHit) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value not found in cache for invocation: \" + context);\n                    }\n                    doProceed(context, wrapper);\n                    syncPut(cacheNames, key, wrapper.value);\n                }\n            }\n        } else {\n            if (!cacheOperation.hasWriteOperations()) {\n                return context.proceed();\n            } else {\n                doProceed(context, wrapper);\n            }\n        }\n\n        List<AnnotationValue<CachePut>> cachePuts = cacheOperation.putOperations;\n        if (cachePuts != null) {\n\n            for (AnnotationValue<CachePut> cachePut : cachePuts) {\n                boolean async = cachePut.get(MEMBER_ASYNC, Boolean.class, false);\n                if (async) {\n                    ioExecutor.submit(() ->\n                            processCachePut(context, wrapper, cachePut, cacheOperation)\n                    );\n                } else {\n                    processCachePut(context, wrapper, cachePut, cacheOperation);\n                }\n            }\n        }\n\n        List<AnnotationValue<CacheInvalidate>> cacheInvalidates = cacheOperation.invalidateOperations;\n        if (cacheInvalidates != null) {\n            for (AnnotationValue<CacheInvalidate> cacheInvalidate : cacheInvalidates) {\n                boolean async = cacheInvalidate.get(MEMBER_ASYNC, Boolean.class, false);\n                if (async) {\n                    ioExecutor.submit(() -> {\n                                try {\n                                    processCacheEvict(context, cacheInvalidate, cacheOperation, async);\n                                } catch (Exception e) {\n                                    throw new CacheSystemException(\"Cache invalidate operation failed: \" + e.getMessage(), e);\n                                }\n                            }\n                    );\n                } else {\n                    processCacheEvict(context, cacheInvalidate, cacheOperation, async);\n                }\n            }\n        }\n\n        return wrapper.optional ? Optional.ofNullable(wrapper.value) : wrapper.value;\n    }\n\n    /**\n     * Intercept the aync method invocation.\n     *\n     * @param context          Contains information about method invocation\n     * @param returnTypeObject The return type of the method in Micronaut\n     * @param returnType       The return type class\n     * @return The value from the cache\n     */\n    protected Object interceptCompletableFuture(MethodInvocationContext<Object, Object> context, ReturnType<?> returnTypeObject, Class returnType) {\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        CompletableFuture<Object> returnFuture;\n        if (cacheable != null) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n            CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n            Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, params);\n            CompletableFuture<Object> thisFuture = new CompletableFuture<>();\n            Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n            asyncCache.get(key, firstTypeVariable).whenComplete((BiConsumer<Optional<?>, Throwable>) (o, throwable) -> {\n                if (throwable == null && o.isPresent()) {\n                    // cache hit, return result\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                    }\n                    thisFuture.complete(o.get());\n                } else {\n                    // cache miss proceed with original future\n                    try {\n                        if (throwable != null) {\n                            if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                                thisFuture.completeExceptionally(throwable);\n                                return;\n                            }\n                        }\n                        CompletableFuture<?> completableFuture = (CompletableFuture) context.proceed();\n                        if (completableFuture == null) {\n                            thisFuture.complete(null);\n                        } else {\n                            completableFuture.whenComplete((BiConsumer<Object, Throwable>) (o1, t2) -> {\n                                if (t2 != null) {\n                                    thisFuture.completeExceptionally(t2);\n                                } else {\n                                    // new cacheable result, cache it\n                                    asyncCache.put(key, o1).whenComplete((aBoolean, throwable1) -> {\n                                        if (throwable1 == null) {\n                                            thisFuture.complete(o1);\n                                        } else {\n                                            thisFuture.completeExceptionally(throwable1);\n                                        }\n                                    });\n\n                                }\n                            });\n                        }\n                    } catch (RuntimeException e) {\n                        thisFuture.completeExceptionally(e);\n                    }\n                }\n            });\n            returnFuture = thisFuture;\n        } else {\n            returnFuture = (CompletableFuture<Object>) context.proceed();\n        }\n        if (cacheOperation.hasWriteOperations()) {\n            returnFuture = processFuturePutOperations(context, cacheOperation, returnFuture);\n        }\n        return returnFuture;\n    }\n\n    /**\n     * Saving inside the cache.\n     *\n     * @param context Contains information about method invocation\n     * @return The operations to cause the return value to be cached within the given cache name.\n     */\n    protected List<AnnotationValue<CachePut>> putOperations(MethodInvocationContext context) {\n        return context.getAnnotationValuesByType(CachePut.class);\n    }\n\n    /**\n     * Evict from the cache.\n     *\n     * @param context Extended version of {@link io.micronaut.aop.InvocationContext} for {@link MethodInterceptor} instances\n     * @return The operations to cause the eviction of the given caches\n     */\n    protected List<AnnotationValue<CacheInvalidate>> invalidateOperations(MethodInvocationContext context) {\n        return context.getAnnotationValuesByType(CacheInvalidate.class);\n    }\n\n    private Object interceptPublisher(MethodInvocationContext<Object, Object> context, ReturnType returnTypeObject, Class returnType) {\n        if (!Publishers.isSingle(returnType) && !context.isAnnotationPresent(SingleResult.class)) {\n            throw new CacheSystemException(\"Only Reactive types that emit a single result can currently be cached. Use either Single, Maybe or Mono for operations that cache.\");\n        }\n        CacheOperation cacheOperation = new CacheOperation(context, returnType);\n        AnnotationValue<Cacheable> cacheable = cacheOperation.cacheable;\n        if (cacheable != null) {\n\n            Publisher<Object> publisher = buildCacheablePublisher(context, returnTypeObject, cacheOperation, cacheable);\n            return Publishers.convertPublisher(publisher, returnType);\n        } else {\n            final List<AnnotationValue<CachePut>> putOperations = cacheOperation.putOperations;\n            if (CollectionUtils.isNotEmpty(putOperations)) {\n                final Publisher<Object> publisher = buildCachePutPublisher(context, cacheOperation, putOperations);\n                return Publishers.convertPublisher(publisher, returnType);\n            } else {\n                final List<AnnotationValue<CacheInvalidate>> invalidateOperations = cacheOperation.invalidateOperations;\n                if (CollectionUtils.isNotEmpty(invalidateOperations)) {\n                    final Publisher<Object> publisher = buildCacheInvalidatePublisher(context, cacheOperation, invalidateOperations);\n                    return Publishers.convertPublisher(publisher, returnType);\n                } else {\n                    return context.proceed();\n                }\n            }\n        }\n    }\n\n    private Publisher<Object> buildCacheInvalidatePublisher(\n            MethodInvocationContext<Object, Object> context,\n            CacheOperation cacheOperation,\n            List<AnnotationValue<CacheInvalidate>> invalidateOperations) {\n        final Flowable<Object> originalFlowable = Publishers.convertPublisher(context.proceed(), Flowable.class);\n\n        return originalFlowable.flatMap((o) -> {\n            List<Flowable<?>> cacheInvalidates = new ArrayList<>();\n            for (AnnotationValue<CacheInvalidate> invalidateOperation : invalidateOperations) {\n                String[] cacheNames = cacheOperation.getCacheInvalidateNames(invalidateOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean invalidateAll = invalidateOperation.getRequiredValue(MEMBER_ALL, Boolean.class);\n                    boolean isAsync = invalidateOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (isAsync) {\n                        if (invalidateAll) {\n                            for (String cacheName : cacheNames) {\n                                AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n                                asyncCache.invalidateAll().whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        asyncCacheErrorHandler.handleInvalidateError(asyncCache, asRuntimeException(throwable));\n                                    }\n                                }, ioExecutor);\n                            }\n                        } else {\n                            CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(invalidateOperation);\n                            String[] parameterNames = invalidateOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n                            Object[] parameterValues = resolveParams(context, parameterNames);\n                            Object key = keyGenerator.generateKey(context, parameterValues);\n                            for (String cacheName : cacheNames) {\n                                AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n                                asyncCache.invalidate(key).whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        asyncCacheErrorHandler.handleInvalidateError(asyncCache, asRuntimeException(throwable));\n                                    }\n                                }, ioExecutor);\n                            }\n                        }\n                    } else {\n\n                        final Flowable<Object> cacheInvalidateFlowable = Flowable.create(emitter -> {\n                            if (invalidateAll) {\n                                final CompletableFuture<Void> allFutures = buildInvalidateAllFutures(cacheNames);\n                                allFutures.whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                        if (asyncCacheErrorHandler.handleInvalidateError(cache, asRuntimeException(throwable))) {\n                                            emitter.onError(throwable);\n                                            return;\n                                        }\n                                        emitter.onNext(true);\n                                        emitter.onComplete();\n                                    } else {\n                                        emitter.onNext(o);\n                                        emitter.onComplete();\n                                    }\n                                }, ioExecutor);\n                            } else {\n                                CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(invalidateOperation);\n                                String[] parameterNames = invalidateOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n                                Object[] parameterValues = resolveParams(context, parameterNames);\n                                Object key = keyGenerator.generateKey(context, parameterValues);\n                                final CompletableFuture<Void> allFutures = buildInvalidateFutures(cacheNames, key);\n                                allFutures.whenCompleteAsync((aBoolean, throwable) -> {\n                                    if (throwable != null) {\n                                        SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                        if (asyncCacheErrorHandler.handleInvalidateError(cache, key, asRuntimeException(throwable))) {\n                                            emitter.onError(throwable);\n                                            return;\n                                        }\n                                    }\n                                    emitter.onNext(o);\n                                    emitter.onComplete();\n                                }, ioExecutor);\n                            }\n                        }, BackpressureStrategy.ERROR);\n                        cacheInvalidates.add(cacheInvalidateFlowable);\n                    }\n                }\n            }\n            if (!cacheInvalidates.isEmpty()) {\n                return Flowable.merge(cacheInvalidates).lastOrError().toFlowable();\n            } else {\n                return Flowable.just(o);\n            }\n        });\n    }\n\n    private Publisher<Object> buildCachePutPublisher(\n            MethodInvocationContext<Object, Object> context,\n            CacheOperation cacheOperation,\n            List<AnnotationValue<CachePut>> putOperations) {\n        final Flowable<?> originalFlowable = Publishers.convertPublisher(context.proceed(), Flowable.class);\n        return originalFlowable.flatMap((Function<Object, Publisher<?>>) o -> {\n            List<Flowable<?>> cachePuts = new ArrayList<>();\n            for (AnnotationValue<CachePut> putOperation : putOperations) {\n                String[] cacheNames = cacheOperation.getCachePutNames(putOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean isAsync = putOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (isAsync) {\n                        putResultAsync(context, cacheOperation, putOperation, cacheNames, o);\n                    } else {\n                        final Flowable<Object> cachePutFlowable = Flowable.create(emitter -> {\n                            CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n                            Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n                            Object key = keyGenerator.generateKey(context, parameterValues);\n                            CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, o, key);\n                            putOperationFuture.whenComplete((aVoid, throwable) -> {\n                                if (throwable == null) {\n                                    emitter.onNext(o);\n                                    emitter.onComplete();\n                                } else {\n                                    SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                    if (errorHandler.handlePutError(cache, key, o, asRuntimeException(throwable))) {\n                                        emitter.onError(throwable);\n                                    } else {\n                                        emitter.onNext(o);\n                                        emitter.onComplete();\n                                    }\n                                }\n                            });\n                        }, BackpressureStrategy.ERROR);\n                        cachePuts.add(cachePutFlowable);\n                    }\n                }\n            }\n\n            if (!cachePuts.isEmpty()) {\n                return Flowable.merge(cachePuts).lastOrError().toFlowable();\n            } else {\n                return Flowable.just(o);\n            }\n        });\n    }\n\n    private Publisher<Object> buildCacheablePublisher(\n            MethodInvocationContext<Object, Object> context,\n            ReturnType returnTypeObject,\n            CacheOperation cacheOperation,\n            AnnotationValue<Cacheable> cacheable) {\n        AsyncCache<?> asyncCache = cacheManager.getCache(cacheOperation.cacheableCacheName).async();\n        CacheKeyGenerator keyGenerator = resolveKeyGenerator(cacheOperation.defaultKeyGenerator, cacheable);\n        Object[] params = resolveParams(context, cacheable.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n        Object key = keyGenerator.generateKey(context, params);\n        Argument<?> firstTypeVariable = returnTypeObject.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);\n\n        Maybe<Object> maybe = Maybe.create(emitter -> {\n            asyncCache.get(key, firstTypeVariable).whenComplete((opt, throwable) -> {\n               if (throwable != null) {\n                   if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable))) {\n                       emitter.onError(throwable);\n                   } else {\n                       emitter.onComplete();\n                   }\n                   emitter.onError(throwable);\n               } else if (opt.isPresent()) {\n                   if (LOG.isDebugEnabled()) {\n                       LOG.debug(\"Value found in cache [\" + asyncCache.getName() + \"] for invocation: \" + context);\n                   }\n                   emitter.onSuccess(opt.get());\n               } else {\n                   emitter.onComplete();\n               }\n            });\n        });\n\n        return maybe.isEmpty().flatMapPublisher(empty -> {\n            if (empty) {\n               return Publishers.convertPublisher(\n                       context.proceed(), Flowable.class)\n                       .flatMap(o -> {\n                           return Single.create(emitter -> {\n                               asyncCache.put(key, o).whenComplete((aBoolean, throwable1) -> {\n                                   if (throwable1 == null) {\n                                       emitter.onSuccess(o);\n                                   } else {\n                                       if (errorHandler.handleLoadError(asyncCache, key, asRuntimeException(throwable1))) {\n\n                                           emitter.onError(throwable1);\n                                       } else {\n                                           emitter.onSuccess(o);\n                                       }\n                                   }\n                               });\n                           }).toFlowable();\n                       });\n            } else {\n                return maybe.toFlowable();\n            }\n        });\n    }\n\n    private CompletableFuture<Object> processFuturePutOperations(MethodInvocationContext<Object, Object> context, CacheOperation cacheOperation, CompletableFuture<Object> returnFuture) {\n        List<AnnotationValue<CachePut>> putOperations = cacheOperation.putOperations;\n        if (putOperations != null) {\n            for (AnnotationValue<CachePut> putOperation : putOperations) {\n                String[] cacheNames = cacheOperation.getCachePutNames(putOperation);\n\n                if (ArrayUtils.isNotEmpty(cacheNames)) {\n                    boolean isAsync = putOperation.get(MEMBER_ASYNC, Boolean.class, false);\n                    if (!isAsync) {\n                        CompletableFuture<Object> newFuture = new CompletableFuture<>();\n                        returnFuture.whenComplete((result, throwable) -> {\n                            if (throwable == null) {\n                                try {\n                                    CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n                                    Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n                                    Object key = keyGenerator.generateKey(context, parameterValues);\n                                    CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, result, key);\n\n                                    putOperationFuture.whenComplete((aVoid, error) -> {\n                                        if (error != null) {\n                                            SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                                            if (errorHandler.handlePutError(cache, key, result, asRuntimeException(error))) {\n                                                newFuture.completeExceptionally(error);\n                                            } else {\n                                                newFuture.complete(result);\n                                            }\n                                        } else {\n                                            newFuture.complete(result);\n                                        }\n                                    });\n                                } catch (Exception e) {\n                                    newFuture.completeExceptionally(e);\n                                }\n                            } else {\n                                newFuture.completeExceptionally(throwable);\n                            }\n                        });\n                        returnFuture = newFuture;\n                    } else {\n                        returnFuture.whenCompleteAsync((result, throwable) -> {\n                            if (throwable == null) {\n                                putResultAsync(context, cacheOperation, putOperation, cacheNames, result);\n                            }\n                        }, ioExecutor);\n                    }\n                }\n            }\n        }\n        return returnFuture;\n    }\n\n    private void putResultAsync(MethodInvocationContext<Object, Object> context, CacheOperation cacheOperation, AnnotationValue<CachePut> putOperation, String[] cacheNames, Object result) {\n        try {\n            CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(putOperation);\n            Object[] parameterValues = resolveParams(context, putOperation.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY));\n            Object key = keyGenerator.generateKey(context, parameterValues);\n            CompletableFuture<Void> putOperationFuture = buildPutFutures(cacheNames, result, key);\n\n            putOperationFuture.whenComplete((aVoid, error) -> {\n                if (error != null) {\n                    SyncCache cache = cacheManager.getCache(cacheNames[0]);\n                    asyncCacheErrorHandler.handlePutError(cache, key, result, asRuntimeException(error));\n                }\n            });\n        } catch (Exception e) {\n            if (LOG.isErrorEnabled()) {\n                LOG.error(\"Cache put operation failed: \" + e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Resolve the cache key generator from the give type.\n     *\n     * @param type The key generator\n     * @return The cache key generator\n     */\n    protected CacheKeyGenerator resolveKeyGenerator(Class<? extends CacheKeyGenerator> type) {\n        if (type == null) {\n            type = DefaultCacheKeyGenerator.class;\n        }\n\n        return keyGenerators.computeIfAbsent(type, aClass -> {\n            if (beanContext.containsBean(aClass)) {\n                return beanContext.getBean(aClass);\n            }\n            return InstantiationUtils.instantiate(aClass);\n        });\n    }\n\n    private CompletableFuture<Void> buildPutFutures(String[] cacheNames, Object result, Object key) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.put(key, result));\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CompletableFuture<Void> buildInvalidateFutures(String[] cacheNames, Object key) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.invalidate(key));\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CompletableFuture<Void> buildInvalidateAllFutures(String[] cacheNames) {\n        List<CompletableFuture<Boolean>> futures = new ArrayList<>();\n        for (String cacheName : cacheNames) {\n            AsyncCache<?> asyncCache = cacheManager.getCache(cacheName).async();\n            futures.add(asyncCache.invalidateAll());\n        }\n        CompletableFuture[] futureArray = futures.toArray(new CompletableFuture[0]);\n        return CompletableFuture.allOf(futureArray);\n    }\n\n    private CacheKeyGenerator resolveKeyGenerator(CacheKeyGenerator defaultKeyGenerator, AnnotationValue<Cacheable> cacheConfig) {\n        CacheKeyGenerator keyGenerator = defaultKeyGenerator;\n        final CacheKeyGenerator altKeyGenInstance = cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElse(null);\n        if (altKeyGenInstance != null) {\n            return altKeyGenInstance;\n        } else {\n            Class<? extends CacheKeyGenerator> alternateKeyGen = cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null);\n            if (alternateKeyGen != null && keyGenerator.getClass() != alternateKeyGen) {\n                keyGenerator = resolveKeyGenerator(alternateKeyGen);\n            }\n            if (keyGenerator == null) {\n                return new DefaultCacheKeyGenerator();\n            }\n            return keyGenerator;\n        }\n\n    }\n\n    private String[] resolveCacheNames(AnnotationValue<CacheConfig> defaultConfig, AnnotationValue<Cacheable> cacheConfig) {\n        String[] cacheNames = cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(null);\n        if (ArrayUtils.isEmpty(cacheNames)) {\n            cacheNames = defaultConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY);\n        }\n        return cacheNames;\n    }\n\n    private void doProceed(MethodInvocationContext context, ValueWrapper wrapper) {\n        Object result = context.proceed();\n        if (result instanceof Optional) {\n            Optional optional = (Optional) result;\n            wrapper.optional = true;\n            if (optional.isPresent()) {\n                wrapper.value = optional.get();\n            }\n        } else {\n            wrapper.value = result;\n        }\n    }\n\n    private void processCachePut(MethodInvocationContext<?, ?> context, ValueWrapper wrapper, AnnotationValue<CachePut> cacheConfig, CacheOperation cacheOperation) {\n        String[] cacheNames = cacheOperation.getCachePutNames(cacheConfig);\n        CacheKeyGenerator keyGenerator = cacheOperation.getCachePutKeyGenerator(cacheConfig);\n        String[] parameterNames = cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n        Object[] parameterValues = resolveParams(context, parameterNames);\n        boolean isAsync = cacheConfig.get(MEMBER_ASYNC, Boolean.class, false);\n\n\n        processCachePut(context, wrapper, cacheNames, keyGenerator, parameterValues, isAsync);\n    }\n\n    private void processCachePut(MethodInvocationContext<?, ?> context, ValueWrapper wrapper, String[] cacheNames, CacheKeyGenerator keyGenerator, Object[] parameterValues, boolean isAsync) {\n        if (!ArrayUtils.isEmpty(cacheNames)) {\n            Object v = wrapper.value;\n            if (isAsync) {\n                ioExecutor.submit(() -> {\n                    try {\n                        Object key = keyGenerator.generateKey(context, parameterValues);\n                        for (String cacheName : cacheNames) {\n                            SyncCache cache = cacheManager.getCache(cacheName);\n                            AsyncCache<?> asyncCache = cache.async();\n                            CompletableFuture<Boolean> putFuture = asyncCache.put(key, v);\n                            putFuture.whenCompleteAsync((aBoolean, throwable) -> {\n                                if (throwable != null) {\n                                    asyncCacheErrorHandler.handlePutError(cache, key, v, asRuntimeException(throwable));\n                                }\n                            }, ioExecutor);\n                        }\n                    } catch (Exception e) {\n                        throw new CacheSystemException(\"Cache put operation failed: \" + e.getMessage(), e);\n                    }\n                });\n            } else {\n                Object key = keyGenerator.generateKey(context, parameterValues);\n                syncPut(cacheNames, key, v);\n            }\n        }\n    }\n\n    private void syncPut(String[] cacheNames, Object key, Object value) {\n        for (String cacheName : cacheNames) {\n            SyncCache syncCache = cacheManager.getCache(cacheName);\n            try {\n                syncCache.put(key, value);\n            } catch (RuntimeException e) {\n                if (errorHandler.handlePutError(syncCache, key, value, e)) {\n                    throw e;\n                }\n            }\n        }\n    }\n\n    private void processCacheEvict(\n            MethodInvocationContext context,\n            AnnotationValue<CacheInvalidate> cacheConfig,\n            CacheOperation cacheOperation,\n            boolean async) {\n\n        String[] cacheNames = cacheOperation.getCacheInvalidateNames(cacheConfig);\n        CacheKeyGenerator keyGenerator = cacheOperation.getCacheInvalidateKeyGenerator(cacheConfig);\n        boolean invalidateAll = cacheConfig.getRequiredValue(MEMBER_ALL, Boolean.class);\n        Object key = null;\n        String[] parameterNames = cacheConfig.get(MEMBER_PARAMETERS, String[].class, StringUtils.EMPTY_STRING_ARRAY);\n        Object[] parameterValues = resolveParams(context, parameterNames);\n\n        if (!invalidateAll) {\n            key = keyGenerator.generateKey(context, parameterValues);\n        }\n\n        if (!ArrayUtils.isEmpty(cacheNames)) {\n            for (String cacheName : cacheNames) {\n                SyncCache syncCache = cacheManager.getCache(cacheName);\n                if (async) {\n                    AsyncCache<?> asyncCache = syncCache.async();\n                    if (invalidateAll) {\n                        CompletableFuture<Boolean> future = asyncCache.invalidateAll();\n                        future.whenCompleteAsync((aBoolean, throwable) -> {\n                            if (throwable != null) {\n                                asyncCacheErrorHandler.handleInvalidateError(syncCache, asRuntimeException(throwable));\n                            }\n                        }, ioExecutor);\n                    } else {\n                        Object finalKey = key;\n                        CompletableFuture<Boolean> future = asyncCache.invalidate(key);\n                        future.whenCompleteAsync((aBoolean, throwable) -> {\n                            if (throwable != null) {\n                                asyncCacheErrorHandler.handleInvalidateError(syncCache, finalKey, asRuntimeException(throwable));\n                            }\n                        }, ioExecutor);\n                    }\n                } else {\n                    if (invalidateAll) {\n                        try {\n                            syncCache.invalidateAll();\n                        } catch (RuntimeException e) {\n                            if (errorHandler.handleInvalidateError(syncCache, e)) {\n                                throw e;\n                            }\n                        }\n                    } else {\n                        try {\n                            syncCache.invalidate(key);\n                        } catch (RuntimeException e) {\n                            if (errorHandler.handleInvalidateError(syncCache, key, e)) {\n                                throw e;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private RuntimeException asRuntimeException(Throwable throwable) {\n        if (throwable instanceof RuntimeException) {\n            return (RuntimeException) throwable;\n        } else {\n            return new RuntimeException(throwable);\n        }\n    }\n\n    private Object[] resolveParams(MethodInvocationContext<?, ?> context, String[] parameterNames) {\n        Object[] parameterValues;\n        if (ArrayUtils.isEmpty(parameterNames)) {\n            parameterValues = context.getParameterValues();\n        } else {\n            List list = new ArrayList();\n            Map<String, MutableArgumentValue<?>> parameters = context.getParameters();\n            for (String name : parameterNames) {\n                list.add(parameters.get(name).getValue());\n            }\n            parameterValues = list.toArray();\n        }\n        return parameterValues;\n    }\n\n    /**\n     *\n     */\n    private class CacheOperation {\n        final Class returnType;\n        final MethodInvocationContext<?, ?> context;\n        final CacheKeyGenerator defaultKeyGenerator;\n        final AnnotationValue<CacheConfig> defaultConfig;\n        String cacheableCacheName;\n        AnnotationValue<Cacheable> cacheable;\n        List<AnnotationValue<CachePut>> putOperations;\n        List<AnnotationValue<CacheInvalidate>> invalidateOperations;\n\n        CacheOperation(MethodInvocationContext<?, ?> context, Class returnType) {\n            this.context = context;\n            this.returnType = returnType;\n\n            this.defaultConfig = context.getAnnotation(CacheConfig.class);\n            this.defaultKeyGenerator = resolveKeyGenerator(defaultConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null));\n            boolean isVoid = isVoid();\n            this.putOperations = isVoid ? null : putOperations(context);\n            this.invalidateOperations = invalidateOperations(context);\n            if (!isVoid && context.hasStereotype(Cacheable.class)) {\n                AnnotationValue<Cacheable> cacheable = context.getAnnotation(Cacheable.class);\n                String[] names = resolveCacheNames(defaultConfig, cacheable);\n                if (ArrayUtils.isNotEmpty(names)) {\n                    this.cacheableCacheName = names[0];\n                    this.cacheable = cacheable;\n                }\n            }\n        }\n\n        boolean hasWriteOperations() {\n            return putOperations != null || invalidateOperations != null;\n        }\n\n        boolean isVoid() {\n            return void.class == returnType;\n        }\n\n        String[] getCachePutNames(AnnotationValue<CachePut> cacheConfig) {\n            return getCacheNames(cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY));\n        }\n\n        String[] getCacheInvalidateNames(AnnotationValue<CacheInvalidate> cacheConfig) {\n            return getCacheNames(cacheConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY));\n        }\n\n        CacheKeyGenerator getCacheInvalidateKeyGenerator(AnnotationValue<CacheInvalidate> cacheConfig) {\n            return cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElseGet(() ->\n                getKeyGenerator(cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null))\n            );\n        }\n\n        CacheKeyGenerator getCachePutKeyGenerator(AnnotationValue<CachePut> cacheConfig) {\n            return cacheConfig.get(MEMBER_KEY_GENERATOR, CacheKeyGenerator.class).orElseGet(() ->\n                getKeyGenerator(cacheConfig.get(MEMBER_KEY_GENERATOR, Class.class).orElse(null))\n            );\n        }\n\n        private String[] getCacheNames(String[] cacheNames) {\n            if (ArrayUtils.isEmpty(cacheNames)) {\n                return defaultConfig.get(MEMBER_CACHE_NAMES, String[].class).orElse(StringUtils.EMPTY_STRING_ARRAY);\n            } else {\n                return cacheNames;\n            }\n        }\n\n        private CacheKeyGenerator getKeyGenerator(Class<? extends CacheKeyGenerator> alternateKeyGen) {\n            CacheKeyGenerator keyGenerator = defaultKeyGenerator;\n            if (alternateKeyGen != null && defaultKeyGenerator.getClass() != alternateKeyGen) {\n                keyGenerator = resolveKeyGenerator(alternateKeyGen);\n            }\n            return keyGenerator;\n        }\n    }\n\n    /**\n     * The value wrapper.\n     */\n    private class ValueWrapper {\n        Object value;\n        boolean optional;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.scheduling.io.watch;\n\nimport io.micronaut.context.ApplicationContext;\nimport io.micronaut.context.BeanContext;\nimport io.micronaut.context.condition.Condition;\nimport io.micronaut.context.condition.ConditionContext;\nimport io.micronaut.core.annotation.Introspected;\nimport io.micronaut.core.convert.ConversionContext;\nimport io.micronaut.core.util.CollectionUtils;\n\nimport java.io.File;\nimport java.util.List;\n\n/**\n * Custom condition to only enable file watch if the watch paths exist.\n *\n * @author graemerocher\n * @since 1.2.0\n */\n@Introspected\npublic class FileWatchCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context) {\n        BeanContext beanContext = context.getBeanContext();\n        if (beanContext instanceof ApplicationContext) {\n            List<String> paths = ((ApplicationContext) beanContext)\n                    .getEnvironment()\n                    .getProperty(FileWatchConfiguration.PATHS, ConversionContext.LIST_OF_STRING)\n                    .orElse(null);\n\n            if (CollectionUtils.isNotEmpty(paths)) {\n\n\n                boolean matchedPaths = paths.stream().anyMatch(p -> new File(p).exists());\n                if (!matchedPaths) {\n                    context.fail(\"File watch disabled because no paths matching the watch pattern exist (Paths: \" + paths + \")\");\n                }\n                return matchedPaths;\n            }\n        }\n\n        context.fail(\"File watch disabled because no watch paths specified\");\n        return false;\n    }\n}\n", "/*\n * Copyright 2017-2019 original authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.micronaut.session.binder;\n\nimport io.micronaut.context.annotation.Requires;\nimport io.micronaut.core.bind.ArgumentBinder;\nimport io.micronaut.core.convert.ArgumentConversionContext;\nimport io.micronaut.core.convert.value.MutableConvertibleValues;\nimport io.micronaut.core.type.Argument;\nimport io.micronaut.http.HttpRequest;\nimport io.micronaut.http.filter.OncePerRequestHttpServerFilter;\nimport io.micronaut.http.server.HttpServerConfiguration;\nimport io.micronaut.http.bind.binders.TypedRequestArgumentBinder;\nimport io.micronaut.session.Session;\nimport io.micronaut.session.SessionStore;\nimport io.micronaut.session.http.HttpSessionFilter;\n\nimport javax.inject.Singleton;\nimport java.util.Optional;\n\n/**\n * Binds an argument of type {@link Session} for controllers.\n *\n * @author Graeme Rocher\n * @since 1.0\n */\n@SuppressWarnings(\"unused\")\n@Singleton\n@Requires(classes = HttpServerConfiguration.class)\npublic class SessionArgumentBinder implements TypedRequestArgumentBinder<Session> {\n\n    private static final Argument<Session> TYPE = Argument.of(Session.class);\n\n    private final SessionStore<Session> sessionStore;\n\n    /**\n     * Constructor.\n     *\n     * @param sessionStore The session store\n     */\n    public SessionArgumentBinder(SessionStore<Session> sessionStore) {\n        this.sessionStore = sessionStore;\n    }\n\n    @Override\n    public Argument<Session> argumentType() {\n        return TYPE;\n    }\n\n    @Override\n    public ArgumentBinder.BindingResult<Session> bind(ArgumentConversionContext<Session> context, HttpRequest<?> source) {\n        if (!source.getAttributes().contains(OncePerRequestHttpServerFilter.getKey(HttpSessionFilter.class))) {\n            // the filter hasn't been executed\n            //noinspection unchecked\n            return ArgumentBinder.BindingResult.EMPTY;\n        }\n\n        MutableConvertibleValues<Object> attrs = source.getAttributes();\n        Optional<Session> existing = attrs.get(HttpSessionFilter.SESSION_ATTRIBUTE, Session.class);\n        if (existing.isPresent()) {\n            return () -> existing;\n        } else {\n            // create a new session store it in the attribute\n            if (!context.getArgument().isNullable()) {\n                Session newSession = sessionStore.newSession();\n                attrs.put(HttpSessionFilter.SESSION_ATTRIBUTE, newSession);\n                return () -> Optional.of(newSession);\n            } else {\n                //noinspection unchecked\n                return BindingResult.EMPTY;\n            }\n        }\n    }\n}\n"], "filenames": ["core/src/main/java/io/micronaut/core/convert/ConversionContext.java", "core/src/main/java/io/micronaut/core/convert/DefaultArgumentConversionContext.java", "core/src/main/java/io/micronaut/core/convert/value/ConvertibleMultiValues.java", "core/src/main/java/io/micronaut/core/convert/value/ConvertibleValues.java", "core/src/main/java/io/micronaut/core/type/Argument.java", "core/src/main/java/io/micronaut/core/type/DefaultArgument.java", "http-client/src/main/java/io/micronaut/http/client/exceptions/HttpClientErrorDecoder.java", "http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java", "http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/CompletableFutureBodyBinder.java", "http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/PublisherBodyBinder.java", "http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy", "http-server/src/main/java/io/micronaut/http/server/cors/CorsFilter.java", "http-server/src/main/java/io/micronaut/http/server/cors/CorsOriginConverter.java", "http/src/main/java/io/micronaut/http/HttpHeaders.java", "http/src/main/java/io/micronaut/http/MediaType.java", "runtime/src/main/java/io/micronaut/cache/interceptor/CacheInterceptor.java", "runtime/src/main/java/io/micronaut/scheduling/io/watch/FileWatchCondition.java", "session/src/main/java/io/micronaut/session/binder/SessionArgumentBinder.java"], "buggy_code_start_loc": [44, 22, 17, 73, 43, 50, 74, 143, 51, 56, 17, 29, 17, 17, 17, 262, 23, 44], "buggy_code_end_loc": [44, 117, 175, 74, 108, 188, 75, 788, 69, 75, 310, 161, 75, 524, 319, 507, 44, 59], "fixing_code_start_loc": [45, 22, 18, 73, 44, 50, 74, 144, 52, 57, 18, 30, 18, 18, 18, 262, 23, 45], "fixing_code_end_loc": [70, 131, 193, 74, 119, 184, 75, 789, 71, 76, 311, 164, 79, 525, 330, 507, 44, 61], "type": "CWE-400", "message": "Micronaut is a JVM-based, full stack Java framework designed for building JVM web applications with support for Java, Kotlin and the Groovy language. In affected versions sending an invalid Content Type header leads to memory leak in DefaultArgumentConversionContext as this type is erroneously used in static state. ### Impact Sending an invalid Content Type header leads to memory leak in `DefaultArgumentConversionContext` as this type is erroneously used in static state. ### Patches The problem is patched in Micronaut 3.2.7 and above. ### Workarounds The default content type binder can be replaced in an existing Micronaut application to mitigate the issue: ```java package example; import java.util.List; import io.micronaut.context.annotation.Replaces; import io.micronaut.core.convert.ConversionService; import io.micronaut.http.MediaType; import io.micronaut.http.bind.DefaultRequestBinderRegistry; import io.micronaut.http.bind.binders.RequestArgumentBinder; import jakarta.inject.Singleton; @Singleton @Replaces(DefaultRequestBinderRegistry.class) class FixedRequestBinderRegistry extends DefaultRequestBinderRegistry { public FixedRequestBinderRegistry(ConversionService conversionService, List<RequestArgumentBinder> binders) { super(conversionService, binders); } @Override protected void registerDefaultConverters(ConversionService<?> conversionService) { super.registerDefaultConverters(conversionService); conversionService.addConverter(CharSequence.class, MediaType.class, charSequence -> { try { return MediaType.of(charSequence); } catch (IllegalArgumentException e) { return null; } }); } } ``` ### References Commit that introduced the vulnerability https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3 ### For more information If you have any questions or comments about this advisory: * Open an issue in [Micronaut Core](https://github.com/micronaut-projects/micronaut-core/issues) * Email us at [info@micronaut.io](mailto:info@micronaut.io)", "other": {"cve": {"id": "CVE-2022-21700", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-18T23:15:08.840", "lastModified": "2022-01-26T14:35:47.580", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Micronaut is a JVM-based, full stack Java framework designed for building JVM web applications with support for Java, Kotlin and the Groovy language. In affected versions sending an invalid Content Type header leads to memory leak in DefaultArgumentConversionContext as this type is erroneously used in static state. ### Impact Sending an invalid Content Type header leads to memory leak in `DefaultArgumentConversionContext` as this type is erroneously used in static state. ### Patches The problem is patched in Micronaut 3.2.7 and above. ### Workarounds The default content type binder can be replaced in an existing Micronaut application to mitigate the issue: ```java package example; import java.util.List; import io.micronaut.context.annotation.Replaces; import io.micronaut.core.convert.ConversionService; import io.micronaut.http.MediaType; import io.micronaut.http.bind.DefaultRequestBinderRegistry; import io.micronaut.http.bind.binders.RequestArgumentBinder; import jakarta.inject.Singleton; @Singleton @Replaces(DefaultRequestBinderRegistry.class) class FixedRequestBinderRegistry extends DefaultRequestBinderRegistry { public FixedRequestBinderRegistry(ConversionService conversionService, List<RequestArgumentBinder> binders) { super(conversionService, binders); } @Override protected void registerDefaultConverters(ConversionService<?> conversionService) { super.registerDefaultConverters(conversionService); conversionService.addConverter(CharSequence.class, MediaType.class, charSequence -> { try { return MediaType.of(charSequence); } catch (IllegalArgumentException e) { return null; } }); } } ``` ### References Commit that introduced the vulnerability https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3 ### For more information If you have any questions or comments about this advisory: * Open an issue in [Micronaut Core](https://github.com/micronaut-projects/micronaut-core/issues) * Email us at [info@micronaut.io](mailto:info@micronaut.io)"}, {"lang": "es", "value": "Micronaut es un marco de trabajo Java de pila completa basado en JVM dise\u00f1ado para construir aplicaciones web JVM con soporte para Java, Kotlin y el lenguaje Groovy. En las versiones afectadas, el env\u00edo de un encabezado Content Type no v\u00e1lida conlleva a una p\u00e9rdida de memoria en DefaultArgumentConversionContext, ya que este tipo es usada err\u00f3neamente en el estado est\u00e1tico. ### Impacto El env\u00edo de un encabezado Content Type no v\u00e1lida conlleva a una p\u00e9rdida de memoria en \"DefaultArgumentConversionContext\" ya que este tipo es usado err\u00f3neamente en estado est\u00e1tico. ### Parches El problema est\u00e1 parcheado en Micronaut versiones 3.2.7 y posteriores. ### Medidas de mitigaci\u00f3n El aglutinante de tipo de contenido por defecto puede ser reemplazado en una aplicaci\u00f3n Micronaut existente para mitigar el problema: \"\"\"java package example; import java.util.List; import io.micronaut.context.annotation.Replaces; import io.micronaut.core.convert.ConversionService; import io.micronaut.http.MediaType; import io.micronaut.http.bind.DefaultRequestBinderRegistry; import io. micronaut.http.bind.binders.RequestArgumentBinder; import jakarta.inject.Singleton; @Singleton @Replaces(DefaultRequestBinderRegistry.class) class FixedRequestBinderRegistry extends DefaultRequestBinderRegistry { public FixedRequestBinderRegistry(ConversionService conversionService, List(RequestArgumentBinder) binders) { super(conversionService, binders); } @Override protected void registerDefaultConverters(ConversionService(?) conversionService) { super.registerDefaultConverters(conversionService); conversionService.addConverter(CharSequence.class, MediaType.class, charSequence -) { try { return MediaType.of(charSequence); } catch (IllegalArgumentException e) { return null; } }); } } ``` ### Referencias Compromiso que introdujo la vulnerabilidad https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3 ### Para m\u00e1s informaci\u00f3n Si presenta alguna pregunta o comentario sobre este aviso: * Abra una incidencia en [Micronaut Core](https://github.com/micronaut-projects/micronaut-core/issues) * Env\u00edenos un correo electr\u00f3nico a [info@micronaut.io](mailto:info@micronaut.io)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:objectcomputing:micronaut:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.7", "matchCriteriaId": "F97F98AD-F97C-4B79-961B-EA4076A2F6CD"}]}]}], "references": [{"url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/micronaut-projects/micronaut-core/security/advisories/GHSA-2457-2263-mm9f", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/micronaut-projects/micronaut-core/commit/b8ec32c311689667c69ae7d9f9c3b3a8abc96fe3"}}