{"buggy_code": ["#include \"rar.hpp\"\n\nsize_t Archive::ReadHeader()\n{\n  // Once we failed to decrypt an encrypted block, there is no reason to\n  // attempt to do it further. We'll never be successful and only generate\n  // endless errors.\n  if (FailedHeaderDecryption)\n    return 0;\n\n  CurBlockPos=Tell();\n\n  // Other developers asked us to initialize it to suppress \"may be used\n  // uninitialized\" warning in code below in some compilers.\n  size_t ReadSize=0;\n\n  switch(Format)\n  {\n#ifndef SFX_MODULE\n    case RARFMT14:\n      ReadSize=ReadHeader14();\n      break;\n#endif\n    case RARFMT15:\n      ReadSize=ReadHeader15();\n      break;\n    case RARFMT50:\n      ReadSize=ReadHeader50();\n      break;\n  }\n\n  // It is important to check ReadSize>0 here, because it is normal\n  // for RAR2 and RAR3 archives without end of archive block to have\n  // NextBlockPos==CurBlockPos after the end of archive has reached.\n  if (ReadSize>0 && NextBlockPos<=CurBlockPos)\n  {\n    BrokenHeaderMsg();\n    ReadSize=0;\n  }\n\n  if (ReadSize==0)\n    CurHeaderType=HEAD_UNKNOWN;\n\n  return ReadSize;\n}\n\n\nsize_t Archive::SearchBlock(HEADER_TYPE HeaderType)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 &&\n         (HeaderType==HEAD_ENDARC || GetHeaderType()!=HEAD_ENDARC))\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HeaderType)\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchSubBlock(const wchar *Type)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 && GetHeaderType()!=HEAD_ENDARC)\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(Type))\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchRR()\n{\n  // If locator extra field is available for recovery record, let's utilize it.\n  if (MainHead.Locator && MainHead.RROffset!=0)\n  {\n    uint64 CurPos=Tell();\n    Seek(MainHead.RROffset,SEEK_SET);\n    size_t Size=ReadHeader();\n    if (Size!=0 && !BrokenHeader && GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(SUBHEAD_TYPE_RR))\n      return Size;\n    Seek(CurPos,SEEK_SET);\n  }\n  // Otherwise scan the entire archive to find the recovery record.\n  return SearchSubBlock(SUBHEAD_TYPE_RR);\n}\n\n\nvoid Archive::UnexpEndArcMsg()\n{\n  int64 ArcSize=FileLength();\n\n  // If block positions are equal to file size, this is not an error.\n  // It can happen when we reached the end of older RAR 1.5 archive,\n  // which did not have the end of archive block.\n  // We can't replace this check by checking that read size is exactly 0\n  // in the beginning of file header, because in this case the read position\n  // still can be beyond the end of archive.\n  if (CurBlockPos!=ArcSize || NextBlockPos!=ArcSize)\n  {\n    uiMsg(UIERROR_UNEXPEOF,FileName);\n    ErrHandler.SetErrorCode(RARX_WARNING);\n  }\n}\n\n\nvoid Archive::BrokenHeaderMsg()\n{\n  uiMsg(UIERROR_HEADERBROKEN,FileName);\n  BrokenHeader=true;\n  ErrHandler.SetErrorCode(RARX_CRC);\n}\n\n\nvoid Archive::UnkEncVerMsg(const wchar *Name,const wchar *Info)\n{\n  uiMsg(UIERROR_UNKNOWNENCMETHOD,FileName,Name,Info);\n  ErrHandler.SetErrorCode(RARX_WARNING);\n}\n\n\n// Return f in case of signed integer overflow or negative parameters\n// or v1+v2 otherwise. We use it for file offsets, which are signed\n// for compatibility with off_t in POSIX file functions and third party code.\n// Signed integer overflow is the undefined behavior according to\n// C++ standard and it causes fuzzers to complain.\ninline int64 SafeAdd(int64 v1,int64 v2,int64 f)\n{\n  return v1>=0 && v2>=0 && v1<=MAX_INT64-v2 ? v1+v2 : f;\n}\n\n\nsize_t Archive::ReadHeader15()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD3;\n\n  if (Decrypt)\n  {\n#ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.\n    return 0;\n#else\n    RequestArcPassword(NULL);\n\n    byte Salt[SIZE_SALT30];\n    if (Read(Salt,SIZE_SALT30)!=SIZE_SALT30)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n    HeadersCrypt.SetCryptKeys(false,CRYPT_RAR30,&Cmd->Password,Salt,NULL,0,NULL,NULL);\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  Raw.Read(SIZEOF_SHORTBLOCKHEAD);\n  if (Raw.Size()==0)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.HeadCRC=Raw.Get2();\n\n  ShortBlock.Reset();\n\n  uint HeaderType=Raw.Get1();\n  ShortBlock.Flags=Raw.Get2();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & SKIP_IF_UNKNOWN)!=0;\n  ShortBlock.HeadSize=Raw.Get2();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)HeaderType;\n  if (ShortBlock.HeadSize<SIZEOF_SHORTBLOCKHEAD)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  // For simpler further processing we map header types common\n  // for RAR 1.5 and 5.0 formats to RAR 5.0 values. It does not include\n  // header types specific for RAR 1.5 - 4.x only.\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD3_MAIN:    ShortBlock.HeaderType=HEAD_MAIN;     break;\n    case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;\n    case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;\n    case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;\n  }\n  CurHeaderType=ShortBlock.HeaderType;\n\n  if (ShortBlock.HeaderType==HEAD3_CMT)\n  {\n    // Old style (up to RAR 2.9) comment header embedded into main\n    // or file header. We must not read the entire ShortBlock.HeadSize here\n    // to not break the comment processing logic later.\n    Raw.Read(SIZEOF_COMMHEAD-SIZEOF_SHORTBLOCKHEAD);\n  }\n  else\n    if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)\n    {\n      // Old style (up to RAR 2.9) main archive comment embedded into\n      // the main archive header found. While we can read the entire\n      // ShortBlock.HeadSize here and remove this part of \"if\", it would be\n      // waste of memory, because we'll read and process this comment data\n      // in other function anyway and we do not need them here now.\n      Raw.Read(SIZEOF_MAINHEAD3-SIZEOF_SHORTBLOCKHEAD);\n    }\n    else\n      Raw.Read(ShortBlock.HeadSize-SIZEOF_SHORTBLOCKHEAD);\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_MAIN:\n      MainHead.Reset();\n      *(BaseBlock *)&MainHead=ShortBlock;\n      MainHead.HighPosAV=Raw.Get2();\n      MainHead.PosAV=Raw.Get4();\n\n      Volume=(MainHead.Flags & MHD_VOLUME)!=0;\n      Solid=(MainHead.Flags & MHD_SOLID)!=0;\n      Locked=(MainHead.Flags & MHD_LOCK)!=0;\n      Protected=(MainHead.Flags & MHD_PROTECT)!=0;\n      Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;\n      Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;\n      MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;\n\n      // Only for encrypted 3.0+ archives. 2.x archives did not have this\n      // flag, so for non-encrypted archives, we'll set it later based on\n      // file attributes.\n      FirstVolume=(MainHead.Flags & MHD_FIRSTVOLUME)!=0;\n\n      NewNumbering=(MainHead.Flags & MHD_NEWNUMBERING)!=0;\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n        FileHeader *hd=FileBlock ? &FileHead:&SubHead;\n        hd->Reset();\n\n        *(BaseBlock *)hd=ShortBlock;\n\n        hd->SplitBefore=(hd->Flags & LHD_SPLIT_BEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & LHD_SPLIT_AFTER)!=0;\n        hd->Encrypted=(hd->Flags & LHD_PASSWORD)!=0;\n        hd->SaltSet=(hd->Flags & LHD_SALT)!=0;\n        hd->Solid=FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->SubBlock=!FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->Dir=(hd->Flags & LHD_WINDOWMASK)==LHD_DIRECTORY;\n        hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);\n        hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;\n        hd->Version=(hd->Flags & LHD_VERSION)!=0;\n\n        hd->DataSize=Raw.Get4();\n        uint LowUnpSize=Raw.Get4();\n        hd->HostOS=Raw.Get1();\n\n        hd->FileHash.Type=HASH_CRC32;\n        hd->FileHash.CRC32=Raw.Get4();\n\n        uint FileTime=Raw.Get4();\n        hd->UnpVer=Raw.Get1();\n\n        hd->Method=Raw.Get1()-0x30;\n        size_t NameSize=Raw.Get2();\n        hd->FileAttr=Raw.Get4();\n\n        // RAR15 did not use the special dictionary size to mark dirs.\n        if (hd->UnpVer<20 && (hd->FileAttr & 0x10)!=0)\n          hd->Dir=true;\n\n        hd->CryptMethod=CRYPT_NONE;\n        if (hd->Encrypted)\n          switch(hd->UnpVer)\n          {\n            case 13: hd->CryptMethod=CRYPT_RAR13; break;\n            case 15: hd->CryptMethod=CRYPT_RAR15; break;\n            case 20:\n            case 26: hd->CryptMethod=CRYPT_RAR20; break;\n            default: hd->CryptMethod=CRYPT_RAR30; break;\n          }\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST_UNIX || hd->HostOS==HOST_BEOS)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS<HOST_MAX)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->RedirType=FSREDIR_NONE;\n\n        // RAR 4.x Unix symlink.\n        if (hd->HostOS==HOST_UNIX && (hd->FileAttr & 0xF000)==0xA000)\n        {\n          hd->RedirType=FSREDIR_UNIXSYMLINK;\n          *hd->RedirName=0;\n        }\n\n        hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;\n\n        hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;\n\n        uint HighPackSize,HighUnpSize;\n        if (hd->LargeFile)\n        {\n          HighPackSize=Raw.Get4();\n          HighUnpSize=Raw.Get4();\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);\n        }\n        else\n        {\n          HighPackSize=HighUnpSize=0;\n          // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates\n          // that we do not know the unpacked file size and must unpack it\n          // until we find the end of file marker in compressed data.\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff);\n        }\n        hd->PackSize=INT32TO64(HighPackSize,hd->DataSize);\n        hd->UnpSize=INT32TO64(HighUnpSize,LowUnpSize);\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        if (FileBlock)\n        {\n          *hd->FileName=0;\n          if ((hd->Flags & LHD_UNICODE)!=0)\n          {\n            EncodeFileName NameCoder;\n            size_t Length=strlen(FileName);\n            Length++;\n            if (ReadNameSize>Length)\n              NameCoder.Decode(FileName,ReadNameSize,(byte *)FileName+Length,\n                               ReadNameSize-Length,hd->FileName,\n                               ASIZE(hd->FileName));\n          }\n\n          if (*hd->FileName==0)\n            ArcCharToWide(FileName,hd->FileName,ASIZE(hd->FileName),ACTW_OEM);\n\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n        else\n        {\n          CharToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n          // Calculate the size of optional data.\n          int DataSize=int(hd->HeadSize-NameSize-SIZEOF_FILEHEAD3);\n          if ((hd->Flags & LHD_SALT)!=0)\n            DataSize-=SIZE_SALT30;\n\n          if (DataSize>0)\n          {\n            // Here we read optional additional fields for subheaders.\n            // They are stored after the file name and before salt.\n            hd->SubData.Alloc(DataSize);\n            Raw.GetB(&hd->SubData[0],DataSize);\n\n          }\n\n          if (hd->CmpName(SUBHEAD_TYPE_CMT))\n            MainComment=true;\n        }\n        if ((hd->Flags & LHD_SALT)!=0)\n          Raw.GetB(hd->Salt,SIZE_SALT30);\n        hd->mtime.SetDos(FileTime);\n        if ((hd->Flags & LHD_EXTTIME)!=0)\n        {\n          ushort Flags=Raw.Get2();\n          RarTime *tbl[4];\n          tbl[0]=&FileHead.mtime;\n          tbl[1]=&FileHead.ctime;\n          tbl[2]=&FileHead.atime;\n          tbl[3]=NULL; // Archive time is not used now.\n          for (int I=0;I<4;I++)\n          {\n            RarTime *CurTime=tbl[I];\n            uint rmode=Flags>>(3-I)*4;\n            if ((rmode & 8)==0 || CurTime==NULL)\n              continue;\n            if (I!=0)\n            {\n              uint DosTime=Raw.Get4();\n              CurTime->SetDos(DosTime);\n            }\n            RarLocalTime rlt;\n            CurTime->GetLocal(&rlt);\n            if (rmode & 4)\n              rlt.Second++;\n            rlt.Reminder=0;\n            uint count=rmode&3;\n            for (uint J=0;J<count;J++)\n            {\n              byte CurByte=Raw.Get1();\n              rlt.Reminder|=(((uint)CurByte)<<((J+3-count)*8));\n            }\n            // Convert from 100ns RAR precision to REMINDER_PRECISION.\n            rlt.Reminder*=RarTime::REMINDER_PRECISION/10000000;\n            CurTime->SetLocal(&rlt);\n          }\n        }\n        // Set to 0 in case of overflow, so end of ReadHeader cares about it.\n        NextBlockPos=SafeAdd(NextBlockPos,hd->PackSize,0);\n\n        bool CRCProcessedOnly=hd->CommentInHeader;\n        ushort HeaderCRC=Raw.GetCRC15(CRCProcessedOnly);\n        if (hd->HeadCRC!=HeaderCRC)\n        {\n          BrokenHeader=true;\n          ErrHandler.SetErrorCode(RARX_WARNING);\n\n          // If we have a broken encrypted header, we do not need to display\n          // the error message here, because it will be displayed for such\n          // headers later in this function. Also such headers are unlikely\n          // to have anything sensible in file name field, so it is useless\n          // to display the file name.\n          if (!Decrypt)\n            uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n        }\n      }\n      break;\n    case HEAD_ENDARC:\n      *(BaseBlock *)&EndArcHead=ShortBlock;\n      EndArcHead.NextVolume=(EndArcHead.Flags & EARC_NEXT_VOLUME)!=0;\n      EndArcHead.DataCRC=(EndArcHead.Flags & EARC_DATACRC)!=0;\n      EndArcHead.RevSpace=(EndArcHead.Flags & EARC_REVSPACE)!=0;\n      EndArcHead.StoreVolNumber=(EndArcHead.Flags & EARC_VOLNUMBER)!=0;\n      if (EndArcHead.DataCRC)\n        EndArcHead.ArcDataCRC=Raw.Get4();\n      if (EndArcHead.StoreVolNumber)\n        VolNumber=EndArcHead.VolNumber=Raw.Get2();\n      break;\n#ifndef SFX_MODULE\n    case HEAD3_CMT:\n      *(BaseBlock *)&CommHead=ShortBlock;\n      CommHead.UnpSize=Raw.Get2();\n      CommHead.UnpVer=Raw.Get1();\n      CommHead.Method=Raw.Get1();\n      CommHead.CommCRC=Raw.Get2();\n      break;\n    case HEAD3_PROTECT:\n      *(BaseBlock *)&ProtectHead=ShortBlock;\n      ProtectHead.DataSize=Raw.Get4();\n      ProtectHead.Version=Raw.Get1();\n      ProtectHead.RecSectors=Raw.Get2();\n      ProtectHead.TotalBlocks=Raw.Get4();\n      Raw.GetB(ProtectHead.Mark,8);\n      NextBlockPos+=ProtectHead.DataSize;\n      break;\n    case HEAD3_OLDSERVICE: // RAR 2.9 and earlier.\n      *(BaseBlock *)&SubBlockHead=ShortBlock;\n      SubBlockHead.DataSize=Raw.Get4();\n      NextBlockPos+=SubBlockHead.DataSize;\n      SubBlockHead.SubType=Raw.Get2();\n      SubBlockHead.Level=Raw.Get1();\n      switch(SubBlockHead.SubType)\n      {\n        case UO_HEAD:\n          *(SubBlockHeader *)&UOHead=SubBlockHead;\n          UOHead.OwnerNameSize=Raw.Get2();\n          UOHead.GroupNameSize=Raw.Get2();\n          if (UOHead.OwnerNameSize>=ASIZE(UOHead.OwnerName))\n            UOHead.OwnerNameSize=ASIZE(UOHead.OwnerName)-1;\n          if (UOHead.GroupNameSize>=ASIZE(UOHead.GroupName))\n            UOHead.GroupNameSize=ASIZE(UOHead.GroupName)-1;\n          Raw.GetB(UOHead.OwnerName,UOHead.OwnerNameSize);\n          Raw.GetB(UOHead.GroupName,UOHead.GroupNameSize);\n          UOHead.OwnerName[UOHead.OwnerNameSize]=0;\n          UOHead.GroupName[UOHead.GroupNameSize]=0;\n          break;\n        case NTACL_HEAD:\n          *(SubBlockHeader *)&EAHead=SubBlockHead;\n          EAHead.UnpSize=Raw.Get4();\n          EAHead.UnpVer=Raw.Get1();\n          EAHead.Method=Raw.Get1();\n          EAHead.EACRC=Raw.Get4();\n          break;\n        case STREAM_HEAD:\n          *(SubBlockHeader *)&StreamHead=SubBlockHead;\n          StreamHead.UnpSize=Raw.Get4();\n          StreamHead.UnpVer=Raw.Get1();\n          StreamHead.Method=Raw.Get1();\n          StreamHead.StreamCRC=Raw.Get4();\n          StreamHead.StreamNameSize=Raw.Get2();\n          if (StreamHead.StreamNameSize>=ASIZE(StreamHead.StreamName))\n            StreamHead.StreamNameSize=ASIZE(StreamHead.StreamName)-1;\n          Raw.GetB(StreamHead.StreamName,StreamHead.StreamNameSize);\n          StreamHead.StreamName[StreamHead.StreamNameSize]=0;\n          break;\n      }\n      break;\n#endif\n    default:\n      if (ShortBlock.Flags & LONG_BLOCK)\n        NextBlockPos+=Raw.Get4();\n      break;\n  }\n\n  ushort HeaderCRC=Raw.GetCRC15(false);\n\n  // Old AV header does not have header CRC properly set.\n  if (ShortBlock.HeadCRC!=HeaderCRC && ShortBlock.HeaderType!=HEAD3_SIGN &&\n      ShortBlock.HeaderType!=HEAD3_AV)\n  {\n    bool Recovered=false;\n    if (ShortBlock.HeaderType==HEAD_ENDARC && EndArcHead.RevSpace)\n    {\n      // Last 7 bytes of recovered volume can contain zeroes, because\n      // REV files store its own information (volume number, etc.) here.\n      int64 Length=Tell();\n      Seek(Length-7,SEEK_SET);\n      Recovered=true;\n      for (int J=0;J<7;J++)\n        if (GetByte()!=0)\n          Recovered=false;\n    }\n    if (!Recovered)\n    {\n      BrokenHeader=true;\n      ErrHandler.SetErrorCode(RARX_CRC);\n\n      if (Decrypt)\n      {\n        uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n        FailedHeaderDecryption=true;\n        return 0;\n      }\n    }\n  }\n\n  return Raw.Size();\n}\n\n\nsize_t Archive::ReadHeader50()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD5;\n\n  if (Decrypt)\n  {\n#if defined(RAR_NOCRYPT)\n    return 0;\n#else\n\n    if (Cmd->SkipEncrypted)\n    {\n      uiMsg(UIMSG_SKIPENCARC,FileName);\n      FailedHeaderDecryption=true; // Suppress error messages and quit quietly.\n      return 0;\n    }\n\n    byte HeadersInitV[SIZE_INITV];\n    if (Read(HeadersInitV,SIZE_INITV)!=SIZE_INITV)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n\n    // We repeat the password request only for manually entered passwords\n    // and not for -p<pwd>. Wrong password can be intentionally provided\n    // in -p<pwd> to not stop batch processing for encrypted archives.\n    bool GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n\n    RarCheckPassword CheckPwd;\n    if (CryptHead.UsePswCheck && !BrokenHeader)\n      CheckPwd.Set(CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,CryptHead.PswCheck);\n    \n    while (true) // Repeat the password prompt for wrong passwords.\n    {\n      RequestArcPassword(CheckPwd.IsSet() ? &CheckPwd:NULL);\n\n      byte PswCheck[SIZE_PSWCHECK];\n      HeadersCrypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,NULL,PswCheck);\n      // Verify password validity. If header is damaged, we cannot rely on\n      // password check value, because it can be damaged too.\n      if (CryptHead.UsePswCheck && !BrokenHeader &&\n          memcmp(PswCheck,CryptHead.PswCheck,SIZE_PSWCHECK)!=0)\n      {\n        if (GlobalPassword) // For -p<pwd> or Ctrl+P.\n        {\n          // This message is used by Android GUI to reset cached passwords.\n          // Update appropriate code if changed.\n          uiMsg(UIERROR_BADPSW,FileName,FileName);\n          FailedHeaderDecryption=true;\n          ErrHandler.SetErrorCode(RARX_BADPWD);\n          return 0;\n        }\n        else // For passwords entered manually.\n        {\n          // This message is used by Android GUI and Windows GUI and SFX to\n          // reset cached passwords. Update appropriate code if changed.\n          uiMsg(UIWAIT_BADPSW,FileName,FileName);\n          Cmd->Password.Clean();\n        }\n\n#ifdef RARDLL\n        // Avoid new requests for unrar.dll to prevent the infinite loop\n        // if app always returns the same password.\n        ErrHandler.SetErrorCode(RARX_BADPWD);\n        Cmd->DllError=ERAR_BAD_PASSWORD;\n        ErrHandler.Exit(RARX_BADPWD);\n#else\n        continue; // Request a password again.\n#endif\n      }\n      break;\n    }\n\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  // Header size must not occupy more than 3 variable length integer bytes\n  // resulting in 2 MB maximum header size (MAX_HEADER_SIZE_RAR5),\n  // so here we read 4 byte CRC32 followed by 3 bytes or less of header size.\n  const size_t FirstReadSize=7; // Smallest possible block size.\n  if (Raw.Read(FirstReadSize)<FirstReadSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.Reset();\n  ShortBlock.HeadCRC=Raw.Get4();\n  uint SizeBytes=Raw.GetVSize(4);\n  uint64 BlockSize=Raw.GetV();\n\n  if (BlockSize==0 || SizeBytes==0)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  int SizeToRead=int(BlockSize);\n  SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any.\n  uint HeaderSize=4+SizeBytes+(uint)BlockSize;\n\n  if (SizeToRead<0 || HeaderSize<SIZEOF_SHORTBLOCKHEAD5)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  Raw.Read(SizeToRead);\n\n  if (Raw.Size()<HeaderSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  uint HeaderCRC=Raw.GetCRC50();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)Raw.GetV();\n  ShortBlock.Flags=(uint)Raw.GetV();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & HFL_SKIPIFUNKNOWN)!=0;\n  ShortBlock.HeadSize=HeaderSize;\n\n  CurHeaderType=ShortBlock.HeaderType;\n\n  bool BadCRC=(ShortBlock.HeadCRC!=HeaderCRC);\n  if (BadCRC)\n  {\n    BrokenHeaderMsg(); // Report, but attempt to process.\n\n    BrokenHeader=true;\n    ErrHandler.SetErrorCode(RARX_CRC);\n\n    if (Decrypt)\n    {\n      uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n      FailedHeaderDecryption=true;\n      return 0;\n    }\n  }\n\n  uint64 ExtraSize=0;\n  if ((ShortBlock.Flags & HFL_EXTRA)!=0)\n  {\n    ExtraSize=Raw.GetV();\n    if (ExtraSize>=ShortBlock.HeadSize)\n    {\n      BrokenHeaderMsg();\n      return 0;\n    }\n  }\n\n  uint64 DataSize=0;\n  if ((ShortBlock.Flags & HFL_DATA)!=0)\n    DataSize=Raw.GetV();\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);\n  // Set to 0 in case of overflow, so end of ReadHeader cares about it.\n  NextBlockPos=SafeAdd(NextBlockPos,DataSize,0);\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_CRYPT:\n      {\n        *(BaseBlock *)&CryptHead=ShortBlock;\n        uint CryptVersion=(uint)Raw.GetV();\n        if (CryptVersion>CRYPT_VERSION)\n        {\n          wchar Info[20];\n          swprintf(Info,ASIZE(Info),L\"h%u\",CryptVersion);\n          UnkEncVerMsg(FileName,Info);\n          return 0;\n        }\n        uint EncFlags=(uint)Raw.GetV();\n        CryptHead.UsePswCheck=(EncFlags & CHFL_CRYPT_PSWCHECK)!=0;\n        CryptHead.Lg2Count=Raw.Get1();\n        if (CryptHead.Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n        {\n          wchar Info[20];\n          swprintf(Info,ASIZE(Info),L\"hc%u\",CryptHead.Lg2Count);\n          UnkEncVerMsg(FileName,Info);\n          return 0;\n        }\n\n        Raw.GetB(CryptHead.Salt,SIZE_SALT50);\n        if (CryptHead.UsePswCheck)\n        {\n          Raw.GetB(CryptHead.PswCheck,SIZE_PSWCHECK);\n\n          byte csum[SIZE_PSWCHECK_CSUM];\n          Raw.GetB(csum,SIZE_PSWCHECK_CSUM);\n\n          sha256_context ctx;\n          sha256_init(&ctx);\n          sha256_process(&ctx, CryptHead.PswCheck, SIZE_PSWCHECK);\n\n          byte Digest[SHA256_DIGEST_SIZE];\n          sha256_done(&ctx, Digest);\n\n          CryptHead.UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n        }\n        Encrypted=true;\n      }\n      break;\n    case HEAD_MAIN:\n      {\n        MainHead.Reset();\n        *(BaseBlock *)&MainHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n\n        Volume=(ArcFlags & MHFL_VOLUME)!=0;\n        Solid=(ArcFlags & MHFL_SOLID)!=0;\n        Locked=(ArcFlags & MHFL_LOCK)!=0;\n        Protected=(ArcFlags & MHFL_PROTECT)!=0;\n        Signed=false;\n        NewNumbering=true;\n\n        if ((ArcFlags & MHFL_VOLNUMBER)!=0)\n          VolNumber=(uint)Raw.GetV();\n        else\n          VolNumber=0;\n        FirstVolume=Volume && VolNumber==0;\n\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,&MainHead);\n\n#ifdef USE_QOPEN\n        if (!ProhibitQOpen && MainHead.Locator && MainHead.QOpenOffset>0 && Cmd->QOpenMode!=QOPEN_NONE)\n        {\n          // We seek to QO block in the end of archive when processing\n          // QOpen.Load, so we need to preserve current block positions\n          // to not break normal archive processing by calling function.\n          int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;\n          HEADER_TYPE SaveCurHeaderType=CurHeaderType;\n\n          QOpen.Init(this,false);\n          QOpen.Load(MainHead.QOpenOffset);\n\n          CurBlockPos=SaveCurBlockPos;\n          NextBlockPos=SaveNextBlockPos;\n          CurHeaderType=SaveCurHeaderType;\n        }\n#endif\n      }\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        FileHeader *hd=ShortBlock.HeaderType==HEAD_FILE ? &FileHead:&SubHead;\n        hd->Reset(); // Clear hash, time fields and other stuff like flags.\n        *(BaseBlock *)hd=ShortBlock;\n\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n\n        hd->LargeFile=true;\n\n        hd->PackSize=DataSize;\n        hd->FileFlags=(uint)Raw.GetV();\n        hd->UnpSize=Raw.GetV();\n\n        hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        hd->MaxSize=Max(hd->PackSize,hd->UnpSize);\n        hd->FileAttr=(uint)Raw.GetV();\n        if ((hd->FileFlags & FHFL_UTIME)!=0)\n          hd->mtime.SetUnix((time_t)Raw.Get4());\n\n        hd->FileHash.Type=HASH_NONE;\n        if ((hd->FileFlags & FHFL_CRC32)!=0)\n        {\n          hd->FileHash.Type=HASH_CRC32;\n          hd->FileHash.CRC32=Raw.Get4();\n        }\n\n        hd->RedirType=FSREDIR_NONE;\n\n        uint CompInfo=(uint)Raw.GetV();\n        hd->Method=(CompInfo>>7) & 7;\n\n        // \"+ 50\" to not mix with old RAR format algorithms. For example,\n        // we may need to use the compression algorithm 15 in the future,\n        // but it was already used in RAR 1.5 and Unpack needs to distinguish\n        // them.\n        hd->UnpVer=(CompInfo & 0x3f) + 50;\n        if (hd->UnpVer!=50) // Only 5.0 compression is known now.\n          hd->UnpVer=VER_UNKNOWN;\n\n        hd->HostOS=(byte)Raw.GetV();\n        size_t NameSize=(size_t)Raw.GetV();\n        hd->Inherited=(ShortBlock.Flags & HFL_INHERITED)!=0;\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST5_UNIX)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS==HOST5_WINDOWS)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->SplitBefore=(hd->Flags & HFL_SPLITBEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & HFL_SPLITAFTER)!=0;\n        hd->SubBlock=(hd->Flags & HFL_CHILD)!=0;\n        hd->Solid=FileBlock && (CompInfo & FCI_SOLID)!=0;\n        hd->Dir=(hd->FileFlags & FHFL_DIRECTORY)!=0;\n        hd->WinSize=hd->Dir ? 0:size_t(0x20000)<<((CompInfo>>10)&0xf);\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        UtfToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n        // Should do it before converting names, because extra fields can\n        // affect name processing, like in case of NTFS streams.\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,hd);\n\n        if (FileBlock)\n        {\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n\n        if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_CMT))\n          MainComment=true;\n\n\n        if (BadCRC) // Add the file name to broken header message displayed above.\n          uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n      }\n      break;\n    case HEAD_ENDARC:\n      {\n        *(BaseBlock *)&EndArcHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n        EndArcHead.NextVolume=(ArcFlags & EHFL_NEXTVOLUME)!=0;\n        EndArcHead.StoreVolNumber=false;\n        EndArcHead.DataCRC=false;\n        EndArcHead.RevSpace=false;\n      }\n      break;\n  }\n\n  return Raw.Size();\n}\n\n\n#if !defined(RAR_NOCRYPT)\nvoid Archive::RequestArcPassword(RarCheckPassword *CheckPwd)\n{\n  if (!Cmd->Password.IsSet())\n  {\n#ifdef RARDLL\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n    }\n    if (!Cmd->Password.IsSet())\n    {\n      Close();\n      Cmd->DllError=ERAR_MISSING_PASSWORD;\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#else\n    if (!uiGetPassword(UIPASSWORD_ARCHIVE,FileName,&Cmd->Password,CheckPwd))\n    {\n      Close();\n      uiMsg(UIERROR_INCERRCOUNT); // Prevent archive deleting if delete after extraction is on.\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#endif\n    Cmd->ManualPassword=true;\n  }\n}\n#endif\n\n\nvoid Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,const BaseBlock *bb)\n{\n  // Read extra data from the end of block skipping any fields before it.\n  size_t ExtraStart=Raw->Size()-ExtraSize;\n  if (ExtraStart<Raw->GetPos())\n    return;\n  Raw->SetPos(ExtraStart);\n  while (Raw->DataLeft()>=2)\n  {\n    int64 FieldSize=Raw->GetV(); // Needs to be signed for check below and can be negative.\n    if (FieldSize<=0 || Raw->DataLeft()==0 || FieldSize>(int64)Raw->DataLeft())\n      break;\n    size_t NextPos=size_t(Raw->GetPos()+FieldSize);\n    uint64 FieldType=Raw->GetV();\n\n    FieldSize=int64(NextPos-Raw->GetPos()); // Field size without size and type fields.\n\n    if (FieldSize<0) // FieldType is longer than expected extra field size.\n      break;\n\n    if (bb->HeaderType==HEAD_MAIN)\n    {\n      MainHeader *hd=(MainHeader *)bb;\n      switch(FieldType)\n      {\n        case MHEXTRA_LOCATOR:\n          {\n            hd->Locator=true;\n            uint Flags=(uint)Raw->GetV();\n            if ((Flags & MHEXTRA_LOCATOR_QLIST)!=0)\n            {\n              uint64 Offset=Raw->GetV();\n              if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n                hd->QOpenOffset=Offset+CurBlockPos;\n            }\n            if ((Flags & MHEXTRA_LOCATOR_RR)!=0)\n            {\n              uint64 Offset=Raw->GetV();\n              if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n                hd->RROffset=Offset+CurBlockPos;\n            }\n          }\n          break;\n        case MHEXTRA_METADATA:\n          {\n            uint Flags=(uint)Raw->GetV();\n            if ((Flags & MHEXTRA_METADATA_NAME)!=0)\n            {\n              uint64 NameSize=Raw->GetV();\n              if (NameSize<0x10000) // Prevent excessive allocation.\n              {\n                std::vector<char> NameU((size_t)NameSize); // UTF-8 name.\n                Raw->GetB(&NameU[0],(size_t)NameSize);\n                // If starts from 0, the name was longer han reserved space\n                // when saving this extra field.\n                if (NameU[0]!=0)\n                {\n                  NameU.push_back(0);\n                  std::vector<wchar> NameW(NameU.size()*4);\n                  UtfToWide(&NameU[0],&NameW[0],NameW.size());\n                  hd->OrigName.assign(&NameW[0]);\n                }\n              }\n            }\n            if ((Flags & MHEXTRA_METADATA_CTIME)!=0)\n              if ((Flags & MHEXTRA_METADATA_UNIXTIME)!=0)\n                if ((Flags & MHEXTRA_METADATA_UNIX_NS)!=0)\n                  hd->OrigCtime.SetUnixNS(Raw->Get8());\n                else\n                  hd->OrigCtime.SetUnix((time_t)Raw->Get4());\n              else\n                hd->OrigCtime.SetWin(Raw->Get8());\n          }\n          break;\n      }\n    }\n\n    if (bb->HeaderType==HEAD_FILE || bb->HeaderType==HEAD_SERVICE)\n    {\n      FileHeader *hd=(FileHeader *)bb;\n      switch(FieldType)\n      {\n        case FHEXTRA_CRYPT:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint EncVersion=(uint)Raw->GetV();\n            if (EncVersion>CRYPT_VERSION)\n            {\n              wchar Info[20];\n              swprintf(Info,ASIZE(Info),L\"x%u\",EncVersion);\n              UnkEncVerMsg(hd->FileName,Info);\n            }\n            else\n            {\n              uint Flags=(uint)Raw->GetV();\n              hd->UsePswCheck=(Flags & FHEXTRA_CRYPT_PSWCHECK)!=0;\n              hd->UseHashKey=(Flags & FHEXTRA_CRYPT_HASHMAC)!=0;\n              hd->Lg2Count=Raw->Get1();\n              if (hd->Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n              {\n                wchar Info[20];\n                swprintf(Info,ASIZE(Info),L\"xc%u\",hd->Lg2Count);\n                UnkEncVerMsg(hd->FileName,Info);\n              }\n              Raw->GetB(hd->Salt,SIZE_SALT50);\n              Raw->GetB(hd->InitV,SIZE_INITV);\n              if (hd->UsePswCheck)\n              {\n                Raw->GetB(hd->PswCheck,SIZE_PSWCHECK);\n\n                // It is important to know if password check data is valid.\n                // If it is damaged and header CRC32 fails to detect it,\n                // archiver would refuse to decompress a possibly valid file.\n                // Since we want to be sure distinguishing a wrong password\n                // or corrupt file data, we use 64-bit password check data\n                // and to control its validity we use 32 bits of password\n                // check data SHA-256 additionally to 32-bit header CRC32.\n                byte csum[SIZE_PSWCHECK_CSUM];\n                Raw->GetB(csum,SIZE_PSWCHECK_CSUM);\n\n                sha256_context ctx;\n                sha256_init(&ctx);\n                sha256_process(&ctx, hd->PswCheck, SIZE_PSWCHECK);\n\n                byte Digest[SHA256_DIGEST_SIZE];\n                sha256_done(&ctx, Digest);\n\n                hd->UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n\n                // RAR 5.21 and earlier set PswCheck field in service records to 0\n                // even if UsePswCheck was present.\n                if (bb->HeaderType==HEAD_SERVICE && memcmp(hd->PswCheck,\"\\0\\0\\0\\0\\0\\0\\0\\0\",SIZE_PSWCHECK)==0)\n                  hd->UsePswCheck=0;\n              }\n              hd->SaltSet=true;\n              hd->CryptMethod=CRYPT_RAR50;\n              hd->Encrypted=true;\n            }\n          }\n          break;\n        case FHEXTRA_HASH:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint Type=(uint)Raw->GetV();\n            if (Type==FHEXTRA_HASH_BLAKE2)\n            {\n              hd->FileHash.Type=HASH_BLAKE2;\n              Raw->GetB(hd->FileHash.Digest,BLAKE2_DIGEST_SIZE);\n            }\n          }\n          break;\n        case FHEXTRA_HTIME:\n          if (FieldSize>=5)\n          {\n            byte Flags=(byte)Raw->GetV();\n            bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;\n            if ((Flags & FHEXTRA_HTIME_MTIME)!=0)\n              if (UnixTime)\n                hd->mtime.SetUnix(Raw->Get4());\n              else\n                hd->mtime.SetWin(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_CTIME)!=0)\n              if (UnixTime)\n                hd->ctime.SetUnix(Raw->Get4());\n              else\n                hd->ctime.SetWin(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_ATIME)!=0)\n              if (UnixTime)\n                hd->atime.SetUnix((time_t)Raw->Get4());\n              else\n                hd->atime.SetWin(Raw->Get8());\n            if (UnixTime && (Flags & FHEXTRA_HTIME_UNIX_NS)!=0) // Add nanoseconds.\n            {\n              uint ns;\n              if ((Flags & FHEXTRA_HTIME_MTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->mtime.Adjust(ns);\n              if ((Flags & FHEXTRA_HTIME_CTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->ctime.Adjust(ns);\n              if ((Flags & FHEXTRA_HTIME_ATIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->atime.Adjust(ns);\n            }\n          }\n          break;\n        case FHEXTRA_VERSION:\n          if (FieldSize>=1)\n          {\n            Raw->GetV(); // Skip flags field.\n            uint Version=(uint)Raw->GetV();\n            if (Version!=0)\n            {\n              hd->Version=true;\n\n              wchar VerText[20];\n              swprintf(VerText,ASIZE(VerText),L\";%u\",Version);\n              wcsncatz(hd->FileName,VerText,ASIZE(hd->FileName));\n            }\n          }\n          break;\n        case FHEXTRA_REDIR:\n          {\n            hd->RedirType=(FILE_SYSTEM_REDIRECT)Raw->GetV();\n            uint Flags=(uint)Raw->GetV();\n            hd->DirTarget=(Flags & FHEXTRA_REDIR_DIR)!=0;\n            size_t NameSize=(size_t)Raw->GetV();\n\n            char UtfName[NM*4];\n            *UtfName=0;\n            if (NameSize<ASIZE(UtfName)-1)\n            {\n              Raw->GetB(UtfName,NameSize);\n              UtfName[NameSize]=0;\n            }\n#ifdef _WIN_ALL\n            UnixSlashToDos(UtfName,UtfName,ASIZE(UtfName));\n#endif\n            UtfToWide(UtfName,hd->RedirName,ASIZE(hd->RedirName));\n          }\n          break;\n        case FHEXTRA_UOWNER:\n          {\n            uint Flags=(uint)Raw->GetV();\n            hd->UnixOwnerNumeric=(Flags & FHEXTRA_UOWNER_NUMUID)!=0;\n            hd->UnixGroupNumeric=(Flags & FHEXTRA_UOWNER_NUMGID)!=0;\n            *hd->UnixOwnerName=*hd->UnixGroupName=0;\n            if ((Flags & FHEXTRA_UOWNER_UNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixOwnerName)-1);\n              Raw->GetB(hd->UnixOwnerName,Length);\n              hd->UnixOwnerName[Length]=0;\n            }\n            if ((Flags & FHEXTRA_UOWNER_GNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixGroupName)-1);\n              Raw->GetB(hd->UnixGroupName,Length);\n              hd->UnixGroupName[Length]=0;\n            }\n#ifdef _UNIX\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uid_t)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(gid_t)Raw->GetV();\n#else\n            // Need these fields in Windows too for 'list' command,\n            // but uid_t and gid_t are not defined.\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uint)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(uint)Raw->GetV();\n#endif\n            hd->UnixOwnerSet=true;\n          }\n          break;\n        case FHEXTRA_SUBDATA:\n          {\n            // RAR 5.21 and earlier set FHEXTRA_SUBDATA size to 1 less than\n            // required. It did not hurt extraction, because UnRAR 5.21\n            // and earlier ignored this field and set FieldSize as data left\n            // in entire extra area. But now we set the correct field size\n            // and set FieldSize based on the actual extra record size,\n            // so we need to adjust it for those older archives here.\n            // FHEXTRA_SUBDATA in those archives always belongs to HEAD_SERVICE\n            // and always is last in extra area. So since its size is by 1\n            // less than needed, we always have 1 byte left in extra area,\n            // which fact we use here to detect such archives.\n            if (bb->HeaderType==HEAD_SERVICE && Raw->Size()-NextPos==1)\n              FieldSize++;\n\n            // We cannot allocate too much memory here, because above\n            // we check FieldSize againt Raw size and we control that Raw size\n            // is sensible when reading headers.\n            hd->SubData.Alloc((size_t)FieldSize);\n            Raw->GetB(hd->SubData.Addr(0),(size_t)FieldSize);\n          }\n          break;\n      }\n    }\n\n    Raw->SetPos(NextPos);\n  }\n}\n\n\n#ifndef SFX_MODULE\nsize_t Archive::ReadHeader14()\n{\n  RawRead Raw(this);\n  if (CurBlockPos<=(int64)SFXSize)\n  {\n    Raw.Read(SIZEOF_MAINHEAD14);\n    MainHead.Reset();\n    byte Mark[4];\n    Raw.GetB(Mark,4);\n    uint HeadSize=Raw.Get2();\n    if (HeadSize<7)\n      return false;\n    byte Flags=Raw.Get1();\n    NextBlockPos=CurBlockPos+HeadSize;\n    CurHeaderType=HEAD_MAIN;\n\n    Volume=(Flags & MHD_VOLUME)!=0;\n    Solid=(Flags & MHD_SOLID)!=0;\n    Locked=(Flags & MHD_LOCK)!=0;\n    MainHead.CommentInHeader=(Flags & MHD_COMMENT)!=0;\n    MainHead.PackComment=(Flags & MHD_PACK_COMMENT)!=0;\n  }\n  else\n  {\n    Raw.Read(SIZEOF_FILEHEAD14);\n    FileHead.Reset();\n\n    FileHead.HeaderType=HEAD_FILE;\n    FileHead.DataSize=Raw.Get4();\n    FileHead.UnpSize=Raw.Get4();\n    FileHead.FileHash.Type=HASH_RAR14;\n    FileHead.FileHash.CRC32=Raw.Get2();\n    FileHead.HeadSize=Raw.Get2();\n    if (FileHead.HeadSize<21)\n      return false;\n    uint FileTime=Raw.Get4();\n    FileHead.FileAttr=Raw.Get1();\n    FileHead.Flags=Raw.Get1()|LONG_BLOCK;\n    FileHead.UnpVer=(Raw.Get1()==2) ? 13 : 10;\n    size_t NameSize=Raw.Get1();\n    FileHead.Method=Raw.Get1();\n\n    FileHead.SplitBefore=(FileHead.Flags & LHD_SPLIT_BEFORE)!=0;\n    FileHead.SplitAfter=(FileHead.Flags & LHD_SPLIT_AFTER)!=0;\n    FileHead.Encrypted=(FileHead.Flags & LHD_PASSWORD)!=0;\n    FileHead.CryptMethod=FileHead.Encrypted ? CRYPT_RAR13:CRYPT_NONE;\n\n    FileHead.PackSize=FileHead.DataSize;\n    FileHead.WinSize=0x10000;\n    FileHead.Dir=(FileHead.FileAttr & 0x10)!=0;\n\n    FileHead.HostOS=HOST_MSDOS;\n    FileHead.HSType=HSYS_WINDOWS;\n\n    FileHead.mtime.SetDos(FileTime);\n\n    Raw.Read(NameSize);\n\n    char FileName[NM];\n    size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n    Raw.GetB((byte *)FileName,ReadNameSize);\n    FileName[ReadNameSize]=0;\n    IntToExt(FileName,FileName,ASIZE(FileName));\n    CharToWide(FileName,FileHead.FileName,ASIZE(FileHead.FileName));\n    ConvertNameCase(FileHead.FileName);\n    ConvertFileHeader(&FileHead);\n\n    if (Raw.Size()!=0)\n      NextBlockPos=CurBlockPos+FileHead.HeadSize+FileHead.PackSize;\n    CurHeaderType=HEAD_FILE;\n  }\n  return NextBlockPos>CurBlockPos ? Raw.Size() : 0;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid Archive::ConvertNameCase(wchar *Name)\n{\n  if (Cmd->ConvertNames==NAMES_UPPERCASE)\n    wcsupper(Name);\n  if (Cmd->ConvertNames==NAMES_LOWERCASE)\n    wcslower(Name);\n}\n#endif\n\n\nbool Archive::IsArcDir()\n{\n  return FileHead.Dir;\n}\n\n\nvoid Archive::ConvertAttributes()\n{\n#if defined(_WIN_ALL) || defined(_EMX)\n  if (FileHead.HSType!=HSYS_WINDOWS)\n    FileHead.FileAttr=FileHead.Dir ? 0x10 : 0x20;\n#endif\n#ifdef _UNIX\n  // umask defines which permission bits must not be set by default\n  // when creating a file or directory. The typical default value\n  // for the process umask is S_IWGRP | S_IWOTH (octal 022),\n  // resulting in 0644 mode for new files.\n  // Normally umask is applied automatically when creating a file,\n  // but we set attributes with chmod later, so we need to calculate\n  // resulting attributes here. We do it only for non-Unix archives.\n  // We restore native Unix attributes as is, because it can be backup.\n  static mode_t mask = (mode_t) -1;\n\n  if (mask == (mode_t) -1)\n  {\n    // umask call returns the current umask value. Argument (022) is not\n    // really important here.\n    mask = umask(022);\n\n    // Restore the original umask value, which was changed to 022 above.\n    umask(mask);\n  }\n\n  switch(FileHead.HSType)\n  {\n    case HSYS_WINDOWS:\n      {\n        // Mapping MSDOS, OS/2 and Windows file attributes to Unix.\n\n        if (FileHead.FileAttr & 0x10) // FILE_ATTRIBUTE_DIRECTORY\n        {\n          // For directories we use 0777 mask.\n          FileHead.FileAttr=0777 & ~mask;\n        }\n        else\n          if (FileHead.FileAttr & 1)  // FILE_ATTRIBUTE_READONLY\n          {\n            // For read only files we use 0444 mask with 'w' bits turned off.\n            FileHead.FileAttr=0444 & ~mask;\n          }\n          else\n          {\n            // umask does not set +x for regular files, so we use 0666\n            // instead of 0777 as for directories.\n            FileHead.FileAttr=0666 & ~mask;\n          }\n      }\n      break;\n    case HSYS_UNIX:\n      break;\n    default:\n      if (FileHead.Dir)\n        FileHead.FileAttr=0x41ff & ~mask;\n      else\n        FileHead.FileAttr=0x81b6 & ~mask;\n      break;\n  }\n#endif\n}\n\n\nvoid Archive::ConvertFileHeader(FileHeader *hd)\n{\n  if (hd->HSType==HSYS_UNKNOWN)\n    if (hd->Dir)\n      hd->FileAttr=0x10;\n    else\n      hd->FileAttr=0x20;\n\n#ifdef _WIN_ALL\n  if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\n    ConvertToPrecomposed(hd->FileName,ASIZE(hd->FileName));\n#endif\n\n  for (wchar *s=hd->FileName;*s!=0;s++)\n  {\n#ifdef _UNIX\n    // Backslash is the invalid character for Windows file headers,\n    // but it can present in Unix file names extracted in Unix.\n    if (*s=='\\\\' && Format==RARFMT50 && hd->HSType==HSYS_WINDOWS)\n      *s='_';\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n    // RAR 5.0 archives do not use '\\' as path separator, so if we see it,\n    // it means that it is a part of Unix file name, which we cannot\n    // extract in Windows.\n    if (*s=='\\\\' && Format==RARFMT50)\n      *s='_';\n\n    // ':' in file names is allowed in Unix, but not in Windows.\n    // Even worse, file data will be written to NTFS stream on NTFS,\n    // so automatic name correction on file create error in extraction\n    // routine does not work. In Windows and DOS versions we better\n    // replace ':' now.\n    if (*s==':')\n      *s='_';\n#endif\n\n    // This code must be performed only after other path separator checks,\n    // because it produces backslashes illegal for some of checks above.\n    // Backslash is allowed in file names in Unix, but not in Windows.\n    // Still, RAR 4.x uses backslashes as path separator even in Unix.\n    // Forward slash is not allowed in both systems. In RAR 5.0 we use\n    // the forward slash as universal path separator.\n    if (*s=='/' || *s=='\\\\' && Format!=RARFMT50)\n      *s=CPATHDIVIDER;\n  }\n}\n\n\nint64 Archive::GetStartPos()\n{\n  int64 StartPos=SFXSize+MarkHead.HeadSize;\n  if (Format==RARFMT15)\n    StartPos+=MainHead.HeadSize;\n  else // RAR 5.0.\n    StartPos+=CryptHead.HeadSize+FullHeaderSize(MainHead.HeadSize);\n  return StartPos;\n}\n\n\nbool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      // So huge allocation must never happen in valid archives.\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}\n", "#ifndef _RAR_CRYPT_\n#define _RAR_CRYPT_\n\n\nenum CRYPT_METHOD {\n  CRYPT_NONE,CRYPT_RAR13,CRYPT_RAR15,CRYPT_RAR20,CRYPT_RAR30,CRYPT_RAR50\n};\n\n#define SIZE_SALT50              16\n#define SIZE_SALT30               8\n#define SIZE_INITV               16\n#define SIZE_PSWCHECK             8\n#define SIZE_PSWCHECK_CSUM        4\n\n#define CRYPT_BLOCK_SIZE         16\n#define CRYPT_BLOCK_MASK         (CRYPT_BLOCK_SIZE-1) // 0xf\n\n// 2013.04.29: set to 15 for RAR 5.00 beta 1.\n// 2022.09.07: changed to 16 for upcoming RAR 6.20.\n#define CRYPT5_KDF_LG2_COUNT     16 // LOG2 of PDKDF2 iteration count.\n\n#define CRYPT5_KDF_LG2_COUNT_MAX 24 // LOG2 of maximum accepted iteration count.\n#define CRYPT_VERSION             0 // Supported encryption version.\n\n\nclass CryptData\n{\n  struct KDF5CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT50];\n    byte Key[32];\n    uint Lg2Count; // Log2 of PBKDF2 repetition count.\n    byte PswCheckValue[SHA256_DIGEST_SIZE];\n    byte HashKeyValue[SHA256_DIGEST_SIZE];\n\n    KDF5CacheItem() {Clean();}\n    ~KDF5CacheItem() {Clean();}\n\n    void Clean()\n    {\n      cleandata(Salt,sizeof(Salt));\n      cleandata(Key,sizeof(Key));\n      cleandata(&Lg2Count,sizeof(Lg2Count));\n      cleandata(PswCheckValue,sizeof(PswCheckValue));\n      cleandata(HashKeyValue,sizeof(HashKeyValue));\n    }\n  };\n\n  struct KDF3CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT30];\n    byte Key[16];\n    byte Init[16];\n    bool SaltPresent;\n\n    KDF3CacheItem() {Clean();}\n    ~KDF3CacheItem() {Clean();}\n\n    void Clean()\n    {\n      cleandata(Salt,sizeof(Salt));\n      cleandata(Key,sizeof(Key));\n      cleandata(Init,sizeof(Init));\n      cleandata(&SaltPresent,sizeof(SaltPresent));\n    }\n  };\n\n\n  private:\n    void SetKey13(const char *Password);\n    void Decrypt13(byte *Data,size_t Count);\n\n    void SetKey15(const char *Password);\n    void Crypt15(byte *Data,size_t Count);\n\n    void SetKey20(const char *Password);\n    void Swap20(byte *Ch1,byte *Ch2);\n    void UpdKeys20(byte *Buf);\n    void EncryptBlock20(byte *Buf);\n    void DecryptBlock20(byte *Buf);\n\n    void SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt);\n    void SetKey50(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck);\n\n    KDF3CacheItem KDF3Cache[4];\n    uint KDF3CachePos;\n    \n    KDF5CacheItem KDF5Cache[4];\n    uint KDF5CachePos;\n\n    CRYPT_METHOD Method;\n\n    Rijndael rin;\n\n    uint CRCTab[256]; // For RAR 1.5 and RAR 2.0 encryption.\n    \n    byte SubstTable20[256];\n    uint Key20[4];\n\n    byte Key13[3];\n    ushort Key15[4];\n  public:\n    CryptData();\n    bool SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,SecPassword *Password,\n         const byte *Salt,const byte *InitV,uint Lg2Cnt,\n         byte *HashKey,byte *PswCheck);\n    void SetAV15Encryption();\n    void SetCmt13Encryption();\n    void EncryptBlock(byte *Buf,size_t Size);\n    void DecryptBlock(byte *Buf,size_t Size);\n    static void SetSalt(byte *Salt,size_t SaltSize);\n};\n\n\nclass CheckPassword\n{\n  public:\n    enum CONFIDENCE {CONFIDENCE_HIGH,CONFIDENCE_MEDIUM,CONFIDENCE_LOW};\n    virtual CONFIDENCE GetConfidence()=0;\n    virtual bool Check(SecPassword *Password)=0;\n};\n\nclass RarCheckPassword:public CheckPassword\n{\n  private:\n    CryptData *Crypt;\n    uint Lg2Count;\n    byte Salt[SIZE_SALT50];\n    byte InitV[SIZE_INITV];\n    byte PswCheck[SIZE_PSWCHECK];\n  public:\n    RarCheckPassword()\n    {\n      Crypt=NULL;\n    }\n    ~RarCheckPassword()\n    {\n      delete Crypt;\n    }\n    void Set(byte *Salt,byte *InitV,uint Lg2Count,byte *PswCheck)\n    {\n      if (Crypt==NULL)\n        Crypt=new CryptData;\n      memcpy(this->Salt,Salt,sizeof(this->Salt));\n      memcpy(this->InitV,InitV,sizeof(this->InitV));\n      this->Lg2Count=Lg2Count;\n      memcpy(this->PswCheck,PswCheck,sizeof(this->PswCheck));\n    }\n    bool IsSet() {return Crypt!=NULL;}\n\n    // RAR5 provides the higly reliable 64 bit password verification value.\n    CONFIDENCE GetConfidence() {return CONFIDENCE_HIGH;}\n\n    bool Check(SecPassword *Password)\n    {\n      byte PswCheck[SIZE_PSWCHECK];\n      Crypt->SetCryptKeys(false,CRYPT_RAR50,Password,Salt,InitV,Lg2Count,NULL,PswCheck);\n      return memcmp(PswCheck,this->PswCheck,sizeof(this->PswCheck))==0;\n    }\n};\n\nvoid GetRnd(byte *RndBuf,size_t BufSize);\n\nvoid hmac_sha256(const byte *Key,size_t KeyLength,const byte *Data,\n                 size_t DataLength,byte *ResDigest);\nvoid pbkdf2(const byte *pass, size_t pass_len, const byte *salt,\n            size_t salt_len,byte *key, byte *Value1, byte *Value2,\n            uint rounds);\n\nvoid ConvertHashToMAC(HashValue *Value,byte *Key);\n\n#endif\n", "#include <windows.h>\n#include <commctrl.h>\n\nVS_VERSION_INFO VERSIONINFO\nFILEVERSION 6, 20, 2, 681\nPRODUCTVERSION 6, 20, 2, 681\nFILEOS VOS__WINDOWS32\nFILETYPE VFT_APP\n{\n  BLOCK \"StringFileInfo\"\n  {\n    BLOCK \"040904E4\"\n    {\n      VALUE \"CompanyName\", \"Alexander Roshal\\0\"\n      VALUE \"ProductName\", \"RAR decompression library\\0\"\n      VALUE \"FileDescription\", \"RAR decompression library\\0\"\n      VALUE \"FileVersion\", \"6.20.2\\0\"\n      VALUE \"ProductVersion\", \"6.20.2\\0\"\n      VALUE \"LegalCopyright\", \"Copyright \u0119 Alexander Roshal 1993-2022\\0\"\n      VALUE \"OriginalFilename\", \"Unrar.dll\\0\"\n    }\n  }\n  BLOCK \"VarFileInfo\"\n  {\n    VALUE \"Translation\", 0x0409, 0x04E4\n  }\n}\n\n", "#include \"rar.hpp\"\n\n#include \"hardlinks.cpp\"\n#include \"win32stm.cpp\"\n\n#ifdef _WIN_ALL\n#include \"win32acl.cpp\"\n#include \"win32lnk.cpp\"\n#endif\n\n#ifdef _UNIX\n#include \"uowners.cpp\"\n#ifdef SAVE_LINKS\n#include \"ulinks.cpp\"\n#endif\n#endif\n\n\n\n// RAR2 service header extra records.\n#ifndef SFX_MODULE\nvoid SetExtraInfo20(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n  if (Cmd->Test)\n    return;\n  switch(Arc.SubBlockHead.SubType)\n  {\n#ifdef _UNIX\n    case UO_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractUnixOwner20(Arc,Name);\n      break;\n#endif\n#ifdef _WIN_ALL\n    case NTACL_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractACL20(Arc,Name);\n      break;\n    case STREAM_HEAD:\n      ExtractStreams20(Arc,Name);\n      break;\n#endif\n  }\n}\n#endif\n\n\n// RAR3 and RAR5 service header extra records.\nvoid SetExtraInfo(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n#ifdef _UNIX\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.Format==RARFMT15 &&\n      Arc.SubHead.CmpName(SUBHEAD_TYPE_UOWNER))\n    ExtractUnixOwner30(Arc,Name);\n#endif\n#ifdef _WIN_ALL\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.SubHead.CmpName(SUBHEAD_TYPE_ACL))\n    ExtractACL(Arc,Name);\n  if (Arc.SubHead.CmpName(SUBHEAD_TYPE_STREAM))\n    ExtractStreams(Arc,Name,Cmd->Test);\n#endif\n}\n\n\n// Extra data stored directly in file header.\nvoid SetFileHeaderExtra(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n#ifdef _UNIX\n   if (Cmd->ProcessOwners && Arc.Format==RARFMT50 && Arc.FileHead.UnixOwnerSet)\n     SetUnixOwner(Arc,Name);\n#endif\n}\n\n\n\n\n// Calculate a number of path components except \\. and \\..\nstatic int CalcAllowedDepth(const wchar *Name)\n{\n  int AllowedDepth=0;\n  while (*Name!=0)\n  {\n    if (IsPathDiv(Name[0]) && Name[1]!=0 && !IsPathDiv(Name[1]))\n    {\n      bool Dot=Name[1]=='.' && (IsPathDiv(Name[2]) || Name[2]==0);\n      bool Dot2=Name[1]=='.' && Name[2]=='.' && (IsPathDiv(Name[3]) || Name[3]==0);\n      if (!Dot && !Dot2)\n        AllowedDepth++;\n    }\n    Name++;\n  }\n  return AllowedDepth;\n}\n\n\n// Check if all existing path components are directories and not links.\nstatic bool LinkInPath(const wchar *Name)\n{\n  wchar Path[NM];\n  if (wcslen(Name)>=ASIZE(Path))\n    return true;  // It should not be that long, skip.\n  wcsncpyz(Path,Name,ASIZE(Path));\n  for (wchar *s=Path+wcslen(Path)-1;s>Path;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && (FD.IsLink || !FD.IsDir))\n        return true;\n    }\n  return false;\n}\n\n\nbool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  // Catch root dir based /path/file paths also as stuff like \\\\?\\.\n  // Do not check PrepSrcName here, it can be root based if destination path\n  // is a root based.\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n\n  // Number of \"..\" in link target.\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  // If link target includes \"..\", it must not have another links\n  // in the path, because they can bypass our safety check. For example,\n  // suppose we extracted \"lnk1\" -> \".\" first and \"lnk1/lnk2\" -> \"..\" next\n  // or \"dir/lnk1\" -> \"..\" first and \"dir/lnk1/lnk2\" -> \"..\" next.\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n    \n  // We could check just prepared src name, but for extra safety\n  // we check both original (as from archive header) and prepared\n  // (after applying the destination path and -ep switches) names.\n\n  int AllowedDepth=CalcAllowedDepth(SrcName); // Original name depth.\n\n  // Remove the destination path from prepared name if any. We should not\n  // count the destination path depth, because the link target must point\n  // inside of this path, not outside of it.\n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}\n\n\nbool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}\n", "#ifndef _RAR_EXTINFO_\n#define _RAR_EXTINFO_\n\nbool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName);\nbool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName);\n#ifdef _UNIX\nvoid SetUnixOwner(Archive &Arc,const wchar *FileName);\n#endif\n\nbool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize);\n\nvoid GetStreamNameNTFS(Archive &Arc,wchar *StreamName,size_t MaxSize);\n\n#ifdef _WIN_ALL\nbool SetPrivilege(LPCTSTR PrivName);\n#endif\n\nvoid SetExtraInfo20(CommandData *Cmd,Archive &Arc,wchar *Name);\nvoid SetExtraInfo(CommandData *Cmd,Archive &Arc,wchar *Name);\nvoid SetFileHeaderExtra(CommandData *Cmd,Archive &Arc,wchar *Name);\n\n\n#endif\n", "#include \"rar.hpp\"\n\nCmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n\n  *ArcName=0;\n  *DestFileName=0;\n\n  ArcAnalyzed=false;\n  Analyze=new AnalyzeData;\n  memset(Analyze,0,sizeof(*Analyze));\n\n  TotalFileCount=0;\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}\n\n\nCmdExtract::~CmdExtract()\n{\n  ReleaseAnalyzeData();\n  delete Unp;\n  delete Analyze;\n}\n\n\nvoid CmdExtract::ReleaseAnalyzeData()\n{\n  for (size_t I=0;I<RefList.Size();I++)\n  {\n    // We can have undeleted temporary reference source here if extraction\n    // was interrupted early or if user refused to overwrite prompt.\n    if (RefList[I].TmpName!=NULL)\n      DelFile(RefList[I].TmpName);\n    free(RefList[I].RefName);\n    free(RefList[I].TmpName);\n  }\n  RefList.Reset();\n\n  memset(Analyze,0,sizeof(*Analyze));\n}\n\n\nvoid CmdExtract::DoExtract()\n{\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n  Fat32=NotFat32=false;\n#endif\n  PasswordCancelled=false;\n  DataIO.SetCurrentCommand(Cmd->Command[0]);\n\n  if (*Cmd->UseStdin==0)\n  {\n    FindData FD;\n    while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n      if (FindFile::FastFind(ArcName,&FD))\n        DataIO.TotalArcSize+=FD.Size;\n  }\n\n  Cmd->ArcNames.Rewind();\n  while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n  {\n    if (Cmd->ManualPassword)\n      Cmd->Password.Clean(); // Clean user entered password before processing next archive.\n  \n    ReconstructDone=false; // Must be reset here, not in ExtractArchiveInit().\n    UseExactVolName=false; // Must be reset here, not in ExtractArchiveInit().\n    while (true)\n    {\n      EXTRACT_ARC_CODE Code=ExtractArchive();\n      if (Code!=EXTRACT_ARC_REPEAT)\n        break;\n    }\n    DataIO.ProcessedArcSize+=DataIO.LastArcSize;\n  }\n\n  // Clean user entered password. Not really required, just for extra safety.\n  if (Cmd->ManualPassword)\n    Cmd->Password.Clean();\n\n  if (TotalFileCount==0 && Cmd->Command[0]!='I' && \n      ErrHandler.GetErrorCode()!=RARX_BADPWD) // Not in case of wrong archive password.\n  {\n    if (!PasswordCancelled)\n      uiMsg(UIERROR_NOFILESTOEXTRACT,ArcName);\n\n    // Other error codes may explain a reason of \"no files extracted\" clearer,\n    // so set it only if no other errors found (wrong mask set by user).\n    if (ErrHandler.GetErrorCode()==RARX_SUCCESS)\n      ErrHandler.SetErrorCode(RARX_NOFILES);\n  }\n  else\n    if (!Cmd->DisableDone)\n      if (Cmd->Command[0]=='I')\n        mprintf(St(MDone));\n      else\n        if (ErrHandler.GetErrorCount()==0)\n          mprintf(St(MExtrAllOk));\n        else\n          mprintf(St(MExtrTotalErr),ErrHandler.GetErrorCount());\n}\n\n\nvoid CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n\n  DataIO.UnpVolume=false;\n\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n\n  ArcAnalyzed=false;\n\n  StartTime.SetCurrentTime();\n}\n\n\nEXTRACT_ARC_CODE CmdExtract::ExtractArchive()\n{\n  Archive Arc(Cmd);\n  if (*Cmd->UseStdin!=0)\n  {\n    Arc.SetHandleType(FILE_HANDLESTD);\n#ifdef USE_QOPEN\n    Arc.SetProhibitQOpen(true);\n#endif\n  }\n  else\n  {\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) // WinRAR GUI code also resets the cache.\n    if (*Cmd->Command=='T' || Cmd->Test)\n      ResetFileCache(ArcName); // Reset the file cache when testing an archive.\n#endif\n    if (!Arc.WOpen(ArcName))\n      return EXTRACT_ARC_NEXT;\n  }\n\n  if (!Arc.IsArchive(true))\n  {\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n    if (CmpExt(ArcName,L\"rev\"))\n    {\n      wchar FirstVolName[NM];\n      VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),true);\n\n      // If several volume names from same volume set are specified\n      // and current volume is not first in set and first volume is present\n      // and specified too, let's skip the current volume.\n      if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n          Cmd->ArcNames.Search(FirstVolName,false))\n        return EXTRACT_ARC_NEXT;\n      RecVolumesTest(Cmd,NULL,ArcName);\n      TotalFileCount++; // Suppress \"No files to extract\" message.\n      return EXTRACT_ARC_NEXT;\n    }\n#endif\n\n    mprintf(St(MNotRAR),ArcName);\n\n#ifndef SFX_MODULE\n    if (CmpExt(ArcName,L\"rar\"))\n#endif\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    return EXTRACT_ARC_NEXT;\n  }\n\n  if (Arc.FailedHeaderDecryption) // Bad archive password.\n    return EXTRACT_ARC_NEXT;\n\n#ifndef SFX_MODULE\n  if (Arc.Volume && !Arc.FirstVolume && !UseExactVolName)\n  {\n    wchar FirstVolName[NM];\n    VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),Arc.NewNumbering);\n\n    // If several volume names from same volume set are specified\n    // and current volume is not first in set and first volume is present\n    // and specified too, let's skip the current volume.\n    if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n        Cmd->ArcNames.Search(FirstVolName,false))\n      return EXTRACT_ARC_NEXT;\n  }\n#endif\n\n  Arc.ViewComment(); // Must be before possible EXTRACT_ARC_REPEAT.\n\n  int64 VolumeSetSize=0; // Total size of volumes after the current volume.\n\n#ifndef SFX_MODULE\n  if (!ArcAnalyzed && *Cmd->UseStdin==0)\n  {\n    AnalyzeArchive(Arc.FileName,Arc.Volume,Arc.NewNumbering);\n    ArcAnalyzed=true; // Avoid repeated analysis on EXTRACT_ARC_REPEAT.\n  }\n#endif\n\n  if (Arc.Volume)\n  {\n#ifndef SFX_MODULE\n    // Try to speed up extraction for independent solid volumes by starting\n    // extraction from non-first volume if we can.\n    if (*Analyze->StartName!=0)\n    {\n      wcsncpyz(ArcName,Analyze->StartName,ASIZE(ArcName));\n      *Analyze->StartName=0;\n\n      UseExactVolName=true;\n      return EXTRACT_ARC_REPEAT;\n    }\n#endif\n    \n    // Calculate the total size of all accessible volumes.\n    // This size is necessary to display the correct total progress indicator.\n\n    wchar NextName[NM];\n    wcsncpyz(NextName,Arc.FileName,ASIZE(NextName));\n\n    while (true)\n    {\n      // First volume is already added to DataIO.TotalArcSize \n      // in initial TotalArcSize calculation in DoExtract.\n      // So we skip it and start from second volume.\n      NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n      FindData FD;\n      if (FindFile::FastFind(NextName,&FD))\n        VolumeSetSize+=FD.Size;\n      else\n        break;\n    }\n    DataIO.TotalArcSize+=VolumeSetSize;\n  }\n\n  ExtractArchiveInit(Arc);\n\n  if (*Cmd->Command=='T' || *Cmd->Command=='I')\n    Cmd->Test=true;\n\n\n  if (*Cmd->Command=='I')\n  {\n    Cmd->DisablePercentage=true;\n  }\n  else\n    uiStartArchiveExtract(!Cmd->Test,ArcName);\n\n#ifndef SFX_MODULE\n  if (Analyze->StartPos!=0)\n  {\n    Arc.Seek(Analyze->StartPos,SEEK_SET);\n    Analyze->StartPos=0;\n  }\n#endif\n\n\n  while (1)\n  {\n    size_t Size=Arc.ReadHeader();\n\n\n    bool Repeat=false;\n    if (!ExtractCurrentFile(Arc,Size,Repeat))\n      if (Repeat)\n      {\n        // If we started extraction from not first volume and need to\n        // restart it from first, we must set DataIO.TotalArcSize to size\n        // of new first volume to display the total progress correctly.\n        FindData NewArc;\n        if (FindFile::FastFind(ArcName,&NewArc))\n          DataIO.TotalArcSize=NewArc.Size;\n        return EXTRACT_ARC_REPEAT;\n      }\n      else\n        break;\n  }\n\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Cmd->Test && Arc.Volume)\n    RecVolumesTest(Cmd,&Arc,ArcName);\n#endif\n\n  return EXTRACT_ARC_NEXT;\n}\n\n\nbool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)\n{\n  wchar Command=Cmd->Command[0];\n  if (HeaderSize==0)\n    if (DataIO.UnpVolume)\n    {\n#ifdef NOVOLUME\n      return false;\n#else\n      // Supposing we unpack an old RAR volume without the end of archive\n      // record and last file is not split between volumes.\n      if (!MergeArchive(Arc,&DataIO,false,Command))\n      {\n        ErrHandler.SetErrorCode(RARX_WARNING);\n        return false;\n      }\n#endif\n    }\n    else\n      return false;\n\n  HEADER_TYPE HeaderType=Arc.GetHeaderType();\n  if (HeaderType==HEAD_FILE)\n  {\n    // Unlike Arc.FileName, ArcName might store an old volume name here.\n    if (Analyze->EndPos!=0 && Analyze->EndPos==Arc.CurBlockPos &&\n        (*Analyze->EndName==0 || wcscmp(Analyze->EndName,Arc.FileName)==0))\n      return false;\n  }\n  else\n  {\n#ifndef SFX_MODULE\n    if (Arc.Format==RARFMT15 && HeaderType==HEAD3_OLDSERVICE && PrevProcessed)\n      SetExtraInfo20(Cmd,Arc,DestFileName);\n#endif\n    if (HeaderType==HEAD_SERVICE && PrevProcessed)\n      SetExtraInfo(Cmd,Arc,DestFileName);\n    if (HeaderType==HEAD_ENDARC)\n      if (Arc.EndArcHead.NextVolume)\n      {\n#ifdef NOVOLUME\n        return false;\n#else\n        if (!MergeArchive(Arc,&DataIO,false,Command))\n        {\n          ErrHandler.SetErrorCode(RARX_WARNING);\n          return false;\n        }\n        Arc.Seek(Arc.CurBlockPos,SEEK_SET);\n        return true;\n#endif\n      }\n      else\n        return false;\n    Arc.SeekToNext();\n    return true;\n  }\n  PrevProcessed=false;\n\n  // We can get negative sizes in corrupt archive and it is unacceptable\n  // for size comparisons in ComprDataIO::UnpRead, where we cast sizes\n  // to size_t and can exceed another read or available size. We could fix it\n  // when reading an archive. But we prefer to do it here, because this\n  // function is called directly in unrar.dll, so we fix bad parameters\n  // passed to dll. Also we want to see real negative sizes in the listing\n  // of corrupt archive. To prevent uninitialized data access perform\n  // these checks after rejecting zero length and non-file headers above.\n  if (Arc.FileHead.PackSize<0)\n    Arc.FileHead.PackSize=0;\n  if (Arc.FileHead.UnpSize<0)\n    Arc.FileHead.UnpSize=0;\n\n  // 2022.03.20: We might remove this check in the future.\n  // It duplicates Analyze->EndPos and Analyze->EndName in all cases except\n  // volumes on removable media.\n  if (!Cmd->Recurse && MatchedArgs>=Cmd->FileArgs.ItemsCount() && AllMatchesExact)\n    return false;\n\n  int MatchType=MATCH_WILDSUBPATH;\n\n  bool EqualNames=false;\n  wchar MatchedArg[NM];\n  int MatchNumber=Cmd->IsProcessFile(Arc.FileHead,&EqualNames,MatchType,0,MatchedArg,ASIZE(MatchedArg));\n  bool MatchFound=MatchNumber!=0;\n#ifndef SFX_MODULE\n  if (Cmd->ExclPath==EXCL_BASEPATH)\n  {\n    wcsncpyz(Cmd->ArcPath,MatchedArg,ASIZE(Cmd->ArcPath));\n    *PointToName(Cmd->ArcPath)=0;\n    if (IsWildcard(Cmd->ArcPath)) // Cannot correctly process path*\\* masks here.\n      *Cmd->ArcPath=0;\n  }\n#endif\n  if (MatchFound && !EqualNames)\n    AllMatchesExact=false;\n\n  Arc.ConvertAttributes();\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Arc.FileHead.SplitBefore && FirstFile && !UseExactVolName)\n  {\n    wchar CurVolName[NM];\n    wcsncpyz(CurVolName,ArcName,ASIZE(CurVolName));\n    GetFirstVolIfFullSet(ArcName,Arc.NewNumbering,ArcName,ASIZE(ArcName));\n\n    if (wcsicomp(ArcName,CurVolName)!=0 && FileExist(ArcName))\n    {\n      wcsncpyz(Cmd->ArcName,ArcName,ASIZE(ArcName)); // For GUI \"Delete archive after extraction\".\n      // If first volume name does not match the current name and if such\n      // volume name really exists, let's unpack from this first volume.\n      Repeat=true;\n      return false;\n    }\n#ifndef RARDLL\n    if (!ReconstructDone)\n    {\n      ReconstructDone=true;\n      if (RecVolumesRestore(Cmd,Arc.FileName,true))\n      {\n        Repeat=true;\n        return false;\n      }\n    }\n#endif\n    wcsncpyz(ArcName,CurVolName,ASIZE(ArcName));\n  }\n#endif\n\n  wchar ArcFileName[NM];\n  ConvertPath(Arc.FileHead.FileName,ArcFileName,ASIZE(ArcFileName));\n\n  if (Arc.FileHead.Version)\n  {\n    if (Cmd->VersionControl!=1 && !EqualNames)\n    {\n      if (Cmd->VersionControl==0)\n        MatchFound=false;\n      int Version=ParseVersionFileName(ArcFileName,false);\n      if (Cmd->VersionControl-1==Version)\n        ParseVersionFileName(ArcFileName,true);\n      else\n        MatchFound=false;\n    }\n  }\n  else\n    if (!Arc.IsArcDir() && Cmd->VersionControl>1)\n      MatchFound=false;\n\n  DataIO.UnpVolume=Arc.FileHead.SplitAfter;\n  DataIO.NextVolumeMissing=false;\n\n  Arc.Seek(Arc.NextBlockPos-Arc.FileHead.PackSize,SEEK_SET);\n\n  bool ExtrFile=false;\n  bool SkipSolid=false;\n\n#ifndef SFX_MODULE\n  if (FirstFile && (MatchFound || Arc.Solid) && Arc.FileHead.SplitBefore)\n  {\n    if (MatchFound)\n    {\n      uiMsg(UIERROR_NEEDPREVVOL,Arc.FileName,ArcFileName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_BAD_DATA;\n#endif\n      ErrHandler.SetErrorCode(RARX_OPEN);\n    }\n    MatchFound=false;\n  }\n\n  FirstFile=false;\n#endif\n\n  bool RefTarget=false;\n  if (!MatchFound)\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(ArcFileName,RefList[I].RefName)==0)\n      {\n        ExtractRef *MatchedRef=&RefList[I];\n      \n        if (!Cmd->Test) // While harmless, it is useless for 't'.\n        {\n          wcsncpyz(DestFileName,*Cmd->TempPath!=0 ? Cmd->TempPath:Cmd->ExtrPath,ASIZE(DestFileName));\n          AddEndSlash(DestFileName,ASIZE(DestFileName));\n          wcsncatz(DestFileName,L\"__tmp_reference_source_\",ASIZE(DestFileName));\n          MkTemp(DestFileName,ASIZE(DestFileName));\n          MatchedRef->TmpName=wcsdup(DestFileName);\n        }\n        RefTarget=true; // Need it even for 't' to test the reference source.\n        break;\n      }\n  \n  if (Arc.FileHead.Encrypted && Cmd->SkipEncrypted)\n    if (Arc.Solid)\n      return false; // Abort the entire extraction for solid archive.\n    else\n      MatchFound=false; // Skip only the current file for non-solid archive.\n  \n  if (MatchFound || RefTarget || (SkipSolid=Arc.Solid)!=0)\n  {\n    // First common call of uiStartFileExtract. It is done before overwrite\n    // prompts, so if SkipSolid state is changed below, we'll need to make\n    // additional uiStartFileExtract calls with updated parameters.\n    if (!uiStartFileExtract(ArcFileName,!Cmd->Test,Cmd->Test && Command!='I',SkipSolid))\n      return false;\n\n    if (!RefTarget)\n      ExtrPrepareName(Arc,ArcFileName,DestFileName,ASIZE(DestFileName));\n\n    // DestFileName can be set empty in case of excessive -ap switch.\n    ExtrFile=!SkipSolid && *DestFileName!=0 && !Arc.FileHead.SplitBefore;\n\n    if ((Cmd->FreshFiles || Cmd->UpdateFiles) && (Command=='E' || Command=='X'))\n    {\n      FindData FD;\n      if (FindFile::FastFind(DestFileName,&FD))\n      {\n        if (FD.mtime >= Arc.FileHead.mtime)\n        {\n          // If directory already exists and its modification time is newer \n          // than start of extraction, it is likely it was created \n          // when creating a path to one of already extracted items. \n          // In such case we'll better update its time even if archived \n          // directory is older.\n\n          if (!FD.IsDir || FD.mtime<StartTime)\n            ExtrFile=false;\n        }\n      }\n      else\n        if (Cmd->FreshFiles)\n          ExtrFile=false;\n    }\n\n    if (!CheckUnpVer(Arc,ArcFileName))\n    {\n      ErrHandler.SetErrorCode(RARX_FATAL);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_UNKNOWN_FORMAT;\n#endif\n      Arc.SeekToNext();\n      return !Arc.Solid; // Can try extracting next file only in non-solid archive.\n    }\n\n    if (Arc.FileHead.Encrypted)\n    {\n      RarCheckPassword CheckPwd;\n      if (Arc.Format==RARFMT50 && Arc.FileHead.UsePswCheck && !Arc.BrokenHeader)\n        CheckPwd.Set(Arc.FileHead.Salt,Arc.FileHead.InitV,Arc.FileHead.Lg2Count,Arc.FileHead.PswCheck);\n\n      while (true) // Repeat the password prompt for wrong and empty passwords.\n      {\n        // Stop archive extracting if user cancelled a password prompt.\n#ifdef RARDLL\n        if (!ExtrDllGetPassword())\n        {\n          Cmd->DllError=ERAR_MISSING_PASSWORD;\n          return false;\n        }\n#else\n        if (!ExtrGetPassword(Arc,ArcFileName,CheckPwd.IsSet() ? &CheckPwd:NULL))\n        {\n          PasswordCancelled=true;\n          return false;\n        }\n#endif\n\n        // Set a password before creating the file, so we can skip creating\n        // in case of wrong password.\n        SecPassword FilePassword=Cmd->Password;\n  #if defined(_WIN_ALL) && !defined(SFX_MODULE)\n        ConvertDosPassword(Arc,FilePassword);\n  #endif\n\n        byte PswCheck[SIZE_PSWCHECK];\n        DataIO.SetEncryption(false,Arc.FileHead.CryptMethod,&FilePassword,\n               Arc.FileHead.SaltSet ? Arc.FileHead.Salt:NULL,\n               Arc.FileHead.InitV,Arc.FileHead.Lg2Count,\n               Arc.FileHead.HashKey,PswCheck);\n\n        // If header is damaged, we cannot rely on password check value,\n        // because it can be damaged too.\n        if (Arc.FileHead.UsePswCheck && !Arc.BrokenHeader &&\n            memcmp(Arc.FileHead.PswCheck,PswCheck,SIZE_PSWCHECK)!=0)\n        {\n          if (GlobalPassword) // For -p<pwd> or Ctrl+P to avoid the infinite loop.\n          {\n            // This message is used by Android GUI to reset cached passwords.\n            // Update appropriate code if changed.\n            uiMsg(UIERROR_BADPSW,Arc.FileName,ArcFileName);\n          }\n          else // For passwords entered manually.\n          {\n            // This message is used by Android GUI and Windows GUI and SFX to\n            // reset cached passwords. Update appropriate code if changed.\n            uiMsg(UIWAIT_BADPSW,Arc.FileName,ArcFileName);\n            Cmd->Password.Clean();\n\n            // Avoid new requests for unrar.dll to prevent the infinite loop\n            // if app always returns the same password.\n  #ifndef RARDLL\n            continue; // Request a password again.\n  #endif\n          }\n  #ifdef RARDLL\n          // If we already have ERAR_EOPEN as result of missing volume,\n          // we should not replace it with less precise ERAR_BAD_PASSWORD.\n          if (Cmd->DllError!=ERAR_EOPEN)\n            Cmd->DllError=ERAR_BAD_PASSWORD;\n  #endif\n          ErrHandler.SetErrorCode(RARX_BADPWD);\n          ExtrFile=false;\n        }\n        break;\n      }\n    }\n\n#ifdef RARDLL\n    if (*Cmd->DllDestName!=0)\n      wcsncpyz(DestFileName,Cmd->DllDestName,ASIZE(DestFileName));\n#endif\n\n    File CurFile;\n\n    bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;\n    if (LinkEntry && (Arc.FileHead.RedirType!=FSREDIR_FILECOPY))\n    {\n      if (ExtrFile && Command!='P' && !Cmd->Test)\n      {\n        // Overwrite prompt for symbolic and hard links and when we move\n        // a temporary file to the file reference instead of copying it.\n        bool UserReject=false;\n        if (FileExist(DestFileName) && !UserReject)\n          FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n        if (UserReject)\n          ExtrFile=false;\n      }\n    }\n    else\n      if (Arc.IsArcDir())\n      {\n        if (!ExtrFile || Command=='P' || Command=='I' || Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n          return true;\n        TotalFileCount++;\n        ExtrCreateDir(Arc,ArcFileName);\n        // It is important to not increment MatchedArgs here, so we extract\n        // dir with its entire contents and not dir record only even if\n        // dir record precedes files.\n        return true;\n      }\n      else\n        if (ExtrFile) // Create files and file copies (FSREDIR_FILECOPY).\n          ExtrFile=ExtrCreateFile(Arc,CurFile);\n\n    if (!ExtrFile && Arc.Solid)\n    {\n      SkipSolid=true;\n      ExtrFile=true;\n\n      // We changed SkipSolid, so we need to call uiStartFileExtract\n      // with \"Skip\" parameter to change the operation status \n      // from \"extracting\" to \"skipping\". For example, it can be necessary\n      // if user answered \"No\" to overwrite prompt when unpacking\n      // a solid archive.\n      if (!uiStartFileExtract(ArcFileName,false,false,true))\n        return false;\n    }\n    if (ExtrFile)\n    {\n      // Set it in test mode, so we also test subheaders such as NTFS streams\n      // after tested file.\n      if (Cmd->Test)\n        PrevProcessed=true;\n\n      bool TestMode=Cmd->Test || SkipSolid; // Unpack to memory, not to disk.\n\n      if (!SkipSolid)\n      {\n        if (!TestMode && Command!='P' && CurFile.IsDevice())\n        {\n          uiMsg(UIERROR_INVALIDNAME,Arc.FileName,DestFileName);\n          ErrHandler.WriteError(Arc.FileName,DestFileName);\n        }\n        TotalFileCount++;\n      }\n      FileCount++;\n      if (Command!='I' && !Cmd->DisableNames)\n        if (SkipSolid)\n          mprintf(St(MExtrSkipFile),ArcFileName);\n        else\n          switch(Cmd->Test ? 'T':Command) // \"Test\" can be also enabled by -t switch.\n          {\n            case 'T':\n              mprintf(St(MExtrTestFile),ArcFileName);\n              break;\n#ifndef SFX_MODULE\n            case 'P':\n              mprintf(St(MExtrPrinting),ArcFileName);\n              break;\n#endif\n            case 'X':\n            case 'E':\n              mprintf(St(MExtrFile),DestFileName);\n              break;\n          }\n      if (!Cmd->DisablePercentage && !Cmd->DisableNames)\n        mprintf(L\"     \");\n      if (Cmd->DisableNames)\n        uiEolAfterMsg(); // Avoid erasing preceding messages by percentage indicator in -idn mode.\n\n      DataIO.CurUnpRead=0;\n      DataIO.CurUnpWrite=0;\n      DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.PackedDataHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.SetPackedSizeToRead(Arc.FileHead.PackSize);\n      DataIO.SetFiles(&Arc,&CurFile);\n      DataIO.SetTestMode(TestMode);\n      DataIO.SetSkipUnpCRC(SkipSolid);\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n      if (!TestMode && !Arc.BrokenHeader &&\n          Arc.FileHead.UnpSize>0xffffffff && (Fat32 || !NotFat32))\n      {\n        if (!Fat32) // Not detected yet.\n          NotFat32=!(Fat32=IsFAT(Cmd->ExtrPath));\n        if (Fat32)\n          uiMsg(UIMSG_FAT32SIZE); // Inform user about FAT32 size limit.\n      }\n#endif\n\n      uint64 Preallocated=0;\n      if (!TestMode && !Arc.BrokenHeader && Arc.FileHead.UnpSize>1000000 &&\n          Arc.FileHead.PackSize*1024>Arc.FileHead.UnpSize && Arc.IsSeekable() &&\n          (Arc.FileHead.UnpSize<100000000 || Arc.FileLength()>Arc.FileHead.PackSize))\n      {\n        CurFile.Prealloc(Arc.FileHead.UnpSize);\n        Preallocated=Arc.FileHead.UnpSize;\n      }\n      CurFile.SetAllowDelete(!Cmd->KeepBroken);\n\n      bool FileCreateMode=!TestMode && !SkipSolid && Command!='P';\n      bool ShowChecksum=true; // Display checksum verification result.\n\n      bool LinkSuccess=true; // Assume success for test mode.\n      if (LinkEntry)\n      {\n        FILE_SYSTEM_REDIRECT Type=Arc.FileHead.RedirType;\n\n        if (Type==FSREDIR_HARDLINK || Type==FSREDIR_FILECOPY)\n        {\n          wchar RedirName[NM];\n          ConvertPath(Arc.FileHead.RedirName,RedirName,ASIZE(RedirName));\n\n          wchar NameExisting[NM];\n          ExtrPrepareName(Arc,RedirName,NameExisting,ASIZE(NameExisting));\n          if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.\n            if (Type==FSREDIR_HARDLINK)\n              LinkSuccess=ExtractHardlink(Cmd,DestFileName,NameExisting,ASIZE(NameExisting));\n            else\n              LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,RedirName,DestFileName,NameExisting,ASIZE(NameExisting),Arc.FileHead.UnpSize);\n        }\n        else\n          if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)\n          {\n            if (FileCreateMode)\n              LinkSuccess=ExtractSymlink(Cmd,DataIO,Arc,DestFileName);\n          }\n          else\n          {\n            uiMsg(UIERROR_UNKNOWNEXTRA,Arc.FileName,ArcFileName);\n            LinkSuccess=false;\n          }\n          \n          if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)\n          {\n            // RAR 5.x links have a valid data checksum even in case of\n            // failure, because they do not store any data.\n            // We do not want to display \"OK\" in this case.\n            // For 4.x symlinks we verify the checksum only when extracting,\n            // but not when testing an archive.\n            ShowChecksum=false;\n          }\n          PrevProcessed=FileCreateMode && LinkSuccess;\n      }\n      else\n        if (!Arc.FileHead.SplitBefore)\n          if (Arc.FileHead.Method==0)\n            UnstoreFile(DataIO,Arc.FileHead.UnpSize);\n          else\n          {\n            Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);\n            Unp->SetDestSize(Arc.FileHead.UnpSize);\n#ifndef SFX_MODULE\n            if (Arc.Format!=RARFMT50 && Arc.FileHead.UnpVer<=15)\n              Unp->DoUnpack(15,FileCount>1 && Arc.Solid);\n            else\n#endif\n              Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);\n          }\n\n      Arc.SeekToNext();\n\n      // We check for \"split after\" flag to detect partially extracted files\n      // from incomplete volume sets. For them file header contains packed\n      // data hash, which must not be compared against unpacked data hash\n      // to prevent accidental match. Moreover, for -m0 volumes packed data\n      // hash would match truncated unpacked data hash and lead to fake \"OK\"\n      // in incomplete volume set.\n      bool ValidCRC=!Arc.FileHead.SplitAfter && DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL);\n\n      // We set AnySolidDataUnpackedWell to true if we found at least one\n      // valid non-zero solid file in preceding solid stream. If it is true\n      // and if current encrypted file is broken, we do not need to hint\n      // about a wrong password and can report CRC error only.\n      if (!Arc.FileHead.Solid)\n        AnySolidDataUnpackedWell=false; // Reset the flag, because non-solid file is found.\n      else\n        if (Arc.FileHead.Method!=0 && Arc.FileHead.UnpSize>0 && ValidCRC)\n          AnySolidDataUnpackedWell=true;\n \n      bool BrokenFile=false;\n      \n      // Checksum is not calculated in skip solid mode for performance reason.\n      if (!SkipSolid && ShowChecksum)\n      {\n        if (ValidCRC)\n        {\n          if (Command!='P' && Command!='I' && !Cmd->DisableNames)\n            mprintf(L\"%s%s \",Cmd->DisablePercentage ? L\" \":L\"\\b\\b\\b\\b\\b \",\n              Arc.FileHead.FileHash.Type==HASH_NONE ? L\"  ?\":St(MOk));\n        }\n        else\n        {\n          if (Arc.FileHead.Encrypted && (!Arc.FileHead.UsePswCheck || \n              Arc.BrokenHeader) && !AnySolidDataUnpackedWell)\n            uiMsg(UIERROR_CHECKSUMENC,Arc.FileName,ArcFileName);\n          else\n            uiMsg(UIERROR_CHECKSUM,Arc.FileName,ArcFileName);\n          BrokenFile=true;\n          ErrHandler.SetErrorCode(RARX_CRC);\n#ifdef RARDLL\n          // If we already have ERAR_EOPEN as result of missing volume\n          // or ERAR_BAD_PASSWORD for RAR5 wrong password,\n          // we should not replace it with less precise ERAR_BAD_DATA.\n          if (Cmd->DllError!=ERAR_EOPEN && Cmd->DllError!=ERAR_BAD_PASSWORD)\n            Cmd->DllError=ERAR_BAD_DATA;\n#endif\n        }\n      }\n      else\n      {\n        // We check SkipSolid to remove percent for skipped solid files only.\n        // We must not apply these \\b to links with ShowChecksum==false\n        // and their possible error messages.\n        if (SkipSolid) \n          mprintf(L\"\\b\\b\\b\\b\\b     \");\n      }\n\n      // If we successfully unpacked a hard link, we wish to set its file\n      // attributes. Hard link shares file metadata with link target,\n      // so we do not need to set link time or owner. But when we overwrite\n      // an existing link, we can call PrepareToDelete(), which affects\n      // link target attributes as well. So we set link attributes to restore\n      // both target and link attributes if PrepareToDelete() changed them.\n      bool SetAttrOnly=LinkEntry && Arc.FileHead.RedirType==FSREDIR_HARDLINK && LinkSuccess;\n\n      if (!TestMode && (Command=='X' || Command=='E') &&\n          (!LinkEntry || SetAttrOnly || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && \n          (!BrokenFile || Cmd->KeepBroken))\n      {\n        // Below we use DestFileName instead of CurFile.FileName,\n        // so we can set file attributes also for hard links, which do not\n        // have the open CurFile. These strings are the same for other items.\n\n        if (!SetAttrOnly)\n        {\n          // We could preallocate more space that really written to broken file\n          // or file with crafted header.\n          if (Preallocated>0 && (BrokenFile || DataIO.CurUnpWrite!=Preallocated))\n            CurFile.Truncate();\n\n\n          CurFile.SetOpenFileTime(\n            Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n            Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n            Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n          CurFile.Close();\n\n          SetFileHeaderExtra(Cmd,Arc,DestFileName);\n\n          CurFile.SetCloseFileTime(\n            Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n            Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n        }\n        \n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n        if (Cmd->SetCompressedAttr &&\n            (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0)\n          SetFileCompression(DestFileName,true);\n        if (Cmd->ClearArc)\n          Arc.FileHead.FileAttr&=~FILE_ATTRIBUTE_ARCHIVE;\n#endif\n        if (!Cmd->IgnoreGeneralAttr && !SetFileAttr(DestFileName,Arc.FileHead.FileAttr))\n        {\n          uiMsg(UIERROR_FILEATTR,Arc.FileName,DestFileName);\n          // Android cannot set file attributes and while UIERROR_FILEATTR\n          // above is handled by Android RAR silently, this call would cause\n          // \"Operation not permitted\" message for every unpacked file.\n          ErrHandler.SysErrMsg();\n        }\n\n        PrevProcessed=true;\n      }\n    }\n  }\n  // It is important to increment it for files, but not dirs. So we extract\n  // dir with its entire contents, not just dir record only even if dir\n  // record precedes files.\n  if (MatchFound)\n    MatchedArgs++;\n  if (DataIO.NextVolumeMissing)\n    return false;\n  if (!ExtrFile)\n    if (!Arc.Solid)\n      Arc.SeekToNext();\n    else\n      if (!SkipSolid)\n        return false;\n  return true;\n}\n\n\nvoid CmdExtract::UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize)\n{\n  Array<byte> Buffer(File::CopyBufferSize());\n  while (true)\n  {\n    int ReadSize=DataIO.UnpRead(&Buffer[0],Buffer.Size());\n    if (ReadSize<=0)\n      break;\n    int WriteSize=ReadSize<DestUnpSize ? ReadSize:(int)DestUnpSize;\n    if (WriteSize>0)\n    {\n      DataIO.UnpWrite(&Buffer[0],WriteSize);\n      DestUnpSize-=WriteSize;\n    }\n  }\n}\n\n\nbool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); // Not needed for RAR 5.1+ archives.\n\n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    // If we couldn't find the existing file, check if match is present\n    // in temporary reference sources list.\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        // If only one reference left targeting to this temporary file,\n        // it is faster to move the file instead of copying and deleting it.\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) // Only one reference left for this temporary file.\n        {\n          New.Delete(); // Delete the previously opened destination file.\n          // Try moving the file first.\n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            // If move failed, re-create the destination and try coping.\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; // Try copying below.\n          }\n          else\n          {\n            // If moved successfully, reopen the destination file and seek to\n            // end for SetOpenFileTime() and possible Truncate() calls later.\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            // We already moved the file, so clean the name to not try\n            // deleting non-existent temporary file later.\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    // Update only the current file progress in WinRAR, set the total to 0\n    // to keep it as is. It looks better for WinRAR.\n    uiExtractProgress(CopySize,UnpSize,0,0);\n\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n\n  return true;\n}\n\n\nvoid CmdExtract::ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *DestName,size_t DestSize)\n{\n  if (Cmd->Test)\n  {\n    // Destination name conversion isn't needed for simple archive test.\n    // This check also allows to avoid issuing \"Attempting to correct...\n    // Renaming...\" messages in MakeNameCompatible() below for problematic\n    // names like aux.txt when testing an archive.\n    wcsncpyz(DestName,ArcFileName,DestSize);\n    return;\n  }\n  \n  wcsncpyz(DestName,Cmd->ExtrPath,DestSize);\n\n  if (*Cmd->ExtrPath!=0)\n  {\n     wchar LastChar=*PointToLastChar(Cmd->ExtrPath);\n    // We need IsPathDiv check here to correctly handle Unix forward slash\n    // in the end of destination path in Windows: rar x arc dest/\n    // so we call IsPathDiv first instead of just calling AddEndSlash,\n    // which checks for only one type of path separator.\n    // IsDriveDiv is needed for current drive dir: rar x arc d:\n    if (!IsPathDiv(LastChar) && !IsDriveDiv(LastChar))\n    {\n      // Destination path can be without trailing slash if it come from GUI shell.\n      AddEndSlash(DestName,DestSize);\n    }\n  }\n\n#ifndef SFX_MODULE\n  if (Cmd->AppendArcNameToPath!=APPENDARCNAME_NONE)\n  {\n    switch(Cmd->AppendArcNameToPath)\n    {\n      case APPENDARCNAME_DESTPATH: // To subdir of destination path.\n        wcsncatz(DestName,PointToName(Arc.FirstVolumeName),DestSize);\n        SetExt(DestName,NULL,DestSize);\n        break;\n      case APPENDARCNAME_OWNSUBDIR: // To subdir of archive own dir.\n        wcsncpyz(DestName,Arc.FirstVolumeName,DestSize);\n        SetExt(DestName,NULL,DestSize);\n        break;\n      case APPENDARCNAME_OWNDIR:  // To archive own dir.\n        wcsncpyz(DestName,Arc.FirstVolumeName,DestSize);\n        RemoveNameFromPath(DestName);\n        break;\n    }\n    AddEndSlash(DestName,DestSize);\n  }\n#endif\n\n#ifndef SFX_MODULE\n  wchar *ArcPath=*Cmd->ExclArcPath!=0 ? Cmd->ExclArcPath:Cmd->ArcPath;\n  size_t ArcPathLength=wcslen(ArcPath);\n  if (ArcPathLength>0)\n  {\n    size_t NameLength=wcslen(ArcFileName);\n    if (NameLength>=ArcPathLength &&  wcsnicompc(ArcPath,ArcFileName,ArcPathLength)==0 &&\n        (IsPathDiv(ArcPath[ArcPathLength-1]) || \n         IsPathDiv(ArcFileName[ArcPathLength]) || ArcFileName[ArcPathLength]==0))\n    {\n      ArcFileName+=Min(ArcPathLength,NameLength);\n      while (IsPathDiv(*ArcFileName))\n        ArcFileName++;\n      if (*ArcFileName==0) // Excessive -ap switch.\n      {\n        *DestName=0;\n        return;\n      }\n    }\n  }\n#endif\n\n  wchar Command=Cmd->Command[0];\n  // Use -ep3 only in systems, where disk letters are exist, not in Unix.\n  bool AbsPaths=Cmd->ExclPath==EXCL_ABSPATH && Command=='X' && IsDriveDiv(':');\n\n  // We do not use any user specified destination paths when extracting\n  // absolute paths in -ep3 mode.\n  if (AbsPaths)\n    *DestName=0;\n\n  if (Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n    wcsncatz(DestName,PointToName(ArcFileName),DestSize);\n  else\n    wcsncatz(DestName,ArcFileName,DestSize);\n\n#ifdef _WIN_ALL\n  // Must do after Cmd->ArcPath processing above, so file name and arc path\n  // trailing spaces are in sync.\n  if (!Cmd->AllowIncompatNames)\n    MakeNameCompatible(DestName,DestSize);\n#endif\n\n  wchar DiskLetter=toupperw(DestName[0]);\n\n  if (AbsPaths)\n  {\n    if (DestName[1]=='_' && IsPathDiv(DestName[2]) &&\n        DiskLetter>='A' && DiskLetter<='Z')\n      DestName[1]=':';\n    else\n      if (DestName[0]=='_' && DestName[1]=='_')\n      {\n        // Convert __server\\share to \\\\server\\share.\n        DestName[0]=CPATHDIVIDER;\n        DestName[1]=CPATHDIVIDER;\n      }\n  }\n}\n\n\n#ifdef RARDLL\nbool CmdExtract::ExtrDllGetPassword()\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n      Cmd->ManualPassword=true;\n    }\n    if (!Cmd->Password.IsSet())\n      return false;\n  }\n  return true;\n}\n#endif\n\n\n#ifndef RARDLL\nbool CmdExtract::ExtrGetPassword(Archive &Arc,const wchar *ArcFileName,RarCheckPassword *CheckPwd)\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password,CheckPwd)/* || !Cmd->Password.IsSet()*/)\n    {\n      // Suppress \"test is ok\" message if user cancelled the password prompt.\n      uiMsg(UIERROR_INCERRCOUNT);\n      return false;\n    }\n    Cmd->ManualPassword=true;\n  }\n#if !defined(SILENT)\n  else\n    if (!GlobalPassword && !Arc.FileHead.Solid)\n    {\n      eprintf(St(MUseCurPsw),ArcFileName);\n      switch(Cmd->AllYes ? 1 : Ask(St(MYesNoAll)))\n      {\n        case -1:\n          ErrHandler.Exit(RARX_USERBREAK);\n        case 2:\n          if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password,CheckPwd))\n            return false;\n          break;\n        case 3:\n          GlobalPassword=true;\n          break;\n      }\n    }\n#endif\n  return true;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid CmdExtract::ConvertDosPassword(Archive &Arc,SecPassword &DestPwd)\n{\n  if (Arc.Format==RARFMT15 && Arc.FileHead.HostOS==HOST_MSDOS)\n  {\n    // We need the password in OEM encoding if file was encrypted by\n    // native RAR/DOS (not extender based). Let's make the conversion.\n    wchar PlainPsw[MAXPASSWORD];\n    Cmd->Password.Get(PlainPsw,ASIZE(PlainPsw));\n    char PswA[MAXPASSWORD];\n    CharToOemBuffW(PlainPsw,PswA,ASIZE(PswA));\n    PswA[ASIZE(PswA)-1]=0;\n    CharToWide(PswA,PlainPsw,ASIZE(PlainPsw));\n    DestPwd.Set(PlainPsw);\n    cleandata(PlainPsw,sizeof(PlainPsw));\n    cleandata(PswA,sizeof(PswA));\n  }\n}\n#endif\n\n\nvoid CmdExtract::ExtrCreateDir(Archive &Arc,const wchar *ArcFileName)\n{\n  if (Cmd->Test)\n  {\n    if (!Cmd->DisableNames)\n    {\n      mprintf(St(MExtrTestFile),ArcFileName);\n      mprintf(L\" %s\",St(MOk));\n    }\n    return;\n  }\n\n  MKDIR_CODE MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n  bool DirExist=false;\n  if (MDCode!=MKDIR_SUCCESS)\n  {\n    DirExist=FileExist(DestFileName);\n    if (DirExist && !IsDir(GetFileAttr(DestFileName)))\n    {\n      // File with name same as this directory exists. Propose user\n      // to overwrite it.\n      bool UserReject;\n      FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n      DirExist=false;\n    }\n    if (!DirExist)\n    {\n      CreatePath(DestFileName,true,Cmd->DisableNames);\n      MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n      if (MDCode!=MKDIR_SUCCESS && !IsNameUsable(DestFileName))\n      {\n        uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n        wchar OrigName[ASIZE(DestFileName)];\n        wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n        MakeNameUsable(DestFileName,true);\n#ifndef SFX_MODULE\n        uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n        DirExist=FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName));\n        if (!DirExist)\n        {\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n        }\n      }\n    }\n  }\n  if (MDCode==MKDIR_SUCCESS)\n  {\n    if (!Cmd->DisableNames)\n    {\n      mprintf(St(MCreatDir),DestFileName);\n      mprintf(L\" %s\",St(MOk));\n    }\n    PrevProcessed=true;\n  }\n  else\n    if (DirExist)\n    {\n      if (!Cmd->IgnoreGeneralAttr)\n        SetFileAttr(DestFileName,Arc.FileHead.FileAttr);\n      PrevProcessed=true;\n    }\n    else\n    {\n      uiMsg(UIERROR_DIRCREATE,Arc.FileName,DestFileName);\n      ErrHandler.SysErrMsg();\n#ifdef RARDLL\n      Cmd->DllError=ERAR_ECREATE;\n#endif\n      ErrHandler.SetErrorCode(RARX_CREATE);\n    }\n  if (PrevProcessed)\n  {\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    if (Cmd->SetCompressedAttr &&\n        (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0 && WinNT()!=WNT_NONE)\n      SetFileCompression(DestFileName,true);\n#endif\n    SetFileHeaderExtra(Cmd,Arc,DestFileName);\n    SetDirTime(DestFileName,\n      Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n      Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n      Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n  }\n}\n\n\nbool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    // Specify \"write only\" mode to avoid OpenIndiana NAS problems\n    // with SetFileTime and read+write files.\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n\n          MakeNameUsable(DestFileName,true);\n\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}\n\n\nbool CmdExtract::CheckUnpVer(Archive &Arc,const wchar *ArcFileName)\n{\n  bool WrongVer;\n  if (Arc.Format==RARFMT50) // Both SFX and RAR can unpack RAR 5.0 archives.\n    WrongVer=Arc.FileHead.UnpVer>VER_UNPACK5;\n  else\n  {\n#ifdef SFX_MODULE   // SFX can unpack only RAR 2.9 archives.\n    WrongVer=Arc.FileHead.UnpVer!=VER_UNPACK;\n#else               // All formats since 1.3 for RAR.\n    WrongVer=Arc.FileHead.UnpVer<13 || Arc.FileHead.UnpVer>VER_UNPACK;\n#endif\n  }\n\n  // We can unpack stored files regardless of compression version field.\n  if (Arc.FileHead.Method==0)\n    WrongVer=false;\n\n  if (WrongVer)\n  {\n    ErrHandler.UnknownMethodMsg(Arc.FileName,ArcFileName);\n    uiMsg(UIERROR_NEWERRAR,Arc.FileName);\n  }\n  return !WrongVer;\n}\n\n\n#ifndef SFX_MODULE\n// Find non-matched reference sources in solid and non-solid archives.\n// Detect the optimal start position for semi-solid archives\n// and optimal start volume for independent solid volumes.\n// \n// Alternatively we could collect references while extracting an archive\n// and perform the second extraction pass for references only.\n// But it would be slower for solid archives than scaning headers\n// in first pass and extracting everything in second, as implemented now.\n// \nvoid CmdExtract::AnalyzeArchive(const wchar *ArcName,bool Volume,bool NewNumbering)\n{\n  ReleaseAnalyzeData(); // If processing non-first archive in multiple archives set.\n\n  wchar *ArgName=Cmd->FileArgs.GetString();\n  Cmd->FileArgs.Rewind();\n  if (ArgName!=NULL && (wcscmp(ArgName,L\"*\")==0 || wcscmp(ArgName,L\"*.*\")==0))\n    return; // No need to check further for * and *.* masks.\n\n  // Start search from first volume if all volumes preceding current are available.\n  wchar NextName[NM];\n  if (Volume)\n    GetFirstVolIfFullSet(ArcName,NewNumbering,NextName,ASIZE(NextName));\n  else\n    wcsncpyz(NextName,ArcName,ASIZE(NextName));\n  \n  bool MatchFound=false;\n  bool FirstVolume=true;\n  bool PrevMatched=false;\n  bool OpenNext=false;\n\n  while (true)\n  {\n    Archive Arc(Cmd);\n    if (!Arc.Open(NextName) || !Arc.IsArchive(false))\n    {\n      if (OpenNext)\n      {\n        // If we couldn't open trailing volumes, we can't set early exit\n        // parameters. It is possible that some volume are on removable media\n        // and will be provided by user when extracting.\n        *Analyze->EndName=0;\n        Analyze->EndPos=0;\n      }\n      break;\n    }\n\n    OpenNext=false;\n    bool FirstFile=true;\n    while (Arc.ReadHeader()>0)\n    {\n      Wait();\n\n      HEADER_TYPE HeaderType=Arc.GetHeaderType();\n      if (HeaderType==HEAD_ENDARC)\n      {\n        OpenNext|=Arc.EndArcHead.NextVolume; // Allow open next volume.\n        break;\n      }\n      if (HeaderType==HEAD_FILE)\n      {\n        if (!Arc.FileHead.SplitBefore)\n        {\n          if (!MatchFound && !Arc.FileHead.Solid) // Can start extraction from here.\n          {\n            if (!FirstVolume)\n              wcsncpyz(Analyze->StartName,NextName,ASIZE(Analyze->StartName));\n            if (!FirstFile)\n              Analyze->StartPos=Arc.CurBlockPos;\n          }\n          FirstFile=false;\n\n          if (Cmd->IsProcessFile(Arc.FileHead,NULL,MATCH_WILDSUBPATH,0,NULL,0)!=0)\n          {\n            MatchFound = true;\n            PrevMatched = true;\n\n            // Matched file reference pointing at maybe non-matched source file.\n            // Even though we know RedirName, we can't check if source file\n            // is certainly non-matched, because it can be filtered out by\n            // date or attributes, which we do not know here.\n            if (Arc.FileHead.RedirType==FSREDIR_FILECOPY)\n            {\n              bool AlreadyAdded=false;\n              for (size_t I=0;I<RefList.Size();I++)\n                if (wcscmp(Arc.FileHead.RedirName,RefList[I].RefName)==0)\n                {\n                  // Increment the reference count if we added such reference\n                  // source earlier.\n                  RefList[I].RefCount++;\n                  AlreadyAdded=true;\n                  break;\n                }\n\n              // Limit the maximum size of reference sources list to some\n              // sensible value to prevent the excessive memory allocation.\n              size_t MaxListSize=1000000;\n\n              if (!AlreadyAdded && RefList.Size()<MaxListSize)\n              {\n                ExtractRef Ref={0};\n                Ref.RefName=wcsdup(Arc.FileHead.RedirName);\n                Ref.RefCount=1;\n                RefList.Push(Ref);\n              }\n            }\n          }\n          else\n          {\n            if (PrevMatched) // First non-matched item after matched.\n            {\n              if (!FirstVolume)\n                wcsncpyz(Analyze->EndName,NextName,ASIZE(Analyze->EndName));\n              if (!FirstFile)\n                Analyze->EndPos=Arc.CurBlockPos;\n            }\n            PrevMatched=false;\n          }\n        }\n        if (Arc.FileHead.SplitAfter)\n        {\n          OpenNext=true; // Allow open next volume.\n          break;\n        }\n      }\n      Arc.SeekToNext();\n    }\n    Arc.Close();\n\n    if (Volume && OpenNext)\n    {\n      NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n      FirstVolume=false;\n    }\n    else\n      break;\n  }\n\n  // If file references are present, we can't reliably skip in semi-solid\n  // archives, because reference source can be present in skipped data.\n  if (RefList.Size()!=0)\n    memset(Analyze,0,sizeof(*Analyze));\n}\n#endif\n\n\n#ifndef SFX_MODULE\n// Return the first volume name if all volumes preceding the specified\n// are available. Otherwise return the specified volume name.\nvoid CmdExtract::GetFirstVolIfFullSet(const wchar *SrcName,bool NewNumbering,wchar *DestName,size_t DestSize)\n{\n  wchar FirstVolName[NM];\n  VolNameToFirstName(SrcName,FirstVolName,ASIZE(FirstVolName),NewNumbering);\n  wchar NextName[NM];\n  wcsncpyz(NextName,FirstVolName,ASIZE(NextName));\n  wchar ResultName[NM];\n  wcsncpyz(ResultName,SrcName,ASIZE(ResultName));\n  while (true)\n  {\n    if (wcscmp(SrcName,NextName)==0)\n    {\n      wcsncpyz(ResultName,FirstVolName,DestSize);\n      break;\n    }\n    if (!FileExist(NextName))\n      break;\n    NextVolumeName(NextName,ASIZE(NextName),!NewNumbering);\n  }\n  wcsncpyz(DestName,ResultName,DestSize);\n}\n\n#endif", "#ifndef _RAR_EXTRACT_\n#define _RAR_EXTRACT_\n\nenum EXTRACT_ARC_CODE {EXTRACT_ARC_NEXT,EXTRACT_ARC_REPEAT};\n\nclass CmdExtract\n{\n  private:\n    struct ExtractRef\n    {\n      wchar *RefName;\n      wchar *TmpName;\n      uint64 RefCount;\n    };\n    Array<ExtractRef> RefList;\n\n    struct AnalyzeData\n    {\n      wchar StartName[NM];\n      uint64 StartPos;\n      wchar EndName[NM];\n      uint64 EndPos;\n    } *Analyze;\n\n    bool ArcAnalyzed;\n\n    void ReleaseAnalyzeData();\n    EXTRACT_ARC_CODE ExtractArchive();\n    bool ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize);\n    void ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *DestName,size_t DestSize);\n#ifdef RARDLL\n    bool ExtrDllGetPassword();\n#else\n    bool ExtrGetPassword(Archive &Arc,const wchar *ArcFileName,RarCheckPassword *CheckPwd);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    void ConvertDosPassword(Archive &Arc,SecPassword &DestPwd);\n#endif\n    void ExtrCreateDir(Archive &Arc,const wchar *ArcFileName);\n    bool ExtrCreateFile(Archive &Arc,File &CurFile);\n    bool CheckUnpVer(Archive &Arc,const wchar *ArcFileName);\n#ifndef SFX_MODULE\n    void AnalyzeArchive(const wchar *ArcName,bool Volume,bool NewNumbering);\n    void GetFirstVolIfFullSet(const wchar *SrcName,bool NewNumbering,wchar *DestName,size_t DestSize);\n#endif\n\n    RarTime StartTime; // Time when extraction started.\n\n    CommandData *Cmd;\n\n    ComprDataIO DataIO;\n    Unpack *Unp;\n    unsigned long TotalFileCount;\n\n    unsigned long FileCount;\n    unsigned long MatchedArgs;\n    bool FirstFile;\n    bool AllMatchesExact;\n    bool ReconstructDone;\n    bool UseExactVolName;\n\n    // If any non-zero solid file was successfully unpacked before current.\n    // If true and if current encrypted file is broken, obviously\n    // the password is correct and we can report broken CRC without\n    // any wrong password hints.\n    bool AnySolidDataUnpackedWell;\n\n    wchar ArcName[NM];\n\n    bool GlobalPassword;\n    bool PrevProcessed; // If previous file was successfully extracted or tested.\n    wchar DestFileName[NM];\n    bool PasswordCancelled;\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n    bool Fat32,NotFat32;\n#endif\n  public:\n    CmdExtract(CommandData *Cmd);\n    ~CmdExtract();\n    void DoExtract();\n    void ExtractArchiveInit(Archive &Arc);\n    bool ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat);\n    static void UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize);\n};\n\n#endif\n", "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); // Not needed for RAR 5.1+ archives.\n\n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}\n\n", "/****************************************************************************\n *  This file is part of PPMd project                                       *\n *  Written and distributed to public domain by Dmitry Shkarin 1997,        *\n *  1999-2000                                                               *\n *  Contents: model description and encoding/decoding routines              *\n ****************************************************************************/\n\nstatic const int MAX_O=64; /* maximum allowed model order */\nconst uint TOP=1 << 24, BOT=1 << 15;\n\ntemplate <class T>\ninline void _PPMD_SWAP(T& t1,T& t2) { T tmp=t1; t1=t2; t2=tmp; }\n\n\ninline RARPPM_CONTEXT* RARPPM_CONTEXT::createChild(ModelPPM *Model,RARPPM_STATE* pStats,\n                                             RARPPM_STATE& FirstState)\n{\n  RARPPM_CONTEXT* pc = (RARPPM_CONTEXT*) Model->SubAlloc.AllocContext();\n  if ( pc ) \n  {\n    pc->NumStats=1;                     \n    pc->OneState=FirstState;\n    pc->Suffix=this;                    \n    pStats->Successor=pc;\n  }\n  return pc;\n}\n\n\nModelPPM::ModelPPM()\n{\n  MinContext=NULL;\n  MaxContext=NULL;\n  MedContext=NULL;\n}\n\n\nvoid ModelPPM::RestartModelRare()\n{\n  int i, k, m;\n  memset(CharMask,0,sizeof(CharMask));\n  SubAlloc.InitSubAllocator();\n  InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;\n  MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();\n  if (MinContext == NULL)\n    throw std::bad_alloc();\n  MinContext->Suffix=NULL;\n  OrderFall=MaxOrder;\n  MinContext->U.SummFreq=(MinContext->NumStats=256)+1;\n  FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);\n  if (FoundState == NULL)\n    throw std::bad_alloc();\n  for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) \n  {\n    MinContext->U.Stats[i].Symbol=i;      \n    MinContext->U.Stats[i].Freq=1;\n    MinContext->U.Stats[i].Successor=NULL;\n  }\n  \n  static const ushort InitBinEsc[]={\n    0x3CDD,0x1F3F,0x59BF,0x48F3,0x64A1,0x5ABC,0x6632,0x6051\n  };\n\n  for (i=0;i < 128;i++)\n    for (k=0;k < 8;k++)\n      for (m=0;m < 64;m += 8)\n        BinSumm[i][k+m]=BIN_SCALE-InitBinEsc[k]/(i+2);\n  for (i=0;i < 25;i++)\n    for (k=0;k < 16;k++)            \n      SEE2Cont[i][k].init(5*i+10);\n}\n\n\nvoid ModelPPM::StartModelRare(int MaxOrder)\n{\n  int i, k, m ,Step;\n  EscCount=1;\n/*\n  if (MaxOrder < 2) \n  {\n    memset(CharMask,0,sizeof(CharMask));\n    OrderFall=ModelPPM::MaxOrder;\n    MinContext=MaxContext;\n    while (MinContext->Suffix != NULL)\n    {\n      MinContext=MinContext->Suffix;\n      OrderFall--;\n    }\n    FoundState=MinContext->U.Stats;\n    MinContext=MaxContext;\n  } \n  else \n*/\n  {\n    ModelPPM::MaxOrder=MaxOrder;\n    RestartModelRare();\n    NS2BSIndx[0]=2*0;\n    NS2BSIndx[1]=2*1;\n    memset(NS2BSIndx+2,2*2,9);\n    memset(NS2BSIndx+11,2*3,256-11);\n    for (i=0;i < 3;i++)\n      NS2Indx[i]=i;\n    for (m=i, k=Step=1;i < 256;i++) \n    {\n      NS2Indx[i]=m;\n      if ( !--k ) \n      { \n        k = ++Step;\n        m++; \n      }\n    }\n    memset(HB2Flag,0,0x40);\n    memset(HB2Flag+0x40,0x08,0x100-0x40);\n    DummySEE2Cont.Shift=PERIOD_BITS;\n  }\n}\n\n\nvoid RARPPM_CONTEXT::rescale(ModelPPM *Model)\n{\n  int OldNS=NumStats, i=NumStats-1, Adder, EscFreq;\n  RARPPM_STATE* p1, * p;\n  for (p=Model->FoundState;p != U.Stats;p--)\n    _PPMD_SWAP(p[0],p[-1]);\n  U.Stats->Freq += 4;\n  U.SummFreq += 4;\n  EscFreq=U.SummFreq-p->Freq;\n  Adder=(Model->OrderFall != 0);\n  U.SummFreq = (p->Freq=(p->Freq+Adder) >> 1);\n  do \n  {\n    EscFreq -= (++p)->Freq;\n    U.SummFreq += (p->Freq=(p->Freq+Adder) >> 1);\n    if (p[0].Freq > p[-1].Freq) \n    {\n      RARPPM_STATE tmp=*(p1=p);\n      do \n      { \n        p1[0]=p1[-1]; \n      } while (--p1 != U.Stats && tmp.Freq > p1[-1].Freq);\n      *p1=tmp;\n    }\n  } while ( --i );\n  if (p->Freq == 0) \n  {\n    do \n    { \n      i++; \n    } while ((--p)->Freq == 0);\n    EscFreq += i;\n    if ((NumStats -= i) == 1) \n    {\n      RARPPM_STATE tmp=*U.Stats;\n      do \n      { \n        tmp.Freq-=(tmp.Freq >> 1); \n        EscFreq>>=1; \n      } while (EscFreq > 1);\n      Model->SubAlloc.FreeUnits(U.Stats,(OldNS+1) >> 1);\n      *(Model->FoundState=&OneState)=tmp;  return;\n    }\n  }\n  U.SummFreq += (EscFreq -= (EscFreq >> 1));\n  int n0=(OldNS+1) >> 1, n1=(NumStats+1) >> 1;\n  if (n0 != n1)\n    U.Stats = (RARPPM_STATE*) Model->SubAlloc.ShrinkUnits(U.Stats,n0,n1);\n  Model->FoundState=U.Stats;\n}\n\n\ninline RARPPM_CONTEXT* ModelPPM::CreateSuccessors(bool Skip,RARPPM_STATE* p1)\n{\n  RARPPM_STATE UpState;\n  RARPPM_CONTEXT* pc=MinContext, * UpBranch=FoundState->Successor;\n  RARPPM_STATE * p, * ps[MAX_O], ** pps=ps;\n  if ( !Skip ) \n  {\n    *pps++ = FoundState;\n    if ( !pc->Suffix )\n      goto NO_LOOP;\n  }\n  if ( p1 ) \n  {\n    p=p1;\n    pc=pc->Suffix;\n    goto LOOP_ENTRY;\n  }\n  do \n  {\n    pc=pc->Suffix;\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != FoundState->Symbol)\n        do \n        {\n          p++; \n        } while (p->Symbol != FoundState->Symbol);\n    } \n    else\n      p=&(pc->OneState);\nLOOP_ENTRY:\n    if (p->Successor != UpBranch) \n    {\n      pc=p->Successor;\n      break;\n\n    }\n    // We ensure that PPM order input parameter does not exceed MAX_O (64),\n    // so we do not really need this check and added it for extra safety.\n    // See CVE-2017-17969 for details.\n    if (pps>=ps+ASIZE(ps))\n      return NULL;\n\n    *pps++ = p;\n  } while ( pc->Suffix );\nNO_LOOP:\n  if (pps == ps)\n    return pc;\n  UpState.Symbol=*(byte*) UpBranch;\n  UpState.Successor=(RARPPM_CONTEXT*) (((byte*) UpBranch)+1);\n  if (pc->NumStats != 1) \n  {\n    if ((byte*) pc <= SubAlloc.pText)\n      return(NULL);\n    if ((p=pc->U.Stats)->Symbol != UpState.Symbol)\n    do \n    { \n      p++; \n    } while (p->Symbol != UpState.Symbol);\n    uint cf=p->Freq-1;\n    uint s0=pc->U.SummFreq-pc->NumStats-cf;\n    UpState.Freq=1+((2*cf <= s0)?(5*cf > s0):((2*cf+3*s0-1)/(2*s0)));\n  } \n  else\n    UpState.Freq=pc->OneState.Freq;\n  do \n  {\n    pc = pc->createChild(this,*--pps,UpState);\n    if ( !pc )\n      return NULL;\n  } while (pps != ps);\n  return pc;\n}\n\n\ninline void ModelPPM::UpdateModel()\n{\n  RARPPM_STATE fs = *FoundState, *p = NULL;\n  RARPPM_CONTEXT *pc, *Successor;\n  uint ns1, ns, cf, sf, s0;\n  if (fs.Freq < MAX_FREQ/4 && (pc=MinContext->Suffix) != NULL) \n  {\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != fs.Symbol) \n      {\n        do \n        { \n          p++; \n        } while (p->Symbol != fs.Symbol);\n        if (p[0].Freq >= p[-1].Freq) \n        {\n          _PPMD_SWAP(p[0],p[-1]); \n          p--;\n        }\n      }\n      if (p->Freq < MAX_FREQ-9) \n      {\n        p->Freq += 2;               \n        pc->U.SummFreq += 2;\n      }\n    } \n    else \n    {\n      p=&(pc->OneState);\n      p->Freq += (p->Freq < 32);\n    }\n  }\n  if ( !OrderFall ) \n  {\n    MinContext=MaxContext=FoundState->Successor=CreateSuccessors(TRUE,p);\n    if ( !MinContext )\n      goto RESTART_MODEL;\n    return;\n  }\n  *SubAlloc.pText++ = fs.Symbol;                   \n  Successor = (RARPPM_CONTEXT*) SubAlloc.pText;\n  if (SubAlloc.pText >= SubAlloc.FakeUnitsStart)                \n    goto RESTART_MODEL;\n  if ( fs.Successor ) \n  {\n    if ((byte*) fs.Successor <= SubAlloc.pText &&\n        (fs.Successor=CreateSuccessors(FALSE,p)) == NULL)\n      goto RESTART_MODEL;\n    if ( !--OrderFall ) \n    {\n      Successor=fs.Successor;\n      SubAlloc.pText -= (MaxContext != MinContext);\n    }\n  } \n  else \n  {\n    FoundState->Successor=Successor;\n    fs.Successor=MinContext;\n  }\n  s0=MinContext->U.SummFreq-(ns=MinContext->NumStats)-(fs.Freq-1);\n  for (pc=MaxContext;pc != MinContext;pc=pc->Suffix) \n  {\n    if ((ns1=pc->NumStats) != 1) \n    {\n      if ((ns1 & 1) == 0) \n      {\n        pc->U.Stats=(RARPPM_STATE*) SubAlloc.ExpandUnits(pc->U.Stats,ns1 >> 1);\n        if ( !pc->U.Stats )           \n          goto RESTART_MODEL;\n      }\n      pc->U.SummFreq += (2*ns1 < ns)+2*((4*ns1 <= ns) & (pc->U.SummFreq <= 8*ns1));\n    } \n    else \n    {\n      p=(RARPPM_STATE*) SubAlloc.AllocUnits(1);\n      if ( !p )\n        goto RESTART_MODEL;\n      *p=pc->OneState;\n      pc->U.Stats=p;\n      if (p->Freq < MAX_FREQ/4-1)\n        p->Freq += p->Freq;\n      else\n        p->Freq  = MAX_FREQ-4;\n      pc->U.SummFreq=p->Freq+InitEsc+(ns > 3);\n    }\n    cf=2*fs.Freq*(pc->U.SummFreq+6);\n    sf=s0+pc->U.SummFreq;\n    if (cf < 6*sf) \n    {\n      cf=1+(cf > sf)+(cf >= 4*sf);\n      pc->U.SummFreq += 3;\n    }\n    else \n    {\n      cf=4+(cf >= 9*sf)+(cf >= 12*sf)+(cf >= 15*sf);\n      pc->U.SummFreq += cf;\n    }\n    p=pc->U.Stats+ns1;\n    p->Successor=Successor;\n    p->Symbol = fs.Symbol;\n    p->Freq = cf;\n    pc->NumStats=++ns1;\n  }\n  MaxContext=MinContext=fs.Successor;\n  return;\nRESTART_MODEL:\n  RestartModelRare();\n  EscCount=0;\n}\n\n\n// Tabulated escapes for exponential symbol distribution\nstatic const byte ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };\n#define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))\n\n\n\ninline void RARPPM_CONTEXT::decodeBinSymbol(ModelPPM *Model)\n{\n  RARPPM_STATE& rs=OneState;\n  Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n  ushort& bs=Model->BinSumm[rs.Freq-1][Model->PrevSuccess+\n           Model->NS2BSIndx[Suffix->NumStats-1]+\n           Model->HiBitsFlag+2*Model->HB2Flag[rs.Symbol]+\n           ((Model->RunLength >> 26) & 0x20)];\n  if (Model->Coder.GetCurrentShiftCount(TOT_BITS) < bs) \n  {\n    Model->FoundState=&rs;\n    rs.Freq += (rs.Freq < 128);\n    Model->Coder.SubRange.LowCount=0;\n    Model->Coder.SubRange.HighCount=bs;\n    bs = GET_SHORT16(bs+INTERVAL-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->PrevSuccess=1;\n    Model->RunLength++;\n  } \n  else \n  {\n    Model->Coder.SubRange.LowCount=bs;\n    bs = GET_SHORT16(bs-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->Coder.SubRange.HighCount=BIN_SCALE;\n    Model->InitEsc=ExpEscape[bs >> 10];\n    Model->NumMasked=1;\n    Model->CharMask[rs.Symbol]=Model->EscCount;\n    Model->PrevSuccess=0;\n    Model->FoundState=NULL;\n  }\n}\n\n\ninline void RARPPM_CONTEXT::update1(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p[0].Freq > p[-1].Freq) \n  {\n    _PPMD_SWAP(p[0],p[-1]);                   \n    Model->FoundState=--p;\n    if (p->Freq > MAX_FREQ)             \n      rescale(Model);\n  }\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol1(ModelPPM *Model)\n{\n  Model->Coder.SubRange.scale=U.SummFreq;\n  RARPPM_STATE* p=U.Stats;\n  int i, HiCnt;\n  int count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  if (count < (HiCnt=p->Freq)) \n  {\n    Model->PrevSuccess=(2*(Model->Coder.SubRange.HighCount=HiCnt) > Model->Coder.SubRange.scale);\n    Model->RunLength += Model->PrevSuccess;\n    (Model->FoundState=p)->Freq=(HiCnt += 4);\n    U.SummFreq += 4;\n    if (HiCnt > MAX_FREQ)\n      rescale(Model);\n    Model->Coder.SubRange.LowCount=0;\n    return(true);\n  }\n  else\n    if (Model->FoundState==NULL)\n      return(false);\n  Model->PrevSuccess=0;\n  i=NumStats-1;\n  while ((HiCnt += (++p)->Freq) <= count)\n    if (--i == 0) \n    {\n      Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n      Model->Coder.SubRange.LowCount=HiCnt;\n      Model->CharMask[p->Symbol]=Model->EscCount;\n      i=(Model->NumMasked=NumStats)-1;\n      Model->FoundState=NULL;\n      do \n      { \n        Model->CharMask[(--p)->Symbol]=Model->EscCount; \n      } while ( --i );\n      Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n      return(true);\n    }\n  Model->Coder.SubRange.LowCount=(Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n  update1(Model,p);\n  return(true);\n}\n\n\ninline void RARPPM_CONTEXT::update2(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p->Freq > MAX_FREQ)                 \n    rescale(Model);\n  Model->EscCount++;\n  Model->RunLength=Model->InitRL;\n}\n\n\ninline RARPPM_SEE2_CONTEXT* RARPPM_CONTEXT::makeEscFreq2(ModelPPM *Model,int Diff)\n{\n  RARPPM_SEE2_CONTEXT* psee2c;\n  if (NumStats != 256) \n  {\n    psee2c=Model->SEE2Cont[Model->NS2Indx[Diff-1]]+\n           (Diff < Suffix->NumStats-NumStats)+\n           2*(U.SummFreq < 11*NumStats)+4*(Model->NumMasked > Diff)+\n           Model->HiBitsFlag;\n    Model->Coder.SubRange.scale=psee2c->getMean();\n  }\n  else \n  {\n    psee2c=&Model->DummySEE2Cont;\n    Model->Coder.SubRange.scale=1;\n  }\n  return psee2c;\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n\n    // We do not reuse PPMd coder in unstable state, so we do not really need\n    // this check and added it for extra safety. See CVE-2017-17969 for details.\n    if (pps>=ps+ASIZE(ps))\n      return false;\n\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) // Extra safety check.\n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) // Extra safety check.\n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}\n\n\ninline void ModelPPM::ClearMask()\n{\n  EscCount=1;                             \n  memset(CharMask,0,sizeof(CharMask));\n}\n\n\n\n\n// reset PPM variables after data error allowing safe resuming\n// of further data processing\nvoid ModelPPM::CleanUp()\n{\n  SubAlloc.StopSubAllocator();\n  SubAlloc.StartSubAllocator(1);\n  StartModelRare(2);\n}\n\n\nbool ModelPPM::DecodeInit(Unpack *UnpackRead,int &EscChar)\n{\n  int MaxOrder=UnpackRead->GetChar();\n  bool Reset=(MaxOrder & 0x20)!=0;\n\n  int MaxMB;\n  if (Reset)\n    MaxMB=UnpackRead->GetChar();\n  else\n    if (SubAlloc.GetAllocatedMemory()==0)\n      return(false);\n  if (MaxOrder & 0x40)\n    EscChar=UnpackRead->GetChar();\n  Coder.InitDecoder(UnpackRead);\n  if (Reset)\n  {\n    MaxOrder=(MaxOrder & 0x1f)+1;\n    if (MaxOrder>16)\n      MaxOrder=16+(MaxOrder-16)*3;\n    if (MaxOrder==1)\n    {\n      SubAlloc.StopSubAllocator();\n      return(false);\n    }\n    SubAlloc.StartSubAllocator(MaxMB+1);\n    StartModelRare(MaxOrder);\n  }\n  return(MinContext!=NULL);\n}\n\n\nint ModelPPM::DecodeChar()\n{\n  if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n    return(-1);\n  if (MinContext->NumStats != 1)      \n  {\n    if ((byte*)MinContext->U.Stats <= SubAlloc.pText || (byte*)MinContext->U.Stats>SubAlloc.HeapEnd)\n      return(-1);\n    if (!MinContext->decodeSymbol1(this))\n      return(-1);\n  }\n  else                                \n    MinContext->decodeBinSymbol(this);\n  Coder.Decode();\n  while ( !FoundState ) \n  {\n    ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n    do\n    {\n      OrderFall++;                \n      MinContext=MinContext->Suffix;\n      if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n        return(-1);\n    } while (MinContext->NumStats == NumMasked);\n    if (!MinContext->decodeSymbol2(this))\n      return(-1);\n    Coder.Decode();\n  }\n  int Symbol=FoundState->Symbol;\n  if (!OrderFall && (byte*) FoundState->Successor > SubAlloc.pText)\n    MinContext=MaxContext=FoundState->Successor;\n  else\n  {\n    UpdateModel();\n    if (EscCount == 0)\n      ClearMask();\n  }\n  ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n  return(Symbol);\n}\n", "#include \"rar.hpp\"\n\nwchar* PointToName(const wchar *Path)\n{\n  for (int I=(int)wcslen(Path)-1;I>=0;I--)\n    if (IsPathDiv(Path[I]))\n      return (wchar*)&Path[I+1];\n  return (wchar*)((*Path!=0 && IsDriveDiv(Path[1])) ? Path+2:Path);\n}\n\n\nwchar* PointToLastChar(const wchar *Path)\n{\n  size_t Length=wcslen(Path);\n  return (wchar*)(Length>0 ? Path+Length-1:Path);\n}\n\n\nwchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n\n  // Prevent \\..\\ in any part of path string.\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n\n  // Remove any amount of <d>:\\ and any sequence of . and \\ in the beginning of path string.\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n\n  // Code above does not remove last \"..\", doing here.\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  \n  if (DestPath!=NULL)\n  {\n    // SrcPath and DestPath can point to same memory area,\n    // so we use the temporary buffer for copying.\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}\n\n\nvoid SetName(wchar *FullName,const wchar *Name,size_t MaxSize)\n{\n  wchar *NamePtr=PointToName(FullName);\n  wcsncpyz(NamePtr,Name,MaxSize-(NamePtr-FullName));\n}\n\n\nvoid SetExt(wchar *Name,const wchar *NewExt,size_t MaxSize)\n{\n  if (Name==NULL || *Name==0)\n    return;\n  wchar *Dot=GetExt(Name);\n  if (Dot!=NULL)\n    *Dot=0;\n  if (NewExt!=NULL)\n  {\n    wcsncatz(Name,L\".\",MaxSize);\n    wcsncatz(Name,NewExt,MaxSize);\n  }\n}\n\n\n#ifndef SFX_MODULE\nvoid SetSFXExt(wchar *SFXName,size_t MaxSize)\n{\n  if (SFXName==NULL || *SFXName==0)\n    return;\n\n#ifdef _UNIX\n  SetExt(SFXName,L\"sfx\",MaxSize);\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n  SetExt(SFXName,L\"exe\",MaxSize);\n#endif\n}\n#endif\n\n\n// 'Ext' is an extension with the leading dot, like L\".rar\".\nwchar *GetExt(const wchar *Name)\n{\n  return Name==NULL ? NULL:wcsrchr(PointToName(Name),'.');\n}\n\n\n// 'Ext' is an extension without the leading dot, like L\"rar\".\nbool CmpExt(const wchar *Name,const wchar *Ext)\n{\n  wchar *NameExt=GetExt(Name);\n  return NameExt!=NULL && wcsicomp(NameExt+1,Ext)==0;\n}\n\n\nbool IsWildcard(const wchar *Str)\n{\n  if (Str==NULL)\n    return false;\n#ifdef _WIN_ALL\n  // Not treat the special NTFS \\\\?\\d: path prefix as a wildcard.\n  if (Str[0]=='\\\\' && Str[1]=='\\\\' && Str[2]=='?' && Str[3]=='\\\\')\n    Str+=4;\n#endif\n  return wcspbrk(Str,L\"*?\")!=NULL;\n}\n\n\nbool IsPathDiv(int Ch)\n{\n#ifdef _WIN_ALL\n  return Ch=='\\\\' || Ch=='/';\n#else\n  return Ch==CPATHDIVIDER;\n#endif\n}\n\n\nbool IsDriveDiv(int Ch)\n{\n#ifdef _UNIX\n  return false;\n#else\n  return Ch==':';\n#endif\n}\n\n\nbool IsDriveLetter(const wchar *Path)\n{\n  wchar Letter=etoupperw(Path[0]);\n  return Letter>='A' && Letter<='Z' && IsDriveDiv(Path[1]);\n}\n\n\nint GetPathDisk(const wchar *Path)\n{\n  if (IsDriveLetter(Path))\n    return etoupperw(*Path)-'A';\n  else\n    return -1;\n}\n\n\nvoid AddEndSlash(wchar *Path,size_t MaxLength)\n{\n  size_t Length=wcslen(Path);\n  if (Length>0 && Path[Length-1]!=CPATHDIVIDER && Length+1<MaxLength)\n  {\n    Path[Length]=CPATHDIVIDER;\n    Path[Length+1]=0;\n  }\n}\n\n\nvoid MakeName(const wchar *Path,const wchar *Name,wchar *Pathname,size_t MaxSize)\n{\n  // 'Path', 'Name' and 'Pathname' can point to same memory area. So we use\n  // the temporary buffer instead of constructing the name in 'Pathname'.\n  wchar OutName[NM];\n  wcsncpyz(OutName,Path,ASIZE(OutName));\n  // Do not add slash to d:, we want to allow relative paths like d:filename.\n  if (!IsDriveLetter(Path) || Path[2]!=0)\n    AddEndSlash(OutName,ASIZE(OutName));\n  wcsncatz(OutName,Name,ASIZE(OutName));\n  wcsncpyz(Pathname,OutName,MaxSize);\n}\n\n\n// Returns file path including the trailing path separator symbol.\nvoid GetFilePath(const wchar *FullName,wchar *Path,size_t MaxLength)\n{\n  if (MaxLength==0)\n    return;\n  size_t PathLength=Min(MaxLength-1,size_t(PointToName(FullName)-FullName));\n  wcsncpy(Path,FullName,PathLength);\n  Path[PathLength]=0;\n}\n\n\n// Removes name and returns file path without the trailing\n// path separator symbol.\nvoid RemoveNameFromPath(wchar *Path)\n{\n  wchar *Name=PointToName(Path);\n  if (Name>=Path+2 && (!IsDriveDiv(Path[1]) || Name>=Path+4))\n    Name--;\n  *Name=0;\n}\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nbool GetAppDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  LPMALLOC g_pMalloc;\n  SHGetMalloc(&g_pMalloc);\n  LPITEMIDLIST ppidl;\n  *Path=0;\n  bool Success=false;\n  if (SHGetSpecialFolderLocation(NULL,CSIDL_APPDATA,&ppidl)==NOERROR &&\n      SHGetPathFromIDList(ppidl,Path) && *Path!=0)\n  {\n    AddEndSlash(Path,MaxSize);\n    wcsncatz(Path,L\"WinRAR\",MaxSize);\n    Success=FileExist(Path);\n    if (!Success && Create)\n      Success=MakeDir(Path,false,0)==MKDIR_SUCCESS;\n  }\n  g_pMalloc->Free(ppidl);\n  return Success;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid GetRarDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  *Path=0;\n\n  HKEY hKey;\n  if (RegOpenKeyEx(HKEY_CURRENT_USER,L\"Software\\\\WinRAR\\\\Paths\",0,\n                   KEY_QUERY_VALUE,&hKey)==ERROR_SUCCESS)\n  {\n    DWORD DataSize=(DWORD)MaxSize,Type;\n    RegQueryValueEx(hKey,L\"AppData\",0,&Type,(BYTE *)Path,&DataSize);\n    RegCloseKey(hKey);\n  }\n\n  if (*Path==0 || !FileExist(Path))\n    if (!GetAppDataPath(Path,MaxSize,Create))\n    {\n      GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n      RemoveNameFromPath(Path);\n    }\n}\n#endif\n\n\n#ifndef SFX_MODULE\nbool EnumConfigPaths(uint Number,wchar *Path,size_t MaxSize,bool Create)\n{\n#ifdef _UNIX\n  static const wchar *ConfPath[]={\n    L\"/etc\", L\"/etc/rar\", L\"/usr/lib\", L\"/usr/local/lib\", L\"/usr/local/etc\"\n  };\n  if (Number==0)\n  {\n    char *EnvStr=getenv(\"HOME\");\n    if (EnvStr!=NULL)\n      CharToWide(EnvStr,Path,MaxSize);\n    else\n      wcsncpyz(Path,ConfPath[0],MaxSize);\n    return true;\n  }\n  Number--;\n  if (Number>=ASIZE(ConfPath))\n    return false;\n  wcsncpyz(Path,ConfPath[Number], MaxSize);\n  return true;\n#elif defined(_WIN_ALL)\n  if (Number>1)\n    return false;\n  if (Number==0)\n    GetRarDataPath(Path,MaxSize,Create);\n  else\n  {\n    GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n    RemoveNameFromPath(Path);\n  }\n  return true;\n#else\n  return false;\n#endif\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid GetConfigName(const wchar *Name,wchar *FullName,size_t MaxSize,bool CheckExist,bool Create)\n{\n  *FullName=0;\n  for (uint I=0;EnumConfigPaths(I,FullName,MaxSize,Create);I++)\n  {\n    AddEndSlash(FullName,MaxSize);\n    wcsncatz(FullName,Name,MaxSize);\n    if (!CheckExist || WildFileExist(FullName))\n      break;\n  }\n}\n#endif\n\n\n// Returns a pointer to rightmost digit of volume number or to beginning\n// of file name if numeric part is missing.\nwchar* GetVolNumPart(const wchar *ArcName)\n{\n  // We do not want to increment any characters in path component.\n  ArcName=PointToName(ArcName);\n\n  if (*ArcName==0)\n    return (wchar *)ArcName;\n\n  // Pointing to last name character.\n  const wchar *ChPtr=ArcName+wcslen(ArcName)-1;\n\n  // Skipping the archive extension.\n  while (!IsDigit(*ChPtr) && ChPtr>ArcName)\n    ChPtr--;\n\n  // Skipping the numeric part of name.\n  const wchar *NumPtr=ChPtr;\n  while (IsDigit(*NumPtr) && NumPtr>ArcName)\n    NumPtr--;\n\n  // Searching for first numeric part in names like name.part##of##.rar.\n  // Stop search on the first dot.\n  while (NumPtr>ArcName && *NumPtr!='.')\n  {\n    if (IsDigit(*NumPtr))\n    {\n      // Validate the first numeric part only if it has a dot somewhere \n      // before it.\n      const wchar *Dot=wcschr(ArcName,'.');\n      if (Dot!=NULL && Dot<NumPtr)\n        ChPtr=NumPtr;\n      break;\n    }\n    NumPtr--;\n  }\n  return (wchar *)ChPtr;\n}\n\n\nvoid NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering)\n{\n  wchar *ChPtr;\n  if ((ChPtr=GetExt(ArcName))==NULL)\n  {\n    wcsncatz(ArcName,L\".rar\",MaxLength);\n    ChPtr=GetExt(ArcName);\n  }\n  else\n    if (ChPtr[1]==0 || wcsicomp(ChPtr,L\".exe\")==0 || wcsicomp(ChPtr,L\".sfx\")==0)\n      wcsncpyz(ChPtr,L\".rar\",MaxLength-(ChPtr-ArcName));\n\n  if (ChPtr==NULL || *ChPtr!='.' || ChPtr[1]==0)\n  {\n    // Normally we shall have some extension here. If we don't, it means\n    // the name has no extension and buffer has no free space to append one.\n    // Let's clear the name to prevent a new call with same name and return.\n    *ArcName=0;\n    return;\n  }\n\n  if (!OldNumbering)\n  {\n    ChPtr=GetVolNumPart(ArcName);\n\n    // We should not check for IsDigit(*ChPtr) here and should increment\n    // even non-digits. If we got a corrupt archive with volume flag,\n    // but without numeric part, we still need to modify its name somehow,\n    // so while (exist(name)) {NextVolumeName()} loops do not run infinitely.\n    while ((++(*ChPtr))=='9'+1)\n    {\n      *ChPtr='0';\n      ChPtr--;\n      if (ChPtr<ArcName || !IsDigit(*ChPtr))\n      {\n        // Convert .part:.rar (.part9.rar after increment) to part10.rar.\n        for (wchar *EndPtr=ArcName+wcslen(ArcName);EndPtr!=ChPtr;EndPtr--)\n          *(EndPtr+1)=*EndPtr;\n        *(ChPtr+1)='1';\n        break;\n      }\n    }\n  }\n  else\n    if (!IsDigit(ChPtr[2]) || !IsDigit(ChPtr[3]))\n      wcsncpyz(ChPtr+2,L\"00\",MaxLength-(ChPtr-ArcName)-2); // From .rar to .r00.\n    else\n    {\n      ChPtr+=wcslen(ChPtr)-1; // Set to last character.\n      while (++(*ChPtr)=='9'+1)\n        if (ChPtr<=ArcName || *(ChPtr-1)=='.')\n        {\n          *ChPtr='a'; // From .999 to .a00 if started from .001 or for too short names.\n          break;\n        }\n        else\n        {\n          *ChPtr='0';\n          ChPtr--;\n        }\n    }\n}\n\n\nbool IsNameUsable(const wchar *Name)\n{\n#ifndef _UNIX\n  if (Name[0] && Name[1] && wcschr(Name+2,':')!=NULL)\n    return false;\n  for (const wchar *s=Name;*s!=0;s++)\n  {\n    if ((uint)*s<32)\n      return false;\n    if ((*s==' ' || *s=='.') && IsPathDiv(s[1]))\n      return false;\n  }\n#endif\n  return *Name!=0 && wcspbrk(Name,L\"?*<>|\\\"\")==NULL;\n}\n\n\nvoid MakeNameUsable(char *Name,bool Extended)\n{\n#ifdef _WIN_ALL\n  // In Windows we also need to convert characters not defined in current\n  // code page. This double conversion changes them to '?', which is\n  // catched by code below.\n  size_t NameLength=strlen(Name);\n  wchar NameW[NM];\n  CharToWide(Name,NameW,ASIZE(NameW));\n  WideToChar(NameW,Name,NameLength+1);\n  Name[NameLength]=0;\n#endif\n  for (char *s=Name;*s!=0;s=charnext(s))\n  {\n    if (strchr(Extended ? \"?*<>|\\\"\":\"?*\",*s)!=NULL || Extended && (byte)*s<32)\n      *s='_';\n#ifdef _EMX\n    if (*s=='=')\n      *s='_';\n#endif\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if ((*s==' ' || *s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.') && IsPathDiv(s[1]))\n      *s='_';\n#endif\n  }\n}\n\n\nvoid MakeNameUsable(wchar *Name,bool Extended)\n{\n  for (wchar *s=Name;*s!=0;s++)\n  {\n    if (wcschr(Extended ? L\"?*<>|\\\"\":L\"?*\",*s)!=NULL || Extended && (uint)*s<32)\n      *s='_';\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n#if 0  // We already can create such files.\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if (IsPathDiv(s[1]) && (*s==' ' || *s=='.' && s>Name &&\n        !IsPathDiv(s[-1]) && (s[-1]!='.' || s>Name+1 && !IsPathDiv(s[-2]))))\n      *s='_';\n#endif\n#endif\n  }\n}\n\n\nvoid UnixSlashToDos(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid UnixSlashToDos(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid ConvertNameToFull(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (Src==NULL || *Src==0)\n  {\n    if (MaxSize>0)\n      *Dest=0;\n    return;\n  }\n#ifdef _WIN_ALL\n  {\n    wchar FullName[NM],*NamePtr;\n    DWORD Code=GetFullPathName(Src,ASIZE(FullName),FullName,&NamePtr);\n    if (Code==0 || Code>ASIZE(FullName))\n    {\n      wchar LongName[NM];\n      if (GetWinLongPath(Src,LongName,ASIZE(LongName)))\n        Code=GetFullPathName(LongName,ASIZE(FullName),FullName,&NamePtr);\n    }\n    if (Code!=0 && Code<ASIZE(FullName))\n      wcsncpyz(Dest,FullName,MaxSize);\n    else\n      if (Src!=Dest)\n        wcsncpyz(Dest,Src,MaxSize);\n  }\n#elif defined(_UNIX)\n  if (IsFullPath(Src))\n    *Dest=0;\n  else\n  {\n    char CurDirA[NM];\n    if (getcwd(CurDirA,ASIZE(CurDirA))==NULL)\n      *CurDirA=0;\n    CharToWide(CurDirA,Dest,MaxSize);\n    AddEndSlash(Dest,MaxSize);\n  }\n  wcsncatz(Dest,Src,MaxSize);\n#else\n  wcsncpyz(Dest,Src,MaxSize);\n#endif\n}\n\n\nbool IsFullPath(const wchar *Path)\n{\n/*\n  wchar PathOnly[NM];\n  GetFilePath(Path,PathOnly,ASIZE(PathOnly));\n  if (IsWildcard(PathOnly))\n    return true;\n*/\n#if defined(_WIN_ALL) || defined(_EMX)\n  return Path[0]=='\\\\' && Path[1]=='\\\\' || IsDriveLetter(Path) && IsPathDiv(Path[2]);\n#else\n  return IsPathDiv(Path[0]);\n#endif\n}\n\n\nbool IsFullRootPath(const wchar *Path)\n{\n  return IsFullPath(Path) || IsPathDiv(Path[0]);\n}\n\n\nvoid GetPathRoot(const wchar *Path,wchar *Root,size_t MaxSize)\n{\n  *Root=0;\n  if (IsDriveLetter(Path))\n    swprintf(Root,MaxSize,L\"%c:\\\\\",*Path);\n  else\n    if (Path[0]=='\\\\' && Path[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(Path+2,'\\\\');\n      if (Slash!=NULL)\n      {\n        size_t Length;\n        if ((Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n          Length=Slash-Path+1;\n        else\n          Length=wcslen(Path);\n        if (Length>=MaxSize)\n          Length=0;\n        wcsncpy(Root,Path,Length);\n        Root[Length]=0;\n      }\n    }\n}\n\n\nint ParseVersionFileName(wchar *Name,bool Truncate)\n{\n  int Version=0;\n  wchar *VerText=wcsrchr(Name,';');\n  if (VerText!=NULL)\n  {\n    Version=atoiw(VerText+1);\n    if (Truncate)\n      *VerText=0;\n  }\n  return Version;\n}\n\n\n#if !defined(SFX_MODULE)\n// Get the name of first volume. Return the leftmost digit of volume number.\nwchar* VolNameToFirstName(const wchar *VolName,wchar *FirstName,size_t MaxSize,bool NewNumbering)\n{\n  if (FirstName!=VolName)\n    wcsncpyz(FirstName,VolName,MaxSize);\n  wchar *VolNumStart=FirstName;\n  if (NewNumbering)\n  {\n    wchar N='1';\n\n    // From the rightmost digit of volume number to the left.\n    for (wchar *ChPtr=GetVolNumPart(FirstName);ChPtr>FirstName;ChPtr--)\n      if (IsDigit(*ChPtr))\n      {\n        *ChPtr=N; // Set the rightmost digit to '1' and others to '0'.\n        N='0';\n      }\n      else\n        if (N=='0')\n        {\n          VolNumStart=ChPtr+1; // Store the position of leftmost digit in volume number.\n          break;\n        }\n  }\n  else\n  {\n    // Old volume numbering scheme. Just set the extension to \".rar\".\n    SetExt(FirstName,L\"rar\",MaxSize);\n    VolNumStart=GetExt(FirstName);\n  }\n  if (!FileExist(FirstName))\n  {\n    // If the first volume, which name we just generated, does not exist,\n    // check if volume with same name and any other extension is available.\n    // It can help in case of *.exe or *.sfx first volume.\n    wchar Mask[NM];\n    wcsncpyz(Mask,FirstName,ASIZE(Mask));\n    SetExt(Mask,L\"*\",ASIZE(Mask));\n    FindFile Find;\n    Find.SetMask(Mask);\n    FindData FD;\n    while (Find.Next(&FD))\n    {\n      Archive Arc;\n      if (Arc.Open(FD.Name,0) && Arc.IsArchive(true) && Arc.FirstVolume)\n      {\n        wcsncpyz(FirstName,FD.Name,MaxSize);\n        break;\n      }\n    }\n  }\n  return VolNumStart;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nstatic void GenArcName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,uint ArcNumber,bool &ArcNumPresent)\n{\n  bool Prefix=false;\n  if (*GenerateMask=='+')\n  {\n    Prefix=true;    // Add the time string before the archive name.\n    GenerateMask++; // Skip '+' in the beginning of time mask.\n  }\n\n  wchar Mask[MAX_GENERATE_MASK];\n  wcsncpyz(Mask,*GenerateMask!=0 ? GenerateMask:L\"yyyymmddhhmmss\",ASIZE(Mask));\n\n  bool QuoteMode=false;\n  uint MAsMinutes=0; // By default we treat 'M' as months.\n  for (uint I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    int CurChar=toupperw(Mask[I]);\n    if (CurChar=='H')\n      MAsMinutes=2; // Treat next two 'M' after 'H' as minutes.\n    if (CurChar=='D' || CurChar=='Y')\n      MAsMinutes=0; // Treat 'M' in HHDDMMYY and HHYYMMDD as month.\n\n    if (MAsMinutes>0 && CurChar=='M')\n    {\n      // Replace minutes with 'I'. We use 'M' both for months and minutes,\n      // so we treat as minutes only those 'M', which are found after hours.\n      Mask[I]='I';\n      MAsMinutes--;\n    }\n    if (CurChar=='N')\n    {\n      uint Digits=GetDigits(ArcNumber);\n      uint NCount=0;\n      while (toupperw(Mask[I+NCount])=='N')\n        NCount++;\n\n      // Here we ensure that we have enough 'N' characters to fit all digits\n      // of archive number. We'll replace them by actual number later\n      // in this function.\n      if (NCount<Digits)\n      {\n        wmemmove(Mask+I+Digits,Mask+I+NCount,wcslen(Mask+I+NCount)+1);\n        wmemset(Mask+I,'N',Digits);\n      }\n      I+=Max(Digits,NCount)-1;\n      ArcNumPresent=true;\n      continue;\n    }\n  }\n\n  RarTime CurTime;\n  CurTime.SetCurrentTime();\n  RarLocalTime rlt;\n  CurTime.GetLocal(&rlt);\n\n  wchar Ext[NM],*Dot=GetExt(ArcName);\n  *Ext=0;\n  if (Dot==NULL)\n    wcsncpyz(Ext,*PointToName(ArcName)==0 ? L\".rar\":L\"\",ASIZE(Ext));\n  else\n  {\n    wcsncpyz(Ext,Dot,ASIZE(Ext));\n    *Dot=0;\n  }\n\n  int WeekDay=rlt.wDay==0 ? 6:rlt.wDay-1;\n  int StartWeekDay=rlt.yDay-WeekDay;\n  if (StartWeekDay<0)\n    if (StartWeekDay<=-4)\n      StartWeekDay+=IsLeapYear(rlt.Year-1) ? 366:365;\n    else\n      StartWeekDay=0;\n  int CurWeek=StartWeekDay/7+1;\n  if (StartWeekDay%7>=4)\n    CurWeek++;\n\n  char Field[10][6];\n\n  sprintf(Field[0],\"%04u\",rlt.Year);\n  sprintf(Field[1],\"%02u\",rlt.Month);\n  sprintf(Field[2],\"%02u\",rlt.Day);\n  sprintf(Field[3],\"%02u\",rlt.Hour);\n  sprintf(Field[4],\"%02u\",rlt.Minute);\n  sprintf(Field[5],\"%02u\",rlt.Second);\n  sprintf(Field[6],\"%02u\",(uint)CurWeek);\n  sprintf(Field[7],\"%u\",(uint)WeekDay+1);\n  sprintf(Field[8],\"%03u\",rlt.yDay+1);\n  sprintf(Field[9],\"%05u\",ArcNumber);\n\n  const wchar *MaskChars=L\"YMDHISWAEN\";\n\n  // How many times every modifier character was encountered in the mask.\n  int CField[sizeof(Field)/sizeof(Field[0])];\n\n  memset(CField,0,sizeof(CField));\n  QuoteMode=false;\n  for (uint I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr!=NULL)\n      CField[ChPtr-MaskChars]++;\n   }\n\n  wchar DateText[MAX_GENERATE_MASK];\n  *DateText=0;\n  QuoteMode=false;\n  for (size_t I=0,J=0;Mask[I]!=0 && J<ASIZE(DateText)-1;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr==NULL || QuoteMode)\n    {\n      DateText[J]=Mask[I];\n#ifdef _WIN_ALL\n      // We do not allow ':' in Windows because of NTFS streams.\n      // Users had problems after specifying hh:mm mask.\n      if (DateText[J]==':')\n        DateText[J]='_';\n#endif\n    }\n    else\n    {\n      size_t FieldPos=ChPtr-MaskChars;\n      int CharPos=(int)strlen(Field[FieldPos])-CField[FieldPos]--;\n\n      // CField[FieldPos] shall have exactly 3 \"MMM\" symbols, so we do not\n      // repeat the month name in case \"MMMMMMMM\" mask. But since we\n      // decremented CField[FieldPos] above, we compared it with 2.\n      if (FieldPos==1 && CField[FieldPos]==2 &&\n          toupperw(Mask[I+1])=='M' && toupperw(Mask[I+2])=='M')\n      {\n        wcsncpyz(DateText+J,GetMonthName(rlt.Month-1),ASIZE(DateText)-J);\n        J=wcslen(DateText);\n        I+=2;\n        continue;\n      }\n      // If CharPos is negative, we have more modifier characters than\n      // matching time data. We prefer to issue a modifier character\n      // instead of repeating time data from beginning, so user can notice\n      // excessive modifiers added by mistake.\n      if (CharPos<0)\n        DateText[J]=Mask[I];\n      else\n        DateText[J]=Field[FieldPos][CharPos];\n    }\n    DateText[++J]=0;\n  }\n\n  if (Prefix)\n  {\n    wchar NewName[NM];\n    GetFilePath(ArcName,NewName,ASIZE(NewName));\n    AddEndSlash(NewName,ASIZE(NewName));\n    wcsncatz(NewName,DateText,ASIZE(NewName));\n    wcsncatz(NewName,PointToName(ArcName),ASIZE(NewName));\n    wcsncpyz(ArcName,NewName,MaxSize);\n  }\n  else\n    wcsncatz(ArcName,DateText,MaxSize);\n  wcsncatz(ArcName,Ext,MaxSize);\n}\n\n\nvoid GenerateArchiveName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,bool Archiving)\n{\n  wchar NewName[NM];\n\n  uint ArcNumber=1;\n  while (true) // Loop for 'N' (archive number) processing.\n  {\n    wcsncpyz(NewName,ArcName,ASIZE(NewName));\n    \n    bool ArcNumPresent=false;\n\n    GenArcName(NewName,ASIZE(NewName),GenerateMask,ArcNumber,ArcNumPresent);\n    \n    if (!ArcNumPresent)\n      break;\n    if (!FileExist(NewName))\n    {\n      if (!Archiving && ArcNumber>1)\n      {\n        // If we perform non-archiving operation, we need to use the last\n        // existing archive before the first unused name. So we generate\n        // the name for (ArcNumber-1) below.\n        wcsncpyz(NewName,NullToEmpty(ArcName),ASIZE(NewName));\n        GenArcName(NewName,ASIZE(NewName),GenerateMask,ArcNumber-1,ArcNumPresent);\n      }\n      break;\n    }\n    ArcNumber++;\n  }\n  wcsncpyz(ArcName,NewName,MaxSize);\n}\n#endif\n\n\nwchar* GetWideName(const char *Name,const wchar *NameW,wchar *DestW,size_t DestSize)\n{\n  if (NameW!=NULL && *NameW!=0)\n  {\n    if (DestW!=NameW)\n      wcsncpy(DestW,NameW,DestSize);\n  }\n  else\n    if (Name!=NULL)\n      CharToWide(Name,DestW,DestSize);\n    else\n      *DestW=0;\n\n  // Ensure that we return a zero terminate string for security reasons.\n  if (DestSize>0)\n    DestW[DestSize-1]=0;\n\n  return DestW;\n}\n\n\n#ifdef _WIN_ALL\n// We should return 'true' even if resulting path is shorter than MAX_PATH,\n// because we can also use this function to open files with non-standard\n// characters, even if their path length is normal.\nbool GetWinLongPath(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (*Src==0)\n    return false;\n  const wchar *Prefix=L\"\\\\\\\\?\\\\\";\n  const size_t PrefixLength=4;\n  bool FullPath=IsDriveLetter(Src) && IsPathDiv(Src[2]);\n  size_t SrcLength=wcslen(Src);\n  if (IsFullPath(Src)) // Paths in d:\\path\\name format.\n  {\n    if (IsDriveLetter(Src))\n    {\n      if (MaxSize<=PrefixLength+SrcLength)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      wcsncatz(Dest,Src,MaxSize); // \"\\\\?\\D:\\very long path\".\n      return true;\n    }\n    else\n      if (Src[0]=='\\\\' && Src[1]=='\\\\')\n      {\n        if (MaxSize<=PrefixLength+SrcLength+2)\n          return false;\n        wcsncpyz(Dest,Prefix,MaxSize);\n        wcsncatz(Dest,L\"UNC\",MaxSize);\n        wcsncatz(Dest,Src+1,MaxSize); // \"\\\\?\\UNC\\server\\share\".\n        return true;\n      }\n    // We may be here only if we modify IsFullPath in the future.\n    return false;\n  }\n  else\n  {\n    wchar CurDir[NM];\n    DWORD DirCode=GetCurrentDirectory(ASIZE(CurDir)-1,CurDir);\n    if (DirCode==0 || DirCode>ASIZE(CurDir)-1)\n      return false;\n\n    if (IsPathDiv(Src[0])) // Paths in \\path\\name format.\n    {\n      if (MaxSize<=PrefixLength+SrcLength+2)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      CurDir[2]=0;\n      wcsncatz(Dest,CurDir,MaxSize); // Copy drive letter 'd:'.\n      wcsncatz(Dest,Src,MaxSize);\n      return true;\n    }\n    else  // Paths in path\\name format.\n    {\n      AddEndSlash(CurDir,ASIZE(CurDir));\n      if (MaxSize<=PrefixLength+wcslen(CurDir)+SrcLength)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      wcsncatz(Dest,CurDir,MaxSize);\n\n      if (Src[0]=='.' && IsPathDiv(Src[1])) // Remove leading .\\ in pathname.\n        Src+=2;\n\n      wcsncatz(Dest,Src,MaxSize);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n// Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\nvoid ConvertToPrecomposed(wchar *Name,size_t NameSize)\n{\n  wchar FileName[NM];\n  if (WinNT()>=WNT_VISTA && // MAP_PRECOMPOSED is not supported in XP.\n      FoldString(MAP_PRECOMPOSED,Name,-1,FileName,ASIZE(FileName))!=0)\n  {\n    FileName[ASIZE(FileName)-1]=0;\n    wcsncpyz(Name,FileName,NameSize);\n  }\n}\n\n\nvoid MakeNameCompatible(wchar *Name,size_t MaxSize)\n{\n  // Remove trailing spaces and dots in file name and in dir names in path.\n  int Src=0,Dest=0;\n  while (true)\n  {\n    if (IsPathDiv(Name[Src]) || Name[Src]==0)\n      for (int I=Dest-1;I>0 && (Name[I]==' ' || Name[I]=='.');I--)\n      {\n        // Permit path1/./path2 and ../path1 paths.\n        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || Name[I-1]=='.' && I==1))\n          break;\n        Dest--;\n      }\n    Name[Dest]=Name[Src];\n    if (Name[Src]==0)\n      break;\n    Src++;\n    Dest++;\n  }\n\n  // Rename reserved device names, such as aux.txt to _aux.txt.\n  // We check them in path components too, where they are also prohibited.\n  for (uint I=0;Name[I]!=0;I++)\n    if (I==0 || I>0 && IsPathDiv(Name[I-1]))\n    {\n      static const wchar *Devices[]={L\"CON\",L\"PRN\",L\"AUX\",L\"NUL\",L\"COM#\",L\"LPT#\"};\n      wchar *s=Name+I;\n      bool MatchFound=false;\n      for (uint J=0;J<ASIZE(Devices);J++)\n        for (uint K=0;;K++)\n          if (Devices[J][K]=='#')\n          {\n            if (!IsDigit(s[K]))\n              break;\n          }\n          else\n            if (Devices[J][K]==0)\n            {\n              // Names like aux.txt are accessible without \\\\?\\ prefix\n              // since Windows 11. Pure aux is still prohibited.\n              MatchFound=s[K]==0 || s[K]=='.' && !IsWindows11OrGreater() || IsPathDiv(s[K]);\n              break;\n            }\n            else\n              if (Devices[J][K]!=toupperw(s[K]))\n                break;\n      if (MatchFound)\n      {\n        wchar OrigName[NM];\n        wcsncpyz(OrigName,Name,ASIZE(OrigName));\n        if (MaxSize>I+1) // I+1, because we do not move the trailing 0.\n          memmove(s+1,s,(MaxSize-I-1)*sizeof(*s));\n        *s='_';\n#ifndef SFX_MODULE\n        uiMsg(UIMSG_CORRECTINGNAME,nullptr);\n        uiMsg(UIERROR_RENAMING,nullptr,OrigName,Name);\n#endif\n      }\n    }\n}\n#endif\n\n\n", "#ifndef _RAR_TIMEFN_\n#define _RAR_TIMEFN_\n\nstruct RarLocalTime\n{\n  uint Year;\n  uint Month;\n  uint Day;\n  uint Hour;\n  uint Minute;\n  uint Second;\n  uint Reminder; // Part of time smaller than 1 second, represented in 1/REMINDER_PRECISION intervals.\n  uint wDay;\n  uint yDay;\n};\n\n\nclass RarTime\n{\n  private:\n    static const uint TICKS_PER_SECOND = 1000000000; // Internal precision.\n\n    // Internal time representation in 1/TICKS_PER_SECOND since 01.01.1601.\n    // We use nanoseconds here to handle the high precision Unix time.\n    uint64 itime;\n  public:\n    // RarLocalTime::Reminder precision. Must be equal to TICKS_PER_SECOND.\n    // Unlike TICKS_PER_SECOND, it is a public field.\n    static const uint REMINDER_PRECISION = TICKS_PER_SECOND;\n  public:\n    RarTime() {Reset();}\n    bool operator == (RarTime &rt) {return itime==rt.itime;}\n    bool operator != (RarTime &rt) {return itime!=rt.itime;}\n    bool operator < (RarTime &rt)  {return itime<rt.itime;}\n    bool operator <= (RarTime &rt) {return itime<rt.itime || itime==rt.itime;}\n    bool operator > (RarTime &rt)  {return itime>rt.itime;}\n    bool operator >= (RarTime &rt) {return itime>rt.itime || itime==rt.itime;}\n\n    void GetLocal(RarLocalTime *lt);\n    void SetLocal(RarLocalTime *lt);\n#ifdef _WIN_ALL\n    void GetWinFT(FILETIME *ft);\n    void SetWinFT(FILETIME *ft);\n#endif\n    uint64 GetWin();\n    void SetWin(uint64 WinTime);\n    time_t GetUnix();\n    void SetUnix(time_t ut);\n    uint64 GetUnixNS();\n    void SetUnixNS(uint64 ns);\n    uint GetDos();\n    void SetDos(uint DosTime);\n    void GetText(wchar *DateStr,size_t MaxSize,bool FullMS);\n    void SetIsoText(const wchar *TimeText);\n    void SetAgeText(const wchar *TimeText);\n    void SetCurrentTime();\n    void Reset() {itime=0;}\n    bool IsSet() {return itime!=0;}\n    void Adjust(int64 ns);\n};\n\nconst wchar *GetMonthName(int Month);\nbool IsLeapYear(int Year);\n\n#endif\n", "\n\nstatic bool UnixSymlink(CommandData *Cmd,const char *Target,const wchar *LinkName,RarTime *ftm,RarTime *fta)\n{\n  CreatePath(LinkName,true,Cmd->DisableNames);\n\n  // Overwrite prompt was already issued and confirmed earlier, so we can\n  // remove existing symlink or regular file here. PrepareToDelete was also\n  // called earlier inside of uiAskReplaceEx.\n  DelFile(LinkName);\n\n  char LinkNameA[NM];\n  WideToChar(LinkName,LinkNameA,ASIZE(LinkNameA));\n  if (symlink(Target,LinkNameA)==-1) // Error.\n  {\n    if (errno==EEXIST)\n      uiMsg(UIERROR_ULINKEXIST,LinkName);\n    else\n    {\n      uiMsg(UIERROR_SLINKCREATE,UINULL,LinkName);\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    }\n    return false;\n  }\n#ifdef USE_LUTIMES\n#ifdef UNIX_TIME_NS\n  timespec times[2];\n  times[0].tv_sec=fta->GetUnix();\n  times[0].tv_nsec=fta->IsSet() ? long(fta->GetUnixNS()%1000000000) : UTIME_NOW;\n  times[1].tv_sec=ftm->GetUnix();\n  times[1].tv_nsec=ftm->IsSet() ? long(ftm->GetUnixNS()%1000000000) : UTIME_NOW;\n  utimensat(AT_FDCWD,LinkNameA,times,AT_SYMLINK_NOFOLLOW);\n#else\n  struct timeval tv[2];\n  tv[0].tv_sec=fta->GetUnix();\n  tv[0].tv_usec=long(fta->GetUnixNS()%1000000000/1000);\n  tv[1].tv_sec=ftm->GetUnix();\n  tv[1].tv_usec=long(ftm->GetUnixNS()%1000000000/1000);\n  lutimes(LinkNameA,tv);\n#endif\n#endif\n\n  return true;\n}\n\n\nstatic bool IsFullPath(const char *PathA) // Unix ASCII version.\n{\n  return *PathA==CPATHDIVIDER;\n}\n\n\n// For security purpose we prefer to be sure that CharToWide completed\n// successfully and even if it truncated a string for some reason,\n// it didn't affect the number of path related characters we analyze\n// in IsRelativeSymlinkSafe later.\n// This check is likely to be excessive, but let's keep it anyway.\nstatic bool SafeCharToWide(const char *Src,wchar *Dest,size_t DestSize)\n{\n  if (!CharToWide(Src,Dest,DestSize) || *Dest==0)\n    return false;\n  uint SrcChars=0,DestChars=0;\n  for (uint I=0;Src[I]!=0;I++)\n    if (Src[I]=='/' || Src[I]=='.')\n      SrcChars++;\n  for (uint I=0;Dest[I]!=0;I++)\n    if (Dest[I]=='/' || Dest[I]=='.')\n      DestChars++;\n  return SrcChars==DestChars;\n}\n\n\nbool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    // Return true in case of bad checksum, so link will be processed further\n    // and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    // Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    // can include the destination path as a prefix, which can\n    // confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}\n\n\nbool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    // Cannot create Windows absolute path symlinks in Unix. Only relative path\n    // Windows symlinks can be created here. RAR 5.0 used \\??\\ prefix\n    // for Windows absolute symlinks, since RAR 5.1 /??/ is used.\n    // We escape ? as \\? to avoid \"trigraph\" warning\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  // Use hd->FileName instead of LinkName, since LinkName can include\n  // the destination path as a prefix, which can confuse\n  // IsRelativeSymlinkSafe algorithm.\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}\n", "#define RARVER_MAJOR     6\n#define RARVER_MINOR    20\n#define RARVER_BETA      2\n#define RARVER_DAY      12\n#define RARVER_MONTH    11\n#define RARVER_YEAR   2022\n", "\n\n#if !defined(SFX_MODULE) && defined(_WIN_ALL)\nvoid ExtractStreams20(Archive &Arc,const wchar *FileName)\n{\n  if (Arc.BrokenHeader)\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  if (Arc.StreamHead.Method<0x31 || Arc.StreamHead.Method>0x35 || Arc.StreamHead.UnpVer>VER_PACK)\n  {\n    uiMsg(UIERROR_STREAMUNKNOWN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_WARNING);\n    return;\n  }\n\n  wchar StreamName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    // Convert single character names like f:stream to .\\f:stream to\n    // resolve the ambiguity with drive letters.\n    wcsncpyz(StreamName,L\".\\\\\",ASIZE(StreamName));\n    wcsncatz(StreamName,FileName,ASIZE(StreamName));\n  }\n  else\n    wcsncpyz(StreamName,FileName,ASIZE(StreamName));\n  if (wcslen(StreamName)+strlen(Arc.StreamHead.StreamName)>=ASIZE(StreamName) ||\n      Arc.StreamHead.StreamName[0]!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  wchar StoredName[NM];\n  CharToWide(Arc.StreamHead.StreamName,StoredName,ASIZE(StoredName));\n  ConvertPath(StoredName+1,StoredName+1,ASIZE(StoredName)-1);\n\n  wcsncatz(StreamName,StoredName,ASIZE(StreamName));\n\n  FindData fd;\n  bool Found=FindFile::FastFind(FileName,&fd);\n\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n\n  File CurFile;\n  if (CurFile.WCreate(StreamName))\n  {\n    ComprDataIO DataIO;\n    Unpack Unpack(&DataIO);\n    Unpack.Init(0x10000,false);\n\n    DataIO.SetPackedSizeToRead(Arc.StreamHead.DataSize);\n    DataIO.EnableShowProgress(false);\n    DataIO.SetFiles(&Arc,&CurFile);\n    DataIO.UnpHash.Init(HASH_CRC32,1);\n    Unpack.SetDestSize(Arc.StreamHead.UnpSize);\n    Unpack.DoUnpack(Arc.StreamHead.UnpVer,false);\n\n    if (Arc.StreamHead.StreamCRC!=DataIO.UnpHash.GetCRC32())\n    {\n      uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,StreamName);\n      ErrHandler.SetErrorCode(RARX_CRC);\n    }\n    else\n      CurFile.Close();\n  }\n  File HostFile;\n  if (Found && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr);\n}\n#endif\n\n\n#ifdef _WIN_ALL\nvoid ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    // Convert single character names like f:stream to .\\f:stream to\n    // resolve the ambiguity with drive letters.\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n\n\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n  if (CurFile.WCreate(FullName) && Arc.ReadSubData(NULL,&CurFile,false))\n    CurFile.Close();\n\n  // Restoring original file timestamps.\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n\n  // Restoring original file attributes. Important if file was read only\n  // or did not have \"Archive\" attribute\n  SetFileAttr(FileName,fd.FileAttr);\n}\n#endif\n\n\nvoid GetStreamNameNTFS(Archive &Arc,wchar *StreamName,size_t MaxSize)\n{\n  byte *Data=&Arc.SubHead.SubData[0];\n  size_t DataSize=Arc.SubHead.SubData.Size();\n  if (Arc.Format==RARFMT15)\n  {\n    size_t DestSize=Min(DataSize/2,MaxSize-1);\n    RawToWide(Data,StreamName,DestSize);\n    StreamName[DestSize]=0;\n  }\n  else\n  {\n    char UtfString[NM*4];\n    size_t DestSize=Min(DataSize,ASIZE(UtfString)-1);\n    memcpy(UtfString,Data,DestSize);\n    UtfString[DestSize]=0;\n    UtfToWide(UtfString,StreamName,MaxSize);\n  }\n}\n"], "fixing_code": ["#include \"rar.hpp\"\n\nsize_t Archive::ReadHeader()\n{\n  // Once we failed to decrypt an encrypted block, there is no reason to\n  // attempt to do it further. We'll never be successful and only generate\n  // endless errors.\n  if (FailedHeaderDecryption)\n    return 0;\n\n  CurBlockPos=Tell();\n\n  // Other developers asked us to initialize it to suppress \"may be used\n  // uninitialized\" warning in code below in some compilers.\n  size_t ReadSize=0;\n\n  switch(Format)\n  {\n#ifndef SFX_MODULE\n    case RARFMT14:\n      ReadSize=ReadHeader14();\n      break;\n#endif\n    case RARFMT15:\n      ReadSize=ReadHeader15();\n      break;\n    case RARFMT50:\n      ReadSize=ReadHeader50();\n      break;\n  }\n\n  // It is important to check ReadSize>0 here, because it is normal\n  // for RAR2 and RAR3 archives without end of archive block to have\n  // NextBlockPos==CurBlockPos after the end of archive has reached.\n  if (ReadSize>0 && NextBlockPos<=CurBlockPos)\n  {\n    BrokenHeaderMsg();\n    ReadSize=0;\n  }\n\n  if (ReadSize==0)\n    CurHeaderType=HEAD_UNKNOWN;\n\n  return ReadSize;\n}\n\n\nsize_t Archive::SearchBlock(HEADER_TYPE HeaderType)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 &&\n         (HeaderType==HEAD_ENDARC || GetHeaderType()!=HEAD_ENDARC))\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HeaderType)\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchSubBlock(const wchar *Type)\n{\n  size_t Size,Count=0;\n  while ((Size=ReadHeader())!=0 && GetHeaderType()!=HEAD_ENDARC)\n  {\n    if ((++Count & 127)==0)\n      Wait();\n    if (GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(Type))\n      return Size;\n    SeekToNext();\n  }\n  return 0;\n}\n\n\nsize_t Archive::SearchRR()\n{\n  // If locator extra field is available for recovery record, let's utilize it.\n  if (MainHead.Locator && MainHead.RROffset!=0)\n  {\n    uint64 CurPos=Tell();\n    Seek(MainHead.RROffset,SEEK_SET);\n    size_t Size=ReadHeader();\n    if (Size!=0 && !BrokenHeader && GetHeaderType()==HEAD_SERVICE && SubHead.CmpName(SUBHEAD_TYPE_RR))\n      return Size;\n    Seek(CurPos,SEEK_SET);\n  }\n  // Otherwise scan the entire archive to find the recovery record.\n  return SearchSubBlock(SUBHEAD_TYPE_RR);\n}\n\n\nvoid Archive::UnexpEndArcMsg()\n{\n  int64 ArcSize=FileLength();\n\n  // If block positions are equal to file size, this is not an error.\n  // It can happen when we reached the end of older RAR 1.5 archive,\n  // which did not have the end of archive block.\n  // We can't replace this check by checking that read size is exactly 0\n  // in the beginning of file header, because in this case the read position\n  // still can be beyond the end of archive.\n  if (CurBlockPos!=ArcSize || NextBlockPos!=ArcSize)\n  {\n    uiMsg(UIERROR_UNEXPEOF,FileName);\n    ErrHandler.SetErrorCode(RARX_WARNING);\n  }\n}\n\n\nvoid Archive::BrokenHeaderMsg()\n{\n  uiMsg(UIERROR_HEADERBROKEN,FileName);\n  BrokenHeader=true;\n  ErrHandler.SetErrorCode(RARX_CRC);\n}\n\n\nvoid Archive::UnkEncVerMsg(const wchar *Name,const wchar *Info)\n{\n  uiMsg(UIERROR_UNKNOWNENCMETHOD,FileName,Name,Info);\n  ErrHandler.SetErrorCode(RARX_WARNING);\n}\n\n\n// Return f in case of signed integer overflow or negative parameters\n// or v1+v2 otherwise. We use it for file offsets, which are signed\n// for compatibility with off_t in POSIX file functions and third party code.\n// Signed integer overflow is the undefined behavior according to\n// C++ standard and it causes fuzzers to complain.\ninline int64 SafeAdd(int64 v1,int64 v2,int64 f)\n{\n  return v1>=0 && v2>=0 && v1<=MAX_INT64-v2 ? v1+v2 : f;\n}\n\n\nsize_t Archive::ReadHeader15()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD3;\n\n  if (Decrypt)\n  {\n#ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.\n    return 0;\n#else\n    RequestArcPassword(NULL);\n\n    byte Salt[SIZE_SALT30];\n    if (Read(Salt,SIZE_SALT30)!=SIZE_SALT30)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n    HeadersCrypt.SetCryptKeys(false,CRYPT_RAR30,&Cmd->Password,Salt,NULL,0,NULL,NULL);\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  Raw.Read(SIZEOF_SHORTBLOCKHEAD);\n  if (Raw.Size()==0)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.HeadCRC=Raw.Get2();\n\n  ShortBlock.Reset();\n\n  uint HeaderType=Raw.Get1();\n  ShortBlock.Flags=Raw.Get2();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & SKIP_IF_UNKNOWN)!=0;\n  ShortBlock.HeadSize=Raw.Get2();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)HeaderType;\n  if (ShortBlock.HeadSize<SIZEOF_SHORTBLOCKHEAD)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  // For simpler further processing we map header types common\n  // for RAR 1.5 and 5.0 formats to RAR 5.0 values. It does not include\n  // header types specific for RAR 1.5 - 4.x only.\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD3_MAIN:    ShortBlock.HeaderType=HEAD_MAIN;     break;\n    case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;\n    case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;\n    case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;\n  }\n  CurHeaderType=ShortBlock.HeaderType;\n\n  if (ShortBlock.HeaderType==HEAD3_CMT)\n  {\n    // Old style (up to RAR 2.9) comment header embedded into main\n    // or file header. We must not read the entire ShortBlock.HeadSize here\n    // to not break the comment processing logic later.\n    Raw.Read(SIZEOF_COMMHEAD-SIZEOF_SHORTBLOCKHEAD);\n  }\n  else\n    if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)\n    {\n      // Old style (up to RAR 2.9) main archive comment embedded into\n      // the main archive header found. While we can read the entire\n      // ShortBlock.HeadSize here and remove this part of \"if\", it would be\n      // waste of memory, because we'll read and process this comment data\n      // in other function anyway and we do not need them here now.\n      Raw.Read(SIZEOF_MAINHEAD3-SIZEOF_SHORTBLOCKHEAD);\n    }\n    else\n      Raw.Read(ShortBlock.HeadSize-SIZEOF_SHORTBLOCKHEAD);\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_MAIN:\n      MainHead.Reset();\n      *(BaseBlock *)&MainHead=ShortBlock;\n      MainHead.HighPosAV=Raw.Get2();\n      MainHead.PosAV=Raw.Get4();\n\n      Volume=(MainHead.Flags & MHD_VOLUME)!=0;\n      Solid=(MainHead.Flags & MHD_SOLID)!=0;\n      Locked=(MainHead.Flags & MHD_LOCK)!=0;\n      Protected=(MainHead.Flags & MHD_PROTECT)!=0;\n      Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;\n      Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;\n      MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;\n\n      // Only for encrypted 3.0+ archives. 2.x archives did not have this\n      // flag, so for non-encrypted archives, we'll set it later based on\n      // file attributes.\n      FirstVolume=(MainHead.Flags & MHD_FIRSTVOLUME)!=0;\n\n      NewNumbering=(MainHead.Flags & MHD_NEWNUMBERING)!=0;\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n        FileHeader *hd=FileBlock ? &FileHead:&SubHead;\n        hd->Reset();\n\n        *(BaseBlock *)hd=ShortBlock;\n\n        hd->SplitBefore=(hd->Flags & LHD_SPLIT_BEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & LHD_SPLIT_AFTER)!=0;\n        hd->Encrypted=(hd->Flags & LHD_PASSWORD)!=0;\n        hd->SaltSet=(hd->Flags & LHD_SALT)!=0;\n        hd->Solid=FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->SubBlock=!FileBlock && (hd->Flags & LHD_SOLID)!=0;\n        hd->Dir=(hd->Flags & LHD_WINDOWMASK)==LHD_DIRECTORY;\n        hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);\n        hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;\n        hd->Version=(hd->Flags & LHD_VERSION)!=0;\n\n        hd->DataSize=Raw.Get4();\n        uint LowUnpSize=Raw.Get4();\n        hd->HostOS=Raw.Get1();\n\n        hd->FileHash.Type=HASH_CRC32;\n        hd->FileHash.CRC32=Raw.Get4();\n\n        uint FileTime=Raw.Get4();\n        hd->UnpVer=Raw.Get1();\n\n        hd->Method=Raw.Get1()-0x30;\n        size_t NameSize=Raw.Get2();\n        hd->FileAttr=Raw.Get4();\n\n        // RAR15 did not use the special dictionary size to mark dirs.\n        if (hd->UnpVer<20 && (hd->FileAttr & 0x10)!=0)\n          hd->Dir=true;\n\n        hd->CryptMethod=CRYPT_NONE;\n        if (hd->Encrypted)\n          switch(hd->UnpVer)\n          {\n            case 13: hd->CryptMethod=CRYPT_RAR13; break;\n            case 15: hd->CryptMethod=CRYPT_RAR15; break;\n            case 20:\n            case 26: hd->CryptMethod=CRYPT_RAR20; break;\n            default: hd->CryptMethod=CRYPT_RAR30; break;\n          }\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST_UNIX || hd->HostOS==HOST_BEOS)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS<HOST_MAX)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->RedirType=FSREDIR_NONE;\n\n        // RAR 4.x Unix symlink.\n        if (hd->HostOS==HOST_UNIX && (hd->FileAttr & 0xF000)==0xA000)\n        {\n          hd->RedirType=FSREDIR_UNIXSYMLINK;\n          *hd->RedirName=0;\n        }\n\n        hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;\n\n        hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;\n\n        uint HighPackSize,HighUnpSize;\n        if (hd->LargeFile)\n        {\n          HighPackSize=Raw.Get4();\n          HighUnpSize=Raw.Get4();\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);\n        }\n        else\n        {\n          HighPackSize=HighUnpSize=0;\n          // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates\n          // that we do not know the unpacked file size and must unpack it\n          // until we find the end of file marker in compressed data.\n          hd->UnknownUnpSize=(LowUnpSize==0xffffffff);\n        }\n        hd->PackSize=INT32TO64(HighPackSize,hd->DataSize);\n        hd->UnpSize=INT32TO64(HighUnpSize,LowUnpSize);\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        if (FileBlock)\n        {\n          *hd->FileName=0;\n          if ((hd->Flags & LHD_UNICODE)!=0)\n          {\n            EncodeFileName NameCoder;\n            size_t Length=strlen(FileName);\n            Length++;\n            if (ReadNameSize>Length)\n              NameCoder.Decode(FileName,ReadNameSize,(byte *)FileName+Length,\n                               ReadNameSize-Length,hd->FileName,\n                               ASIZE(hd->FileName));\n          }\n\n          if (*hd->FileName==0)\n            ArcCharToWide(FileName,hd->FileName,ASIZE(hd->FileName),ACTW_OEM);\n\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n        else\n        {\n          CharToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n          // Calculate the size of optional data.\n          int DataSize=int(hd->HeadSize-NameSize-SIZEOF_FILEHEAD3);\n          if ((hd->Flags & LHD_SALT)!=0)\n            DataSize-=SIZE_SALT30;\n\n          if (DataSize>0)\n          {\n            // Here we read optional additional fields for subheaders.\n            // They are stored after the file name and before salt.\n            hd->SubData.Alloc(DataSize);\n            Raw.GetB(&hd->SubData[0],DataSize);\n\n          }\n\n          if (hd->CmpName(SUBHEAD_TYPE_CMT))\n            MainComment=true;\n        }\n        if ((hd->Flags & LHD_SALT)!=0)\n          Raw.GetB(hd->Salt,SIZE_SALT30);\n        hd->mtime.SetDos(FileTime);\n        if ((hd->Flags & LHD_EXTTIME)!=0)\n        {\n          ushort Flags=Raw.Get2();\n          RarTime *tbl[4];\n          tbl[0]=&FileHead.mtime;\n          tbl[1]=&FileHead.ctime;\n          tbl[2]=&FileHead.atime;\n          tbl[3]=NULL; // Archive time is not used now.\n          for (int I=0;I<4;I++)\n          {\n            RarTime *CurTime=tbl[I];\n            uint rmode=Flags>>(3-I)*4;\n            if ((rmode & 8)==0 || CurTime==NULL)\n              continue;\n            if (I!=0)\n            {\n              uint DosTime=Raw.Get4();\n              CurTime->SetDos(DosTime);\n            }\n            RarLocalTime rlt;\n            CurTime->GetLocal(&rlt);\n            if (rmode & 4)\n              rlt.Second++;\n            rlt.Reminder=0;\n            uint count=rmode&3;\n            for (uint J=0;J<count;J++)\n            {\n              byte CurByte=Raw.Get1();\n              rlt.Reminder|=(((uint)CurByte)<<((J+3-count)*8));\n            }\n            // Convert from 100ns RAR precision to REMINDER_PRECISION.\n            rlt.Reminder*=RarTime::REMINDER_PRECISION/10000000;\n            CurTime->SetLocal(&rlt);\n          }\n        }\n        // Set to 0 in case of overflow, so end of ReadHeader cares about it.\n        NextBlockPos=SafeAdd(NextBlockPos,hd->PackSize,0);\n\n        bool CRCProcessedOnly=hd->CommentInHeader;\n        ushort HeaderCRC=Raw.GetCRC15(CRCProcessedOnly);\n        if (hd->HeadCRC!=HeaderCRC)\n        {\n          BrokenHeader=true;\n          ErrHandler.SetErrorCode(RARX_WARNING);\n\n          // If we have a broken encrypted header, we do not need to display\n          // the error message here, because it will be displayed for such\n          // headers later in this function. Also such headers are unlikely\n          // to have anything sensible in file name field, so it is useless\n          // to display the file name.\n          if (!Decrypt)\n            uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n        }\n      }\n      break;\n    case HEAD_ENDARC:\n      *(BaseBlock *)&EndArcHead=ShortBlock;\n      EndArcHead.NextVolume=(EndArcHead.Flags & EARC_NEXT_VOLUME)!=0;\n      EndArcHead.DataCRC=(EndArcHead.Flags & EARC_DATACRC)!=0;\n      EndArcHead.RevSpace=(EndArcHead.Flags & EARC_REVSPACE)!=0;\n      EndArcHead.StoreVolNumber=(EndArcHead.Flags & EARC_VOLNUMBER)!=0;\n      if (EndArcHead.DataCRC)\n        EndArcHead.ArcDataCRC=Raw.Get4();\n      if (EndArcHead.StoreVolNumber)\n        VolNumber=EndArcHead.VolNumber=Raw.Get2();\n      break;\n#ifndef SFX_MODULE\n    case HEAD3_CMT:\n      *(BaseBlock *)&CommHead=ShortBlock;\n      CommHead.UnpSize=Raw.Get2();\n      CommHead.UnpVer=Raw.Get1();\n      CommHead.Method=Raw.Get1();\n      CommHead.CommCRC=Raw.Get2();\n      break;\n    case HEAD3_PROTECT:\n      *(BaseBlock *)&ProtectHead=ShortBlock;\n      ProtectHead.DataSize=Raw.Get4();\n      ProtectHead.Version=Raw.Get1();\n      ProtectHead.RecSectors=Raw.Get2();\n      ProtectHead.TotalBlocks=Raw.Get4();\n      Raw.GetB(ProtectHead.Mark,8);\n      NextBlockPos+=ProtectHead.DataSize;\n      break;\n    case HEAD3_OLDSERVICE: // RAR 2.9 and earlier.\n      *(BaseBlock *)&SubBlockHead=ShortBlock;\n      SubBlockHead.DataSize=Raw.Get4();\n      NextBlockPos+=SubBlockHead.DataSize;\n      SubBlockHead.SubType=Raw.Get2();\n      SubBlockHead.Level=Raw.Get1();\n      switch(SubBlockHead.SubType)\n      {\n        case UO_HEAD:\n          *(SubBlockHeader *)&UOHead=SubBlockHead;\n          UOHead.OwnerNameSize=Raw.Get2();\n          UOHead.GroupNameSize=Raw.Get2();\n          if (UOHead.OwnerNameSize>=ASIZE(UOHead.OwnerName))\n            UOHead.OwnerNameSize=ASIZE(UOHead.OwnerName)-1;\n          if (UOHead.GroupNameSize>=ASIZE(UOHead.GroupName))\n            UOHead.GroupNameSize=ASIZE(UOHead.GroupName)-1;\n          Raw.GetB(UOHead.OwnerName,UOHead.OwnerNameSize);\n          Raw.GetB(UOHead.GroupName,UOHead.GroupNameSize);\n          UOHead.OwnerName[UOHead.OwnerNameSize]=0;\n          UOHead.GroupName[UOHead.GroupNameSize]=0;\n          break;\n        case NTACL_HEAD:\n          *(SubBlockHeader *)&EAHead=SubBlockHead;\n          EAHead.UnpSize=Raw.Get4();\n          EAHead.UnpVer=Raw.Get1();\n          EAHead.Method=Raw.Get1();\n          EAHead.EACRC=Raw.Get4();\n          break;\n        case STREAM_HEAD:\n          *(SubBlockHeader *)&StreamHead=SubBlockHead;\n          StreamHead.UnpSize=Raw.Get4();\n          StreamHead.UnpVer=Raw.Get1();\n          StreamHead.Method=Raw.Get1();\n          StreamHead.StreamCRC=Raw.Get4();\n          StreamHead.StreamNameSize=Raw.Get2();\n          if (StreamHead.StreamNameSize>=ASIZE(StreamHead.StreamName))\n            StreamHead.StreamNameSize=ASIZE(StreamHead.StreamName)-1;\n          Raw.GetB(StreamHead.StreamName,StreamHead.StreamNameSize);\n          StreamHead.StreamName[StreamHead.StreamNameSize]=0;\n          break;\n      }\n      break;\n#endif\n    default:\n      if (ShortBlock.Flags & LONG_BLOCK)\n        NextBlockPos+=Raw.Get4();\n      break;\n  }\n\n  ushort HeaderCRC=Raw.GetCRC15(false);\n\n  // Old AV header does not have header CRC properly set.\n  if (ShortBlock.HeadCRC!=HeaderCRC && ShortBlock.HeaderType!=HEAD3_SIGN &&\n      ShortBlock.HeaderType!=HEAD3_AV)\n  {\n    bool Recovered=false;\n    if (ShortBlock.HeaderType==HEAD_ENDARC && EndArcHead.RevSpace)\n    {\n      // Last 7 bytes of recovered volume can contain zeroes, because\n      // REV files store its own information (volume number, etc.) here.\n      int64 Length=Tell();\n      Seek(Length-7,SEEK_SET);\n      Recovered=true;\n      for (int J=0;J<7;J++)\n        if (GetByte()!=0)\n          Recovered=false;\n    }\n    if (!Recovered)\n    {\n      BrokenHeader=true;\n      ErrHandler.SetErrorCode(RARX_CRC);\n\n      if (Decrypt)\n      {\n        uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n        FailedHeaderDecryption=true;\n        return 0;\n      }\n    }\n  }\n\n  return Raw.Size();\n}\n\n\nsize_t Archive::ReadHeader50()\n{\n  RawRead Raw(this);\n\n  bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD5;\n\n  if (Decrypt)\n  {\n#if defined(RAR_NOCRYPT)\n    return 0;\n#else\n\n    if (Cmd->SkipEncrypted)\n    {\n      uiMsg(UIMSG_SKIPENCARC,FileName);\n      FailedHeaderDecryption=true; // Suppress error messages and quit quietly.\n      return 0;\n    }\n\n    byte HeadersInitV[SIZE_INITV];\n    if (Read(HeadersInitV,SIZE_INITV)!=SIZE_INITV)\n    {\n      UnexpEndArcMsg();\n      return 0;\n    }\n\n    // We repeat the password request only for manually entered passwords\n    // and not for -p<pwd>. Wrong password can be intentionally provided\n    // in -p<pwd> to not stop batch processing for encrypted archives.\n    bool GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n\n    RarCheckPassword CheckPwd;\n    if (CryptHead.UsePswCheck && !BrokenHeader)\n      CheckPwd.Set(CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,CryptHead.PswCheck);\n    \n    while (true) // Repeat the password prompt for wrong passwords.\n    {\n      RequestArcPassword(CheckPwd.IsSet() ? &CheckPwd:NULL);\n\n      byte PswCheck[SIZE_PSWCHECK];\n      HeadersCrypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,NULL,PswCheck);\n      // Verify password validity. If header is damaged, we cannot rely on\n      // password check value, because it can be damaged too.\n      if (CryptHead.UsePswCheck && !BrokenHeader &&\n          memcmp(PswCheck,CryptHead.PswCheck,SIZE_PSWCHECK)!=0)\n      {\n        if (GlobalPassword) // For -p<pwd> or Ctrl+P.\n        {\n          // This message is used by Android GUI to reset cached passwords.\n          // Update appropriate code if changed.\n          uiMsg(UIERROR_BADPSW,FileName,FileName);\n          FailedHeaderDecryption=true;\n          ErrHandler.SetErrorCode(RARX_BADPWD);\n          return 0;\n        }\n        else // For passwords entered manually.\n        {\n          // This message is used by Android GUI and Windows GUI and SFX to\n          // reset cached passwords. Update appropriate code if changed.\n          uiMsg(UIWAIT_BADPSW,FileName,FileName);\n          Cmd->Password.Clean();\n        }\n\n#ifdef RARDLL\n        // Avoid new requests for unrar.dll to prevent the infinite loop\n        // if app always returns the same password.\n        ErrHandler.SetErrorCode(RARX_BADPWD);\n        Cmd->DllError=ERAR_BAD_PASSWORD;\n        ErrHandler.Exit(RARX_BADPWD);\n#else\n        continue; // Request a password again.\n#endif\n      }\n      break;\n    }\n\n    Raw.SetCrypt(&HeadersCrypt);\n#endif\n  }\n\n  // Header size must not occupy more than 3 variable length integer bytes\n  // resulting in 2 MB maximum header size (MAX_HEADER_SIZE_RAR5),\n  // so here we read 4 byte CRC32 followed by 3 bytes or less of header size.\n  const size_t FirstReadSize=7; // Smallest possible block size.\n  if (Raw.Read(FirstReadSize)<FirstReadSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  ShortBlock.Reset();\n  ShortBlock.HeadCRC=Raw.Get4();\n  uint SizeBytes=Raw.GetVSize(4);\n  uint64 BlockSize=Raw.GetV();\n\n  if (BlockSize==0 || SizeBytes==0)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  int SizeToRead=int(BlockSize);\n  SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any.\n  uint HeaderSize=4+SizeBytes+(uint)BlockSize;\n\n  if (SizeToRead<0 || HeaderSize<SIZEOF_SHORTBLOCKHEAD5)\n  {\n    BrokenHeaderMsg();\n    return 0;\n  }\n\n  Raw.Read(SizeToRead);\n\n  if (Raw.Size()<HeaderSize)\n  {\n    UnexpEndArcMsg();\n    return 0;\n  }\n\n  uint HeaderCRC=Raw.GetCRC50();\n\n  ShortBlock.HeaderType=(HEADER_TYPE)Raw.GetV();\n  ShortBlock.Flags=(uint)Raw.GetV();\n  ShortBlock.SkipIfUnknown=(ShortBlock.Flags & HFL_SKIPIFUNKNOWN)!=0;\n  ShortBlock.HeadSize=HeaderSize;\n\n  CurHeaderType=ShortBlock.HeaderType;\n\n  bool BadCRC=(ShortBlock.HeadCRC!=HeaderCRC);\n  if (BadCRC)\n  {\n    BrokenHeaderMsg(); // Report, but attempt to process.\n\n    BrokenHeader=true;\n    ErrHandler.SetErrorCode(RARX_CRC);\n\n    if (Decrypt)\n    {\n      uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);\n      FailedHeaderDecryption=true;\n      return 0;\n    }\n  }\n\n  uint64 ExtraSize=0;\n  if ((ShortBlock.Flags & HFL_EXTRA)!=0)\n  {\n    ExtraSize=Raw.GetV();\n    if (ExtraSize>=ShortBlock.HeadSize)\n    {\n      BrokenHeaderMsg();\n      return 0;\n    }\n  }\n\n  uint64 DataSize=0;\n  if ((ShortBlock.Flags & HFL_DATA)!=0)\n    DataSize=Raw.GetV();\n\n  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);\n  // Set to 0 in case of overflow, so end of ReadHeader cares about it.\n  NextBlockPos=SafeAdd(NextBlockPos,DataSize,0);\n\n  switch(ShortBlock.HeaderType)\n  {\n    case HEAD_CRYPT:\n      {\n        *(BaseBlock *)&CryptHead=ShortBlock;\n        uint CryptVersion=(uint)Raw.GetV();\n        if (CryptVersion>CRYPT_VERSION)\n        {\n          wchar Info[20];\n          swprintf(Info,ASIZE(Info),L\"h%u\",CryptVersion);\n          UnkEncVerMsg(FileName,Info);\n          return 0;\n        }\n        uint EncFlags=(uint)Raw.GetV();\n        CryptHead.UsePswCheck=(EncFlags & CHFL_CRYPT_PSWCHECK)!=0;\n        CryptHead.Lg2Count=Raw.Get1();\n        if (CryptHead.Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n        {\n          wchar Info[20];\n          swprintf(Info,ASIZE(Info),L\"hc%u\",CryptHead.Lg2Count);\n          UnkEncVerMsg(FileName,Info);\n          return 0;\n        }\n\n        Raw.GetB(CryptHead.Salt,SIZE_SALT50);\n        if (CryptHead.UsePswCheck)\n        {\n          Raw.GetB(CryptHead.PswCheck,SIZE_PSWCHECK);\n\n          byte csum[SIZE_PSWCHECK_CSUM];\n          Raw.GetB(csum,SIZE_PSWCHECK_CSUM);\n\n          sha256_context ctx;\n          sha256_init(&ctx);\n          sha256_process(&ctx, CryptHead.PswCheck, SIZE_PSWCHECK);\n\n          byte Digest[SHA256_DIGEST_SIZE];\n          sha256_done(&ctx, Digest);\n\n          CryptHead.UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n        }\n        Encrypted=true;\n      }\n      break;\n    case HEAD_MAIN:\n      {\n        MainHead.Reset();\n        *(BaseBlock *)&MainHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n\n        Volume=(ArcFlags & MHFL_VOLUME)!=0;\n        Solid=(ArcFlags & MHFL_SOLID)!=0;\n        Locked=(ArcFlags & MHFL_LOCK)!=0;\n        Protected=(ArcFlags & MHFL_PROTECT)!=0;\n        Signed=false;\n        NewNumbering=true;\n\n        if ((ArcFlags & MHFL_VOLNUMBER)!=0)\n          VolNumber=(uint)Raw.GetV();\n        else\n          VolNumber=0;\n        FirstVolume=Volume && VolNumber==0;\n\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,&MainHead);\n\n#ifdef USE_QOPEN\n        if (!ProhibitQOpen && MainHead.Locator && MainHead.QOpenOffset>0 && Cmd->QOpenMode!=QOPEN_NONE)\n        {\n          // We seek to QO block in the end of archive when processing\n          // QOpen.Load, so we need to preserve current block positions\n          // to not break normal archive processing by calling function.\n          int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;\n          HEADER_TYPE SaveCurHeaderType=CurHeaderType;\n\n          QOpen.Init(this,false);\n          QOpen.Load(MainHead.QOpenOffset);\n\n          CurBlockPos=SaveCurBlockPos;\n          NextBlockPos=SaveNextBlockPos;\n          CurHeaderType=SaveCurHeaderType;\n        }\n#endif\n      }\n      break;\n    case HEAD_FILE:\n    case HEAD_SERVICE:\n      {\n        FileHeader *hd=ShortBlock.HeaderType==HEAD_FILE ? &FileHead:&SubHead;\n        hd->Reset(); // Clear hash, time fields and other stuff like flags.\n        *(BaseBlock *)hd=ShortBlock;\n\n        bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;\n\n        hd->LargeFile=true;\n\n        hd->PackSize=DataSize;\n        hd->FileFlags=(uint)Raw.GetV();\n        hd->UnpSize=Raw.GetV();\n\n        hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;\n        if (hd->UnknownUnpSize)\n          hd->UnpSize=INT64NDF;\n\n        hd->MaxSize=Max(hd->PackSize,hd->UnpSize);\n        hd->FileAttr=(uint)Raw.GetV();\n        if ((hd->FileFlags & FHFL_UTIME)!=0)\n          hd->mtime.SetUnix((time_t)Raw.Get4());\n\n        hd->FileHash.Type=HASH_NONE;\n        if ((hd->FileFlags & FHFL_CRC32)!=0)\n        {\n          hd->FileHash.Type=HASH_CRC32;\n          hd->FileHash.CRC32=Raw.Get4();\n        }\n\n        hd->RedirType=FSREDIR_NONE;\n\n        uint CompInfo=(uint)Raw.GetV();\n        hd->Method=(CompInfo>>7) & 7;\n\n        // \"+ 50\" to not mix with old RAR format algorithms. For example,\n        // we may need to use the compression algorithm 15 in the future,\n        // but it was already used in RAR 1.5 and Unpack needs to distinguish\n        // them.\n        hd->UnpVer=(CompInfo & 0x3f) + 50;\n        if (hd->UnpVer!=50) // Only 5.0 compression is known now.\n          hd->UnpVer=VER_UNKNOWN;\n\n        hd->HostOS=(byte)Raw.GetV();\n        size_t NameSize=(size_t)Raw.GetV();\n        hd->Inherited=(ShortBlock.Flags & HFL_INHERITED)!=0;\n\n        hd->HSType=HSYS_UNKNOWN;\n        if (hd->HostOS==HOST5_UNIX)\n          hd->HSType=HSYS_UNIX;\n        else\n          if (hd->HostOS==HOST5_WINDOWS)\n            hd->HSType=HSYS_WINDOWS;\n\n        hd->SplitBefore=(hd->Flags & HFL_SPLITBEFORE)!=0;\n        hd->SplitAfter=(hd->Flags & HFL_SPLITAFTER)!=0;\n        hd->SubBlock=(hd->Flags & HFL_CHILD)!=0;\n        hd->Solid=FileBlock && (CompInfo & FCI_SOLID)!=0;\n        hd->Dir=(hd->FileFlags & FHFL_DIRECTORY)!=0;\n        hd->WinSize=hd->Dir ? 0:size_t(0x20000)<<((CompInfo>>10)&0xf);\n\n        char FileName[NM*4];\n        size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n        Raw.GetB((byte *)FileName,ReadNameSize);\n        FileName[ReadNameSize]=0;\n\n        UtfToWide(FileName,hd->FileName,ASIZE(hd->FileName));\n\n        // Should do it before converting names, because extra fields can\n        // affect name processing, like in case of NTFS streams.\n        if (ExtraSize!=0)\n          ProcessExtra50(&Raw,(size_t)ExtraSize,hd);\n\n        if (FileBlock)\n        {\n#ifndef SFX_MODULE\n          ConvertNameCase(hd->FileName);\n#endif\n          ConvertFileHeader(hd);\n        }\n\n        if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_CMT))\n          MainComment=true;\n\n\n        if (BadCRC) // Add the file name to broken header message displayed above.\n          uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);\n      }\n      break;\n    case HEAD_ENDARC:\n      {\n        *(BaseBlock *)&EndArcHead=ShortBlock;\n        uint ArcFlags=(uint)Raw.GetV();\n        EndArcHead.NextVolume=(ArcFlags & EHFL_NEXTVOLUME)!=0;\n        EndArcHead.StoreVolNumber=false;\n        EndArcHead.DataCRC=false;\n        EndArcHead.RevSpace=false;\n      }\n      break;\n  }\n\n  return Raw.Size();\n}\n\n\n#if !defined(RAR_NOCRYPT)\nvoid Archive::RequestArcPassword(RarCheckPassword *CheckPwd)\n{\n  if (!Cmd->Password.IsSet())\n  {\n#ifdef RARDLL\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n    }\n    if (!Cmd->Password.IsSet())\n    {\n      Close();\n      Cmd->DllError=ERAR_MISSING_PASSWORD;\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#else\n    if (!uiGetPassword(UIPASSWORD_ARCHIVE,FileName,&Cmd->Password,CheckPwd))\n    {\n      Close();\n      uiMsg(UIERROR_INCERRCOUNT); // Prevent archive deleting if delete after extraction is on.\n      ErrHandler.Exit(RARX_USERBREAK);\n    }\n#endif\n    Cmd->ManualPassword=true;\n  }\n}\n#endif\n\n\nvoid Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,const BaseBlock *bb)\n{\n  // Read extra data from the end of block skipping any fields before it.\n  size_t ExtraStart=Raw->Size()-ExtraSize;\n  if (ExtraStart<Raw->GetPos())\n    return;\n  Raw->SetPos(ExtraStart);\n  while (Raw->DataLeft()>=2)\n  {\n    int64 FieldSize=Raw->GetV(); // Needs to be signed for check below and can be negative.\n    if (FieldSize<=0 || Raw->DataLeft()==0 || FieldSize>(int64)Raw->DataLeft())\n      break;\n    size_t NextPos=size_t(Raw->GetPos()+FieldSize);\n    uint64 FieldType=Raw->GetV();\n\n    FieldSize=int64(NextPos-Raw->GetPos()); // Field size without size and type fields.\n\n    if (FieldSize<0) // FieldType is longer than expected extra field size.\n      break;\n\n    if (bb->HeaderType==HEAD_MAIN)\n    {\n      MainHeader *hd=(MainHeader *)bb;\n      switch(FieldType)\n      {\n        case MHEXTRA_LOCATOR:\n          {\n            hd->Locator=true;\n            uint Flags=(uint)Raw->GetV();\n            if ((Flags & MHEXTRA_LOCATOR_QLIST)!=0)\n            {\n              uint64 Offset=Raw->GetV();\n              if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n                hd->QOpenOffset=Offset+CurBlockPos;\n            }\n            if ((Flags & MHEXTRA_LOCATOR_RR)!=0)\n            {\n              uint64 Offset=Raw->GetV();\n              if (Offset!=0) // 0 means that reserved space was not enough to write the offset.\n                hd->RROffset=Offset+CurBlockPos;\n            }\n          }\n          break;\n        case MHEXTRA_METADATA:\n          {\n            uint Flags=(uint)Raw->GetV();\n            if ((Flags & MHEXTRA_METADATA_NAME)!=0)\n            {\n              uint64 NameSize=Raw->GetV();\n              if (NameSize<0x10000) // Prevent excessive allocation.\n              {\n                std::vector<char> NameU((size_t)NameSize); // UTF-8 name.\n                Raw->GetB(&NameU[0],(size_t)NameSize);\n                // If starts from 0, the name was longer han reserved space\n                // when saving this extra field.\n                if (NameU[0]!=0)\n                {\n                  NameU.push_back(0);\n                  std::vector<wchar> NameW(NameU.size()*4);\n                  UtfToWide(&NameU[0],&NameW[0],NameW.size());\n                  hd->OrigName.assign(&NameW[0]);\n                }\n              }\n            }\n            if ((Flags & MHEXTRA_METADATA_CTIME)!=0)\n              if ((Flags & MHEXTRA_METADATA_UNIXTIME)!=0)\n                if ((Flags & MHEXTRA_METADATA_UNIX_NS)!=0)\n                  hd->OrigCtime.SetUnixNS(Raw->Get8());\n                else\n                  hd->OrigCtime.SetUnix((time_t)Raw->Get4());\n              else\n                hd->OrigCtime.SetWin(Raw->Get8());\n          }\n          break;\n      }\n    }\n\n    if (bb->HeaderType==HEAD_FILE || bb->HeaderType==HEAD_SERVICE)\n    {\n      FileHeader *hd=(FileHeader *)bb;\n      switch(FieldType)\n      {\n        case FHEXTRA_CRYPT:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint EncVersion=(uint)Raw->GetV();\n            if (EncVersion>CRYPT_VERSION)\n            {\n              wchar Info[20];\n              swprintf(Info,ASIZE(Info),L\"x%u\",EncVersion);\n              UnkEncVerMsg(hd->FileName,Info);\n            }\n            else\n            {\n              uint Flags=(uint)Raw->GetV();\n              hd->UsePswCheck=(Flags & FHEXTRA_CRYPT_PSWCHECK)!=0;\n              hd->UseHashKey=(Flags & FHEXTRA_CRYPT_HASHMAC)!=0;\n              hd->Lg2Count=Raw->Get1();\n              if (hd->Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)\n              {\n                wchar Info[20];\n                swprintf(Info,ASIZE(Info),L\"xc%u\",hd->Lg2Count);\n                UnkEncVerMsg(hd->FileName,Info);\n              }\n              Raw->GetB(hd->Salt,SIZE_SALT50);\n              Raw->GetB(hd->InitV,SIZE_INITV);\n              if (hd->UsePswCheck)\n              {\n                Raw->GetB(hd->PswCheck,SIZE_PSWCHECK);\n\n                // It is important to know if password check data is valid.\n                // If it is damaged and header CRC32 fails to detect it,\n                // archiver would refuse to decompress a possibly valid file.\n                // Since we want to be sure distinguishing a wrong password\n                // or corrupt file data, we use 64-bit password check data\n                // and to control its validity we use 32 bits of password\n                // check data SHA-256 additionally to 32-bit header CRC32.\n                byte csum[SIZE_PSWCHECK_CSUM];\n                Raw->GetB(csum,SIZE_PSWCHECK_CSUM);\n\n                sha256_context ctx;\n                sha256_init(&ctx);\n                sha256_process(&ctx, hd->PswCheck, SIZE_PSWCHECK);\n\n                byte Digest[SHA256_DIGEST_SIZE];\n                sha256_done(&ctx, Digest);\n\n                hd->UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;\n\n                // RAR 5.21 and earlier set PswCheck field in service records to 0\n                // even if UsePswCheck was present.\n                if (bb->HeaderType==HEAD_SERVICE && memcmp(hd->PswCheck,\"\\0\\0\\0\\0\\0\\0\\0\\0\",SIZE_PSWCHECK)==0)\n                  hd->UsePswCheck=0;\n              }\n              hd->SaltSet=true;\n              hd->CryptMethod=CRYPT_RAR50;\n              hd->Encrypted=true;\n            }\n          }\n          break;\n        case FHEXTRA_HASH:\n          {\n            FileHeader *hd=(FileHeader *)bb;\n            uint Type=(uint)Raw->GetV();\n            if (Type==FHEXTRA_HASH_BLAKE2)\n            {\n              hd->FileHash.Type=HASH_BLAKE2;\n              Raw->GetB(hd->FileHash.Digest,BLAKE2_DIGEST_SIZE);\n            }\n          }\n          break;\n        case FHEXTRA_HTIME:\n          if (FieldSize>=5)\n          {\n            byte Flags=(byte)Raw->GetV();\n            bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;\n            if ((Flags & FHEXTRA_HTIME_MTIME)!=0)\n              if (UnixTime)\n                hd->mtime.SetUnix(Raw->Get4());\n              else\n                hd->mtime.SetWin(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_CTIME)!=0)\n              if (UnixTime)\n                hd->ctime.SetUnix(Raw->Get4());\n              else\n                hd->ctime.SetWin(Raw->Get8());\n            if ((Flags & FHEXTRA_HTIME_ATIME)!=0)\n              if (UnixTime)\n                hd->atime.SetUnix((time_t)Raw->Get4());\n              else\n                hd->atime.SetWin(Raw->Get8());\n            if (UnixTime && (Flags & FHEXTRA_HTIME_UNIX_NS)!=0) // Add nanoseconds.\n            {\n              uint ns;\n              if ((Flags & FHEXTRA_HTIME_MTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->mtime.Adjust(ns);\n              if ((Flags & FHEXTRA_HTIME_CTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->ctime.Adjust(ns);\n              if ((Flags & FHEXTRA_HTIME_ATIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)\n                hd->atime.Adjust(ns);\n            }\n          }\n          break;\n        case FHEXTRA_VERSION:\n          if (FieldSize>=1)\n          {\n            Raw->GetV(); // Skip flags field.\n            uint Version=(uint)Raw->GetV();\n            if (Version!=0)\n            {\n              hd->Version=true;\n\n              wchar VerText[20];\n              swprintf(VerText,ASIZE(VerText),L\";%u\",Version);\n              wcsncatz(hd->FileName,VerText,ASIZE(hd->FileName));\n            }\n          }\n          break;\n        case FHEXTRA_REDIR:\n          {\n            hd->RedirType=(FILE_SYSTEM_REDIRECT)Raw->GetV();\n            uint Flags=(uint)Raw->GetV();\n            hd->DirTarget=(Flags & FHEXTRA_REDIR_DIR)!=0;\n            size_t NameSize=(size_t)Raw->GetV();\n\n            char UtfName[NM*4];\n            *UtfName=0;\n            if (NameSize<ASIZE(UtfName)-1)\n            {\n              Raw->GetB(UtfName,NameSize);\n              UtfName[NameSize]=0;\n            }\n#ifdef _WIN_ALL\n            UnixSlashToDos(UtfName,UtfName,ASIZE(UtfName));\n#endif\n            UtfToWide(UtfName,hd->RedirName,ASIZE(hd->RedirName));\n          }\n          break;\n        case FHEXTRA_UOWNER:\n          {\n            uint Flags=(uint)Raw->GetV();\n            hd->UnixOwnerNumeric=(Flags & FHEXTRA_UOWNER_NUMUID)!=0;\n            hd->UnixGroupNumeric=(Flags & FHEXTRA_UOWNER_NUMGID)!=0;\n            *hd->UnixOwnerName=*hd->UnixGroupName=0;\n            if ((Flags & FHEXTRA_UOWNER_UNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixOwnerName)-1);\n              Raw->GetB(hd->UnixOwnerName,Length);\n              hd->UnixOwnerName[Length]=0;\n            }\n            if ((Flags & FHEXTRA_UOWNER_GNAME)!=0)\n            {\n              size_t Length=(size_t)Raw->GetV();\n              Length=Min(Length,ASIZE(hd->UnixGroupName)-1);\n              Raw->GetB(hd->UnixGroupName,Length);\n              hd->UnixGroupName[Length]=0;\n            }\n#ifdef _UNIX\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uid_t)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(gid_t)Raw->GetV();\n#else\n            // Need these fields in Windows too for 'list' command,\n            // but uid_t and gid_t are not defined.\n            if (hd->UnixOwnerNumeric)\n              hd->UnixOwnerID=(uint)Raw->GetV();\n            if (hd->UnixGroupNumeric)\n              hd->UnixGroupID=(uint)Raw->GetV();\n#endif\n            hd->UnixOwnerSet=true;\n          }\n          break;\n        case FHEXTRA_SUBDATA:\n          {\n            // RAR 5.21 and earlier set FHEXTRA_SUBDATA size to 1 less than\n            // required. It did not hurt extraction, because UnRAR 5.21\n            // and earlier ignored this field and set FieldSize as data left\n            // in entire extra area. But now we set the correct field size\n            // and set FieldSize based on the actual extra record size,\n            // so we need to adjust it for those older archives here.\n            // FHEXTRA_SUBDATA in those archives always belongs to HEAD_SERVICE\n            // and always is last in extra area. So since its size is by 1\n            // less than needed, we always have 1 byte left in extra area,\n            // which fact we use here to detect such archives.\n            if (bb->HeaderType==HEAD_SERVICE && Raw->Size()-NextPos==1)\n              FieldSize++;\n\n            // We cannot allocate too much memory here, because above\n            // we check FieldSize againt Raw size and we control that Raw size\n            // is sensible when reading headers.\n            hd->SubData.Alloc((size_t)FieldSize);\n            Raw->GetB(hd->SubData.Addr(0),(size_t)FieldSize);\n          }\n          break;\n      }\n    }\n\n    Raw->SetPos(NextPos);\n  }\n}\n\n\n#ifndef SFX_MODULE\nsize_t Archive::ReadHeader14()\n{\n  RawRead Raw(this);\n  if (CurBlockPos<=(int64)SFXSize)\n  {\n    Raw.Read(SIZEOF_MAINHEAD14);\n    MainHead.Reset();\n    byte Mark[4];\n    Raw.GetB(Mark,4);\n    uint HeadSize=Raw.Get2();\n    if (HeadSize<7)\n      return false;\n    byte Flags=Raw.Get1();\n    NextBlockPos=CurBlockPos+HeadSize;\n    CurHeaderType=HEAD_MAIN;\n\n    Volume=(Flags & MHD_VOLUME)!=0;\n    Solid=(Flags & MHD_SOLID)!=0;\n    Locked=(Flags & MHD_LOCK)!=0;\n    MainHead.CommentInHeader=(Flags & MHD_COMMENT)!=0;\n    MainHead.PackComment=(Flags & MHD_PACK_COMMENT)!=0;\n  }\n  else\n  {\n    Raw.Read(SIZEOF_FILEHEAD14);\n    FileHead.Reset();\n\n    FileHead.HeaderType=HEAD_FILE;\n    FileHead.DataSize=Raw.Get4();\n    FileHead.UnpSize=Raw.Get4();\n    FileHead.FileHash.Type=HASH_RAR14;\n    FileHead.FileHash.CRC32=Raw.Get2();\n    FileHead.HeadSize=Raw.Get2();\n    if (FileHead.HeadSize<21)\n      return false;\n    uint FileTime=Raw.Get4();\n    FileHead.FileAttr=Raw.Get1();\n    FileHead.Flags=Raw.Get1()|LONG_BLOCK;\n    FileHead.UnpVer=(Raw.Get1()==2) ? 13 : 10;\n    size_t NameSize=Raw.Get1();\n    FileHead.Method=Raw.Get1();\n\n    FileHead.SplitBefore=(FileHead.Flags & LHD_SPLIT_BEFORE)!=0;\n    FileHead.SplitAfter=(FileHead.Flags & LHD_SPLIT_AFTER)!=0;\n    FileHead.Encrypted=(FileHead.Flags & LHD_PASSWORD)!=0;\n    FileHead.CryptMethod=FileHead.Encrypted ? CRYPT_RAR13:CRYPT_NONE;\n\n    FileHead.PackSize=FileHead.DataSize;\n    FileHead.WinSize=0x10000;\n    FileHead.Dir=(FileHead.FileAttr & 0x10)!=0;\n\n    FileHead.HostOS=HOST_MSDOS;\n    FileHead.HSType=HSYS_WINDOWS;\n\n    FileHead.mtime.SetDos(FileTime);\n\n    Raw.Read(NameSize);\n\n    char FileName[NM];\n    size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);\n    Raw.GetB((byte *)FileName,ReadNameSize);\n    FileName[ReadNameSize]=0;\n    IntToExt(FileName,FileName,ASIZE(FileName));\n    CharToWide(FileName,FileHead.FileName,ASIZE(FileHead.FileName));\n    ConvertNameCase(FileHead.FileName);\n    ConvertFileHeader(&FileHead);\n\n    if (Raw.Size()!=0)\n      NextBlockPos=CurBlockPos+FileHead.HeadSize+FileHead.PackSize;\n    CurHeaderType=HEAD_FILE;\n  }\n  return NextBlockPos>CurBlockPos ? Raw.Size() : 0;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid Archive::ConvertNameCase(wchar *Name)\n{\n  if (Cmd->ConvertNames==NAMES_UPPERCASE)\n    wcsupper(Name);\n  if (Cmd->ConvertNames==NAMES_LOWERCASE)\n    wcslower(Name);\n}\n#endif\n\n\nbool Archive::IsArcDir()\n{\n  return FileHead.Dir;\n}\n\n\nvoid Archive::ConvertAttributes()\n{\n#if defined(_WIN_ALL) || defined(_EMX)\n  if (FileHead.HSType!=HSYS_WINDOWS)\n    FileHead.FileAttr=FileHead.Dir ? 0x10 : 0x20;\n#endif\n#ifdef _UNIX\n  // umask defines which permission bits must not be set by default\n  // when creating a file or directory. The typical default value\n  // for the process umask is S_IWGRP | S_IWOTH (octal 022),\n  // resulting in 0644 mode for new files.\n  // Normally umask is applied automatically when creating a file,\n  // but we set attributes with chmod later, so we need to calculate\n  // resulting attributes here. We do it only for non-Unix archives.\n  // We restore native Unix attributes as is, because it can be backup.\n  static mode_t mask = (mode_t) -1;\n\n  if (mask == (mode_t) -1)\n  {\n    // umask call returns the current umask value. Argument (022) is not\n    // really important here.\n    mask = umask(022);\n\n    // Restore the original umask value, which was changed to 022 above.\n    umask(mask);\n  }\n\n  switch(FileHead.HSType)\n  {\n    case HSYS_WINDOWS:\n      {\n        // Mapping MSDOS, OS/2 and Windows file attributes to Unix.\n\n        if (FileHead.FileAttr & 0x10) // FILE_ATTRIBUTE_DIRECTORY\n        {\n          // For directories we use 0777 mask.\n          FileHead.FileAttr=0777 & ~mask;\n        }\n        else\n          if (FileHead.FileAttr & 1)  // FILE_ATTRIBUTE_READONLY\n          {\n            // For read only files we use 0444 mask with 'w' bits turned off.\n            FileHead.FileAttr=0444 & ~mask;\n          }\n          else\n          {\n            // umask does not set +x for regular files, so we use 0666\n            // instead of 0777 as for directories.\n            FileHead.FileAttr=0666 & ~mask;\n          }\n      }\n      break;\n    case HSYS_UNIX:\n      break;\n    default:\n      if (FileHead.Dir)\n        FileHead.FileAttr=0x41ff & ~mask;\n      else\n        FileHead.FileAttr=0x81b6 & ~mask;\n      break;\n  }\n#endif\n}\n\n\nvoid Archive::ConvertFileHeader(FileHeader *hd)\n{\n  if (hd->HSType==HSYS_UNKNOWN)\n    if (hd->Dir)\n      hd->FileAttr=0x10;\n    else\n      hd->FileAttr=0x20;\n\n#ifdef _WIN_ALL\n  if (hd->HSType==HSYS_UNIX) // Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\n    ConvertToPrecomposed(hd->FileName,ASIZE(hd->FileName));\n#endif\n\n  for (wchar *s=hd->FileName;*s!=0;s++)\n  {\n#ifdef _UNIX\n    // Backslash is the invalid character for Windows file headers,\n    // but it can present in Unix file names extracted in Unix.\n    if (*s=='\\\\' && Format==RARFMT50 && hd->HSType==HSYS_WINDOWS)\n      *s='_';\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n    // RAR 5.0 archives do not use '\\' as path separator, so if we see it,\n    // it means that it is a part of Unix file name, which we cannot\n    // extract in Windows.\n    if (*s=='\\\\' && Format==RARFMT50)\n      *s='_';\n\n    // ':' in file names is allowed in Unix, but not in Windows.\n    // Even worse, file data will be written to NTFS stream on NTFS,\n    // so automatic name correction on file create error in extraction\n    // routine does not work. In Windows and DOS versions we better\n    // replace ':' now.\n    if (*s==':')\n      *s='_';\n#endif\n\n    // This code must be performed only after other path separator checks,\n    // because it produces backslashes illegal for some of checks above.\n    // Backslash is allowed in file names in Unix, but not in Windows.\n    // Still, RAR 4.x uses backslashes as path separator even in Unix.\n    // Forward slash is not allowed in both systems. In RAR 5.0 we use\n    // the forward slash as universal path separator.\n    if (*s=='/' || *s=='\\\\' && Format!=RARFMT50)\n      *s=CPATHDIVIDER;\n  }\n}\n\n\nint64 Archive::GetStartPos()\n{\n  int64 StartPos=SFXSize+MarkHead.HeadSize;\n  if (Format==RARFMT15)\n    StartPos+=MainHead.HeadSize;\n  else // RAR 5.0.\n    StartPos+=CryptHead.HeadSize+FullHeaderSize(MainHead.HeadSize);\n  return StartPos;\n}\n\n\nbool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      // Prevent the excessive allocation. When reading to memory, normally\n      // this function operates with reasonably small blocks, such as\n      // the archive comment, NTFS ACL or \"Zone.Identifier\" NTFS stream.\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}\n", "#ifndef _RAR_CRYPT_\n#define _RAR_CRYPT_\n\n\nenum CRYPT_METHOD {\n  CRYPT_NONE,CRYPT_RAR13,CRYPT_RAR15,CRYPT_RAR20,CRYPT_RAR30,CRYPT_RAR50\n};\n\n#define SIZE_SALT50              16\n#define SIZE_SALT30               8\n#define SIZE_INITV               16\n#define SIZE_PSWCHECK             8\n#define SIZE_PSWCHECK_CSUM        4\n\n#define CRYPT_BLOCK_SIZE         16\n#define CRYPT_BLOCK_MASK         (CRYPT_BLOCK_SIZE-1) // 0xf\n\n#define CRYPT5_KDF_LG2_COUNT     15 // LOG2 of PDKDF2 iteration count.\n#define CRYPT5_KDF_LG2_COUNT_MAX 24 // LOG2 of maximum accepted iteration count.\n#define CRYPT_VERSION             0 // Supported encryption version.\n\n\nclass CryptData\n{\n  struct KDF5CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT50];\n    byte Key[32];\n    uint Lg2Count; // Log2 of PBKDF2 repetition count.\n    byte PswCheckValue[SHA256_DIGEST_SIZE];\n    byte HashKeyValue[SHA256_DIGEST_SIZE];\n\n    KDF5CacheItem() {Clean();}\n    ~KDF5CacheItem() {Clean();}\n\n    void Clean()\n    {\n      cleandata(Salt,sizeof(Salt));\n      cleandata(Key,sizeof(Key));\n      cleandata(&Lg2Count,sizeof(Lg2Count));\n      cleandata(PswCheckValue,sizeof(PswCheckValue));\n      cleandata(HashKeyValue,sizeof(HashKeyValue));\n    }\n  };\n\n  struct KDF3CacheItem\n  {\n    SecPassword Pwd;\n    byte Salt[SIZE_SALT30];\n    byte Key[16];\n    byte Init[16];\n    bool SaltPresent;\n\n    KDF3CacheItem() {Clean();}\n    ~KDF3CacheItem() {Clean();}\n\n    void Clean()\n    {\n      cleandata(Salt,sizeof(Salt));\n      cleandata(Key,sizeof(Key));\n      cleandata(Init,sizeof(Init));\n      cleandata(&SaltPresent,sizeof(SaltPresent));\n    }\n  };\n\n\n  private:\n    void SetKey13(const char *Password);\n    void Decrypt13(byte *Data,size_t Count);\n\n    void SetKey15(const char *Password);\n    void Crypt15(byte *Data,size_t Count);\n\n    void SetKey20(const char *Password);\n    void Swap20(byte *Ch1,byte *Ch2);\n    void UpdKeys20(byte *Buf);\n    void EncryptBlock20(byte *Buf);\n    void DecryptBlock20(byte *Buf);\n\n    void SetKey30(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt);\n    void SetKey50(bool Encrypt,SecPassword *Password,const wchar *PwdW,const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck);\n\n    KDF3CacheItem KDF3Cache[4];\n    uint KDF3CachePos;\n    \n    KDF5CacheItem KDF5Cache[4];\n    uint KDF5CachePos;\n\n    CRYPT_METHOD Method;\n\n    Rijndael rin;\n\n    uint CRCTab[256]; // For RAR 1.5 and RAR 2.0 encryption.\n    \n    byte SubstTable20[256];\n    uint Key20[4];\n\n    byte Key13[3];\n    ushort Key15[4];\n  public:\n    CryptData();\n    bool SetCryptKeys(bool Encrypt,CRYPT_METHOD Method,SecPassword *Password,\n         const byte *Salt,const byte *InitV,uint Lg2Cnt,\n         byte *HashKey,byte *PswCheck);\n    void SetAV15Encryption();\n    void SetCmt13Encryption();\n    void EncryptBlock(byte *Buf,size_t Size);\n    void DecryptBlock(byte *Buf,size_t Size);\n    static void SetSalt(byte *Salt,size_t SaltSize);\n};\n\n\nclass CheckPassword\n{\n  public:\n    enum CONFIDENCE {CONFIDENCE_HIGH,CONFIDENCE_MEDIUM,CONFIDENCE_LOW};\n    virtual CONFIDENCE GetConfidence()=0;\n    virtual bool Check(SecPassword *Password)=0;\n};\n\nclass RarCheckPassword:public CheckPassword\n{\n  private:\n    CryptData *Crypt;\n    uint Lg2Count;\n    byte Salt[SIZE_SALT50];\n    byte InitV[SIZE_INITV];\n    byte PswCheck[SIZE_PSWCHECK];\n  public:\n    RarCheckPassword()\n    {\n      Crypt=NULL;\n    }\n    ~RarCheckPassword()\n    {\n      delete Crypt;\n    }\n    void Set(byte *Salt,byte *InitV,uint Lg2Count,byte *PswCheck)\n    {\n      if (Crypt==NULL)\n        Crypt=new CryptData;\n      memcpy(this->Salt,Salt,sizeof(this->Salt));\n      memcpy(this->InitV,InitV,sizeof(this->InitV));\n      this->Lg2Count=Lg2Count;\n      memcpy(this->PswCheck,PswCheck,sizeof(this->PswCheck));\n    }\n    bool IsSet() {return Crypt!=NULL;}\n\n    // RAR5 provides the higly reliable 64 bit password verification value.\n    CONFIDENCE GetConfidence() {return CONFIDENCE_HIGH;}\n\n    bool Check(SecPassword *Password)\n    {\n      byte PswCheck[SIZE_PSWCHECK];\n      Crypt->SetCryptKeys(false,CRYPT_RAR50,Password,Salt,InitV,Lg2Count,NULL,PswCheck);\n      return memcmp(PswCheck,this->PswCheck,sizeof(this->PswCheck))==0;\n    }\n};\n\nvoid GetRnd(byte *RndBuf,size_t BufSize);\n\nvoid hmac_sha256(const byte *Key,size_t KeyLength,const byte *Data,\n                 size_t DataLength,byte *ResDigest);\nvoid pbkdf2(const byte *pass, size_t pass_len, const byte *salt,\n            size_t salt_len,byte *key, byte *Value1, byte *Value2,\n            uint rounds);\n\nvoid ConvertHashToMAC(HashValue *Value,byte *Key);\n\n#endif\n", "#include <windows.h>\n#include <commctrl.h>\n\nVS_VERSION_INFO VERSIONINFO\nFILEVERSION 6, 20, 3, 714\nPRODUCTVERSION 6, 20, 3, 714\nFILEOS VOS__WINDOWS32\nFILETYPE VFT_APP\n{\n  BLOCK \"StringFileInfo\"\n  {\n    BLOCK \"040904E4\"\n    {\n      VALUE \"CompanyName\", \"Alexander Roshal\\0\"\n      VALUE \"ProductName\", \"RAR decompression library\\0\"\n      VALUE \"FileDescription\", \"RAR decompression library\\0\"\n      VALUE \"FileVersion\", \"6.20.3\\0\"\n      VALUE \"ProductVersion\", \"6.20.3\\0\"\n      VALUE \"LegalCopyright\", \"Copyright \u0119 Alexander Roshal 1993-2022\\0\"\n      VALUE \"OriginalFilename\", \"Unrar.dll\\0\"\n    }\n  }\n  BLOCK \"VarFileInfo\"\n  {\n    VALUE \"Translation\", 0x0409, 0x04E4\n  }\n}\n\n", "#include \"rar.hpp\"\n\n#include \"hardlinks.cpp\"\n#include \"win32stm.cpp\"\n\n#ifdef _WIN_ALL\n#include \"win32acl.cpp\"\n#include \"win32lnk.cpp\"\n#endif\n\n#ifdef _UNIX\n#include \"uowners.cpp\"\n#ifdef SAVE_LINKS\n#include \"ulinks.cpp\"\n#endif\n#endif\n\n\n\n// RAR2 service header extra records.\n#ifndef SFX_MODULE\nvoid SetExtraInfo20(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n  if (Cmd->Test)\n    return;\n  switch(Arc.SubBlockHead.SubType)\n  {\n#ifdef _UNIX\n    case UO_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractUnixOwner20(Arc,Name);\n      break;\n#endif\n#ifdef _WIN_ALL\n    case NTACL_HEAD:\n      if (Cmd->ProcessOwners)\n        ExtractACL20(Arc,Name);\n      break;\n    case STREAM_HEAD:\n      ExtractStreams20(Arc,Name);\n      break;\n#endif\n  }\n}\n#endif\n\n\n// RAR3 and RAR5 service header extra records.\nvoid SetExtraInfo(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n#ifdef _UNIX\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.Format==RARFMT15 &&\n      Arc.SubHead.CmpName(SUBHEAD_TYPE_UOWNER))\n    ExtractUnixOwner30(Arc,Name);\n#endif\n#ifdef _WIN_ALL\n  if (!Cmd->Test && Cmd->ProcessOwners && Arc.SubHead.CmpName(SUBHEAD_TYPE_ACL))\n    ExtractACL(Arc,Name);\n  if (Arc.SubHead.CmpName(SUBHEAD_TYPE_STREAM))\n    ExtractStreams(Arc,Name,Cmd->Test);\n#endif\n}\n\n\n// Extra data stored directly in file header.\nvoid SetFileHeaderExtra(CommandData *Cmd,Archive &Arc,wchar *Name)\n{\n#ifdef _UNIX\n   if (Cmd->ProcessOwners && Arc.Format==RARFMT50 && Arc.FileHead.UnixOwnerSet)\n     SetUnixOwner(Arc,Name);\n#endif\n}\n\n\n\n\n// Calculate a number of path components except \\. and \\..\nstatic int CalcAllowedDepth(const wchar *Name)\n{\n  int AllowedDepth=0;\n  while (*Name!=0)\n  {\n    if (IsPathDiv(Name[0]) && Name[1]!=0 && !IsPathDiv(Name[1]))\n    {\n      bool Dot=Name[1]=='.' && (IsPathDiv(Name[2]) || Name[2]==0);\n      bool Dot2=Name[1]=='.' && Name[2]=='.' && (IsPathDiv(Name[3]) || Name[3]==0);\n      if (!Dot && !Dot2)\n        AllowedDepth++;\n    }\n    Name++;\n  }\n  return AllowedDepth;\n}\n\n\n// Check if all existing path components are directories and not links.\nstatic bool LinkInPath(const wchar *Name)\n{\n  wchar Path[NM];\n  if (wcslen(Name)>=ASIZE(Path))\n    return true;  // It should not be that long, skip.\n  wcsncpyz(Path,Name,ASIZE(Path));\n  for (wchar *s=Path+wcslen(Path)-1;s>Path;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && (FD.IsLink || !FD.IsDir))\n        return true;\n    }\n  return false;\n}\n\n\n// Delete symbolic links in file path, if any, and replace them by directories.\n// Prevents extracting files outside of destination folder with symlink chains.\nbool LinksToDirs(const wchar *SrcName,const wchar *SkipPart,std::wstring &LastChecked)\n{\n  // Unlike Unix, Windows doesn't expand lnk1 in symlink targets like\n  // \"lnk1/../dir\", but converts the path to \"dir\". In Unix we need to call\n  // this function to prevent placing unpacked files outside of destination\n  // folder if previously we unpacked \"dir/lnk1\" -> \"..\",\n  // \"dir/lnk2\" -> \"lnk1/..\" and \"dir/lnk2/anypath/poc.txt\".\n  // We may still need this function to prevent abusing symlink chains\n  // in link source path if we remove detection of such chains\n  // in IsRelativeSymlinkSafe. This function seems to make other symlink\n  // related safety checks redundant, but for now we prefer to keep them too.\n  //\n  // 2022.12.01: the performance impact is minimized after adding the check\n  // against the previous path and enabling this verification only after\n  // extracting a symlink with \"..\" in target. So we enabled it for Windows\n  // as well for extra safety.\n//#ifdef _UNIX\n  wchar Path[NM];\n  if (wcslen(SrcName)>=ASIZE(Path))\n    return false;  // It should not be that long, skip.\n  wcsncpyz(Path,SrcName,ASIZE(Path));\n\n  size_t SkipLength=wcslen(SkipPart);\n\n  if (SkipLength>0 && wcsncmp(Path,SkipPart,SkipLength)!=0)\n    SkipLength=0; // Parameter validation, not really needed now.\n\n  // Do not check parts already checked in previous path to improve performance.\n  for (uint I=0;Path[I]!=0 && I<LastChecked.size() && Path[I]==LastChecked[I];I++)\n    if (IsPathDiv(Path[I]) && I>SkipLength)\n      SkipLength=I;\n\n  wchar *Name=Path;\n  if (SkipLength>0)\n  {\n    // Avoid converting symlinks in destination path part specified by user.\n    Name+=SkipLength;\n    while (IsPathDiv(*Name))\n      Name++;\n  }\n\n  for (wchar *s=Path+wcslen(Path)-1;s>Name;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && FD.IsLink)\n#ifdef _WIN_ALL\n        if (!DelDir(Path))\n#else\n        if (!DelFile(Path))\n#endif\n          return false; // Couldn't delete the symlink to replace it with directory.\n    }\n  LastChecked=SrcName;\n//#endif\n  return true;\n}\n\n\nbool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  // Catch root dir based /path/file paths also as stuff like \\\\?\\.\n  // Do not check PrepSrcName here, it can be root based if destination path\n  // is a root based.\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n\n  // Number of \"..\" in link target.\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  // If link target includes \"..\", it must not have another links in its\n  // source path, because they can bypass our safety check. For example,\n  // suppose we extracted \"lnk1\" -> \".\" first and \"lnk1/lnk2\" -> \"..\" next\n  // or \"dir/lnk1\" -> \"..\" first, \"dir/lnk1/lnk2\" -> \"..\" next and\n  // file \"dir/lnk1/lnk2/poc.txt\" last.\n  // Do not confuse with link chains in target, this is in link source path.\n  // It is important for Windows too, though this check can be omitted\n  // if LinksToDirs is invoked in Windows as well.\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n    \n  // We could check just prepared src name, but for extra safety\n  // we check both original (as from archive header) and prepared\n  // (after applying the destination path and -ep switches) names.\n\n  int AllowedDepth=CalcAllowedDepth(SrcName); // Original name depth.\n\n  // Remove the destination path from prepared name if any. We should not\n  // count the destination path depth, because the link target must point\n  // inside of this path, not outside of it.\n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}\n\n\nbool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName,bool &UpLink)\n{\n  // Returning true in Uplink indicates that link target might include \"..\"\n  // and enables additional checks. It is ok to falsely return true here,\n  // as it implies only the minor performance penalty. But we shall always\n  // return true for links with \"..\" in target for security reason.\n\n  UpLink=true; // Assume the target might include potentially unsafe \"..\".\n#if defined(SAVE_LINKS) && defined(_UNIX) || defined(_WIN_ALL)\n  if (Arc.Format==RARFMT50) // For RAR5 archives we can check RedirName for both Unix and Windows.\n    UpLink=wcsstr(Arc.FileHead.RedirName,L\"..\")!=NULL;\n#endif\n\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName,UpLink);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined(_WIN_ALL)\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}\n", "#ifndef _RAR_EXTINFO_\n#define _RAR_EXTINFO_\n\nbool LinksToDirs(const wchar *SrcName,const wchar *SkipPart,std::wstring &LastChecked);\nbool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName);\nbool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName,bool &UpLink);\n#ifdef _UNIX\nvoid SetUnixOwner(Archive &Arc,const wchar *FileName);\n#endif\n\nbool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize);\n\nvoid GetStreamNameNTFS(Archive &Arc,wchar *StreamName,size_t MaxSize);\n\n#ifdef _WIN_ALL\nbool SetPrivilege(LPCTSTR PrivName);\n#endif\n\nvoid SetExtraInfo20(CommandData *Cmd,Archive &Arc,wchar *Name);\nvoid SetExtraInfo(CommandData *Cmd,Archive &Arc,wchar *Name);\nvoid SetFileHeaderExtra(CommandData *Cmd,Archive &Arc,wchar *Name);\n\n\n#endif\n", "#include \"rar.hpp\"\n\nCmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n\n  *ArcName=0;\n  *DestFileName=0;\n\n  ArcAnalyzed=false;\n  Analyze=new AnalyzeData;\n  memset(Analyze,0,sizeof(*Analyze));\n\n  TotalFileCount=0;\n\n  // Common for all archives involved. Set here instead of DoExtract()\n  // to use in unrar.dll too. Allows to avoid LinksToDirs() calls\n  // and save CPU time in no symlinks including \"..\" in target were extracted.\n  UpLinkExtracted=false;\n\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}\n\n\nCmdExtract::~CmdExtract()\n{\n  ReleaseAnalyzeData();\n  delete Unp;\n  delete Analyze;\n}\n\n\nvoid CmdExtract::ReleaseAnalyzeData()\n{\n  for (size_t I=0;I<RefList.Size();I++)\n  {\n    // We can have undeleted temporary reference source here if extraction\n    // was interrupted early or if user refused to overwrite prompt.\n    if (RefList[I].TmpName!=NULL)\n      DelFile(RefList[I].TmpName);\n    free(RefList[I].RefName);\n    free(RefList[I].TmpName);\n  }\n  RefList.Reset();\n\n  memset(Analyze,0,sizeof(*Analyze));\n}\n\n\nvoid CmdExtract::DoExtract()\n{\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n  Fat32=NotFat32=false;\n#endif\n  PasswordCancelled=false;\n  DataIO.SetCurrentCommand(Cmd->Command[0]);\n\n  if (*Cmd->UseStdin==0)\n  {\n    FindData FD;\n    while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n      if (FindFile::FastFind(ArcName,&FD))\n        DataIO.TotalArcSize+=FD.Size;\n  }\n\n  Cmd->ArcNames.Rewind();\n  while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))\n  {\n    if (Cmd->ManualPassword)\n      Cmd->Password.Clean(); // Clean user entered password before processing next archive.\n  \n    ReconstructDone=false; // Must be reset here, not in ExtractArchiveInit().\n    UseExactVolName=false; // Must be reset here, not in ExtractArchiveInit().\n    while (true)\n    {\n      EXTRACT_ARC_CODE Code=ExtractArchive();\n      if (Code!=EXTRACT_ARC_REPEAT)\n        break;\n    }\n    DataIO.ProcessedArcSize+=DataIO.LastArcSize;\n  }\n\n  // Clean user entered password. Not really required, just for extra safety.\n  if (Cmd->ManualPassword)\n    Cmd->Password.Clean();\n\n  if (TotalFileCount==0 && Cmd->Command[0]!='I' && \n      ErrHandler.GetErrorCode()!=RARX_BADPWD) // Not in case of wrong archive password.\n  {\n    if (!PasswordCancelled)\n      uiMsg(UIERROR_NOFILESTOEXTRACT,ArcName);\n\n    // Other error codes may explain a reason of \"no files extracted\" clearer,\n    // so set it only if no other errors found (wrong mask set by user).\n    if (ErrHandler.GetErrorCode()==RARX_SUCCESS)\n      ErrHandler.SetErrorCode(RARX_NOFILES);\n  }\n  else\n    if (!Cmd->DisableDone)\n      if (Cmd->Command[0]=='I')\n        mprintf(St(MDone));\n      else\n        if (ErrHandler.GetErrorCount()==0)\n          mprintf(St(MExtrAllOk));\n        else\n          mprintf(St(MExtrTotalErr),ErrHandler.GetErrorCount());\n}\n\n\nvoid CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n\n  DataIO.UnpVolume=false;\n\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n\n  ArcAnalyzed=false;\n\n  StartTime.SetCurrentTime();\n\n  LastCheckedSymlink.clear();\n}\n\n\nEXTRACT_ARC_CODE CmdExtract::ExtractArchive()\n{\n  Archive Arc(Cmd);\n  if (*Cmd->UseStdin!=0)\n  {\n    Arc.SetHandleType(FILE_HANDLESTD);\n#ifdef USE_QOPEN\n    Arc.SetProhibitQOpen(true);\n#endif\n  }\n  else\n  {\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) // WinRAR GUI code also resets the cache.\n    if (*Cmd->Command=='T' || Cmd->Test)\n      ResetFileCache(ArcName); // Reset the file cache when testing an archive.\n#endif\n    if (!Arc.WOpen(ArcName))\n      return EXTRACT_ARC_NEXT;\n  }\n\n  if (!Arc.IsArchive(true))\n  {\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n    if (CmpExt(ArcName,L\"rev\"))\n    {\n      wchar FirstVolName[NM];\n      VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),true);\n\n      // If several volume names from same volume set are specified\n      // and current volume is not first in set and first volume is present\n      // and specified too, let's skip the current volume.\n      if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n          Cmd->ArcNames.Search(FirstVolName,false))\n        return EXTRACT_ARC_NEXT;\n      RecVolumesTest(Cmd,NULL,ArcName);\n      TotalFileCount++; // Suppress \"No files to extract\" message.\n      return EXTRACT_ARC_NEXT;\n    }\n#endif\n\n    mprintf(St(MNotRAR),ArcName);\n\n#ifndef SFX_MODULE\n    if (CmpExt(ArcName,L\"rar\"))\n#endif\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    return EXTRACT_ARC_NEXT;\n  }\n\n  if (Arc.FailedHeaderDecryption) // Bad archive password.\n    return EXTRACT_ARC_NEXT;\n\n#ifndef SFX_MODULE\n  if (Arc.Volume && !Arc.FirstVolume && !UseExactVolName)\n  {\n    wchar FirstVolName[NM];\n    VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),Arc.NewNumbering);\n\n    // If several volume names from same volume set are specified\n    // and current volume is not first in set and first volume is present\n    // and specified too, let's skip the current volume.\n    if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&\n        Cmd->ArcNames.Search(FirstVolName,false))\n      return EXTRACT_ARC_NEXT;\n  }\n#endif\n\n  Arc.ViewComment(); // Must be before possible EXTRACT_ARC_REPEAT.\n\n  int64 VolumeSetSize=0; // Total size of volumes after the current volume.\n\n#ifndef SFX_MODULE\n  if (!ArcAnalyzed && *Cmd->UseStdin==0)\n  {\n    AnalyzeArchive(Arc.FileName,Arc.Volume,Arc.NewNumbering);\n    ArcAnalyzed=true; // Avoid repeated analysis on EXTRACT_ARC_REPEAT.\n  }\n#endif\n\n  if (Arc.Volume)\n  {\n#ifndef SFX_MODULE\n    // Try to speed up extraction for independent solid volumes by starting\n    // extraction from non-first volume if we can.\n    if (*Analyze->StartName!=0)\n    {\n      wcsncpyz(ArcName,Analyze->StartName,ASIZE(ArcName));\n      *Analyze->StartName=0;\n\n      UseExactVolName=true;\n      return EXTRACT_ARC_REPEAT;\n    }\n#endif\n    \n    // Calculate the total size of all accessible volumes.\n    // This size is necessary to display the correct total progress indicator.\n\n    wchar NextName[NM];\n    wcsncpyz(NextName,Arc.FileName,ASIZE(NextName));\n\n    while (true)\n    {\n      // First volume is already added to DataIO.TotalArcSize \n      // in initial TotalArcSize calculation in DoExtract.\n      // So we skip it and start from second volume.\n      NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n      FindData FD;\n      if (FindFile::FastFind(NextName,&FD))\n        VolumeSetSize+=FD.Size;\n      else\n        break;\n    }\n    DataIO.TotalArcSize+=VolumeSetSize;\n  }\n\n  ExtractArchiveInit(Arc);\n\n  if (*Cmd->Command=='T' || *Cmd->Command=='I')\n    Cmd->Test=true;\n\n\n  if (*Cmd->Command=='I')\n  {\n    Cmd->DisablePercentage=true;\n  }\n  else\n    uiStartArchiveExtract(!Cmd->Test,ArcName);\n\n#ifndef SFX_MODULE\n  if (Analyze->StartPos!=0)\n  {\n    Arc.Seek(Analyze->StartPos,SEEK_SET);\n    Analyze->StartPos=0;\n  }\n#endif\n\n\n  while (1)\n  {\n    size_t Size=Arc.ReadHeader();\n\n\n    bool Repeat=false;\n    if (!ExtractCurrentFile(Arc,Size,Repeat))\n      if (Repeat)\n      {\n        // If we started extraction from not first volume and need to\n        // restart it from first, we must set DataIO.TotalArcSize to size\n        // of new first volume to display the total progress correctly.\n        FindData NewArc;\n        if (FindFile::FastFind(ArcName,&NewArc))\n          DataIO.TotalArcSize=NewArc.Size;\n        return EXTRACT_ARC_REPEAT;\n      }\n      else\n        break;\n  }\n\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Cmd->Test && Arc.Volume)\n    RecVolumesTest(Cmd,&Arc,ArcName);\n#endif\n\n  return EXTRACT_ARC_NEXT;\n}\n\n\nbool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)\n{\n  wchar Command=Cmd->Command[0];\n  if (HeaderSize==0)\n    if (DataIO.UnpVolume)\n    {\n#ifdef NOVOLUME\n      return false;\n#else\n      // Supposing we unpack an old RAR volume without the end of archive\n      // record and last file is not split between volumes.\n      if (!MergeArchive(Arc,&DataIO,false,Command))\n      {\n        ErrHandler.SetErrorCode(RARX_WARNING);\n        return false;\n      }\n#endif\n    }\n    else\n      return false;\n\n  HEADER_TYPE HeaderType=Arc.GetHeaderType();\n  if (HeaderType==HEAD_FILE)\n  {\n    // Unlike Arc.FileName, ArcName might store an old volume name here.\n    if (Analyze->EndPos!=0 && Analyze->EndPos==Arc.CurBlockPos &&\n        (*Analyze->EndName==0 || wcscmp(Analyze->EndName,Arc.FileName)==0))\n      return false;\n  }\n  else\n  {\n#ifndef SFX_MODULE\n    if (Arc.Format==RARFMT15 && HeaderType==HEAD3_OLDSERVICE && PrevProcessed)\n      SetExtraInfo20(Cmd,Arc,DestFileName);\n#endif\n    if (HeaderType==HEAD_SERVICE && PrevProcessed)\n      SetExtraInfo(Cmd,Arc,DestFileName);\n    if (HeaderType==HEAD_ENDARC)\n      if (Arc.EndArcHead.NextVolume)\n      {\n#ifdef NOVOLUME\n        return false;\n#else\n        if (!MergeArchive(Arc,&DataIO,false,Command))\n        {\n          ErrHandler.SetErrorCode(RARX_WARNING);\n          return false;\n        }\n        Arc.Seek(Arc.CurBlockPos,SEEK_SET);\n        return true;\n#endif\n      }\n      else\n        return false;\n    Arc.SeekToNext();\n    return true;\n  }\n  PrevProcessed=false;\n\n  // We can get negative sizes in corrupt archive and it is unacceptable\n  // for size comparisons in ComprDataIO::UnpRead, where we cast sizes\n  // to size_t and can exceed another read or available size. We could fix it\n  // when reading an archive. But we prefer to do it here, because this\n  // function is called directly in unrar.dll, so we fix bad parameters\n  // passed to dll. Also we want to see real negative sizes in the listing\n  // of corrupt archive. To prevent uninitialized data access perform\n  // these checks after rejecting zero length and non-file headers above.\n  if (Arc.FileHead.PackSize<0)\n    Arc.FileHead.PackSize=0;\n  if (Arc.FileHead.UnpSize<0)\n    Arc.FileHead.UnpSize=0;\n\n  // 2022.03.20: We might remove this check in the future.\n  // It duplicates Analyze->EndPos and Analyze->EndName in all cases except\n  // volumes on removable media.\n  if (!Cmd->Recurse && MatchedArgs>=Cmd->FileArgs.ItemsCount() && AllMatchesExact)\n    return false;\n\n  int MatchType=MATCH_WILDSUBPATH;\n\n  bool EqualNames=false;\n  wchar MatchedArg[NM];\n  int MatchNumber=Cmd->IsProcessFile(Arc.FileHead,&EqualNames,MatchType,0,MatchedArg,ASIZE(MatchedArg));\n  bool MatchFound=MatchNumber!=0;\n#ifndef SFX_MODULE\n  if (Cmd->ExclPath==EXCL_BASEPATH)\n  {\n    wcsncpyz(Cmd->ArcPath,MatchedArg,ASIZE(Cmd->ArcPath));\n    *PointToName(Cmd->ArcPath)=0;\n    if (IsWildcard(Cmd->ArcPath)) // Cannot correctly process path*\\* masks here.\n      *Cmd->ArcPath=0;\n  }\n#endif\n  if (MatchFound && !EqualNames)\n    AllMatchesExact=false;\n\n  Arc.ConvertAttributes();\n\n#if !defined(SFX_MODULE) && !defined(RARDLL)\n  if (Arc.FileHead.SplitBefore && FirstFile && !UseExactVolName)\n  {\n    wchar CurVolName[NM];\n    wcsncpyz(CurVolName,ArcName,ASIZE(CurVolName));\n    GetFirstVolIfFullSet(ArcName,Arc.NewNumbering,ArcName,ASIZE(ArcName));\n\n    if (wcsicomp(ArcName,CurVolName)!=0 && FileExist(ArcName))\n    {\n      wcsncpyz(Cmd->ArcName,ArcName,ASIZE(ArcName)); // For GUI \"Delete archive after extraction\".\n      // If first volume name does not match the current name and if such\n      // volume name really exists, let's unpack from this first volume.\n      Repeat=true;\n      return false;\n    }\n#ifndef RARDLL\n    if (!ReconstructDone)\n    {\n      ReconstructDone=true;\n      if (RecVolumesRestore(Cmd,Arc.FileName,true))\n      {\n        Repeat=true;\n        return false;\n      }\n    }\n#endif\n    wcsncpyz(ArcName,CurVolName,ASIZE(ArcName));\n  }\n#endif\n\n  wchar ArcFileName[NM];\n  ConvertPath(Arc.FileHead.FileName,ArcFileName,ASIZE(ArcFileName));\n\n  if (Arc.FileHead.Version)\n  {\n    if (Cmd->VersionControl!=1 && !EqualNames)\n    {\n      if (Cmd->VersionControl==0)\n        MatchFound=false;\n      int Version=ParseVersionFileName(ArcFileName,false);\n      if (Cmd->VersionControl-1==Version)\n        ParseVersionFileName(ArcFileName,true);\n      else\n        MatchFound=false;\n    }\n  }\n  else\n    if (!Arc.IsArcDir() && Cmd->VersionControl>1)\n      MatchFound=false;\n\n  DataIO.UnpVolume=Arc.FileHead.SplitAfter;\n  DataIO.NextVolumeMissing=false;\n\n  Arc.Seek(Arc.NextBlockPos-Arc.FileHead.PackSize,SEEK_SET);\n\n  bool ExtrFile=false;\n  bool SkipSolid=false;\n\n#ifndef SFX_MODULE\n  if (FirstFile && (MatchFound || Arc.Solid) && Arc.FileHead.SplitBefore)\n  {\n    if (MatchFound)\n    {\n      uiMsg(UIERROR_NEEDPREVVOL,Arc.FileName,ArcFileName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_BAD_DATA;\n#endif\n      ErrHandler.SetErrorCode(RARX_OPEN);\n    }\n    MatchFound=false;\n  }\n\n  FirstFile=false;\n#endif\n\n  bool RefTarget=false;\n  if (!MatchFound)\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(ArcFileName,RefList[I].RefName)==0)\n      {\n        ExtractRef *MatchedRef=&RefList[I];\n      \n        if (!Cmd->Test) // While harmless, it is useless for 't'.\n        {\n          wcsncpyz(DestFileName,*Cmd->TempPath!=0 ? Cmd->TempPath:Cmd->ExtrPath,ASIZE(DestFileName));\n          AddEndSlash(DestFileName,ASIZE(DestFileName));\n          wcsncatz(DestFileName,L\"__tmp_reference_source_\",ASIZE(DestFileName));\n          MkTemp(DestFileName,ASIZE(DestFileName));\n          MatchedRef->TmpName=wcsdup(DestFileName);\n        }\n        RefTarget=true; // Need it even for 't' to test the reference source.\n        break;\n      }\n  \n  if (Arc.FileHead.Encrypted && Cmd->SkipEncrypted)\n    if (Arc.Solid)\n      return false; // Abort the entire extraction for solid archive.\n    else\n      MatchFound=false; // Skip only the current file for non-solid archive.\n  \n  if (MatchFound || RefTarget || (SkipSolid=Arc.Solid)!=0)\n  {\n    // First common call of uiStartFileExtract. It is done before overwrite\n    // prompts, so if SkipSolid state is changed below, we'll need to make\n    // additional uiStartFileExtract calls with updated parameters.\n    if (!uiStartFileExtract(ArcFileName,!Cmd->Test,Cmd->Test && Command!='I',SkipSolid))\n      return false;\n\n    if (!RefTarget)\n      ExtrPrepareName(Arc,ArcFileName,DestFileName,ASIZE(DestFileName));\n\n    // DestFileName can be set empty in case of excessive -ap switch.\n    ExtrFile=!SkipSolid && *DestFileName!=0 && !Arc.FileHead.SplitBefore;\n\n    if ((Cmd->FreshFiles || Cmd->UpdateFiles) && (Command=='E' || Command=='X'))\n    {\n      FindData FD;\n      if (FindFile::FastFind(DestFileName,&FD))\n      {\n        if (FD.mtime >= Arc.FileHead.mtime)\n        {\n          // If directory already exists and its modification time is newer \n          // than start of extraction, it is likely it was created \n          // when creating a path to one of already extracted items. \n          // In such case we'll better update its time even if archived \n          // directory is older.\n\n          if (!FD.IsDir || FD.mtime<StartTime)\n            ExtrFile=false;\n        }\n      }\n      else\n        if (Cmd->FreshFiles)\n          ExtrFile=false;\n    }\n\n    if (!CheckUnpVer(Arc,ArcFileName))\n    {\n      ErrHandler.SetErrorCode(RARX_FATAL);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_UNKNOWN_FORMAT;\n#endif\n      Arc.SeekToNext();\n      return !Arc.Solid; // Can try extracting next file only in non-solid archive.\n    }\n\n    if (Arc.FileHead.Encrypted)\n    {\n      RarCheckPassword CheckPwd;\n      if (Arc.Format==RARFMT50 && Arc.FileHead.UsePswCheck && !Arc.BrokenHeader)\n        CheckPwd.Set(Arc.FileHead.Salt,Arc.FileHead.InitV,Arc.FileHead.Lg2Count,Arc.FileHead.PswCheck);\n\n      while (true) // Repeat the password prompt for wrong and empty passwords.\n      {\n        // Stop archive extracting if user cancelled a password prompt.\n#ifdef RARDLL\n        if (!ExtrDllGetPassword())\n        {\n          Cmd->DllError=ERAR_MISSING_PASSWORD;\n          return false;\n        }\n#else\n        if (!ExtrGetPassword(Arc,ArcFileName,CheckPwd.IsSet() ? &CheckPwd:NULL))\n        {\n          PasswordCancelled=true;\n          return false;\n        }\n#endif\n\n        // Set a password before creating the file, so we can skip creating\n        // in case of wrong password.\n        SecPassword FilePassword=Cmd->Password;\n  #if defined(_WIN_ALL) && !defined(SFX_MODULE)\n        ConvertDosPassword(Arc,FilePassword);\n  #endif\n\n        byte PswCheck[SIZE_PSWCHECK];\n        DataIO.SetEncryption(false,Arc.FileHead.CryptMethod,&FilePassword,\n               Arc.FileHead.SaltSet ? Arc.FileHead.Salt:NULL,\n               Arc.FileHead.InitV,Arc.FileHead.Lg2Count,\n               Arc.FileHead.HashKey,PswCheck);\n\n        // If header is damaged, we cannot rely on password check value,\n        // because it can be damaged too.\n        if (Arc.FileHead.UsePswCheck && !Arc.BrokenHeader &&\n            memcmp(Arc.FileHead.PswCheck,PswCheck,SIZE_PSWCHECK)!=0)\n        {\n          if (GlobalPassword) // For -p<pwd> or Ctrl+P to avoid the infinite loop.\n          {\n            // This message is used by Android GUI to reset cached passwords.\n            // Update appropriate code if changed.\n            uiMsg(UIERROR_BADPSW,Arc.FileName,ArcFileName);\n          }\n          else // For passwords entered manually.\n          {\n            // This message is used by Android GUI and Windows GUI and SFX to\n            // reset cached passwords. Update appropriate code if changed.\n            uiMsg(UIWAIT_BADPSW,Arc.FileName,ArcFileName);\n            Cmd->Password.Clean();\n\n            // Avoid new requests for unrar.dll to prevent the infinite loop\n            // if app always returns the same password.\n  #ifndef RARDLL\n            continue; // Request a password again.\n  #endif\n          }\n  #ifdef RARDLL\n          // If we already have ERAR_EOPEN as result of missing volume,\n          // we should not replace it with less precise ERAR_BAD_PASSWORD.\n          if (Cmd->DllError!=ERAR_EOPEN)\n            Cmd->DllError=ERAR_BAD_PASSWORD;\n  #endif\n          ErrHandler.SetErrorCode(RARX_BADPWD);\n          ExtrFile=false;\n        }\n        break;\n      }\n    }\n\n#ifdef RARDLL\n    if (*Cmd->DllDestName!=0)\n      wcsncpyz(DestFileName,Cmd->DllDestName,ASIZE(DestFileName));\n#endif\n\n    if (ExtrFile && Command!='P' && !Cmd->Test && !Cmd->AbsoluteLinks &&\n        UpLinkExtracted)\n      ExtrFile=LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n\n    File CurFile;\n\n    bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;\n    if (LinkEntry && (Arc.FileHead.RedirType!=FSREDIR_FILECOPY))\n    {\n      if (ExtrFile && Command!='P' && !Cmd->Test)\n      {\n        // Overwrite prompt for symbolic and hard links and when we move\n        // a temporary file to the file reference instead of copying it.\n        bool UserReject=false;\n        if (FileExist(DestFileName) && !UserReject)\n          FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n        if (UserReject)\n          ExtrFile=false;\n      }\n    }\n    else\n      if (Arc.IsArcDir())\n      {\n        if (!ExtrFile || Command=='P' || Command=='I' || Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n          return true;\n        TotalFileCount++;\n        ExtrCreateDir(Arc,ArcFileName);\n        // It is important to not increment MatchedArgs here, so we extract\n        // dir with its entire contents and not dir record only even if\n        // dir record precedes files.\n        return true;\n      }\n      else\n        if (ExtrFile) // Create files and file copies (FSREDIR_FILECOPY).\n          ExtrFile=ExtrCreateFile(Arc,CurFile);\n\n    if (!ExtrFile && Arc.Solid)\n    {\n      SkipSolid=true;\n      ExtrFile=true;\n\n      // We changed SkipSolid, so we need to call uiStartFileExtract\n      // with \"Skip\" parameter to change the operation status \n      // from \"extracting\" to \"skipping\". For example, it can be necessary\n      // if user answered \"No\" to overwrite prompt when unpacking\n      // a solid archive.\n      if (!uiStartFileExtract(ArcFileName,false,false,true))\n        return false;\n    }\n    if (ExtrFile)\n    {\n      // Set it in test mode, so we also test subheaders such as NTFS streams\n      // after tested file.\n      if (Cmd->Test)\n        PrevProcessed=true;\n\n      bool TestMode=Cmd->Test || SkipSolid; // Unpack to memory, not to disk.\n\n      if (!SkipSolid)\n      {\n        if (!TestMode && Command!='P' && CurFile.IsDevice())\n        {\n          uiMsg(UIERROR_INVALIDNAME,Arc.FileName,DestFileName);\n          ErrHandler.WriteError(Arc.FileName,DestFileName);\n        }\n        TotalFileCount++;\n      }\n      FileCount++;\n      if (Command!='I' && !Cmd->DisableNames)\n        if (SkipSolid)\n          mprintf(St(MExtrSkipFile),ArcFileName);\n        else\n          switch(Cmd->Test ? 'T':Command) // \"Test\" can be also enabled by -t switch.\n          {\n            case 'T':\n              mprintf(St(MExtrTestFile),ArcFileName);\n              break;\n#ifndef SFX_MODULE\n            case 'P':\n              mprintf(St(MExtrPrinting),ArcFileName);\n              break;\n#endif\n            case 'X':\n            case 'E':\n              mprintf(St(MExtrFile),DestFileName);\n              break;\n          }\n      if (!Cmd->DisablePercentage && !Cmd->DisableNames)\n        mprintf(L\"     \");\n      if (Cmd->DisableNames)\n        uiEolAfterMsg(); // Avoid erasing preceding messages by percentage indicator in -idn mode.\n\n      DataIO.CurUnpRead=0;\n      DataIO.CurUnpWrite=0;\n      DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.PackedDataHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);\n      DataIO.SetPackedSizeToRead(Arc.FileHead.PackSize);\n      DataIO.SetFiles(&Arc,&CurFile);\n      DataIO.SetTestMode(TestMode);\n      DataIO.SetSkipUnpCRC(SkipSolid);\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n      if (!TestMode && !Arc.BrokenHeader &&\n          Arc.FileHead.UnpSize>0xffffffff && (Fat32 || !NotFat32))\n      {\n        if (!Fat32) // Not detected yet.\n          NotFat32=!(Fat32=IsFAT(Cmd->ExtrPath));\n        if (Fat32)\n          uiMsg(UIMSG_FAT32SIZE); // Inform user about FAT32 size limit.\n      }\n#endif\n\n      uint64 Preallocated=0;\n      if (!TestMode && !Arc.BrokenHeader && Arc.FileHead.UnpSize>1000000 &&\n          Arc.FileHead.PackSize*1024>Arc.FileHead.UnpSize && Arc.IsSeekable() &&\n          (Arc.FileHead.UnpSize<100000000 || Arc.FileLength()>Arc.FileHead.PackSize))\n      {\n        CurFile.Prealloc(Arc.FileHead.UnpSize);\n        Preallocated=Arc.FileHead.UnpSize;\n      }\n      CurFile.SetAllowDelete(!Cmd->KeepBroken);\n\n      bool FileCreateMode=!TestMode && !SkipSolid && Command!='P';\n      bool ShowChecksum=true; // Display checksum verification result.\n\n      bool LinkSuccess=true; // Assume success for test mode.\n      if (LinkEntry)\n      {\n        FILE_SYSTEM_REDIRECT Type=Arc.FileHead.RedirType;\n\n        if (Type==FSREDIR_HARDLINK || Type==FSREDIR_FILECOPY)\n        {\n          wchar RedirName[NM];\n        \n          // 2022.11.15: Might be needed when unpacking WinRAR 5.0 links with\n          // Unix RAR. WinRAR 5.0 used \\ path separators here, when beginning\n          // from 5.10 even Windows version uses / internally and converts\n          // them to \\ when reading FHEXTRA_REDIR.\n          // We must perform this conversion before ConvertPath call,\n          // so paths mixing different slashes like \\dir1/dir2\\file are\n          // processed correctly.\n          SlashToNative(Arc.FileHead.RedirName,RedirName,ASIZE(RedirName));\n\n          ConvertPath(RedirName,RedirName,ASIZE(RedirName));\n\n          wchar NameExisting[NM];\n          ExtrPrepareName(Arc,RedirName,NameExisting,ASIZE(NameExisting));\n          if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.\n            if (Type==FSREDIR_HARDLINK)\n              LinkSuccess=ExtractHardlink(Cmd,DestFileName,NameExisting,ASIZE(NameExisting));\n            else\n              LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,RedirName,DestFileName,NameExisting,ASIZE(NameExisting),Arc.FileHead.UnpSize);\n        }\n        else\n          if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)\n          {\n            if (FileCreateMode)\n            {\n              bool UpLink;\n              LinkSuccess=ExtractSymlink(Cmd,DataIO,Arc,DestFileName,UpLink);\n              UpLinkExtracted|=LinkSuccess && UpLink;\n\n              // We do not actually need to reset the cache here if we cache\n              // only the single last checked path, because at this point\n              // it will always contain the link own path and link can't\n              // overwrite its parent folder. But if we ever decide to cache\n              // several already checked paths, we'll need to reset them here.\n              // Otherwise if no files were created in one of such paths,\n              // let's say because of file create error, it might be possible\n              // to overwrite the path with link and avoid checks. We keep this\n              // code here as a reminder in case of possible modifications.\n              LastCheckedSymlink.clear(); // Reset cache for safety reason.\n            }\n          }\n          else\n          {\n            uiMsg(UIERROR_UNKNOWNEXTRA,Arc.FileName,ArcFileName);\n            LinkSuccess=false;\n          }\n          \n          if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)\n          {\n            // RAR 5.x links have a valid data checksum even in case of\n            // failure, because they do not store any data.\n            // We do not want to display \"OK\" in this case.\n            // For 4.x symlinks we verify the checksum only when extracting,\n            // but not when testing an archive.\n            ShowChecksum=false;\n          }\n          PrevProcessed=FileCreateMode && LinkSuccess;\n      }\n      else\n        if (!Arc.FileHead.SplitBefore)\n          if (Arc.FileHead.Method==0)\n            UnstoreFile(DataIO,Arc.FileHead.UnpSize);\n          else\n          {\n            Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);\n            Unp->SetDestSize(Arc.FileHead.UnpSize);\n#ifndef SFX_MODULE\n            if (Arc.Format!=RARFMT50 && Arc.FileHead.UnpVer<=15)\n              Unp->DoUnpack(15,FileCount>1 && Arc.Solid);\n            else\n#endif\n              Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);\n          }\n\n      Arc.SeekToNext();\n\n      // We check for \"split after\" flag to detect partially extracted files\n      // from incomplete volume sets. For them file header contains packed\n      // data hash, which must not be compared against unpacked data hash\n      // to prevent accidental match. Moreover, for -m0 volumes packed data\n      // hash would match truncated unpacked data hash and lead to fake \"OK\"\n      // in incomplete volume set.\n      bool ValidCRC=!Arc.FileHead.SplitAfter && DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL);\n\n      // We set AnySolidDataUnpackedWell to true if we found at least one\n      // valid non-zero solid file in preceding solid stream. If it is true\n      // and if current encrypted file is broken, we do not need to hint\n      // about a wrong password and can report CRC error only.\n      if (!Arc.FileHead.Solid)\n        AnySolidDataUnpackedWell=false; // Reset the flag, because non-solid file is found.\n      else\n        if (Arc.FileHead.Method!=0 && Arc.FileHead.UnpSize>0 && ValidCRC)\n          AnySolidDataUnpackedWell=true;\n \n      bool BrokenFile=false;\n      \n      // Checksum is not calculated in skip solid mode for performance reason.\n      if (!SkipSolid && ShowChecksum)\n      {\n        if (ValidCRC)\n        {\n          if (Command!='P' && Command!='I' && !Cmd->DisableNames)\n            mprintf(L\"%s%s \",Cmd->DisablePercentage ? L\" \":L\"\\b\\b\\b\\b\\b \",\n              Arc.FileHead.FileHash.Type==HASH_NONE ? L\"  ?\":St(MOk));\n        }\n        else\n        {\n          if (Arc.FileHead.Encrypted && (!Arc.FileHead.UsePswCheck || \n              Arc.BrokenHeader) && !AnySolidDataUnpackedWell)\n            uiMsg(UIERROR_CHECKSUMENC,Arc.FileName,ArcFileName);\n          else\n            uiMsg(UIERROR_CHECKSUM,Arc.FileName,ArcFileName);\n          BrokenFile=true;\n          ErrHandler.SetErrorCode(RARX_CRC);\n#ifdef RARDLL\n          // If we already have ERAR_EOPEN as result of missing volume\n          // or ERAR_BAD_PASSWORD for RAR5 wrong password,\n          // we should not replace it with less precise ERAR_BAD_DATA.\n          if (Cmd->DllError!=ERAR_EOPEN && Cmd->DllError!=ERAR_BAD_PASSWORD)\n            Cmd->DllError=ERAR_BAD_DATA;\n#endif\n        }\n      }\n      else\n      {\n        // We check SkipSolid to remove percent for skipped solid files only.\n        // We must not apply these \\b to links with ShowChecksum==false\n        // and their possible error messages.\n        if (SkipSolid) \n          mprintf(L\"\\b\\b\\b\\b\\b     \");\n      }\n\n      // If we successfully unpacked a hard link, we wish to set its file\n      // attributes. Hard link shares file metadata with link target,\n      // so we do not need to set link time or owner. But when we overwrite\n      // an existing link, we can call PrepareToDelete(), which affects\n      // link target attributes as well. So we set link attributes to restore\n      // both target and link attributes if PrepareToDelete() changed them.\n      bool SetAttrOnly=LinkEntry && Arc.FileHead.RedirType==FSREDIR_HARDLINK && LinkSuccess;\n\n      if (!TestMode && (Command=='X' || Command=='E') &&\n          (!LinkEntry || SetAttrOnly || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && \n          (!BrokenFile || Cmd->KeepBroken))\n      {\n        // Below we use DestFileName instead of CurFile.FileName,\n        // so we can set file attributes also for hard links, which do not\n        // have the open CurFile. These strings are the same for other items.\n\n        if (!SetAttrOnly)\n        {\n          // We could preallocate more space that really written to broken file\n          // or file with crafted header.\n          if (Preallocated>0 && (BrokenFile || DataIO.CurUnpWrite!=Preallocated))\n            CurFile.Truncate();\n\n\n          CurFile.SetOpenFileTime(\n            Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n            Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n            Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n          CurFile.Close();\n\n          SetFileHeaderExtra(Cmd,Arc,DestFileName);\n\n          CurFile.SetCloseFileTime(\n            Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n            Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n        }\n        \n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n        if (Cmd->SetCompressedAttr &&\n            (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0)\n          SetFileCompression(DestFileName,true);\n        if (Cmd->ClearArc)\n          Arc.FileHead.FileAttr&=~FILE_ATTRIBUTE_ARCHIVE;\n#endif\n        if (!Cmd->IgnoreGeneralAttr && !SetFileAttr(DestFileName,Arc.FileHead.FileAttr))\n        {\n          uiMsg(UIERROR_FILEATTR,Arc.FileName,DestFileName);\n          // Android cannot set file attributes and while UIERROR_FILEATTR\n          // above is handled by Android RAR silently, this call would cause\n          // \"Operation not permitted\" message for every unpacked file.\n          ErrHandler.SysErrMsg();\n        }\n\n        PrevProcessed=true;\n      }\n    }\n  }\n  // It is important to increment it for files, but not dirs. So we extract\n  // dir with its entire contents, not just dir record only even if dir\n  // record precedes files.\n  if (MatchFound)\n    MatchedArgs++;\n  if (DataIO.NextVolumeMissing)\n    return false;\n  if (!ExtrFile)\n    if (!Arc.Solid)\n      Arc.SeekToNext();\n    else\n      if (!SkipSolid)\n        return false;\n  return true;\n}\n\n\nvoid CmdExtract::UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize)\n{\n  Array<byte> Buffer(File::CopyBufferSize());\n  while (true)\n  {\n    int ReadSize=DataIO.UnpRead(&Buffer[0],Buffer.Size());\n    if (ReadSize<=0)\n      break;\n    int WriteSize=ReadSize<DestUnpSize ? ReadSize:(int)DestUnpSize;\n    if (WriteSize>0)\n    {\n      DataIO.UnpWrite(&Buffer[0],WriteSize);\n      DestUnpSize-=WriteSize;\n    }\n  }\n}\n\n\nbool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    // If we couldn't find the existing file, check if match is present\n    // in temporary reference sources list.\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        // If only one reference left targeting to this temporary file,\n        // it is faster to move the file instead of copying and deleting it.\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) // Only one reference left for this temporary file.\n        {\n          New.Delete(); // Delete the previously opened destination file.\n          // Try moving the file first.\n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            // If move failed, re-create the destination and try coping.\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; // Try copying below.\n          }\n          else\n          {\n            // If moved successfully, reopen the destination file and seek to\n            // end for SetOpenFileTime() and possible Truncate() calls later.\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            // We already moved the file, so clean the name to not try\n            // deleting non-existent temporary file later.\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    // Update only the current file progress in WinRAR, set the total to 0\n    // to keep it as is. It looks better for WinRAR.\n    uiExtractProgress(CopySize,UnpSize,0,0);\n\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n\n  return true;\n}\n\n\nvoid CmdExtract::ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *DestName,size_t DestSize)\n{\n  if (Cmd->Test)\n  {\n    // Destination name conversion isn't needed for simple archive test.\n    // This check also allows to avoid issuing \"Attempting to correct...\n    // Renaming...\" messages in MakeNameCompatible() below for problematic\n    // names like aux.txt when testing an archive.\n    wcsncpyz(DestName,ArcFileName,DestSize);\n    return;\n  }\n  \n  wcsncpyz(DestName,Cmd->ExtrPath,DestSize);\n\n  if (*Cmd->ExtrPath!=0)\n  {\n     wchar LastChar=*PointToLastChar(Cmd->ExtrPath);\n    // We need IsPathDiv check here to correctly handle Unix forward slash\n    // in the end of destination path in Windows: rar x arc dest/\n    // so we call IsPathDiv first instead of just calling AddEndSlash,\n    // which checks for only one type of path separator.\n    // IsDriveDiv is needed for current drive dir: rar x arc d:\n    if (!IsPathDiv(LastChar) && !IsDriveDiv(LastChar))\n    {\n      // Destination path can be without trailing slash if it come from GUI shell.\n      AddEndSlash(DestName,DestSize);\n    }\n  }\n\n#ifndef SFX_MODULE\n  if (Cmd->AppendArcNameToPath!=APPENDARCNAME_NONE)\n  {\n    switch(Cmd->AppendArcNameToPath)\n    {\n      case APPENDARCNAME_DESTPATH: // To subdir of destination path.\n        wcsncatz(DestName,PointToName(Arc.FirstVolumeName),DestSize);\n        SetExt(DestName,NULL,DestSize);\n        break;\n      case APPENDARCNAME_OWNSUBDIR: // To subdir of archive own dir.\n        wcsncpyz(DestName,Arc.FirstVolumeName,DestSize);\n        SetExt(DestName,NULL,DestSize);\n        break;\n      case APPENDARCNAME_OWNDIR:  // To archive own dir.\n        wcsncpyz(DestName,Arc.FirstVolumeName,DestSize);\n        RemoveNameFromPath(DestName);\n        break;\n    }\n    AddEndSlash(DestName,DestSize);\n  }\n#endif\n\n#ifndef SFX_MODULE\n  wchar *ArcPath=*Cmd->ExclArcPath!=0 ? Cmd->ExclArcPath:Cmd->ArcPath;\n  size_t ArcPathLength=wcslen(ArcPath);\n  if (ArcPathLength>0)\n  {\n    size_t NameLength=wcslen(ArcFileName);\n    if (NameLength>=ArcPathLength &&  wcsnicompc(ArcPath,ArcFileName,ArcPathLength)==0 &&\n        (IsPathDiv(ArcPath[ArcPathLength-1]) || \n         IsPathDiv(ArcFileName[ArcPathLength]) || ArcFileName[ArcPathLength]==0))\n    {\n      ArcFileName+=Min(ArcPathLength,NameLength);\n      while (IsPathDiv(*ArcFileName))\n        ArcFileName++;\n      if (*ArcFileName==0) // Excessive -ap switch.\n      {\n        *DestName=0;\n        return;\n      }\n    }\n  }\n#endif\n\n  wchar Command=Cmd->Command[0];\n  // Use -ep3 only in systems, where disk letters are exist, not in Unix.\n  bool AbsPaths=Cmd->ExclPath==EXCL_ABSPATH && Command=='X' && IsDriveDiv(':');\n\n  // We do not use any user specified destination paths when extracting\n  // absolute paths in -ep3 mode.\n  if (AbsPaths)\n    *DestName=0;\n\n  if (Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)\n    wcsncatz(DestName,PointToName(ArcFileName),DestSize);\n  else\n    wcsncatz(DestName,ArcFileName,DestSize);\n\n#ifdef _WIN_ALL\n  // Must do after Cmd->ArcPath processing above, so file name and arc path\n  // trailing spaces are in sync.\n  if (!Cmd->AllowIncompatNames)\n    MakeNameCompatible(DestName,DestSize);\n#endif\n\n  wchar DiskLetter=toupperw(DestName[0]);\n\n  if (AbsPaths)\n  {\n    if (DestName[1]=='_' && IsPathDiv(DestName[2]) &&\n        DiskLetter>='A' && DiskLetter<='Z')\n      DestName[1]=':';\n    else\n      if (DestName[0]=='_' && DestName[1]=='_')\n      {\n        // Convert __server\\share to \\\\server\\share.\n        DestName[0]=CPATHDIVIDER;\n        DestName[1]=CPATHDIVIDER;\n      }\n  }\n}\n\n\n#ifdef RARDLL\nbool CmdExtract::ExtrDllGetPassword()\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (Cmd->Callback!=NULL)\n    {\n      wchar PasswordW[MAXPASSWORD];\n      *PasswordW=0;\n      if (Cmd->Callback(UCM_NEEDPASSWORDW,Cmd->UserData,(LPARAM)PasswordW,ASIZE(PasswordW))==-1)\n        *PasswordW=0;\n      if (*PasswordW==0)\n      {\n        char PasswordA[MAXPASSWORD];\n        *PasswordA=0;\n        if (Cmd->Callback(UCM_NEEDPASSWORD,Cmd->UserData,(LPARAM)PasswordA,ASIZE(PasswordA))==-1)\n          *PasswordA=0;\n        GetWideName(PasswordA,NULL,PasswordW,ASIZE(PasswordW));\n        cleandata(PasswordA,sizeof(PasswordA));\n      }\n      Cmd->Password.Set(PasswordW);\n      cleandata(PasswordW,sizeof(PasswordW));\n      Cmd->ManualPassword=true;\n    }\n    if (!Cmd->Password.IsSet())\n      return false;\n  }\n  return true;\n}\n#endif\n\n\n#ifndef RARDLL\nbool CmdExtract::ExtrGetPassword(Archive &Arc,const wchar *ArcFileName,RarCheckPassword *CheckPwd)\n{\n  if (!Cmd->Password.IsSet())\n  {\n    if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password,CheckPwd)/* || !Cmd->Password.IsSet()*/)\n    {\n      // Suppress \"test is ok\" message if user cancelled the password prompt.\n      uiMsg(UIERROR_INCERRCOUNT);\n      return false;\n    }\n    Cmd->ManualPassword=true;\n  }\n#if !defined(SILENT)\n  else\n    if (!GlobalPassword && !Arc.FileHead.Solid)\n    {\n      eprintf(St(MUseCurPsw),ArcFileName);\n      switch(Cmd->AllYes ? 1 : Ask(St(MYesNoAll)))\n      {\n        case -1:\n          ErrHandler.Exit(RARX_USERBREAK);\n        case 2:\n          if (!uiGetPassword(UIPASSWORD_FILE,ArcFileName,&Cmd->Password,CheckPwd))\n            return false;\n          break;\n        case 3:\n          GlobalPassword=true;\n          break;\n      }\n    }\n#endif\n  return true;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid CmdExtract::ConvertDosPassword(Archive &Arc,SecPassword &DestPwd)\n{\n  if (Arc.Format==RARFMT15 && Arc.FileHead.HostOS==HOST_MSDOS)\n  {\n    // We need the password in OEM encoding if file was encrypted by\n    // native RAR/DOS (not extender based). Let's make the conversion.\n    wchar PlainPsw[MAXPASSWORD];\n    Cmd->Password.Get(PlainPsw,ASIZE(PlainPsw));\n    char PswA[MAXPASSWORD];\n    CharToOemBuffW(PlainPsw,PswA,ASIZE(PswA));\n    PswA[ASIZE(PswA)-1]=0;\n    CharToWide(PswA,PlainPsw,ASIZE(PlainPsw));\n    DestPwd.Set(PlainPsw);\n    cleandata(PlainPsw,sizeof(PlainPsw));\n    cleandata(PswA,sizeof(PswA));\n  }\n}\n#endif\n\n\nvoid CmdExtract::ExtrCreateDir(Archive &Arc,const wchar *ArcFileName)\n{\n  if (Cmd->Test)\n  {\n    if (!Cmd->DisableNames)\n    {\n      mprintf(St(MExtrTestFile),ArcFileName);\n      mprintf(L\" %s\",St(MOk));\n    }\n    return;\n  }\n\n  MKDIR_CODE MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n  bool DirExist=false;\n  if (MDCode!=MKDIR_SUCCESS)\n  {\n    DirExist=FileExist(DestFileName);\n    if (DirExist && !IsDir(GetFileAttr(DestFileName)))\n    {\n      // File with name same as this directory exists. Propose user\n      // to overwrite it.\n      bool UserReject;\n      FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);\n      DirExist=false;\n    }\n    if (!DirExist)\n    {\n      CreatePath(DestFileName,true,Cmd->DisableNames);\n      MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n      if (MDCode!=MKDIR_SUCCESS && !IsNameUsable(DestFileName))\n      {\n        uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n        wchar OrigName[ASIZE(DestFileName)];\n        wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n        MakeNameUsable(DestFileName,true);\n#ifndef SFX_MODULE\n        uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n        DirExist=FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName));\n        if (!DirExist)\n        {\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          MDCode=MakeDir(DestFileName,!Cmd->IgnoreGeneralAttr,Arc.FileHead.FileAttr);\n        }\n      }\n    }\n  }\n  if (MDCode==MKDIR_SUCCESS)\n  {\n    if (!Cmd->DisableNames)\n    {\n      mprintf(St(MCreatDir),DestFileName);\n      mprintf(L\" %s\",St(MOk));\n    }\n    PrevProcessed=true;\n  }\n  else\n    if (DirExist)\n    {\n      if (!Cmd->IgnoreGeneralAttr)\n        SetFileAttr(DestFileName,Arc.FileHead.FileAttr);\n      PrevProcessed=true;\n    }\n    else\n    {\n      uiMsg(UIERROR_DIRCREATE,Arc.FileName,DestFileName);\n      ErrHandler.SysErrMsg();\n#ifdef RARDLL\n      Cmd->DllError=ERAR_ECREATE;\n#endif\n      ErrHandler.SetErrorCode(RARX_CREATE);\n    }\n  if (PrevProcessed)\n  {\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    if (Cmd->SetCompressedAttr &&\n        (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0 && WinNT()!=WNT_NONE)\n      SetFileCompression(DestFileName,true);\n#endif\n    SetFileHeaderExtra(Cmd,Arc,DestFileName);\n    SetDirTime(DestFileName,\n      Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,\n      Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,\n      Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);\n  }\n}\n\n\nbool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    // Specify \"write only\" mode to avoid OpenIndiana NAS problems\n    // with SetFileTime and read+write files.\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n\n          MakeNameUsable(DestFileName,true);\n\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}\n\n\nbool CmdExtract::CheckUnpVer(Archive &Arc,const wchar *ArcFileName)\n{\n  bool WrongVer;\n  if (Arc.Format==RARFMT50) // Both SFX and RAR can unpack RAR 5.0 archives.\n    WrongVer=Arc.FileHead.UnpVer>VER_UNPACK5;\n  else\n  {\n#ifdef SFX_MODULE   // SFX can unpack only RAR 2.9 archives.\n    WrongVer=Arc.FileHead.UnpVer!=VER_UNPACK;\n#else               // All formats since 1.3 for RAR.\n    WrongVer=Arc.FileHead.UnpVer<13 || Arc.FileHead.UnpVer>VER_UNPACK;\n#endif\n  }\n\n  // We can unpack stored files regardless of compression version field.\n  if (Arc.FileHead.Method==0)\n    WrongVer=false;\n\n  if (WrongVer)\n  {\n    ErrHandler.UnknownMethodMsg(Arc.FileName,ArcFileName);\n    uiMsg(UIERROR_NEWERRAR,Arc.FileName);\n  }\n  return !WrongVer;\n}\n\n\n#ifndef SFX_MODULE\n// Find non-matched reference sources in solid and non-solid archives.\n// Detect the optimal start position for semi-solid archives\n// and optimal start volume for independent solid volumes.\n// \n// Alternatively we could collect references while extracting an archive\n// and perform the second extraction pass for references only.\n// But it would be slower for solid archives than scaning headers\n// in first pass and extracting everything in second, as implemented now.\n// \nvoid CmdExtract::AnalyzeArchive(const wchar *ArcName,bool Volume,bool NewNumbering)\n{\n  ReleaseAnalyzeData(); // If processing non-first archive in multiple archives set.\n\n  wchar *ArgName=Cmd->FileArgs.GetString();\n  Cmd->FileArgs.Rewind();\n  if (ArgName!=NULL && (wcscmp(ArgName,L\"*\")==0 || wcscmp(ArgName,L\"*.*\")==0))\n    return; // No need to check further for * and *.* masks.\n\n  // Start search from first volume if all volumes preceding current are available.\n  wchar NextName[NM];\n  if (Volume)\n    GetFirstVolIfFullSet(ArcName,NewNumbering,NextName,ASIZE(NextName));\n  else\n    wcsncpyz(NextName,ArcName,ASIZE(NextName));\n  \n  bool MatchFound=false;\n  bool FirstVolume=true;\n  bool PrevMatched=false;\n  bool OpenNext=false;\n\n  while (true)\n  {\n    Archive Arc(Cmd);\n    if (!Arc.Open(NextName) || !Arc.IsArchive(false))\n    {\n      if (OpenNext)\n      {\n        // If we couldn't open trailing volumes, we can't set early exit\n        // parameters. It is possible that some volume are on removable media\n        // and will be provided by user when extracting.\n        *Analyze->EndName=0;\n        Analyze->EndPos=0;\n      }\n      break;\n    }\n\n    OpenNext=false;\n    bool FirstFile=true;\n    while (Arc.ReadHeader()>0)\n    {\n      Wait();\n\n      HEADER_TYPE HeaderType=Arc.GetHeaderType();\n      if (HeaderType==HEAD_ENDARC)\n      {\n        OpenNext|=Arc.EndArcHead.NextVolume; // Allow open next volume.\n        break;\n      }\n      if (HeaderType==HEAD_FILE)\n      {\n        if (!Arc.FileHead.SplitBefore)\n        {\n          if (!MatchFound && !Arc.FileHead.Solid) // Can start extraction from here.\n          {\n            if (!FirstVolume)\n              wcsncpyz(Analyze->StartName,NextName,ASIZE(Analyze->StartName));\n            if (!FirstFile)\n              Analyze->StartPos=Arc.CurBlockPos;\n          }\n          FirstFile=false;\n\n          if (Cmd->IsProcessFile(Arc.FileHead,NULL,MATCH_WILDSUBPATH,0,NULL,0)!=0)\n          {\n            MatchFound = true;\n            PrevMatched = true;\n\n            // Matched file reference pointing at maybe non-matched source file.\n            // Even though we know RedirName, we can't check if source file\n            // is certainly non-matched, because it can be filtered out by\n            // date or attributes, which we do not know here.\n            if (Arc.FileHead.RedirType==FSREDIR_FILECOPY)\n            {\n              bool AlreadyAdded=false;\n              for (size_t I=0;I<RefList.Size();I++)\n                if (wcscmp(Arc.FileHead.RedirName,RefList[I].RefName)==0)\n                {\n                  // Increment the reference count if we added such reference\n                  // source earlier.\n                  RefList[I].RefCount++;\n                  AlreadyAdded=true;\n                  break;\n                }\n\n              // Limit the maximum size of reference sources list to some\n              // sensible value to prevent the excessive memory allocation.\n              size_t MaxListSize=1000000;\n\n              if (!AlreadyAdded && RefList.Size()<MaxListSize)\n              {\n                ExtractRef Ref={0};\n                Ref.RefName=wcsdup(Arc.FileHead.RedirName);\n                Ref.RefCount=1;\n                RefList.Push(Ref);\n              }\n            }\n          }\n          else\n          {\n            if (PrevMatched) // First non-matched item after matched.\n            {\n              if (!FirstVolume)\n                wcsncpyz(Analyze->EndName,NextName,ASIZE(Analyze->EndName));\n              if (!FirstFile)\n                Analyze->EndPos=Arc.CurBlockPos;\n            }\n            PrevMatched=false;\n          }\n        }\n        if (Arc.FileHead.SplitAfter)\n        {\n          OpenNext=true; // Allow open next volume.\n          break;\n        }\n      }\n      Arc.SeekToNext();\n    }\n    Arc.Close();\n\n    if (Volume && OpenNext)\n    {\n      NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);\n      FirstVolume=false;\n    }\n    else\n      break;\n  }\n\n  // If file references are present, we can't reliably skip in semi-solid\n  // archives, because reference source can be present in skipped data.\n  if (RefList.Size()!=0)\n    memset(Analyze,0,sizeof(*Analyze));\n}\n#endif\n\n\n#ifndef SFX_MODULE\n// Return the first volume name if all volumes preceding the specified\n// are available. Otherwise return the specified volume name.\nvoid CmdExtract::GetFirstVolIfFullSet(const wchar *SrcName,bool NewNumbering,wchar *DestName,size_t DestSize)\n{\n  wchar FirstVolName[NM];\n  VolNameToFirstName(SrcName,FirstVolName,ASIZE(FirstVolName),NewNumbering);\n  wchar NextName[NM];\n  wcsncpyz(NextName,FirstVolName,ASIZE(NextName));\n  wchar ResultName[NM];\n  wcsncpyz(ResultName,SrcName,ASIZE(ResultName));\n  while (true)\n  {\n    if (wcscmp(SrcName,NextName)==0)\n    {\n      wcsncpyz(ResultName,FirstVolName,DestSize);\n      break;\n    }\n    if (!FileExist(NextName))\n      break;\n    NextVolumeName(NextName,ASIZE(NextName),!NewNumbering);\n  }\n  wcsncpyz(DestName,ResultName,DestSize);\n}\n\n#endif", "#ifndef _RAR_EXTRACT_\n#define _RAR_EXTRACT_\n\nenum EXTRACT_ARC_CODE {EXTRACT_ARC_NEXT,EXTRACT_ARC_REPEAT};\n\nclass CmdExtract\n{\n  private:\n    struct ExtractRef\n    {\n      wchar *RefName;\n      wchar *TmpName;\n      uint64 RefCount;\n    };\n    Array<ExtractRef> RefList;\n\n    struct AnalyzeData\n    {\n      wchar StartName[NM];\n      uint64 StartPos;\n      wchar EndName[NM];\n      uint64 EndPos;\n    } *Analyze;\n\n    bool ArcAnalyzed;\n\n    void ReleaseAnalyzeData();\n    EXTRACT_ARC_CODE ExtractArchive();\n    bool ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize);\n    void ExtrPrepareName(Archive &Arc,const wchar *ArcFileName,wchar *DestName,size_t DestSize);\n#ifdef RARDLL\n    bool ExtrDllGetPassword();\n#else\n    bool ExtrGetPassword(Archive &Arc,const wchar *ArcFileName,RarCheckPassword *CheckPwd);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    void ConvertDosPassword(Archive &Arc,SecPassword &DestPwd);\n#endif\n    void ExtrCreateDir(Archive &Arc,const wchar *ArcFileName);\n    bool ExtrCreateFile(Archive &Arc,File &CurFile);\n    bool CheckUnpVer(Archive &Arc,const wchar *ArcFileName);\n#ifndef SFX_MODULE\n    void AnalyzeArchive(const wchar *ArcName,bool Volume,bool NewNumbering);\n    void GetFirstVolIfFullSet(const wchar *SrcName,bool NewNumbering,wchar *DestName,size_t DestSize);\n#endif\n\n    RarTime StartTime; // Time when extraction started.\n\n    CommandData *Cmd;\n\n    ComprDataIO DataIO;\n    Unpack *Unp;\n    unsigned long TotalFileCount;\n\n    unsigned long FileCount;\n    unsigned long MatchedArgs;\n    bool FirstFile;\n    bool AllMatchesExact;\n    bool ReconstructDone;\n    bool UseExactVolName;\n\n    // If any non-zero solid file was successfully unpacked before current.\n    // If true and if current encrypted file is broken, obviously\n    // the password is correct and we can report broken CRC without\n    // any wrong password hints.\n    bool AnySolidDataUnpackedWell;\n\n    wchar ArcName[NM];\n\n    bool GlobalPassword;\n    bool PrevProcessed; // If previous file was successfully extracted or tested.\n    wchar DestFileName[NM];\n    bool PasswordCancelled;\n    bool UpLinkExtracted; // At least one symlink with \"..\" in target was extracted.\n\n    // Last path checked for symlinks. We use it to improve the performance,\n    // so we do not check recently checked folders again.\n    std::wstring LastCheckedSymlink;\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)\n    bool Fat32,NotFat32;\n#endif\n  public:\n    CmdExtract(CommandData *Cmd);\n    ~CmdExtract();\n    void DoExtract();\n    void ExtractArchiveInit(Archive &Arc);\n    bool ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat);\n    static void UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize);\n};\n\n#endif\n", "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}\n\n", "/****************************************************************************\n *  This file is part of PPMd project                                       *\n *  Written and distributed to public domain by Dmitry Shkarin 1997,        *\n *  1999-2000                                                               *\n *  Contents: model description and encoding/decoding routines              *\n ****************************************************************************/\n\nstatic const int MAX_O=64; /* maximum allowed model order */\nconst uint TOP=1 << 24, BOT=1 << 15;\n\ntemplate <class T>\ninline void _PPMD_SWAP(T& t1,T& t2) { T tmp=t1; t1=t2; t2=tmp; }\n\n\ninline RARPPM_CONTEXT* RARPPM_CONTEXT::createChild(ModelPPM *Model,RARPPM_STATE* pStats,\n                                             RARPPM_STATE& FirstState)\n{\n  RARPPM_CONTEXT* pc = (RARPPM_CONTEXT*) Model->SubAlloc.AllocContext();\n  if ( pc ) \n  {\n    pc->NumStats=1;                     \n    pc->OneState=FirstState;\n    pc->Suffix=this;                    \n    pStats->Successor=pc;\n  }\n  return pc;\n}\n\n\nModelPPM::ModelPPM()\n{\n  MinContext=NULL;\n  MaxContext=NULL;\n  MedContext=NULL;\n}\n\n\nvoid ModelPPM::RestartModelRare()\n{\n  int i, k, m;\n  memset(CharMask,0,sizeof(CharMask));\n  SubAlloc.InitSubAllocator();\n  InitRL=-(MaxOrder < 12 ? MaxOrder:12)-1;\n  MinContext = MaxContext = (RARPPM_CONTEXT*) SubAlloc.AllocContext();\n  if (MinContext == NULL)\n    throw std::bad_alloc();\n  MinContext->Suffix=NULL;\n  OrderFall=MaxOrder;\n  MinContext->U.SummFreq=(MinContext->NumStats=256)+1;\n  FoundState=MinContext->U.Stats=(RARPPM_STATE*)SubAlloc.AllocUnits(256/2);\n  if (FoundState == NULL)\n    throw std::bad_alloc();\n  for (RunLength=InitRL, PrevSuccess=i=0;i < 256;i++) \n  {\n    MinContext->U.Stats[i].Symbol=i;      \n    MinContext->U.Stats[i].Freq=1;\n    MinContext->U.Stats[i].Successor=NULL;\n  }\n  \n  static const ushort InitBinEsc[]={\n    0x3CDD,0x1F3F,0x59BF,0x48F3,0x64A1,0x5ABC,0x6632,0x6051\n  };\n\n  for (i=0;i < 128;i++)\n    for (k=0;k < 8;k++)\n      for (m=0;m < 64;m += 8)\n        BinSumm[i][k+m]=BIN_SCALE-InitBinEsc[k]/(i+2);\n  for (i=0;i < 25;i++)\n    for (k=0;k < 16;k++)            \n      SEE2Cont[i][k].init(5*i+10);\n}\n\n\nvoid ModelPPM::StartModelRare(int MaxOrder)\n{\n  int i, k, m ,Step;\n  EscCount=1;\n/*\n  if (MaxOrder < 2) \n  {\n    memset(CharMask,0,sizeof(CharMask));\n    OrderFall=ModelPPM::MaxOrder;\n    MinContext=MaxContext;\n    while (MinContext->Suffix != NULL)\n    {\n      MinContext=MinContext->Suffix;\n      OrderFall--;\n    }\n    FoundState=MinContext->U.Stats;\n    MinContext=MaxContext;\n  } \n  else \n*/\n  {\n    ModelPPM::MaxOrder=MaxOrder;\n    RestartModelRare();\n    NS2BSIndx[0]=2*0;\n    NS2BSIndx[1]=2*1;\n    memset(NS2BSIndx+2,2*2,9);\n    memset(NS2BSIndx+11,2*3,256-11);\n    for (i=0;i < 3;i++)\n      NS2Indx[i]=i;\n    for (m=i, k=Step=1;i < 256;i++) \n    {\n      NS2Indx[i]=m;\n      if ( !--k ) \n      { \n        k = ++Step;\n        m++; \n      }\n    }\n    memset(HB2Flag,0,0x40);\n    memset(HB2Flag+0x40,0x08,0x100-0x40);\n    DummySEE2Cont.Shift=PERIOD_BITS;\n  }\n}\n\n\nvoid RARPPM_CONTEXT::rescale(ModelPPM *Model)\n{\n  int OldNS=NumStats, i=NumStats-1, Adder, EscFreq;\n  RARPPM_STATE* p1, * p;\n  for (p=Model->FoundState;p != U.Stats;p--)\n    _PPMD_SWAP(p[0],p[-1]);\n  U.Stats->Freq += 4;\n  U.SummFreq += 4;\n  EscFreq=U.SummFreq-p->Freq;\n  Adder=(Model->OrderFall != 0);\n  U.SummFreq = (p->Freq=(p->Freq+Adder) >> 1);\n  do \n  {\n    EscFreq -= (++p)->Freq;\n    U.SummFreq += (p->Freq=(p->Freq+Adder) >> 1);\n    if (p[0].Freq > p[-1].Freq) \n    {\n      RARPPM_STATE tmp=*(p1=p);\n      do \n      { \n        p1[0]=p1[-1]; \n      } while (--p1 != U.Stats && tmp.Freq > p1[-1].Freq);\n      *p1=tmp;\n    }\n  } while ( --i );\n  if (p->Freq == 0) \n  {\n    do \n    { \n      i++; \n    } while ((--p)->Freq == 0);\n    EscFreq += i;\n    if ((NumStats -= i) == 1) \n    {\n      RARPPM_STATE tmp=*U.Stats;\n      do \n      { \n        tmp.Freq-=(tmp.Freq >> 1); \n        EscFreq>>=1; \n      } while (EscFreq > 1);\n      Model->SubAlloc.FreeUnits(U.Stats,(OldNS+1) >> 1);\n      *(Model->FoundState=&OneState)=tmp;  return;\n    }\n  }\n  U.SummFreq += (EscFreq -= (EscFreq >> 1));\n  int n0=(OldNS+1) >> 1, n1=(NumStats+1) >> 1;\n  if (n0 != n1)\n    U.Stats = (RARPPM_STATE*) Model->SubAlloc.ShrinkUnits(U.Stats,n0,n1);\n  Model->FoundState=U.Stats;\n}\n\n\ninline RARPPM_CONTEXT* ModelPPM::CreateSuccessors(bool Skip,RARPPM_STATE* p1)\n{\n  RARPPM_STATE UpState;\n  RARPPM_CONTEXT* pc=MinContext, * UpBranch=FoundState->Successor;\n  RARPPM_STATE * p, * ps[MAX_O], ** pps=ps;\n  if ( !Skip ) \n  {\n    *pps++ = FoundState;\n    if ( !pc->Suffix )\n      goto NO_LOOP;\n  }\n  if ( p1 ) \n  {\n    p=p1;\n    pc=pc->Suffix;\n    goto LOOP_ENTRY;\n  }\n  do \n  {\n    pc=pc->Suffix;\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != FoundState->Symbol)\n        do \n        {\n          p++; \n        } while (p->Symbol != FoundState->Symbol);\n    } \n    else\n      p=&(pc->OneState);\nLOOP_ENTRY:\n    if (p->Successor != UpBranch) \n    {\n      pc=p->Successor;\n      break;\n\n    }\n    // We ensure that PPM order input parameter does not exceed MAX_O (64),\n    // so we do not really need this check and added it for extra safety.\n    // See CVE-2017-17969 for details.\n    if (pps>=ps+ASIZE(ps))\n      return NULL;\n\n    *pps++ = p;\n  } while ( pc->Suffix );\nNO_LOOP:\n  if (pps == ps)\n    return pc;\n  UpState.Symbol=*(byte*) UpBranch;\n  UpState.Successor=(RARPPM_CONTEXT*) (((byte*) UpBranch)+1);\n  if (pc->NumStats != 1) \n  {\n    if ((byte*) pc <= SubAlloc.pText)\n      return(NULL);\n    if ((p=pc->U.Stats)->Symbol != UpState.Symbol)\n    do \n    { \n      p++; \n    } while (p->Symbol != UpState.Symbol);\n    uint cf=p->Freq-1;\n    uint s0=pc->U.SummFreq-pc->NumStats-cf;\n    UpState.Freq=1+((2*cf <= s0)?(5*cf > s0):((2*cf+3*s0-1)/(2*s0)));\n  } \n  else\n    UpState.Freq=pc->OneState.Freq;\n  do \n  {\n    pc = pc->createChild(this,*--pps,UpState);\n    if ( !pc )\n      return NULL;\n  } while (pps != ps);\n  return pc;\n}\n\n\ninline void ModelPPM::UpdateModel()\n{\n  RARPPM_STATE fs = *FoundState, *p = NULL;\n  RARPPM_CONTEXT *pc, *Successor;\n  uint ns1, ns, cf, sf, s0;\n  if (fs.Freq < MAX_FREQ/4 && (pc=MinContext->Suffix) != NULL) \n  {\n    if (pc->NumStats != 1) \n    {\n      if ((p=pc->U.Stats)->Symbol != fs.Symbol) \n      {\n        do \n        { \n          p++; \n        } while (p->Symbol != fs.Symbol);\n        if (p[0].Freq >= p[-1].Freq) \n        {\n          _PPMD_SWAP(p[0],p[-1]); \n          p--;\n        }\n      }\n      if (p->Freq < MAX_FREQ-9) \n      {\n        p->Freq += 2;               \n        pc->U.SummFreq += 2;\n      }\n    } \n    else \n    {\n      p=&(pc->OneState);\n      p->Freq += (p->Freq < 32);\n    }\n  }\n  if ( !OrderFall ) \n  {\n    MinContext=MaxContext=FoundState->Successor=CreateSuccessors(TRUE,p);\n    if ( !MinContext )\n      goto RESTART_MODEL;\n    return;\n  }\n  *SubAlloc.pText++ = fs.Symbol;                   \n  Successor = (RARPPM_CONTEXT*) SubAlloc.pText;\n  if (SubAlloc.pText >= SubAlloc.FakeUnitsStart)                \n    goto RESTART_MODEL;\n  if ( fs.Successor ) \n  {\n    if ((byte*) fs.Successor <= SubAlloc.pText &&\n        (fs.Successor=CreateSuccessors(FALSE,p)) == NULL)\n      goto RESTART_MODEL;\n    if ( !--OrderFall ) \n    {\n      Successor=fs.Successor;\n      SubAlloc.pText -= (MaxContext != MinContext);\n    }\n  } \n  else \n  {\n    FoundState->Successor=Successor;\n    fs.Successor=MinContext;\n  }\n  s0=MinContext->U.SummFreq-(ns=MinContext->NumStats)-(fs.Freq-1);\n  for (pc=MaxContext;pc != MinContext;pc=pc->Suffix) \n  {\n    if ((ns1=pc->NumStats) != 1) \n    {\n      if ((ns1 & 1) == 0) \n      {\n        pc->U.Stats=(RARPPM_STATE*) SubAlloc.ExpandUnits(pc->U.Stats,ns1 >> 1);\n        if ( !pc->U.Stats )           \n          goto RESTART_MODEL;\n      }\n      pc->U.SummFreq += (2*ns1 < ns)+2*((4*ns1 <= ns) & (pc->U.SummFreq <= 8*ns1));\n    } \n    else \n    {\n      p=(RARPPM_STATE*) SubAlloc.AllocUnits(1);\n      if ( !p )\n        goto RESTART_MODEL;\n      *p=pc->OneState;\n      pc->U.Stats=p;\n      if (p->Freq < MAX_FREQ/4-1)\n        p->Freq += p->Freq;\n      else\n        p->Freq  = MAX_FREQ-4;\n      pc->U.SummFreq=p->Freq+InitEsc+(ns > 3);\n    }\n    cf=2*fs.Freq*(pc->U.SummFreq+6);\n    sf=s0+pc->U.SummFreq;\n    if (cf < 6*sf) \n    {\n      cf=1+(cf > sf)+(cf >= 4*sf);\n      pc->U.SummFreq += 3;\n    }\n    else \n    {\n      cf=4+(cf >= 9*sf)+(cf >= 12*sf)+(cf >= 15*sf);\n      pc->U.SummFreq += cf;\n    }\n    p=pc->U.Stats+ns1;\n    p->Successor=Successor;\n    p->Symbol = fs.Symbol;\n    p->Freq = cf;\n    pc->NumStats=++ns1;\n  }\n  MaxContext=MinContext=fs.Successor;\n  return;\nRESTART_MODEL:\n  RestartModelRare();\n  EscCount=0;\n}\n\n\n// Tabulated escapes for exponential symbol distribution\nstatic const byte ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };\n#define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))\n\n\n\ninline void RARPPM_CONTEXT::decodeBinSymbol(ModelPPM *Model)\n{\n  RARPPM_STATE& rs=OneState;\n  Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n  ushort& bs=Model->BinSumm[rs.Freq-1][Model->PrevSuccess+\n           Model->NS2BSIndx[Suffix->NumStats-1]+\n           Model->HiBitsFlag+2*Model->HB2Flag[rs.Symbol]+\n           ((Model->RunLength >> 26) & 0x20)];\n  if (Model->Coder.GetCurrentShiftCount(TOT_BITS) < bs) \n  {\n    Model->FoundState=&rs;\n    rs.Freq += (rs.Freq < 128);\n    Model->Coder.SubRange.LowCount=0;\n    Model->Coder.SubRange.HighCount=bs;\n    bs = GET_SHORT16(bs+INTERVAL-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->PrevSuccess=1;\n    Model->RunLength++;\n  } \n  else \n  {\n    Model->Coder.SubRange.LowCount=bs;\n    bs = GET_SHORT16(bs-GET_MEAN(bs,PERIOD_BITS,2));\n    Model->Coder.SubRange.HighCount=BIN_SCALE;\n    Model->InitEsc=ExpEscape[bs >> 10];\n    Model->NumMasked=1;\n    Model->CharMask[rs.Symbol]=Model->EscCount;\n    Model->PrevSuccess=0;\n    Model->FoundState=NULL;\n  }\n}\n\n\ninline void RARPPM_CONTEXT::update1(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p[0].Freq > p[-1].Freq) \n  {\n    _PPMD_SWAP(p[0],p[-1]);                   \n    Model->FoundState=--p;\n    if (p->Freq > MAX_FREQ)             \n      rescale(Model);\n  }\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol1(ModelPPM *Model)\n{\n  Model->Coder.SubRange.scale=U.SummFreq;\n  RARPPM_STATE* p=U.Stats;\n  int i, HiCnt;\n  int count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  if (count < (HiCnt=p->Freq)) \n  {\n    Model->PrevSuccess=(2*(Model->Coder.SubRange.HighCount=HiCnt) > Model->Coder.SubRange.scale);\n    Model->RunLength += Model->PrevSuccess;\n    (Model->FoundState=p)->Freq=(HiCnt += 4);\n    U.SummFreq += 4;\n    if (HiCnt > MAX_FREQ)\n      rescale(Model);\n    Model->Coder.SubRange.LowCount=0;\n    return(true);\n  }\n  else\n    if (Model->FoundState==NULL)\n      return(false);\n  Model->PrevSuccess=0;\n  i=NumStats-1;\n  while ((HiCnt += (++p)->Freq) <= count)\n    if (--i == 0) \n    {\n      Model->HiBitsFlag=Model->HB2Flag[Model->FoundState->Symbol];\n      Model->Coder.SubRange.LowCount=HiCnt;\n      Model->CharMask[p->Symbol]=Model->EscCount;\n      i=(Model->NumMasked=NumStats)-1;\n      Model->FoundState=NULL;\n      do \n      { \n        Model->CharMask[(--p)->Symbol]=Model->EscCount; \n      } while ( --i );\n      Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n      return(true);\n    }\n  Model->Coder.SubRange.LowCount=(Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n  update1(Model,p);\n  return(true);\n}\n\n\ninline void RARPPM_CONTEXT::update2(ModelPPM *Model,RARPPM_STATE* p)\n{\n  (Model->FoundState=p)->Freq += 4;              \n  U.SummFreq += 4;\n  if (p->Freq > MAX_FREQ)                 \n    rescale(Model);\n  Model->EscCount++;\n  Model->RunLength=Model->InitRL;\n}\n\n\ninline RARPPM_SEE2_CONTEXT* RARPPM_CONTEXT::makeEscFreq2(ModelPPM *Model,int Diff)\n{\n  RARPPM_SEE2_CONTEXT* psee2c;\n  if (NumStats != 256) \n  {\n    psee2c=Model->SEE2Cont[Model->NS2Indx[Diff-1]]+\n           (Diff < Suffix->NumStats-NumStats)+\n           2*(U.SummFreq < 11*NumStats)+4*(Model->NumMasked > Diff)+\n           Model->HiBitsFlag;\n    Model->Coder.SubRange.scale=psee2c->getMean();\n  }\n  else \n  {\n    psee2c=&Model->DummySEE2Cont;\n    Model->Coder.SubRange.scale=1;\n  }\n  return psee2c;\n}\n\n\n\n\ninline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n\n    // We do not reuse PPMd coder in unstable state, so we do not really need\n    // this check and added it for extra safety. See CVE-2017-17969 for details.\n    if (pps>=ps+ASIZE(ps))\n      return false;\n\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) // Extra safety check.\n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n\n    // 2022.12.02: we removed pps-- here and changed the code below to avoid\n    // \"array subscript -1 is outside array bounds\" warning in some compilers.\n    do \n    { \n      if (pps>=ps+ASIZE(ps)) // Extra safety check.\n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n      pps++;\n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}\n\n\ninline void ModelPPM::ClearMask()\n{\n  EscCount=1;                             \n  memset(CharMask,0,sizeof(CharMask));\n}\n\n\n\n\n// reset PPM variables after data error allowing safe resuming\n// of further data processing\nvoid ModelPPM::CleanUp()\n{\n  SubAlloc.StopSubAllocator();\n  SubAlloc.StartSubAllocator(1);\n  StartModelRare(2);\n}\n\n\nbool ModelPPM::DecodeInit(Unpack *UnpackRead,int &EscChar)\n{\n  int MaxOrder=UnpackRead->GetChar();\n  bool Reset=(MaxOrder & 0x20)!=0;\n\n  int MaxMB;\n  if (Reset)\n    MaxMB=UnpackRead->GetChar();\n  else\n    if (SubAlloc.GetAllocatedMemory()==0)\n      return(false);\n  if (MaxOrder & 0x40)\n    EscChar=UnpackRead->GetChar();\n  Coder.InitDecoder(UnpackRead);\n  if (Reset)\n  {\n    MaxOrder=(MaxOrder & 0x1f)+1;\n    if (MaxOrder>16)\n      MaxOrder=16+(MaxOrder-16)*3;\n    if (MaxOrder==1)\n    {\n      SubAlloc.StopSubAllocator();\n      return(false);\n    }\n    SubAlloc.StartSubAllocator(MaxMB+1);\n    StartModelRare(MaxOrder);\n  }\n  return(MinContext!=NULL);\n}\n\n\nint ModelPPM::DecodeChar()\n{\n  if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n    return(-1);\n  if (MinContext->NumStats != 1)      \n  {\n    if ((byte*)MinContext->U.Stats <= SubAlloc.pText || (byte*)MinContext->U.Stats>SubAlloc.HeapEnd)\n      return(-1);\n    if (!MinContext->decodeSymbol1(this))\n      return(-1);\n  }\n  else                                \n    MinContext->decodeBinSymbol(this);\n  Coder.Decode();\n  while ( !FoundState ) \n  {\n    ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n    do\n    {\n      OrderFall++;                \n      MinContext=MinContext->Suffix;\n      if ((byte*)MinContext <= SubAlloc.pText || (byte*)MinContext>SubAlloc.HeapEnd)\n        return(-1);\n    } while (MinContext->NumStats == NumMasked);\n    if (!MinContext->decodeSymbol2(this))\n      return(-1);\n    Coder.Decode();\n  }\n  int Symbol=FoundState->Symbol;\n  if (!OrderFall && (byte*) FoundState->Successor > SubAlloc.pText)\n    MinContext=MaxContext=FoundState->Successor;\n  else\n  {\n    UpdateModel();\n    if (EscCount == 0)\n      ClearMask();\n  }\n  ARI_DEC_NORMALIZE(Coder.code,Coder.low,Coder.range,Coder.UnpackRead);\n  return(Symbol);\n}\n", "#include \"rar.hpp\"\n\nwchar* PointToName(const wchar *Path)\n{\n  for (int I=(int)wcslen(Path)-1;I>=0;I--)\n    if (IsPathDiv(Path[I]))\n      return (wchar*)&Path[I+1];\n  return (wchar*)((*Path!=0 && IsDriveDiv(Path[1])) ? Path+2:Path);\n}\n\n\nwchar* PointToLastChar(const wchar *Path)\n{\n  size_t Length=wcslen(Path);\n  return (wchar*)(Length>0 ? Path+Length-1:Path);\n}\n\n\nwchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n\n  // Prevent \\..\\ in any part of path string.\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n\n  // Remove any amount of <d>:\\ and any sequence of . and \\ in the beginning of path string.\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n\n    // Skip UNC Windows \\\\server\\share\\ or Unix //server/share/\n    if (IsPathDiv(s[0]) && IsPathDiv(s[1]))\n    {\n      uint SlashCount=0;\n      for (const wchar *t=s+2;*t!=0;t++)\n        if (IsPathDiv(*t) && ++SlashCount==2)\n        {\n          s=t+1; // Found two more path separators after leading two.\n          break;\n        }\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n\n  // Code above does not remove last \"..\", doing here.\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  \n  if (DestPath!=NULL)\n  {\n    // SrcPath and DestPath can point to same memory area,\n    // so we use the temporary buffer for copying.\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}\n\n\nvoid SetName(wchar *FullName,const wchar *Name,size_t MaxSize)\n{\n  wchar *NamePtr=PointToName(FullName);\n  wcsncpyz(NamePtr,Name,MaxSize-(NamePtr-FullName));\n}\n\n\nvoid SetExt(wchar *Name,const wchar *NewExt,size_t MaxSize)\n{\n  if (Name==NULL || *Name==0)\n    return;\n  wchar *Dot=GetExt(Name);\n  if (Dot!=NULL)\n    *Dot=0;\n  if (NewExt!=NULL)\n  {\n    wcsncatz(Name,L\".\",MaxSize);\n    wcsncatz(Name,NewExt,MaxSize);\n  }\n}\n\n\n#ifndef SFX_MODULE\nvoid SetSFXExt(wchar *SFXName,size_t MaxSize)\n{\n  if (SFXName==NULL || *SFXName==0)\n    return;\n\n#ifdef _UNIX\n  SetExt(SFXName,L\"sfx\",MaxSize);\n#endif\n\n#if defined(_WIN_ALL) || defined(_EMX)\n  SetExt(SFXName,L\"exe\",MaxSize);\n#endif\n}\n#endif\n\n\n// 'Ext' is an extension with the leading dot, like L\".rar\".\nwchar *GetExt(const wchar *Name)\n{\n  return Name==NULL ? NULL:wcsrchr(PointToName(Name),'.');\n}\n\n\n// 'Ext' is an extension without the leading dot, like L\"rar\".\nbool CmpExt(const wchar *Name,const wchar *Ext)\n{\n  wchar *NameExt=GetExt(Name);\n  return NameExt!=NULL && wcsicomp(NameExt+1,Ext)==0;\n}\n\n\nbool IsWildcard(const wchar *Str)\n{\n  if (Str==NULL)\n    return false;\n#ifdef _WIN_ALL\n  // Not treat the special NTFS \\\\?\\d: path prefix as a wildcard.\n  if (Str[0]=='\\\\' && Str[1]=='\\\\' && Str[2]=='?' && Str[3]=='\\\\')\n    Str+=4;\n#endif\n  return wcspbrk(Str,L\"*?\")!=NULL;\n}\n\n\nbool IsPathDiv(int Ch)\n{\n#ifdef _WIN_ALL\n  return Ch=='\\\\' || Ch=='/';\n#else\n  return Ch==CPATHDIVIDER;\n#endif\n}\n\n\nbool IsDriveDiv(int Ch)\n{\n#ifdef _UNIX\n  return false;\n#else\n  return Ch==':';\n#endif\n}\n\n\nbool IsDriveLetter(const wchar *Path)\n{\n  wchar Letter=etoupperw(Path[0]);\n  return Letter>='A' && Letter<='Z' && IsDriveDiv(Path[1]);\n}\n\n\nint GetPathDisk(const wchar *Path)\n{\n  if (IsDriveLetter(Path))\n    return etoupperw(*Path)-'A';\n  else\n    return -1;\n}\n\n\nvoid AddEndSlash(wchar *Path,size_t MaxLength)\n{\n  size_t Length=wcslen(Path);\n  if (Length>0 && Path[Length-1]!=CPATHDIVIDER && Length+1<MaxLength)\n  {\n    Path[Length]=CPATHDIVIDER;\n    Path[Length+1]=0;\n  }\n}\n\n\nvoid MakeName(const wchar *Path,const wchar *Name,wchar *Pathname,size_t MaxSize)\n{\n  // 'Path', 'Name' and 'Pathname' can point to same memory area. So we use\n  // the temporary buffer instead of constructing the name in 'Pathname'.\n  wchar OutName[NM];\n  wcsncpyz(OutName,Path,ASIZE(OutName));\n  // Do not add slash to d:, we want to allow relative paths like d:filename.\n  if (!IsDriveLetter(Path) || Path[2]!=0)\n    AddEndSlash(OutName,ASIZE(OutName));\n  wcsncatz(OutName,Name,ASIZE(OutName));\n  wcsncpyz(Pathname,OutName,MaxSize);\n}\n\n\n// Returns file path including the trailing path separator symbol.\nvoid GetFilePath(const wchar *FullName,wchar *Path,size_t MaxLength)\n{\n  if (MaxLength==0)\n    return;\n  size_t PathLength=Min(MaxLength-1,size_t(PointToName(FullName)-FullName));\n  wcsncpy(Path,FullName,PathLength);\n  Path[PathLength]=0;\n}\n\n\n// Removes name and returns file path without the trailing\n// path separator symbol.\nvoid RemoveNameFromPath(wchar *Path)\n{\n  wchar *Name=PointToName(Path);\n  if (Name>=Path+2 && (!IsDriveDiv(Path[1]) || Name>=Path+4))\n    Name--;\n  *Name=0;\n}\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nbool GetAppDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  LPMALLOC g_pMalloc;\n  SHGetMalloc(&g_pMalloc);\n  LPITEMIDLIST ppidl;\n  *Path=0;\n  bool Success=false;\n  if (SHGetSpecialFolderLocation(NULL,CSIDL_APPDATA,&ppidl)==NOERROR &&\n      SHGetPathFromIDList(ppidl,Path) && *Path!=0)\n  {\n    AddEndSlash(Path,MaxSize);\n    wcsncatz(Path,L\"WinRAR\",MaxSize);\n    Success=FileExist(Path);\n    if (!Success && Create)\n      Success=MakeDir(Path,false,0)==MKDIR_SUCCESS;\n  }\n  g_pMalloc->Free(ppidl);\n  return Success;\n}\n#endif\n\n\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\nvoid GetRarDataPath(wchar *Path,size_t MaxSize,bool Create)\n{\n  *Path=0;\n\n  HKEY hKey;\n  if (RegOpenKeyEx(HKEY_CURRENT_USER,L\"Software\\\\WinRAR\\\\Paths\",0,\n                   KEY_QUERY_VALUE,&hKey)==ERROR_SUCCESS)\n  {\n    DWORD DataSize=(DWORD)MaxSize,Type;\n    RegQueryValueEx(hKey,L\"AppData\",0,&Type,(BYTE *)Path,&DataSize);\n    RegCloseKey(hKey);\n  }\n\n  if (*Path==0 || !FileExist(Path))\n    if (!GetAppDataPath(Path,MaxSize,Create))\n    {\n      GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n      RemoveNameFromPath(Path);\n    }\n}\n#endif\n\n\n#ifndef SFX_MODULE\nbool EnumConfigPaths(uint Number,wchar *Path,size_t MaxSize,bool Create)\n{\n#ifdef _UNIX\n  static const wchar *ConfPath[]={\n    L\"/etc\", L\"/etc/rar\", L\"/usr/lib\", L\"/usr/local/lib\", L\"/usr/local/etc\"\n  };\n  if (Number==0)\n  {\n    char *EnvStr=getenv(\"HOME\");\n    if (EnvStr!=NULL)\n      CharToWide(EnvStr,Path,MaxSize);\n    else\n      wcsncpyz(Path,ConfPath[0],MaxSize);\n    return true;\n  }\n  Number--;\n  if (Number>=ASIZE(ConfPath))\n    return false;\n  wcsncpyz(Path,ConfPath[Number], MaxSize);\n  return true;\n#elif defined(_WIN_ALL)\n  if (Number>1)\n    return false;\n  if (Number==0)\n    GetRarDataPath(Path,MaxSize,Create);\n  else\n  {\n    GetModuleFileName(NULL,Path,(DWORD)MaxSize);\n    RemoveNameFromPath(Path);\n  }\n  return true;\n#else\n  return false;\n#endif\n}\n#endif\n\n\n#ifndef SFX_MODULE\nvoid GetConfigName(const wchar *Name,wchar *FullName,size_t MaxSize,bool CheckExist,bool Create)\n{\n  *FullName=0;\n  for (uint I=0;EnumConfigPaths(I,FullName,MaxSize,Create);I++)\n  {\n    AddEndSlash(FullName,MaxSize);\n    wcsncatz(FullName,Name,MaxSize);\n    if (!CheckExist || WildFileExist(FullName))\n      break;\n  }\n}\n#endif\n\n\n// Returns a pointer to rightmost digit of volume number or to beginning\n// of file name if numeric part is missing.\nwchar* GetVolNumPart(const wchar *ArcName)\n{\n  // We do not want to increment any characters in path component.\n  ArcName=PointToName(ArcName);\n\n  if (*ArcName==0)\n    return (wchar *)ArcName;\n\n  // Pointing to last name character.\n  const wchar *ChPtr=ArcName+wcslen(ArcName)-1;\n\n  // Skipping the archive extension.\n  while (!IsDigit(*ChPtr) && ChPtr>ArcName)\n    ChPtr--;\n\n  // Skipping the numeric part of name.\n  const wchar *NumPtr=ChPtr;\n  while (IsDigit(*NumPtr) && NumPtr>ArcName)\n    NumPtr--;\n\n  // Searching for first numeric part in names like name.part##of##.rar.\n  // Stop search on the first dot.\n  while (NumPtr>ArcName && *NumPtr!='.')\n  {\n    if (IsDigit(*NumPtr))\n    {\n      // Validate the first numeric part only if it has a dot somewhere \n      // before it.\n      const wchar *Dot=wcschr(ArcName,'.');\n      if (Dot!=NULL && Dot<NumPtr)\n        ChPtr=NumPtr;\n      break;\n    }\n    NumPtr--;\n  }\n  return (wchar *)ChPtr;\n}\n\n\nvoid NextVolumeName(wchar *ArcName,uint MaxLength,bool OldNumbering)\n{\n  wchar *ChPtr;\n  if ((ChPtr=GetExt(ArcName))==NULL)\n  {\n    wcsncatz(ArcName,L\".rar\",MaxLength);\n    ChPtr=GetExt(ArcName);\n  }\n  else\n    if (ChPtr[1]==0 || wcsicomp(ChPtr,L\".exe\")==0 || wcsicomp(ChPtr,L\".sfx\")==0)\n      wcsncpyz(ChPtr,L\".rar\",MaxLength-(ChPtr-ArcName));\n\n  if (ChPtr==NULL || *ChPtr!='.' || ChPtr[1]==0)\n  {\n    // Normally we shall have some extension here. If we don't, it means\n    // the name has no extension and buffer has no free space to append one.\n    // Let's clear the name to prevent a new call with same name and return.\n    *ArcName=0;\n    return;\n  }\n\n  if (!OldNumbering)\n  {\n    ChPtr=GetVolNumPart(ArcName);\n\n    // We should not check for IsDigit(*ChPtr) here and should increment\n    // even non-digits. If we got a corrupt archive with volume flag,\n    // but without numeric part, we still need to modify its name somehow,\n    // so while (exist(name)) {NextVolumeName()} loops do not run infinitely.\n    while ((++(*ChPtr))=='9'+1)\n    {\n      *ChPtr='0';\n      ChPtr--;\n      if (ChPtr<ArcName || !IsDigit(*ChPtr))\n      {\n        // Convert .part:.rar (.part9.rar after increment) to part10.rar.\n        for (wchar *EndPtr=ArcName+wcslen(ArcName);EndPtr!=ChPtr;EndPtr--)\n          *(EndPtr+1)=*EndPtr;\n        *(ChPtr+1)='1';\n        break;\n      }\n    }\n  }\n  else\n    if (!IsDigit(ChPtr[2]) || !IsDigit(ChPtr[3]))\n      wcsncpyz(ChPtr+2,L\"00\",MaxLength-(ChPtr-ArcName)-2); // From .rar to .r00.\n    else\n    {\n      ChPtr+=wcslen(ChPtr)-1; // Set to last character.\n      while (++(*ChPtr)=='9'+1)\n        if (ChPtr<=ArcName || *(ChPtr-1)=='.')\n        {\n          *ChPtr='a'; // From .999 to .a00 if started from .001 or for too short names.\n          break;\n        }\n        else\n        {\n          *ChPtr='0';\n          ChPtr--;\n        }\n    }\n}\n\n\nbool IsNameUsable(const wchar *Name)\n{\n#ifndef _UNIX\n  if (Name[0] && Name[1] && wcschr(Name+2,':')!=NULL)\n    return false;\n  for (const wchar *s=Name;*s!=0;s++)\n  {\n    if ((uint)*s<32)\n      return false;\n    if ((*s==' ' || *s=='.') && IsPathDiv(s[1]))\n      return false;\n  }\n#endif\n  return *Name!=0 && wcspbrk(Name,L\"?*<>|\\\"\")==NULL;\n}\n\n\nvoid MakeNameUsable(char *Name,bool Extended)\n{\n#ifdef _WIN_ALL\n  // In Windows we also need to convert characters not defined in current\n  // code page. This double conversion changes them to '?', which is\n  // catched by code below.\n  size_t NameLength=strlen(Name);\n  wchar NameW[NM];\n  CharToWide(Name,NameW,ASIZE(NameW));\n  WideToChar(NameW,Name,NameLength+1);\n  Name[NameLength]=0;\n#endif\n  for (char *s=Name;*s!=0;s=charnext(s))\n  {\n    if (strchr(Extended ? \"?*<>|\\\"\":\"?*\",*s)!=NULL || Extended && (byte)*s<32)\n      *s='_';\n#ifdef _EMX\n    if (*s=='=')\n      *s='_';\n#endif\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if ((*s==' ' || *s=='.' && s>Name && !IsPathDiv(s[-1]) && s[-1]!='.') && IsPathDiv(s[1]))\n      *s='_';\n#endif\n  }\n}\n\n\nvoid MakeNameUsable(wchar *Name,bool Extended)\n{\n  for (wchar *s=Name;*s!=0;s++)\n  {\n    if (wcschr(Extended ? L\"?*<>|\\\"\":L\"?*\",*s)!=NULL || Extended && (uint)*s<32)\n      *s='_';\n#ifndef _UNIX\n    if (s-Name>1 && *s==':')\n      *s='_';\n#if 0  // We already can create such files.\n    // Remove ' ' and '.' before path separator, but allow .\\ and ..\\.\n    if (IsPathDiv(s[1]) && (*s==' ' || *s=='.' && s>Name &&\n        !IsPathDiv(s[-1]) && (s[-1]!='.' || s>Name+1 && !IsPathDiv(s[-2]))))\n      *s='_';\n#endif\n#endif\n  }\n}\n\n\nvoid UnixSlashToDos(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const char *SrcName,char *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid UnixSlashToDos(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='/' ? '\\\\':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid DosSlashToUnix(const wchar *SrcName,wchar *DestName,size_t MaxLength)\n{\n  size_t Copied=0;\n  for (;Copied<MaxLength-1 && SrcName[Copied]!=0;Copied++)\n    DestName[Copied]=SrcName[Copied]=='\\\\' ? '/':SrcName[Copied];\n  DestName[Copied]=0;\n}\n\n\nvoid ConvertNameToFull(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (Src==NULL || *Src==0)\n  {\n    if (MaxSize>0)\n      *Dest=0;\n    return;\n  }\n#ifdef _WIN_ALL\n  {\n    wchar FullName[NM],*NamePtr;\n    DWORD Code=GetFullPathName(Src,ASIZE(FullName),FullName,&NamePtr);\n    if (Code==0 || Code>ASIZE(FullName))\n    {\n      wchar LongName[NM];\n      if (GetWinLongPath(Src,LongName,ASIZE(LongName)))\n        Code=GetFullPathName(LongName,ASIZE(FullName),FullName,&NamePtr);\n    }\n    if (Code!=0 && Code<ASIZE(FullName))\n      wcsncpyz(Dest,FullName,MaxSize);\n    else\n      if (Src!=Dest)\n        wcsncpyz(Dest,Src,MaxSize);\n  }\n#elif defined(_UNIX)\n  if (IsFullPath(Src))\n    *Dest=0;\n  else\n  {\n    char CurDirA[NM];\n    if (getcwd(CurDirA,ASIZE(CurDirA))==NULL)\n      *CurDirA=0;\n    CharToWide(CurDirA,Dest,MaxSize);\n    AddEndSlash(Dest,MaxSize);\n  }\n  wcsncatz(Dest,Src,MaxSize);\n#else\n  wcsncpyz(Dest,Src,MaxSize);\n#endif\n}\n\n\nbool IsFullPath(const wchar *Path)\n{\n/*\n  wchar PathOnly[NM];\n  GetFilePath(Path,PathOnly,ASIZE(PathOnly));\n  if (IsWildcard(PathOnly))\n    return true;\n*/\n#if defined(_WIN_ALL) || defined(_EMX)\n  return Path[0]=='\\\\' && Path[1]=='\\\\' || IsDriveLetter(Path) && IsPathDiv(Path[2]);\n#else\n  return IsPathDiv(Path[0]);\n#endif\n}\n\n\nbool IsFullRootPath(const wchar *Path)\n{\n  return IsFullPath(Path) || IsPathDiv(Path[0]);\n}\n\n\nvoid GetPathRoot(const wchar *Path,wchar *Root,size_t MaxSize)\n{\n  *Root=0;\n  if (IsDriveLetter(Path))\n    swprintf(Root,MaxSize,L\"%c:\\\\\",*Path);\n  else\n    if (Path[0]=='\\\\' && Path[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(Path+2,'\\\\');\n      if (Slash!=NULL)\n      {\n        size_t Length;\n        if ((Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n          Length=Slash-Path+1;\n        else\n          Length=wcslen(Path);\n        if (Length>=MaxSize)\n          Length=0;\n        wcsncpy(Root,Path,Length);\n        Root[Length]=0;\n      }\n    }\n}\n\n\nint ParseVersionFileName(wchar *Name,bool Truncate)\n{\n  int Version=0;\n  wchar *VerText=wcsrchr(Name,';');\n  if (VerText!=NULL)\n  {\n    Version=atoiw(VerText+1);\n    if (Truncate)\n      *VerText=0;\n  }\n  return Version;\n}\n\n\n#if !defined(SFX_MODULE)\n// Get the name of first volume. Return the leftmost digit of volume number.\nwchar* VolNameToFirstName(const wchar *VolName,wchar *FirstName,size_t MaxSize,bool NewNumbering)\n{\n  if (FirstName!=VolName)\n    wcsncpyz(FirstName,VolName,MaxSize);\n  wchar *VolNumStart=FirstName;\n  if (NewNumbering)\n  {\n    wchar N='1';\n\n    // From the rightmost digit of volume number to the left.\n    for (wchar *ChPtr=GetVolNumPart(FirstName);ChPtr>FirstName;ChPtr--)\n      if (IsDigit(*ChPtr))\n      {\n        *ChPtr=N; // Set the rightmost digit to '1' and others to '0'.\n        N='0';\n      }\n      else\n        if (N=='0')\n        {\n          VolNumStart=ChPtr+1; // Store the position of leftmost digit in volume number.\n          break;\n        }\n  }\n  else\n  {\n    // Old volume numbering scheme. Just set the extension to \".rar\".\n    SetExt(FirstName,L\"rar\",MaxSize);\n    VolNumStart=GetExt(FirstName);\n  }\n  if (!FileExist(FirstName))\n  {\n    // If the first volume, which name we just generated, does not exist,\n    // check if volume with same name and any other extension is available.\n    // It can help in case of *.exe or *.sfx first volume.\n    wchar Mask[NM];\n    wcsncpyz(Mask,FirstName,ASIZE(Mask));\n    SetExt(Mask,L\"*\",ASIZE(Mask));\n    FindFile Find;\n    Find.SetMask(Mask);\n    FindData FD;\n    while (Find.Next(&FD))\n    {\n      Archive Arc;\n      if (Arc.Open(FD.Name,0) && Arc.IsArchive(true) && Arc.FirstVolume)\n      {\n        wcsncpyz(FirstName,FD.Name,MaxSize);\n        break;\n      }\n    }\n  }\n  return VolNumStart;\n}\n#endif\n\n\n#ifndef SFX_MODULE\nstatic void GenArcName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,uint ArcNumber,bool &ArcNumPresent)\n{\n  bool Prefix=false;\n  if (*GenerateMask=='+')\n  {\n    Prefix=true;    // Add the time string before the archive name.\n    GenerateMask++; // Skip '+' in the beginning of time mask.\n  }\n\n  wchar Mask[MAX_GENERATE_MASK];\n  wcsncpyz(Mask,*GenerateMask!=0 ? GenerateMask:L\"yyyymmddhhmmss\",ASIZE(Mask));\n\n  bool QuoteMode=false;\n  uint MAsMinutes=0; // By default we treat 'M' as months.\n  for (uint I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    int CurChar=toupperw(Mask[I]);\n    if (CurChar=='H')\n      MAsMinutes=2; // Treat next two 'M' after 'H' as minutes.\n    if (CurChar=='D' || CurChar=='Y')\n      MAsMinutes=0; // Treat 'M' in HHDDMMYY and HHYYMMDD as month.\n\n    if (MAsMinutes>0 && CurChar=='M')\n    {\n      // Replace minutes with 'I'. We use 'M' both for months and minutes,\n      // so we treat as minutes only those 'M', which are found after hours.\n      Mask[I]='I';\n      MAsMinutes--;\n    }\n    if (CurChar=='N')\n    {\n      uint Digits=GetDigits(ArcNumber);\n      uint NCount=0;\n      while (toupperw(Mask[I+NCount])=='N')\n        NCount++;\n\n      // Here we ensure that we have enough 'N' characters to fit all digits\n      // of archive number. We'll replace them by actual number later\n      // in this function.\n      if (NCount<Digits)\n      {\n        wmemmove(Mask+I+Digits,Mask+I+NCount,wcslen(Mask+I+NCount)+1);\n        wmemset(Mask+I,'N',Digits);\n      }\n      I+=Max(Digits,NCount)-1;\n      ArcNumPresent=true;\n      continue;\n    }\n  }\n\n  RarTime CurTime;\n  CurTime.SetCurrentTime();\n  RarLocalTime rlt;\n  CurTime.GetLocal(&rlt);\n\n  wchar Ext[NM],*Dot=GetExt(ArcName);\n  *Ext=0;\n  if (Dot==NULL)\n    wcsncpyz(Ext,*PointToName(ArcName)==0 ? L\".rar\":L\"\",ASIZE(Ext));\n  else\n  {\n    wcsncpyz(Ext,Dot,ASIZE(Ext));\n    *Dot=0;\n  }\n\n  int WeekDay=rlt.wDay==0 ? 6:rlt.wDay-1;\n  int StartWeekDay=rlt.yDay-WeekDay;\n  if (StartWeekDay<0)\n    if (StartWeekDay<=-4)\n      StartWeekDay+=IsLeapYear(rlt.Year-1) ? 366:365;\n    else\n      StartWeekDay=0;\n  int CurWeek=StartWeekDay/7+1;\n  if (StartWeekDay%7>=4)\n    CurWeek++;\n\n  char Field[10][6];\n\n  sprintf(Field[0],\"%04u\",rlt.Year);\n  sprintf(Field[1],\"%02u\",rlt.Month);\n  sprintf(Field[2],\"%02u\",rlt.Day);\n  sprintf(Field[3],\"%02u\",rlt.Hour);\n  sprintf(Field[4],\"%02u\",rlt.Minute);\n  sprintf(Field[5],\"%02u\",rlt.Second);\n  sprintf(Field[6],\"%02u\",(uint)CurWeek);\n  sprintf(Field[7],\"%u\",(uint)WeekDay+1);\n  sprintf(Field[8],\"%03u\",rlt.yDay+1);\n  sprintf(Field[9],\"%05u\",ArcNumber);\n\n  const wchar *MaskChars=L\"YMDHISWAEN\";\n\n  // How many times every modifier character was encountered in the mask.\n  int CField[sizeof(Field)/sizeof(Field[0])];\n\n  memset(CField,0,sizeof(CField));\n  QuoteMode=false;\n  for (uint I=0;Mask[I]!=0;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    if (QuoteMode)\n      continue;\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr!=NULL)\n      CField[ChPtr-MaskChars]++;\n   }\n\n  wchar DateText[MAX_GENERATE_MASK];\n  *DateText=0;\n  QuoteMode=false;\n  for (size_t I=0,J=0;Mask[I]!=0 && J<ASIZE(DateText)-1;I++)\n  {\n    if (Mask[I]=='{' || Mask[I]=='}')\n    {\n      QuoteMode=(Mask[I]=='{');\n      continue;\n    }\n    const wchar *ChPtr=wcschr(MaskChars,toupperw(Mask[I]));\n    if (ChPtr==NULL || QuoteMode)\n    {\n      DateText[J]=Mask[I];\n#ifdef _WIN_ALL\n      // We do not allow ':' in Windows because of NTFS streams.\n      // Users had problems after specifying hh:mm mask.\n      if (DateText[J]==':')\n        DateText[J]='_';\n#endif\n    }\n    else\n    {\n      size_t FieldPos=ChPtr-MaskChars;\n      int CharPos=(int)strlen(Field[FieldPos])-CField[FieldPos]--;\n\n      // CField[FieldPos] shall have exactly 3 \"MMM\" symbols, so we do not\n      // repeat the month name in case \"MMMMMMMM\" mask. But since we\n      // decremented CField[FieldPos] above, we compared it with 2.\n      if (FieldPos==1 && CField[FieldPos]==2 &&\n          toupperw(Mask[I+1])=='M' && toupperw(Mask[I+2])=='M')\n      {\n        wcsncpyz(DateText+J,GetMonthName(rlt.Month-1),ASIZE(DateText)-J);\n        J=wcslen(DateText);\n        I+=2;\n        continue;\n      }\n      // If CharPos is negative, we have more modifier characters than\n      // matching time data. We prefer to issue a modifier character\n      // instead of repeating time data from beginning, so user can notice\n      // excessive modifiers added by mistake.\n      if (CharPos<0)\n        DateText[J]=Mask[I];\n      else\n        DateText[J]=Field[FieldPos][CharPos];\n    }\n    DateText[++J]=0;\n  }\n\n  if (Prefix)\n  {\n    wchar NewName[NM];\n    GetFilePath(ArcName,NewName,ASIZE(NewName));\n    AddEndSlash(NewName,ASIZE(NewName));\n    wcsncatz(NewName,DateText,ASIZE(NewName));\n    wcsncatz(NewName,PointToName(ArcName),ASIZE(NewName));\n    wcsncpyz(ArcName,NewName,MaxSize);\n  }\n  else\n    wcsncatz(ArcName,DateText,MaxSize);\n  wcsncatz(ArcName,Ext,MaxSize);\n}\n\n\nvoid GenerateArchiveName(wchar *ArcName,size_t MaxSize,const wchar *GenerateMask,bool Archiving)\n{\n  wchar NewName[NM];\n\n  uint ArcNumber=1;\n  while (true) // Loop for 'N' (archive number) processing.\n  {\n    wcsncpyz(NewName,ArcName,ASIZE(NewName));\n    \n    bool ArcNumPresent=false;\n\n    GenArcName(NewName,ASIZE(NewName),GenerateMask,ArcNumber,ArcNumPresent);\n    \n    if (!ArcNumPresent)\n      break;\n    if (!FileExist(NewName))\n    {\n      if (!Archiving && ArcNumber>1)\n      {\n        // If we perform non-archiving operation, we need to use the last\n        // existing archive before the first unused name. So we generate\n        // the name for (ArcNumber-1) below.\n        wcsncpyz(NewName,NullToEmpty(ArcName),ASIZE(NewName));\n        GenArcName(NewName,ASIZE(NewName),GenerateMask,ArcNumber-1,ArcNumPresent);\n      }\n      break;\n    }\n    ArcNumber++;\n  }\n  wcsncpyz(ArcName,NewName,MaxSize);\n}\n#endif\n\n\nwchar* GetWideName(const char *Name,const wchar *NameW,wchar *DestW,size_t DestSize)\n{\n  if (NameW!=NULL && *NameW!=0)\n  {\n    if (DestW!=NameW)\n      wcsncpy(DestW,NameW,DestSize);\n  }\n  else\n    if (Name!=NULL)\n      CharToWide(Name,DestW,DestSize);\n    else\n      *DestW=0;\n\n  // Ensure that we return a zero terminate string for security reasons.\n  if (DestSize>0)\n    DestW[DestSize-1]=0;\n\n  return DestW;\n}\n\n\n#ifdef _WIN_ALL\n// We should return 'true' even if resulting path is shorter than MAX_PATH,\n// because we can also use this function to open files with non-standard\n// characters, even if their path length is normal.\nbool GetWinLongPath(const wchar *Src,wchar *Dest,size_t MaxSize)\n{\n  if (*Src==0)\n    return false;\n  const wchar *Prefix=L\"\\\\\\\\?\\\\\";\n  const size_t PrefixLength=4;\n  bool FullPath=IsDriveLetter(Src) && IsPathDiv(Src[2]);\n  size_t SrcLength=wcslen(Src);\n  if (IsFullPath(Src)) // Paths in d:\\path\\name format.\n  {\n    if (IsDriveLetter(Src))\n    {\n      if (MaxSize<=PrefixLength+SrcLength)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      wcsncatz(Dest,Src,MaxSize); // \"\\\\?\\D:\\very long path\".\n      return true;\n    }\n    else\n      if (Src[0]=='\\\\' && Src[1]=='\\\\')\n      {\n        if (MaxSize<=PrefixLength+SrcLength+2)\n          return false;\n        wcsncpyz(Dest,Prefix,MaxSize);\n        wcsncatz(Dest,L\"UNC\",MaxSize);\n        wcsncatz(Dest,Src+1,MaxSize); // \"\\\\?\\UNC\\server\\share\".\n        return true;\n      }\n    // We may be here only if we modify IsFullPath in the future.\n    return false;\n  }\n  else\n  {\n    wchar CurDir[NM];\n    DWORD DirCode=GetCurrentDirectory(ASIZE(CurDir)-1,CurDir);\n    if (DirCode==0 || DirCode>ASIZE(CurDir)-1)\n      return false;\n\n    if (IsPathDiv(Src[0])) // Paths in \\path\\name format.\n    {\n      if (MaxSize<=PrefixLength+SrcLength+2)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      CurDir[2]=0;\n      wcsncatz(Dest,CurDir,MaxSize); // Copy drive letter 'd:'.\n      wcsncatz(Dest,Src,MaxSize);\n      return true;\n    }\n    else  // Paths in path\\name format.\n    {\n      AddEndSlash(CurDir,ASIZE(CurDir));\n      if (MaxSize<=PrefixLength+wcslen(CurDir)+SrcLength)\n        return false;\n      wcsncpyz(Dest,Prefix,MaxSize);\n      wcsncatz(Dest,CurDir,MaxSize);\n\n      if (Src[0]=='.' && IsPathDiv(Src[1])) // Remove leading .\\ in pathname.\n        Src+=2;\n\n      wcsncatz(Dest,Src,MaxSize);\n      return true;\n    }\n  }\n  return false;\n}\n\n\n// Convert Unix, OS X and Android decomposed chracters to Windows precomposed.\nvoid ConvertToPrecomposed(wchar *Name,size_t NameSize)\n{\n  wchar FileName[NM];\n  if (WinNT()>=WNT_VISTA && // MAP_PRECOMPOSED is not supported in XP.\n      FoldString(MAP_PRECOMPOSED,Name,-1,FileName,ASIZE(FileName))!=0)\n  {\n    FileName[ASIZE(FileName)-1]=0;\n    wcsncpyz(Name,FileName,NameSize);\n  }\n}\n\n\nvoid MakeNameCompatible(wchar *Name,size_t MaxSize)\n{\n  // Remove trailing spaces and dots in file name and in dir names in path.\n  int Src=0,Dest=0;\n  while (true)\n  {\n    if (IsPathDiv(Name[Src]) || Name[Src]==0)\n      for (int I=Dest-1;I>0 && (Name[I]==' ' || Name[I]=='.');I--)\n      {\n        // Permit path1/./path2 and ../path1 paths.\n        if (Name[I]=='.' && (IsPathDiv(Name[I-1]) || Name[I-1]=='.' && I==1))\n          break;\n        Dest--;\n      }\n    Name[Dest]=Name[Src];\n    if (Name[Src]==0)\n      break;\n    Src++;\n    Dest++;\n  }\n\n  // Rename reserved device names, such as aux.txt to _aux.txt.\n  // We check them in path components too, where they are also prohibited.\n  for (uint I=0;Name[I]!=0;I++)\n    if (I==0 || I>0 && IsPathDiv(Name[I-1]))\n    {\n      static const wchar *Devices[]={L\"CON\",L\"PRN\",L\"AUX\",L\"NUL\",L\"COM#\",L\"LPT#\"};\n      wchar *s=Name+I;\n      bool MatchFound=false;\n      for (uint J=0;J<ASIZE(Devices);J++)\n        for (uint K=0;;K++)\n          if (Devices[J][K]=='#')\n          {\n            if (!IsDigit(s[K]))\n              break;\n          }\n          else\n            if (Devices[J][K]==0)\n            {\n              // Names like aux.txt are accessible without \\\\?\\ prefix\n              // since Windows 11. Pure aux is still prohibited.\n              MatchFound=s[K]==0 || s[K]=='.' && !IsWindows11OrGreater() || IsPathDiv(s[K]);\n              break;\n            }\n            else\n              if (Devices[J][K]!=toupperw(s[K]))\n                break;\n      if (MatchFound)\n      {\n        wchar OrigName[NM];\n        wcsncpyz(OrigName,Name,ASIZE(OrigName));\n        if (MaxSize>I+1) // I+1, because we do not move the trailing 0.\n          memmove(s+1,s,(MaxSize-I-1)*sizeof(*s));\n        *s='_';\n#ifndef SFX_MODULE\n        uiMsg(UIMSG_CORRECTINGNAME,nullptr);\n        uiMsg(UIERROR_RENAMING,nullptr,OrigName,Name);\n#endif\n      }\n    }\n}\n#endif\n\n\n", "#ifndef _RAR_TIMEFN_\n#define _RAR_TIMEFN_\n\nstruct RarLocalTime\n{\n  uint Year;\n  uint Month;\n  uint Day;\n  uint Hour;\n  uint Minute;\n  uint Second;\n  uint Reminder; // Part of time smaller than 1 second, represented in 1/REMINDER_PRECISION intervals.\n  uint wDay;\n  uint yDay;\n};\n\n\nclass RarTime\n{\n  private:\n    static const uint TICKS_PER_SECOND = 1000000000; // Internal precision.\n\n    // Internal time representation in 1/TICKS_PER_SECOND since 01.01.1601.\n    // We use nanoseconds here to handle the high precision Unix time.\n    // It allows dates up to July 2185.\n    //\n    // If we'll ever need to extend the date range, we can define a lower\n    // precision Windows version of TICKS_PER_SECOND. But then Unix and Windows\n    // versions can differ in least significant digits of \"lt\" time output\n    // for Unix archives.\n    // Alternatively we can introduce 'bool HighPrecision' set to true\n    // in SetUnixNS() and TicksPerSecond() instead of constant above.\n    // It might be more reliable than defining TicksPerSecond variable,\n    // which wouldn't survive memset of any structure hosting RarTime.\n    // We would need to eliminate all such memsets in the entire code first.\n    uint64 itime;\n  public:\n    // RarLocalTime::Reminder precision. Must be equal to TICKS_PER_SECOND.\n    // Unlike TICKS_PER_SECOND, it is a public field.\n    static const uint REMINDER_PRECISION = TICKS_PER_SECOND;\n  public:\n    RarTime() {Reset();}\n    bool operator == (RarTime &rt) {return itime==rt.itime;}\n    bool operator != (RarTime &rt) {return itime!=rt.itime;}\n    bool operator < (RarTime &rt)  {return itime<rt.itime;}\n    bool operator <= (RarTime &rt) {return itime<rt.itime || itime==rt.itime;}\n    bool operator > (RarTime &rt)  {return itime>rt.itime;}\n    bool operator >= (RarTime &rt) {return itime>rt.itime || itime==rt.itime;}\n\n    void GetLocal(RarLocalTime *lt);\n    void SetLocal(RarLocalTime *lt);\n#ifdef _WIN_ALL\n    void GetWinFT(FILETIME *ft);\n    void SetWinFT(FILETIME *ft);\n#endif\n    uint64 GetWin();\n    void SetWin(uint64 WinTime);\n    time_t GetUnix();\n    void SetUnix(time_t ut);\n    uint64 GetUnixNS();\n    void SetUnixNS(uint64 ns);\n    uint GetDos();\n    void SetDos(uint DosTime);\n    void GetText(wchar *DateStr,size_t MaxSize,bool FullMS);\n    void SetIsoText(const wchar *TimeText);\n    void SetAgeText(const wchar *TimeText);\n    void SetCurrentTime();\n    void Reset() {itime=0;}\n    bool IsSet() {return itime!=0;}\n    void Adjust(int64 ns);\n};\n\nconst wchar *GetMonthName(int Month);\nbool IsLeapYear(int Year);\n\n#endif\n", "\n\nstatic bool UnixSymlink(CommandData *Cmd,const char *Target,const wchar *LinkName,RarTime *ftm,RarTime *fta)\n{\n  CreatePath(LinkName,true,Cmd->DisableNames);\n\n  // Overwrite prompt was already issued and confirmed earlier, so we can\n  // remove existing symlink or regular file here. PrepareToDelete was also\n  // called earlier inside of uiAskReplaceEx.\n  DelFile(LinkName);\n\n  char LinkNameA[NM];\n  WideToChar(LinkName,LinkNameA,ASIZE(LinkNameA));\n  if (symlink(Target,LinkNameA)==-1) // Error.\n  {\n    if (errno==EEXIST)\n      uiMsg(UIERROR_ULINKEXIST,LinkName);\n    else\n    {\n      uiMsg(UIERROR_SLINKCREATE,UINULL,LinkName);\n      ErrHandler.SetErrorCode(RARX_WARNING);\n    }\n    return false;\n  }\n#ifdef USE_LUTIMES\n#ifdef UNIX_TIME_NS\n  timespec times[2];\n  times[0].tv_sec=fta->GetUnix();\n  times[0].tv_nsec=fta->IsSet() ? long(fta->GetUnixNS()%1000000000) : UTIME_NOW;\n  times[1].tv_sec=ftm->GetUnix();\n  times[1].tv_nsec=ftm->IsSet() ? long(ftm->GetUnixNS()%1000000000) : UTIME_NOW;\n  utimensat(AT_FDCWD,LinkNameA,times,AT_SYMLINK_NOFOLLOW);\n#else\n  struct timeval tv[2];\n  tv[0].tv_sec=fta->GetUnix();\n  tv[0].tv_usec=long(fta->GetUnixNS()%1000000000/1000);\n  tv[1].tv_sec=ftm->GetUnix();\n  tv[1].tv_usec=long(ftm->GetUnixNS()%1000000000/1000);\n  lutimes(LinkNameA,tv);\n#endif\n#endif\n\n  return true;\n}\n\n\nstatic bool IsFullPath(const char *PathA) // Unix ASCII version.\n{\n  return *PathA==CPATHDIVIDER;\n}\n\n\n// For security purpose we prefer to be sure that CharToWide completed\n// successfully and even if it truncated a string for some reason,\n// it didn't affect the number of path related characters we analyze\n// in IsRelativeSymlinkSafe later.\n// This check is likely to be excessive, but let's keep it anyway.\nstatic bool SafeCharToWide(const char *Src,wchar *Dest,size_t DestSize)\n{\n  if (!CharToWide(Src,Dest,DestSize) || *Dest==0)\n    return false;\n  uint SrcChars=0,DestChars=0;\n  for (uint I=0;Src[I]!=0;I++)\n    if (Src[I]=='/' || Src[I]=='.')\n      SrcChars++;\n  for (uint I=0;Dest[I]!=0;I++)\n    if (Dest[I]=='/' || Dest[I]=='.')\n      DestChars++;\n  return SrcChars==DestChars;\n}\n\n\nstatic bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,\n                              const wchar *LinkName,bool &UpLink)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    // Return true in case of bad checksum, so link will be processed further\n    // and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    // Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    // can include the destination path as a prefix, which can\n    // confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    UpLink=strstr(Target,\"..\")!=NULL;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}\n\n\nstatic bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    // Cannot create Windows absolute path symlinks in Unix. Only relative path\n    // Windows symlinks can be created here. RAR 5.0 used \\??\\ prefix\n    // for Windows absolute symlinks, since RAR 5.1 /??/ is used.\n    // We escape ? as \\? to avoid \"trigraph\" warning\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  // Use hd->FileName instead of LinkName, since LinkName can include\n  // the destination path as a prefix, which can confuse\n  // IsRelativeSymlinkSafe algorithm.\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}\n", "#define RARVER_MAJOR     6\n#define RARVER_MINOR    20\n#define RARVER_BETA      3\n#define RARVER_DAY      15\n#define RARVER_MONTH    12\n#define RARVER_YEAR   2022\n", "\n\n#if !defined(SFX_MODULE) && defined(_WIN_ALL)\nvoid ExtractStreams20(Archive &Arc,const wchar *FileName)\n{\n  if (Arc.BrokenHeader)\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  if (Arc.StreamHead.Method<0x31 || Arc.StreamHead.Method>0x35 || Arc.StreamHead.UnpVer>VER_PACK)\n  {\n    uiMsg(UIERROR_STREAMUNKNOWN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_WARNING);\n    return;\n  }\n\n  wchar StreamName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    // Convert single character names like f:stream to .\\f:stream to\n    // resolve the ambiguity with drive letters.\n    wcsncpyz(StreamName,L\".\\\\\",ASIZE(StreamName));\n    wcsncatz(StreamName,FileName,ASIZE(StreamName));\n  }\n  else\n    wcsncpyz(StreamName,FileName,ASIZE(StreamName));\n  if (wcslen(StreamName)+strlen(Arc.StreamHead.StreamName)>=ASIZE(StreamName) ||\n      Arc.StreamHead.StreamName[0]!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  wchar StoredName[NM];\n  CharToWide(Arc.StreamHead.StreamName,StoredName,ASIZE(StoredName));\n  ConvertPath(StoredName+1,StoredName+1,ASIZE(StoredName)-1);\n\n  wcsncatz(StreamName,StoredName,ASIZE(StreamName));\n\n  FindData fd;\n  bool Found=FindFile::FastFind(FileName,&fd);\n\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n\n  File CurFile;\n  if (CurFile.WCreate(StreamName))\n  {\n    ComprDataIO DataIO;\n    Unpack Unpack(&DataIO);\n    Unpack.Init(0x10000,false);\n\n    DataIO.SetPackedSizeToRead(Arc.StreamHead.DataSize);\n    DataIO.EnableShowProgress(false);\n    DataIO.SetFiles(&Arc,&CurFile);\n    DataIO.UnpHash.Init(HASH_CRC32,1);\n    Unpack.SetDestSize(Arc.StreamHead.UnpSize);\n    Unpack.DoUnpack(Arc.StreamHead.UnpVer,false);\n\n    if (Arc.StreamHead.StreamCRC!=DataIO.UnpHash.GetCRC32())\n    {\n      uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,StreamName);\n      ErrHandler.SetErrorCode(RARX_CRC);\n    }\n    else\n      CurFile.Close();\n  }\n  File HostFile;\n  if (Found && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr);\n}\n#endif\n\n\n#ifdef _WIN_ALL\nvoid ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    // Convert single character names like f:stream to .\\f:stream to\n    // resolve the ambiguity with drive letters.\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n\n\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n\n  if (CurFile.WCreate(FullName))\n  {\n    if (Arc.ReadSubData(NULL,&CurFile,false))\n      CurFile.Close();\n  }\n\n  // Restoring original file timestamps.\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n\n  // Restoring original file attributes. Important if file was read only\n  // or did not have \"Archive\" attribute\n  SetFileAttr(FileName,fd.FileAttr);\n}\n#endif\n\n\nvoid GetStreamNameNTFS(Archive &Arc,wchar *StreamName,size_t MaxSize)\n{\n  byte *Data=&Arc.SubHead.SubData[0];\n  size_t DataSize=Arc.SubHead.SubData.Size();\n  if (Arc.Format==RARFMT15)\n  {\n    size_t DestSize=Min(DataSize/2,MaxSize-1);\n    RawToWide(Data,StreamName,DestSize);\n    StreamName[DestSize]=0;\n  }\n  else\n  {\n    char UtfString[NM*4];\n    size_t DestSize=Min(DataSize,ASIZE(UtfString)-1);\n    memcpy(UtfString,Data,DestSize);\n    UtfString[DestSize]=0;\n    UtfToWide(UtfString,StreamName,MaxSize);\n  }\n}\n"], "filenames": ["arcread.cpp", "crypt.hpp", "dll.rc", "extinfo.cpp", "extinfo.hpp", "extract.cpp", "extract.hpp", "hardlinks.cpp", "model.cpp", "pathfn.cpp", "timefn.hpp", "ulinks.cpp", "version.hpp", "win32stm.cpp"], "buggy_code_start_loc": [1479, 18, 5, 114, 3, 14, 73, 3, 535, 34, 24, 73, 3, 121], "buggy_code_end_loc": [1480, 22, 19, 172, 6, 1352, 73, 5, 541, 39, 24, 110, 6, 123], "fixing_code_start_loc": [1479, 18, 5, 115, 4, 15, 74, 2, 535, 34, 25, 73, 3, 121], "fixing_code_end_loc": [1482, 19, 19, 249, 7, 1392, 80, 2, 544, 45, 36, 112, 6, 127], "type": "CWE-59", "message": "UnRAR before 6.2.3 allows extraction of files outside of the destination folder via symlink chains.", "other": {"cve": {"id": "CVE-2022-48579", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-07T04:15:12.073", "lastModified": "2023-08-17T19:15:09.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "UnRAR before 6.2.3 allows extraction of files outside of the destination folder via symlink chains."}, {"lang": "es", "value": "UnRAR en las versiones anteriores a la 6.2.3 permite la extracci\u00f3n de archivos fuera de la carpeta de destino mediante cadenas de enlaces simb\u00f3licos.  "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rarlab:unrar:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.3", "matchCriteriaId": "057E9885-5E94-4549-945B-33045A3FAAB8"}]}]}], "references": [{"url": "https://github.com/pmachapman/unrar/commit/2ecab6bb5ac4f3b88f270218445496662020205f#diff-ca3086f578522062d7e390ed2cd7e10f646378a8b8cbf287a6e4db5966df68ee", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/08/msg00023.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/pmachapman/unrar/commit/2ecab6bb5ac4f3b88f270218445496662020205f#diff-ca3086f578522062d7e390ed2cd7e10f646378a8b8cbf287a6e4db5966df68ee"}}