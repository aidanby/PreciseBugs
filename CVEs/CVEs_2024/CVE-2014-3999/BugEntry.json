{"buggy_code": ["<?php\n/**\n * The main Horde_Ldap class.\n *\n * Copyright 2003-2007 Tarjej Huse, Jan Wagner, Del Elson, Benedikt Hallinger\n * Copyright 2009-2014 Horde LLC (http://www.horde.org/)\n *\n * @package   Ldap\n * @author    Tarjej Huse <tarjei@bergfald.no>\n * @author    Jan Wagner <wagner@netsols.de>\n * @author    Del <del@babel.com.au>\n * @author    Benedikt Hallinger <beni@php.net>\n * @author    Ben Klang <ben@alkaloid.net>\n * @author    Chuck Hagenbuch <chuck@horde.org>\n * @author    Jan Schneider <jan@horde.org>\n * @license   http://www.gnu.org/licenses/lgpl-3.0.txt LGPLv3\n */\nclass Horde_Ldap\n{\n    /**\n     * Class configuration array\n     *\n     * - hostspec:       the LDAP host to connect to (may be an array of\n     *                   several hosts to try).\n     * - port:           the server port.\n     * - version:        LDAP version (defaults to 3).\n     * - tls:            when set, ldap_start_tls() is run after connecting.\n     * - binddn:         the DN to bind as when searching.\n     * - bindpw:         password to use when searching LDAP.\n     * - basedn:         LDAP base.\n     * - options:        hash of LDAP options to set.\n     * - filter:         default search filter.\n     * - scope:          default search scope.\n     * - user:           configuration parameters for {@link findUserDN()},\n     *                   must contain 'uid', and 'filter' or 'objectclass'\n     *                   entries.\n     * - auto_reconnect: if true, the class will automatically\n     *                   attempt to reconnect to the LDAP server in certain\n     *                   failure conditions when attempting a search, or other\n     *                   LDAP operations.  Defaults to false.  Note that if you\n     *                   set this to true, calls to search() may block\n     *                   indefinitely if there is a catastrophic server failure.\n     * - min_backoff:    minimum reconnection delay period (in seconds).\n     * - current_backof: initial reconnection delay period (in seconds).\n     * - max_backoff:    maximum reconnection delay period (in seconds).\n     * - cache           a Horde_Cache instance for caching schema requests.\n     *\n     * @var array\n     */\n    protected $_config = array(\n        'hostspec'        => 'localhost',\n        'port'            => 389,\n        'version'         => 3,\n        'tls'             => false,\n        'binddn'          => '',\n        'bindpw'          => '',\n        'basedn'          => '',\n        'options'         => array(),\n        'filter'          => '(objectClass=*)',\n        'scope'           => 'sub',\n        'user'            => array(),\n        'auto_reconnect'  => false,\n        'min_backoff'     => 1,\n        'current_backoff' => 1,\n        'max_backoff'     => 32,\n        'cache'           => false,\n        'cachettl'        => 3600);\n\n    /**\n     * List of hosts we try to establish a connection to.\n     *\n     * @var array\n     */\n    protected $_hostList = array();\n\n    /**\n     * List of hosts that are known to be down.\n     *\n     * @var array\n     */\n    protected $_downHostList = array();\n\n    /**\n     * LDAP resource link.\n     *\n     * @var resource\n     */\n    protected $_link;\n\n    /**\n     * Schema object.\n     *\n     * @see schema()\n     * @var Horde_Ldap_Schema\n     */\n    protected $_schema;\n\n    /**\n     * Schema cache function callback.\n     *\n     * @see registerSchemaCache()\n     * @var string\n     */\n    protected $_schemaCache;\n\n    /**\n     * Cache for attribute encoding checks.\n     *\n     * @var array Hash with attribute names as key and boolean value\n     *            to determine whether they should be utf8 encoded or not.\n     */\n    protected $_schemaAttrs = array();\n\n    /**\n     * Cache for rootDSE objects\n     *\n     * Hash with requested rootDSE attr names as key and rootDSE\n     * object as value.\n     *\n     * Since the RootDSE object itself may request a rootDSE object,\n     * {@link rootDSE()} caches successful requests.\n     * Internally, Horde_Ldap needs several lookups to this object, so\n     * caching increases performance significally.\n     *\n     * @var array\n     */\n    protected $_rootDSECache = array();\n\n    /**\n     * Constructor.\n     *\n     * @see $_config\n     *\n     * @param array $config Configuration array.\n     */\n    public function __construct($config = array())\n    {\n        if (!Horde_Util::loadExtension('ldap')) {\n            throw new Horde_Ldap_Exception('No PHP LDAP extension');\n        }\n        $this->setConfig($config);\n        $this->bind();\n    }\n\n    /**\n     * Destructor.\n     */\n    public function __destruct()\n    {\n        $this->disconnect();\n    }\n\n    /**\n     * Sets the internal configuration array.\n     *\n     * @param array $config Configuration hash.\n     */\n    protected function setConfig($config)\n    {\n        /* Parameter check -- probably should raise an error here if\n         * config is not an array. */\n        if (!is_array($config)) {\n            return;\n        }\n\n        foreach ($config as $k => $v) {\n            if (isset($this->_config[$k])) {\n                $this->_config[$k] = $v;\n            }\n        }\n\n        /* Ensure the host list is an array. */\n        if (is_array($this->_config['hostspec'])) {\n            $this->_hostList = $this->_config['hostspec'];\n        } else {\n            if (strlen($this->_config['hostspec'])) {\n                $this->_hostList = array($this->_config['hostspec']);\n            } else {\n                $this->_hostList = array();\n                /* This will cause an error in _connect(), so\n                 * the user is notified about the failure. */\n            }\n        }\n\n        /* Reset the down host list, which seems like a sensible thing\n         * to do if the config is being reset for some reason. */\n        $this->_downHostList = array();\n    }\n\n    /**\n     * Bind or rebind to the LDAP server.\n     *\n     * This function binds with the given DN and password to the\n     * server. In case no connection has been made yet, it will be\n     * started and STARTTLS issued if appropiate.\n     *\n     * The internal bind configuration is not being updated, so if you\n     * call bind() without parameters, you can rebind with the\n     * credentials provided at first connecting to the server.\n     *\n     * @param string $dn       DN for binding.\n     * @param string $password Password for binding.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function bind($dn = null, $password = null)\n    {\n        /* Fetch current bind credentials. */\n        if (empty($dn)) {\n            $dn = $this->_config['binddn'];\n        }\n        if (empty($password)) {\n            $password = $this->_config['bindpw'];\n        }\n\n        /* Connect first, if we haven't so far.  This will also bind\n         * us to the server. */\n        if (!$this->_link) {\n            /* Store old credentials so we can revert them later, then\n             * overwrite config with new bind credentials. */\n            $olddn = $this->_config['binddn'];\n            $oldpw = $this->_config['bindpw'];\n\n            /* Overwrite bind credentials in config so\n             * _connect() knows about them. */\n            $this->_config['binddn'] = $dn;\n            $this->_config['bindpw'] = $password;\n\n            /* Try to connect with provided credentials. */\n            $msg = $this->_connect();\n\n            /* Reset to previous config. */\n            $this->_config['binddn'] = $olddn;\n            $this->_config['bindpw'] = $oldpw;\n            return;\n        }\n\n        /* Do the requested bind as we are asked to bind manually. */\n        if (empty($dn)) {\n            /* Anonymous bind. */\n            $msg = @ldap_bind($this->_link);\n        } else {\n            /* Privileged bind. */\n            $msg = @ldap_bind($this->_link, $dn, $password);\n        }\n        if (!$msg) {\n            throw new Horde_Ldap_Exception('Bind failed: ' . @ldap_error($this->_link),\n                                           @ldap_errno($this->_link));\n        }\n    }\n\n    /**\n     * Connects to the LDAP server.\n     *\n     * This function connects to the LDAP server specified in the\n     * configuration, binds and set up the LDAP protocol as needed.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    protected function _connect()\n    {\n        /* Connecting is briefly described in RFC1777. Basicly it works like\n         * this:\n         *  1. set up TCP connection\n         *  2. secure that connection if neccessary\n         *  3a. setVersion to tell server which version we want to speak\n         *  3b. perform bind\n         *  3c. setVersion to tell server which version we want to speak\n         *      together with a test for supported versions\n         *  4. set additional protocol options */\n\n        /* Return if we are already connected. */\n        if ($this->_link) {\n            return;\n        }\n\n        /* Connnect to the LDAP server if we are not connected.  Note that\n         * ldap_connect() may return a link value even if no connection is\n         * made.  We need to do at least one anonymous bind to ensure that a\n         * connection is actually valid.\n         *\n         * See: http://www.php.net/manual/en/function.ldap-connect.php */\n\n        /* Default error message in case all connection attempts fail but no\n         * message is set. */\n        $current_error = new Horde_Ldap_Exception('Unknown connection error');\n\n        /* Catch empty $_hostList arrays. */\n        if (!is_array($this->_hostList) || !count($this->_hostList)) {\n            throw new Horde_Ldap_Exception('No servers configured');\n        }\n\n        /* Cycle through the host list. */\n        foreach ($this->_hostList as $host) {\n            /* Ensure we have a valid string for host name. */\n            if (is_array($host)) {\n                $current_error = new Horde_Ldap_Exception('No Servers configured');\n                continue;\n            }\n\n            /* Skip this host if it is known to be down. */\n            if (in_array($host, $this->_downHostList)) {\n                continue;\n            }\n\n            /* Record the host that we are actually connecting to in case we\n             * need it later. */\n            $this->_config['hostspec'] = $host;\n\n            /* Attempt a connection. */\n            $this->_link = @ldap_connect($host, $this->_config['port']);\n            if (!$this->_link) {\n                $current_error = new Horde_Ldap_Exception('Could not connect to ' .  $host . ':' . $this->_config['port']);\n                $this->_downHostList[] = $host;\n                continue;\n            }\n\n            /* If we're supposed to use TLS, do so before we try to bind, as\n             * some strict servers only allow binding via secure\n             * connections. */\n            if ($this->_config['tls']) {\n                try {\n                    $this->startTLS();\n                } catch (Horde_Ldap_Exception $e) {\n                    $current_error           = $e;\n                    $this->_link             = false;\n                    $this->_downHostList[] = $host;\n                    continue;\n                }\n            }\n\n            /* Try to set the configured LDAP version on the connection if LDAP\n             * server needs that before binding (eg OpenLDAP).\n             * This could be necessary since RFC 1777 states that the protocol\n             * version has to be set at the bind request.\n             * We use force here which means that the test in the rootDSE is\n             * skipped; this is neccessary, because some strict LDAP servers\n             * only allow to read the LDAP rootDSE (which tells us the\n             * supported protocol versions) with authenticated clients.\n             * This may fail in which case we try again after binding.\n             * In this case, most probably the bind() or setVersion() call\n             * below will also fail, providing error messages. */\n            $version_set = false;\n            $this->setVersion(0, true);\n\n            /* Attempt to bind to the server. If we have credentials\n             * configured, we try to use them, otherwise it's an anonymous\n             * bind.\n             * As stated by RFC 1777, the bind request should be the first\n             * operation to be performed after the connection is established.\n             * This may give an protocol error if the server does not support\n             * v2 binds and the above call to setVersion() failed.\n             * If the above call failed, we try an v2 bind here and set the\n             * version afterwards (with checking to the rootDSE). */\n            try {\n                $this->bind();\n            } catch (Exception $e) {\n                /* The bind failed, discard link and save error msg.\n                 * Then record the host as down and try next one. */\n                if ($this->errorName($e->getCode()) == 'LDAP_PROTOCOL_ERROR' &&\n                    !$version_set) {\n                    /* Provide a finer grained error message if protocol error\n                     * arises because of invalid version. */\n                    $e = new Horde_Ldap_Exception($e->getMessage() . ' (could not set LDAP protocol version to ' . $this->_config['version'].')', $e->getCode());\n                }\n                $this->_link             = false;\n                $current_error           = $e;\n                $this->_downHostList[] = $host;\n                continue;\n            }\n\n            /* Set desired LDAP version if not successfully set before.\n             * Here, a check against the rootDSE is performed, so we get a\n             * error message if the server does not support the version.\n             * The rootDSE entry should tell us which LDAP versions are\n             * supported. However, some strict LDAP servers only allow\n             * bound users to read the rootDSE. */\n            if (!$version_set) {\n                try {\n                    $this->setVersion();\n                } catch (Exception $e) {\n                    $current_error           = $e;\n                    $this->_link             = false;\n                    $this->_downHostList[] = $host;\n                    continue;\n                }\n            }\n\n            /* Set LDAP parameters, now that we know we have a valid\n             * connection. */\n            if (isset($this->_config['options']) &&\n                is_array($this->_config['options']) &&\n                count($this->_config['options'])) {\n                foreach ($this->_config['options'] as $opt => $val) {\n                    try {\n                        $this->setOption($opt, $val);\n                    } catch (Exception $e) {\n                        $current_error           = $e;\n                        $this->_link             = false;\n                        $this->_downHostList[] = $host;\n                        continue 2;\n                    }\n                }\n            }\n\n            /* At this stage we have connected, bound, and set up options, so\n             * we have a known good LDAP server.  Time to go home. */\n            return;\n        }\n\n        /* All connection attempts have failed, return the last error. */\n        throw $current_error;\n    }\n\n    /**\n     * Reconnects to the LDAP server.\n     *\n     * In case the connection to the LDAP service has dropped out for some\n     * reason, this function will reconnect, and re-bind if a bind has been\n     * attempted in the past.  It is probably most useful when the server list\n     * provided to the new() or _connect() function is an array rather than a\n     * single host name, because in that case it will be able to connect to a\n     * failover or secondary server in case the primary server goes down.\n     *\n     * This method just tries to re-establish the current connection.  It will\n     * sleep for the current backoff period (seconds) before attempting the\n     * connect, and if the connection fails it will double the backoff period,\n     * but not try again.  If you want to ensure a reconnection during a\n     * transient period of server downtime then you need to call this function\n     * in a loop.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    protected function _reconnect()\n    {\n        /* Return if we are already connected. */\n        if ($this->_link) {\n            return;\n        }\n\n        /* Sleep for a backoff period in seconds. */\n        sleep($this->_config['current_backoff']);\n\n        /* Retry all available connections. */\n        $this->_downHostList = array();\n\n        try {\n            $this->_connect();\n        } catch (Horde_Ldap_Exception $e) {\n            $this->_config['current_backoff'] *= 2;\n            if ($this->_config['current_backoff'] > $this->_config['max_backoff']) {\n                $this->_config['current_backoff'] = $this->_config['max_backoff'];\n            }\n            throw $e;\n        }\n\n        /* Now we should be able to safely (re-)bind. */\n        try {\n            $this->bind();\n        } catch (Exception $e) {\n            $this->_config['current_backoff'] *= 2;\n            if ($this->_config['current_backoff'] > $this->_config['max_backoff']) {\n                $this->_config['current_backoff'] = $this->_config['max_backoff'];\n            }\n\n            /* $this->_config['hostspec'] should have had the last connected\n             * host stored in it by _connect().  Since we are unable to\n             * bind to that host we can safely assume that it is down or has\n             * some other problem. */\n            $this->_downHostList[] = $this->_config['hostspec'];\n            throw $e;\n        }\n\n        /* At this stage we have connected, bound, and set up options, so we\n         * have a known good LDAP server. Time to go home. */\n        $this->_config['current_backoff'] = $this->_config['min_backoff'];\n    }\n\n    /**\n     * Closes the LDAP connection.\n     */\n    public function disconnect()\n    {\n        @ldap_close($this->_link);\n    }\n\n    /**\n     * Starts an encrypted session.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function startTLS()\n    {\n        /* First try STARTTLS blindly, some servers don't even allow to receive\n         * the rootDSE without TLS. */\n        if (@ldap_start_tls($this->_link)) {\n            return;\n        }\n\n        /* Keep original error. */\n        $error = 'TLS not started: ' . @ldap_error($this->_link);\n        $errno = @ldap_errno($this->_link);\n\n        /* Test to see if the server supports TLS at all.\n         * This is done via testing the extensions offered by the server.\n         * The OID 1.3.6.1.4.1.1466.20037 tells whether TLS is supported. */\n        try {\n            $rootDSE = $this->rootDSE();\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to start TLS and unable to fetch rootDSE entry to see if TLS is supported: ' . $e->getMessage(), $e->getCode());\n        }\n\n        try {\n            $supported_extensions = $rootDSE->getValue('supportedExtension');\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to start TLS and unable to fetch rootDSE attribute \"supportedExtension\" to see if TLS is supoported: ' . $e->getMessage(), $e->getCode());\n        }\n\n        if (!in_array('1.3.6.1.4.1.1466.20037', $supported_extensions)) {\n            throw new Horde_Ldap_Exception('Server reports that it does not support TLS');\n        }\n\n        throw new Horde_Ldap_Exception($error, $errno);\n    }\n\n    /**\n     * Adds a new entry to the directory.\n     *\n     * This also links the entry to the connection used for the add, if it was\n     * a fresh entry.\n     *\n     * @see HordeLdap_Entry::createFresh()\n     *\n     * @param Horde_Ldap_Entry $entry An LDAP entry.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function add(Horde_Ldap_Entry $entry)\n    {\n        /* Continue attempting the add operation in a loop until we get a\n         * success, a definitive failure, or the world ends. */\n        while (true) {\n            $link = $this->getLink();\n            if ($link === false) {\n                /* We do not have a successful connection yet.  The call to\n                 * getLink() would have kept trying if we wanted one. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $entry->dn() . ' no valid LDAP connection could be found.');\n            }\n\n            if (@ldap_add($link, $entry->dn(), $entry->getValues())) {\n                /* Entry successfully added, we should update its Horde_Ldap\n                 * reference in case it is not set so far (fresh entry). */\n                try {\n                    $entry->getLDAP();\n                } catch (Horde_Ldap_Exception $e) {\n                    $entry->setLDAP($this);\n                }\n                /* Store that the entry is present inside the directory. */\n                $entry->markAsNew(false);\n                return;\n            }\n\n            /* We have a failure.  What kind?  We may be able to reconnect and\n             * try again. */\n            $error_code = @ldap_errno($link);\n            if ($this->errorName($error_code) != 'LDAP_OPERATIONS_ERROR' |\n                !$this->_config['auto_reconnect']) {\n                /* Errors other than the above are just passed back to the user\n                 * so he may react upon them. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $entry->dn() . ': ' . ldap_err2str($error_code), $error_code);\n            }\n\n            /* The server has disconnected before trying the operation.  We\n             * should try again, possibly with a different server. */\n            $this->_link = false;\n            $this->_reconnect();\n        }\n    }\n\n    /**\n     * Deletes an entry from the directory.\n     *\n     * @param string|Horde_Ldap_Entry $dn        DN string or Horde_Ldap_Entry.\n     * @param boolean                 $recursive Should we delete all children\n     *                                           recursivelx as well?\n     * @throws Horde_Ldap_Exception\n     */\n    public function delete($dn, $recursive = false)\n    {\n        if ($dn instanceof Horde_Ldap_Entry) {\n             $dn = $dn->dn();\n        }\n        if (!is_string($dn)) {\n            throw new Horde_Ldap_Exception('Parameter is not a string nor an entry object!');\n        }\n\n        /* Recursive delete searches for children and calls delete for them. */\n        if ($recursive) {\n            $result = @ldap_list($this->_link, $dn, '(objectClass=*)', array(null), 0, 0);\n            if ($result && @ldap_count_entries($this->_link, $result)) {\n                for ($subentry = @ldap_first_entry($this->_link, $result);\n                     $subentry;\n                     $subentry = @ldap_next_entry($this->_link, $subentry)) {\n                    $this->delete(@ldap_get_dn($this->_link, $subentry), true);\n                }\n            }\n        }\n\n        /* Continue the delete operation in a loop until we get a success, or a\n         * definitive failure. */\n        while (true) {\n            $link = $this->getLink();\n            if (!$link) {\n                /* We do not have a successful connection yet.  The call to\n                 * getLink() would have kept trying if we wanted one. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $dn . ' no valid LDAP connection could be found.');\n            }\n\n            $s = @ldap_delete($link, $dn);\n            if ($s) {\n                /* Entry successfully deleted. */\n                return;\n            }\n\n            /* We have a failure.  What kind? We may be able to reconnect and\n             * try again. */\n            $error_code = @ldap_errno($link);\n            if ($this->errorName($error_code) == 'LDAP_OPERATIONS_ERROR' &&\n                $this->_config['auto_reconnect']) {\n                /* The server has disconnected before trying the operation.  We\n                 * should try again, possibly with a different server. */\n                $this->_link = false;\n                $this->_reconnect();\n            } elseif ($this->errorName($error_code) == 'LDAP_NOT_ALLOWED_ON_NONLEAF') {\n                /* Subentries present, server refused to delete.\n                 * Deleting subentries is the clients responsibility, but since\n                 * the user may not know of the subentries, we do not force\n                 * that here but instead notify the developer so he may take\n                 * actions himself. */\n                throw new Horde_Ldap_Exception('Could not delete entry ' . $dn . ' because of subentries. Use the recursive parameter to delete them.', $error_code);\n            } else {\n                /* Errors other than the above catched are just passed back to\n                 * the user so he may react upon them. */\n                throw new Horde_Ldap_Exception('Could not delete entry ' . $dn . ': ' . ldap_err2str($error_code), $error_code);\n            }\n        }\n    }\n\n    /**\n     * Modifies an LDAP entry on the server.\n     *\n     * The $params argument is an array of actions and should be something like\n     * this:\n     * <code>\n     * array('add' => array('attribute1' => array('val1', 'val2'),\n     *                      'attribute2' => array('val1')),\n     *       'delete' => array('attribute1'),\n     *       'replace' => array('attribute1' => array('val1')),\n     *       'changes' => array('add' => ...,\n     *                          'replace' => ...,\n     *                          'delete' => array('attribute1', 'attribute2' => array('val1')))\n     * </code>\n     *\n     * The order of execution is as following:\n     *   1. adds from 'add' array\n     *   2. deletes from 'delete' array\n     *   3. replaces from 'replace' array\n     *   4. changes (add, replace, delete) in order of appearance\n     *\n     * The function calls the corresponding functions of an Horde_Ldap_Entry\n     * object. A detailed description of array structures can be found there.\n     *\n     * Unlike the modification methods provided by the Horde_Ldap_Entry object,\n     * this method will instantly carry out an update() after each operation,\n     * thus modifying \"directly\" on the server.\n     *\n     * @see Horde_Ldap_Entry::add()\n     * @see Horde_Ldap_Entry::delete()\n     * @see Horde_Ldap_Entry::replace()\n     *\n     * @param string|Horde_Ldap_Entry $entry DN string or Horde_Ldap_Entry.\n     * @param array                   $parms Array of changes\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function modify($entry, $parms = array())\n    {\n        if (is_string($entry)) {\n            $entry = $this->getEntry($entry);\n        }\n        if (!($entry instanceof Horde_Ldap_Entry)) {\n            throw new Horde_Ldap_Exception('Parameter is not a string nor an entry object!');\n        }\n\n        if ($unknown = array_diff(array_keys($parms), array('add', 'delete', 'replace', 'changes'))) {\n            throw new Horde_Ldap_Exception('Unknown modify action(s): ' . implode(', ', $unknown));\n        }\n\n        /* Perform changes mentioned separately. */\n        foreach (array('add', 'delete', 'replace') as $action) {\n            if (!isset($parms[$action])) {\n                continue;\n            }\n            $entry->$action($parms[$action]);\n            $entry->setLDAP($this);\n\n            /* Because the ldap_*() functions are called inside\n             * Horde_Ldap_Entry::update(), we have to trap the error codes\n             * issued from that if we want to support reconnection. */\n            while (true) {\n                try {\n                    $entry->update();\n                    break;\n                } catch (Exception $e) {\n                    /* We have a failure.  What kind?  We may be able to\n                     * reconnect and try again. */\n                    if ($this->errorName($e->getCode()) != 'LDAP_OPERATIONS_ERROR' ||\n                        !$this->_config['auto_reconnect']) {\n                        /* Errors other than the above catched are just passed\n                         * back to the user so he may react upon them. */\n                        throw new Horde_Ldap_Exception('Could not modify entry: ' . $e->getMessage());\n                    }\n                    /* The server has disconnected before trying the operation.\n                     * We should try again, possibly with a different\n                     * server. */\n                    $this->_link = false;\n                    $this->_reconnect();\n                }\n            }\n        }\n\n        if (!isset($parms['changes']) || !is_array($parms['changes'])) {\n            return;\n        }\n\n        /* Perform combined changes in 'changes' array. */\n        foreach ($parms['changes'] as $action => $value) {\n            $this->modify($entry, array($action => $value));\n        }\n    }\n\n    /**\n     * Runs an LDAP search query.\n     *\n     * $base and $filter may be ommitted. The one from config will then be\n     * used. $base is either a DN-string or an Horde_Ldap_Entry object in which\n     * case its DN will be used.\n     *\n     * $params may contain:\n     * - scope: The scope which will be used for searching, defaults to 'sub':\n     *          - base: Just one entry\n     *          - sub: The whole tree\n     *          - one: Immediately below $base\n     * - sizelimit: Limit the number of entries returned\n     *              (default: 0 = unlimited)\n     * - timelimit: Limit the time spent for searching (default: 0 = unlimited)\n     * - attrsonly: If true, the search will only return the attribute names\n     * - attributes: Array of attribute names, which the entry should contain.\n     *               It is good practice to limit this to just the ones you\n     *               need.\n     *\n     * You cannot override server side limitations to sizelimit and timelimit:\n     * You can always only lower a given limit.\n     *\n     * @todo implement search controls (sorting etc)\n     *\n     * @param string|Horde_Ldap_Entry  $base   LDAP searchbase.\n     * @param string|Horde_Ldap_Filter $filter LDAP search filter.\n     * @param array                    $params Array of options.\n     *\n     * @return Horde_Ldap_Search  The search result.\n     * @throws Horde_Ldap_Exception\n     */\n    public function search($base = null, $filter = null, $params = array())\n    {\n        if (is_null($base)) {\n            $base = $this->_config['basedn'];\n        }\n        if ($base instanceof Horde_Ldap_Entry) {\n            /* Fetch DN of entry, making searchbase relative to the entry. */\n            $base = $base->dn();\n        }\n        if (is_null($filter)) {\n            $filter = $this->_config['filter'];\n        }\n        if ($filter instanceof Horde_Ldap_Filter) {\n            /* Convert Horde_Ldap_Filter to string representation. */\n            $filter = (string)$filter;\n        }\n\n        /* Setting search parameters.  */\n        $sizelimit  = isset($params['sizelimit']) ? $params['sizelimit'] : 0;\n        $timelimit  = isset($params['timelimit']) ? $params['timelimit'] : 0;\n        $attrsonly  = isset($params['attrsonly']) ? $params['attrsonly'] : 0;\n        $attributes = isset($params['attributes']) ? $params['attributes'] : array();\n\n        /* Ensure $attributes to be an array in case only one attribute name\n         * was given as string. */\n        if (!is_array($attributes)) {\n            $attributes = array($attributes);\n        }\n\n        /* Reorganize the $attributes array index keys sometimes there are\n         * problems with not consecutive indexes. */\n        $attributes = array_values($attributes);\n\n        /* Scoping makes searches faster! */\n        $scope = isset($params['scope'])\n            ? $params['scope']\n            : $this->_config['scope'];\n\n        switch ($scope) {\n        case 'one':\n            $search_function = 'ldap_list';\n            break;\n        case 'base':\n            $search_function = 'ldap_read';\n            break;\n        default:\n            $search_function = 'ldap_search';\n        }\n\n        /* Continue attempting the search operation until we get a success or a\n         * definitive failure. */\n        while (true) {\n            $link = $this->getLink();\n            $search = @call_user_func($search_function,\n                                      $link,\n                                      $base,\n                                      $filter,\n                                      $attributes,\n                                      $attrsonly,\n                                      $sizelimit,\n                                      $timelimit);\n\n            if ($errno = @ldap_errno($link)) {\n                $err = $this->errorName($errno);\n                if ($err == 'LDAP_NO_SUCH_OBJECT' ||\n                    $err == 'LDAP_SIZELIMIT_EXCEEDED') {\n                    return new Horde_Ldap_Search($search, $this, $attributes);\n                }\n                if ($err == 'LDAP_FILTER_ERROR') {\n                    /* Bad search filter. */\n                    throw new Horde_Ldap_Exception(ldap_err2str($errno) . ' ($filter)', $errno);\n                }\n                if ($err == 'LDAP_OPERATIONS_ERROR' &&\n                    $this->_config['auto_reconnect']) {\n                    $this->_link = false;\n                    $this->_reconnect();\n                } else {\n                    $msg = \"\\nParameters:\\nBase: $base\\nFilter: $filter\\nScope: $scope\";\n                    throw new Horde_Ldap_Exception(ldap_err2str($errno) . $msg, $errno);\n                }\n            } else {\n                return new Horde_Ldap_Search($search, $this, $attributes);\n            }\n        }\n    }\n\n    /**\n     * Returns the DN of a user.\n     *\n     * The purpose is to quickly find the full DN of a user so it can be used\n     * to re-bind as this user. This method requires the 'user' configuration\n     * parameter to be set.\n     *\n     * @param string $user  The user to find.\n     *\n     * @return string  The user's full DN.\n     * @throws Horde_Ldap_Exception\n     * @throws Horde_Exception_NotFound\n     */\n    public function findUserDN($user)\n    {\n        $filter = Horde_Ldap_Filter::combine(\n            'and',\n            array(Horde_Ldap_Filter::build($this->_config['user']),\n                  Horde_Ldap_Filter::create($this->_config['user']['uid'], 'equals', $user)));\n        $search = $this->search(\n            null,\n            $filter,\n            array('attributes' => array($this->_config['user']['uid'])));\n        if (!$search->count()) {\n            throw new Horde_Exception_NotFound('DN for user ' . $user . ' not found');\n        }\n        $entry = $search->shiftEntry();\n        return $entry->currentDN();\n    }\n\n    /**\n     * Sets an LDAP option.\n     *\n     * @param string $option Option to set.\n     * @param mixed  $value  Value to set option to.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function setOption($option, $value)\n    {\n        if (!$this->_link) {\n            throw new Horde_Ldap_Exception('Could not set LDAP option: No LDAP connection');\n        }\n        if (!defined($option)) {\n            throw new Horde_Ldap_Exception('Unkown option requested');\n        }\n        if (@ldap_set_option($this->_link, constant($option), $value)) {\n            return;\n        }\n        $err = @ldap_errno($this->_link);\n        if ($err) {\n            throw new Horde_Ldap_Exception(ldap_err2str($err), $err);\n        }\n        throw new Horde_Ldap_Exception('Unknown error');\n    }\n\n    /**\n     * Returns an LDAP option value.\n     *\n     * @param string $option Option to get.\n     *\n     * @return Horde_Ldap_Error|string Horde_Ldap_Error or option value\n     * @throws Horde_Ldap_Exception\n     */\n    public function getOption($option)\n    {\n        if (!$this->_link) {\n            throw new Horde_Ldap_Exception('No LDAP connection');\n        }\n        if (!defined($option)) {\n            throw new Horde_Ldap_Exception('Unkown option requested');\n        }\n        if (@ldap_get_option($this->_link, constant($option), $value)) {\n            return $value;\n        }\n        $err = @ldap_errno($this->_link);\n        if ($err) {\n            throw new Horde_Ldap_Exception(ldap_err2str($err), $err);\n        }\n        throw new Horde_Ldap_Exception('Unknown error');\n    }\n\n    /**\n     * Returns the LDAP protocol version that is used on the connection.\n     *\n     * A lot of LDAP functionality is defined by what protocol version\n     * the LDAP server speaks. This might be 2 or 3.\n     *\n     * @return integer  The protocol version.\n     */\n    public function getVersion()\n    {\n        if ($this->_link) {\n            $version = $this->getOption('LDAP_OPT_PROTOCOL_VERSION');\n        } else {\n            $version = $this->_config['version'];\n        }\n        return $version;\n    }\n\n    /**\n     * Sets the LDAP protocol version that is used on the connection.\n     *\n     * @todo Checking via the rootDSE takes much time - why? fetching\n     *       and instanciation is quick!\n     *\n     * @param integer $version LDAP version that should be used.\n     * @param boolean $force   If set to true, the check against the rootDSE\n     *                         will be skipped.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function setVersion($version = 0, $force = false)\n    {\n        if (!$version) {\n            $version = $this->_config['version'];\n        }\n\n        /* Check to see if the server supports this version first.\n         *\n         * TODO: Why is this so horribly slow? $this->rootDSE() is very fast,\n         * as well as Horde_Ldap_RootDse(). Seems like a problem at copying the\n         * object inside PHP??  Additionally, this is not always\n         * reproducable... */\n        if (!$force) {\n            try {\n                $rootDSE = $this->rootDSE();\n                $supported_versions = $rootDSE->getValue('supportedLDAPVersion');\n                if (is_string($supported_versions)) {\n                    $supported_versions = array($supported_versions);\n                }\n                $check_ok = in_array($version, $supported_versions);\n            } catch (Horde_Ldap_Exception $e) {\n                /* If we don't get a root DSE, this is probably a v2 server. */\n                $check_ok = $version < 3;\n            }\n        }\n        $check_ok = true;\n\n        if ($force || $check_ok) {\n            return $this->setOption('LDAP_OPT_PROTOCOL_VERSION', $version);\n        }\n        throw new Horde_Ldap_Exception('LDAP Server does not support protocol version ' . $version);\n    }\n\n\n    /**\n     * Returns whether a DN exists in the directory.\n     *\n     * @param string|Horde_Ldap_Entry $dn The DN of the object to test.\n     *\n     * @return boolean  True if the DN exists.\n     * @throws Horde_Ldap_Exception\n     */\n    public function exists($dn)\n    {\n        if ($dn instanceof Horde_Ldap_Entry) {\n             $dn = $dn->dn();\n        }\n        if (!is_string($dn)) {\n            throw new Horde_Ldap_Exception('Parameter $dn is not a string nor an entry object!');\n        }\n\n        /* Make dn relative to parent. */\n        $base = Horde_Ldap_Util::explodeDN($dn, array('casefold' => 'none', 'reverse' => false, 'onlyvalues' => false));\n        $entry_rdn = array_shift($base);\n        $base = Horde_Ldap_Util::canonicalDN($base);\n\n        $result = @ldap_list($this->_link, $base, $entry_rdn, array(), 1, 1);\n        if (@ldap_count_entries($this->_link, $result)) {\n            return true;\n        }\n        if ($this->errorName(@ldap_errno($this->_link)) == 'LDAP_NO_SUCH_OBJECT') {\n            return false;\n        }\n        if (@ldap_errno($this->_link)) {\n            throw new Horde_Ldap_Exception(@ldap_error($this->_link), @ldap_errno($this->_link));\n        }\n        return false;\n    }\n\n\n    /**\n     * Returns a specific entry based on the DN.\n     *\n     * @todo Maybe a check against the schema should be done to be\n     *       sure the attribute type exists.\n     *\n     * @param string $dn   DN of the entry that should be fetched.\n     * @param array  $attributes Array of Attributes to select. If ommitted, all\n     *                     attributes are fetched.\n     *\n     * @return Horde_Ldap_Entry  A Horde_Ldap_Entry object.\n     * @throws Horde_Ldap_Exception\n     * @throws Horde_Exception_NotFound\n     */\n    public function getEntry($dn, $attributes = array())\n    {\n        if (!is_array($attributes)) {\n            $attributes = array($attributes);\n        }\n        $result = $this->search($dn, '(objectClass=*)',\n                                array('scope' => 'base', 'attributes' => $attributes));\n        if (!$result->count()) {\n            throw new Horde_Exception_NotFound(sprintf('Could not fetch entry %s: no entry found', $dn));\n        }\n        $entry = $result->shiftEntry();\n        if (!$entry) {\n            throw new Horde_Ldap_Exception('Could not fetch entry (error retrieving entry from search result)');\n        }\n        return $entry;\n    }\n\n    /**\n     * Renames or moves an entry.\n     *\n     * This method will instantly carry out an update() after the\n     * move, so the entry is moved instantly.\n     *\n     * You can pass an optional Horde_Ldap object. In this case, a\n     * cross directory move will be performed which deletes the entry\n     * in the source (THIS) directory and adds it in the directory\n     * $target_ldap.\n     *\n     * A cross directory move will switch the entry's internal LDAP\n     * reference so updates to the entry will go to the new directory.\n     *\n     * If you want to do a cross directory move, you need to pass an\n     * Horde_Ldap_Entry object, otherwise the attributes will be\n     * empty.\n     *\n     * @param string|Horde_Ldap_Entry $entry       An LDAP entry.\n     * @param string                  $newdn       The new location.\n     * @param Horde_Ldap              $target_ldap Target directory for cross\n     *                                             server move.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function move($entry, $newdn, $target_ldap = null)\n    {\n        if (is_string($entry)) {\n            if ($target_ldap && $target_ldap !== $this) {\n                throw new Horde_Ldap_Exception('Unable to perform cross directory move: operation requires a Horde_Ldap_Entry object');\n            }\n            $entry = $this->getEntry($entry);\n        }\n        if (!$entry instanceof Horde_Ldap_Entry) {\n            throw new Horde_Ldap_Exception('Parameter $entry is expected to be a Horde_Ldap_Entry object! (If DN was passed, conversion failed)');\n        }\n        if ($target_ldap && !($target_ldap instanceof Horde_Ldap)) {\n            throw new Horde_Ldap_Exception('Parameter $target_ldap is expected to be a Horde_Ldap object!');\n        }\n\n        if (!$target_ldap || $target_ldap === $this) {\n            /* Local move. */\n            $entry->dn($newdn);\n            $entry->setLDAP($this);\n            $entry->update();\n            return;\n        }\n\n        /* Cross directory move. */\n        if ($target_ldap->exists($newdn)) {\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: entry does exist in target directory');\n        }\n        $entry->dn($newdn);\n        try {\n            $target_ldap->add($entry);\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: ' . $e->getMessage() . ' in target directory');\n        }\n\n        try {\n            $this->delete($entry->currentDN());\n        } catch (Exception $e) {\n            try {\n                $add_error_string = '';\n                /* Undo add. */\n                $target_ldap->delete($entry);\n            } catch (Exception $e) {\n                $add_error_string = ' Additionally, the deletion (undo add) of $entry in target directory failed.';\n            }\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: ' . $e->getMessage() . ' in source directory.' . $add_error_string);\n        }\n        $entry->setLDAP($target_ldap);\n    }\n\n    /**\n     * Copies an entry to a new location.\n     *\n     * The entry will be immediately copied. Only attributes you have\n     * selected will be copied.\n     *\n     * @param Horde_Ldap_Entry $entry An LDAP entry.\n     * @param string           $newdn New FQF-DN of the entry.\n     *\n     * @return Horde_Ldap_Entry  The copied entry.\n     * @throws Horde_Ldap_Exception\n     */\n    public function copy($entry, $newdn)\n    {\n        if (!$entry instanceof Horde_Ldap_Entry) {\n            throw new Horde_Ldap_Exception('Parameter $entry is expected to be a Horde_Ldap_Entry object');\n        }\n\n        $newentry = Horde_Ldap_Entry::createFresh($newdn, $entry->getValues());\n        $this->add($newentry);\n\n        return $newentry;\n    }\n\n\n    /**\n     * Returns the string for an LDAP errorcode.\n     *\n     * Made to be able to make better errorhandling.  Function based\n     * on DB::errorMessage().\n     *\n     * Hint: The best description of the errorcodes is found here:\n     * http://www.directory-info.com/Ldap/LDAPErrorCodes.html\n     *\n     * @param integer $errorcode An error code.\n     *\n     * @return string The description for the error.\n     */\n    public static function errorName($errorcode)\n    {\n        $errorMessages = array(\n            0x00 => 'LDAP_SUCCESS',\n            0x01 => 'LDAP_OPERATIONS_ERROR',\n            0x02 => 'LDAP_PROTOCOL_ERROR',\n            0x03 => 'LDAP_TIMELIMIT_EXCEEDED',\n            0x04 => 'LDAP_SIZELIMIT_EXCEEDED',\n            0x05 => 'LDAP_COMPARE_FALSE',\n            0x06 => 'LDAP_COMPARE_TRUE',\n            0x07 => 'LDAP_AUTH_METHOD_NOT_SUPPORTED',\n            0x08 => 'LDAP_STRONG_AUTH_REQUIRED',\n            0x09 => 'LDAP_PARTIAL_RESULTS',\n            0x0a => 'LDAP_REFERRAL',\n            0x0b => 'LDAP_ADMINLIMIT_EXCEEDED',\n            0x0c => 'LDAP_UNAVAILABLE_CRITICAL_EXTENSION',\n            0x0d => 'LDAP_CONFIDENTIALITY_REQUIRED',\n            0x0e => 'LDAP_SASL_BIND_INPROGRESS',\n            0x10 => 'LDAP_NO_SUCH_ATTRIBUTE',\n            0x11 => 'LDAP_UNDEFINED_TYPE',\n            0x12 => 'LDAP_INAPPROPRIATE_MATCHING',\n            0x13 => 'LDAP_CONSTRAINT_VIOLATION',\n            0x14 => 'LDAP_TYPE_OR_VALUE_EXISTS',\n            0x15 => 'LDAP_INVALID_SYNTAX',\n            0x20 => 'LDAP_NO_SUCH_OBJECT',\n            0x21 => 'LDAP_ALIAS_PROBLEM',\n            0x22 => 'LDAP_INVALID_DN_SYNTAX',\n            0x23 => 'LDAP_IS_LEAF',\n            0x24 => 'LDAP_ALIAS_DEREF_PROBLEM',\n            0x30 => 'LDAP_INAPPROPRIATE_AUTH',\n            0x31 => 'LDAP_INVALID_CREDENTIALS',\n            0x32 => 'LDAP_INSUFFICIENT_ACCESS',\n            0x33 => 'LDAP_BUSY',\n            0x34 => 'LDAP_UNAVAILABLE',\n            0x35 => 'LDAP_UNWILLING_TO_PERFORM',\n            0x36 => 'LDAP_LOOP_DETECT',\n            0x3C => 'LDAP_SORT_CONTROL_MISSING',\n            0x3D => 'LDAP_INDEX_RANGE_ERROR',\n            0x40 => 'LDAP_NAMING_VIOLATION',\n            0x41 => 'LDAP_OBJECT_CLASS_VIOLATION',\n            0x42 => 'LDAP_NOT_ALLOWED_ON_NONLEAF',\n            0x43 => 'LDAP_NOT_ALLOWED_ON_RDN',\n            0x44 => 'LDAP_ALREADY_EXISTS',\n            0x45 => 'LDAP_NO_OBJECT_CLASS_MODS',\n            0x46 => 'LDAP_RESULTS_TOO_LARGE',\n            0x47 => 'LDAP_AFFECTS_MULTIPLE_DSAS',\n            0x50 => 'LDAP_OTHER',\n            0x51 => 'LDAP_SERVER_DOWN',\n            0x52 => 'LDAP_LOCAL_ERROR',\n            0x53 => 'LDAP_ENCODING_ERROR',\n            0x54 => 'LDAP_DECODING_ERROR',\n            0x55 => 'LDAP_TIMEOUT',\n            0x56 => 'LDAP_AUTH_UNKNOWN',\n            0x57 => 'LDAP_FILTER_ERROR',\n            0x58 => 'LDAP_USER_CANCELLED',\n            0x59 => 'LDAP_PARAM_ERROR',\n            0x5a => 'LDAP_NO_MEMORY',\n            0x5b => 'LDAP_CONNECT_ERROR',\n            0x5c => 'LDAP_NOT_SUPPORTED',\n            0x5d => 'LDAP_CONTROL_NOT_FOUND',\n            0x5e => 'LDAP_NO_RESULTS_RETURNED',\n            0x5f => 'LDAP_MORE_RESULTS_TO_RETURN',\n            0x60 => 'LDAP_CLIENT_LOOP',\n            0x61 => 'LDAP_REFERRAL_LIMIT_EXCEEDED',\n            1000 => 'Unknown Error');\n\n         return isset($errorMessages[$errorcode]) ?\n            $errorMessages[$errorcode] :\n            'Unknown Error (' . $errorcode . ')';\n    }\n\n    /**\n     * Returns a rootDSE object\n     *\n     * This either fetches a fresh rootDSE object or returns it from\n     * the internal cache for performance reasons, if possible.\n     *\n     * @param array $attrs Array of attributes to search for.\n     *\n     * @return Horde_Ldap_RootDse Horde_Ldap_RootDse object\n     * @throws Horde_Ldap_Exception\n     */\n    public function rootDSE(array $attrs = array())\n    {\n        $attrs_signature = serialize($attrs);\n\n        /* See if we need to fetch a fresh object, or if we already\n         * requested this object with the same attributes. */\n        if (!isset($this->_rootDSECache[$attrs_signature])) {\n            $this->_rootDSECache[$attrs_signature] = new Horde_Ldap_RootDse($this, $attrs);\n        }\n\n        return $this->_rootDSECache[$attrs_signature];\n    }\n\n    /**\n     * Returns a schema object\n     *\n     * @param string $dn Subschema entry dn.\n     *\n     * @return Horde_Ldap_Schema  Horde_Ldap_Schema object\n     * @throws Horde_Ldap_Exception\n     */\n    public function schema($dn = null)\n    {\n        /* If a schema caching object is registered, we use that to fetch a\n         * schema object. */\n        $key = 'Horde_Ldap_Schema_' . md5(serialize(array($this->_config['hostspec'], $this->_config['port'], $dn)));\n        if (!$this->_schema && $this->_config['cache']) {\n            $schema = $this->_config['cache']->get($key, $this->_config['cachettl']);\n            if ($schema) {\n                $this->_schema = @unserialize($schema);\n            }\n        }\n\n        /* Fetch schema, if not tried before and no cached version available.\n         * If we are already fetching the schema, we will skip fetching. */\n        if (!$this->_schema) {\n            /* Store a temporary error message so subsequent calls to schema()\n             * can detect that we are fetching the schema already. Otherwise we\n             * will get an infinite loop at Horde_Ldap_Schema. */\n            $this->_schema = new Horde_Ldap_Exception('Schema not initialized');\n            $this->_schema = new Horde_Ldap_Schema($this, $dn);\n\n            /* If schema caching is active, advise the cache to store the\n             * schema. */\n            if ($this->_config['cache']) {\n                $this->_config['cache']->set($key, serialize($this->_schema), $this->_config['cachettl']);\n            }\n        }\n\n        if ($this->_schema instanceof Horde_Ldap_Exception) {\n            throw $this->_schema;\n        }\n\n        return $this->_schema;\n    }\n\n    /**\n     * Checks if PHP's LDAP extension is loaded.\n     *\n     * If it is not loaded, it tries to load it manually using PHP's dl().\n     * It knows both windows-dll and *nix-so.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public static function checkLDAPExtension()\n    {\n        if (!extension_loaded('ldap') && !@dl('ldap.' . PHP_SHLIB_SUFFIX)) {\n            throw new Horde_Ldap_Exception('Unable to locate PHP LDAP extension. Please install it before using the Horde_Ldap package.');\n        }\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Encodes given attributes to UTF8 if needed by schema.\n     *\n     * This function takes attributes in an array and then checks\n     * against the schema if they need UTF8 encoding. If that is the\n     * case, they will be encoded. An encoded array will be returned\n     * and can be used for adding or modifying.\n     *\n     * $attributes is expected to be an array with keys describing\n     * the attribute names and the values as the value of this attribute:\n     * <code>$attributes = array('cn' => 'foo', 'attr2' => array('mv1', 'mv2'));</code>\n     *\n     * @param array $attributes An array of attributes.\n     *\n     * @return array|Horde_Ldap_Error An array of UTF8 encoded attributes or an error.\n     */\n    public function utf8Encode($attributes)\n    {\n        return $this->utf8($attributes, 'utf8_encode');\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Decodes the given attribute values if needed by schema\n     *\n     * $attributes is expected to be an array with keys describing\n     * the attribute names and the values as the value of this attribute:\n     * <code>$attributes = array('cn' => 'foo', 'attr2' => array('mv1', 'mv2'));</code>\n     *\n     * @param array $attributes Array of attributes\n     *\n     * @access public\n     * @see utf8Encode()\n     * @return array|Horde_Ldap_Error Array with decoded attribute values or Error\n     */\n    public function utf8Decode($attributes)\n    {\n        return $this->utf8($attributes, 'utf8_decode');\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Encodes or decodes attribute values if needed\n     *\n     * @param array $attributes Array of attributes\n     * @param array $function   Function to apply to attribute values\n     *\n     * @access protected\n     * @return array Array of attributes with function applied to values.\n     */\n    protected function utf8($attributes, $function)\n    {\n        if (!is_array($attributes) || array_key_exists(0, $attributes)) {\n            throw new Horde_Ldap_Exception('Parameter $attributes is expected to be an associative array');\n        }\n\n        if (!$this->_schema) {\n            $this->_schema = $this->schema();\n        }\n\n        if (!$this->_link || !function_exists($function)) {\n            return $attributes;\n        }\n\n        if (is_array($attributes) && count($attributes) > 0) {\n\n            foreach ($attributes as $k => $v) {\n\n                if (!isset($this->_schemaAttrs[$k])) {\n\n                    try {\n                        $attr = $this->_schema->get('attribute', $k);\n                    } catch (Exception $e) {\n                        continue;\n                    }\n\n                    if (false !== strpos($attr['syntax'], '1.3.6.1.4.1.1466.115.121.1.15')) {\n                        $encode = true;\n                    } else {\n                        $encode = false;\n                    }\n                    $this->_schemaAttrs[$k] = $encode;\n\n                } else {\n                    $encode = $this->_schemaAttrs[$k];\n                }\n\n                if ($encode) {\n                    if (is_array($v)) {\n                        foreach ($v as $ak => $av) {\n                            $v[$ak] = call_user_func($function, $av);\n                        }\n                    } else {\n                        $v = call_user_func($function, $v);\n                    }\n                }\n                $attributes[$k] = $v;\n            }\n        }\n        return $attributes;\n    }\n\n    /**\n     * Returns the LDAP link resource.\n     *\n     * It will loop attempting to re-establish the connection if the\n     * connection attempt fails and auto_reconnect has been turned on\n     * (see the _config array documentation).\n     *\n     * @return resource LDAP link.\n     */\n    public function getLink()\n    {\n        if ($this->_config['auto_reconnect']) {\n            while (true) {\n                /* Return the link handle if we are already connected.\n                 * Otherwise try to reconnect. */\n                if ($this->_link) {\n                    return $this->_link;\n                }\n                $this->_reconnect();\n            }\n        }\n        return $this->_link;\n    }\n\n    /**\n     * Builds an LDAP search filter fragment.\n     *\n     * @param string $lhs    The attribute to test.\n     * @param string $op     The operator.\n     * @param string $rhs    The comparison value.\n     * @param array $params  Any additional parameters for the operator.\n     *\n     * @return string  The LDAP search fragment.\n     */\n    public static function buildClause($lhs, $op, $rhs, $params = array())\n    {\n        switch ($op) {\n        case 'LIKE':\n            if (empty($rhs)) {\n                return '(' . $lhs . '=*)';\n            }\n            if (!empty($params['begin'])) {\n                return sprintf('(|(%s=%s*)(%s=* %s*))', $lhs, self::quote($rhs), $lhs, self::quote($rhs));\n            }\n            if (!empty($params['approximate'])) {\n                return sprintf('(%s~=%s)', $lhs, self::quote($rhs));\n            }\n            return sprintf('(%s=*%s*)', $lhs, self::quote($rhs));\n\n        default:\n            return sprintf('(%s%s%s)', $lhs, $op, self::quote($rhs));\n        }\n    }\n\n\n    /**\n     * Escapes characters with special meaning in LDAP searches.\n     *\n     * @param string $clause  The string to escape.\n     *\n     * @return string  The escaped string.\n     */\n    public static function quote($clause)\n    {\n        return str_replace(array('\\\\',   '(',  ')',  '*',  \"\\0\"),\n                           array('\\\\5c', '\\(', '\\)', '\\*', \"\\\\00\"),\n                           $clause);\n    }\n\n    /**\n     * Takes an array of DN elements and properly quotes it according to RFC\n     * 1485.\n     *\n     * @param array $parts  An array of tuples containing the attribute\n     *                      name and that attribute's value which make\n     *                      up the DN. Example:\n     *                      <code>\n     *                      $parts = array(0 => array('cn', 'John Smith'),\n     *                                     1 => array('dc', 'example'),\n     *                                     2 => array('dc', 'com'));\n     *                      </code>\n     *\n     * @return string  The properly quoted string DN.\n     */\n    public static function quoteDN($parts)\n    {\n        $dn = '';\n        $count = count($parts);\n        for ($i = 0; $i < $count; $i++) {\n            if ($i > 0) {\n                $dn .= ',';\n            }\n            $dn .= $parts[$i][0] . '=';\n\n            // See if we need to quote the value.\n            if (preg_match('/^\\s|\\s$|\\s\\s|[,+=\"\\r\\n<>#;]/', $parts[$i][1])) {\n                $dn .= '\"' . str_replace('\"', '\\\\\"', $parts[$i][1]) . '\"';\n            } else {\n                $dn .= $parts[$i][1];\n            }\n        }\n\n        return $dn;\n    }\n}\n", "<?php\n\nrequire_once __DIR__ . '/TestBase.php';\n\n/**\n * Copyright 2010-2014 Horde LLC (http://www.horde.org/)\n *\n * @package    Ldap\n * @subpackage UnitTests\n * @author     Jan Schneider <jan@horde.org>\n * @license    http://www.gnu.org/licenses/lgpl-3.0.html LGPL-3.0\n */\nclass Horde_Ldap_LdapTest extends Horde_Ldap_TestBase\n{\n    public static function tearDownAfterClass()\n    {\n        if (!self::$ldapcfg) {\n            return;\n        }\n\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $clean = array('cn=Horde_Ldap_TestEntry,',\n                       'ou=Horde_Ldap_Test_subdelete,',\n                       'ou=Horde_Ldap_Test_modify,',\n                       'ou=Horde_Ldap_Test_search1,',\n                       'ou=Horde_Ldap_Test_search2,',\n                       'ou=Horde_Ldap_Test_exists,',\n                       'ou=Horde_Ldap_Test_getEntry,',\n                       'ou=Horde_Ldap_Test_move,',\n                       'ou=Horde_Ldap_Test_pool,',\n                       'ou=Horde_Ldap_Test_tgt,');\n        foreach ($clean as $dn) {\n            try {\n                $ldap->delete($dn . self::$ldapcfg['server']['basedn'], true);\n            } catch (Exception $e) {}\n        }\n    }\n\n    /**\n     * Tests if the server can connect and bind correctly.\n     */\n    public function testConnectAndPrivilegedBind()\n    {\n        // This connect is supposed to fail.\n        $lcfg = array('hostspec' => 'nonexistant.ldap.horde.org');\n        try {\n            $ldap = new Horde_Ldap($lcfg);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Failing with multiple hosts.\n        $lcfg = array('hostspec' => array('nonexistant1.ldap.horde.org',\n                                          'nonexistant2.ldap.horde.org'));\n        try {\n            $ldap = new Horde_Ldap($lcfg);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Simple working connect and privileged bind.\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Working connect and privileged bind with first host down.\n        $lcfg = array('hostspec' => array('nonexistant.ldap.horde.org',\n                                          self::$ldapcfg['server']['hostspec']),\n                      'port'      => self::$ldapcfg['server']['port'],\n                      'binddn'    => self::$ldapcfg['server']['binddn'],\n                      'bindpw'    => self::$ldapcfg['server']['bindpw']);\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Tests if the server can connect and bind anonymously, if supported.\n     */\n    public function testConnectAndAnonymousBind()\n    {\n        if (!self::$ldapcfg['capability']['anonymous']) {\n            $this->markTestSkipped('Server does not support anonymous bind');\n        }\n\n        // Simple working connect and anonymous bind.\n        $lcfg = array('hostspec' => self::$ldapcfg['server']['hostspec'],\n                      'port'     => self::$ldapcfg['server']['port']);\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Tests startTLS() if server supports it.\n     */\n    public function testStartTLS()\n    {\n        if (!self::$ldapcfg['capability']['tls']) {\n            $this->markTestSkipped('Server does not support TLS');\n        }\n\n        // Simple working connect and privileged bind.\n        $lcfg = array('starttls' => true) + self::$ldapcfg['server'];\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Test if adding and deleting a fresh entry works.\n     */\n    public function testAdd()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Adding a fresh entry.\n        $cn = 'Horde_Ldap_TestEntry';\n        $dn = 'cn=' . $cn . ',' . self::$ldapcfg['server']['basedn'];\n        $fresh_entry = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'person'),\n                  'cn'          => $cn,\n                  'sn'          => 'TestEntry'));\n        $this->assertInstanceOf('Horde_Ldap_Entry', $fresh_entry);\n        $ldap->add($fresh_entry);\n\n        // Deleting this entry.\n        $ldap->delete($fresh_entry);\n    }\n\n    /**\n     * Basic deletion is tested in testAdd(), so here we just test if\n     * advanced deletion tasks work properly.\n     */\n    public function testDelete()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some parameter checks.\n        try {\n            $ldap->delete(1234);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n        try {\n            $ldap->delete($ldap);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // In order to test subtree deletion, we need some little tree\n        // which we need to establish first.\n        $base   = self::$ldapcfg['server']['basedn'];\n        $testdn = 'ou=Horde_Ldap_Test_subdelete,' . $base;\n\n        $ou = Horde_Ldap_Entry::createFresh(\n            $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_subdelete'));\n        $ou_1 = Horde_Ldap_Entry::createFresh(\n            'ou=test1,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test1'));\n        $ou_1_l1 = Horde_Ldap_Entry::createFresh(\n            'l=subtest,ou=test1,' . $testdn,\n            array('objectClass' => array('top', 'locality'),\n                  'l' => 'test1'));\n        $ou_2 = Horde_Ldap_Entry::createFresh(\n            'ou=test2,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test2'));\n        $ou_3 = Horde_Ldap_Entry::createFresh(\n            'ou=test3,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test3'));\n        $ldap->add($ou);\n        $ldap->add($ou_1);\n        $ldap->add($ou_1_l1);\n        $ldap->add($ou_2);\n        $ldap->add($ou_3);\n        $this->assertTrue($ldap->exists($ou->dn()));\n        $this->assertTrue($ldap->exists($ou_1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_2->dn()));\n        $this->assertTrue($ldap->exists($ou_3->dn()));\n        // Tree established now. We can run some tests now :D\n\n        // Try to delete some non existent entry inside that subtree (fails).\n        try {\n            $ldap->delete('cn=not_existent,ou=test1,' . $testdn);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {\n            $this->assertEquals('LDAP_NO_SUCH_OBJECT', Horde_Ldap::errorName($e->getCode()));\n        }\n\n        // Try to delete main test ou without recursive set (fails too).\n        try {\n            $ldap->delete($testdn);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {\n            $this->assertEquals('LDAP_NOT_ALLOWED_ON_NONLEAF', Horde_Ldap::errorName($e->getCode()));\n        }\n\n        // Retry with subtree delete, this should work.\n        $ldap->delete($testdn, true);\n\n        // The DN is not allowed to exist anymore.\n        $this->assertFalse($ldap->exists($testdn));\n    }\n\n    /**\n     * Test modify().\n     */\n    public function testModify()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // We need a test entry.\n        $local_entry = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_modify,' . self::$ldapcfg['server']['basedn'],\n            array('objectClass'     => array('top', 'organizationalUnit'),\n                  'ou'              => 'Horde_Ldap_Test_modify',\n                  'street'          => 'Beniroad',\n                  'telephoneNumber' => array('1234', '5678'),\n                  'postalcode'      => '12345',\n                  'postalAddress'   => 'someAddress',\n                  'st'              => array('State 1', 'State 2')));\n        $ldap->add($local_entry);\n        $this->assertTrue($ldap->exists($local_entry->dn()));\n\n        // Test invalid actions.\n        try {\n            $ldap->modify($local_entry, array('foo' => 'bar'));\n            $this->fail('Expected exception when passing invalid actions to modify().');\n        } catch (Horde_Ldap_Exception $e) {\n        }\n\n        // Prepare some changes.\n        $changes = array(\n            'add' => array(\n                'businessCategory' => array('foocat', 'barcat'),\n                'description' => 'testval'\n            ),\n            'delete' => array('postalAddress'),\n            'replace' => array('telephoneNumber' => array('345', '567')),\n            'changes' => array(\n                'replace' => array('street' => 'Highway to Hell'),\n                'add' => array('l' => 'someLocality'),\n                'delete' => array(\n                    'postalcode',\n                    'st' => array('State 1'))));\n\n        // Perform those changes.\n        $ldap->modify($local_entry, $changes);\n\n        // Verify correct attribute changes.\n        $actual_entry = $ldap->getEntry($local_entry->dn(),\n                                        array('objectClass', 'ou',\n                                              'postalAddress', 'street',\n                                              'telephoneNumber', 'postalcode',\n                                              'st', 'l', 'businessCategory',\n                                              'description'));\n        $this->assertInstanceOf('Horde_Ldap_Entry', $actual_entry);\n        $expected_attributes = array(\n            'objectClass'      => array('top', 'organizationalUnit'),\n            'ou'               => 'Horde_Ldap_Test_modify',\n            'street'           => 'Highway to Hell',\n            'l'                => 'someLocality',\n            'telephoneNumber'  => array('345', '567'),\n            'businessCategory' => array('foocat', 'barcat'),\n            'description'      => 'testval',\n            'st'               => 'State 2'\n        );\n\n        $local_attributes  = $local_entry->getValues();\n        $actual_attributes = $actual_entry->getValues();\n\n        // To enable easy check, we need to sort the values of the remaining\n        // multival attributes as well as the attribute names.\n        ksort($expected_attributes);\n        ksort($local_attributes);\n        ksort($actual_attributes);\n        sort($expected_attributes['businessCategory']);\n        sort($local_attributes['businessCategory']);\n        sort($actual_attributes['businessCategory']);\n\n        // The attributes must match the expected values.  Both, the entry\n        // inside the directory and our local copy must reflect the same\n        // values.\n        $this->assertEquals($expected_attributes, $actual_attributes, 'The directory entries attributes are not OK!');\n        $this->assertEquals($expected_attributes, $local_attributes, 'The local entries attributes are not OK!');\n    }\n\n    /**\n     * Test search().\n     */\n    public function testSearch()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some testdata, so we can test sizelimit.\n        $base = self::$ldapcfg['server']['basedn'];\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search1,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search1'));\n        $ou1_1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search1_1,' . $ou1->dn(),\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search2'));\n        $ou2 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search2,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search2'));\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($ou1->dn()));\n        $ldap->add($ou1_1);\n        $this->assertTrue($ldap->exists($ou1_1->dn()));\n        $ldap->add($ou2);\n        $this->assertTrue($ldap->exists($ou2->dn()));\n\n\n        // Search for test filter, should at least return our two test entries.\n        $res = $ldap->search(null, '(ou=Horde_Ldap*)',\n                             array('attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Same, but with Horde_Ldap_Filter object.\n        $filtero = Horde_Ldap_Filter::create('ou', 'begins', 'Horde_Ldap');\n        $this->assertInstanceOf('Horde_Ldap_Filter', $filtero);\n        $res = $ldap->search(null, $filtero,\n                             array('attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Search using default filter for base-onelevel scope, should at least\n        // return our two test entries.\n        $res = $ldap->search(null, null,\n                             array('scope' => 'one', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Base-search using custom base (string), should only return the test\n        // entry $ou1 and not the entry below it.\n        $res = $ldap->search($ou1->dn(), null,\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n\n        // Search using custom base, this time using an entry object.  This\n        // tests if passing an entry object as base works, should only return\n        // the test entry $ou1.\n        $res = $ldap->search($ou1, '(ou=*)',\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n\n        // Search using default filter for base-onelevel scope with sizelimit,\n        // should of course return more than one entry, but not more than\n        // sizelimit\n        $res = $ldap->search(\n            null, null,\n            array('scope' => 'one', 'sizelimit' => 1, 'attributes' => '1.1')\n        );\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n        // Sizelimit should be exceeded now.\n        $this->assertTrue($res->sizeLimitExceeded());\n\n        // Bad filter.\n        try {\n            $res = $ldap->search(null, 'somebadfilter',\n                                 array('attributes' => '1.1'));\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Bad base.\n        try {\n            $res = $ldap->search('badbase', null,\n                                 array('attributes' => '1.1'));\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Nullresult.\n        $res = $ldap->search(null, '(cn=nevermatching_filter)',\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(0, $res->count());\n    }\n\n    /**\n     * Test exists().\n     */\n    public function testExists()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        $dn = 'ou=Horde_Ldap_Test_exists,' . self::$ldapcfg['server']['basedn'];\n\n        // Testing not existing DN.\n        $this->assertFalse($ldap->exists($dn));\n\n        // Passing an entry object (should work). It should return false,\n        // because we didn't add the test entry yet.\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search1'));\n        $this->assertFalse($ldap->exists($ou1));\n\n        // Testing not existing DN.\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($dn));\n\n        // Passing an float instead of a string.\n        try {\n            $ldap->exists(1.234);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Test getEntry().\n     */\n    public function testGetEntry()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $dn = 'ou=Horde_Ldap_Test_getEntry,' . self::$ldapcfg['server']['basedn'];\n        $entry = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_getEntry'));\n        $ldap->add($entry);\n\n        // Existing DN.\n        $this->assertInstanceOf('Horde_Ldap_Entry', $ldap->getEntry($dn));\n\n        // Not existing DN.\n        try {\n            $ldap->getEntry('cn=notexistent,' . self::$ldapcfg['server']['basedn']);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Exception_NotFound $e) {}\n    }\n\n    /**\n     * Test move().\n     */\n    public function testMove()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // For Moving tests, we need some little tree again.\n        $base   = self::$ldapcfg['server']['basedn'];\n        $testdn = 'ou=Horde_Ldap_Test_move,' . $base;\n\n        $ou = Horde_Ldap_Entry::createFresh(\n            $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_move'));\n        $ou_1 = Horde_Ldap_Entry::createFresh(\n            'ou=source,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'source'));\n        $ou_1_l1 = Horde_Ldap_Entry::createFresh(\n            'l=moveitem,ou=source,' . $testdn,\n            array('objectClass' => array('top','locality'),\n                  'l' => 'moveitem',\n                  'description' => 'movetest'));\n        $ou_2 = Horde_Ldap_Entry::createFresh(\n            'ou=target,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'target'));\n        $ou_3 = Horde_Ldap_Entry::createFresh(\n            'ou=target_otherdir,' . $testdn,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'target_otherdir'));\n        $ldap->add($ou);\n        $ldap->add($ou_1);\n        $ldap->add($ou_1_l1);\n        $ldap->add($ou_2);\n        $ldap->add($ou_3);\n        $this->assertTrue($ldap->exists($ou->dn()));\n        $this->assertTrue($ldap->exists($ou_1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_2->dn()));\n        $this->assertTrue($ldap->exists($ou_3->dn()));\n        // Tree established.\n\n        // Local rename.\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, str_replace('moveitem', 'move_item', $ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertFalse($ldap->exists($olddn));\n\n        // Local move.\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, 'l=move_item,' . $ou_2->dn());\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertFalse($ldap->exists($olddn));\n\n        // Local move backward, with rename. Here we use the DN of the object,\n        // to test DN conversion.\n        // Note that this will outdate the object since it does not has\n        // knowledge about the move.\n        $olddn = $ou_1_l1->currentDN();\n        $newdn = 'l=moveditem,' . $ou_2->dn();\n        $ldap->move($olddn, $newdn);\n        $this->assertTrue($ldap->exists($newdn));\n        $this->assertFalse($ldap->exists($olddn));\n        // Refetch since the object's DN was outdated.\n        $ou_1_l1 = $ldap->getEntry($newdn);\n\n        // Fake-cross directory move using two separate links to the same\n        // directory. This other directory is represented by\n        // ou=target_otherdir.\n        $ldap2 = new Horde_Ldap(self::$ldapcfg['server']);\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, 'l=movedcrossdir,' . $ou_3->dn(), $ldap2);\n        $this->assertFalse($ldap->exists($olddn));\n        $this->assertTrue($ldap2->exists($ou_1_l1->dn()));\n\n        // Try to move over an existing entry.\n        try {\n            $ldap->move($ou_2, $ou_3->dn(), $ldap2);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try cross directory move without providing an valid entry but a DN.\n        try {\n            $ldap->move($ou_1_l1->dn(), 'l=movedcrossdir2,'.$ou_2->dn(), $ldap2);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try passing an invalid entry object.\n        try {\n            $ldap->move($ldap, 'l=move_item,'.$ou_2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try passing an invalid LDAP object.\n        try {\n            $ldap->move($ou_1_l1, 'l=move_item,'.$ou_2->dn(), $ou_1);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Test copy().\n     */\n    public function testCopy()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some testdata.\n        $base = self::$ldapcfg['server']['basedn'];\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_pool,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_copy'));\n        $ou2 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_tgt,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_copy'));\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($ou1->dn()));\n        $ldap->add($ou2);\n        $this->assertTrue($ldap->exists($ou2->dn()));\n\n        $entry = Horde_Ldap_Entry::createFresh(\n            'l=cptest,' . $ou1->dn(),\n            array('objectClass' => array('top','locality'),\n                  'l' => 'cptest'));\n        $ldap->add($entry);\n        $ldap->exists($entry->dn());\n\n        // Copy over the entry to another tree with rename.\n        $entrycp = $ldap->copy($entry, 'l=test_copied,' . $ou2->dn());\n        $this->assertInstanceOf('Horde_Ldap_Entry', $entrycp);\n        $this->assertNotEquals($entry->dn(), $entrycp->dn());\n        $this->assertTrue($ldap->exists($entrycp->dn()));\n\n        // Copy same again (fails, entry exists).\n        try {\n            $entrycp_f = $ldap->copy($entry, 'l=test_copied,' . $ou2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Use only DNs to copy (fails).\n        try {\n            $entrycp = $ldap->copy($entry->dn(), 'l=test_copied2,' . $ou2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Tests retrieval of root DSE object.\n     */\n    public function testRootDSE()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertInstanceOf('Horde_Ldap_RootDse', $ldap->rootDSE());\n    }\n\n    /**\n     * Tests retrieval of schema through LDAP object.\n     */\n    public function testSchema()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertInstanceOf('Horde_Ldap_Schema', $ldap->schema());\n    }\n\n    /**\n     * Test getLink().\n     */\n    public function testGetLink()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertTrue(is_resource($ldap->getLink()));\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * The main Horde_Ldap class.\n *\n * Copyright 2003-2007 Tarjej Huse, Jan Wagner, Del Elson, Benedikt Hallinger\n * Copyright 2009-2014 Horde LLC (http://www.horde.org/)\n *\n * @package   Ldap\n * @author    Tarjej Huse <tarjei@bergfald.no>\n * @author    Jan Wagner <wagner@netsols.de>\n * @author    Del <del@babel.com.au>\n * @author    Benedikt Hallinger <beni@php.net>\n * @author    Ben Klang <ben@alkaloid.net>\n * @author    Chuck Hagenbuch <chuck@horde.org>\n * @author    Jan Schneider <jan@horde.org>\n * @license   http://www.gnu.org/licenses/lgpl-3.0.txt LGPLv3\n */\nclass Horde_Ldap\n{\n    /**\n     * Class configuration array\n     *\n     * - hostspec:       the LDAP host to connect to (may be an array of\n     *                   several hosts to try).\n     * - port:           the server port.\n     * - version:        LDAP version (defaults to 3).\n     * - tls:            when set, ldap_start_tls() is run after connecting.\n     * - binddn:         the DN to bind as when searching.\n     * - bindpw:         password to use when searching LDAP.\n     * - basedn:         LDAP base.\n     * - options:        hash of LDAP options to set.\n     * - filter:         default search filter.\n     * - scope:          default search scope.\n     * - user:           configuration parameters for {@link findUserDN()},\n     *                   must contain 'uid', and 'filter' or 'objectclass'\n     *                   entries.\n     * - auto_reconnect: if true, the class will automatically\n     *                   attempt to reconnect to the LDAP server in certain\n     *                   failure conditions when attempting a search, or other\n     *                   LDAP operations.  Defaults to false.  Note that if you\n     *                   set this to true, calls to search() may block\n     *                   indefinitely if there is a catastrophic server failure.\n     * - min_backoff:    minimum reconnection delay period (in seconds).\n     * - current_backof: initial reconnection delay period (in seconds).\n     * - max_backoff:    maximum reconnection delay period (in seconds).\n     * - cache           a Horde_Cache instance for caching schema requests.\n     *\n     * @var array\n     */\n    protected $_config = array(\n        'hostspec'        => 'localhost',\n        'port'            => 389,\n        'version'         => 3,\n        'tls'             => false,\n        'binddn'          => '',\n        'bindpw'          => '',\n        'basedn'          => '',\n        'options'         => array(),\n        'filter'          => '(objectClass=*)',\n        'scope'           => 'sub',\n        'user'            => array(),\n        'auto_reconnect'  => false,\n        'min_backoff'     => 1,\n        'current_backoff' => 1,\n        'max_backoff'     => 32,\n        'cache'           => false,\n        'cachettl'        => 3600);\n\n    /**\n     * List of hosts we try to establish a connection to.\n     *\n     * @var array\n     */\n    protected $_hostList = array();\n\n    /**\n     * List of hosts that are known to be down.\n     *\n     * @var array\n     */\n    protected $_downHostList = array();\n\n    /**\n     * LDAP resource link.\n     *\n     * @var resource\n     */\n    protected $_link;\n\n    /**\n     * Schema object.\n     *\n     * @see schema()\n     * @var Horde_Ldap_Schema\n     */\n    protected $_schema;\n\n    /**\n     * Schema cache function callback.\n     *\n     * @see registerSchemaCache()\n     * @var string\n     */\n    protected $_schemaCache;\n\n    /**\n     * Cache for attribute encoding checks.\n     *\n     * @var array Hash with attribute names as key and boolean value\n     *            to determine whether they should be utf8 encoded or not.\n     */\n    protected $_schemaAttrs = array();\n\n    /**\n     * Cache for rootDSE objects\n     *\n     * Hash with requested rootDSE attr names as key and rootDSE\n     * object as value.\n     *\n     * Since the RootDSE object itself may request a rootDSE object,\n     * {@link rootDSE()} caches successful requests.\n     * Internally, Horde_Ldap needs several lookups to this object, so\n     * caching increases performance significally.\n     *\n     * @var array\n     */\n    protected $_rootDSECache = array();\n\n    /**\n     * Constructor.\n     *\n     * @see $_config\n     *\n     * @param array $config Configuration array.\n     */\n    public function __construct($config = array())\n    {\n        if (!Horde_Util::loadExtension('ldap')) {\n            throw new Horde_Ldap_Exception('No PHP LDAP extension');\n        }\n        $this->setConfig($config);\n        $this->bind();\n    }\n\n    /**\n     * Destructor.\n     */\n    public function __destruct()\n    {\n        $this->disconnect();\n    }\n\n    /**\n     * Sets the internal configuration array.\n     *\n     * @param array $config Configuration hash.\n     */\n    protected function setConfig($config)\n    {\n        /* Parameter check -- probably should raise an error here if\n         * config is not an array. */\n        if (!is_array($config)) {\n            return;\n        }\n\n        foreach ($config as $k => $v) {\n            if (isset($this->_config[$k])) {\n                $this->_config[$k] = $v;\n            }\n        }\n\n        /* Ensure the host list is an array. */\n        if (is_array($this->_config['hostspec'])) {\n            $this->_hostList = $this->_config['hostspec'];\n        } else {\n            if (strlen($this->_config['hostspec'])) {\n                $this->_hostList = array($this->_config['hostspec']);\n            } else {\n                $this->_hostList = array();\n                /* This will cause an error in _connect(), so\n                 * the user is notified about the failure. */\n            }\n        }\n\n        /* Reset the down host list, which seems like a sensible thing\n         * to do if the config is being reset for some reason. */\n        $this->_downHostList = array();\n    }\n\n    /**\n     * Bind or rebind to the LDAP server.\n     *\n     * This function binds with the given DN and password to the\n     * server. In case no connection has been made yet, it will be\n     * started and STARTTLS issued if appropiate.\n     *\n     * The internal bind configuration is not being updated, so if you\n     * call bind() without parameters, you can rebind with the\n     * credentials provided at first connecting to the server.\n     *\n     * @param string $dn       DN for binding.\n     * @param string $password Password for binding.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function bind($dn = null, $password = null)\n    {\n        /* Fetch current bind credentials. */\n        if (is_null($dn)) {\n            $dn = $this->_config['binddn'];\n        }\n        if (is_null($password)) {\n            $password = $this->_config['bindpw'];\n        }\n\n        /* Connect first, if we haven't so far.  This will also bind\n         * us to the server. */\n        if (!$this->_link) {\n            /* Store old credentials so we can revert them later, then\n             * overwrite config with new bind credentials. */\n            $olddn = $this->_config['binddn'];\n            $oldpw = $this->_config['bindpw'];\n\n            /* Overwrite bind credentials in config so\n             * _connect() knows about them. */\n            $this->_config['binddn'] = $dn;\n            $this->_config['bindpw'] = $password;\n\n            /* Try to connect with provided credentials. */\n            $msg = $this->_connect();\n\n            /* Reset to previous config. */\n            $this->_config['binddn'] = $olddn;\n            $this->_config['bindpw'] = $oldpw;\n            return;\n        }\n\n        /* Do the requested bind as we are asked to bind manually. */\n        if (empty($dn)) {\n            /* Anonymous bind. */\n            $msg = @ldap_bind($this->_link);\n        } else {\n            /* Privileged bind. */\n            $msg = @ldap_bind($this->_link, $dn, $password);\n        }\n        if (!$msg) {\n            throw new Horde_Ldap_Exception('Bind failed: ' . @ldap_error($this->_link),\n                                           @ldap_errno($this->_link));\n        }\n    }\n\n    /**\n     * Connects to the LDAP server.\n     *\n     * This function connects to the LDAP server specified in the\n     * configuration, binds and set up the LDAP protocol as needed.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    protected function _connect()\n    {\n        /* Connecting is briefly described in RFC1777. Basicly it works like\n         * this:\n         *  1. set up TCP connection\n         *  2. secure that connection if neccessary\n         *  3a. setVersion to tell server which version we want to speak\n         *  3b. perform bind\n         *  3c. setVersion to tell server which version we want to speak\n         *      together with a test for supported versions\n         *  4. set additional protocol options */\n\n        /* Return if we are already connected. */\n        if ($this->_link) {\n            return;\n        }\n\n        /* Connnect to the LDAP server if we are not connected.  Note that\n         * ldap_connect() may return a link value even if no connection is\n         * made.  We need to do at least one anonymous bind to ensure that a\n         * connection is actually valid.\n         *\n         * See: http://www.php.net/manual/en/function.ldap-connect.php */\n\n        /* Default error message in case all connection attempts fail but no\n         * message is set. */\n        $current_error = new Horde_Ldap_Exception('Unknown connection error');\n\n        /* Catch empty $_hostList arrays. */\n        if (!is_array($this->_hostList) || !count($this->_hostList)) {\n            throw new Horde_Ldap_Exception('No servers configured');\n        }\n\n        /* Cycle through the host list. */\n        foreach ($this->_hostList as $host) {\n            /* Ensure we have a valid string for host name. */\n            if (is_array($host)) {\n                $current_error = new Horde_Ldap_Exception('No Servers configured');\n                continue;\n            }\n\n            /* Skip this host if it is known to be down. */\n            if (in_array($host, $this->_downHostList)) {\n                continue;\n            }\n\n            /* Record the host that we are actually connecting to in case we\n             * need it later. */\n            $this->_config['hostspec'] = $host;\n\n            /* Attempt a connection. */\n            $this->_link = @ldap_connect($host, $this->_config['port']);\n            if (!$this->_link) {\n                $current_error = new Horde_Ldap_Exception('Could not connect to ' .  $host . ':' . $this->_config['port']);\n                $this->_downHostList[] = $host;\n                continue;\n            }\n\n            /* If we're supposed to use TLS, do so before we try to bind, as\n             * some strict servers only allow binding via secure\n             * connections. */\n            if ($this->_config['tls']) {\n                try {\n                    $this->startTLS();\n                } catch (Horde_Ldap_Exception $e) {\n                    $current_error           = $e;\n                    $this->_link             = false;\n                    $this->_downHostList[] = $host;\n                    continue;\n                }\n            }\n\n            /* Try to set the configured LDAP version on the connection if LDAP\n             * server needs that before binding (eg OpenLDAP).\n             * This could be necessary since RFC 1777 states that the protocol\n             * version has to be set at the bind request.\n             * We use force here which means that the test in the rootDSE is\n             * skipped; this is neccessary, because some strict LDAP servers\n             * only allow to read the LDAP rootDSE (which tells us the\n             * supported protocol versions) with authenticated clients.\n             * This may fail in which case we try again after binding.\n             * In this case, most probably the bind() or setVersion() call\n             * below will also fail, providing error messages. */\n            $version_set = false;\n            $this->setVersion(0, true);\n\n            /* Attempt to bind to the server. If we have credentials\n             * configured, we try to use them, otherwise it's an anonymous\n             * bind.\n             * As stated by RFC 1777, the bind request should be the first\n             * operation to be performed after the connection is established.\n             * This may give an protocol error if the server does not support\n             * v2 binds and the above call to setVersion() failed.\n             * If the above call failed, we try an v2 bind here and set the\n             * version afterwards (with checking to the rootDSE). */\n            try {\n                $this->bind();\n            } catch (Exception $e) {\n                /* The bind failed, discard link and save error msg.\n                 * Then record the host as down and try next one. */\n                if ($this->errorName($e->getCode()) == 'LDAP_PROTOCOL_ERROR' &&\n                    !$version_set) {\n                    /* Provide a finer grained error message if protocol error\n                     * arises because of invalid version. */\n                    $e = new Horde_Ldap_Exception($e->getMessage() . ' (could not set LDAP protocol version to ' . $this->_config['version'].')', $e->getCode());\n                }\n                $this->_link             = false;\n                $current_error           = $e;\n                $this->_downHostList[] = $host;\n                continue;\n            }\n\n            /* Set desired LDAP version if not successfully set before.\n             * Here, a check against the rootDSE is performed, so we get a\n             * error message if the server does not support the version.\n             * The rootDSE entry should tell us which LDAP versions are\n             * supported. However, some strict LDAP servers only allow\n             * bound users to read the rootDSE. */\n            if (!$version_set) {\n                try {\n                    $this->setVersion();\n                } catch (Exception $e) {\n                    $current_error           = $e;\n                    $this->_link             = false;\n                    $this->_downHostList[] = $host;\n                    continue;\n                }\n            }\n\n            /* Set LDAP parameters, now that we know we have a valid\n             * connection. */\n            if (isset($this->_config['options']) &&\n                is_array($this->_config['options']) &&\n                count($this->_config['options'])) {\n                foreach ($this->_config['options'] as $opt => $val) {\n                    try {\n                        $this->setOption($opt, $val);\n                    } catch (Exception $e) {\n                        $current_error           = $e;\n                        $this->_link             = false;\n                        $this->_downHostList[] = $host;\n                        continue 2;\n                    }\n                }\n            }\n\n            /* At this stage we have connected, bound, and set up options, so\n             * we have a known good LDAP server.  Time to go home. */\n            return;\n        }\n\n        /* All connection attempts have failed, return the last error. */\n        throw $current_error;\n    }\n\n    /**\n     * Reconnects to the LDAP server.\n     *\n     * In case the connection to the LDAP service has dropped out for some\n     * reason, this function will reconnect, and re-bind if a bind has been\n     * attempted in the past.  It is probably most useful when the server list\n     * provided to the new() or _connect() function is an array rather than a\n     * single host name, because in that case it will be able to connect to a\n     * failover or secondary server in case the primary server goes down.\n     *\n     * This method just tries to re-establish the current connection.  It will\n     * sleep for the current backoff period (seconds) before attempting the\n     * connect, and if the connection fails it will double the backoff period,\n     * but not try again.  If you want to ensure a reconnection during a\n     * transient period of server downtime then you need to call this function\n     * in a loop.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    protected function _reconnect()\n    {\n        /* Return if we are already connected. */\n        if ($this->_link) {\n            return;\n        }\n\n        /* Sleep for a backoff period in seconds. */\n        sleep($this->_config['current_backoff']);\n\n        /* Retry all available connections. */\n        $this->_downHostList = array();\n\n        try {\n            $this->_connect();\n        } catch (Horde_Ldap_Exception $e) {\n            $this->_config['current_backoff'] *= 2;\n            if ($this->_config['current_backoff'] > $this->_config['max_backoff']) {\n                $this->_config['current_backoff'] = $this->_config['max_backoff'];\n            }\n            throw $e;\n        }\n\n        /* Now we should be able to safely (re-)bind. */\n        try {\n            $this->bind();\n        } catch (Exception $e) {\n            $this->_config['current_backoff'] *= 2;\n            if ($this->_config['current_backoff'] > $this->_config['max_backoff']) {\n                $this->_config['current_backoff'] = $this->_config['max_backoff'];\n            }\n\n            /* $this->_config['hostspec'] should have had the last connected\n             * host stored in it by _connect().  Since we are unable to\n             * bind to that host we can safely assume that it is down or has\n             * some other problem. */\n            $this->_downHostList[] = $this->_config['hostspec'];\n            throw $e;\n        }\n\n        /* At this stage we have connected, bound, and set up options, so we\n         * have a known good LDAP server. Time to go home. */\n        $this->_config['current_backoff'] = $this->_config['min_backoff'];\n    }\n\n    /**\n     * Closes the LDAP connection.\n     */\n    public function disconnect()\n    {\n        @ldap_close($this->_link);\n    }\n\n    /**\n     * Starts an encrypted session.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function startTLS()\n    {\n        /* First try STARTTLS blindly, some servers don't even allow to receive\n         * the rootDSE without TLS. */\n        if (@ldap_start_tls($this->_link)) {\n            return;\n        }\n\n        /* Keep original error. */\n        $error = 'TLS not started: ' . @ldap_error($this->_link);\n        $errno = @ldap_errno($this->_link);\n\n        /* Test to see if the server supports TLS at all.\n         * This is done via testing the extensions offered by the server.\n         * The OID 1.3.6.1.4.1.1466.20037 tells whether TLS is supported. */\n        try {\n            $rootDSE = $this->rootDSE();\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to start TLS and unable to fetch rootDSE entry to see if TLS is supported: ' . $e->getMessage(), $e->getCode());\n        }\n\n        try {\n            $supported_extensions = $rootDSE->getValue('supportedExtension');\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to start TLS and unable to fetch rootDSE attribute \"supportedExtension\" to see if TLS is supoported: ' . $e->getMessage(), $e->getCode());\n        }\n\n        if (!in_array('1.3.6.1.4.1.1466.20037', $supported_extensions)) {\n            throw new Horde_Ldap_Exception('Server reports that it does not support TLS');\n        }\n\n        throw new Horde_Ldap_Exception($error, $errno);\n    }\n\n    /**\n     * Adds a new entry to the directory.\n     *\n     * This also links the entry to the connection used for the add, if it was\n     * a fresh entry.\n     *\n     * @see HordeLdap_Entry::createFresh()\n     *\n     * @param Horde_Ldap_Entry $entry An LDAP entry.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function add(Horde_Ldap_Entry $entry)\n    {\n        /* Continue attempting the add operation in a loop until we get a\n         * success, a definitive failure, or the world ends. */\n        while (true) {\n            $link = $this->getLink();\n            if ($link === false) {\n                /* We do not have a successful connection yet.  The call to\n                 * getLink() would have kept trying if we wanted one. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $entry->dn() . ' no valid LDAP connection could be found.');\n            }\n\n            if (@ldap_add($link, $entry->dn(), $entry->getValues())) {\n                /* Entry successfully added, we should update its Horde_Ldap\n                 * reference in case it is not set so far (fresh entry). */\n                try {\n                    $entry->getLDAP();\n                } catch (Horde_Ldap_Exception $e) {\n                    $entry->setLDAP($this);\n                }\n                /* Store that the entry is present inside the directory. */\n                $entry->markAsNew(false);\n                return;\n            }\n\n            /* We have a failure.  What kind?  We may be able to reconnect and\n             * try again. */\n            $error_code = @ldap_errno($link);\n            if ($this->errorName($error_code) != 'LDAP_OPERATIONS_ERROR' |\n                !$this->_config['auto_reconnect']) {\n                /* Errors other than the above are just passed back to the user\n                 * so he may react upon them. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $entry->dn() . ': ' . ldap_err2str($error_code), $error_code);\n            }\n\n            /* The server has disconnected before trying the operation.  We\n             * should try again, possibly with a different server. */\n            $this->_link = false;\n            $this->_reconnect();\n        }\n    }\n\n    /**\n     * Deletes an entry from the directory.\n     *\n     * @param string|Horde_Ldap_Entry $dn        DN string or Horde_Ldap_Entry.\n     * @param boolean                 $recursive Should we delete all children\n     *                                           recursivelx as well?\n     * @throws Horde_Ldap_Exception\n     */\n    public function delete($dn, $recursive = false)\n    {\n        if ($dn instanceof Horde_Ldap_Entry) {\n             $dn = $dn->dn();\n        }\n        if (!is_string($dn)) {\n            throw new Horde_Ldap_Exception('Parameter is not a string nor an entry object!');\n        }\n\n        /* Recursive delete searches for children and calls delete for them. */\n        if ($recursive) {\n            $result = @ldap_list($this->_link, $dn, '(objectClass=*)', array(null), 0, 0);\n            if ($result && @ldap_count_entries($this->_link, $result)) {\n                for ($subentry = @ldap_first_entry($this->_link, $result);\n                     $subentry;\n                     $subentry = @ldap_next_entry($this->_link, $subentry)) {\n                    $this->delete(@ldap_get_dn($this->_link, $subentry), true);\n                }\n            }\n        }\n\n        /* Continue the delete operation in a loop until we get a success, or a\n         * definitive failure. */\n        while (true) {\n            $link = $this->getLink();\n            if (!$link) {\n                /* We do not have a successful connection yet.  The call to\n                 * getLink() would have kept trying if we wanted one. */\n                throw new Horde_Ldap_Exception('Could not add entry ' . $dn . ' no valid LDAP connection could be found.');\n            }\n\n            $s = @ldap_delete($link, $dn);\n            if ($s) {\n                /* Entry successfully deleted. */\n                return;\n            }\n\n            /* We have a failure.  What kind? We may be able to reconnect and\n             * try again. */\n            $error_code = @ldap_errno($link);\n            if ($this->errorName($error_code) == 'LDAP_OPERATIONS_ERROR' &&\n                $this->_config['auto_reconnect']) {\n                /* The server has disconnected before trying the operation.  We\n                 * should try again, possibly with a different server. */\n                $this->_link = false;\n                $this->_reconnect();\n            } elseif ($this->errorName($error_code) == 'LDAP_NOT_ALLOWED_ON_NONLEAF') {\n                /* Subentries present, server refused to delete.\n                 * Deleting subentries is the clients responsibility, but since\n                 * the user may not know of the subentries, we do not force\n                 * that here but instead notify the developer so he may take\n                 * actions himself. */\n                throw new Horde_Ldap_Exception('Could not delete entry ' . $dn . ' because of subentries. Use the recursive parameter to delete them.', $error_code);\n            } else {\n                /* Errors other than the above catched are just passed back to\n                 * the user so he may react upon them. */\n                throw new Horde_Ldap_Exception('Could not delete entry ' . $dn . ': ' . ldap_err2str($error_code), $error_code);\n            }\n        }\n    }\n\n    /**\n     * Modifies an LDAP entry on the server.\n     *\n     * The $params argument is an array of actions and should be something like\n     * this:\n     * <code>\n     * array('add' => array('attribute1' => array('val1', 'val2'),\n     *                      'attribute2' => array('val1')),\n     *       'delete' => array('attribute1'),\n     *       'replace' => array('attribute1' => array('val1')),\n     *       'changes' => array('add' => ...,\n     *                          'replace' => ...,\n     *                          'delete' => array('attribute1', 'attribute2' => array('val1')))\n     * </code>\n     *\n     * The order of execution is as following:\n     *   1. adds from 'add' array\n     *   2. deletes from 'delete' array\n     *   3. replaces from 'replace' array\n     *   4. changes (add, replace, delete) in order of appearance\n     *\n     * The function calls the corresponding functions of an Horde_Ldap_Entry\n     * object. A detailed description of array structures can be found there.\n     *\n     * Unlike the modification methods provided by the Horde_Ldap_Entry object,\n     * this method will instantly carry out an update() after each operation,\n     * thus modifying \"directly\" on the server.\n     *\n     * @see Horde_Ldap_Entry::add()\n     * @see Horde_Ldap_Entry::delete()\n     * @see Horde_Ldap_Entry::replace()\n     *\n     * @param string|Horde_Ldap_Entry $entry DN string or Horde_Ldap_Entry.\n     * @param array                   $parms Array of changes\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function modify($entry, $parms = array())\n    {\n        if (is_string($entry)) {\n            $entry = $this->getEntry($entry);\n        }\n        if (!($entry instanceof Horde_Ldap_Entry)) {\n            throw new Horde_Ldap_Exception('Parameter is not a string nor an entry object!');\n        }\n\n        if ($unknown = array_diff(array_keys($parms), array('add', 'delete', 'replace', 'changes'))) {\n            throw new Horde_Ldap_Exception('Unknown modify action(s): ' . implode(', ', $unknown));\n        }\n\n        /* Perform changes mentioned separately. */\n        foreach (array('add', 'delete', 'replace') as $action) {\n            if (!isset($parms[$action])) {\n                continue;\n            }\n            $entry->$action($parms[$action]);\n            $entry->setLDAP($this);\n\n            /* Because the ldap_*() functions are called inside\n             * Horde_Ldap_Entry::update(), we have to trap the error codes\n             * issued from that if we want to support reconnection. */\n            while (true) {\n                try {\n                    $entry->update();\n                    break;\n                } catch (Exception $e) {\n                    /* We have a failure.  What kind?  We may be able to\n                     * reconnect and try again. */\n                    if ($this->errorName($e->getCode()) != 'LDAP_OPERATIONS_ERROR' ||\n                        !$this->_config['auto_reconnect']) {\n                        /* Errors other than the above catched are just passed\n                         * back to the user so he may react upon them. */\n                        throw new Horde_Ldap_Exception('Could not modify entry: ' . $e->getMessage());\n                    }\n                    /* The server has disconnected before trying the operation.\n                     * We should try again, possibly with a different\n                     * server. */\n                    $this->_link = false;\n                    $this->_reconnect();\n                }\n            }\n        }\n\n        if (!isset($parms['changes']) || !is_array($parms['changes'])) {\n            return;\n        }\n\n        /* Perform combined changes in 'changes' array. */\n        foreach ($parms['changes'] as $action => $value) {\n            $this->modify($entry, array($action => $value));\n        }\n    }\n\n    /**\n     * Runs an LDAP search query.\n     *\n     * $base and $filter may be ommitted. The one from config will then be\n     * used. $base is either a DN-string or an Horde_Ldap_Entry object in which\n     * case its DN will be used.\n     *\n     * $params may contain:\n     * - scope: The scope which will be used for searching, defaults to 'sub':\n     *          - base: Just one entry\n     *          - sub: The whole tree\n     *          - one: Immediately below $base\n     * - sizelimit: Limit the number of entries returned\n     *              (default: 0 = unlimited)\n     * - timelimit: Limit the time spent for searching (default: 0 = unlimited)\n     * - attrsonly: If true, the search will only return the attribute names\n     * - attributes: Array of attribute names, which the entry should contain.\n     *               It is good practice to limit this to just the ones you\n     *               need.\n     *\n     * You cannot override server side limitations to sizelimit and timelimit:\n     * You can always only lower a given limit.\n     *\n     * @todo implement search controls (sorting etc)\n     *\n     * @param string|Horde_Ldap_Entry  $base   LDAP searchbase.\n     * @param string|Horde_Ldap_Filter $filter LDAP search filter.\n     * @param array                    $params Array of options.\n     *\n     * @return Horde_Ldap_Search  The search result.\n     * @throws Horde_Ldap_Exception\n     */\n    public function search($base = null, $filter = null, $params = array())\n    {\n        if (is_null($base)) {\n            $base = $this->_config['basedn'];\n        }\n        if ($base instanceof Horde_Ldap_Entry) {\n            /* Fetch DN of entry, making searchbase relative to the entry. */\n            $base = $base->dn();\n        }\n        if (is_null($filter)) {\n            $filter = $this->_config['filter'];\n        }\n        if ($filter instanceof Horde_Ldap_Filter) {\n            /* Convert Horde_Ldap_Filter to string representation. */\n            $filter = (string)$filter;\n        }\n\n        /* Setting search parameters.  */\n        $sizelimit  = isset($params['sizelimit']) ? $params['sizelimit'] : 0;\n        $timelimit  = isset($params['timelimit']) ? $params['timelimit'] : 0;\n        $attrsonly  = isset($params['attrsonly']) ? $params['attrsonly'] : 0;\n        $attributes = isset($params['attributes']) ? $params['attributes'] : array();\n\n        /* Ensure $attributes to be an array in case only one attribute name\n         * was given as string. */\n        if (!is_array($attributes)) {\n            $attributes = array($attributes);\n        }\n\n        /* Reorganize the $attributes array index keys sometimes there are\n         * problems with not consecutive indexes. */\n        $attributes = array_values($attributes);\n\n        /* Scoping makes searches faster! */\n        $scope = isset($params['scope'])\n            ? $params['scope']\n            : $this->_config['scope'];\n\n        switch ($scope) {\n        case 'one':\n            $search_function = 'ldap_list';\n            break;\n        case 'base':\n            $search_function = 'ldap_read';\n            break;\n        default:\n            $search_function = 'ldap_search';\n        }\n\n        /* Continue attempting the search operation until we get a success or a\n         * definitive failure. */\n        while (true) {\n            $link = $this->getLink();\n            $search = @call_user_func($search_function,\n                                      $link,\n                                      $base,\n                                      $filter,\n                                      $attributes,\n                                      $attrsonly,\n                                      $sizelimit,\n                                      $timelimit);\n\n            if ($errno = @ldap_errno($link)) {\n                $err = $this->errorName($errno);\n                if ($err == 'LDAP_NO_SUCH_OBJECT' ||\n                    $err == 'LDAP_SIZELIMIT_EXCEEDED') {\n                    return new Horde_Ldap_Search($search, $this, $attributes);\n                }\n                if ($err == 'LDAP_FILTER_ERROR') {\n                    /* Bad search filter. */\n                    throw new Horde_Ldap_Exception(ldap_err2str($errno) . ' ($filter)', $errno);\n                }\n                if ($err == 'LDAP_OPERATIONS_ERROR' &&\n                    $this->_config['auto_reconnect']) {\n                    $this->_link = false;\n                    $this->_reconnect();\n                } else {\n                    $msg = \"\\nParameters:\\nBase: $base\\nFilter: $filter\\nScope: $scope\";\n                    throw new Horde_Ldap_Exception(ldap_err2str($errno) . $msg, $errno);\n                }\n            } else {\n                return new Horde_Ldap_Search($search, $this, $attributes);\n            }\n        }\n    }\n\n    /**\n     * Returns the DN of a user.\n     *\n     * The purpose is to quickly find the full DN of a user so it can be used\n     * to re-bind as this user. This method requires the 'user' configuration\n     * parameter to be set.\n     *\n     * @param string $user  The user to find.\n     *\n     * @return string  The user's full DN.\n     * @throws Horde_Ldap_Exception\n     * @throws Horde_Exception_NotFound\n     */\n    public function findUserDN($user)\n    {\n        $filter = Horde_Ldap_Filter::combine(\n            'and',\n            array(Horde_Ldap_Filter::build($this->_config['user']),\n                  Horde_Ldap_Filter::create($this->_config['user']['uid'], 'equals', $user)));\n        $search = $this->search(\n            null,\n            $filter,\n            array('attributes' => array($this->_config['user']['uid'])));\n        if (!$search->count()) {\n            throw new Horde_Exception_NotFound('DN for user ' . $user . ' not found');\n        }\n        $entry = $search->shiftEntry();\n        return $entry->currentDN();\n    }\n\n    /**\n     * Sets an LDAP option.\n     *\n     * @param string $option Option to set.\n     * @param mixed  $value  Value to set option to.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function setOption($option, $value)\n    {\n        if (!$this->_link) {\n            throw new Horde_Ldap_Exception('Could not set LDAP option: No LDAP connection');\n        }\n        if (!defined($option)) {\n            throw new Horde_Ldap_Exception('Unkown option requested');\n        }\n        if (@ldap_set_option($this->_link, constant($option), $value)) {\n            return;\n        }\n        $err = @ldap_errno($this->_link);\n        if ($err) {\n            throw new Horde_Ldap_Exception(ldap_err2str($err), $err);\n        }\n        throw new Horde_Ldap_Exception('Unknown error');\n    }\n\n    /**\n     * Returns an LDAP option value.\n     *\n     * @param string $option Option to get.\n     *\n     * @return Horde_Ldap_Error|string Horde_Ldap_Error or option value\n     * @throws Horde_Ldap_Exception\n     */\n    public function getOption($option)\n    {\n        if (!$this->_link) {\n            throw new Horde_Ldap_Exception('No LDAP connection');\n        }\n        if (!defined($option)) {\n            throw new Horde_Ldap_Exception('Unkown option requested');\n        }\n        if (@ldap_get_option($this->_link, constant($option), $value)) {\n            return $value;\n        }\n        $err = @ldap_errno($this->_link);\n        if ($err) {\n            throw new Horde_Ldap_Exception(ldap_err2str($err), $err);\n        }\n        throw new Horde_Ldap_Exception('Unknown error');\n    }\n\n    /**\n     * Returns the LDAP protocol version that is used on the connection.\n     *\n     * A lot of LDAP functionality is defined by what protocol version\n     * the LDAP server speaks. This might be 2 or 3.\n     *\n     * @return integer  The protocol version.\n     */\n    public function getVersion()\n    {\n        if ($this->_link) {\n            $version = $this->getOption('LDAP_OPT_PROTOCOL_VERSION');\n        } else {\n            $version = $this->_config['version'];\n        }\n        return $version;\n    }\n\n    /**\n     * Sets the LDAP protocol version that is used on the connection.\n     *\n     * @todo Checking via the rootDSE takes much time - why? fetching\n     *       and instanciation is quick!\n     *\n     * @param integer $version LDAP version that should be used.\n     * @param boolean $force   If set to true, the check against the rootDSE\n     *                         will be skipped.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function setVersion($version = 0, $force = false)\n    {\n        if (!$version) {\n            $version = $this->_config['version'];\n        }\n\n        /* Check to see if the server supports this version first.\n         *\n         * TODO: Why is this so horribly slow? $this->rootDSE() is very fast,\n         * as well as Horde_Ldap_RootDse(). Seems like a problem at copying the\n         * object inside PHP??  Additionally, this is not always\n         * reproducable... */\n        if (!$force) {\n            try {\n                $rootDSE = $this->rootDSE();\n                $supported_versions = $rootDSE->getValue('supportedLDAPVersion');\n                if (is_string($supported_versions)) {\n                    $supported_versions = array($supported_versions);\n                }\n                $check_ok = in_array($version, $supported_versions);\n            } catch (Horde_Ldap_Exception $e) {\n                /* If we don't get a root DSE, this is probably a v2 server. */\n                $check_ok = $version < 3;\n            }\n        }\n        $check_ok = true;\n\n        if ($force || $check_ok) {\n            return $this->setOption('LDAP_OPT_PROTOCOL_VERSION', $version);\n        }\n        throw new Horde_Ldap_Exception('LDAP Server does not support protocol version ' . $version);\n    }\n\n\n    /**\n     * Returns whether a DN exists in the directory.\n     *\n     * @param string|Horde_Ldap_Entry $dn The DN of the object to test.\n     *\n     * @return boolean  True if the DN exists.\n     * @throws Horde_Ldap_Exception\n     */\n    public function exists($dn)\n    {\n        if ($dn instanceof Horde_Ldap_Entry) {\n             $dn = $dn->dn();\n        }\n        if (!is_string($dn)) {\n            throw new Horde_Ldap_Exception('Parameter $dn is not a string nor an entry object!');\n        }\n\n        /* Make dn relative to parent. */\n        $base = Horde_Ldap_Util::explodeDN($dn, array('casefold' => 'none', 'reverse' => false, 'onlyvalues' => false));\n        $entry_rdn = array_shift($base);\n        $base = Horde_Ldap_Util::canonicalDN($base);\n\n        $result = @ldap_list($this->_link, $base, $entry_rdn, array(), 1, 1);\n        if (@ldap_count_entries($this->_link, $result)) {\n            return true;\n        }\n        if ($this->errorName(@ldap_errno($this->_link)) == 'LDAP_NO_SUCH_OBJECT') {\n            return false;\n        }\n        if (@ldap_errno($this->_link)) {\n            throw new Horde_Ldap_Exception(@ldap_error($this->_link), @ldap_errno($this->_link));\n        }\n        return false;\n    }\n\n\n    /**\n     * Returns a specific entry based on the DN.\n     *\n     * @todo Maybe a check against the schema should be done to be\n     *       sure the attribute type exists.\n     *\n     * @param string $dn   DN of the entry that should be fetched.\n     * @param array  $attributes Array of Attributes to select. If ommitted, all\n     *                     attributes are fetched.\n     *\n     * @return Horde_Ldap_Entry  A Horde_Ldap_Entry object.\n     * @throws Horde_Ldap_Exception\n     * @throws Horde_Exception_NotFound\n     */\n    public function getEntry($dn, $attributes = array())\n    {\n        if (!is_array($attributes)) {\n            $attributes = array($attributes);\n        }\n        $result = $this->search($dn, '(objectClass=*)',\n                                array('scope' => 'base', 'attributes' => $attributes));\n        if (!$result->count()) {\n            throw new Horde_Exception_NotFound(sprintf('Could not fetch entry %s: no entry found', $dn));\n        }\n        $entry = $result->shiftEntry();\n        if (!$entry) {\n            throw new Horde_Ldap_Exception('Could not fetch entry (error retrieving entry from search result)');\n        }\n        return $entry;\n    }\n\n    /**\n     * Renames or moves an entry.\n     *\n     * This method will instantly carry out an update() after the\n     * move, so the entry is moved instantly.\n     *\n     * You can pass an optional Horde_Ldap object. In this case, a\n     * cross directory move will be performed which deletes the entry\n     * in the source (THIS) directory and adds it in the directory\n     * $target_ldap.\n     *\n     * A cross directory move will switch the entry's internal LDAP\n     * reference so updates to the entry will go to the new directory.\n     *\n     * If you want to do a cross directory move, you need to pass an\n     * Horde_Ldap_Entry object, otherwise the attributes will be\n     * empty.\n     *\n     * @param string|Horde_Ldap_Entry $entry       An LDAP entry.\n     * @param string                  $newdn       The new location.\n     * @param Horde_Ldap              $target_ldap Target directory for cross\n     *                                             server move.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public function move($entry, $newdn, $target_ldap = null)\n    {\n        if (is_string($entry)) {\n            if ($target_ldap && $target_ldap !== $this) {\n                throw new Horde_Ldap_Exception('Unable to perform cross directory move: operation requires a Horde_Ldap_Entry object');\n            }\n            $entry = $this->getEntry($entry);\n        }\n        if (!$entry instanceof Horde_Ldap_Entry) {\n            throw new Horde_Ldap_Exception('Parameter $entry is expected to be a Horde_Ldap_Entry object! (If DN was passed, conversion failed)');\n        }\n        if ($target_ldap && !($target_ldap instanceof Horde_Ldap)) {\n            throw new Horde_Ldap_Exception('Parameter $target_ldap is expected to be a Horde_Ldap object!');\n        }\n\n        if (!$target_ldap || $target_ldap === $this) {\n            /* Local move. */\n            $entry->dn($newdn);\n            $entry->setLDAP($this);\n            $entry->update();\n            return;\n        }\n\n        /* Cross directory move. */\n        if ($target_ldap->exists($newdn)) {\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: entry does exist in target directory');\n        }\n        $entry->dn($newdn);\n        try {\n            $target_ldap->add($entry);\n        } catch (Exception $e) {\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: ' . $e->getMessage() . ' in target directory');\n        }\n\n        try {\n            $this->delete($entry->currentDN());\n        } catch (Exception $e) {\n            try {\n                $add_error_string = '';\n                /* Undo add. */\n                $target_ldap->delete($entry);\n            } catch (Exception $e) {\n                $add_error_string = ' Additionally, the deletion (undo add) of $entry in target directory failed.';\n            }\n            throw new Horde_Ldap_Exception('Unable to perform cross directory move: ' . $e->getMessage() . ' in source directory.' . $add_error_string);\n        }\n        $entry->setLDAP($target_ldap);\n    }\n\n    /**\n     * Copies an entry to a new location.\n     *\n     * The entry will be immediately copied. Only attributes you have\n     * selected will be copied.\n     *\n     * @param Horde_Ldap_Entry $entry An LDAP entry.\n     * @param string           $newdn New FQF-DN of the entry.\n     *\n     * @return Horde_Ldap_Entry  The copied entry.\n     * @throws Horde_Ldap_Exception\n     */\n    public function copy($entry, $newdn)\n    {\n        if (!$entry instanceof Horde_Ldap_Entry) {\n            throw new Horde_Ldap_Exception('Parameter $entry is expected to be a Horde_Ldap_Entry object');\n        }\n\n        $newentry = Horde_Ldap_Entry::createFresh($newdn, $entry->getValues());\n        $this->add($newentry);\n\n        return $newentry;\n    }\n\n\n    /**\n     * Returns the string for an LDAP errorcode.\n     *\n     * Made to be able to make better errorhandling.  Function based\n     * on DB::errorMessage().\n     *\n     * Hint: The best description of the errorcodes is found here:\n     * http://www.directory-info.com/Ldap/LDAPErrorCodes.html\n     *\n     * @param integer $errorcode An error code.\n     *\n     * @return string The description for the error.\n     */\n    public static function errorName($errorcode)\n    {\n        $errorMessages = array(\n            0x00 => 'LDAP_SUCCESS',\n            0x01 => 'LDAP_OPERATIONS_ERROR',\n            0x02 => 'LDAP_PROTOCOL_ERROR',\n            0x03 => 'LDAP_TIMELIMIT_EXCEEDED',\n            0x04 => 'LDAP_SIZELIMIT_EXCEEDED',\n            0x05 => 'LDAP_COMPARE_FALSE',\n            0x06 => 'LDAP_COMPARE_TRUE',\n            0x07 => 'LDAP_AUTH_METHOD_NOT_SUPPORTED',\n            0x08 => 'LDAP_STRONG_AUTH_REQUIRED',\n            0x09 => 'LDAP_PARTIAL_RESULTS',\n            0x0a => 'LDAP_REFERRAL',\n            0x0b => 'LDAP_ADMINLIMIT_EXCEEDED',\n            0x0c => 'LDAP_UNAVAILABLE_CRITICAL_EXTENSION',\n            0x0d => 'LDAP_CONFIDENTIALITY_REQUIRED',\n            0x0e => 'LDAP_SASL_BIND_INPROGRESS',\n            0x10 => 'LDAP_NO_SUCH_ATTRIBUTE',\n            0x11 => 'LDAP_UNDEFINED_TYPE',\n            0x12 => 'LDAP_INAPPROPRIATE_MATCHING',\n            0x13 => 'LDAP_CONSTRAINT_VIOLATION',\n            0x14 => 'LDAP_TYPE_OR_VALUE_EXISTS',\n            0x15 => 'LDAP_INVALID_SYNTAX',\n            0x20 => 'LDAP_NO_SUCH_OBJECT',\n            0x21 => 'LDAP_ALIAS_PROBLEM',\n            0x22 => 'LDAP_INVALID_DN_SYNTAX',\n            0x23 => 'LDAP_IS_LEAF',\n            0x24 => 'LDAP_ALIAS_DEREF_PROBLEM',\n            0x30 => 'LDAP_INAPPROPRIATE_AUTH',\n            0x31 => 'LDAP_INVALID_CREDENTIALS',\n            0x32 => 'LDAP_INSUFFICIENT_ACCESS',\n            0x33 => 'LDAP_BUSY',\n            0x34 => 'LDAP_UNAVAILABLE',\n            0x35 => 'LDAP_UNWILLING_TO_PERFORM',\n            0x36 => 'LDAP_LOOP_DETECT',\n            0x3C => 'LDAP_SORT_CONTROL_MISSING',\n            0x3D => 'LDAP_INDEX_RANGE_ERROR',\n            0x40 => 'LDAP_NAMING_VIOLATION',\n            0x41 => 'LDAP_OBJECT_CLASS_VIOLATION',\n            0x42 => 'LDAP_NOT_ALLOWED_ON_NONLEAF',\n            0x43 => 'LDAP_NOT_ALLOWED_ON_RDN',\n            0x44 => 'LDAP_ALREADY_EXISTS',\n            0x45 => 'LDAP_NO_OBJECT_CLASS_MODS',\n            0x46 => 'LDAP_RESULTS_TOO_LARGE',\n            0x47 => 'LDAP_AFFECTS_MULTIPLE_DSAS',\n            0x50 => 'LDAP_OTHER',\n            0x51 => 'LDAP_SERVER_DOWN',\n            0x52 => 'LDAP_LOCAL_ERROR',\n            0x53 => 'LDAP_ENCODING_ERROR',\n            0x54 => 'LDAP_DECODING_ERROR',\n            0x55 => 'LDAP_TIMEOUT',\n            0x56 => 'LDAP_AUTH_UNKNOWN',\n            0x57 => 'LDAP_FILTER_ERROR',\n            0x58 => 'LDAP_USER_CANCELLED',\n            0x59 => 'LDAP_PARAM_ERROR',\n            0x5a => 'LDAP_NO_MEMORY',\n            0x5b => 'LDAP_CONNECT_ERROR',\n            0x5c => 'LDAP_NOT_SUPPORTED',\n            0x5d => 'LDAP_CONTROL_NOT_FOUND',\n            0x5e => 'LDAP_NO_RESULTS_RETURNED',\n            0x5f => 'LDAP_MORE_RESULTS_TO_RETURN',\n            0x60 => 'LDAP_CLIENT_LOOP',\n            0x61 => 'LDAP_REFERRAL_LIMIT_EXCEEDED',\n            1000 => 'Unknown Error');\n\n         return isset($errorMessages[$errorcode]) ?\n            $errorMessages[$errorcode] :\n            'Unknown Error (' . $errorcode . ')';\n    }\n\n    /**\n     * Returns a rootDSE object\n     *\n     * This either fetches a fresh rootDSE object or returns it from\n     * the internal cache for performance reasons, if possible.\n     *\n     * @param array $attrs Array of attributes to search for.\n     *\n     * @return Horde_Ldap_RootDse Horde_Ldap_RootDse object\n     * @throws Horde_Ldap_Exception\n     */\n    public function rootDSE(array $attrs = array())\n    {\n        $attrs_signature = serialize($attrs);\n\n        /* See if we need to fetch a fresh object, or if we already\n         * requested this object with the same attributes. */\n        if (!isset($this->_rootDSECache[$attrs_signature])) {\n            $this->_rootDSECache[$attrs_signature] = new Horde_Ldap_RootDse($this, $attrs);\n        }\n\n        return $this->_rootDSECache[$attrs_signature];\n    }\n\n    /**\n     * Returns a schema object\n     *\n     * @param string $dn Subschema entry dn.\n     *\n     * @return Horde_Ldap_Schema  Horde_Ldap_Schema object\n     * @throws Horde_Ldap_Exception\n     */\n    public function schema($dn = null)\n    {\n        /* If a schema caching object is registered, we use that to fetch a\n         * schema object. */\n        $key = 'Horde_Ldap_Schema_' . md5(serialize(array($this->_config['hostspec'], $this->_config['port'], $dn)));\n        if (!$this->_schema && $this->_config['cache']) {\n            $schema = $this->_config['cache']->get($key, $this->_config['cachettl']);\n            if ($schema) {\n                $this->_schema = @unserialize($schema);\n            }\n        }\n\n        /* Fetch schema, if not tried before and no cached version available.\n         * If we are already fetching the schema, we will skip fetching. */\n        if (!$this->_schema) {\n            /* Store a temporary error message so subsequent calls to schema()\n             * can detect that we are fetching the schema already. Otherwise we\n             * will get an infinite loop at Horde_Ldap_Schema. */\n            $this->_schema = new Horde_Ldap_Exception('Schema not initialized');\n            $this->_schema = new Horde_Ldap_Schema($this, $dn);\n\n            /* If schema caching is active, advise the cache to store the\n             * schema. */\n            if ($this->_config['cache']) {\n                $this->_config['cache']->set($key, serialize($this->_schema), $this->_config['cachettl']);\n            }\n        }\n\n        if ($this->_schema instanceof Horde_Ldap_Exception) {\n            throw $this->_schema;\n        }\n\n        return $this->_schema;\n    }\n\n    /**\n     * Checks if PHP's LDAP extension is loaded.\n     *\n     * If it is not loaded, it tries to load it manually using PHP's dl().\n     * It knows both windows-dll and *nix-so.\n     *\n     * @throws Horde_Ldap_Exception\n     */\n    public static function checkLDAPExtension()\n    {\n        if (!extension_loaded('ldap') && !@dl('ldap.' . PHP_SHLIB_SUFFIX)) {\n            throw new Horde_Ldap_Exception('Unable to locate PHP LDAP extension. Please install it before using the Horde_Ldap package.');\n        }\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Encodes given attributes to UTF8 if needed by schema.\n     *\n     * This function takes attributes in an array and then checks\n     * against the schema if they need UTF8 encoding. If that is the\n     * case, they will be encoded. An encoded array will be returned\n     * and can be used for adding or modifying.\n     *\n     * $attributes is expected to be an array with keys describing\n     * the attribute names and the values as the value of this attribute:\n     * <code>$attributes = array('cn' => 'foo', 'attr2' => array('mv1', 'mv2'));</code>\n     *\n     * @param array $attributes An array of attributes.\n     *\n     * @return array|Horde_Ldap_Error An array of UTF8 encoded attributes or an error.\n     */\n    public function utf8Encode($attributes)\n    {\n        return $this->utf8($attributes, 'utf8_encode');\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Decodes the given attribute values if needed by schema\n     *\n     * $attributes is expected to be an array with keys describing\n     * the attribute names and the values as the value of this attribute:\n     * <code>$attributes = array('cn' => 'foo', 'attr2' => array('mv1', 'mv2'));</code>\n     *\n     * @param array $attributes Array of attributes\n     *\n     * @access public\n     * @see utf8Encode()\n     * @return array|Horde_Ldap_Error Array with decoded attribute values or Error\n     */\n    public function utf8Decode($attributes)\n    {\n        return $this->utf8($attributes, 'utf8_decode');\n    }\n\n    /**\n     * @todo Remove this and expect all data to be UTF-8.\n     *\n     * Encodes or decodes attribute values if needed\n     *\n     * @param array $attributes Array of attributes\n     * @param array $function   Function to apply to attribute values\n     *\n     * @access protected\n     * @return array Array of attributes with function applied to values.\n     */\n    protected function utf8($attributes, $function)\n    {\n        if (!is_array($attributes) || array_key_exists(0, $attributes)) {\n            throw new Horde_Ldap_Exception('Parameter $attributes is expected to be an associative array');\n        }\n\n        if (!$this->_schema) {\n            $this->_schema = $this->schema();\n        }\n\n        if (!$this->_link || !function_exists($function)) {\n            return $attributes;\n        }\n\n        if (is_array($attributes) && count($attributes) > 0) {\n\n            foreach ($attributes as $k => $v) {\n\n                if (!isset($this->_schemaAttrs[$k])) {\n\n                    try {\n                        $attr = $this->_schema->get('attribute', $k);\n                    } catch (Exception $e) {\n                        continue;\n                    }\n\n                    if (false !== strpos($attr['syntax'], '1.3.6.1.4.1.1466.115.121.1.15')) {\n                        $encode = true;\n                    } else {\n                        $encode = false;\n                    }\n                    $this->_schemaAttrs[$k] = $encode;\n\n                } else {\n                    $encode = $this->_schemaAttrs[$k];\n                }\n\n                if ($encode) {\n                    if (is_array($v)) {\n                        foreach ($v as $ak => $av) {\n                            $v[$ak] = call_user_func($function, $av);\n                        }\n                    } else {\n                        $v = call_user_func($function, $v);\n                    }\n                }\n                $attributes[$k] = $v;\n            }\n        }\n        return $attributes;\n    }\n\n    /**\n     * Returns the LDAP link resource.\n     *\n     * It will loop attempting to re-establish the connection if the\n     * connection attempt fails and auto_reconnect has been turned on\n     * (see the _config array documentation).\n     *\n     * @return resource LDAP link.\n     */\n    public function getLink()\n    {\n        if ($this->_config['auto_reconnect']) {\n            while (true) {\n                /* Return the link handle if we are already connected.\n                 * Otherwise try to reconnect. */\n                if ($this->_link) {\n                    return $this->_link;\n                }\n                $this->_reconnect();\n            }\n        }\n        return $this->_link;\n    }\n\n    /**\n     * Builds an LDAP search filter fragment.\n     *\n     * @param string $lhs    The attribute to test.\n     * @param string $op     The operator.\n     * @param string $rhs    The comparison value.\n     * @param array $params  Any additional parameters for the operator.\n     *\n     * @return string  The LDAP search fragment.\n     */\n    public static function buildClause($lhs, $op, $rhs, $params = array())\n    {\n        switch ($op) {\n        case 'LIKE':\n            if (empty($rhs)) {\n                return '(' . $lhs . '=*)';\n            }\n            if (!empty($params['begin'])) {\n                return sprintf('(|(%s=%s*)(%s=* %s*))', $lhs, self::quote($rhs), $lhs, self::quote($rhs));\n            }\n            if (!empty($params['approximate'])) {\n                return sprintf('(%s~=%s)', $lhs, self::quote($rhs));\n            }\n            return sprintf('(%s=*%s*)', $lhs, self::quote($rhs));\n\n        default:\n            return sprintf('(%s%s%s)', $lhs, $op, self::quote($rhs));\n        }\n    }\n\n\n    /**\n     * Escapes characters with special meaning in LDAP searches.\n     *\n     * @param string $clause  The string to escape.\n     *\n     * @return string  The escaped string.\n     */\n    public static function quote($clause)\n    {\n        return str_replace(array('\\\\',   '(',  ')',  '*',  \"\\0\"),\n                           array('\\\\5c', '\\(', '\\)', '\\*', \"\\\\00\"),\n                           $clause);\n    }\n\n    /**\n     * Takes an array of DN elements and properly quotes it according to RFC\n     * 1485.\n     *\n     * @param array $parts  An array of tuples containing the attribute\n     *                      name and that attribute's value which make\n     *                      up the DN. Example:\n     *                      <code>\n     *                      $parts = array(0 => array('cn', 'John Smith'),\n     *                                     1 => array('dc', 'example'),\n     *                                     2 => array('dc', 'com'));\n     *                      </code>\n     *\n     * @return string  The properly quoted string DN.\n     */\n    public static function quoteDN($parts)\n    {\n        $dn = '';\n        $count = count($parts);\n        for ($i = 0; $i < $count; $i++) {\n            if ($i > 0) {\n                $dn .= ',';\n            }\n            $dn .= $parts[$i][0] . '=';\n\n            // See if we need to quote the value.\n            if (preg_match('/^\\s|\\s$|\\s\\s|[,+=\"\\r\\n<>#;]/', $parts[$i][1])) {\n                $dn .= '\"' . str_replace('\"', '\\\\\"', $parts[$i][1]) . '\"';\n            } else {\n                $dn .= $parts[$i][1];\n            }\n        }\n\n        return $dn;\n    }\n}\n", "<?php\n\nrequire_once __DIR__ . '/TestBase.php';\n\n/**\n * Copyright 2010-2014 Horde LLC (http://www.horde.org/)\n *\n * @package    Ldap\n * @subpackage UnitTests\n * @author     Jan Schneider <jan@horde.org>\n * @license    http://www.gnu.org/licenses/lgpl-3.0.html LGPL-3.0\n */\nclass Horde_Ldap_LdapTest extends Horde_Ldap_TestBase\n{\n    public static function tearDownAfterClass()\n    {\n        if (!self::$ldapcfg) {\n            return;\n        }\n\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $clean = array('cn=Horde_Ldap_TestEntry,',\n                       'ou=Horde_Ldap_Test_subdelete,',\n                       'ou=Horde_Ldap_Test_modify,',\n                       'ou=Horde_Ldap_Test_search1,',\n                       'ou=Horde_Ldap_Test_search2,',\n                       'ou=Horde_Ldap_Test_exists,',\n                       'ou=Horde_Ldap_Test_getEntry,',\n                       'ou=Horde_Ldap_Test_move,',\n                       'ou=Horde_Ldap_Test_pool,',\n                       'ou=Horde_Ldap_Test_tgt,');\n        foreach ($clean as $dn) {\n            try {\n                $ldap->delete($dn . self::$ldapcfg['server']['basedn'], true);\n            } catch (Exception $e) {}\n        }\n    }\n\n    /**\n     * Tests if the server can connect and bind correctly.\n     */\n    public function testConnectAndPrivilegedBind()\n    {\n        // This connect is supposed to fail.\n        $lcfg = array('hostspec' => 'nonexistant.ldap.horde.org');\n        try {\n            $ldap = new Horde_Ldap($lcfg);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Failing with multiple hosts.\n        $lcfg = array('hostspec' => array('nonexistant1.ldap.horde.org',\n                                          'nonexistant2.ldap.horde.org'));\n        try {\n            $ldap = new Horde_Ldap($lcfg);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Simple working connect and privileged bind.\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Working connect and privileged bind with first host down.\n        $lcfg = array('hostspec' => array('nonexistant.ldap.horde.org',\n                                          self::$ldapcfg['server']['hostspec']),\n                      'port'      => self::$ldapcfg['server']['port'],\n                      'binddn'    => self::$ldapcfg['server']['binddn'],\n                      'bindpw'    => self::$ldapcfg['server']['bindpw']);\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Tests if the server can connect and bind anonymously, if supported.\n     */\n    public function testConnectAndAnonymousBind()\n    {\n        if (!self::$ldapcfg['capability']['anonymous']) {\n            $this->markTestSkipped('Server does not support anonymous bind');\n        }\n\n        // Simple working connect and anonymous bind.\n        $lcfg = array('hostspec' => self::$ldapcfg['server']['hostspec'],\n                      'port'     => self::$ldapcfg['server']['port']);\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Tests if the server can connect and bind, but not rebind with empty\n     * password.\n     *\n     * @expectedException Horde_Ldap_Exception\n     */\n    public function testConnectAndEmptyRebind()\n    {\n        // Simple working connect and privileged bind.\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $ldap->bind(self::$ldapcfg['server']['binddn'], '');\n    }\n\n    /**\n     * Tests startTLS() if server supports it.\n     */\n    public function testStartTLS()\n    {\n        if (!self::$ldapcfg['capability']['tls']) {\n            $this->markTestSkipped('Server does not support TLS');\n        }\n\n        // Simple working connect and privileged bind.\n        $lcfg = array('starttls' => true) + self::$ldapcfg['server'];\n        $ldap = new Horde_Ldap($lcfg);\n    }\n\n    /**\n     * Test if adding and deleting a fresh entry works.\n     */\n    public function testAdd()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Adding a fresh entry.\n        $cn = 'Horde_Ldap_TestEntry';\n        $dn = 'cn=' . $cn . ',' . self::$ldapcfg['server']['basedn'];\n        $fresh_entry = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'person'),\n                  'cn'          => $cn,\n                  'sn'          => 'TestEntry'));\n        $this->assertInstanceOf('Horde_Ldap_Entry', $fresh_entry);\n        $ldap->add($fresh_entry);\n\n        // Deleting this entry.\n        $ldap->delete($fresh_entry);\n    }\n\n    /**\n     * Basic deletion is tested in testAdd(), so here we just test if\n     * advanced deletion tasks work properly.\n     */\n    public function testDelete()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some parameter checks.\n        try {\n            $ldap->delete(1234);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n        try {\n            $ldap->delete($ldap);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // In order to test subtree deletion, we need some little tree\n        // which we need to establish first.\n        $base   = self::$ldapcfg['server']['basedn'];\n        $testdn = 'ou=Horde_Ldap_Test_subdelete,' . $base;\n\n        $ou = Horde_Ldap_Entry::createFresh(\n            $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_subdelete'));\n        $ou_1 = Horde_Ldap_Entry::createFresh(\n            'ou=test1,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test1'));\n        $ou_1_l1 = Horde_Ldap_Entry::createFresh(\n            'l=subtest,ou=test1,' . $testdn,\n            array('objectClass' => array('top', 'locality'),\n                  'l' => 'test1'));\n        $ou_2 = Horde_Ldap_Entry::createFresh(\n            'ou=test2,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test2'));\n        $ou_3 = Horde_Ldap_Entry::createFresh(\n            'ou=test3,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'test3'));\n        $ldap->add($ou);\n        $ldap->add($ou_1);\n        $ldap->add($ou_1_l1);\n        $ldap->add($ou_2);\n        $ldap->add($ou_3);\n        $this->assertTrue($ldap->exists($ou->dn()));\n        $this->assertTrue($ldap->exists($ou_1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_2->dn()));\n        $this->assertTrue($ldap->exists($ou_3->dn()));\n        // Tree established now. We can run some tests now :D\n\n        // Try to delete some non existent entry inside that subtree (fails).\n        try {\n            $ldap->delete('cn=not_existent,ou=test1,' . $testdn);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {\n            $this->assertEquals('LDAP_NO_SUCH_OBJECT', Horde_Ldap::errorName($e->getCode()));\n        }\n\n        // Try to delete main test ou without recursive set (fails too).\n        try {\n            $ldap->delete($testdn);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {\n            $this->assertEquals('LDAP_NOT_ALLOWED_ON_NONLEAF', Horde_Ldap::errorName($e->getCode()));\n        }\n\n        // Retry with subtree delete, this should work.\n        $ldap->delete($testdn, true);\n\n        // The DN is not allowed to exist anymore.\n        $this->assertFalse($ldap->exists($testdn));\n    }\n\n    /**\n     * Test modify().\n     */\n    public function testModify()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // We need a test entry.\n        $local_entry = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_modify,' . self::$ldapcfg['server']['basedn'],\n            array('objectClass'     => array('top', 'organizationalUnit'),\n                  'ou'              => 'Horde_Ldap_Test_modify',\n                  'street'          => 'Beniroad',\n                  'telephoneNumber' => array('1234', '5678'),\n                  'postalcode'      => '12345',\n                  'postalAddress'   => 'someAddress',\n                  'st'              => array('State 1', 'State 2')));\n        $ldap->add($local_entry);\n        $this->assertTrue($ldap->exists($local_entry->dn()));\n\n        // Test invalid actions.\n        try {\n            $ldap->modify($local_entry, array('foo' => 'bar'));\n            $this->fail('Expected exception when passing invalid actions to modify().');\n        } catch (Horde_Ldap_Exception $e) {\n        }\n\n        // Prepare some changes.\n        $changes = array(\n            'add' => array(\n                'businessCategory' => array('foocat', 'barcat'),\n                'description' => 'testval'\n            ),\n            'delete' => array('postalAddress'),\n            'replace' => array('telephoneNumber' => array('345', '567')),\n            'changes' => array(\n                'replace' => array('street' => 'Highway to Hell'),\n                'add' => array('l' => 'someLocality'),\n                'delete' => array(\n                    'postalcode',\n                    'st' => array('State 1'))));\n\n        // Perform those changes.\n        $ldap->modify($local_entry, $changes);\n\n        // Verify correct attribute changes.\n        $actual_entry = $ldap->getEntry($local_entry->dn(),\n                                        array('objectClass', 'ou',\n                                              'postalAddress', 'street',\n                                              'telephoneNumber', 'postalcode',\n                                              'st', 'l', 'businessCategory',\n                                              'description'));\n        $this->assertInstanceOf('Horde_Ldap_Entry', $actual_entry);\n        $expected_attributes = array(\n            'objectClass'      => array('top', 'organizationalUnit'),\n            'ou'               => 'Horde_Ldap_Test_modify',\n            'street'           => 'Highway to Hell',\n            'l'                => 'someLocality',\n            'telephoneNumber'  => array('345', '567'),\n            'businessCategory' => array('foocat', 'barcat'),\n            'description'      => 'testval',\n            'st'               => 'State 2'\n        );\n\n        $local_attributes  = $local_entry->getValues();\n        $actual_attributes = $actual_entry->getValues();\n\n        // To enable easy check, we need to sort the values of the remaining\n        // multival attributes as well as the attribute names.\n        ksort($expected_attributes);\n        ksort($local_attributes);\n        ksort($actual_attributes);\n        sort($expected_attributes['businessCategory']);\n        sort($local_attributes['businessCategory']);\n        sort($actual_attributes['businessCategory']);\n\n        // The attributes must match the expected values.  Both, the entry\n        // inside the directory and our local copy must reflect the same\n        // values.\n        $this->assertEquals($expected_attributes, $actual_attributes, 'The directory entries attributes are not OK!');\n        $this->assertEquals($expected_attributes, $local_attributes, 'The local entries attributes are not OK!');\n    }\n\n    /**\n     * Test search().\n     */\n    public function testSearch()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some testdata, so we can test sizelimit.\n        $base = self::$ldapcfg['server']['basedn'];\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search1,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search1'));\n        $ou1_1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search1_1,' . $ou1->dn(),\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search2'));\n        $ou2 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_search2,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search2'));\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($ou1->dn()));\n        $ldap->add($ou1_1);\n        $this->assertTrue($ldap->exists($ou1_1->dn()));\n        $ldap->add($ou2);\n        $this->assertTrue($ldap->exists($ou2->dn()));\n\n\n        // Search for test filter, should at least return our two test entries.\n        $res = $ldap->search(null, '(ou=Horde_Ldap*)',\n                             array('attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Same, but with Horde_Ldap_Filter object.\n        $filtero = Horde_Ldap_Filter::create('ou', 'begins', 'Horde_Ldap');\n        $this->assertInstanceOf('Horde_Ldap_Filter', $filtero);\n        $res = $ldap->search(null, $filtero,\n                             array('attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Search using default filter for base-onelevel scope, should at least\n        // return our two test entries.\n        $res = $ldap->search(null, null,\n                             array('scope' => 'one', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertThat($res->count(), $this->greaterThanOrEqual(2));\n\n        // Base-search using custom base (string), should only return the test\n        // entry $ou1 and not the entry below it.\n        $res = $ldap->search($ou1->dn(), null,\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n\n        // Search using custom base, this time using an entry object.  This\n        // tests if passing an entry object as base works, should only return\n        // the test entry $ou1.\n        $res = $ldap->search($ou1, '(ou=*)',\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n\n        // Search using default filter for base-onelevel scope with sizelimit,\n        // should of course return more than one entry, but not more than\n        // sizelimit\n        $res = $ldap->search(\n            null, null,\n            array('scope' => 'one', 'sizelimit' => 1, 'attributes' => '1.1')\n        );\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(1, $res->count());\n        // Sizelimit should be exceeded now.\n        $this->assertTrue($res->sizeLimitExceeded());\n\n        // Bad filter.\n        try {\n            $res = $ldap->search(null, 'somebadfilter',\n                                 array('attributes' => '1.1'));\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Bad base.\n        try {\n            $res = $ldap->search('badbase', null,\n                                 array('attributes' => '1.1'));\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Nullresult.\n        $res = $ldap->search(null, '(cn=nevermatching_filter)',\n                             array('scope' => 'base', 'attributes' => '1.1'));\n        $this->assertInstanceOf('Horde_Ldap_Search', $res);\n        $this->assertEquals(0, $res->count());\n    }\n\n    /**\n     * Test exists().\n     */\n    public function testExists()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        $dn = 'ou=Horde_Ldap_Test_exists,' . self::$ldapcfg['server']['basedn'];\n\n        // Testing not existing DN.\n        $this->assertFalse($ldap->exists($dn));\n\n        // Passing an entry object (should work). It should return false,\n        // because we didn't add the test entry yet.\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_search1'));\n        $this->assertFalse($ldap->exists($ou1));\n\n        // Testing not existing DN.\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($dn));\n\n        // Passing an float instead of a string.\n        try {\n            $ldap->exists(1.234);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Test getEntry().\n     */\n    public function testGetEntry()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $dn = 'ou=Horde_Ldap_Test_getEntry,' . self::$ldapcfg['server']['basedn'];\n        $entry = Horde_Ldap_Entry::createFresh(\n            $dn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_getEntry'));\n        $ldap->add($entry);\n\n        // Existing DN.\n        $this->assertInstanceOf('Horde_Ldap_Entry', $ldap->getEntry($dn));\n\n        // Not existing DN.\n        try {\n            $ldap->getEntry('cn=notexistent,' . self::$ldapcfg['server']['basedn']);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Exception_NotFound $e) {}\n    }\n\n    /**\n     * Test move().\n     */\n    public function testMove()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // For Moving tests, we need some little tree again.\n        $base   = self::$ldapcfg['server']['basedn'];\n        $testdn = 'ou=Horde_Ldap_Test_move,' . $base;\n\n        $ou = Horde_Ldap_Entry::createFresh(\n            $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_move'));\n        $ou_1 = Horde_Ldap_Entry::createFresh(\n            'ou=source,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'source'));\n        $ou_1_l1 = Horde_Ldap_Entry::createFresh(\n            'l=moveitem,ou=source,' . $testdn,\n            array('objectClass' => array('top','locality'),\n                  'l' => 'moveitem',\n                  'description' => 'movetest'));\n        $ou_2 = Horde_Ldap_Entry::createFresh(\n            'ou=target,' . $testdn,\n            array('objectClass' => array('top', 'organizationalUnit'),\n                  'ou' => 'target'));\n        $ou_3 = Horde_Ldap_Entry::createFresh(\n            'ou=target_otherdir,' . $testdn,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'target_otherdir'));\n        $ldap->add($ou);\n        $ldap->add($ou_1);\n        $ldap->add($ou_1_l1);\n        $ldap->add($ou_2);\n        $ldap->add($ou_3);\n        $this->assertTrue($ldap->exists($ou->dn()));\n        $this->assertTrue($ldap->exists($ou_1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_2->dn()));\n        $this->assertTrue($ldap->exists($ou_3->dn()));\n        // Tree established.\n\n        // Local rename.\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, str_replace('moveitem', 'move_item', $ou_1_l1->dn()));\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertFalse($ldap->exists($olddn));\n\n        // Local move.\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, 'l=move_item,' . $ou_2->dn());\n        $this->assertTrue($ldap->exists($ou_1_l1->dn()));\n        $this->assertFalse($ldap->exists($olddn));\n\n        // Local move backward, with rename. Here we use the DN of the object,\n        // to test DN conversion.\n        // Note that this will outdate the object since it does not has\n        // knowledge about the move.\n        $olddn = $ou_1_l1->currentDN();\n        $newdn = 'l=moveditem,' . $ou_2->dn();\n        $ldap->move($olddn, $newdn);\n        $this->assertTrue($ldap->exists($newdn));\n        $this->assertFalse($ldap->exists($olddn));\n        // Refetch since the object's DN was outdated.\n        $ou_1_l1 = $ldap->getEntry($newdn);\n\n        // Fake-cross directory move using two separate links to the same\n        // directory. This other directory is represented by\n        // ou=target_otherdir.\n        $ldap2 = new Horde_Ldap(self::$ldapcfg['server']);\n        $olddn = $ou_1_l1->currentDN();\n        $ldap->move($ou_1_l1, 'l=movedcrossdir,' . $ou_3->dn(), $ldap2);\n        $this->assertFalse($ldap->exists($olddn));\n        $this->assertTrue($ldap2->exists($ou_1_l1->dn()));\n\n        // Try to move over an existing entry.\n        try {\n            $ldap->move($ou_2, $ou_3->dn(), $ldap2);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try cross directory move without providing an valid entry but a DN.\n        try {\n            $ldap->move($ou_1_l1->dn(), 'l=movedcrossdir2,'.$ou_2->dn(), $ldap2);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try passing an invalid entry object.\n        try {\n            $ldap->move($ldap, 'l=move_item,'.$ou_2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Try passing an invalid LDAP object.\n        try {\n            $ldap->move($ou_1_l1, 'l=move_item,'.$ou_2->dn(), $ou_1);\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Test copy().\n     */\n    public function testCopy()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n\n        // Some testdata.\n        $base = self::$ldapcfg['server']['basedn'];\n        $ou1 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_pool,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_copy'));\n        $ou2 = Horde_Ldap_Entry::createFresh(\n            'ou=Horde_Ldap_Test_tgt,' . $base,\n            array('objectClass' => array('top','organizationalUnit'),\n                  'ou' => 'Horde_Ldap_Test_copy'));\n        $ldap->add($ou1);\n        $this->assertTrue($ldap->exists($ou1->dn()));\n        $ldap->add($ou2);\n        $this->assertTrue($ldap->exists($ou2->dn()));\n\n        $entry = Horde_Ldap_Entry::createFresh(\n            'l=cptest,' . $ou1->dn(),\n            array('objectClass' => array('top','locality'),\n                  'l' => 'cptest'));\n        $ldap->add($entry);\n        $ldap->exists($entry->dn());\n\n        // Copy over the entry to another tree with rename.\n        $entrycp = $ldap->copy($entry, 'l=test_copied,' . $ou2->dn());\n        $this->assertInstanceOf('Horde_Ldap_Entry', $entrycp);\n        $this->assertNotEquals($entry->dn(), $entrycp->dn());\n        $this->assertTrue($ldap->exists($entrycp->dn()));\n\n        // Copy same again (fails, entry exists).\n        try {\n            $entrycp_f = $ldap->copy($entry, 'l=test_copied,' . $ou2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n\n        // Use only DNs to copy (fails).\n        try {\n            $entrycp = $ldap->copy($entry->dn(), 'l=test_copied2,' . $ou2->dn());\n            $this->fail('Horde_Ldap_Exception expected.');\n        } catch (Horde_Ldap_Exception $e) {}\n    }\n\n    /**\n     * Tests retrieval of root DSE object.\n     */\n    public function testRootDSE()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertInstanceOf('Horde_Ldap_RootDse', $ldap->rootDSE());\n    }\n\n    /**\n     * Tests retrieval of schema through LDAP object.\n     */\n    public function testSchema()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertInstanceOf('Horde_Ldap_Schema', $ldap->schema());\n    }\n\n    /**\n     * Test getLink().\n     */\n    public function testGetLink()\n    {\n        $ldap = new Horde_Ldap(self::$ldapcfg['server']);\n        $this->assertTrue(is_resource($ldap->getLink()));\n    }\n}\n"], "filenames": ["framework/Ldap/lib/Horde/Ldap.php", "framework/Ldap/test/Horde/Ldap/LdapTest.php"], "buggy_code_start_loc": [209, 83], "buggy_code_end_loc": [213, 83], "fixing_code_start_loc": [209, 84], "fixing_code_end_loc": [213, 97], "type": "CWE-287", "message": "The Horde_Ldap library before 2.0.6 for Horde allows remote attackers to bypass authentication by leveraging knowledge of the LDAP bind user DN.", "other": {"cve": {"id": "CVE-2014-3999", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-10T15:29:00.877", "lastModified": "2018-05-18T13:23:25.737", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Horde_Ldap library before 2.0.6 for Horde allows remote attackers to bypass authentication by leveraging knowledge of the LDAP bind user DN."}, {"lang": "es", "value": "La biblioteca Horde_Ldap en versiones anteriores a la 2.0.6 para Horde permite que atacantes remotos omitan la autenticaci\u00f3n aprovechando el conocimiento del DN del usuario bind LDAP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:horde:horde_ldap:*:*:*:*:*:horde:*:*", "versionEndExcluding": "2.0.6", "matchCriteriaId": "7620D38C-DA8C-4183-9139-5B019DA7112C"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/06/14/1", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/68014", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1109628", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/horde/horde/commit/4c3e18f1724ab39bfef10c189a5b52036a744d55", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://marc.info/?l=horde-announce&m=140178644816474&w=2", "source": "cve@mitre.org", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/horde/horde/commit/4c3e18f1724ab39bfef10c189a5b52036a744d55"}}