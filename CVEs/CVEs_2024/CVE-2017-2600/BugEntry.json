{"buggy_code": ["/*\n * The MIT License\n *\n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Red Hat, Inc., Seiji Sogabe, Stephen Connolly, Thomas J. Black, Tom Huybrechts, CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport edu.umd.cs.findbugs.annotations.OverrideMustInvoke;\nimport edu.umd.cs.findbugs.annotations.When;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.Launcher.ProcStarter;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.console.AnnotatedLargeText;\nimport hudson.init.Initializer;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Queue.FlyweightTask;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.queue.WorkUnit;\nimport hudson.node_monitors.NodeMonitor;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.slaves.AbstractCloudSlave;\nimport hudson.slaves.ComputerLauncher;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.slaves.WorkspaceList;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.OfflineCause.ByCLI;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.EditDistance;\nimport hudson.util.ExceptionCatchingThreadFactory;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.RunList;\nimport hudson.util.Futures;\nimport hudson.util.NamingThreadFactory;\nimport jenkins.model.Jenkins;\nimport jenkins.util.ContextResettingExecutorService;\nimport jenkins.security.MasterToSlaveCallable;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\n\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.DoNotUse;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.annotation.concurrent.GuardedBy;\nimport javax.servlet.ServletException;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ExecutionException;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.nio.charset.Charset;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.Inet4Address;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Represents the running state of a remote computer that holds {@link Executor}s.\n *\n * <p>\n * {@link Executor}s on one {@link Computer} are transparently interchangeable\n * (that is the definition of {@link Computer}).\n *\n * <p>\n * This object is related to {@link Node} but they have some significant differences.\n * {@link Computer} primarily works as a holder of {@link Executor}s, so\n * if a {@link Node} is configured (probably temporarily) with 0 executors,\n * you won't have a {@link Computer} object for it (except for the master node,\n * which always gets its {@link Computer} in case we have no static executors and\n * we need to run a {@link FlyweightTask} - see JENKINS-7291 for more discussion.)\n *\n * Also, even if you remove a {@link Node}, it takes time for the corresponding\n * {@link Computer} to be removed, if some builds are already in progress on that\n * node. Or when the node configuration is changed, unaffected {@link Computer} object\n * remains intact, while all the {@link Node} objects will go away.\n *\n * <p>\n * This object also serves UI (unlike {@link Node}), and can be used along with\n * {@link TransientComputerActionFactory} to add {@link Action}s to {@link Computer}s.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic /*transient*/ abstract class Computer extends Actionable implements AccessControlled, ExecutorListener {\n\n    private final CopyOnWriteArrayList<Executor> executors = new CopyOnWriteArrayList<Executor>();\n    // TODO:\n    private final CopyOnWriteArrayList<OneOffExecutor> oneOffExecutors = new CopyOnWriteArrayList<OneOffExecutor>();\n\n    private int numExecutors;\n\n    /**\n     * Contains info about reason behind computer being offline.\n     */\n    protected volatile OfflineCause offlineCause;\n\n    private long connectTime = 0;\n\n    /**\n     * True if Jenkins shouldn't start new builds on this node.\n     */\n    private boolean temporarilyOffline;\n\n    /**\n     * {@link Node} object may be created and deleted independently\n     * from this object.\n     */\n    protected String nodeName;\n\n    /**\n     * @see #getHostName()\n     */\n    private volatile String cachedHostName;\n    private volatile boolean hostNameCached;\n\n    /**\n     * @see #getEnvironment()\n     */\n    private volatile EnvVars cachedEnvironment;\n\n\n    private final WorkspaceList workspaceList = new WorkspaceList();\n\n    protected transient List<Action> transientActions;\n\n    protected final Object statusChangeLock = new Object();\n\n    /**\n     * Keeps track of stack traces to track the tremination requests for this computer.\n     *\n     * @since 1.607\n     * @see Executor#resetWorkUnit(String)\n     */\n    private transient final List<TerminationRequest> terminatedBy = Collections.synchronizedList(new ArrayList\n            <TerminationRequest>());\n\n    /**\n     * This method captures the information of a request to terminate a computer instance. Method is public as\n     * it needs to be called from {@link AbstractCloudSlave} and {@link jenkins.model.Nodes}. In general you should\n     * not need to call this method directly, however if implementing a custom node type or a different path\n     * for removing nodes, it may make sense to call this method in order to capture the originating request.\n     *\n     * @since 1.607\n     */\n    public void recordTermination() {\n        StaplerRequest request = Stapler.getCurrentRequest();\n        if (request != null) {\n            terminatedBy.add(new TerminationRequest(\n                    String.format(\"Termination requested at %s by %s [id=%d] from HTTP request for %s\",\n                            new Date(),\n                            Thread.currentThread(),\n                            Thread.currentThread().getId(),\n                            request.getRequestURL()\n                    )\n            ));\n        } else {\n            terminatedBy.add(new TerminationRequest(\n                    String.format(\"Termination requested at %s by %s [id=%d]\",\n                            new Date(),\n                            Thread.currentThread(),\n                            Thread.currentThread().getId()\n                    )\n            ));\n        }\n    }\n\n    /**\n     * Returns the list of captured termination requests for this Computer. This method is used by {@link Executor}\n     * to provide details on why a Computer was removed in-between work being scheduled against the {@link Executor}\n     * and the {@link Executor} starting to execute the task.\n     *\n     * @return the (possibly empty) list of termination requests.\n     * @see Executor#resetWorkUnit(String)\n     * @since 1.607\n     */\n    public List<TerminationRequest> getTerminatedBy() {\n        return new ArrayList<TerminationRequest>(terminatedBy);\n    }\n\n    public Computer(Node node) {\n        setNode(node);\n    }\n\n     /**\n     * Returns list of all boxes {@link ComputerPanelBox}s.\n     */\n    public List<ComputerPanelBox> getComputerPanelBoxs(){\n        return ComputerPanelBox.all(this);\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the computer.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public List<Action> getActions() {\n    \tList<Action> result = new ArrayList<Action>();\n    \tresult.addAll(super.getActions());\n    \tsynchronized (this) {\n    \t\tif (transientActions == null) {\n    \t\t\ttransientActions = TransientComputerActionFactory.createAllFor(this);\n    \t\t}\n    \t\tresult.addAll(transientActions);\n    \t}\n    \treturn Collections.unmodifiableList(result);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void addAction(Action a) {\n        if(a==null) throw new IllegalArgumentException();\n        super.getActions().add(a);\n    }\n\n    /**\n     * This is where the log from the remote agent goes.\n     * The method also creates a log directory if required.\n     * @see #getLogDir(), #relocateOldLogs()\n     */\n    public @Nonnull File getLogFile() {\n        return new File(getLogDir(),\"slave.log\");\n    }\n\n    /**\n     * Directory where rotated slave logs are stored.\n     *\n     * The method also creates a log directory if required.\n     *\n     * @since 1.613\n     */\n    protected @Nonnull File getLogDir() {\n        File dir = new File(Jenkins.getInstance().getRootDir(),\"logs/slaves/\"+nodeName);\n        if (!dir.exists() && !dir.mkdirs()) {\n            LOGGER.severe(\"Failed to create slave log directory \" + dir.getAbsolutePath());\n        }\n        return dir;\n    }\n\n    /**\n     * Gets the object that coordinates the workspace allocation on this computer.\n     */\n    public WorkspaceList getWorkspaceList() {\n        return workspaceList;\n    }\n\n    /**\n     * Gets the string representation of the slave log.\n     */\n    public String getLog() throws IOException {\n        return Util.loadFile(getLogFile());\n    }\n\n    /**\n     * Used to URL-bind {@link AnnotatedLargeText}.\n     */\n    public AnnotatedLargeText<Computer> getLogText() {\n        return new AnnotatedLargeText<Computer>(getLogFile(), Charset.defaultCharset(), false, this);\n    }\n\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    public void checkPermission(Permission permission) {\n        getACL().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return getACL().hasPermission(permission);\n    }\n\n    /**\n     * If the computer was offline (either temporarily or not),\n     * this method will return the cause.\n     *\n     * @return\n     *      null if the system was put offline without given a cause.\n     */\n    @Exported\n    public OfflineCause getOfflineCause() {\n        return offlineCause;\n    }\n\n    /**\n     * If the computer was offline (either temporarily or not),\n     * this method will return the cause as a string (without user info).\n     *\n     * @return\n     *      empty string if the system was put offline without given a cause.\n     */\n    @Exported\n    public String getOfflineCauseReason() {\n        if (offlineCause == null) {\n            return \"\";\n        }\n        // fetch the localized string for \"Disconnected By\"\n        String gsub_base = hudson.slaves.Messages.SlaveComputer_DisconnectedBy(\"\",\"\");\n        // regex to remove commented reason base string\n        String gsub1 = \"^\" + gsub_base + \"[\\\\w\\\\W]* \\\\: \";\n        // regex to remove non-commented reason base string\n        String gsub2 = \"^\" + gsub_base + \"[\\\\w\\\\W]*\";\n\n        String newString = offlineCause.toString().replaceAll(gsub1, \"\");\n        return newString.replaceAll(gsub2, \"\");\n    }\n\n    /**\n     * Gets the channel that can be used to run a program on this computer.\n     *\n     * @return\n     *      never null when {@link #isOffline()}==false.\n     */\n    public abstract @Nullable VirtualChannel getChannel();\n\n    /**\n     * Gets the default charset of this computer.\n     *\n     * @return\n     *      never null when {@link #isOffline()}==false.\n     */\n    public abstract Charset getDefaultCharset();\n\n    /**\n     * Gets the logs recorded by this slave.\n     */\n    public abstract List<LogRecord> getLogRecords() throws IOException, InterruptedException;\n\n    /**\n     * If {@link #getChannel()}==null, attempts to relaunch the slave agent.\n     */\n    public abstract void doLaunchSlaveAgent( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException;\n\n    /**\n     * @deprecated since 2009-01-06.  Use {@link #connect(boolean)}\n     */\n    @Deprecated\n    public final void launch() {\n        connect(true);\n    }\n\n    /**\n     * Do the same as {@link #doLaunchSlaveAgent(StaplerRequest, StaplerResponse)}\n     * but outside the context of serving a request.\n     *\n     * <p>\n     * If already connected or if this computer doesn't support proactive launching, no-op.\n     * This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @see #disconnect()\n     *\n     * @param forceReconnect\n     *      If true and a connect activity is already in progress, it will be cancelled and\n     *      the new one will be started. If false, and a connect activity is already in progress, this method\n     *      will do nothing and just return the pending connection operation.\n     * @return\n     *      A {@link Future} representing pending completion of the task. The 'completion' includes\n     *      both a successful completion and a non-successful completion (such distinction typically doesn't\n     *      make much sense because as soon as {@link Computer} is connected it can be disconnected by some other threads.)\n     */\n    public final Future<?> connect(boolean forceReconnect) {\n    \tconnectTime = System.currentTimeMillis();\n    \treturn _connect(forceReconnect);\n    }\n\n    /**\n     * Allows implementing-classes to provide an implementation for the connect method.\n     *\n     * <p>\n     * If already connected or if this computer doesn't support proactive launching, no-op.\n     * This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @see #disconnect()\n     *\n     * @param forceReconnect\n     *      If true and a connect activity is already in progress, it will be cancelled and\n     *      the new one will be started. If false, and a connect activity is already in progress, this method\n     *      will do nothing and just return the pending connection operation.\n     * @return\n     *      A {@link Future} representing pending completion of the task. The 'completion' includes\n     *      both a successful completion and a non-successful completion (such distinction typically doesn't\n     *      make much sense because as soon as {@link Computer} is connected it can be disconnected by some other threads.)\n     */\n    protected abstract Future<?> _connect(boolean forceReconnect);\n\n    /**\n     * CLI command to reconnect this node.\n     */\n    @CLIMethod(name=\"connect-node\")\n    public void cliConnect(@Option(name=\"-f\",usage=\"Cancel any currently pending connect operation and retry from scratch\") boolean force) throws ExecutionException, InterruptedException {\n        checkPermission(CONNECT);\n        connect(force).get();\n    }\n\n    /**\n     * Gets the time (since epoch) when this computer connected.\n     *\n     * @return The time in ms since epoch when this computer last connected.\n     */\n    public final long getConnectTime() {\n    \treturn connectTime;\n    }\n\n    /**\n     * Disconnect this computer.\n     *\n     * If this is the master, no-op. This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @param cause\n     *      Object that identifies the reason the node was disconnected.\n     *\n     * @return\n     *      {@link Future} to track the asynchronous disconnect operation.\n     * @see #connect(boolean)\n     * @since 1.320\n     */\n    public Future<?> disconnect(OfflineCause cause) {\n        recordTermination();\n        offlineCause = cause;\n        if (Util.isOverridden(Computer.class,getClass(),\"disconnect\"))\n            return disconnect();    // legacy subtypes that extend disconnect().\n\n        connectTime=0;\n        return Futures.precomputed(null);\n    }\n\n    /**\n     * Equivalent to {@code disconnect(null)}\n     *\n     * @deprecated as of 1.320.\n     *      Use {@link #disconnect(OfflineCause)} and specify the cause.\n     */\n    @Deprecated\n    public Future<?> disconnect() {\n        recordTermination();\n        if (Util.isOverridden(Computer.class,getClass(),\"disconnect\",OfflineCause.class))\n            // if the subtype already derives disconnect(OfflineCause), delegate to it\n            return disconnect(null);\n\n        connectTime=0;\n        return Futures.precomputed(null);\n    }\n\n    /**\n     * CLI command to disconnects this node.\n     */\n    @CLIMethod(name=\"disconnect-node\")\n    public void cliDisconnect(@Option(name=\"-m\",usage=\"Record the note about why you are disconnecting this node\") String cause) throws ExecutionException, InterruptedException {\n        checkPermission(DISCONNECT);\n        disconnect(new ByCLI(cause)).get();\n    }\n\n    /**\n     * CLI command to mark the node offline.\n     */\n    @CLIMethod(name=\"offline-node\")\n    public void cliOffline(@Option(name=\"-m\",usage=\"Record the note about why you are disconnecting this node\") String cause) throws ExecutionException, InterruptedException {\n        checkPermission(DISCONNECT);\n        setTemporarilyOffline(true, new ByCLI(cause));\n    }\n\n    @CLIMethod(name=\"online-node\")\n    public void cliOnline() throws ExecutionException, InterruptedException {\n        checkPermission(CONNECT);\n        setTemporarilyOffline(false, null);\n    }\n\n    /**\n     * Number of {@link Executor}s that are configured for this computer.\n     *\n     * <p>\n     * When this value is decreased, it is temporarily possible\n     * for {@link #executors} to have a larger number than this.\n     */\n    // ugly name to let EL access this\n    @Exported\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    /**\n     * Returns {@link Node#getNodeName() the name of the node}.\n     */\n    public @Nonnull String getName() {\n        return nodeName != null ? nodeName : \"\";\n    }\n\n    /**\n     * True if this computer is a Unix machine (as opposed to Windows machine).\n     *\n     * @since 1.624\n     * @return\n     *      null if the computer is disconnected and therefore we don't know whether it is Unix or not.\n     */\n    public abstract @CheckForNull Boolean isUnix();\n\n    /**\n     * Returns the {@link Node} that this computer represents.\n     *\n     * @return\n     *      null if the configuration has changed and the node is removed, yet the corresponding {@link Computer}\n     *      is not yet gone.\n     */\n    public @CheckForNull Node getNode() {\n        Jenkins j = Jenkins.getInstance();\n        if (j == null) {\n            return null;\n        }\n        if (nodeName == null) {\n            return j;\n        }\n        return j.getNode(nodeName);\n    }\n\n    @Exported\n    public LoadStatistics getLoadStatistics() {\n        return LabelAtom.get(nodeName != null ? nodeName : Jenkins.getInstance().getSelfLabel().toString()).loadStatistics;\n    }\n\n    public BuildTimelineWidget getTimeline() {\n        return new BuildTimelineWidget(getBuilds());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskAccepted(Executor executor, Queue.Task task) {\n        // dummy implementation\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskCompleted(Executor executor, Queue.Task task, long durationMS) {\n        // dummy implementation\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskCompletedWithProblems(Executor executor, Queue.Task task, long durationMS, Throwable problems) {\n        // dummy implementation\n    }\n\n    @Exported\n    public boolean isOffline() {\n        return temporarilyOffline || getChannel()==null;\n    }\n\n    public final boolean isOnline() {\n        return !isOffline();\n    }\n\n    /**\n     * This method is called to determine whether manual launching of the slave is allowed at this point in time.\n     * @return {@code true} if manual launching of the slave is allowed at this point in time.\n     */\n    @Exported\n    public boolean isManualLaunchAllowed() {\n        return getRetentionStrategy().isManualLaunchAllowed(this);\n    }\n\n\n    /**\n     * Is a {@link #connect(boolean)} operation in progress?\n     */\n    public abstract boolean isConnecting();\n\n    /**\n     * Returns true if this computer is supposed to be launched via JNLP.\n     * @deprecated since 2008-05-18.\n     *     See {@linkplain #isLaunchSupported()} and {@linkplain ComputerLauncher}\n     */\n    @Exported\n    @Deprecated\n    public boolean isJnlpAgent() {\n        return false;\n    }\n\n    /**\n     * Returns true if this computer can be launched by Hudson proactively and automatically.\n     *\n     * <p>\n     * For example, JNLP slaves return {@code false} from this, because the launch process\n     * needs to be initiated from the slave side.\n     */\n    @Exported\n    public boolean isLaunchSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true if this node is marked temporarily offline by the user.\n     *\n     * <p>\n     * In contrast, {@link #isOffline()} represents the actual online/offline\n     * state. For example, this method may return false while {@link #isOffline()}\n     * returns true if the slave agent failed to launch.\n     *\n     * @deprecated\n     *      You should almost always want {@link #isOffline()}.\n     *      This method is marked as deprecated to warn people when they\n     *      accidentally call this method.\n     */\n    @Exported\n    @Deprecated\n    public boolean isTemporarilyOffline() {\n        return temporarilyOffline;\n    }\n\n    /**\n     * @deprecated as of 1.320.\n     *      Use {@link #setTemporarilyOffline(boolean, OfflineCause)}\n     */\n    @Deprecated\n    public void setTemporarilyOffline(boolean temporarilyOffline) {\n        setTemporarilyOffline(temporarilyOffline,null);\n    }\n\n    /**\n     * Marks the computer as temporarily offline. This retains the underlying\n     * {@link Channel} connection, but prevent builds from executing.\n     *\n     * @param cause\n     *      If the first argument is true, specify the reason why the node is being put\n     *      offline.\n     */\n    public void setTemporarilyOffline(boolean temporarilyOffline, OfflineCause cause) {\n        offlineCause = temporarilyOffline ? cause : null;\n        this.temporarilyOffline = temporarilyOffline;\n        Node node = getNode();\n        if (node != null) {\n            node.setTemporaryOfflineCause(offlineCause);\n        }\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n        synchronized (statusChangeLock) {\n            statusChangeLock.notifyAll();\n        }\n        for (ComputerListener cl : ComputerListener.all()) {\n            if (temporarilyOffline)     cl.onTemporarilyOffline(this,cause);\n            else                        cl.onTemporarilyOnline(this);\n        }\n    }\n\n    @Exported\n    public String getIcon() {\n        if(isOffline())\n            return \"computer-x.png\";\n        else\n            return \"computer.png\";\n    }\n\n    @Exported\n    public String getIconClassName() {\n        if(isOffline())\n            return \"icon-computer-x\";\n        else\n            return \"icon-computer\";\n    }\n\n    public String getIconAltText() {\n        if(isOffline())\n            return \"[offline]\";\n        else\n            return \"[online]\";\n    }\n\n    @Exported\n    @Override public @Nonnull String getDisplayName() {\n        return nodeName;\n    }\n\n    public String getCaption() {\n        return Messages.Computer_Caption(nodeName);\n    }\n\n    public String getUrl() {\n        return \"computer/\" + Util.rawEncode(getName()) + \"/\";\n    }\n\n    /**\n     * Returns projects that are tied on this node.\n     */\n    public List<AbstractProject> getTiedJobs() {\n        Node node = getNode();\n        return (node != null) ? node.getSelfLabel().getTiedJobs() : Collections.EMPTY_LIST;\n    }\n\n    public RunList getBuilds() {\n    \treturn new RunList(Jenkins.getInstance().getAllItems(Job.class)).node(getNode());\n    }\n\n    /**\n     * Called to notify {@link Computer} that its corresponding {@link Node}\n     * configuration is updated.\n     */\n    protected void setNode(Node node) {\n        assert node!=null;\n        if(node instanceof Slave)\n            this.nodeName = node.getNodeName();\n        else\n            this.nodeName = null;\n\n        setNumExecutors(node.getNumExecutors());\n        if (this.temporarilyOffline) {\n            // When we get a new node, push our current temp offline\n            // status to it (as the status is not carried across\n            // configuration changes that recreate the node).\n            // Since this is also called the very first time this\n            // Computer is created, avoid pushing an empty status\n            // as that could overwrite any status that the Node\n            // brought along from its persisted config data.\n            node.setTemporaryOfflineCause(this.offlineCause);\n        }\n    }\n\n    /**\n     * Called by {@link Jenkins#updateComputerList()} to notify {@link Computer} that it will be discarded.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * @see #onRemoved()\n     */\n    protected void kill() {\n        // On most code paths, this should already be zero, and thus this next call becomes a no-op... and more\n        // importantly it will not acquire a lock on the Queue... not that the lock is bad, more that the lock\n        // may delay unnecessarily\n        setNumExecutors(0);\n    }\n\n    /**\n     * Called by {@link Jenkins#updateComputerList()} to notify {@link Computer} that it will be discarded.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * <p>\n     * Note that the Queue lock is already held when this method is called.\n     *\n     * @see #onRemoved()\n     */\n    @Restricted(NoExternalUse.class)\n    @GuardedBy(\"hudson.model.Queue.lock\")\n    /*package*/ void inflictMortalWound() {\n        setNumExecutors(0);\n    }\n\n    /**\n     * Called by {@link Jenkins} when this computer is removed.\n     *\n     * <p>\n     * This happens when list of nodes are updated (for example by {@link Jenkins#setNodes(List)} and\n     * the computer becomes redundant. Such {@link Computer}s get {@linkplain #kill() killed}, then\n     * after all its executors are finished, this method is called.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * @see #kill()\n     * @since 1.510\n     */\n    protected void onRemoved(){\n    }\n\n    private synchronized void setNumExecutors(int n) {\n        this.numExecutors = n;\n        final int diff = executors.size()-n;\n\n        if (diff>0) {\n            // we have too many executors\n            // send signal to all idle executors to potentially kill them off\n            // need the Queue maintenance lock held to prevent concurrent job assignment on the idle executors\n            Queue.withLock(new Runnable() {\n                @Override\n                public void run() {\n                    for( Executor e : executors )\n                        if(e.isIdle())\n                            e.interrupt();\n                }\n            });\n        }\n\n        if (diff<0) {\n            // if the number is increased, add new ones\n            addNewExecutorIfNecessary();\n        }\n    }\n\n    private void addNewExecutorIfNecessary() {\n        Set<Integer> availableNumbers  = new HashSet<Integer>();\n        for (int i = 0; i < numExecutors; i++)\n            availableNumbers.add(i);\n\n        for (Executor executor : executors)\n            availableNumbers.remove(executor.getNumber());\n\n        for (Integer number : availableNumbers) {\n            /* There may be busy executors with higher index, so only\n               fill up until numExecutors is reached.\n               Extra executors will call removeExecutor(...) and that\n               will create any necessary executors from #0 again. */\n            if (executors.size() < numExecutors) {\n                Executor e = new Executor(this, number);\n                executors.add(e);\n            }\n        }\n\n    }\n\n    /**\n     * Returns the number of idle {@link Executor}s that can start working immediately.\n     */\n    public int countIdle() {\n        int n = 0;\n        for (Executor e : executors) {\n            if(e.isIdle())\n                n++;\n        }\n        return n;\n    }\n\n    /**\n     * Returns the number of {@link Executor}s that are doing some work right now.\n     */\n    public final int countBusy() {\n        return countExecutors()-countIdle();\n    }\n\n    /**\n     * Returns the current size of the executor pool for this computer.\n     * This number may temporarily differ from {@link #getNumExecutors()} if there\n     * are busy tasks when the configured size is decreased.  OneOffExecutors are\n     * not included in this count.\n     */\n    public final int countExecutors() {\n        return executors.size();\n    }\n\n    /**\n     * Gets the read-only snapshot view of all {@link Executor}s.\n     */\n    @Exported\n    public List<Executor> getExecutors() {\n        return new ArrayList<Executor>(executors);\n    }\n\n    /**\n     * Gets the read-only snapshot view of all {@link OneOffExecutor}s.\n     */\n    @Exported\n    public List<OneOffExecutor> getOneOffExecutors() {\n        return new ArrayList<OneOffExecutor>(oneOffExecutors);\n    }\n\n    /**\n     * Used to render the list of executors.\n     * @return a snapshot of the executor display information\n     * @since 1.607\n     */\n    @Restricted(NoExternalUse.class)\n    public List<DisplayExecutor> getDisplayExecutors() {\n        // The size may change while we are populating, but let's start with a reasonable guess to minimize resizing\n        List<DisplayExecutor> result = new ArrayList<DisplayExecutor>(executors.size()+oneOffExecutors.size());\n        int index = 0;\n        for (Executor e: executors) {\n            if (e.isDisplayCell()) {\n                result.add(new DisplayExecutor(Integer.toString(index + 1), String.format(\"executors/%d\", index), e));\n            }\n            index++;\n        }\n        index = 0;\n        for (OneOffExecutor e: oneOffExecutors) {\n            if (e.isDisplayCell()) {\n                result.add(new DisplayExecutor(\"\", String.format(\"oneOffExecutors/%d\", index), e));\n            }\n            index++;\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if all the executors of this computer are idle.\n     */\n    @Exported\n    public final boolean isIdle() {\n        if (!oneOffExecutors.isEmpty())\n            return false;\n        for (Executor e : executors)\n            if(!e.isIdle())\n                return false;\n        return true;\n    }\n\n    /**\n     * Returns true if this computer has some idle executors that can take more workload.\n     */\n    public final boolean isPartiallyIdle() {\n        for (Executor e : executors)\n            if(e.isIdle())\n                return true;\n        return false;\n    }\n\n    /**\n     * Returns the time when this computer last became idle.\n     *\n     * <p>\n     * If this computer is already idle, the return value will point to the\n     * time in the past since when this computer has been idle.\n     *\n     * <p>\n     * If this computer is busy, the return value will point to the\n     * time in the future where this computer will be expected to become free.\n     */\n    public final long getIdleStartMilliseconds() {\n        long firstIdle = Long.MIN_VALUE;\n        for (Executor e : oneOffExecutors) {\n            firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\n        }\n        for (Executor e : executors) {\n            firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\n        }\n        return firstIdle;\n    }\n\n    /**\n     * Returns the time when this computer first became in demand.\n     */\n    public final long getDemandStartMilliseconds() {\n        long firstDemand = Long.MAX_VALUE;\n        for (Queue.BuildableItem item : Jenkins.getInstance().getQueue().getBuildableItems(this)) {\n            firstDemand = Math.min(item.buildableStartMilliseconds, firstDemand);\n        }\n        return firstDemand;\n    }\n\n    /**\n     * Called by {@link Executor} to kill excessive executors from this computer.\n     */\n    /*package*/ void removeExecutor(final Executor e) {\n        final Runnable task = new Runnable() {\n            @Override\n            public void run() {\n                synchronized (Computer.this) {\n                    executors.remove(e);\n                    addNewExecutorIfNecessary();\n                    if (!isAlive()) {\n                        AbstractCIBase ciBase = Jenkins.getInstance();\n                        if (ciBase != null) {\n                            ciBase.removeComputer(Computer.this);\n                        }\n                    }\n                }\n            }\n        };\n        if (!Queue.tryWithLock(task)) {\n            // JENKINS-28840 if we couldn't get the lock push the operation to a separate thread to avoid deadlocks\n            threadPoolForRemoting.submit(Queue.wrapWithLock(task));\n        }\n    }\n\n    /**\n     * Returns true if any of the executors are {@linkplain Executor#isActive active}.\n     *\n     * Note that if an executor dies, we'll leave it in {@link #executors} until\n     * the administrator yanks it out, so that we can see why it died.\n     *\n     * @since 1.509\n     */\n    protected boolean isAlive() {\n        for (Executor e : executors)\n            if (e.isActive())\n                return true;\n        return false;\n    }\n\n    /**\n     * Interrupt all {@link Executor}s.\n     * Called from {@link Jenkins#cleanUp}.\n     */\n    public void interrupt() {\n        Queue.withLock(new Runnable() {\n            @Override\n            public void run() {\n                for (Executor e : executors) {\n                    e.interruptForShutdown();\n                }\n            }\n        });\n    }\n\n    public String getSearchUrl() {\n        return getUrl();\n    }\n\n    /**\n     * {@link RetentionStrategy} associated with this computer.\n     *\n     * @return\n     *      never null. This method return {@code RetentionStrategy<? super T>} where\n     *      {@code T=this.getClass()}.\n     */\n    public abstract RetentionStrategy getRetentionStrategy();\n\n    /**\n     * Expose monitoring data for the remote API.\n     */\n    @Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        for (NodeMonitor monitor : NodeMonitor.getAll())\n            r.put(monitor.getClass().getName(),monitor.data(this));\n        return r;\n    }\n\n    /**\n     * Gets the system properties of the JVM on this computer.\n     * If this is the master, it returns the system property of the master computer.\n     */\n    public Map<Object,Object> getSystemProperties() throws IOException, InterruptedException {\n        return RemotingDiagnostics.getSystemProperties(getChannel());\n    }\n\n    /**\n     * @deprecated as of 1.292\n     *      Use {@link #getEnvironment()} instead.\n     */\n    @Deprecated\n    public Map<String,String> getEnvVars() throws IOException, InterruptedException {\n        return getEnvironment();\n    }\n\n    /**\n     * Returns cached environment variables (copy to prevent modification) for the JVM on this computer.\n     * If this is the master, it returns the system property of the master computer.\n     */\n    public EnvVars getEnvironment() throws IOException, InterruptedException {\n        EnvVars cachedEnvironment = this.cachedEnvironment;\n        if (cachedEnvironment != null) {\n            return new EnvVars(cachedEnvironment);\n        }\n\n        cachedEnvironment = EnvVars.getRemote(getChannel());\n        this.cachedEnvironment = cachedEnvironment;\n        return new EnvVars(cachedEnvironment);\n    }\n\n    /**\n     * Creates an environment variable override to be used for launching processes on this node.\n     *\n     * @see ProcStarter#envs(Map)\n     * @since 1.489\n     */\n    public @Nonnull EnvVars buildEnvironment(@Nonnull TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env = new EnvVars();\n\n        Node node = getNode();\n        if (node==null)     return env; // bail out\n\n        for (NodeProperty nodeProperty: Jenkins.getInstance().getGlobalNodeProperties()) {\n            nodeProperty.buildEnvVars(env,listener);\n        }\n\n        for (NodeProperty nodeProperty: node.getNodeProperties()) {\n            nodeProperty.buildEnvVars(env,listener);\n        }\n\n        // TODO: hmm, they don't really belong\n        String rootUrl = Jenkins.getInstance().getRootUrl();\n        if(rootUrl!=null) {\n            env.put(\"HUDSON_URL\", rootUrl); // Legacy.\n            env.put(\"JENKINS_URL\", rootUrl);\n        }\n\n        return env;\n    }\n\n    /**\n     * Gets the thread dump of the slave JVM.\n     * @return\n     *      key is the thread name, and the value is the pre-formatted dump.\n     */\n    public Map<String,String> getThreadDump() throws IOException, InterruptedException {\n        return RemotingDiagnostics.getThreadDump(getChannel());\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,getChannel());\n    }\n\n    /**\n     * This method tries to compute the name of the host that's reachable by all the other nodes.\n     *\n     * <p>\n     * Since it's possible that the slave is not reachable from the master (it may be behind a firewall,\n     * connecting to master via JNLP), this method may return null.\n     *\n     * It's surprisingly tricky for a machine to know a name that other systems can get to,\n     * especially between things like DNS search suffix, the hosts file, and YP.\n     *\n     * <p>\n     * So the technique here is to compute possible interfaces and names on the slave,\n     * then try to ping them from the master, and pick the one that worked.\n     *\n     * <p>\n     * The computation may take some time, so it employs caching to make the successive lookups faster.\n     *\n     * @since 1.300\n     * @return\n     *      null if the host name cannot be computed (for example because this computer is offline,\n     *      because the slave is behind the firewall, etc.)\n     */\n    public String getHostName() throws IOException, InterruptedException {\n        if(hostNameCached)\n            // in the worst case we end up having multiple threads computing the host name simultaneously, but that's not harmful, just wasteful.\n            return cachedHostName;\n\n        VirtualChannel channel = getChannel();\n        if(channel==null)   return null; // can't compute right now\n\n        for( String address : channel.call(new ListPossibleNames())) {\n            try {\n                InetAddress ia = InetAddress.getByName(address);\n                if(!(ia instanceof Inet4Address)) {\n                    LOGGER.log(Level.FINE, \"{0} is not an IPv4 address\", address);\n                    continue;\n                }\n                if(!ComputerPinger.checkIsReachable(ia, 3)) {\n                    LOGGER.log(Level.FINE, \"{0} didn't respond to ping\", address);\n                    continue;\n                }\n                cachedHostName = ia.getCanonicalHostName();\n                hostNameCached = true;\n                return cachedHostName;\n            } catch (IOException e) {\n                // if a given name fails to parse on this host, we get this error\n                LogRecord lr = new LogRecord(Level.FINE, \"Failed to parse {0}\");\n                lr.setThrown(e);\n                lr.setParameters(new Object[]{address});\n                LOGGER.log(lr);\n            }\n        }\n\n        // allow the administrator to manually specify the host name as a fallback. HUDSON-5373\n        cachedHostName = channel.call(new GetFallbackName());\n        hostNameCached = true;\n        return cachedHostName;\n    }\n\n    /**\n     * Starts executing a fly-weight task.\n     */\n    /*package*/ final void startFlyWeightTask(WorkUnit p) {\n        OneOffExecutor e = new OneOffExecutor(this);\n        e.start(p);\n        oneOffExecutors.add(e);\n    }\n\n    /*package*/ final void remove(OneOffExecutor e) {\n        oneOffExecutors.remove(e);\n    }\n\n    private static class ListPossibleNames extends MasterToSlaveCallable<List<String>,IOException> {\n        /**\n         * In the normal case we would use {@link Computer} as the logger's name, however to\n         * do that we would have to send the {@link Computer} class over to the remote classloader\n         * and then it would need to be loaded, which pulls in {@link Jenkins} and loads that\n         * and then that fails to load as you are not supposed to do that. Another option\n         * would be to export the logger over remoting, with increased complexity as a result.\n         * Instead we just use a loger based on this class name and prevent any references to\n         * other classes from being transferred over remoting.\n         */\n        private static final Logger LOGGER = Logger.getLogger(ListPossibleNames.class.getName());\n        \n        public List<String> call() throws IOException {\n            List<String> names = new ArrayList<String>();\n\n            Enumeration<NetworkInterface> nis = NetworkInterface.getNetworkInterfaces();\n            while (nis.hasMoreElements()) {\n                NetworkInterface ni =  nis.nextElement();\n                LOGGER.log(Level.FINE, \"Listing up IP addresses for {0}\", ni.getDisplayName());\n                Enumeration<InetAddress> e = ni.getInetAddresses();\n                while (e.hasMoreElements()) {\n                    InetAddress ia =  e.nextElement();\n                    if(ia.isLoopbackAddress()) {\n                        LOGGER.log(Level.FINE, \"{0} is a loopback address\", ia);\n                        continue;\n                    }\n\n                    if(!(ia instanceof Inet4Address)) {\n                        LOGGER.log(Level.FINE, \"{0} is not an IPv4 address\", ia);\n                        continue;\n                    }\n\n                    LOGGER.log(Level.FINE, \"{0} is a viable candidate\", ia);\n                    names.add(ia.getHostAddress());\n                }\n            }\n            return names;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static class GetFallbackName extends MasterToSlaveCallable<String,IOException> {\n        public String call() throws IOException {\n            return System.getProperty(\"host.name\");\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    public static final ExecutorService threadPoolForRemoting = new ContextResettingExecutorService(\n            Executors.newCachedThreadPool(\n                    new ExceptionCatchingThreadFactory(\n                            new NamingThreadFactory(new DaemonThreadFactory(), \"Computer.threadPoolForRemoting\"))));\n\n//\n//\n// UI\n//\n//\n    public void doRssAll( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds());\n    }\n\n    public void doRssFailed(StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" failed builds\", getBuilds().failureOnly());\n    }\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs) throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName() + suffix, getUrl(),\n                runs.newBuilds(), Run.FEED_ADAPTER, req, rsp);\n    }\n\n    @RequirePOST\n    public HttpResponse doToggleOffline(@QueryParameter String offlineMessage) throws IOException, ServletException {\n        if(!temporarilyOffline) {\n            checkPermission(DISCONNECT);\n            offlineMessage = Util.fixEmptyAndTrim(offlineMessage);\n            setTemporarilyOffline(!temporarilyOffline,\n                    new OfflineCause.UserCause(User.current(), offlineMessage));\n        } else {\n            checkPermission(CONNECT);\n            setTemporarilyOffline(!temporarilyOffline,null);\n        }\n        return HttpResponses.redirectToDot();\n    }\n\n    @RequirePOST\n    public HttpResponse doChangeOfflineCause(@QueryParameter String offlineMessage) throws IOException, ServletException {\n        checkPermission(DISCONNECT);\n        offlineMessage = Util.fixEmptyAndTrim(offlineMessage);\n        setTemporarilyOffline(true,\n                new OfflineCause.UserCause(User.current(), offlineMessage));\n        return HttpResponses.redirectToDot();\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Dumps the contents of the export table.\n     */\n    public void doDumpExportTable( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        // this is a debug probe and may expose sensitive information\n        checkPermission(Jenkins.ADMINISTER);\n\n        rsp.setContentType(\"text/plain\");\n        PrintWriter w = new PrintWriter(rsp.getCompressedWriter(req));\n        VirtualChannel vc = getChannel();\n        if (vc instanceof Channel) {\n            w.println(\"Master to slave\");\n            ((Channel)vc).dumpExportTable(w);\n            w.flush(); // flush here once so that even if the dump from the slave fails, the client gets some useful info\n\n            w.println(\"\\n\\n\\nSlave to master\");\n            w.print(vc.call(new DumpExportTableTask()));\n        } else {\n            w.println(Messages.Computer_BadChannel());\n        }\n        w.close();\n    }\n\n    private static final class DumpExportTableTask extends MasterToSlaveCallable<String,IOException> {\n        public String call() throws IOException {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            Channel.current().dumpExportTable(pw);\n            pw.close();\n            return sw.toString();\n        }\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, \"_script.jelly\");\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, \"_scriptText.jelly\");\n    }\n\n    protected void _doScript(StaplerRequest req, StaplerResponse rsp, String view) throws IOException, ServletException {\n        Jenkins._doScript(req, rsp, req.getView(this, view), getChannel(), getACL());\n    }\n\n    /**\n     * Accepts the update to the node configuration.\n     */\n    @RequirePOST\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        String name = Util.fixEmptyAndTrim(req.getSubmittedForm().getString(\"name\"));\n        Jenkins.checkGoodName(name);\n\n        Node node = getNode();\n        if (node == null) {\n            throw new ServletException(\"No such node \" + nodeName);\n        }\n        Node result = node.reconfigure(req, req.getSubmittedForm());\n        replaceBy(result);\n\n        // take the user back to the slave top page.\n        rsp.sendRedirect2(\"../\" + result.getNodeName() + '/');\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp)\n            throws IOException, ServletException {\n\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            checkPermission(EXTENDED_READ);\n            rsp.setContentType(\"application/xml\");\n            Node node = getNode();\n            if (node == null) {\n                throw HttpResponses.notFound();\n            }\n            Jenkins.XSTREAM2.toXMLUTF8(node, rsp.getOutputStream());\n            return;\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml(req.getInputStream());\n            return;\n        }\n\n        // huh?\n        rsp.sendError(SC_BAD_REQUEST);\n    }\n\n    /**\n     * Replaces the current {@link Node} by another one.\n     */\n    private void replaceBy(final Node newNode) throws ServletException, IOException {\n        final Jenkins app = Jenkins.getInstance();\n\n        // use the queue lock until Nodes has a way of directly modifying a single node.\n        Queue.withLock(new NotReallyRoleSensitiveCallable<Void, IOException>() {\n            public Void call() throws IOException {\n                List<Node> nodes = new ArrayList<Node>(app.getNodes());\n                Node node = getNode();\n                int i  = (node != null) ? nodes.indexOf(node) : -1;\n                if(i<0) {\n                    throw new IOException(\"This slave appears to be removed while you were editing the configuration\");\n                }\n                nodes.set(i, newNode);\n                app.setNodes(nodes);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Updates Job by its XML definition.\n     *\n     * @since 1.526\n     */\n    public void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        replaceBy(result);\n    }\n\n    /**\n     * Really deletes the slave.\n     */\n    @RequirePOST\n    public HttpResponse doDoDelete() throws IOException {\n        checkPermission(DELETE);\n        Node node = getNode();\n        if (node != null) {\n            Jenkins.getInstance().removeNode(node);\n        } else {\n            AbstractCIBase app = Jenkins.getInstance();\n            app.removeComputer(this);\n        }\n        return new HttpRedirect(\"..\");\n    }\n\n    /**\n     * Blocks until the node becomes online/offline.\n     */\n    @CLIMethod(name=\"wait-node-online\")\n    public void waitUntilOnline() throws InterruptedException {\n        synchronized (statusChangeLock) {\n            while (!isOnline())\n                statusChangeLock.wait(1000);\n        }\n    }\n\n    @CLIMethod(name=\"wait-node-offline\")\n    public void waitUntilOffline() throws InterruptedException {\n        synchronized (statusChangeLock) {\n            while (!isOffline())\n                statusChangeLock.wait(1000);\n        }\n    }\n\n    /**\n     * Handles incremental log.\n     */\n    public void doProgressiveLog( StaplerRequest req, StaplerResponse rsp) throws IOException {\n        getLogText().doProgressText(req, rsp);\n    }\n\n    /**\n     * Gets the current {@link Computer} that the build is running.\n     * This method only works when called during a build, such as by\n     * {@link hudson.tasks.Publisher}, {@link hudson.tasks.BuildWrapper}, etc.\n     * @return the {@link Computer} associated with {@link Executor#currentExecutor}, or (consistently as of 1.591) null if not on an executor thread\n     */\n    public static @Nullable Computer currentComputer() {\n        Executor e = Executor.currentExecutor();\n        return e != null ? e.getOwner() : null;\n    }\n\n    /**\n     * Returns {@code true} if the computer is accepting tasks. Needed to allow slaves programmatic suspension of task\n     * scheduling that does not overlap with being offline.\n     *\n     * @return {@code true} if the computer is accepting tasks\n     * @see hudson.slaves.RetentionStrategy#isAcceptingTasks(Computer)\n     * @see hudson.model.Node#isAcceptingTasks()\n     */\n    @OverrideMustInvoke(When.ANYTIME)\n    public boolean isAcceptingTasks() {\n        final Node node = getNode();\n        return getRetentionStrategy().isAcceptingTasks(this) && (node == null || node.isAcceptingTasks());\n    }\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static Computer resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Slave name, or empty string for master\") String name) throws CmdLineException {\n        Jenkins h = Jenkins.getInstance();\n        Computer item = h.getComputer(name);\n        if (item==null) {\n            List<String> names = new ArrayList<String>();\n            for (Computer c : h.getComputers())\n                if (c.getName().length()>0)\n                    names.add(c.getName());\n            throw new CmdLineException(null,Messages.Computer_NoSuchSlaveExists(name,EditDistance.findNearest(name,names)));\n        }\n        return item;\n    }\n\n    /**\n     * Relocate log files in the old location to the new location.\n     *\n     * Files were used to be $JENKINS_ROOT/slave-NAME.log (and .1, .2, ...)\n     * but now they are at $JENKINS_ROOT/logs/slaves/NAME/slave.log (and .1, .2, ...)\n     *\n     * @see #getLogFile()\n     */\n    @Initializer\n    public static void relocateOldLogs() {\n        relocateOldLogs(Jenkins.getInstance().getRootDir());\n    }\n\n    /*package*/ static void relocateOldLogs(File dir) {\n        final Pattern logfile = Pattern.compile(\"slave-(.*)\\\\.log(\\\\.[0-9]+)?\");\n        File[] logfiles = dir.listFiles(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n                return logfile.matcher(name).matches();\n            }\n        });\n        if (logfiles==null)     return;\n\n        for (File f : logfiles) {\n            Matcher m = logfile.matcher(f.getName());\n            if (m.matches()) {\n                File newLocation = new File(dir, \"logs/slaves/\" + m.group(1) + \"/slave.log\" + Util.fixNull(m.group(2)));\n                newLocation.getParentFile().mkdirs();\n                boolean relocationSuccessfull=f.renameTo(newLocation);\n                if (relocationSuccessfull) { // The operation will fail if mkdir fails\n                    LOGGER.log(Level.INFO, \"Relocated log file {0} to {1}\",new Object[] {f.getPath(),newLocation.getPath()});\n                } else {\n                    LOGGER.log(Level.WARNING, \"Cannot relocate log file {0} to {1}\",new Object[] {f.getPath(),newLocation.getPath()});\n                }\n            } else {\n                assert false;\n            }\n        }\n    }\n\n    /**\n     * A value class to provide a consistent snapshot view of the state of an executor to avoid race conditions\n     * during rendering of the executors list.\n     *\n     * @since 1.607\n     */\n    @Restricted(NoExternalUse.class)\n    public static class DisplayExecutor implements ModelObject {\n\n        @Nonnull\n        private final String displayName;\n        @Nonnull\n        private final String url;\n        @Nonnull\n        private final Executor executor;\n\n        public DisplayExecutor(@Nonnull String displayName, @Nonnull String url, @Nonnull Executor executor) {\n            this.displayName = displayName;\n            this.url = url;\n            this.executor = executor;\n        }\n\n        @Override\n        @Nonnull\n        public String getDisplayName() {\n            return displayName;\n        }\n\n        @Nonnull\n        public String getUrl() {\n            return url;\n        }\n\n        @Nonnull\n        public Executor getExecutor() {\n            return executor;\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder(\"DisplayExecutor{\");\n            sb.append(\"displayName='\").append(displayName).append('\\'');\n            sb.append(\", url='\").append(url).append('\\'');\n            sb.append(\", executor=\").append(executor);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            DisplayExecutor that = (DisplayExecutor) o;\n\n            if (!executor.equals(that.executor)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        @Extension(ordinal = Double.MAX_VALUE)\n        @Restricted(DoNotUse.class)\n        public static class InternalComputerListener extends ComputerListener {\n            @Override\n            public void onOnline(Computer c, TaskListener listener) throws IOException, InterruptedException {\n                c.cachedEnvironment = null;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return executor.hashCode();\n        }\n    }\n\n    /**\n     * Used to trace requests to terminate a computer.\n     *\n     * @since 1.607\n     */\n    public static class TerminationRequest extends RuntimeException {\n        private final long when;\n        public TerminationRequest(String message) {\n            super(message);\n            this.when = System.currentTimeMillis();\n        }\n\n        /**\n         * Returns the when the termination request was created.\n         *\n         * @return the difference, measured in milliseconds, between\n         * the time of the termination request and midnight, January 1, 1970 UTC.\n         */\n        public long getWhen() {\n            return when;\n        }\n    }\n\n    public static final PermissionGroup PERMISSIONS = new PermissionGroup(Computer.class,Messages._Computer_Permissions_Title());\n    public static final Permission CONFIGURE = new Permission(PERMISSIONS,\"Configure\", Messages._Computer_ConfigurePermission_Description(), Permission.CONFIGURE, PermissionScope.COMPUTER);\n    /**\n     * @since 1.532\n     */\n    public static final Permission EXTENDED_READ = new Permission(PERMISSIONS,\"ExtendedRead\", Messages._Computer_ExtendedReadPermission_Description(), CONFIGURE, Boolean.getBoolean(\"hudson.security.ExtendedReadPermission\"), new PermissionScope[]{PermissionScope.COMPUTER});\n    public static final Permission DELETE = new Permission(PERMISSIONS,\"Delete\", Messages._Computer_DeletePermission_Description(), Permission.DELETE, PermissionScope.COMPUTER);\n    public static final Permission CREATE = new Permission(PERMISSIONS,\"Create\", Messages._Computer_CreatePermission_Description(), Permission.CREATE, PermissionScope.COMPUTER);\n    public static final Permission DISCONNECT = new Permission(PERMISSIONS,\"Disconnect\", Messages._Computer_DisconnectPermission_Description(), Jenkins.ADMINISTER, PermissionScope.COMPUTER);\n    public static final Permission CONNECT = new Permission(PERMISSIONS,\"Connect\", Messages._Computer_ConnectPermission_Description(), DISCONNECT, PermissionScope.COMPUTER);\n    public static final Permission BUILD = new Permission(PERMISSIONS, \"Build\", Messages._Computer_BuildPermission_Description(),  Permission.WRITE, PermissionScope.COMPUTER);\n\n    private static final Logger LOGGER = Logger.getLogger(Computer.class.getName());\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2013 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\nimport hudson.security.ACL;\nimport hudson.security.AccessDeniedException2;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.ServletOutputStream;\n\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.DummySecurityRealm;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n/**\n * @author ogondza\n */\npublic class ComputerConfigDotXmlTest {\n\n    @Rule public final JenkinsRule rule = new JenkinsRule();\n\n    @Mock private StaplerRequest req;\n    @Mock private StaplerResponse rsp;\n\n    private Computer computer;\n    private SecurityContext oldSecurityContext;\n\n    @Before\n    public void setUp() throws Exception {\n\n        MockitoAnnotations.initMocks(this);\n        computer = spy(rule.createSlave().toComputer());\n        rule.jenkins.setSecurityRealm(rule.createDummySecurityRealm());\n        oldSecurityContext = ACL.impersonate(User.get(\"user\").impersonate());\n    }\n\n    @After\n    public void tearDown() {\n\n        SecurityContextHolder.setContext(oldSecurityContext);\n    }\n\n    @Test(expected = AccessDeniedException2.class)\n    public void configXmlGetShouldFailForUnauthorized() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"GET\");\n\n        rule.jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy());\n\n        computer.doConfigDotXml(req, rsp);\n    }\n\n    @Test(expected = AccessDeniedException2.class)\n    public void configXmlPostShouldFailForUnauthorized() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"POST\");\n\n        rule.jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy());\n\n        computer.doConfigDotXml(req, rsp);\n    }\n\n    @Test\n    public void configXmlGetShouldYieldNodeConfiguration() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"GET\");\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        rule.jenkins.setAuthorizationStrategy(auth);\n        Computer.EXTENDED_READ.setEnabled(true);\n        auth.add(Computer.EXTENDED_READ, \"user\");\n\n        final OutputStream outputStream = captureOutput();\n\n        computer.doConfigDotXml(req, rsp);\n\n        final String out = outputStream.toString();\n        assertThat(out, startsWith(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"));\n        assertThat(out, containsString(\"<name>slave0</name>\"));\n        assertThat(out, containsString(\"<description>dummy</description>\"));\n    }\n\n    @Test\n    public void configXmlPostShouldUpdateNodeConfiguration() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"POST\");\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        rule.jenkins.setAuthorizationStrategy(auth);\n        auth.add(Computer.CONFIGURE, \"user\");\n\n        when(req.getInputStream()).thenReturn(xmlNode(\"node.xml\"));\n\n        computer.doConfigDotXml(req, rsp);\n\n        final Node updatedSlave = rule.jenkins.getNode(\"SlaveFromXML\");\n        assertThat(updatedSlave.getNodeName(), equalTo(\"SlaveFromXML\"));\n        assertThat(updatedSlave.getNumExecutors(), equalTo(42));\n    }\n\n    private OutputStream captureOutput() throws IOException {\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        when(rsp.getOutputStream()).thenReturn(new ServletOutputStream() {\n\n            @Override\n            public void write(int b) throws IOException {\n\n                baos.write(b);\n            }\n        });\n\n        return baos;\n    }\n\n    private ServletInputStream xmlNode(final String name) {\n\n        class Stream extends ServletInputStream {\n\n            private final InputStream inner;\n\n            public Stream(final InputStream inner) {\n\n                this.inner = inner;\n            }\n\n            @Override\n            public int read() throws IOException {\n\n                return inner.read();\n            }\n        }\n\n        return new Stream(Computer.class.getResourceAsStream(name));\n    }\n}\n"], "fixing_code": ["/*\n * The MIT License\n *\n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Red Hat, Inc., Seiji Sogabe, Stephen Connolly, Thomas J. Black, Tom Huybrechts, CloudBees, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport edu.umd.cs.findbugs.annotations.OverrideMustInvoke;\nimport edu.umd.cs.findbugs.annotations.When;\nimport hudson.EnvVars;\nimport hudson.Extension;\nimport hudson.Launcher.ProcStarter;\nimport hudson.Util;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.console.AnnotatedLargeText;\nimport hudson.init.Initializer;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.Queue.FlyweightTask;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.queue.WorkUnit;\nimport hudson.node_monitors.NodeMonitor;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.slaves.AbstractCloudSlave;\nimport hudson.slaves.ComputerLauncher;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.slaves.WorkspaceList;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.OfflineCause.ByCLI;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.EditDistance;\nimport hudson.util.ExceptionCatchingThreadFactory;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.RunList;\nimport hudson.util.Futures;\nimport hudson.util.NamingThreadFactory;\nimport jenkins.model.Jenkins;\nimport jenkins.util.ContextResettingExecutorService;\nimport jenkins.security.MasterToSlaveCallable;\nimport jenkins.security.NotReallyRoleSensitiveCallable;\n\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.DoNotUse;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.annotation.concurrent.GuardedBy;\nimport javax.servlet.ServletException;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ExecutionException;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.nio.charset.Charset;\nimport java.net.InetAddress;\nimport java.net.NetworkInterface;\nimport java.net.Inet4Address;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport static javax.servlet.http.HttpServletResponse.*;\n\n/**\n * Represents the running state of a remote computer that holds {@link Executor}s.\n *\n * <p>\n * {@link Executor}s on one {@link Computer} are transparently interchangeable\n * (that is the definition of {@link Computer}).\n *\n * <p>\n * This object is related to {@link Node} but they have some significant differences.\n * {@link Computer} primarily works as a holder of {@link Executor}s, so\n * if a {@link Node} is configured (probably temporarily) with 0 executors,\n * you won't have a {@link Computer} object for it (except for the master node,\n * which always gets its {@link Computer} in case we have no static executors and\n * we need to run a {@link FlyweightTask} - see JENKINS-7291 for more discussion.)\n *\n * Also, even if you remove a {@link Node}, it takes time for the corresponding\n * {@link Computer} to be removed, if some builds are already in progress on that\n * node. Or when the node configuration is changed, unaffected {@link Computer} object\n * remains intact, while all the {@link Node} objects will go away.\n *\n * <p>\n * This object also serves UI (unlike {@link Node}), and can be used along with\n * {@link TransientComputerActionFactory} to add {@link Action}s to {@link Computer}s.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic /*transient*/ abstract class Computer extends Actionable implements AccessControlled, ExecutorListener {\n\n    private final CopyOnWriteArrayList<Executor> executors = new CopyOnWriteArrayList<Executor>();\n    // TODO:\n    private final CopyOnWriteArrayList<OneOffExecutor> oneOffExecutors = new CopyOnWriteArrayList<OneOffExecutor>();\n\n    private int numExecutors;\n\n    /**\n     * Contains info about reason behind computer being offline.\n     */\n    protected volatile OfflineCause offlineCause;\n\n    private long connectTime = 0;\n\n    /**\n     * True if Jenkins shouldn't start new builds on this node.\n     */\n    private boolean temporarilyOffline;\n\n    /**\n     * {@link Node} object may be created and deleted independently\n     * from this object.\n     */\n    protected String nodeName;\n\n    /**\n     * @see #getHostName()\n     */\n    private volatile String cachedHostName;\n    private volatile boolean hostNameCached;\n\n    /**\n     * @see #getEnvironment()\n     */\n    private volatile EnvVars cachedEnvironment;\n\n\n    private final WorkspaceList workspaceList = new WorkspaceList();\n\n    protected transient List<Action> transientActions;\n\n    protected final Object statusChangeLock = new Object();\n\n    /**\n     * Keeps track of stack traces to track the tremination requests for this computer.\n     *\n     * @since 1.607\n     * @see Executor#resetWorkUnit(String)\n     */\n    private transient final List<TerminationRequest> terminatedBy = Collections.synchronizedList(new ArrayList\n            <TerminationRequest>());\n\n    /**\n     * This method captures the information of a request to terminate a computer instance. Method is public as\n     * it needs to be called from {@link AbstractCloudSlave} and {@link jenkins.model.Nodes}. In general you should\n     * not need to call this method directly, however if implementing a custom node type or a different path\n     * for removing nodes, it may make sense to call this method in order to capture the originating request.\n     *\n     * @since 1.607\n     */\n    public void recordTermination() {\n        StaplerRequest request = Stapler.getCurrentRequest();\n        if (request != null) {\n            terminatedBy.add(new TerminationRequest(\n                    String.format(\"Termination requested at %s by %s [id=%d] from HTTP request for %s\",\n                            new Date(),\n                            Thread.currentThread(),\n                            Thread.currentThread().getId(),\n                            request.getRequestURL()\n                    )\n            ));\n        } else {\n            terminatedBy.add(new TerminationRequest(\n                    String.format(\"Termination requested at %s by %s [id=%d]\",\n                            new Date(),\n                            Thread.currentThread(),\n                            Thread.currentThread().getId()\n                    )\n            ));\n        }\n    }\n\n    /**\n     * Returns the list of captured termination requests for this Computer. This method is used by {@link Executor}\n     * to provide details on why a Computer was removed in-between work being scheduled against the {@link Executor}\n     * and the {@link Executor} starting to execute the task.\n     *\n     * @return the (possibly empty) list of termination requests.\n     * @see Executor#resetWorkUnit(String)\n     * @since 1.607\n     */\n    public List<TerminationRequest> getTerminatedBy() {\n        return new ArrayList<TerminationRequest>(terminatedBy);\n    }\n\n    public Computer(Node node) {\n        setNode(node);\n    }\n\n     /**\n     * Returns list of all boxes {@link ComputerPanelBox}s.\n     */\n    public List<ComputerPanelBox> getComputerPanelBoxs(){\n        return ComputerPanelBox.all(this);\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the computer.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public List<Action> getActions() {\n    \tList<Action> result = new ArrayList<Action>();\n    \tresult.addAll(super.getActions());\n    \tsynchronized (this) {\n    \t\tif (transientActions == null) {\n    \t\t\ttransientActions = TransientComputerActionFactory.createAllFor(this);\n    \t\t}\n    \t\tresult.addAll(transientActions);\n    \t}\n    \treturn Collections.unmodifiableList(result);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void addAction(Action a) {\n        if(a==null) throw new IllegalArgumentException();\n        super.getActions().add(a);\n    }\n\n    /**\n     * This is where the log from the remote agent goes.\n     * The method also creates a log directory if required.\n     * @see #getLogDir(), #relocateOldLogs()\n     */\n    public @Nonnull File getLogFile() {\n        return new File(getLogDir(),\"slave.log\");\n    }\n\n    /**\n     * Directory where rotated slave logs are stored.\n     *\n     * The method also creates a log directory if required.\n     *\n     * @since 1.613\n     */\n    protected @Nonnull File getLogDir() {\n        File dir = new File(Jenkins.getInstance().getRootDir(),\"logs/slaves/\"+nodeName);\n        if (!dir.exists() && !dir.mkdirs()) {\n            LOGGER.severe(\"Failed to create slave log directory \" + dir.getAbsolutePath());\n        }\n        return dir;\n    }\n\n    /**\n     * Gets the object that coordinates the workspace allocation on this computer.\n     */\n    public WorkspaceList getWorkspaceList() {\n        return workspaceList;\n    }\n\n    /**\n     * Gets the string representation of the slave log.\n     */\n    public String getLog() throws IOException {\n        return Util.loadFile(getLogFile());\n    }\n\n    /**\n     * Used to URL-bind {@link AnnotatedLargeText}.\n     */\n    public AnnotatedLargeText<Computer> getLogText() {\n        return new AnnotatedLargeText<Computer>(getLogFile(), Charset.defaultCharset(), false, this);\n    }\n\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    public void checkPermission(Permission permission) {\n        getACL().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return getACL().hasPermission(permission);\n    }\n\n    /**\n     * If the computer was offline (either temporarily or not),\n     * this method will return the cause.\n     *\n     * @return\n     *      null if the system was put offline without given a cause.\n     */\n    @Exported\n    public OfflineCause getOfflineCause() {\n        return offlineCause;\n    }\n\n    /**\n     * If the computer was offline (either temporarily or not),\n     * this method will return the cause as a string (without user info).\n     *\n     * @return\n     *      empty string if the system was put offline without given a cause.\n     */\n    @Exported\n    public String getOfflineCauseReason() {\n        if (offlineCause == null) {\n            return \"\";\n        }\n        // fetch the localized string for \"Disconnected By\"\n        String gsub_base = hudson.slaves.Messages.SlaveComputer_DisconnectedBy(\"\",\"\");\n        // regex to remove commented reason base string\n        String gsub1 = \"^\" + gsub_base + \"[\\\\w\\\\W]* \\\\: \";\n        // regex to remove non-commented reason base string\n        String gsub2 = \"^\" + gsub_base + \"[\\\\w\\\\W]*\";\n\n        String newString = offlineCause.toString().replaceAll(gsub1, \"\");\n        return newString.replaceAll(gsub2, \"\");\n    }\n\n    /**\n     * Gets the channel that can be used to run a program on this computer.\n     *\n     * @return\n     *      never null when {@link #isOffline()}==false.\n     */\n    public abstract @Nullable VirtualChannel getChannel();\n\n    /**\n     * Gets the default charset of this computer.\n     *\n     * @return\n     *      never null when {@link #isOffline()}==false.\n     */\n    public abstract Charset getDefaultCharset();\n\n    /**\n     * Gets the logs recorded by this slave.\n     */\n    public abstract List<LogRecord> getLogRecords() throws IOException, InterruptedException;\n\n    /**\n     * If {@link #getChannel()}==null, attempts to relaunch the slave agent.\n     */\n    public abstract void doLaunchSlaveAgent( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException;\n\n    /**\n     * @deprecated since 2009-01-06.  Use {@link #connect(boolean)}\n     */\n    @Deprecated\n    public final void launch() {\n        connect(true);\n    }\n\n    /**\n     * Do the same as {@link #doLaunchSlaveAgent(StaplerRequest, StaplerResponse)}\n     * but outside the context of serving a request.\n     *\n     * <p>\n     * If already connected or if this computer doesn't support proactive launching, no-op.\n     * This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @see #disconnect()\n     *\n     * @param forceReconnect\n     *      If true and a connect activity is already in progress, it will be cancelled and\n     *      the new one will be started. If false, and a connect activity is already in progress, this method\n     *      will do nothing and just return the pending connection operation.\n     * @return\n     *      A {@link Future} representing pending completion of the task. The 'completion' includes\n     *      both a successful completion and a non-successful completion (such distinction typically doesn't\n     *      make much sense because as soon as {@link Computer} is connected it can be disconnected by some other threads.)\n     */\n    public final Future<?> connect(boolean forceReconnect) {\n    \tconnectTime = System.currentTimeMillis();\n    \treturn _connect(forceReconnect);\n    }\n\n    /**\n     * Allows implementing-classes to provide an implementation for the connect method.\n     *\n     * <p>\n     * If already connected or if this computer doesn't support proactive launching, no-op.\n     * This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @see #disconnect()\n     *\n     * @param forceReconnect\n     *      If true and a connect activity is already in progress, it will be cancelled and\n     *      the new one will be started. If false, and a connect activity is already in progress, this method\n     *      will do nothing and just return the pending connection operation.\n     * @return\n     *      A {@link Future} representing pending completion of the task. The 'completion' includes\n     *      both a successful completion and a non-successful completion (such distinction typically doesn't\n     *      make much sense because as soon as {@link Computer} is connected it can be disconnected by some other threads.)\n     */\n    protected abstract Future<?> _connect(boolean forceReconnect);\n\n    /**\n     * CLI command to reconnect this node.\n     */\n    @CLIMethod(name=\"connect-node\")\n    public void cliConnect(@Option(name=\"-f\",usage=\"Cancel any currently pending connect operation and retry from scratch\") boolean force) throws ExecutionException, InterruptedException {\n        checkPermission(CONNECT);\n        connect(force).get();\n    }\n\n    /**\n     * Gets the time (since epoch) when this computer connected.\n     *\n     * @return The time in ms since epoch when this computer last connected.\n     */\n    public final long getConnectTime() {\n    \treturn connectTime;\n    }\n\n    /**\n     * Disconnect this computer.\n     *\n     * If this is the master, no-op. This method may return immediately\n     * while the launch operation happens asynchronously.\n     *\n     * @param cause\n     *      Object that identifies the reason the node was disconnected.\n     *\n     * @return\n     *      {@link Future} to track the asynchronous disconnect operation.\n     * @see #connect(boolean)\n     * @since 1.320\n     */\n    public Future<?> disconnect(OfflineCause cause) {\n        recordTermination();\n        offlineCause = cause;\n        if (Util.isOverridden(Computer.class,getClass(),\"disconnect\"))\n            return disconnect();    // legacy subtypes that extend disconnect().\n\n        connectTime=0;\n        return Futures.precomputed(null);\n    }\n\n    /**\n     * Equivalent to {@code disconnect(null)}\n     *\n     * @deprecated as of 1.320.\n     *      Use {@link #disconnect(OfflineCause)} and specify the cause.\n     */\n    @Deprecated\n    public Future<?> disconnect() {\n        recordTermination();\n        if (Util.isOverridden(Computer.class,getClass(),\"disconnect\",OfflineCause.class))\n            // if the subtype already derives disconnect(OfflineCause), delegate to it\n            return disconnect(null);\n\n        connectTime=0;\n        return Futures.precomputed(null);\n    }\n\n    /**\n     * CLI command to disconnects this node.\n     */\n    @CLIMethod(name=\"disconnect-node\")\n    public void cliDisconnect(@Option(name=\"-m\",usage=\"Record the note about why you are disconnecting this node\") String cause) throws ExecutionException, InterruptedException {\n        checkPermission(DISCONNECT);\n        disconnect(new ByCLI(cause)).get();\n    }\n\n    /**\n     * CLI command to mark the node offline.\n     */\n    @CLIMethod(name=\"offline-node\")\n    public void cliOffline(@Option(name=\"-m\",usage=\"Record the note about why you are disconnecting this node\") String cause) throws ExecutionException, InterruptedException {\n        checkPermission(DISCONNECT);\n        setTemporarilyOffline(true, new ByCLI(cause));\n    }\n\n    @CLIMethod(name=\"online-node\")\n    public void cliOnline() throws ExecutionException, InterruptedException {\n        checkPermission(CONNECT);\n        setTemporarilyOffline(false, null);\n    }\n\n    /**\n     * Number of {@link Executor}s that are configured for this computer.\n     *\n     * <p>\n     * When this value is decreased, it is temporarily possible\n     * for {@link #executors} to have a larger number than this.\n     */\n    // ugly name to let EL access this\n    @Exported\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    /**\n     * Returns {@link Node#getNodeName() the name of the node}.\n     */\n    public @Nonnull String getName() {\n        return nodeName != null ? nodeName : \"\";\n    }\n\n    /**\n     * True if this computer is a Unix machine (as opposed to Windows machine).\n     *\n     * @since 1.624\n     * @return\n     *      null if the computer is disconnected and therefore we don't know whether it is Unix or not.\n     */\n    public abstract @CheckForNull Boolean isUnix();\n\n    /**\n     * Returns the {@link Node} that this computer represents.\n     *\n     * @return\n     *      null if the configuration has changed and the node is removed, yet the corresponding {@link Computer}\n     *      is not yet gone.\n     */\n    public @CheckForNull Node getNode() {\n        Jenkins j = Jenkins.getInstance();\n        if (j == null) {\n            return null;\n        }\n        if (nodeName == null) {\n            return j;\n        }\n        return j.getNode(nodeName);\n    }\n\n    @Exported\n    public LoadStatistics getLoadStatistics() {\n        return LabelAtom.get(nodeName != null ? nodeName : Jenkins.getInstance().getSelfLabel().toString()).loadStatistics;\n    }\n\n    public BuildTimelineWidget getTimeline() {\n        return new BuildTimelineWidget(getBuilds());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskAccepted(Executor executor, Queue.Task task) {\n        // dummy implementation\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskCompleted(Executor executor, Queue.Task task, long durationMS) {\n        // dummy implementation\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void taskCompletedWithProblems(Executor executor, Queue.Task task, long durationMS, Throwable problems) {\n        // dummy implementation\n    }\n\n    @Exported\n    public boolean isOffline() {\n        return temporarilyOffline || getChannel()==null;\n    }\n\n    public final boolean isOnline() {\n        return !isOffline();\n    }\n\n    /**\n     * This method is called to determine whether manual launching of the slave is allowed at this point in time.\n     * @return {@code true} if manual launching of the slave is allowed at this point in time.\n     */\n    @Exported\n    public boolean isManualLaunchAllowed() {\n        return getRetentionStrategy().isManualLaunchAllowed(this);\n    }\n\n\n    /**\n     * Is a {@link #connect(boolean)} operation in progress?\n     */\n    public abstract boolean isConnecting();\n\n    /**\n     * Returns true if this computer is supposed to be launched via JNLP.\n     * @deprecated since 2008-05-18.\n     *     See {@linkplain #isLaunchSupported()} and {@linkplain ComputerLauncher}\n     */\n    @Exported\n    @Deprecated\n    public boolean isJnlpAgent() {\n        return false;\n    }\n\n    /**\n     * Returns true if this computer can be launched by Hudson proactively and automatically.\n     *\n     * <p>\n     * For example, JNLP slaves return {@code false} from this, because the launch process\n     * needs to be initiated from the slave side.\n     */\n    @Exported\n    public boolean isLaunchSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true if this node is marked temporarily offline by the user.\n     *\n     * <p>\n     * In contrast, {@link #isOffline()} represents the actual online/offline\n     * state. For example, this method may return false while {@link #isOffline()}\n     * returns true if the slave agent failed to launch.\n     *\n     * @deprecated\n     *      You should almost always want {@link #isOffline()}.\n     *      This method is marked as deprecated to warn people when they\n     *      accidentally call this method.\n     */\n    @Exported\n    @Deprecated\n    public boolean isTemporarilyOffline() {\n        return temporarilyOffline;\n    }\n\n    /**\n     * @deprecated as of 1.320.\n     *      Use {@link #setTemporarilyOffline(boolean, OfflineCause)}\n     */\n    @Deprecated\n    public void setTemporarilyOffline(boolean temporarilyOffline) {\n        setTemporarilyOffline(temporarilyOffline,null);\n    }\n\n    /**\n     * Marks the computer as temporarily offline. This retains the underlying\n     * {@link Channel} connection, but prevent builds from executing.\n     *\n     * @param cause\n     *      If the first argument is true, specify the reason why the node is being put\n     *      offline.\n     */\n    public void setTemporarilyOffline(boolean temporarilyOffline, OfflineCause cause) {\n        offlineCause = temporarilyOffline ? cause : null;\n        this.temporarilyOffline = temporarilyOffline;\n        Node node = getNode();\n        if (node != null) {\n            node.setTemporaryOfflineCause(offlineCause);\n        }\n        Jenkins.getInstance().getQueue().scheduleMaintenance();\n        synchronized (statusChangeLock) {\n            statusChangeLock.notifyAll();\n        }\n        for (ComputerListener cl : ComputerListener.all()) {\n            if (temporarilyOffline)     cl.onTemporarilyOffline(this,cause);\n            else                        cl.onTemporarilyOnline(this);\n        }\n    }\n\n    @Exported\n    public String getIcon() {\n        if(isOffline())\n            return \"computer-x.png\";\n        else\n            return \"computer.png\";\n    }\n\n    @Exported\n    public String getIconClassName() {\n        if(isOffline())\n            return \"icon-computer-x\";\n        else\n            return \"icon-computer\";\n    }\n\n    public String getIconAltText() {\n        if(isOffline())\n            return \"[offline]\";\n        else\n            return \"[online]\";\n    }\n\n    @Exported\n    @Override public @Nonnull String getDisplayName() {\n        return nodeName;\n    }\n\n    public String getCaption() {\n        return Messages.Computer_Caption(nodeName);\n    }\n\n    public String getUrl() {\n        return \"computer/\" + Util.rawEncode(getName()) + \"/\";\n    }\n\n    /**\n     * Returns projects that are tied on this node.\n     */\n    public List<AbstractProject> getTiedJobs() {\n        Node node = getNode();\n        return (node != null) ? node.getSelfLabel().getTiedJobs() : Collections.EMPTY_LIST;\n    }\n\n    public RunList getBuilds() {\n    \treturn new RunList(Jenkins.getInstance().getAllItems(Job.class)).node(getNode());\n    }\n\n    /**\n     * Called to notify {@link Computer} that its corresponding {@link Node}\n     * configuration is updated.\n     */\n    protected void setNode(Node node) {\n        assert node!=null;\n        if(node instanceof Slave)\n            this.nodeName = node.getNodeName();\n        else\n            this.nodeName = null;\n\n        setNumExecutors(node.getNumExecutors());\n        if (this.temporarilyOffline) {\n            // When we get a new node, push our current temp offline\n            // status to it (as the status is not carried across\n            // configuration changes that recreate the node).\n            // Since this is also called the very first time this\n            // Computer is created, avoid pushing an empty status\n            // as that could overwrite any status that the Node\n            // brought along from its persisted config data.\n            node.setTemporaryOfflineCause(this.offlineCause);\n        }\n    }\n\n    /**\n     * Called by {@link Jenkins#updateComputerList()} to notify {@link Computer} that it will be discarded.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * @see #onRemoved()\n     */\n    protected void kill() {\n        // On most code paths, this should already be zero, and thus this next call becomes a no-op... and more\n        // importantly it will not acquire a lock on the Queue... not that the lock is bad, more that the lock\n        // may delay unnecessarily\n        setNumExecutors(0);\n    }\n\n    /**\n     * Called by {@link Jenkins#updateComputerList()} to notify {@link Computer} that it will be discarded.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * <p>\n     * Note that the Queue lock is already held when this method is called.\n     *\n     * @see #onRemoved()\n     */\n    @Restricted(NoExternalUse.class)\n    @GuardedBy(\"hudson.model.Queue.lock\")\n    /*package*/ void inflictMortalWound() {\n        setNumExecutors(0);\n    }\n\n    /**\n     * Called by {@link Jenkins} when this computer is removed.\n     *\n     * <p>\n     * This happens when list of nodes are updated (for example by {@link Jenkins#setNodes(List)} and\n     * the computer becomes redundant. Such {@link Computer}s get {@linkplain #kill() killed}, then\n     * after all its executors are finished, this method is called.\n     *\n     * <p>\n     * Note that at this point {@link #getNode()} returns null.\n     *\n     * @see #kill()\n     * @since 1.510\n     */\n    protected void onRemoved(){\n    }\n\n    private synchronized void setNumExecutors(int n) {\n        this.numExecutors = n;\n        final int diff = executors.size()-n;\n\n        if (diff>0) {\n            // we have too many executors\n            // send signal to all idle executors to potentially kill them off\n            // need the Queue maintenance lock held to prevent concurrent job assignment on the idle executors\n            Queue.withLock(new Runnable() {\n                @Override\n                public void run() {\n                    for( Executor e : executors )\n                        if(e.isIdle())\n                            e.interrupt();\n                }\n            });\n        }\n\n        if (diff<0) {\n            // if the number is increased, add new ones\n            addNewExecutorIfNecessary();\n        }\n    }\n\n    private void addNewExecutorIfNecessary() {\n        Set<Integer> availableNumbers  = new HashSet<Integer>();\n        for (int i = 0; i < numExecutors; i++)\n            availableNumbers.add(i);\n\n        for (Executor executor : executors)\n            availableNumbers.remove(executor.getNumber());\n\n        for (Integer number : availableNumbers) {\n            /* There may be busy executors with higher index, so only\n               fill up until numExecutors is reached.\n               Extra executors will call removeExecutor(...) and that\n               will create any necessary executors from #0 again. */\n            if (executors.size() < numExecutors) {\n                Executor e = new Executor(this, number);\n                executors.add(e);\n            }\n        }\n\n    }\n\n    /**\n     * Returns the number of idle {@link Executor}s that can start working immediately.\n     */\n    public int countIdle() {\n        int n = 0;\n        for (Executor e : executors) {\n            if(e.isIdle())\n                n++;\n        }\n        return n;\n    }\n\n    /**\n     * Returns the number of {@link Executor}s that are doing some work right now.\n     */\n    public final int countBusy() {\n        return countExecutors()-countIdle();\n    }\n\n    /**\n     * Returns the current size of the executor pool for this computer.\n     * This number may temporarily differ from {@link #getNumExecutors()} if there\n     * are busy tasks when the configured size is decreased.  OneOffExecutors are\n     * not included in this count.\n     */\n    public final int countExecutors() {\n        return executors.size();\n    }\n\n    /**\n     * Gets the read-only snapshot view of all {@link Executor}s.\n     */\n    @Exported\n    public List<Executor> getExecutors() {\n        return new ArrayList<Executor>(executors);\n    }\n\n    /**\n     * Gets the read-only snapshot view of all {@link OneOffExecutor}s.\n     */\n    @Exported\n    public List<OneOffExecutor> getOneOffExecutors() {\n        return new ArrayList<OneOffExecutor>(oneOffExecutors);\n    }\n\n    /**\n     * Used to render the list of executors.\n     * @return a snapshot of the executor display information\n     * @since 1.607\n     */\n    @Restricted(NoExternalUse.class)\n    public List<DisplayExecutor> getDisplayExecutors() {\n        // The size may change while we are populating, but let's start with a reasonable guess to minimize resizing\n        List<DisplayExecutor> result = new ArrayList<DisplayExecutor>(executors.size()+oneOffExecutors.size());\n        int index = 0;\n        for (Executor e: executors) {\n            if (e.isDisplayCell()) {\n                result.add(new DisplayExecutor(Integer.toString(index + 1), String.format(\"executors/%d\", index), e));\n            }\n            index++;\n        }\n        index = 0;\n        for (OneOffExecutor e: oneOffExecutors) {\n            if (e.isDisplayCell()) {\n                result.add(new DisplayExecutor(\"\", String.format(\"oneOffExecutors/%d\", index), e));\n            }\n            index++;\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if all the executors of this computer are idle.\n     */\n    @Exported\n    public final boolean isIdle() {\n        if (!oneOffExecutors.isEmpty())\n            return false;\n        for (Executor e : executors)\n            if(!e.isIdle())\n                return false;\n        return true;\n    }\n\n    /**\n     * Returns true if this computer has some idle executors that can take more workload.\n     */\n    public final boolean isPartiallyIdle() {\n        for (Executor e : executors)\n            if(e.isIdle())\n                return true;\n        return false;\n    }\n\n    /**\n     * Returns the time when this computer last became idle.\n     *\n     * <p>\n     * If this computer is already idle, the return value will point to the\n     * time in the past since when this computer has been idle.\n     *\n     * <p>\n     * If this computer is busy, the return value will point to the\n     * time in the future where this computer will be expected to become free.\n     */\n    public final long getIdleStartMilliseconds() {\n        long firstIdle = Long.MIN_VALUE;\n        for (Executor e : oneOffExecutors) {\n            firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\n        }\n        for (Executor e : executors) {\n            firstIdle = Math.max(firstIdle, e.getIdleStartMilliseconds());\n        }\n        return firstIdle;\n    }\n\n    /**\n     * Returns the time when this computer first became in demand.\n     */\n    public final long getDemandStartMilliseconds() {\n        long firstDemand = Long.MAX_VALUE;\n        for (Queue.BuildableItem item : Jenkins.getInstance().getQueue().getBuildableItems(this)) {\n            firstDemand = Math.min(item.buildableStartMilliseconds, firstDemand);\n        }\n        return firstDemand;\n    }\n\n    /**\n     * Called by {@link Executor} to kill excessive executors from this computer.\n     */\n    /*package*/ void removeExecutor(final Executor e) {\n        final Runnable task = new Runnable() {\n            @Override\n            public void run() {\n                synchronized (Computer.this) {\n                    executors.remove(e);\n                    addNewExecutorIfNecessary();\n                    if (!isAlive()) {\n                        AbstractCIBase ciBase = Jenkins.getInstance();\n                        if (ciBase != null) {\n                            ciBase.removeComputer(Computer.this);\n                        }\n                    }\n                }\n            }\n        };\n        if (!Queue.tryWithLock(task)) {\n            // JENKINS-28840 if we couldn't get the lock push the operation to a separate thread to avoid deadlocks\n            threadPoolForRemoting.submit(Queue.wrapWithLock(task));\n        }\n    }\n\n    /**\n     * Returns true if any of the executors are {@linkplain Executor#isActive active}.\n     *\n     * Note that if an executor dies, we'll leave it in {@link #executors} until\n     * the administrator yanks it out, so that we can see why it died.\n     *\n     * @since 1.509\n     */\n    protected boolean isAlive() {\n        for (Executor e : executors)\n            if (e.isActive())\n                return true;\n        return false;\n    }\n\n    /**\n     * Interrupt all {@link Executor}s.\n     * Called from {@link Jenkins#cleanUp}.\n     */\n    public void interrupt() {\n        Queue.withLock(new Runnable() {\n            @Override\n            public void run() {\n                for (Executor e : executors) {\n                    e.interruptForShutdown();\n                }\n            }\n        });\n    }\n\n    public String getSearchUrl() {\n        return getUrl();\n    }\n\n    /**\n     * {@link RetentionStrategy} associated with this computer.\n     *\n     * @return\n     *      never null. This method return {@code RetentionStrategy<? super T>} where\n     *      {@code T=this.getClass()}.\n     */\n    public abstract RetentionStrategy getRetentionStrategy();\n\n    /**\n     * Expose monitoring data for the remote API.\n     */\n    @Exported(inline=true)\n    public Map<String/*monitor name*/,Object> getMonitorData() {\n        Map<String,Object> r = new HashMap<String, Object>();\n        if (hasPermission(CONNECT)) {\n            for (NodeMonitor monitor : NodeMonitor.getAll())\n                r.put(monitor.getClass().getName(), monitor.data(this));\n        }\n        return r;\n    }\n\n    /**\n     * Gets the system properties of the JVM on this computer.\n     * If this is the master, it returns the system property of the master computer.\n     */\n    public Map<Object,Object> getSystemProperties() throws IOException, InterruptedException {\n        return RemotingDiagnostics.getSystemProperties(getChannel());\n    }\n\n    /**\n     * @deprecated as of 1.292\n     *      Use {@link #getEnvironment()} instead.\n     */\n    @Deprecated\n    public Map<String,String> getEnvVars() throws IOException, InterruptedException {\n        return getEnvironment();\n    }\n\n    /**\n     * Returns cached environment variables (copy to prevent modification) for the JVM on this computer.\n     * If this is the master, it returns the system property of the master computer.\n     */\n    public EnvVars getEnvironment() throws IOException, InterruptedException {\n        EnvVars cachedEnvironment = this.cachedEnvironment;\n        if (cachedEnvironment != null) {\n            return new EnvVars(cachedEnvironment);\n        }\n\n        cachedEnvironment = EnvVars.getRemote(getChannel());\n        this.cachedEnvironment = cachedEnvironment;\n        return new EnvVars(cachedEnvironment);\n    }\n\n    /**\n     * Creates an environment variable override to be used for launching processes on this node.\n     *\n     * @see ProcStarter#envs(Map)\n     * @since 1.489\n     */\n    public @Nonnull EnvVars buildEnvironment(@Nonnull TaskListener listener) throws IOException, InterruptedException {\n        EnvVars env = new EnvVars();\n\n        Node node = getNode();\n        if (node==null)     return env; // bail out\n\n        for (NodeProperty nodeProperty: Jenkins.getInstance().getGlobalNodeProperties()) {\n            nodeProperty.buildEnvVars(env,listener);\n        }\n\n        for (NodeProperty nodeProperty: node.getNodeProperties()) {\n            nodeProperty.buildEnvVars(env,listener);\n        }\n\n        // TODO: hmm, they don't really belong\n        String rootUrl = Jenkins.getInstance().getRootUrl();\n        if(rootUrl!=null) {\n            env.put(\"HUDSON_URL\", rootUrl); // Legacy.\n            env.put(\"JENKINS_URL\", rootUrl);\n        }\n\n        return env;\n    }\n\n    /**\n     * Gets the thread dump of the slave JVM.\n     * @return\n     *      key is the thread name, and the value is the pre-formatted dump.\n     */\n    public Map<String,String> getThreadDump() throws IOException, InterruptedException {\n        return RemotingDiagnostics.getThreadDump(getChannel());\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,getChannel());\n    }\n\n    /**\n     * This method tries to compute the name of the host that's reachable by all the other nodes.\n     *\n     * <p>\n     * Since it's possible that the slave is not reachable from the master (it may be behind a firewall,\n     * connecting to master via JNLP), this method may return null.\n     *\n     * It's surprisingly tricky for a machine to know a name that other systems can get to,\n     * especially between things like DNS search suffix, the hosts file, and YP.\n     *\n     * <p>\n     * So the technique here is to compute possible interfaces and names on the slave,\n     * then try to ping them from the master, and pick the one that worked.\n     *\n     * <p>\n     * The computation may take some time, so it employs caching to make the successive lookups faster.\n     *\n     * @since 1.300\n     * @return\n     *      null if the host name cannot be computed (for example because this computer is offline,\n     *      because the slave is behind the firewall, etc.)\n     */\n    public String getHostName() throws IOException, InterruptedException {\n        if(hostNameCached)\n            // in the worst case we end up having multiple threads computing the host name simultaneously, but that's not harmful, just wasteful.\n            return cachedHostName;\n\n        VirtualChannel channel = getChannel();\n        if(channel==null)   return null; // can't compute right now\n\n        for( String address : channel.call(new ListPossibleNames())) {\n            try {\n                InetAddress ia = InetAddress.getByName(address);\n                if(!(ia instanceof Inet4Address)) {\n                    LOGGER.log(Level.FINE, \"{0} is not an IPv4 address\", address);\n                    continue;\n                }\n                if(!ComputerPinger.checkIsReachable(ia, 3)) {\n                    LOGGER.log(Level.FINE, \"{0} didn't respond to ping\", address);\n                    continue;\n                }\n                cachedHostName = ia.getCanonicalHostName();\n                hostNameCached = true;\n                return cachedHostName;\n            } catch (IOException e) {\n                // if a given name fails to parse on this host, we get this error\n                LogRecord lr = new LogRecord(Level.FINE, \"Failed to parse {0}\");\n                lr.setThrown(e);\n                lr.setParameters(new Object[]{address});\n                LOGGER.log(lr);\n            }\n        }\n\n        // allow the administrator to manually specify the host name as a fallback. HUDSON-5373\n        cachedHostName = channel.call(new GetFallbackName());\n        hostNameCached = true;\n        return cachedHostName;\n    }\n\n    /**\n     * Starts executing a fly-weight task.\n     */\n    /*package*/ final void startFlyWeightTask(WorkUnit p) {\n        OneOffExecutor e = new OneOffExecutor(this);\n        e.start(p);\n        oneOffExecutors.add(e);\n    }\n\n    /*package*/ final void remove(OneOffExecutor e) {\n        oneOffExecutors.remove(e);\n    }\n\n    private static class ListPossibleNames extends MasterToSlaveCallable<List<String>,IOException> {\n        /**\n         * In the normal case we would use {@link Computer} as the logger's name, however to\n         * do that we would have to send the {@link Computer} class over to the remote classloader\n         * and then it would need to be loaded, which pulls in {@link Jenkins} and loads that\n         * and then that fails to load as you are not supposed to do that. Another option\n         * would be to export the logger over remoting, with increased complexity as a result.\n         * Instead we just use a loger based on this class name and prevent any references to\n         * other classes from being transferred over remoting.\n         */\n        private static final Logger LOGGER = Logger.getLogger(ListPossibleNames.class.getName());\n        \n        public List<String> call() throws IOException {\n            List<String> names = new ArrayList<String>();\n\n            Enumeration<NetworkInterface> nis = NetworkInterface.getNetworkInterfaces();\n            while (nis.hasMoreElements()) {\n                NetworkInterface ni =  nis.nextElement();\n                LOGGER.log(Level.FINE, \"Listing up IP addresses for {0}\", ni.getDisplayName());\n                Enumeration<InetAddress> e = ni.getInetAddresses();\n                while (e.hasMoreElements()) {\n                    InetAddress ia =  e.nextElement();\n                    if(ia.isLoopbackAddress()) {\n                        LOGGER.log(Level.FINE, \"{0} is a loopback address\", ia);\n                        continue;\n                    }\n\n                    if(!(ia instanceof Inet4Address)) {\n                        LOGGER.log(Level.FINE, \"{0} is not an IPv4 address\", ia);\n                        continue;\n                    }\n\n                    LOGGER.log(Level.FINE, \"{0} is a viable candidate\", ia);\n                    names.add(ia.getHostAddress());\n                }\n            }\n            return names;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static class GetFallbackName extends MasterToSlaveCallable<String,IOException> {\n        public String call() throws IOException {\n            return System.getProperty(\"host.name\");\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    public static final ExecutorService threadPoolForRemoting = new ContextResettingExecutorService(\n            Executors.newCachedThreadPool(\n                    new ExceptionCatchingThreadFactory(\n                            new NamingThreadFactory(new DaemonThreadFactory(), \"Computer.threadPoolForRemoting\"))));\n\n//\n//\n// UI\n//\n//\n    public void doRssAll( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds());\n    }\n\n    public void doRssFailed(StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" failed builds\", getBuilds().failureOnly());\n    }\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs) throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName() + suffix, getUrl(),\n                runs.newBuilds(), Run.FEED_ADAPTER, req, rsp);\n    }\n\n    @RequirePOST\n    public HttpResponse doToggleOffline(@QueryParameter String offlineMessage) throws IOException, ServletException {\n        if(!temporarilyOffline) {\n            checkPermission(DISCONNECT);\n            offlineMessage = Util.fixEmptyAndTrim(offlineMessage);\n            setTemporarilyOffline(!temporarilyOffline,\n                    new OfflineCause.UserCause(User.current(), offlineMessage));\n        } else {\n            checkPermission(CONNECT);\n            setTemporarilyOffline(!temporarilyOffline,null);\n        }\n        return HttpResponses.redirectToDot();\n    }\n\n    @RequirePOST\n    public HttpResponse doChangeOfflineCause(@QueryParameter String offlineMessage) throws IOException, ServletException {\n        checkPermission(DISCONNECT);\n        offlineMessage = Util.fixEmptyAndTrim(offlineMessage);\n        setTemporarilyOffline(true,\n                new OfflineCause.UserCause(User.current(), offlineMessage));\n        return HttpResponses.redirectToDot();\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Dumps the contents of the export table.\n     */\n    public void doDumpExportTable( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, InterruptedException {\n        // this is a debug probe and may expose sensitive information\n        checkPermission(Jenkins.ADMINISTER);\n\n        rsp.setContentType(\"text/plain\");\n        PrintWriter w = new PrintWriter(rsp.getCompressedWriter(req));\n        VirtualChannel vc = getChannel();\n        if (vc instanceof Channel) {\n            w.println(\"Master to slave\");\n            ((Channel)vc).dumpExportTable(w);\n            w.flush(); // flush here once so that even if the dump from the slave fails, the client gets some useful info\n\n            w.println(\"\\n\\n\\nSlave to master\");\n            w.print(vc.call(new DumpExportTableTask()));\n        } else {\n            w.println(Messages.Computer_BadChannel());\n        }\n        w.close();\n    }\n\n    private static final class DumpExportTableTask extends MasterToSlaveCallable<String,IOException> {\n        public String call() throws IOException {\n            StringWriter sw = new StringWriter();\n            PrintWriter pw = new PrintWriter(sw);\n            Channel.current().dumpExportTable(pw);\n            pw.close();\n            return sw.toString();\n        }\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, \"_script.jelly\");\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, \"_scriptText.jelly\");\n    }\n\n    protected void _doScript(StaplerRequest req, StaplerResponse rsp, String view) throws IOException, ServletException {\n        Jenkins._doScript(req, rsp, req.getView(this, view), getChannel(), getACL());\n    }\n\n    /**\n     * Accepts the update to the node configuration.\n     */\n    @RequirePOST\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        String name = Util.fixEmptyAndTrim(req.getSubmittedForm().getString(\"name\"));\n        Jenkins.checkGoodName(name);\n\n        Node node = getNode();\n        if (node == null) {\n            throw new ServletException(\"No such node \" + nodeName);\n        }\n        Node result = node.reconfigure(req, req.getSubmittedForm());\n        replaceBy(result);\n\n        // take the user back to the slave top page.\n        rsp.sendRedirect2(\"../\" + result.getNodeName() + '/');\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp)\n            throws IOException, ServletException {\n\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            checkPermission(EXTENDED_READ);\n            rsp.setContentType(\"application/xml\");\n            Node node = getNode();\n            if (node == null) {\n                throw HttpResponses.notFound();\n            }\n            Jenkins.XSTREAM2.toXMLUTF8(node, rsp.getOutputStream());\n            return;\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml(req.getInputStream());\n            return;\n        }\n\n        // huh?\n        rsp.sendError(SC_BAD_REQUEST);\n    }\n\n    /**\n     * Replaces the current {@link Node} by another one.\n     */\n    private void replaceBy(final Node newNode) throws ServletException, IOException {\n        final Jenkins app = Jenkins.getInstance();\n\n        // use the queue lock until Nodes has a way of directly modifying a single node.\n        Queue.withLock(new NotReallyRoleSensitiveCallable<Void, IOException>() {\n            public Void call() throws IOException {\n                List<Node> nodes = new ArrayList<Node>(app.getNodes());\n                Node node = getNode();\n                int i  = (node != null) ? nodes.indexOf(node) : -1;\n                if(i<0) {\n                    throw new IOException(\"This slave appears to be removed while you were editing the configuration\");\n                }\n                nodes.set(i, newNode);\n                app.setNodes(nodes);\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Updates Job by its XML definition.\n     *\n     * @since 1.526\n     */\n    public void updateByXml(final InputStream source) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n        Node result = (Node)Jenkins.XSTREAM2.fromXML(source);\n        replaceBy(result);\n    }\n\n    /**\n     * Really deletes the slave.\n     */\n    @RequirePOST\n    public HttpResponse doDoDelete() throws IOException {\n        checkPermission(DELETE);\n        Node node = getNode();\n        if (node != null) {\n            Jenkins.getInstance().removeNode(node);\n        } else {\n            AbstractCIBase app = Jenkins.getInstance();\n            app.removeComputer(this);\n        }\n        return new HttpRedirect(\"..\");\n    }\n\n    /**\n     * Blocks until the node becomes online/offline.\n     */\n    @CLIMethod(name=\"wait-node-online\")\n    public void waitUntilOnline() throws InterruptedException {\n        synchronized (statusChangeLock) {\n            while (!isOnline())\n                statusChangeLock.wait(1000);\n        }\n    }\n\n    @CLIMethod(name=\"wait-node-offline\")\n    public void waitUntilOffline() throws InterruptedException {\n        synchronized (statusChangeLock) {\n            while (!isOffline())\n                statusChangeLock.wait(1000);\n        }\n    }\n\n    /**\n     * Handles incremental log.\n     */\n    public void doProgressiveLog( StaplerRequest req, StaplerResponse rsp) throws IOException {\n        getLogText().doProgressText(req, rsp);\n    }\n\n    /**\n     * Gets the current {@link Computer} that the build is running.\n     * This method only works when called during a build, such as by\n     * {@link hudson.tasks.Publisher}, {@link hudson.tasks.BuildWrapper}, etc.\n     * @return the {@link Computer} associated with {@link Executor#currentExecutor}, or (consistently as of 1.591) null if not on an executor thread\n     */\n    public static @Nullable Computer currentComputer() {\n        Executor e = Executor.currentExecutor();\n        return e != null ? e.getOwner() : null;\n    }\n\n    /**\n     * Returns {@code true} if the computer is accepting tasks. Needed to allow slaves programmatic suspension of task\n     * scheduling that does not overlap with being offline.\n     *\n     * @return {@code true} if the computer is accepting tasks\n     * @see hudson.slaves.RetentionStrategy#isAcceptingTasks(Computer)\n     * @see hudson.model.Node#isAcceptingTasks()\n     */\n    @OverrideMustInvoke(When.ANYTIME)\n    public boolean isAcceptingTasks() {\n        final Node node = getNode();\n        return getRetentionStrategy().isAcceptingTasks(this) && (node == null || node.isAcceptingTasks());\n    }\n\n    /**\n     * Used for CLI binding.\n     */\n    @CLIResolver\n    public static Computer resolveForCLI(\n            @Argument(required=true,metaVar=\"NAME\",usage=\"Slave name, or empty string for master\") String name) throws CmdLineException {\n        Jenkins h = Jenkins.getInstance();\n        Computer item = h.getComputer(name);\n        if (item==null) {\n            List<String> names = new ArrayList<String>();\n            for (Computer c : h.getComputers())\n                if (c.getName().length()>0)\n                    names.add(c.getName());\n            throw new CmdLineException(null,Messages.Computer_NoSuchSlaveExists(name,EditDistance.findNearest(name,names)));\n        }\n        return item;\n    }\n\n    /**\n     * Relocate log files in the old location to the new location.\n     *\n     * Files were used to be $JENKINS_ROOT/slave-NAME.log (and .1, .2, ...)\n     * but now they are at $JENKINS_ROOT/logs/slaves/NAME/slave.log (and .1, .2, ...)\n     *\n     * @see #getLogFile()\n     */\n    @Initializer\n    public static void relocateOldLogs() {\n        relocateOldLogs(Jenkins.getInstance().getRootDir());\n    }\n\n    /*package*/ static void relocateOldLogs(File dir) {\n        final Pattern logfile = Pattern.compile(\"slave-(.*)\\\\.log(\\\\.[0-9]+)?\");\n        File[] logfiles = dir.listFiles(new FilenameFilter() {\n            public boolean accept(File dir, String name) {\n                return logfile.matcher(name).matches();\n            }\n        });\n        if (logfiles==null)     return;\n\n        for (File f : logfiles) {\n            Matcher m = logfile.matcher(f.getName());\n            if (m.matches()) {\n                File newLocation = new File(dir, \"logs/slaves/\" + m.group(1) + \"/slave.log\" + Util.fixNull(m.group(2)));\n                newLocation.getParentFile().mkdirs();\n                boolean relocationSuccessfull=f.renameTo(newLocation);\n                if (relocationSuccessfull) { // The operation will fail if mkdir fails\n                    LOGGER.log(Level.INFO, \"Relocated log file {0} to {1}\",new Object[] {f.getPath(),newLocation.getPath()});\n                } else {\n                    LOGGER.log(Level.WARNING, \"Cannot relocate log file {0} to {1}\",new Object[] {f.getPath(),newLocation.getPath()});\n                }\n            } else {\n                assert false;\n            }\n        }\n    }\n\n    /**\n     * A value class to provide a consistent snapshot view of the state of an executor to avoid race conditions\n     * during rendering of the executors list.\n     *\n     * @since 1.607\n     */\n    @Restricted(NoExternalUse.class)\n    public static class DisplayExecutor implements ModelObject {\n\n        @Nonnull\n        private final String displayName;\n        @Nonnull\n        private final String url;\n        @Nonnull\n        private final Executor executor;\n\n        public DisplayExecutor(@Nonnull String displayName, @Nonnull String url, @Nonnull Executor executor) {\n            this.displayName = displayName;\n            this.url = url;\n            this.executor = executor;\n        }\n\n        @Override\n        @Nonnull\n        public String getDisplayName() {\n            return displayName;\n        }\n\n        @Nonnull\n        public String getUrl() {\n            return url;\n        }\n\n        @Nonnull\n        public Executor getExecutor() {\n            return executor;\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder(\"DisplayExecutor{\");\n            sb.append(\"displayName='\").append(displayName).append('\\'');\n            sb.append(\", url='\").append(url).append('\\'');\n            sb.append(\", executor=\").append(executor);\n            sb.append('}');\n            return sb.toString();\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            DisplayExecutor that = (DisplayExecutor) o;\n\n            if (!executor.equals(that.executor)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        @Extension(ordinal = Double.MAX_VALUE)\n        @Restricted(DoNotUse.class)\n        public static class InternalComputerListener extends ComputerListener {\n            @Override\n            public void onOnline(Computer c, TaskListener listener) throws IOException, InterruptedException {\n                c.cachedEnvironment = null;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return executor.hashCode();\n        }\n    }\n\n    /**\n     * Used to trace requests to terminate a computer.\n     *\n     * @since 1.607\n     */\n    public static class TerminationRequest extends RuntimeException {\n        private final long when;\n        public TerminationRequest(String message) {\n            super(message);\n            this.when = System.currentTimeMillis();\n        }\n\n        /**\n         * Returns the when the termination request was created.\n         *\n         * @return the difference, measured in milliseconds, between\n         * the time of the termination request and midnight, January 1, 1970 UTC.\n         */\n        public long getWhen() {\n            return when;\n        }\n    }\n\n    public static final PermissionGroup PERMISSIONS = new PermissionGroup(Computer.class,Messages._Computer_Permissions_Title());\n    public static final Permission CONFIGURE = new Permission(PERMISSIONS,\"Configure\", Messages._Computer_ConfigurePermission_Description(), Permission.CONFIGURE, PermissionScope.COMPUTER);\n    /**\n     * @since 1.532\n     */\n    public static final Permission EXTENDED_READ = new Permission(PERMISSIONS,\"ExtendedRead\", Messages._Computer_ExtendedReadPermission_Description(), CONFIGURE, Boolean.getBoolean(\"hudson.security.ExtendedReadPermission\"), new PermissionScope[]{PermissionScope.COMPUTER});\n    public static final Permission DELETE = new Permission(PERMISSIONS,\"Delete\", Messages._Computer_DeletePermission_Description(), Permission.DELETE, PermissionScope.COMPUTER);\n    public static final Permission CREATE = new Permission(PERMISSIONS,\"Create\", Messages._Computer_CreatePermission_Description(), Permission.CREATE, PermissionScope.COMPUTER);\n    public static final Permission DISCONNECT = new Permission(PERMISSIONS,\"Disconnect\", Messages._Computer_DisconnectPermission_Description(), Jenkins.ADMINISTER, PermissionScope.COMPUTER);\n    public static final Permission CONNECT = new Permission(PERMISSIONS,\"Connect\", Messages._Computer_ConnectPermission_Description(), DISCONNECT, PermissionScope.COMPUTER);\n    public static final Permission BUILD = new Permission(PERMISSIONS, \"Build\", Messages._Computer_BuildPermission_Description(),  Permission.WRITE, PermissionScope.COMPUTER);\n\n    private static final Logger LOGGER = Logger.getLogger(Computer.class.getName());\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2013 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.startsWith;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.when;\nimport hudson.security.ACL;\nimport hudson.security.AccessDeniedException2;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.ServletOutputStream;\n\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.DummySecurityRealm;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n/**\n * @author ogondza\n */\npublic class ComputerConfigDotXmlTest {\n\n    @Rule public final JenkinsRule rule = new JenkinsRule();\n\n    @Mock private StaplerRequest req;\n    @Mock private StaplerResponse rsp;\n\n    private Computer computer;\n    private SecurityContext oldSecurityContext;\n\n    @Before\n    public void setUp() throws Exception {\n\n        MockitoAnnotations.initMocks(this);\n        computer = spy(rule.createSlave().toComputer());\n        rule.jenkins.setSecurityRealm(rule.createDummySecurityRealm());\n        oldSecurityContext = ACL.impersonate(User.get(\"user\").impersonate());\n    }\n\n    @After\n    public void tearDown() {\n\n        SecurityContextHolder.setContext(oldSecurityContext);\n    }\n\n    @Test(expected = AccessDeniedException2.class)\n    public void configXmlGetShouldFailForUnauthorized() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"GET\");\n\n        rule.jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy());\n\n        computer.doConfigDotXml(req, rsp);\n    }\n\n    @Test(expected = AccessDeniedException2.class)\n    public void configXmlPostShouldFailForUnauthorized() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"POST\");\n\n        rule.jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy());\n\n        computer.doConfigDotXml(req, rsp);\n    }\n\n    @Test\n    public void configXmlGetShouldYieldNodeConfiguration() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"GET\");\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        rule.jenkins.setAuthorizationStrategy(auth);\n        Computer.EXTENDED_READ.setEnabled(true);\n        auth.add(Computer.EXTENDED_READ, \"user\");\n\n        final OutputStream outputStream = captureOutput();\n\n        computer.doConfigDotXml(req, rsp);\n\n        final String out = outputStream.toString();\n        assertThat(out, startsWith(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"));\n        assertThat(out, containsString(\"<name>slave0</name>\"));\n        assertThat(out, containsString(\"<description>dummy</description>\"));\n    }\n\n    @Test\n    public void configXmlPostShouldUpdateNodeConfiguration() throws Exception {\n\n        when(req.getMethod()).thenReturn(\"POST\");\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        rule.jenkins.setAuthorizationStrategy(auth);\n        auth.add(Computer.CONFIGURE, \"user\");\n\n        when(req.getInputStream()).thenReturn(xmlNode(\"node.xml\"));\n\n        computer.doConfigDotXml(req, rsp);\n\n        final Node updatedSlave = rule.jenkins.getNode(\"SlaveFromXML\");\n        assertThat(updatedSlave.getNodeName(), equalTo(\"SlaveFromXML\"));\n        assertThat(updatedSlave.getNumExecutors(), equalTo(42));\n    }\n\n    @Test\n    @Issue(\"SECURITY-343\")\n    public void emptyNodeMonitorDataWithoutConnect() throws Exception {\n        rule.jenkins.setAuthorizationStrategy(new GlobalMatrixAuthorizationStrategy());\n\n        assertTrue(computer.getMonitorData().isEmpty());\n    }\n\n    @Test\n    @Issue(\"SECURITY-343\")\n    public void populatedNodeMonitorDataWithConnect() throws Exception {\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        rule.jenkins.setAuthorizationStrategy(auth);\n        auth.add(Computer.CONNECT, \"user\");\n\n        assertFalse(computer.getMonitorData().isEmpty());\n    }\n\n\n\n    private OutputStream captureOutput() throws IOException {\n\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        when(rsp.getOutputStream()).thenReturn(new ServletOutputStream() {\n\n            @Override\n            public void write(int b) throws IOException {\n\n                baos.write(b);\n            }\n        });\n\n        return baos;\n    }\n\n    private ServletInputStream xmlNode(final String name) {\n\n        class Stream extends ServletInputStream {\n\n            private final InputStream inner;\n\n            public Stream(final InputStream inner) {\n\n                this.inner = inner;\n            }\n\n            @Override\n            public int read() throws IOException {\n\n                return inner.read();\n            }\n        }\n\n        return new Stream(Computer.class.getResourceAsStream(name));\n    }\n}\n"], "filenames": ["core/src/main/java/hudson/model/Computer.java", "test/src/test/java/hudson/model/ComputerConfigDotXmlTest.java"], "buggy_code_start_loc": [1075, 29], "buggy_code_end_loc": [1077, 142], "fixing_code_start_loc": [1075, 30], "fixing_code_end_loc": [1079, 166], "type": "CWE-200", "message": "In jenkins before versions 2.44, 2.32.2 node monitor data could be viewed by low privilege users via the remote API. These included system configuration and runtime information of these nodes (SECURITY-343).", "other": {"cve": {"id": "CVE-2017-2600", "sourceIdentifier": "secalert@redhat.com", "published": "2018-05-15T20:29:00.213", "lastModified": "2019-10-09T23:26:54.553", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In jenkins before versions 2.44, 2.32.2 node monitor data could be viewed by low privilege users via the remote API. These included system configuration and runtime information of these nodes (SECURITY-343)."}, {"lang": "es", "value": "En Jenkins en versiones anteriores a la 2.44 y 2.32.2, los usuarios con privilegios bajos podr\u00edan visualizar los datos del monitor de nodos mediante la API remota. Estos datos incluyen la configuraci\u00f3n del sistema y la informaci\u00f3n de arranque de estos nodos (SECURITY-343)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-325"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.44", "matchCriteriaId": "D4595374-F7F2-43D5-BB78-37E8377B1E45"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndExcluding": "2.32.2", "matchCriteriaId": "F1F48E96-6C2B-4773-98A4-BFF626A0811F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95954", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2600", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/jenkinsci/jenkins/commit/0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://jenkins.io/security/advisory/2017-02-01/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899"}}