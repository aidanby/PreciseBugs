{"buggy_code": ["package profile\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\tmathrand \"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/dropbox/godropbox/container/set\"\n\t\"github.com/dropbox/godropbox/errors\"\n\t\"github.com/pritunl/pritunl-client-electron/service/command\"\n\t\"github.com/pritunl/pritunl-client-electron/service/errortypes\"\n\t\"github.com/pritunl/pritunl-client-electron/service/event\"\n\t\"github.com/pritunl/pritunl-client-electron/service/network\"\n\t\"github.com/pritunl/pritunl-client-electron/service/sprofile\"\n\t\"github.com/pritunl/pritunl-client-electron/service/token\"\n\t\"github.com/pritunl/pritunl-client-electron/service/utils\"\n\t\"golang.org/x/crypto/nacl/box\"\n)\n\nconst (\n\tconnTimeout  = 60 * time.Second\n\tresetWait    = 3000 * time.Millisecond\n\tnetResetWait = 4000 * time.Millisecond\n)\n\nvar (\n\tProfiles = struct {\n\t\tsync.RWMutex\n\t\tm map[string]*Profile\n\t}{\n\t\tm: map[string]*Profile{},\n\t}\n\tPing            = time.Now()\n\tclientTransport = &http.Transport{\n\t\tDisableKeepAlives:   true,\n\t\tTLSHandshakeTimeout: 5 * time.Second,\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t\tMinVersion:         tls.VersionTLS12,\n\t\t\tMaxVersion:         tls.VersionTLS13,\n\t\t},\n\t}\n\tclientInsecure = &http.Client{\n\t\tTransport: clientTransport,\n\t\tTimeout:   10 * time.Second,\n\t}\n\tclientConnInsecure = &http.Client{\n\t\tTransport: clientTransport,\n\t\tTimeout:   45 * time.Second,\n\t}\n\tipReg = regexp.MustCompile(`(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}`)\n)\n\ntype WgKeyReq struct {\n\tData      string `json:\"data\"`\n\tNonce     string `json:\"nonce\"`\n\tPublicKey string `json:\"public_key\"`\n\tSignature string `json:\"signature\"`\n}\n\ntype WgKeyBox struct {\n\tDeviceId    string   `json:\"device_id\"`\n\tDeviceName  string   `json:\"device_name\"`\n\tPlatform    string   `json:\"platform\"`\n\tMacAddr     string   `json:\"mac_addr\"`\n\tMacAddrs    []string `json:\"mac_addrs\"`\n\tToken       string   `json:\"token\"`\n\tNonce       string   `json:\"nonce\"`\n\tPassword    string   `json:\"password\"`\n\tTimestamp   int64    `json:\"timestamp\"`\n\tWgPublicKey string   `json:\"wg_public_key\"`\n}\n\ntype WgKeyResp struct {\n\tData      string `json:\"data\"`\n\tNonce     string `json:\"nonce\"`\n\tSignature string `json:\"signature\"`\n}\n\ntype Route struct {\n\tNextHop    string `json:\"next_hop\"`\n\tNetwork    string `json:\"network\"`\n\tMetric     int    `json:\"metric\"`\n\tNetGateway bool   `json:\"net_gateway\"`\n}\n\ntype WgConf struct {\n\tAddress       string   `json:\"address\"`\n\tAddress6      string   `json:\"address6\"`\n\tHostname      string   `json:\"hostname\"`\n\tHostname6     string   `json:\"hostname6\"`\n\tGateway       string   `json:\"gateway\"`\n\tGateway6      string   `json:\"gateway6\"`\n\tPort          int      `json:\"port\"`\n\tPublicKey     string   `json:\"public_key\"`\n\tRoutes        []*Route `json:\"routes\"`\n\tRoutes6       []*Route `json:\"routes6\"`\n\tDnsServers    []string `json:\"dns_servers\"`\n\tSearchDomains []string `json:\"search_domains\"`\n}\n\ntype WgData struct {\n\tAllow         bool    `json:\"allow\"`\n\tReason        string  `json:\"reason\"`\n\tConfiguration *WgConf `json:\"configuration\"`\n}\n\ntype WgPingData struct {\n\tStatus    bool `json:\"status\"`\n\tTimestamp int  `json:\"timestamp\"`\n}\n\ntype OutputData struct {\n\tId     string `json:\"id\"`\n\tOutput string `json:\"output\"`\n}\n\ntype Profile struct {\n\tstate              bool               `json:\"-\"`\n\tstateLock          sync.Mutex         `json:\"-\"`\n\twgQuickLock        sync.Mutex         `json:\"-\"`\n\tconnected          bool               `json:\"-\"`\n\tstop               bool               `json:\"-\"`\n\tstartTime          time.Time          `json:\"-\"`\n\tauthFailed         bool               `json:\"-\"`\n\twaiters            []chan bool        `json:\"-\"`\n\tremPaths           []string           `json:\"-\"`\n\twgPath             string             `json:\"-\"`\n\twgQuickPath        string             `json:\"-\"`\n\twgConfPth          string             `json:\"-\"`\n\twgHandshake        int                `json:\"-\"`\n\twgServerPublicKey  string             `json:\"-\"`\n\twgReqCancel        context.CancelFunc `json:\"-\"`\n\tcmd                *exec.Cmd          `json:\"-\"`\n\tintf               *utils.Interface   `json:\"-\"`\n\tlastAuthErr        time.Time          `json:\"-\"`\n\ttoken              *token.Token       `json:\"-\"`\n\tId                 string             `json:\"id\"`\n\tMode               string             `json:\"mode\"`\n\tOrgId              string             `json:\"-\"`\n\tUserId             string             `json:\"-\"`\n\tServerId           string             `json:\"-\"`\n\tSyncToken          string             `json:\"-\"`\n\tSyncSecret         string             `json:\"-\"`\n\tPrivateKeyWg       string             `json:\"-\"`\n\tPublicKeyWg        string             `json:\"-\"`\n\tPrivateKey         string             `json:\"-\"`\n\tDeviceId           string             `json:\"-\"`\n\tDeviceName         string             `json:\"-\"`\n\tData               string             `json:\"-\"`\n\tUsername           string             `json:\"-\"`\n\tPassword           string             `json:\"-\"`\n\tServerPublicKey    string             `json:\"-\"`\n\tServerBoxPublicKey string             `json:\"-\"`\n\tTokenTtl           int                `json:\"-\"`\n\tIface              string             `json:\"iface\"`\n\tTuniface           string             `json:\"tun_iface\"`\n\tRoutes             []*Route           `json:\"routes'\"`\n\tRoutes6            []*Route           `json:\"routes6'\"`\n\tReconnect          bool               `json:\"reconnect\"`\n\tStatus             string             `json:\"status\"`\n\tTimestamp          int64              `json:\"timestamp\"`\n\tGatewayAddr        string             `json:\"gateway_addr\"`\n\tGatewayAddr6       string             `json:\"gateway_addr6\"`\n\tServerAddr         string             `json:\"server_addr\"`\n\tClientAddr         string             `json:\"client_addr\"`\n\tMacAddr            string             `json:\"mac_addr\"`\n\tMacAddrs           []string           `json:\"mac_addrs\"`\n\tSystemProfile      *sprofile.Sprofile `json:\"-\"`\n}\n\ntype AuthData struct {\n\tToken     string `json:\"token\"`\n\tPassword  string `json:\"password\"`\n\tNonce     string `json:\"nonce\"`\n\tTimestamp int64  `json:\"timestamp\"`\n}\n\nfunc (p *Profile) write() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id)\n\n\tdata := \"\"\n\tfor _, line := range strings.Split(p.Data, \"\\n\") {\n\t\ttrimLine := strings.TrimSpace(line)\n\t\ttrimLine = strings.Trim(trimLine, \"#\")\n\t\ttrimLine = strings.Trim(trimLine, \"-\")\n\t\ttrimLine = strings.Trim(trimLine, \"_\")\n\t\ttrimLine = strings.Trim(trimLine, \":\")\n\t\ttrimLine = strings.Trim(trimLine, \";\")\n\t\ttrimLine = strings.Trim(trimLine, \"*\")\n\t\ttrimLine = strings.Trim(trimLine, \"%\")\n\t\ttrimLine = strings.Trim(trimLine, \"$\")\n\t\ttrimLine = strings.Trim(trimLine, \"+\")\n\t\ttrimLine = strings.Trim(trimLine, \"=\")\n\t\ttrimLine = strings.Trim(trimLine, \"~\")\n\t\ttrimLine = strings.Trim(trimLine, \"(\")\n\t\ttrimLine = strings.Trim(trimLine, \")\")\n\t\ttrimLine = strings.Trim(trimLine, \"[\")\n\t\ttrimLine = strings.Trim(trimLine, \"]\")\n\t\ttrimLine = strings.Trim(trimLine, \"{\")\n\t\ttrimLine = strings.Trim(trimLine, \"}\")\n\n\t\tif strings.Contains(trimLine, \"script-security\") ||\n\t\t\tstrings.HasPrefix(trimLine, \"log \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"up \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"down \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"route-pre-down \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"tls-verify \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"ipchange \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"route-up \") {\n\n\t\t\tcontinue\n\t\t}\n\t\tdata += line + \"\\n\"\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(data), os.FileMode(0600))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write profile\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeUp() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-up.sh\")\n\n\tscript := \"\"\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tscript = upScriptDarwin\n\t\tbreak\n\tcase \"linux\":\n\t\tresolved := true\n\n\t\tresolvData, _ := ioutil.ReadFile(\"/etc/resolv.conf\")\n\t\tif resolvData != nil {\n\t\t\tresolvDataStr := string(resolvData)\n\t\t\tif !strings.Contains(resolvDataStr, \"systemd-resolved\") &&\n\t\t\t\t!strings.Contains(resolvDataStr, \"127.0.0.53\") {\n\n\t\t\t\tresolved = false\n\t\t\t}\n\t\t}\n\n\t\tif resolved {\n\t\t\tscript = resolvedScript\n\t\t} else {\n\t\t\tscript = resolvScript\n\t\t}\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(script), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write up script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeDown() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-down.sh\")\n\n\tscript := \"\"\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tscript = downScriptDarwin\n\t\tbreak\n\tcase \"linux\":\n\t\tresolved := true\n\n\t\tresolvData, _ := ioutil.ReadFile(\"/etc/resolv.conf\")\n\t\tif resolvData != nil {\n\t\t\tresolvDataStr := string(resolvData)\n\t\t\tif !strings.Contains(resolvDataStr, \"systemd-resolved\") &&\n\t\t\t\t!strings.Contains(resolvDataStr, \"127.0.0.53\") {\n\n\t\t\t\tresolved = false\n\t\t\t}\n\t\t}\n\n\t\tif resolved {\n\t\t\tscript = resolvedScript\n\t\t} else {\n\t\t\tscript = resolvScript\n\t\t}\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(script), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write down script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeBlock() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-block.sh\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(blockScript), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write block script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeAuth() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tusername := p.Username\n\tpassword := p.Password\n\n\tif p.ServerBoxPublicKey != \"\" {\n\t\tvar serverPubKey [32]byte\n\t\tserverPubKeySlic, e := base64.StdEncoding.DecodeString(\n\t\t\tp.ServerBoxPublicKey)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to decode server box key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\t\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\t\tp.token = tokn\n\n\t\tauthToken := \"\"\n\t\tif tokn != nil {\n\t\t\terr = tokn.Update()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tauthToken = tokn.Token\n\t\t} else {\n\t\t\tauthToken, err = utils.RandStrComplex(16)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tauthData := strings.Join([]string{\n\t\t\tauthToken,\n\t\t\tfmt.Sprintf(\"%d\", time.Now().Unix()),\n\t\t\tpassword,\n\t\t}, \"\")\n\n\t\tsenderPubKey, senderPrivKey, e := box.GenerateKey(rand.Reader)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ReadError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to generate nacl key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tvar nonce [24]byte\n\t\tnonceHash := sha256.Sum256(senderPubKey[:])\n\t\tcopy(nonce[:], nonceHash[:24])\n\n\t\tusername = base64.RawStdEncoding.EncodeToString(senderPubKey[:])\n\n\t\tencrypted := box.Seal([]byte{}, []byte(authData),\n\t\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\t\tciphertext64 := base64.RawStdEncoding.EncodeToString(encrypted)\n\t\tpassword = \"$x$\" + ciphertext64\n\t} else if p.ServerPublicKey != \"\" {\n\t\tblock, _ := pem.Decode([]byte(p.ServerPublicKey))\n\n\t\tpub, e := x509.ParsePKCS1PublicKey(block.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse public key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tnonce, e := utils.RandStr(32)\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\treturn\n\t\t}\n\n\t\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\t\tp.token = tokn\n\n\t\tauthToken := \"\"\n\t\tif tokn != nil {\n\t\t\terr = tokn.Update()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tauthToken = tokn.Token\n\t\t}\n\n\t\tauthData := &AuthData{\n\t\t\tToken:     authToken,\n\t\t\tPassword:  password,\n\t\t\tNonce:     nonce,\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t}\n\n\t\tauthDataJson, e := json.Marshal(authData)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to encode auth data\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tciphertext, e := rsa.EncryptOAEP(\n\t\t\tsha512.New(),\n\t\t\trand.Reader,\n\t\t\tpub,\n\t\t\tauthDataJson,\n\t\t\t[]byte{},\n\t\t)\n\t\tif e != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to encrypt auth data\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tciphertext64 := base64.StdEncoding.EncodeToString(ciphertext)\n\n\t\tpassword = \"<%=RSA_ENCRYPTED=%>\" + ciphertext64\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\".auth\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(username+\"\\n\"+password+\"\\n\"),\n\t\tos.FileMode(0600))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write profile auth\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) generateWgKey() (err error) {\n\tprivateKey, err := utils.ExecOutput(p.wgPath, \"genkey\")\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tpublicKey, err := utils.ExecInputOutput(privateKey, p.wgPath, \"pubkey\")\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get public key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tp.PrivateKeyWg = strings.TrimSpace(privateKey)\n\tp.PublicKeyWg = strings.TrimSpace(publicKey)\n\n\treturn\n}\n\nfunc (p *Profile) writeConfWgLinux() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\".key\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(\n\t\tpth,\n\t\t[]byte(p.PrivateKeyWg+\"\\n\"),\n\t\tos.FileMode(0600),\n\t)\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeConfWgQuick(data *WgConf) (pth string, err error) {\n\tallowedIps := []string{}\n\tif data.Routes != nil {\n\t\tfor _, route := range data.Routes {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\tif data.Routes6 != nil {\n\t\tfor _, route := range data.Routes6 {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\n\taddr := data.Address\n\tif data.Address6 != \"\" {\n\t\taddr += \",\" + data.Address6\n\t}\n\n\ttemplData := WgConfData{\n\t\tAddress:    addr,\n\t\tPrivateKey: p.PrivateKeyWg,\n\t\tPublicKey:  data.PublicKey,\n\t\tAllowedIps: strings.Join(allowedIps, \",\"),\n\t\tEndpoint:   fmt.Sprintf(\"%s:%d\", data.Hostname, data.Port),\n\t}\n\n\tif data.DnsServers != nil && len(data.DnsServers) > 0 {\n\t\ttemplData.HasDns = true\n\t\ttemplData.DnsServers = strings.Join(data.DnsServers, \",\")\n\t}\n\n\toutput := &bytes.Buffer{}\n\terr = WgConfTempl.Execute(output, templData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to exec wg template\"),\n\t\t}\n\t\treturn\n\t}\n\n\trootDir := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\trootDir = WgLinuxConfPath\n\n\t\terr = os.MkdirAll(WgLinuxConfPath, 0700)\n\t\tif err != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(\n\t\t\t\t\terr, \"profile: Failed to create wg conf directory\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tcase \"darwin\":\n\t\trootDir = WgMacConfPath\n\n\t\terr = os.MkdirAll(WgMacConfPath, 0700)\n\t\tif err != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(\n\t\t\t\t\terr, \"profile: Failed to create wg conf directory\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\trootDir, err = utils.GetTempDir()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tpth = filepath.Join(rootDir, p.Iface+\".conf\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(\n\t\tpth,\n\t\t[]byte(output.String()),\n\t\tos.FileMode(0600),\n\t)\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write wg conf\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeWgConf(data *WgConf) (pth string, err error) {\n\tswitch runtime.GOOS {\n\tcase \"linux\", \"darwin\", \"windows\":\n\t\tpth, err = p.writeConfWgQuick(data)\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) update() {\n\tevt := event.Event{\n\t\tType: \"update\",\n\t\tData: p,\n\t}\n\tevt.Init()\n\n\tstatus := GetStatus()\n\n\tif status {\n\t\tevt := event.Event{\n\t\t\tType: \"connected\",\n\t\t}\n\t\tevt.Init()\n\t} else {\n\t\tevt := event.Event{\n\t\t\tType: \"disconnected\",\n\t\t}\n\t\tevt.Init()\n\t}\n}\n\nfunc (p *Profile) pushOutput(output string) {\n\tif p.SystemProfile != nil {\n\t\terr := p.SystemProfile.PushOutput(output + \"\\n\")\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"output\": output,\n\t\t\t\t\"error\":  err,\n\t\t\t}).Error(\"profile: Failed to push profile log output\")\n\t\t}\n\t} else {\n\t\tevt := &event.Event{\n\t\t\tType: \"output\",\n\t\t\tData: &OutputData{\n\t\t\t\tId:     p.Id,\n\t\t\t\tOutput: output,\n\t\t\t},\n\t\t}\n\t\tevt.Init()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) parseLine(line string) {\n\tp.pushOutput(line)\n\n\tif strings.Contains(line, \"Initialization Sequence Completed\") {\n\t\tp.connected = true\n\t\tp.Status = \"connected\"\n\t\tp.Timestamp = time.Now().Unix() - 5\n\t\tp.update()\n\n\t\ttokn := p.token\n\t\tif tokn != nil {\n\t\t\ttokn.Valid = true\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tutils.ClearDNSCache()\n\t\t}()\n\t} else if strings.Contains(line, \"Inactivity timeout (--inactive)\") {\n\t\tevt := event.Event{\n\t\t\tType: \"inactive\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tp.stop = true\n\t} else if strings.Contains(line, \"Inactivity timeout\") {\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\trestartLock.Lock()\n\t\t\tif p.stop {\n\t\t\t\trestartLock.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tprfl := p.Copy()\n\t\t\trestartLock.Unlock()\n\n\t\t\terr := p.Stop()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Stop error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tp.Wait()\n\n\t\t\tif prfl.Reconnect {\n\t\t\t\terr = prfl.Start(false)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Restart error\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t} else if strings.Contains(\n\t\tline, \"Can't assign requested address (code=49)\") {\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(3 * time.Second)\n\n\t\t\tif !p.stop {\n\t\t\t\tRestartProfiles(true)\n\t\t\t}\n\t\t}()\n\t} else if strings.Contains(line, \"AUTH_FAILED\") || strings.Contains(\n\t\tline, \"auth-failure\") && !p.authFailed {\n\n\t\tp.stop = true\n\t\tp.authFailed = true\n\n\t\ttokn := p.token\n\t\tif tokn != nil {\n\t\t\ttokn.Init()\n\t\t}\n\n\t\tif time.Since(p.lastAuthErr) > 10*time.Second {\n\t\t\tp.lastAuthErr = time.Now()\n\n\t\t\tevt := event.Event{\n\t\t\t\tType: \"auth_error\",\n\t\t\t\tData: p,\n\t\t\t}\n\t\t\tevt.Init()\n\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t}\n\t} else if strings.Contains(line, \"link remote:\") {\n\t\tsIndex := strings.LastIndex(line, \"]\") + 1\n\t\teIndex := strings.LastIndex(line, \":\")\n\n\t\tp.ServerAddr = line[sIndex:eIndex]\n\t\tp.update()\n\t} else if strings.Contains(line, \"network/local/netmask\") {\n\t\teIndex := strings.LastIndex(line, \"/\")\n\t\tline = line[:eIndex]\n\t\tsIndex := strings.LastIndex(line, \"/\") + 1\n\n\t\tp.ClientAddr = line[sIndex:]\n\t\tp.update()\n\t} else if strings.Contains(line, \"ifconfig\") && strings.Contains(\n\t\tline, \"netmask\") {\n\n\t\tsIndex := strings.Index(line, \"ifconfig\") + 9\n\t\teIndex := strings.Index(line, \"netmask\")\n\t\tline = line[sIndex:eIndex]\n\n\t\tsplit := strings.Split(line, \" \")\n\t\tif len(split) > 2 {\n\t\t\tp.ClientAddr = split[1]\n\t\t\tp.update()\n\t\t}\n\t} else if strings.Contains(line, \"ip addr add dev\") {\n\t\tclientAddr := \"\"\n\t\tsIndex := strings.Index(line, \"ip addr add dev\") + 16\n\t\teIndex := strings.Index(line, \"broadcast\")\n\n\t\tif eIndex == -1 {\n\t\t\tipList := ipReg.FindAllString(line, -1)\n\t\t\tif len(ipList) > 0 {\n\t\t\t\tclientAddr = ipList[0]\n\t\t\t}\n\t\t} else {\n\t\t\tline = line[sIndex:eIndex]\n\t\t\tsplit := strings.Split(line, \" \")\n\n\t\t\tif len(split) > 1 {\n\t\t\t\tsplit := strings.Split(split[1], \"/\")\n\t\t\t\tif len(split) > 1 {\n\t\t\t\t\tclientAddr = split[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif clientAddr != \"\" {\n\t\t\tp.ClientAddr = clientAddr\n\t\t\tp.update()\n\t\t}\n\t}\n}\n\nfunc (p *Profile) clearWgLinux() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\tutils.ExecOutputLogged(\n\t\t\t[]string{\n\t\t\t\t\"does not exist\",\n\t\t\t\t\"is not a\",\n\t\t\t},\n\t\t\tp.wgQuickPath,\n\t\t\t\"down\", p.Iface,\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t}\n}\n\nfunc (p *Profile) clearWgMac() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\tutils.ExecOutputLogged(\n\t\t\t[]string{\n\t\t\t\t\"is not a\",\n\t\t\t},\n\t\t\t\"/usr/local/bin/bash\",\n\t\t\tp.wgQuickPath,\n\t\t\t\"down\", p.Iface,\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t}\n}\n\nfunc (p *Profile) clearWgWin() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t\tp.wgQuickLock.Unlock()\n\t}\n}\n\nfunc (p *Profile) clearWg() {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tp.clearWgLinux()\n\t\tbreak\n\tcase \"darwin\":\n\t\tp.clearWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\tp.clearWgWin()\n\t\tbreak\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) clearStatus(start time.Time) {\n\tif p.intf != nil {\n\t\tutils.ReleaseTap(p.intf)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdiff := time.Since(start)\n\t\tif diff < 1*time.Second {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\tp.clearWg()\n\n\t\tp.Status = \"disconnected\"\n\t\tp.Timestamp = 0\n\t\tp.ClientAddr = \"\"\n\t\tp.ServerAddr = \"\"\n\t\tp.update()\n\n\t\tfor _, path := range p.remPaths {\n\t\t\tos.Remove(path)\n\t\t}\n\n\t\tProfiles.Lock()\n\t\tdelete(Profiles.m, p.Id)\n\t\tif runtime.GOOS == \"darwin\" && len(Profiles.m) == 0 {\n\t\t\terr := utils.ClearScutilKeys()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Failed to clear scutil keys\")\n\t\t\t}\n\t\t}\n\t\tProfiles.Unlock()\n\n\t\tp.stateLock.Lock()\n\t\tp.state = false\n\t\tfor _, waiter := range p.waiters {\n\t\t\twaiter <- true\n\t\t}\n\t\tp.waiters = []chan bool{}\n\t\tp.stateLock.Unlock()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"profile_id\": p.Id,\n\t\t}).Info(\"profile: Disconnected\")\n\t}()\n}\n\nfunc (p *Profile) Copy() (prfl *Profile) {\n\tprfl = &Profile{\n\t\tId:                 p.Id,\n\t\tMode:               p.Mode,\n\t\tOrgId:              p.OrgId,\n\t\tUserId:             p.UserId,\n\t\tServerId:           p.ServerId,\n\t\tSyncToken:          p.SyncToken,\n\t\tSyncSecret:         p.SyncSecret,\n\t\tData:               p.Data,\n\t\tUsername:           p.Username,\n\t\tPassword:           p.Password,\n\t\tServerPublicKey:    p.ServerPublicKey,\n\t\tServerBoxPublicKey: p.ServerBoxPublicKey,\n\t\tReconnect:          p.Reconnect,\n\t\tSystemProfile:      p.SystemProfile,\n\t\tconnected:          p.connected,\n\t}\n\tprfl.Init()\n\n\treturn\n}\n\nfunc (p *Profile) Init() {\n\tp.Id = utils.FilterStr(p.Id)\n\tp.stateLock = sync.Mutex{}\n\tp.waiters = []chan bool{}\n\tp.wgPath = GetWgPath()\n\tp.wgQuickPath = GetWgQuickPath()\n}\n\nfunc (p *Profile) Start(timeout bool) (err error) {\n\tstart := time.Now()\n\tp.startTime = start\n\tp.remPaths = []string{}\n\n\tp.Status = \"connecting\"\n\tp.stateLock.Lock()\n\tp.state = true\n\tp.stateLock.Unlock()\n\n\tProfiles.RLock()\n\tn := len(Profiles.m)\n\t_, ok := Profiles.m[p.Id]\n\tProfiles.RUnlock()\n\tif ok {\n\t\treturn\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"profile_id\": p.Id,\n\t\t\"mode\":       p.Mode,\n\t}).Info(\"profile: Connecting\")\n\n\tif runtime.GOOS == \"darwin\" && n == 0 {\n\t\tutils.ClearScutilKeys()\n\t}\n\n\tProfiles.Lock()\n\tProfiles.m[p.Id] = p\n\tProfiles.Unlock()\n\n\tif p.SystemProfile != nil {\n\t\tupdated, e := p.SystemProfile.Sync()\n\t\tif e != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"profile_id\": p.Id,\n\t\t\t\t\"error\":      e,\n\t\t\t}).Error(\"profile: Failed to sync system profile\")\n\t\t} else if updated {\n\t\t\tUpdateSystemProfile(p, p.SystemProfile)\n\t\t}\n\t}\n\n\tif p.Mode == Wg {\n\t\terr = p.startWg(timeout)\n\t} else {\n\t\terr = p.startOvpn(timeout)\n\t}\n\n\tif p.stop {\n\t\terr = nil\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) startOvpn(timeout bool) (err error) {\n\tconfPath, err := p.write()\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, confPath)\n\n\tvar authPath string\n\tif (p.Username != \"\" && p.Password != \"\") ||\n\t\tp.ServerBoxPublicKey != \"\" || p.ServerPublicKey != \"\" {\n\n\t\tauthPath, err = p.writeAuth()\n\t\tif err != nil {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, authPath)\n\t}\n\n\tp.update()\n\n\targs := []string{\n\t\t\"--config\", confPath,\n\t\t\"--verb\", \"2\",\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tp.intf, err = utils.AcquireTap()\n\t\tif err != nil {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\n\t\tif p.intf != nil {\n\t\t\targs = append(args, \"--dev-node\", p.intf.Name)\n\t\t}\n\t}\n\n\tblockPath, e := p.writeBlock()\n\tif e != nil {\n\t\terr = e\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, blockPath)\n\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\targs = append(args, \"--script-security\", \"1\")\n\t\tbreak\n\tcase \"darwin\":\n\t\tupPath, e := p.writeUp()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, upPath)\n\n\t\tdownPath, e := p.writeDown()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, downPath)\n\n\t\targs = append(args, \"--script-security\", \"2\",\n\t\t\t\"--up\", upPath,\n\t\t\t\"--down\", downPath,\n\t\t\t\"--route-pre-down\", blockPath,\n\t\t\t\"--tls-verify\", blockPath,\n\t\t\t\"--ipchange\", blockPath,\n\t\t\t\"--route-up\", blockPath,\n\t\t)\n\t\tbreak\n\tcase \"linux\":\n\t\tupPath, e := p.writeUp()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, upPath)\n\n\t\tdownPath, e := p.writeDown()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, downPath)\n\n\t\targs = append(args, \"--script-security\", \"2\",\n\t\t\t\"--up\", upPath,\n\t\t\t\"--down\", downPath,\n\t\t\t\"--route-pre-down\", blockPath,\n\t\t\t\"--tls-verify\", blockPath,\n\t\t\t\"--ipchange\", blockPath,\n\t\t\t\"--route-up\", blockPath,\n\t\t)\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\tif authPath != \"\" {\n\t\targs = append(args, \"--auth-user-pass\", authPath)\n\t}\n\n\tcmd := command.Command(getOpenvpnPath(), args...)\n\tcmd.Dir = getOpenvpnDir()\n\tp.cmd = cmd\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get stdout\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get stderr\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\toutput := make(chan string, 100)\n\toutputWait := sync.WaitGroup{}\n\toutputWait.Add(1)\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer func() {\n\t\t\tstdout.Close()\n\t\t\toutput <- \"\"\n\t\t}()\n\n\t\tout := bufio.NewReader(stdout)\n\t\tfor {\n\t\t\tline, _, err := out.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"file already closed\") &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"bad file descriptor\") {\n\n\t\t\t\t\terr = &errortypes.ReadError{\n\t\t\t\t\t\terrors.Wrap(err, \"profile: Failed to read stdout\"),\n\t\t\t\t\t}\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Stdout error\")\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlineStr := string(line)\n\t\t\tif lineStr != \"\" {\n\t\t\t\toutput <- lineStr\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer stderr.Close()\n\n\t\tout := bufio.NewReader(stderr)\n\t\tfor {\n\t\t\tline, _, err := out.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"file already closed\") &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"bad file descriptor\") {\n\n\t\t\t\t\terr = &errortypes.ReadError{\n\t\t\t\t\t\terrors.Wrap(err, \"profile: Failed to read stderr\"),\n\t\t\t\t\t}\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Stderr error\")\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlineStr := string(line)\n\t\t\tif lineStr != \"\" {\n\t\t\t\toutput <- lineStr\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer outputWait.Done()\n\n\t\tfor {\n\t\t\tline := <-output\n\t\t\tif line == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tp.parseLine(line)\n\t\t}\n\t}()\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to start openvpn\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\trunning := true\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tcmd.Wait()\n\t\toutputWait.Wait()\n\t\trunning = false\n\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\terr = utils.RestoreScutilDns()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Failed to restore DNS\")\n\t\t\t}\n\t\t}\n\n\t\tif !p.stop {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"profile_id\": p.Id,\n\t\t\t}).Error(\"profile: Unexpected profile exit\")\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t}()\n\n\tif timeout {\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(connTimeout)\n\t\t\tif p.Status != \"connected\" && running {\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tcmd.Process.Kill()\n\t\t\t\t} else {\n\t\t\t\t\terr = p.cmd.Process.Signal(os.Interrupt)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\terr = &ExecError{\n\t\t\t\t\t\t\terrors.Wrap(err,\n\t\t\t\t\t\t\t\t\"profile: Failed to interrupt openvpn\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tdone := false\n\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\tpanc := recover()\n\t\t\t\t\t\t\tif panc != nil {\n\t\t\t\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\t\t\t\tpanic(panc)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}()\n\n\t\t\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\t\t\tif done {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.cmd.Process.Kill()\n\t\t\t\t\t}()\n\n\t\t\t\t\tp.cmd.Process.Wait()\n\t\t\t\t\tdone = true\n\t\t\t\t}\n\n\t\t\t\tevt := event.Event{\n\t\t\t\t\tType: \"timeout_error\",\n\t\t\t\t\tData: p,\n\t\t\t\t}\n\t\t\t\tevt.Init()\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) reqWg(remote string) (wgData *WgData, err error) {\n\tif p.ServerBoxPublicKey == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Server box public key not set\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar serverPubKey [32]byte\n\tserverPubKeySlic, err := base64.StdEncoding.DecodeString(\n\t\tp.ServerBoxPublicKey)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to decode server box key\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\tp.token = tokn\n\n\tauthToken := \"\"\n\tif tokn != nil {\n\t\terr = tokn.Update()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tauthToken = tokn.Token\n\t} else {\n\t\tauthToken, err = utils.RandStrComplex(16)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\ttokenNonce, err := utils.RandStr(16)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tplatform := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tplatform = \"linux\"\n\t\tbreak\n\tcase \"windows\":\n\t\tplatform = \"win\"\n\t\tbreak\n\tcase \"darwin\":\n\t\tplatform = \"mac\"\n\t\tbreak\n\tdefault:\n\t\tplatform = \"unknown\"\n\t\tbreak\n\t}\n\n\twgBox := &WgKeyBox{\n\t\tDeviceId:    p.DeviceId,\n\t\tDeviceName:  p.DeviceName,\n\t\tPlatform:    platform,\n\t\tMacAddr:     p.MacAddr,\n\t\tMacAddrs:    p.MacAddrs,\n\t\tToken:       authToken,\n\t\tNonce:       tokenNonce,\n\t\tPassword:    p.Password,\n\t\tTimestamp:   time.Now().Unix(),\n\t\tWgPublicKey: p.PublicKeyWg,\n\t}\n\n\twgBoxData, err := json.Marshal(wgBox)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to marshal wg key box\"),\n\t\t}\n\t\treturn\n\t}\n\n\tsenderPubKey, senderPrivKey, err := box.GenerateKey(rand.Reader)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl key\"),\n\t\t}\n\t\treturn\n\t}\n\tsenderPubKey64 := base64.StdEncoding.EncodeToString(senderPubKey[:])\n\n\tvar nonce [24]byte\n\tnonceSl := make([]byte, 24)\n\t_, err = rand.Read(nonceSl)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(nonce[:], nonceSl)\n\n\tencrypted := box.Seal([]byte{}, wgBoxData,\n\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\tnonce64 := base64.StdEncoding.EncodeToString(nonceSl)\n\tciphertext64 := base64.StdEncoding.EncodeToString(encrypted)\n\n\twgReq := &WgKeyReq{\n\t\tData:      ciphertext64,\n\t\tNonce:     nonce64,\n\t\tPublicKey: senderPubKey64,\n\t}\n\n\tuserPrivKeyBlock, _ := pem.Decode([]byte(p.PrivateKey))\n\tif userPrivKeyBlock == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decode private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tuserPrivKey, err := x509.ParsePKCS1PrivateKey(userPrivKeyBlock.Bytes)\n\tif err != nil {\n\t\tuserPrivKeyInf, e := x509.ParsePKCS8PrivateKey(\n\t\t\tuserPrivKeyBlock.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse private key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tuserPrivKey = userPrivKeyInf.(*rsa.PrivateKey)\n\t}\n\n\treqHash := sha512.Sum512([]byte(strings.Join([]string{\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t}, \"&\")))\n\n\trsaSig, err := rsa.SignPSS(\n\t\trand.Reader,\n\t\tuserPrivKey,\n\t\tcrypto.SHA512,\n\t\treqHash[:],\n\t\t&rsa.PSSOptions{\n\t\t\tSaltLength: 0,\n\t\t\tHash:       crypto.SHA512,\n\t\t},\n\t)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to rsa sign data\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgReq.Signature = base64.StdEncoding.EncodeToString(rsaSig)\n\n\twgReqData, err := json.Marshal(wgReq)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treqPath := fmt.Sprintf(\n\t\t\"/key/wg/%s/%s/%s\",\n\t\tp.OrgId, p.UserId, p.ServerId,\n\t)\n\n\tif strings.Contains(remote, \":\") {\n\t\tremote = \"[\" + remote + \"]\"\n\t}\n\n\tu := &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   remote,\n\t\tPath:   reqPath,\n\t}\n\n\tconx, cancel := context.WithCancel(context.Background())\n\n\treq, err := http.NewRequestWithContext(\n\t\tconx,\n\t\t\"POST\",\n\t\tu.String(),\n\t\tbytes.NewBuffer(wgReqData),\n\t)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\ttimestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\tauthNonce, err := utils.RandStr(32)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tauthStr := strings.Join([]string{\n\t\tp.SyncToken,\n\t\ttimestamp,\n\t\tauthNonce,\n\t\t\"POST\",\n\t\treqPath,\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t\twgReq.Signature,\n\t}, \"&\")\n\n\thashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\thashFunc.Write([]byte(authStr))\n\trawSignature := hashFunc.Sum(nil)\n\tsig := base64.StdEncoding.EncodeToString(rawSignature)\n\n\treq.Header.Set(\"Auth-Token\", p.SyncToken)\n\treq.Header.Set(\"Auth-Timestamp\", timestamp)\n\treq.Header.Set(\"Auth-Nonce\", authNonce)\n\treq.Header.Set(\"Auth-Signature\", sig)\n\n\tp.wgReqCancel = cancel\n\tres, err := clientConnInsecure.Do(req)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\tp.wgReqCancel = nil\n\n\tif res.StatusCode != 200 {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrapf(err, \"profile: Bad status %n code from server\",\n\t\t\t\tres.StatusCode),\n\t\t}\n\t\treturn\n\t}\n\n\twgResp := &WgKeyResp{}\n\terr = json.NewDecoder(res.Body).Decode(&wgResp)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response body\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespHashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\trespHashFunc.Write([]byte(wgResp.Data + \"&\" + wgResp.Nonce))\n\trespRawSignature := respHashFunc.Sum(nil)\n\trespSig := base64.StdEncoding.EncodeToString(respRawSignature)\n\n\tif subtle.ConstantTimeCompare(\n\t\t[]byte(respSig), []byte(wgResp.Signature)) != 1 {\n\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Response signature invalid\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespCiphertext, err := base64.StdEncoding.DecodeString(wgResp.Data)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response data\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar respNonce [24]byte\n\trespNonceSl, err := base64.StdEncoding.DecodeString(wgResp.Nonce)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(respNonce[:], respNonceSl)\n\n\trespPlaintext, ok := box.Open([]byte{}, respCiphertext,\n\t\t&respNonce, &serverPubKey, senderPrivKey)\n\n\tif !ok {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decrypt response\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgData = &WgData{}\n\terr = json.Unmarshal(respPlaintext, wgData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse response\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) pingWg(remote string) (wgData *WgPingData, retry bool,\n\terr error) {\n\n\tif p.ServerBoxPublicKey == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Server box public key not set\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar serverPubKey [32]byte\n\tserverPubKeySlic, err := base64.StdEncoding.DecodeString(\n\t\tp.ServerBoxPublicKey)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to decode server box key\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\tplatform := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tplatform = \"linux\"\n\t\tbreak\n\tcase \"windows\":\n\t\tplatform = \"win\"\n\t\tbreak\n\tcase \"darwin\":\n\t\tplatform = \"mac\"\n\t\tbreak\n\tdefault:\n\t\tplatform = \"unknown\"\n\t\tbreak\n\t}\n\n\twgBox := &WgKeyBox{\n\t\tDeviceId:    p.DeviceId,\n\t\tDeviceName:  p.DeviceName,\n\t\tPlatform:    platform,\n\t\tMacAddr:     p.MacAddr,\n\t\tMacAddrs:    p.MacAddrs,\n\t\tTimestamp:   time.Now().Unix(),\n\t\tWgPublicKey: p.PublicKeyWg,\n\t}\n\n\twgBoxData, err := json.Marshal(wgBox)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to marshal wg key box\"),\n\t\t}\n\t\treturn\n\t}\n\n\tsenderPubKey, senderPrivKey, err := box.GenerateKey(rand.Reader)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl key\"),\n\t\t}\n\t\treturn\n\t}\n\tsenderPubKey64 := base64.StdEncoding.EncodeToString(senderPubKey[:])\n\n\tvar nonce [24]byte\n\tnonceSl := make([]byte, 24)\n\t_, err = rand.Read(nonceSl)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(nonce[:], nonceSl)\n\n\tencrypted := box.Seal([]byte{}, wgBoxData,\n\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\tnonce64 := base64.StdEncoding.EncodeToString(nonceSl)\n\tciphertext64 := base64.StdEncoding.EncodeToString(encrypted)\n\n\twgReq := &WgKeyReq{\n\t\tData:      ciphertext64,\n\t\tNonce:     nonce64,\n\t\tPublicKey: senderPubKey64,\n\t}\n\n\tuserPrivKeyBlock, _ := pem.Decode([]byte(p.PrivateKey))\n\tif userPrivKeyBlock == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decode private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tuserPrivKey, err := x509.ParsePKCS1PrivateKey(userPrivKeyBlock.Bytes)\n\tif err != nil {\n\t\tuserPrivKeyInf, e := x509.ParsePKCS8PrivateKey(\n\t\t\tuserPrivKeyBlock.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse private key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tuserPrivKey = userPrivKeyInf.(*rsa.PrivateKey)\n\t}\n\n\treqHash := sha512.Sum512([]byte(strings.Join([]string{\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t}, \"&\")))\n\n\trsaSig, err := rsa.SignPSS(\n\t\trand.Reader,\n\t\tuserPrivKey,\n\t\tcrypto.SHA512,\n\t\treqHash[:],\n\t\t&rsa.PSSOptions{\n\t\t\tSaltLength: 0,\n\t\t\tHash:       crypto.SHA512,\n\t\t},\n\t)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to rsa sign data\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgReq.Signature = base64.StdEncoding.EncodeToString(rsaSig)\n\n\twgReqData, err := json.Marshal(wgReq)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treqPath := fmt.Sprintf(\n\t\t\"/key/wg/%s/%s/%s\",\n\t\tp.OrgId, p.UserId, p.ServerId,\n\t)\n\n\tif strings.Contains(remote, \":\") {\n\t\tremote = \"[\" + remote + \"]\"\n\t}\n\n\tu := &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   remote,\n\t\tPath:   reqPath,\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"PUT\",\n\t\tu.String(),\n\t\tbytes.NewBuffer(wgReqData),\n\t)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\ttimestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\tauthNonce, err := utils.RandStr(32)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tauthStr := strings.Join([]string{\n\t\tp.SyncToken,\n\t\ttimestamp,\n\t\tauthNonce,\n\t\t\"PUT\",\n\t\treqPath,\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t\twgReq.Signature,\n\t}, \"&\")\n\n\thashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\thashFunc.Write([]byte(authStr))\n\trawSignature := hashFunc.Sum(nil)\n\tsig := base64.StdEncoding.EncodeToString(rawSignature)\n\n\treq.Header.Set(\"Auth-Token\", p.SyncToken)\n\treq.Header.Set(\"Auth-Timestamp\", timestamp)\n\treq.Header.Set(\"Auth-Nonce\", authNonce)\n\treq.Header.Set(\"Auth-Signature\", sig)\n\n\tres, err := clientInsecure.Do(req)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode != 200 {\n\t\tif res.StatusCode < 400 || res.StatusCode >= 500 {\n\t\t\tretry = true\n\t\t}\n\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrapf(err, \"profile: Bad status %n code from server\",\n\t\t\t\tres.StatusCode),\n\t\t}\n\t\treturn\n\t}\n\n\twgResp := &WgKeyResp{}\n\terr = json.NewDecoder(res.Body).Decode(&wgResp)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response body\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespHashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\trespHashFunc.Write([]byte(wgResp.Data + \"&\" + wgResp.Nonce))\n\trespRawSignature := respHashFunc.Sum(nil)\n\trespSig := base64.StdEncoding.EncodeToString(respRawSignature)\n\n\tif subtle.ConstantTimeCompare(\n\t\t[]byte(respSig), []byte(wgResp.Signature)) != 1 {\n\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Response signature invalid\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespCiphertext, err := base64.StdEncoding.DecodeString(wgResp.Data)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response data\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar respNonce [24]byte\n\trespNonceSl, err := base64.StdEncoding.DecodeString(wgResp.Nonce)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(respNonce[:], respNonceSl)\n\n\trespPlaintext, ok := box.Open([]byte{}, respCiphertext,\n\t\t&respNonce, &serverPubKey, senderPrivKey)\n\n\tif !ok {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decrypt response\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgData = &WgPingData{}\n\terr = json.Unmarshal(respPlaintext, wgData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse response\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgLinux(data *WgConf) (err error) {\n\tutils.ExecOutputLogged(\n\t\t[]string{\n\t\t\t\"Cannot find device\",\n\t\t},\n\t\t\"ip\", \"link\",\n\t\t\"del\", p.Iface,\n\t)\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"link\",\n\t\t\"add\", \"dev\", p.Iface,\n\t\t\"type\", \"wireguard\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"addr\",\n\t\t\"add\", data.Address,\n\t\t\"dev\", p.Iface,\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif data.Address6 != \"\" {\n\t\t_, err = utils.ExecOutputLogged(nil,\n\t\t\t\"ip\", \"-6\", \"addr\",\n\t\t\t\"add\", data.Address6,\n\t\t\t\"dev\", p.Iface,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tallowedIps := []string{}\n\tif data.Routes != nil {\n\t\tfor _, route := range data.Routes {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\tif data.Routes6 != nil {\n\t\tfor _, route := range data.Routes6 {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\tp.wgPath,\n\t\t\"set\", p.Iface,\n\t\t\"private-key\", p.wgConfPth,\n\t\t\"peer\", data.PublicKey,\n\t\t\"persistent-keepalive\", \"10\",\n\t\t\"allowed-ips\", strings.Join(allowedIps, \",\"),\n\t\t\"endpoint\", fmt.Sprintf(\"%s:%d\", data.Hostname, data.Port),\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"link\",\n\t\t\"set\", p.Iface, \"up\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif data.Routes != nil {\n\t\tp.Routes = data.Routes\n\t\tfor _, route := range data.Routes {\n\t\t\tif route.NetGateway {\n\n\t\t\t} else {\n\t\t\t\tif route.Metric != 0 {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"metric\", strconv.Itoa(route.Metric),\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif data.Routes6 != nil {\n\t\tp.Routes6 = data.Routes6\n\t\tfor _, route := range data.Routes6 {\n\t\t\tif route.NetGateway {\n\n\t\t\t} else {\n\t\t\t\tif route.Metric != 0 {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"-6\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"metric\", strconv.Itoa(route.Metric),\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"-6\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgLinuxQuick() (err error) {\n\tp.wgQuickLock.Lock()\n\tdefer p.wgQuickLock.Unlock()\n\n\tfor i := 0; i < 3; i++ {\n\t\t_, _ = utils.ExecOutput(\n\t\t\tp.wgQuickPath, \"down\", p.Iface,\n\t\t)\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\t_, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\tp.wgQuickPath,\n\t\t\t\"up\", p.Iface,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgMac() (err error) {\n\tp.wgQuickLock.Lock()\n\tdefer p.wgQuickLock.Unlock()\n\n\toutput := \"\"\n\tfor i := 0; i < 3; i++ {\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"/usr/local/bin/bash\", p.wgQuickPath, \"down\", p.Iface,\n\t\t)\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\toutput, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\t\"/usr/local/bin/bash\",\n\t\t\tp.wgQuickPath,\n\t\t\t\"up\", p.Iface,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\ttunIface := \"\"\n\tfor _, line := range strings.Split(output, \"\\n\") {\n\t\tif strings.Contains(line, \"INFO\") {\n\t\t\tmatch := wgIfaceMacReg.FindStringSubmatch(line)\n\t\t\tif match != nil && len(match) >= 2 {\n\t\t\t\ttunIface = match[1]\n\t\t\t}\n\t\t}\n\t}\n\n\tif tunIface == \"\" {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse wg interface output\"),\n\t\t}\n\t\treturn\n\t}\n\tp.Tuniface = tunIface\n\n\treturn\n}\n\nfunc (p *Profile) confWgWin() (err error) {\n\tfor i := 0; i < 3; i++ {\n\t\tp.wgQuickLock.Lock()\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\t_, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\tWgWinPath,\n\t\t\t\"/installtunnelservice\", p.wgConfPth,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWg(data *WgConf) (err error) {\n\tp.ClientAddr = data.Address\n\tp.ServerAddr = data.Hostname\n\tp.GatewayAddr = data.Gateway\n\tp.GatewayAddr6 = data.Gateway6\n\tp.wgServerPublicKey = data.PublicKey\n\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\terr = p.confWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\terr = p.confWgWin()\n\t\tbreak\n\tcase \"linux\":\n\t\terr = p.confWgLinuxQuick()\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) restart() {\n\trestartLock.Lock()\n\tif p.stop {\n\t\trestartLock.Unlock()\n\t\treturn\n\t}\n\n\tprfl := p.Copy()\n\trestartLock.Unlock()\n\n\terr := p.Stop()\n\tif err != nil {\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Stop error\")\n\t\treturn\n\t}\n\n\tp.Wait()\n\n\tif prfl.Reconnect {\n\t\terr = prfl.Start(false)\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Restart error\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Profile) updateWgHandshake() (err error) {\n\tiface := \"\"\n\tif runtime.GOOS == \"darwin\" {\n\t\tiface = p.Tuniface\n\t} else {\n\t\tiface = p.Iface\n\t}\n\n\toutput, err := utils.ExecOutputLogged(\n\t\t[]string{\n\t\t\t\"No such device\",\n\t\t\t\"access interface\",\n\t\t},\n\t\tp.wgPath, \"show\", iface,\n\t\t\"latest-handshakes\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor _, line := range strings.Split(output, \"\\n\") {\n\t\tfields := strings.Fields(line)\n\t\tif len(fields) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif fields[0] == p.wgServerPublicKey {\n\t\t\thandshake, e := strconv.Atoi(fields[1])\n\t\t\tif e != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp.wgHandshake = handshake\n\t\t\treturn\n\t\t}\n\t}\n\n\tp.wgHandshake = 0\n\treturn\n}\n\nfunc (p *Profile) watchWg() {\n\tdefer func() {\n\t\tpanc := recover()\n\t\tif panc != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\"panic\": panc,\n\t\t\t}).Error(\"profile: Panic\")\n\t\t\tpanic(panc)\n\t\t}\n\t}()\n\n\tdefer p.clearStatus(p.startTime)\n\n\ttime.Sleep(1 * time.Second)\n\n\tfor i := 0; i < 30; i++ {\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tgo p.pingWg(p.GatewayAddr)\n\t\t}\n\n\t\terr := p.updateWgHandshake()\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Check handshake status failed\")\n\t\t\tp.Stop()\n\t\t\treturn\n\t\t}\n\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif p.wgHandshake != 0 {\n\t\t\tp.connected = true\n\t\t\tp.Status = \"connected\"\n\t\t\tp.Timestamp = time.Now().Unix() - 5\n\t\t\tp.update()\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n\n\tif p.wgHandshake == 0 {\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tevt := event.Event{\n\t\t\tType: \"handshake_timeout\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tgo p.restart()\n\t\treturn\n\t}\n\n\tfor {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif p.stop {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\tvar data *WgPingData\n\t\tvar retry bool\n\t\tvar err error\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tdata, retry, err = p.pingWg(p.GatewayAddr)\n\t\t\tif !retry {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ttime.Sleep(1 * time.Millisecond)\n\t\t}\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Keepalive failed\")\n\n\t\t\tgo p.restart()\n\t\t\treturn\n\t\t}\n\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif data == nil || !data.Status {\n\t\t\tlogrus.Error(\"profile: Keepalive bad status\")\n\n\t\t\tgo p.restart()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Profile) startWg(timeout bool) (err error) {\n\terr = p.generateWgKey()\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tp.update()\n\n\tremotesSet := set.NewSet()\n\tremotes := []string{}\n\tp.PrivateKey = \"\"\n\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.New(\"profile: Failed to load interfaces\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tmacAddr := \"\"\n\tmacAddrs := []string{}\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp == 0 ||\n\t\t\tiface.Flags&net.FlagLoopback != 0 ||\n\t\t\tiface.HardwareAddr == nil ||\n\t\t\tiface.HardwareAddr.String() == \"\" {\n\n\t\t\tcontinue\n\t\t}\n\n\t\tmacAddr = iface.HardwareAddr.String()\n\t\tif p.MacAddr == \"\" {\n\t\t\tp.MacAddr = macAddr\n\t\t}\n\t\tmacAddrs = append(macAddrs, macAddr)\n\t}\n\tp.MacAddrs = macAddrs\n\n\trangeKey := false\n\tfor _, line := range strings.Split(p.Data, \"\\n\") {\n\t\tif !rangeKey {\n\t\t\tif strings.HasPrefix(line, \"setenv UV_ID\") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tp.DeviceId = lineSpl[2]\n\t\t\t} else if strings.HasPrefix(line, \"setenv UV_NAME\") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tp.DeviceName = lineSpl[2]\n\t\t\t} else if strings.HasPrefix(line, \"remote \") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 4 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tremote := lineSpl[1]\n\t\t\t\tif !remotesSet.Contains(remote) {\n\t\t\t\t\tremotesSet.Add(remote)\n\t\t\t\t\tremotes = append(remotes, remote)\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(line, \"<key>\") {\n\t\t\t\trangeKey = true\n\t\t\t}\n\t\t} else {\n\t\t\tif strings.HasPrefix(line, \"</key>\") {\n\t\t\t\trangeKey = false\n\t\t\t} else {\n\t\t\t\tp.PrivateKey += line + \"\\n\"\n\t\t\t}\n\t\t}\n\t}\n\n\tvar data *WgData\n\tfor _, i := range mathrand.Perm(len(remotes)) {\n\t\tremote := remotes[i]\n\n\t\tdata, err = p.reqWg(remote)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif p.stop {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t}\n\tif err != nil {\n\t\tevt := event.Event{\n\t\t\tType: \"connection_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Request wg connection failed\")\n\t\terr = nil\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\tif p.connected && !p.stop {\n\t\t\tgo p.restart()\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif p.stop {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif data == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Request wg returned empty data\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif !data.Allow {\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"reason\": data.Reason,\n\t\t}).Error(\"profile: Failed to authenticate wg\")\n\n\t\tevt := event.Event{\n\t\t\tType: \"auth_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif data.Configuration == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(\n\t\t\t\terr,\n\t\t\t\t\"profile: Request wg returned empty configuration\",\n\t\t\t),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tiface := network.InterfaceAcquire()\n\tif iface == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.New(\"profile: Failed to acquire interface\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.Iface = iface\n\n\twgConfPth, err := p.writeWgConf(data.Configuration)\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, wgConfPth)\n\tp.wgConfPth = wgConfPth\n\n\terr = p.confWg(data.Configuration)\n\tif err != nil {\n\t\tevt := event.Event{\n\t\t\tType: \"configuration_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Failed to configure wg\")\n\t\terr = nil\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tgo p.watchWg()\n\n\treturn\n}\n\nfunc (p *Profile) stopWgLinux() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\tutils.ExecOutputLogged(\n\t//\t\t[]string{\n\t//\t\t\t\"Cannot find device\",\n\t//\t\t},\n\t//\t\t\"ip\", \"link\",\n\t//\t\t\"del\", p.Iface,\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWgMac() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\tutils.ExecOutputLogged(\n\t//\t\t[]string{\n\t//\t\t\t\"is not a\",\n\t//\t\t},\n\t//\t\tp.wgQuickPath,\n\t//\t\t\"down\", p.Iface,\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWgWin() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\t_, _ = utils.ExecOutput(\n\t//\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t//\t)\n\t//\ttime.Sleep(100 * time.Millisecond)\n\t//\t_, _ = utils.ExecOutput(\n\t//\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWg() (err error) {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\terr = p.stopWgLinux()\n\t\tbreak\n\tcase \"darwin\":\n\t\terr = p.stopWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\terr = p.stopWgWin()\n\t\tbreak\n\tdefault:\n\t\tpanic(\"handlers: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) stopOvpn() (err error) {\n\tif runtime.GOOS == \"windows\" {\n\t\terr = p.cmd.Process.Kill()\n\t\tif err != nil {\n\t\t\terr = &ExecError{\n\t\t\t\terrors.Wrap(err, \"profile: Failed to stop openvpn\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tp.cmd.Process.Signal(os.Interrupt)\n\t\tdone := false\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tif done {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.cmd.Process.Kill()\n\t\t}()\n\n\t\tp.cmd.Process.Wait()\n\t\tdone = true\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) Stop() (err error) {\n\tif p.stop || (p.Mode != Wg && (p.cmd == nil || p.cmd.Process == nil)) {\n\t\treturn\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"profile_id\": p.Id,\n\t}).Info(\"profile: Disconnecting\")\n\n\tp.stop = true\n\tp.Status = \"disconnecting\"\n\tp.update()\n\n\tcancel := p.wgReqCancel\n\tif cancel != nil {\n\t\tcancel()\n\t}\n\n\tdiff := time.Since(p.startTime)\n\tif diff < 8*time.Second {\n\t\tdelay := time.Duration(8-int64(diff.Seconds())) * time.Second\n\t\ttime.Sleep(delay)\n\t}\n\n\tif p.Mode == Wg {\n\t\terr = p.stopWg()\n\t} else {\n\t\terr = p.stopOvpn()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) Wait() {\n\twaiter := make(chan bool, 1)\n\n\tp.stateLock.Lock()\n\tif !p.state {\n\t\treturn\n\t}\n\tp.waiters = append(p.waiters, waiter)\n\tp.stateLock.Unlock()\n\n\t<-waiter\n\ttime.Sleep(50 * time.Millisecond)\n\n\treturn\n}\n"], "fixing_code": ["package profile\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\tmathrand \"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/Sirupsen/logrus\"\n\t\"github.com/dropbox/godropbox/container/set\"\n\t\"github.com/dropbox/godropbox/errors\"\n\t\"github.com/pritunl/pritunl-client-electron/service/command\"\n\t\"github.com/pritunl/pritunl-client-electron/service/errortypes\"\n\t\"github.com/pritunl/pritunl-client-electron/service/event\"\n\t\"github.com/pritunl/pritunl-client-electron/service/network\"\n\t\"github.com/pritunl/pritunl-client-electron/service/sprofile\"\n\t\"github.com/pritunl/pritunl-client-electron/service/token\"\n\t\"github.com/pritunl/pritunl-client-electron/service/utils\"\n\t\"golang.org/x/crypto/nacl/box\"\n)\n\nconst (\n\tconnTimeout  = 60 * time.Second\n\tresetWait    = 3000 * time.Millisecond\n\tnetResetWait = 4000 * time.Millisecond\n)\n\nvar (\n\tProfiles = struct {\n\t\tsync.RWMutex\n\t\tm map[string]*Profile\n\t}{\n\t\tm: map[string]*Profile{},\n\t}\n\tPing            = time.Now()\n\tclientTransport = &http.Transport{\n\t\tDisableKeepAlives:   true,\n\t\tTLSHandshakeTimeout: 5 * time.Second,\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t\tMinVersion:         tls.VersionTLS12,\n\t\t\tMaxVersion:         tls.VersionTLS13,\n\t\t},\n\t}\n\tclientInsecure = &http.Client{\n\t\tTransport: clientTransport,\n\t\tTimeout:   10 * time.Second,\n\t}\n\tclientConnInsecure = &http.Client{\n\t\tTransport: clientTransport,\n\t\tTimeout:   45 * time.Second,\n\t}\n\tipReg = regexp.MustCompile(`(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}`)\n)\n\ntype WgKeyReq struct {\n\tData      string `json:\"data\"`\n\tNonce     string `json:\"nonce\"`\n\tPublicKey string `json:\"public_key\"`\n\tSignature string `json:\"signature\"`\n}\n\ntype WgKeyBox struct {\n\tDeviceId    string   `json:\"device_id\"`\n\tDeviceName  string   `json:\"device_name\"`\n\tPlatform    string   `json:\"platform\"`\n\tMacAddr     string   `json:\"mac_addr\"`\n\tMacAddrs    []string `json:\"mac_addrs\"`\n\tToken       string   `json:\"token\"`\n\tNonce       string   `json:\"nonce\"`\n\tPassword    string   `json:\"password\"`\n\tTimestamp   int64    `json:\"timestamp\"`\n\tWgPublicKey string   `json:\"wg_public_key\"`\n}\n\ntype WgKeyResp struct {\n\tData      string `json:\"data\"`\n\tNonce     string `json:\"nonce\"`\n\tSignature string `json:\"signature\"`\n}\n\ntype Route struct {\n\tNextHop    string `json:\"next_hop\"`\n\tNetwork    string `json:\"network\"`\n\tMetric     int    `json:\"metric\"`\n\tNetGateway bool   `json:\"net_gateway\"`\n}\n\ntype WgConf struct {\n\tAddress       string   `json:\"address\"`\n\tAddress6      string   `json:\"address6\"`\n\tHostname      string   `json:\"hostname\"`\n\tHostname6     string   `json:\"hostname6\"`\n\tGateway       string   `json:\"gateway\"`\n\tGateway6      string   `json:\"gateway6\"`\n\tPort          int      `json:\"port\"`\n\tPublicKey     string   `json:\"public_key\"`\n\tRoutes        []*Route `json:\"routes\"`\n\tRoutes6       []*Route `json:\"routes6\"`\n\tDnsServers    []string `json:\"dns_servers\"`\n\tSearchDomains []string `json:\"search_domains\"`\n}\n\ntype WgData struct {\n\tAllow         bool    `json:\"allow\"`\n\tReason        string  `json:\"reason\"`\n\tConfiguration *WgConf `json:\"configuration\"`\n}\n\ntype WgPingData struct {\n\tStatus    bool `json:\"status\"`\n\tTimestamp int  `json:\"timestamp\"`\n}\n\ntype OutputData struct {\n\tId     string `json:\"id\"`\n\tOutput string `json:\"output\"`\n}\n\ntype Profile struct {\n\tstate              bool               `json:\"-\"`\n\tstateLock          sync.Mutex         `json:\"-\"`\n\twgQuickLock        sync.Mutex         `json:\"-\"`\n\tconnected          bool               `json:\"-\"`\n\tstop               bool               `json:\"-\"`\n\tstartTime          time.Time          `json:\"-\"`\n\tauthFailed         bool               `json:\"-\"`\n\twaiters            []chan bool        `json:\"-\"`\n\tremPaths           []string           `json:\"-\"`\n\twgPath             string             `json:\"-\"`\n\twgQuickPath        string             `json:\"-\"`\n\twgConfPth          string             `json:\"-\"`\n\twgHandshake        int                `json:\"-\"`\n\twgServerPublicKey  string             `json:\"-\"`\n\twgReqCancel        context.CancelFunc `json:\"-\"`\n\tcmd                *exec.Cmd          `json:\"-\"`\n\tintf               *utils.Interface   `json:\"-\"`\n\tlastAuthErr        time.Time          `json:\"-\"`\n\ttoken              *token.Token       `json:\"-\"`\n\tId                 string             `json:\"id\"`\n\tMode               string             `json:\"mode\"`\n\tOrgId              string             `json:\"-\"`\n\tUserId             string             `json:\"-\"`\n\tServerId           string             `json:\"-\"`\n\tSyncToken          string             `json:\"-\"`\n\tSyncSecret         string             `json:\"-\"`\n\tPrivateKeyWg       string             `json:\"-\"`\n\tPublicKeyWg        string             `json:\"-\"`\n\tPrivateKey         string             `json:\"-\"`\n\tDeviceId           string             `json:\"-\"`\n\tDeviceName         string             `json:\"-\"`\n\tData               string             `json:\"-\"`\n\tUsername           string             `json:\"-\"`\n\tPassword           string             `json:\"-\"`\n\tServerPublicKey    string             `json:\"-\"`\n\tServerBoxPublicKey string             `json:\"-\"`\n\tTokenTtl           int                `json:\"-\"`\n\tIface              string             `json:\"iface\"`\n\tTuniface           string             `json:\"tun_iface\"`\n\tRoutes             []*Route           `json:\"routes'\"`\n\tRoutes6            []*Route           `json:\"routes6'\"`\n\tReconnect          bool               `json:\"reconnect\"`\n\tStatus             string             `json:\"status\"`\n\tTimestamp          int64              `json:\"timestamp\"`\n\tGatewayAddr        string             `json:\"gateway_addr\"`\n\tGatewayAddr6       string             `json:\"gateway_addr6\"`\n\tServerAddr         string             `json:\"server_addr\"`\n\tClientAddr         string             `json:\"client_addr\"`\n\tMacAddr            string             `json:\"mac_addr\"`\n\tMacAddrs           []string           `json:\"mac_addrs\"`\n\tSystemProfile      *sprofile.Sprofile `json:\"-\"`\n}\n\ntype AuthData struct {\n\tToken     string `json:\"token\"`\n\tPassword  string `json:\"password\"`\n\tNonce     string `json:\"nonce\"`\n\tTimestamp int64  `json:\"timestamp\"`\n}\n\nfunc (p *Profile) write() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id)\n\n\tdata := \"\"\n\tfor _, line := range strings.Split(p.Data, \"\\n\") {\n\t\ttrimLine := strings.TrimSpace(line)\n\t\ttrimLine = strings.Trim(trimLine, \"#\")\n\t\ttrimLine = strings.Trim(trimLine, \"-\")\n\t\ttrimLine = strings.Trim(trimLine, \"_\")\n\t\ttrimLine = strings.Trim(trimLine, \":\")\n\t\ttrimLine = strings.Trim(trimLine, \";\")\n\t\ttrimLine = strings.Trim(trimLine, \"*\")\n\t\ttrimLine = strings.Trim(trimLine, \"%\")\n\t\ttrimLine = strings.Trim(trimLine, \"$\")\n\t\ttrimLine = strings.Trim(trimLine, \"+\")\n\t\ttrimLine = strings.Trim(trimLine, \"=\")\n\t\ttrimLine = strings.Trim(trimLine, \"~\")\n\t\ttrimLine = strings.Trim(trimLine, \"(\")\n\t\ttrimLine = strings.Trim(trimLine, \")\")\n\t\ttrimLine = strings.Trim(trimLine, \"[\")\n\t\ttrimLine = strings.Trim(trimLine, \"]\")\n\t\ttrimLine = strings.Trim(trimLine, \"{\")\n\t\ttrimLine = strings.Trim(trimLine, \"}\")\n\n\t\tif strings.Contains(trimLine, \"script-security\") ||\n\t\t\tstrings.HasPrefix(trimLine, \"log \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"log-append \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"syslog \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"management \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"plugin \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"up \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"down \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"route-pre-down \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"tls-verify \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"ipchange \") ||\n\t\t\tstrings.HasPrefix(trimLine, \"route-up \") {\n\n\t\t\tcontinue\n\t\t}\n\t\tdata += line + \"\\n\"\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(data), os.FileMode(0600))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write profile\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeUp() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-up.sh\")\n\n\tscript := \"\"\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tscript = upScriptDarwin\n\t\tbreak\n\tcase \"linux\":\n\t\tresolved := true\n\n\t\tresolvData, _ := ioutil.ReadFile(\"/etc/resolv.conf\")\n\t\tif resolvData != nil {\n\t\t\tresolvDataStr := string(resolvData)\n\t\t\tif !strings.Contains(resolvDataStr, \"systemd-resolved\") &&\n\t\t\t\t!strings.Contains(resolvDataStr, \"127.0.0.53\") {\n\n\t\t\t\tresolved = false\n\t\t\t}\n\t\t}\n\n\t\tif resolved {\n\t\t\tscript = resolvedScript\n\t\t} else {\n\t\t\tscript = resolvScript\n\t\t}\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(script), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write up script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeDown() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-down.sh\")\n\n\tscript := \"\"\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tscript = downScriptDarwin\n\t\tbreak\n\tcase \"linux\":\n\t\tresolved := true\n\n\t\tresolvData, _ := ioutil.ReadFile(\"/etc/resolv.conf\")\n\t\tif resolvData != nil {\n\t\t\tresolvDataStr := string(resolvData)\n\t\t\tif !strings.Contains(resolvDataStr, \"systemd-resolved\") &&\n\t\t\t\t!strings.Contains(resolvDataStr, \"127.0.0.53\") {\n\n\t\t\t\tresolved = false\n\t\t\t}\n\t\t}\n\n\t\tif resolved {\n\t\t\tscript = resolvedScript\n\t\t} else {\n\t\t\tscript = resolvScript\n\t\t}\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(script), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write down script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeBlock() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\"-block.sh\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(blockScript), os.FileMode(0755))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write block script\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeAuth() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tusername := p.Username\n\tpassword := p.Password\n\n\tif p.ServerBoxPublicKey != \"\" {\n\t\tvar serverPubKey [32]byte\n\t\tserverPubKeySlic, e := base64.StdEncoding.DecodeString(\n\t\t\tp.ServerBoxPublicKey)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to decode server box key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\t\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\t\tp.token = tokn\n\n\t\tauthToken := \"\"\n\t\tif tokn != nil {\n\t\t\terr = tokn.Update()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tauthToken = tokn.Token\n\t\t} else {\n\t\t\tauthToken, err = utils.RandStrComplex(16)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tauthData := strings.Join([]string{\n\t\t\tauthToken,\n\t\t\tfmt.Sprintf(\"%d\", time.Now().Unix()),\n\t\t\tpassword,\n\t\t}, \"\")\n\n\t\tsenderPubKey, senderPrivKey, e := box.GenerateKey(rand.Reader)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ReadError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to generate nacl key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tvar nonce [24]byte\n\t\tnonceHash := sha256.Sum256(senderPubKey[:])\n\t\tcopy(nonce[:], nonceHash[:24])\n\n\t\tusername = base64.RawStdEncoding.EncodeToString(senderPubKey[:])\n\n\t\tencrypted := box.Seal([]byte{}, []byte(authData),\n\t\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\t\tciphertext64 := base64.RawStdEncoding.EncodeToString(encrypted)\n\t\tpassword = \"$x$\" + ciphertext64\n\t} else if p.ServerPublicKey != \"\" {\n\t\tblock, _ := pem.Decode([]byte(p.ServerPublicKey))\n\n\t\tpub, e := x509.ParsePKCS1PublicKey(block.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse public key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tnonce, e := utils.RandStr(32)\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\treturn\n\t\t}\n\n\t\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\t\tp.token = tokn\n\n\t\tauthToken := \"\"\n\t\tif tokn != nil {\n\t\t\terr = tokn.Update()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tauthToken = tokn.Token\n\t\t}\n\n\t\tauthData := &AuthData{\n\t\t\tToken:     authToken,\n\t\t\tPassword:  password,\n\t\t\tNonce:     nonce,\n\t\t\tTimestamp: time.Now().Unix(),\n\t\t}\n\n\t\tauthDataJson, e := json.Marshal(authData)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to encode auth data\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tciphertext, e := rsa.EncryptOAEP(\n\t\t\tsha512.New(),\n\t\t\trand.Reader,\n\t\t\tpub,\n\t\t\tauthDataJson,\n\t\t\t[]byte{},\n\t\t)\n\t\tif e != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to encrypt auth data\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tciphertext64 := base64.StdEncoding.EncodeToString(ciphertext)\n\n\t\tpassword = \"<%=RSA_ENCRYPTED=%>\" + ciphertext64\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\".auth\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(pth, []byte(username+\"\\n\"+password+\"\\n\"),\n\t\tos.FileMode(0600))\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write profile auth\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) generateWgKey() (err error) {\n\tprivateKey, err := utils.ExecOutput(p.wgPath, \"genkey\")\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tpublicKey, err := utils.ExecInputOutput(privateKey, p.wgPath, \"pubkey\")\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get public key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tp.PrivateKeyWg = strings.TrimSpace(privateKey)\n\tp.PublicKeyWg = strings.TrimSpace(publicKey)\n\n\treturn\n}\n\nfunc (p *Profile) writeConfWgLinux() (pth string, err error) {\n\trootDir, err := utils.GetTempDir()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tpth = filepath.Join(rootDir, p.Id+\".key\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(\n\t\tpth,\n\t\t[]byte(p.PrivateKeyWg+\"\\n\"),\n\t\tos.FileMode(0600),\n\t)\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeConfWgQuick(data *WgConf) (pth string, err error) {\n\tallowedIps := []string{}\n\tif data.Routes != nil {\n\t\tfor _, route := range data.Routes {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\tif data.Routes6 != nil {\n\t\tfor _, route := range data.Routes6 {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\n\taddr := data.Address\n\tif data.Address6 != \"\" {\n\t\taddr += \",\" + data.Address6\n\t}\n\n\ttemplData := WgConfData{\n\t\tAddress:    addr,\n\t\tPrivateKey: p.PrivateKeyWg,\n\t\tPublicKey:  data.PublicKey,\n\t\tAllowedIps: strings.Join(allowedIps, \",\"),\n\t\tEndpoint:   fmt.Sprintf(\"%s:%d\", data.Hostname, data.Port),\n\t}\n\n\tif data.DnsServers != nil && len(data.DnsServers) > 0 {\n\t\ttemplData.HasDns = true\n\t\ttemplData.DnsServers = strings.Join(data.DnsServers, \",\")\n\t}\n\n\toutput := &bytes.Buffer{}\n\terr = WgConfTempl.Execute(output, templData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to exec wg template\"),\n\t\t}\n\t\treturn\n\t}\n\n\trootDir := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\trootDir = WgLinuxConfPath\n\n\t\terr = os.MkdirAll(WgLinuxConfPath, 0700)\n\t\tif err != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(\n\t\t\t\t\terr, \"profile: Failed to create wg conf directory\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tcase \"darwin\":\n\t\trootDir = WgMacConfPath\n\n\t\terr = os.MkdirAll(WgMacConfPath, 0700)\n\t\tif err != nil {\n\t\t\terr = &errortypes.WriteError{\n\t\t\t\terrors.Wrap(\n\t\t\t\t\terr, \"profile: Failed to create wg conf directory\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\tdefault:\n\t\trootDir, err = utils.GetTempDir()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tpth = filepath.Join(rootDir, p.Iface+\".conf\")\n\n\t_ = os.Remove(pth)\n\terr = ioutil.WriteFile(\n\t\tpth,\n\t\t[]byte(output.String()),\n\t\tos.FileMode(0600),\n\t)\n\tif err != nil {\n\t\terr = &WriteError{\n\t\t\terrors.Wrap(err, \"profile: Failed to write wg conf\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) writeWgConf(data *WgConf) (pth string, err error) {\n\tswitch runtime.GOOS {\n\tcase \"linux\", \"darwin\", \"windows\":\n\t\tpth, err = p.writeConfWgQuick(data)\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) update() {\n\tevt := event.Event{\n\t\tType: \"update\",\n\t\tData: p,\n\t}\n\tevt.Init()\n\n\tstatus := GetStatus()\n\n\tif status {\n\t\tevt := event.Event{\n\t\t\tType: \"connected\",\n\t\t}\n\t\tevt.Init()\n\t} else {\n\t\tevt := event.Event{\n\t\t\tType: \"disconnected\",\n\t\t}\n\t\tevt.Init()\n\t}\n}\n\nfunc (p *Profile) pushOutput(output string) {\n\tif p.SystemProfile != nil {\n\t\terr := p.SystemProfile.PushOutput(output + \"\\n\")\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"output\": output,\n\t\t\t\t\"error\":  err,\n\t\t\t}).Error(\"profile: Failed to push profile log output\")\n\t\t}\n\t} else {\n\t\tevt := &event.Event{\n\t\t\tType: \"output\",\n\t\t\tData: &OutputData{\n\t\t\t\tId:     p.Id,\n\t\t\t\tOutput: output,\n\t\t\t},\n\t\t}\n\t\tevt.Init()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) parseLine(line string) {\n\tp.pushOutput(line)\n\n\tif strings.Contains(line, \"Initialization Sequence Completed\") {\n\t\tp.connected = true\n\t\tp.Status = \"connected\"\n\t\tp.Timestamp = time.Now().Unix() - 5\n\t\tp.update()\n\n\t\ttokn := p.token\n\t\tif tokn != nil {\n\t\t\ttokn.Valid = true\n\t\t}\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tutils.ClearDNSCache()\n\t\t}()\n\t} else if strings.Contains(line, \"Inactivity timeout (--inactive)\") {\n\t\tevt := event.Event{\n\t\t\tType: \"inactive\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tp.stop = true\n\t} else if strings.Contains(line, \"Inactivity timeout\") {\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\trestartLock.Lock()\n\t\t\tif p.stop {\n\t\t\t\trestartLock.Unlock()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tprfl := p.Copy()\n\t\t\trestartLock.Unlock()\n\n\t\t\terr := p.Stop()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Stop error\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tp.Wait()\n\n\t\t\tif prfl.Reconnect {\n\t\t\t\terr = prfl.Start(false)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Restart error\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t} else if strings.Contains(\n\t\tline, \"Can't assign requested address (code=49)\") {\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(3 * time.Second)\n\n\t\t\tif !p.stop {\n\t\t\t\tRestartProfiles(true)\n\t\t\t}\n\t\t}()\n\t} else if strings.Contains(line, \"AUTH_FAILED\") || strings.Contains(\n\t\tline, \"auth-failure\") && !p.authFailed {\n\n\t\tp.stop = true\n\t\tp.authFailed = true\n\n\t\ttokn := p.token\n\t\tif tokn != nil {\n\t\t\ttokn.Init()\n\t\t}\n\n\t\tif time.Since(p.lastAuthErr) > 10*time.Second {\n\t\t\tp.lastAuthErr = time.Now()\n\n\t\t\tevt := event.Event{\n\t\t\t\tType: \"auth_error\",\n\t\t\t\tData: p,\n\t\t\t}\n\t\t\tevt.Init()\n\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t}\n\t} else if strings.Contains(line, \"link remote:\") {\n\t\tsIndex := strings.LastIndex(line, \"]\") + 1\n\t\teIndex := strings.LastIndex(line, \":\")\n\n\t\tp.ServerAddr = line[sIndex:eIndex]\n\t\tp.update()\n\t} else if strings.Contains(line, \"network/local/netmask\") {\n\t\teIndex := strings.LastIndex(line, \"/\")\n\t\tline = line[:eIndex]\n\t\tsIndex := strings.LastIndex(line, \"/\") + 1\n\n\t\tp.ClientAddr = line[sIndex:]\n\t\tp.update()\n\t} else if strings.Contains(line, \"ifconfig\") && strings.Contains(\n\t\tline, \"netmask\") {\n\n\t\tsIndex := strings.Index(line, \"ifconfig\") + 9\n\t\teIndex := strings.Index(line, \"netmask\")\n\t\tline = line[sIndex:eIndex]\n\n\t\tsplit := strings.Split(line, \" \")\n\t\tif len(split) > 2 {\n\t\t\tp.ClientAddr = split[1]\n\t\t\tp.update()\n\t\t}\n\t} else if strings.Contains(line, \"ip addr add dev\") {\n\t\tclientAddr := \"\"\n\t\tsIndex := strings.Index(line, \"ip addr add dev\") + 16\n\t\teIndex := strings.Index(line, \"broadcast\")\n\n\t\tif eIndex == -1 {\n\t\t\tipList := ipReg.FindAllString(line, -1)\n\t\t\tif len(ipList) > 0 {\n\t\t\t\tclientAddr = ipList[0]\n\t\t\t}\n\t\t} else {\n\t\t\tline = line[sIndex:eIndex]\n\t\t\tsplit := strings.Split(line, \" \")\n\n\t\t\tif len(split) > 1 {\n\t\t\t\tsplit := strings.Split(split[1], \"/\")\n\t\t\t\tif len(split) > 1 {\n\t\t\t\t\tclientAddr = split[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif clientAddr != \"\" {\n\t\t\tp.ClientAddr = clientAddr\n\t\t\tp.update()\n\t\t}\n\t}\n}\n\nfunc (p *Profile) clearWgLinux() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\tutils.ExecOutputLogged(\n\t\t\t[]string{\n\t\t\t\t\"does not exist\",\n\t\t\t\t\"is not a\",\n\t\t\t},\n\t\t\tp.wgQuickPath,\n\t\t\t\"down\", p.Iface,\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t}\n}\n\nfunc (p *Profile) clearWgMac() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\tutils.ExecOutputLogged(\n\t\t\t[]string{\n\t\t\t\t\"is not a\",\n\t\t\t},\n\t\t\t\"/usr/local/bin/bash\",\n\t\t\tp.wgQuickPath,\n\t\t\t\"down\", p.Iface,\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t}\n}\n\nfunc (p *Profile) clearWgWin() {\n\tif p.Iface != \"\" {\n\t\tp.wgQuickLock.Lock()\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\tnetwork.InterfaceRelease(p.Iface)\n\t\tp.wgQuickLock.Unlock()\n\t}\n}\n\nfunc (p *Profile) clearWg() {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tp.clearWgLinux()\n\t\tbreak\n\tcase \"darwin\":\n\t\tp.clearWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\tp.clearWgWin()\n\t\tbreak\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) clearStatus(start time.Time) {\n\tif p.intf != nil {\n\t\tutils.ReleaseTap(p.intf)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdiff := time.Since(start)\n\t\tif diff < 1*time.Second {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\tp.clearWg()\n\n\t\tp.Status = \"disconnected\"\n\t\tp.Timestamp = 0\n\t\tp.ClientAddr = \"\"\n\t\tp.ServerAddr = \"\"\n\t\tp.update()\n\n\t\tfor _, path := range p.remPaths {\n\t\t\tos.Remove(path)\n\t\t}\n\n\t\tProfiles.Lock()\n\t\tdelete(Profiles.m, p.Id)\n\t\tif runtime.GOOS == \"darwin\" && len(Profiles.m) == 0 {\n\t\t\terr := utils.ClearScutilKeys()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Failed to clear scutil keys\")\n\t\t\t}\n\t\t}\n\t\tProfiles.Unlock()\n\n\t\tp.stateLock.Lock()\n\t\tp.state = false\n\t\tfor _, waiter := range p.waiters {\n\t\t\twaiter <- true\n\t\t}\n\t\tp.waiters = []chan bool{}\n\t\tp.stateLock.Unlock()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"profile_id\": p.Id,\n\t\t}).Info(\"profile: Disconnected\")\n\t}()\n}\n\nfunc (p *Profile) Copy() (prfl *Profile) {\n\tprfl = &Profile{\n\t\tId:                 p.Id,\n\t\tMode:               p.Mode,\n\t\tOrgId:              p.OrgId,\n\t\tUserId:             p.UserId,\n\t\tServerId:           p.ServerId,\n\t\tSyncToken:          p.SyncToken,\n\t\tSyncSecret:         p.SyncSecret,\n\t\tData:               p.Data,\n\t\tUsername:           p.Username,\n\t\tPassword:           p.Password,\n\t\tServerPublicKey:    p.ServerPublicKey,\n\t\tServerBoxPublicKey: p.ServerBoxPublicKey,\n\t\tReconnect:          p.Reconnect,\n\t\tSystemProfile:      p.SystemProfile,\n\t\tconnected:          p.connected,\n\t}\n\tprfl.Init()\n\n\treturn\n}\n\nfunc (p *Profile) Init() {\n\tp.Id = utils.FilterStr(p.Id)\n\tp.stateLock = sync.Mutex{}\n\tp.waiters = []chan bool{}\n\tp.wgPath = GetWgPath()\n\tp.wgQuickPath = GetWgQuickPath()\n}\n\nfunc (p *Profile) Start(timeout bool) (err error) {\n\tstart := time.Now()\n\tp.startTime = start\n\tp.remPaths = []string{}\n\n\tp.Status = \"connecting\"\n\tp.stateLock.Lock()\n\tp.state = true\n\tp.stateLock.Unlock()\n\n\tProfiles.RLock()\n\tn := len(Profiles.m)\n\t_, ok := Profiles.m[p.Id]\n\tProfiles.RUnlock()\n\tif ok {\n\t\treturn\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"profile_id\": p.Id,\n\t\t\"mode\":       p.Mode,\n\t}).Info(\"profile: Connecting\")\n\n\tif runtime.GOOS == \"darwin\" && n == 0 {\n\t\tutils.ClearScutilKeys()\n\t}\n\n\tProfiles.Lock()\n\tProfiles.m[p.Id] = p\n\tProfiles.Unlock()\n\n\tif p.SystemProfile != nil {\n\t\tupdated, e := p.SystemProfile.Sync()\n\t\tif e != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"profile_id\": p.Id,\n\t\t\t\t\"error\":      e,\n\t\t\t}).Error(\"profile: Failed to sync system profile\")\n\t\t} else if updated {\n\t\t\tUpdateSystemProfile(p, p.SystemProfile)\n\t\t}\n\t}\n\n\tif p.Mode == Wg {\n\t\terr = p.startWg(timeout)\n\t} else {\n\t\terr = p.startOvpn(timeout)\n\t}\n\n\tif p.stop {\n\t\terr = nil\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) startOvpn(timeout bool) (err error) {\n\tconfPath, err := p.write()\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, confPath)\n\n\tvar authPath string\n\tif (p.Username != \"\" && p.Password != \"\") ||\n\t\tp.ServerBoxPublicKey != \"\" || p.ServerPublicKey != \"\" {\n\n\t\tauthPath, err = p.writeAuth()\n\t\tif err != nil {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, authPath)\n\t}\n\n\tp.update()\n\n\targs := []string{\n\t\t\"--config\", confPath,\n\t\t\"--verb\", \"2\",\n\t}\n\n\tif runtime.GOOS == \"windows\" {\n\t\tp.intf, err = utils.AcquireTap()\n\t\tif err != nil {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\n\t\tif p.intf != nil {\n\t\t\targs = append(args, \"--dev-node\", p.intf.Name)\n\t\t}\n\t}\n\n\tblockPath, e := p.writeBlock()\n\tif e != nil {\n\t\terr = e\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, blockPath)\n\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\targs = append(args, \"--script-security\", \"1\")\n\t\tbreak\n\tcase \"darwin\":\n\t\tupPath, e := p.writeUp()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, upPath)\n\n\t\tdownPath, e := p.writeDown()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, downPath)\n\n\t\targs = append(args, \"--script-security\", \"2\",\n\t\t\t\"--up\", upPath,\n\t\t\t\"--down\", downPath,\n\t\t\t\"--route-pre-down\", blockPath,\n\t\t\t\"--tls-verify\", blockPath,\n\t\t\t\"--ipchange\", blockPath,\n\t\t\t\"--route-up\", blockPath,\n\t\t)\n\t\tbreak\n\tcase \"linux\":\n\t\tupPath, e := p.writeUp()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, upPath)\n\n\t\tdownPath, e := p.writeDown()\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t\tp.remPaths = append(p.remPaths, downPath)\n\n\t\targs = append(args, \"--script-security\", \"2\",\n\t\t\t\"--up\", upPath,\n\t\t\t\"--down\", downPath,\n\t\t\t\"--route-pre-down\", blockPath,\n\t\t\t\"--tls-verify\", blockPath,\n\t\t\t\"--ipchange\", blockPath,\n\t\t\t\"--route-up\", blockPath,\n\t\t)\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\n\tif authPath != \"\" {\n\t\targs = append(args, \"--auth-user-pass\", authPath)\n\t}\n\n\tcmd := command.Command(getOpenvpnPath(), args...)\n\tcmd.Dir = getOpenvpnDir()\n\tp.cmd = cmd\n\n\tstdout, err := cmd.StdoutPipe()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get stdout\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tstderr, err := cmd.StderrPipe()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to get stderr\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\toutput := make(chan string, 100)\n\toutputWait := sync.WaitGroup{}\n\toutputWait.Add(1)\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer func() {\n\t\t\tstdout.Close()\n\t\t\toutput <- \"\"\n\t\t}()\n\n\t\tout := bufio.NewReader(stdout)\n\t\tfor {\n\t\t\tline, _, err := out.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"file already closed\") &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"bad file descriptor\") {\n\n\t\t\t\t\terr = &errortypes.ReadError{\n\t\t\t\t\t\terrors.Wrap(err, \"profile: Failed to read stdout\"),\n\t\t\t\t\t}\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Stdout error\")\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlineStr := string(line)\n\t\t\tif lineStr != \"\" {\n\t\t\t\toutput <- lineStr\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer stderr.Close()\n\n\t\tout := bufio.NewReader(stderr)\n\t\tfor {\n\t\t\tline, _, err := out.ReadLine()\n\t\t\tif err != nil {\n\t\t\t\tif err != io.EOF &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"file already closed\") &&\n\t\t\t\t\t!strings.Contains(err.Error(), \"bad file descriptor\") {\n\n\t\t\t\t\terr = &errortypes.ReadError{\n\t\t\t\t\t\terrors.Wrap(err, \"profile: Failed to read stderr\"),\n\t\t\t\t\t}\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"error\": err,\n\t\t\t\t\t}).Error(\"profile: Stderr error\")\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlineStr := string(line)\n\t\t\tif lineStr != \"\" {\n\t\t\t\toutput <- lineStr\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tdefer outputWait.Done()\n\n\t\tfor {\n\t\t\tline := <-output\n\t\t\tif line == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tp.parseLine(line)\n\t\t}\n\t}()\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\terr = &ExecError{\n\t\t\terrors.Wrap(err, \"profile: Failed to start openvpn\"),\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\trunning := true\n\tgo func() {\n\t\tdefer func() {\n\t\t\tpanc := recover()\n\t\t\tif panc != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\"panic\": panc,\n\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\tpanic(panc)\n\t\t\t}\n\t\t}()\n\n\t\tcmd.Wait()\n\t\toutputWait.Wait()\n\t\trunning = false\n\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\terr = utils.RestoreScutilDns()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"error\": err,\n\t\t\t\t}).Error(\"profile: Failed to restore DNS\")\n\t\t\t}\n\t\t}\n\n\t\tif !p.stop {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"profile_id\": p.Id,\n\t\t\t}).Error(\"profile: Unexpected profile exit\")\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t}()\n\n\tif timeout {\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(connTimeout)\n\t\t\tif p.Status != \"connected\" && running {\n\t\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\t\tcmd.Process.Kill()\n\t\t\t\t} else {\n\t\t\t\t\terr = p.cmd.Process.Signal(os.Interrupt)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\terr = &ExecError{\n\t\t\t\t\t\t\terrors.Wrap(err,\n\t\t\t\t\t\t\t\t\"profile: Failed to interrupt openvpn\"),\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tdone := false\n\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\tpanc := recover()\n\t\t\t\t\t\t\tif panc != nil {\n\t\t\t\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\t\t\t\tpanic(panc)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}()\n\n\t\t\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\t\t\tif done {\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp.cmd.Process.Kill()\n\t\t\t\t\t}()\n\n\t\t\t\t\tp.cmd.Process.Wait()\n\t\t\t\t\tdone = true\n\t\t\t\t}\n\n\t\t\t\tevt := event.Event{\n\t\t\t\t\tType: \"timeout_error\",\n\t\t\t\t\tData: p,\n\t\t\t\t}\n\t\t\t\tevt.Init()\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) reqWg(remote string) (wgData *WgData, err error) {\n\tif p.ServerBoxPublicKey == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Server box public key not set\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar serverPubKey [32]byte\n\tserverPubKeySlic, err := base64.StdEncoding.DecodeString(\n\t\tp.ServerBoxPublicKey)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to decode server box key\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\ttokn := token.Get(p.Id, p.ServerPublicKey, p.ServerBoxPublicKey)\n\tp.token = tokn\n\n\tauthToken := \"\"\n\tif tokn != nil {\n\t\terr = tokn.Update()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tauthToken = tokn.Token\n\t} else {\n\t\tauthToken, err = utils.RandStrComplex(16)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\ttokenNonce, err := utils.RandStr(16)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tplatform := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tplatform = \"linux\"\n\t\tbreak\n\tcase \"windows\":\n\t\tplatform = \"win\"\n\t\tbreak\n\tcase \"darwin\":\n\t\tplatform = \"mac\"\n\t\tbreak\n\tdefault:\n\t\tplatform = \"unknown\"\n\t\tbreak\n\t}\n\n\twgBox := &WgKeyBox{\n\t\tDeviceId:    p.DeviceId,\n\t\tDeviceName:  p.DeviceName,\n\t\tPlatform:    platform,\n\t\tMacAddr:     p.MacAddr,\n\t\tMacAddrs:    p.MacAddrs,\n\t\tToken:       authToken,\n\t\tNonce:       tokenNonce,\n\t\tPassword:    p.Password,\n\t\tTimestamp:   time.Now().Unix(),\n\t\tWgPublicKey: p.PublicKeyWg,\n\t}\n\n\twgBoxData, err := json.Marshal(wgBox)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to marshal wg key box\"),\n\t\t}\n\t\treturn\n\t}\n\n\tsenderPubKey, senderPrivKey, err := box.GenerateKey(rand.Reader)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl key\"),\n\t\t}\n\t\treturn\n\t}\n\tsenderPubKey64 := base64.StdEncoding.EncodeToString(senderPubKey[:])\n\n\tvar nonce [24]byte\n\tnonceSl := make([]byte, 24)\n\t_, err = rand.Read(nonceSl)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(nonce[:], nonceSl)\n\n\tencrypted := box.Seal([]byte{}, wgBoxData,\n\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\tnonce64 := base64.StdEncoding.EncodeToString(nonceSl)\n\tciphertext64 := base64.StdEncoding.EncodeToString(encrypted)\n\n\twgReq := &WgKeyReq{\n\t\tData:      ciphertext64,\n\t\tNonce:     nonce64,\n\t\tPublicKey: senderPubKey64,\n\t}\n\n\tuserPrivKeyBlock, _ := pem.Decode([]byte(p.PrivateKey))\n\tif userPrivKeyBlock == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decode private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tuserPrivKey, err := x509.ParsePKCS1PrivateKey(userPrivKeyBlock.Bytes)\n\tif err != nil {\n\t\tuserPrivKeyInf, e := x509.ParsePKCS8PrivateKey(\n\t\t\tuserPrivKeyBlock.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse private key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tuserPrivKey = userPrivKeyInf.(*rsa.PrivateKey)\n\t}\n\n\treqHash := sha512.Sum512([]byte(strings.Join([]string{\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t}, \"&\")))\n\n\trsaSig, err := rsa.SignPSS(\n\t\trand.Reader,\n\t\tuserPrivKey,\n\t\tcrypto.SHA512,\n\t\treqHash[:],\n\t\t&rsa.PSSOptions{\n\t\t\tSaltLength: 0,\n\t\t\tHash:       crypto.SHA512,\n\t\t},\n\t)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to rsa sign data\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgReq.Signature = base64.StdEncoding.EncodeToString(rsaSig)\n\n\twgReqData, err := json.Marshal(wgReq)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treqPath := fmt.Sprintf(\n\t\t\"/key/wg/%s/%s/%s\",\n\t\tp.OrgId, p.UserId, p.ServerId,\n\t)\n\n\tif strings.Contains(remote, \":\") {\n\t\tremote = \"[\" + remote + \"]\"\n\t}\n\n\tu := &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   remote,\n\t\tPath:   reqPath,\n\t}\n\n\tconx, cancel := context.WithCancel(context.Background())\n\n\treq, err := http.NewRequestWithContext(\n\t\tconx,\n\t\t\"POST\",\n\t\tu.String(),\n\t\tbytes.NewBuffer(wgReqData),\n\t)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\ttimestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\tauthNonce, err := utils.RandStr(32)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tauthStr := strings.Join([]string{\n\t\tp.SyncToken,\n\t\ttimestamp,\n\t\tauthNonce,\n\t\t\"POST\",\n\t\treqPath,\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t\twgReq.Signature,\n\t}, \"&\")\n\n\thashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\thashFunc.Write([]byte(authStr))\n\trawSignature := hashFunc.Sum(nil)\n\tsig := base64.StdEncoding.EncodeToString(rawSignature)\n\n\treq.Header.Set(\"Auth-Token\", p.SyncToken)\n\treq.Header.Set(\"Auth-Timestamp\", timestamp)\n\treq.Header.Set(\"Auth-Nonce\", authNonce)\n\treq.Header.Set(\"Auth-Signature\", sig)\n\n\tp.wgReqCancel = cancel\n\tres, err := clientConnInsecure.Do(req)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\tp.wgReqCancel = nil\n\n\tif res.StatusCode != 200 {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrapf(err, \"profile: Bad status %n code from server\",\n\t\t\t\tres.StatusCode),\n\t\t}\n\t\treturn\n\t}\n\n\twgResp := &WgKeyResp{}\n\terr = json.NewDecoder(res.Body).Decode(&wgResp)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response body\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespHashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\trespHashFunc.Write([]byte(wgResp.Data + \"&\" + wgResp.Nonce))\n\trespRawSignature := respHashFunc.Sum(nil)\n\trespSig := base64.StdEncoding.EncodeToString(respRawSignature)\n\n\tif subtle.ConstantTimeCompare(\n\t\t[]byte(respSig), []byte(wgResp.Signature)) != 1 {\n\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Response signature invalid\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespCiphertext, err := base64.StdEncoding.DecodeString(wgResp.Data)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response data\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar respNonce [24]byte\n\trespNonceSl, err := base64.StdEncoding.DecodeString(wgResp.Nonce)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(respNonce[:], respNonceSl)\n\n\trespPlaintext, ok := box.Open([]byte{}, respCiphertext,\n\t\t&respNonce, &serverPubKey, senderPrivKey)\n\n\tif !ok {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decrypt response\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgData = &WgData{}\n\terr = json.Unmarshal(respPlaintext, wgData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse response\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) pingWg(remote string) (wgData *WgPingData, retry bool,\n\terr error) {\n\n\tif p.ServerBoxPublicKey == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Server box public key not set\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar serverPubKey [32]byte\n\tserverPubKeySlic, err := base64.StdEncoding.DecodeString(\n\t\tp.ServerBoxPublicKey)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to decode server box key\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(serverPubKey[:], serverPubKeySlic)\n\n\tplatform := \"\"\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\tplatform = \"linux\"\n\t\tbreak\n\tcase \"windows\":\n\t\tplatform = \"win\"\n\t\tbreak\n\tcase \"darwin\":\n\t\tplatform = \"mac\"\n\t\tbreak\n\tdefault:\n\t\tplatform = \"unknown\"\n\t\tbreak\n\t}\n\n\twgBox := &WgKeyBox{\n\t\tDeviceId:    p.DeviceId,\n\t\tDeviceName:  p.DeviceName,\n\t\tPlatform:    platform,\n\t\tMacAddr:     p.MacAddr,\n\t\tMacAddrs:    p.MacAddrs,\n\t\tTimestamp:   time.Now().Unix(),\n\t\tWgPublicKey: p.PublicKeyWg,\n\t}\n\n\twgBoxData, err := json.Marshal(wgBox)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to marshal wg key box\"),\n\t\t}\n\t\treturn\n\t}\n\n\tsenderPubKey, senderPrivKey, err := box.GenerateKey(rand.Reader)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl key\"),\n\t\t}\n\t\treturn\n\t}\n\tsenderPubKey64 := base64.StdEncoding.EncodeToString(senderPubKey[:])\n\n\tvar nonce [24]byte\n\tnonceSl := make([]byte, 24)\n\t_, err = rand.Read(nonceSl)\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.Wrap(err, \"profile: Failed to generate nacl nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(nonce[:], nonceSl)\n\n\tencrypted := box.Seal([]byte{}, wgBoxData,\n\t\t&nonce, &serverPubKey, senderPrivKey)\n\n\tnonce64 := base64.StdEncoding.EncodeToString(nonceSl)\n\tciphertext64 := base64.StdEncoding.EncodeToString(encrypted)\n\n\twgReq := &WgKeyReq{\n\t\tData:      ciphertext64,\n\t\tNonce:     nonce64,\n\t\tPublicKey: senderPubKey64,\n\t}\n\n\tuserPrivKeyBlock, _ := pem.Decode([]byte(p.PrivateKey))\n\tif userPrivKeyBlock == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decode private key\"),\n\t\t}\n\t\treturn\n\t}\n\n\tuserPrivKey, err := x509.ParsePKCS1PrivateKey(userPrivKeyBlock.Bytes)\n\tif err != nil {\n\t\tuserPrivKeyInf, e := x509.ParsePKCS8PrivateKey(\n\t\t\tuserPrivKeyBlock.Bytes)\n\t\tif e != nil {\n\t\t\terr = &errortypes.ParseError{\n\t\t\t\terrors.Wrap(e, \"profile: Failed to parse private key\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tuserPrivKey = userPrivKeyInf.(*rsa.PrivateKey)\n\t}\n\n\treqHash := sha512.Sum512([]byte(strings.Join([]string{\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t}, \"&\")))\n\n\trsaSig, err := rsa.SignPSS(\n\t\trand.Reader,\n\t\tuserPrivKey,\n\t\tcrypto.SHA512,\n\t\treqHash[:],\n\t\t&rsa.PSSOptions{\n\t\t\tSaltLength: 0,\n\t\t\tHash:       crypto.SHA512,\n\t\t},\n\t)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to rsa sign data\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgReq.Signature = base64.StdEncoding.EncodeToString(rsaSig)\n\n\twgReqData, err := json.Marshal(wgReq)\n\tif err != nil {\n\t\treturn\n\t}\n\n\treqPath := fmt.Sprintf(\n\t\t\"/key/wg/%s/%s/%s\",\n\t\tp.OrgId, p.UserId, p.ServerId,\n\t)\n\n\tif strings.Contains(remote, \":\") {\n\t\tremote = \"[\" + remote + \"]\"\n\t}\n\n\tu := &url.URL{\n\t\tScheme: \"https\",\n\t\tHost:   remote,\n\t\tPath:   reqPath,\n\t}\n\n\treq, err := http.NewRequest(\n\t\t\"PUT\",\n\t\tu.String(),\n\t\tbytes.NewBuffer(wgReqData),\n\t)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\ttimestamp := strconv.FormatInt(time.Now().Unix(), 10)\n\tauthNonce, err := utils.RandStr(32)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tauthStr := strings.Join([]string{\n\t\tp.SyncToken,\n\t\ttimestamp,\n\t\tauthNonce,\n\t\t\"PUT\",\n\t\treqPath,\n\t\twgReq.Data,\n\t\twgReq.Nonce,\n\t\twgReq.PublicKey,\n\t\twgReq.Signature,\n\t}, \"&\")\n\n\thashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\thashFunc.Write([]byte(authStr))\n\trawSignature := hashFunc.Sum(nil)\n\tsig := base64.StdEncoding.EncodeToString(rawSignature)\n\n\treq.Header.Set(\"Auth-Token\", p.SyncToken)\n\treq.Header.Set(\"Auth-Timestamp\", timestamp)\n\treq.Header.Set(\"Auth-Nonce\", authNonce)\n\treq.Header.Set(\"Auth-Signature\", sig)\n\n\tres, err := clientInsecure.Do(req)\n\tif err != nil {\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrap(err, \"profile: Request put error\"),\n\t\t}\n\t\treturn\n\t}\n\tdefer res.Body.Close()\n\n\tif res.StatusCode != 200 {\n\t\tif res.StatusCode < 400 || res.StatusCode >= 500 {\n\t\t\tretry = true\n\t\t}\n\n\t\terr = &errortypes.RequestError{\n\t\t\terrors.Wrapf(err, \"profile: Bad status %n code from server\",\n\t\t\t\tres.StatusCode),\n\t\t}\n\t\treturn\n\t}\n\n\twgResp := &WgKeyResp{}\n\terr = json.NewDecoder(res.Body).Decode(&wgResp)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response body\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespHashFunc := hmac.New(sha512.New, []byte(p.SyncSecret))\n\trespHashFunc.Write([]byte(wgResp.Data + \"&\" + wgResp.Nonce))\n\trespRawSignature := respHashFunc.Sum(nil)\n\trespSig := base64.StdEncoding.EncodeToString(respRawSignature)\n\n\tif subtle.ConstantTimeCompare(\n\t\t[]byte(respSig), []byte(wgResp.Signature)) != 1 {\n\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Response signature invalid\"),\n\t\t}\n\t\treturn\n\t}\n\n\trespCiphertext, err := base64.StdEncoding.DecodeString(wgResp.Data)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response data\"),\n\t\t}\n\t\treturn\n\t}\n\n\tvar respNonce [24]byte\n\trespNonceSl, err := base64.StdEncoding.DecodeString(wgResp.Nonce)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Failed to parse response nonce\"),\n\t\t}\n\t\treturn\n\t}\n\tcopy(respNonce[:], respNonceSl)\n\n\trespPlaintext, ok := box.Open([]byte{}, respCiphertext,\n\t\t&respNonce, &serverPubKey, senderPrivKey)\n\n\tif !ok {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to decrypt response\"),\n\t\t}\n\t\treturn\n\t}\n\n\twgData = &WgPingData{}\n\terr = json.Unmarshal(respPlaintext, wgData)\n\tif err != nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse response\"),\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgLinux(data *WgConf) (err error) {\n\tutils.ExecOutputLogged(\n\t\t[]string{\n\t\t\t\"Cannot find device\",\n\t\t},\n\t\t\"ip\", \"link\",\n\t\t\"del\", p.Iface,\n\t)\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"link\",\n\t\t\"add\", \"dev\", p.Iface,\n\t\t\"type\", \"wireguard\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"addr\",\n\t\t\"add\", data.Address,\n\t\t\"dev\", p.Iface,\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif data.Address6 != \"\" {\n\t\t_, err = utils.ExecOutputLogged(nil,\n\t\t\t\"ip\", \"-6\", \"addr\",\n\t\t\t\"add\", data.Address6,\n\t\t\t\"dev\", p.Iface,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tallowedIps := []string{}\n\tif data.Routes != nil {\n\t\tfor _, route := range data.Routes {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\tif data.Routes6 != nil {\n\t\tfor _, route := range data.Routes6 {\n\t\t\tallowedIps = append(allowedIps, route.Network)\n\t\t}\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\tp.wgPath,\n\t\t\"set\", p.Iface,\n\t\t\"private-key\", p.wgConfPth,\n\t\t\"peer\", data.PublicKey,\n\t\t\"persistent-keepalive\", \"10\",\n\t\t\"allowed-ips\", strings.Join(allowedIps, \",\"),\n\t\t\"endpoint\", fmt.Sprintf(\"%s:%d\", data.Hostname, data.Port),\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t_, err = utils.ExecOutputLogged(nil,\n\t\t\"ip\", \"link\",\n\t\t\"set\", p.Iface, \"up\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tif data.Routes != nil {\n\t\tp.Routes = data.Routes\n\t\tfor _, route := range data.Routes {\n\t\t\tif route.NetGateway {\n\n\t\t\t} else {\n\t\t\t\tif route.Metric != 0 {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"metric\", strconv.Itoa(route.Metric),\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif data.Routes6 != nil {\n\t\tp.Routes6 = data.Routes6\n\t\tfor _, route := range data.Routes6 {\n\t\t\tif route.NetGateway {\n\n\t\t\t} else {\n\t\t\t\tif route.Metric != 0 {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"-6\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"metric\", strconv.Itoa(route.Metric),\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_, err = utils.ExecOutputLogged(\n\t\t\t\t\t\t[]string{\n\t\t\t\t\t\t\t\"File exists\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"ip\", \"-6\", \"route\",\n\t\t\t\t\t\t\"add\", route.Network,\n\t\t\t\t\t\t\"via\", route.NextHop,\n\t\t\t\t\t\t\"dev\", p.Iface,\n\t\t\t\t\t)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgLinuxQuick() (err error) {\n\tp.wgQuickLock.Lock()\n\tdefer p.wgQuickLock.Unlock()\n\n\tfor i := 0; i < 3; i++ {\n\t\t_, _ = utils.ExecOutput(\n\t\t\tp.wgQuickPath, \"down\", p.Iface,\n\t\t)\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\t_, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\tp.wgQuickPath,\n\t\t\t\"up\", p.Iface,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWgMac() (err error) {\n\tp.wgQuickLock.Lock()\n\tdefer p.wgQuickLock.Unlock()\n\n\toutput := \"\"\n\tfor i := 0; i < 3; i++ {\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"/usr/local/bin/bash\", p.wgQuickPath, \"down\", p.Iface,\n\t\t)\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\toutput, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\t\"/usr/local/bin/bash\",\n\t\t\tp.wgQuickPath,\n\t\t\t\"up\", p.Iface,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\ttunIface := \"\"\n\tfor _, line := range strings.Split(output, \"\\n\") {\n\t\tif strings.Contains(line, \"INFO\") {\n\t\t\tmatch := wgIfaceMacReg.FindStringSubmatch(line)\n\t\t\tif match != nil && len(match) >= 2 {\n\t\t\t\ttunIface = match[1]\n\t\t\t}\n\t\t}\n\t}\n\n\tif tunIface == \"\" {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.New(\"profile: Failed to parse wg interface output\"),\n\t\t}\n\t\treturn\n\t}\n\tp.Tuniface = tunIface\n\n\treturn\n}\n\nfunc (p *Profile) confWgWin() (err error) {\n\tfor i := 0; i < 3; i++ {\n\t\tp.wgQuickLock.Lock()\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\t_, _ = utils.ExecOutput(\n\t\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t\t)\n\t\tp.wgQuickLock.Unlock()\n\n\t\tif i == 0 {\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\n\t\t_, err = utils.ExecOutputLogged(\n\t\t\tnil,\n\t\t\tWgWinPath,\n\t\t\t\"/installtunnelservice\", p.wgConfPth,\n\t\t)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) confWg(data *WgConf) (err error) {\n\tp.ClientAddr = data.Address\n\tp.ServerAddr = data.Hostname\n\tp.GatewayAddr = data.Gateway\n\tp.GatewayAddr6 = data.Gateway6\n\tp.wgServerPublicKey = data.PublicKey\n\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\terr = p.confWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\terr = p.confWgWin()\n\t\tbreak\n\tcase \"linux\":\n\t\terr = p.confWgLinuxQuick()\n\t\tbreak\n\tdefault:\n\t\tpanic(\"profile: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) restart() {\n\trestartLock.Lock()\n\tif p.stop {\n\t\trestartLock.Unlock()\n\t\treturn\n\t}\n\n\tprfl := p.Copy()\n\trestartLock.Unlock()\n\n\terr := p.Stop()\n\tif err != nil {\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Stop error\")\n\t\treturn\n\t}\n\n\tp.Wait()\n\n\tif prfl.Reconnect {\n\t\terr = prfl.Start(false)\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Restart error\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Profile) updateWgHandshake() (err error) {\n\tiface := \"\"\n\tif runtime.GOOS == \"darwin\" {\n\t\tiface = p.Tuniface\n\t} else {\n\t\tiface = p.Iface\n\t}\n\n\toutput, err := utils.ExecOutputLogged(\n\t\t[]string{\n\t\t\t\"No such device\",\n\t\t\t\"access interface\",\n\t\t},\n\t\tp.wgPath, \"show\", iface,\n\t\t\"latest-handshakes\",\n\t)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfor _, line := range strings.Split(output, \"\\n\") {\n\t\tfields := strings.Fields(line)\n\t\tif len(fields) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif fields[0] == p.wgServerPublicKey {\n\t\t\thandshake, e := strconv.Atoi(fields[1])\n\t\t\tif e != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp.wgHandshake = handshake\n\t\t\treturn\n\t\t}\n\t}\n\n\tp.wgHandshake = 0\n\treturn\n}\n\nfunc (p *Profile) watchWg() {\n\tdefer func() {\n\t\tpanc := recover()\n\t\tif panc != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\"panic\": panc,\n\t\t\t}).Error(\"profile: Panic\")\n\t\t\tpanic(panc)\n\t\t}\n\t}()\n\n\tdefer p.clearStatus(p.startTime)\n\n\ttime.Sleep(1 * time.Second)\n\n\tfor i := 0; i < 30; i++ {\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif i%10 == 0 {\n\t\t\tgo p.pingWg(p.GatewayAddr)\n\t\t}\n\n\t\terr := p.updateWgHandshake()\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Check handshake status failed\")\n\t\t\tp.Stop()\n\t\t\treturn\n\t\t}\n\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif p.wgHandshake != 0 {\n\t\t\tp.connected = true\n\t\t\tp.Status = \"connected\"\n\t\t\tp.Timestamp = time.Now().Unix() - 5\n\t\t\tp.update()\n\t\t\tbreak\n\t\t}\n\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n\n\tif p.wgHandshake == 0 {\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tevt := event.Event{\n\t\t\tType: \"handshake_timeout\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tgo p.restart()\n\t\treturn\n\t}\n\n\tfor {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif p.stop {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}\n\n\t\tvar data *WgPingData\n\t\tvar retry bool\n\t\tvar err error\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tdata, retry, err = p.pingWg(p.GatewayAddr)\n\t\t\tif !retry {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ttime.Sleep(1 * time.Millisecond)\n\t\t}\n\t\tif err != nil {\n\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\"error\": err,\n\t\t\t}).Error(\"profile: Keepalive failed\")\n\n\t\t\tgo p.restart()\n\t\t\treturn\n\t\t}\n\n\t\tif p.stop {\n\t\t\treturn\n\t\t}\n\n\t\tif data == nil || !data.Status {\n\t\t\tlogrus.Error(\"profile: Keepalive bad status\")\n\n\t\t\tgo p.restart()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (p *Profile) startWg(timeout bool) (err error) {\n\terr = p.generateWgKey()\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tp.update()\n\n\tremotesSet := set.NewSet()\n\tremotes := []string{}\n\tp.PrivateKey = \"\"\n\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.New(\"profile: Failed to load interfaces\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tmacAddr := \"\"\n\tmacAddrs := []string{}\n\tfor _, iface := range ifaces {\n\t\tif iface.Flags&net.FlagUp == 0 ||\n\t\t\tiface.Flags&net.FlagLoopback != 0 ||\n\t\t\tiface.HardwareAddr == nil ||\n\t\t\tiface.HardwareAddr.String() == \"\" {\n\n\t\t\tcontinue\n\t\t}\n\n\t\tmacAddr = iface.HardwareAddr.String()\n\t\tif p.MacAddr == \"\" {\n\t\t\tp.MacAddr = macAddr\n\t\t}\n\t\tmacAddrs = append(macAddrs, macAddr)\n\t}\n\tp.MacAddrs = macAddrs\n\n\trangeKey := false\n\tfor _, line := range strings.Split(p.Data, \"\\n\") {\n\t\tif !rangeKey {\n\t\t\tif strings.HasPrefix(line, \"setenv UV_ID\") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tp.DeviceId = lineSpl[2]\n\t\t\t} else if strings.HasPrefix(line, \"setenv UV_NAME\") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tp.DeviceName = lineSpl[2]\n\t\t\t} else if strings.HasPrefix(line, \"remote \") {\n\t\t\t\tlineSpl := strings.Split(line, \" \")\n\t\t\t\tif len(lineSpl) < 4 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tremote := lineSpl[1]\n\t\t\t\tif !remotesSet.Contains(remote) {\n\t\t\t\t\tremotesSet.Add(remote)\n\t\t\t\t\tremotes = append(remotes, remote)\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(line, \"<key>\") {\n\t\t\t\trangeKey = true\n\t\t\t}\n\t\t} else {\n\t\t\tif strings.HasPrefix(line, \"</key>\") {\n\t\t\t\trangeKey = false\n\t\t\t} else {\n\t\t\t\tp.PrivateKey += line + \"\\n\"\n\t\t\t}\n\t\t}\n\t}\n\n\tvar data *WgData\n\tfor _, i := range mathrand.Perm(len(remotes)) {\n\t\tremote := remotes[i]\n\n\t\tdata, err = p.reqWg(remote)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tif p.stop {\n\t\t\tp.clearStatus(p.startTime)\n\t\t\treturn\n\t\t}\n\t}\n\tif err != nil {\n\t\tevt := event.Event{\n\t\t\tType: \"connection_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Request wg connection failed\")\n\t\terr = nil\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\tif p.connected && !p.stop {\n\t\t\tgo p.restart()\n\t\t}\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif p.stop {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif data == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(err, \"profile: Request wg returned empty data\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif !data.Allow {\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"reason\": data.Reason,\n\t\t}).Error(\"profile: Failed to authenticate wg\")\n\n\t\tevt := event.Event{\n\t\t\tType: \"auth_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\ttime.Sleep(3 * time.Second)\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tif data.Configuration == nil {\n\t\terr = &errortypes.ParseError{\n\t\t\terrors.Wrap(\n\t\t\t\terr,\n\t\t\t\t\"profile: Request wg returned empty configuration\",\n\t\t\t),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tiface := network.InterfaceAcquire()\n\tif iface == \"\" {\n\t\terr = &errortypes.ReadError{\n\t\t\terrors.New(\"profile: Failed to acquire interface\"),\n\t\t}\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.Iface = iface\n\n\twgConfPth, err := p.writeWgConf(data.Configuration)\n\tif err != nil {\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\tp.remPaths = append(p.remPaths, wgConfPth)\n\tp.wgConfPth = wgConfPth\n\n\terr = p.confWg(data.Configuration)\n\tif err != nil {\n\t\tevt := event.Event{\n\t\t\tType: \"configuration_error\",\n\t\t\tData: p,\n\t\t}\n\t\tevt.Init()\n\n\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t}).Error(\"profile: Failed to configure wg\")\n\t\terr = nil\n\n\t\tp.clearStatus(p.startTime)\n\t\treturn\n\t}\n\n\tgo p.watchWg()\n\n\treturn\n}\n\nfunc (p *Profile) stopWgLinux() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\tutils.ExecOutputLogged(\n\t//\t\t[]string{\n\t//\t\t\t\"Cannot find device\",\n\t//\t\t},\n\t//\t\t\"ip\", \"link\",\n\t//\t\t\"del\", p.Iface,\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWgMac() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\tutils.ExecOutputLogged(\n\t//\t\t[]string{\n\t//\t\t\t\"is not a\",\n\t//\t\t},\n\t//\t\tp.wgQuickPath,\n\t//\t\t\"down\", p.Iface,\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWgWin() (err error) {\n\t//if p.Iface != \"\" {\n\t//\tp.wgQuickLock.Lock()\n\t//\t_, _ = utils.ExecOutput(\n\t//\t\t\"sc.exe\", \"stop\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t//\t)\n\t//\ttime.Sleep(100 * time.Millisecond)\n\t//\t_, _ = utils.ExecOutput(\n\t//\t\t\"sc.exe\", \"delete\", fmt.Sprintf(\"WireGuardTunnel$%s\", p.Iface),\n\t//\t)\n\t//\tp.wgQuickLock.Unlock()\n\t//}\n\n\treturn\n}\n\nfunc (p *Profile) stopWg() (err error) {\n\tswitch runtime.GOOS {\n\tcase \"linux\":\n\t\terr = p.stopWgLinux()\n\t\tbreak\n\tcase \"darwin\":\n\t\terr = p.stopWgMac()\n\t\tbreak\n\tcase \"windows\":\n\t\terr = p.stopWgWin()\n\t\tbreak\n\tdefault:\n\t\tpanic(\"handlers: Not implemented\")\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) stopOvpn() (err error) {\n\tif runtime.GOOS == \"windows\" {\n\t\terr = p.cmd.Process.Kill()\n\t\tif err != nil {\n\t\t\terr = &ExecError{\n\t\t\t\terrors.Wrap(err, \"profile: Failed to stop openvpn\"),\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tp.cmd.Process.Signal(os.Interrupt)\n\t\tdone := false\n\n\t\tgo func() {\n\t\t\tdefer func() {\n\t\t\t\tpanc := recover()\n\t\t\t\tif panc != nil {\n\t\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\t\"stack\": string(debug.Stack()),\n\t\t\t\t\t\t\"panic\": panc,\n\t\t\t\t\t}).Error(\"profile: Panic\")\n\t\t\t\t\tpanic(panc)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t\tif done {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tp.cmd.Process.Kill()\n\t\t}()\n\n\t\tp.cmd.Process.Wait()\n\t\tdone = true\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) Stop() (err error) {\n\tif p.stop || (p.Mode != Wg && (p.cmd == nil || p.cmd.Process == nil)) {\n\t\treturn\n\t}\n\n\tlogrus.WithFields(logrus.Fields{\n\t\t\"profile_id\": p.Id,\n\t}).Info(\"profile: Disconnecting\")\n\n\tp.stop = true\n\tp.Status = \"disconnecting\"\n\tp.update()\n\n\tcancel := p.wgReqCancel\n\tif cancel != nil {\n\t\tcancel()\n\t}\n\n\tdiff := time.Since(p.startTime)\n\tif diff < 8*time.Second {\n\t\tdelay := time.Duration(8-int64(diff.Seconds())) * time.Second\n\t\ttime.Sleep(delay)\n\t}\n\n\tif p.Mode == Wg {\n\t\terr = p.stopWg()\n\t} else {\n\t\terr = p.stopOvpn()\n\t}\n\n\treturn\n}\n\nfunc (p *Profile) Wait() {\n\twaiter := make(chan bool, 1)\n\n\tp.stateLock.Lock()\n\tif !p.state {\n\t\treturn\n\t}\n\tp.waiters = append(p.waiters, waiter)\n\tp.stateLock.Unlock()\n\n\t<-waiter\n\ttime.Sleep(50 * time.Millisecond)\n\n\treturn\n}\n"], "filenames": ["service/profile/profile.go"], "buggy_code_start_loc": [239], "buggy_code_end_loc": [239], "fixing_code_start_loc": [240], "fixing_code_end_loc": [244], "type": "CWE-269", "message": "Pritunl Client v1.2.2550.20 contains a local privilege escalation vulnerability in the pritunl-service component. The attack vector is: malicious openvpn config. A local attacker could leverage the log and log-append along with log injection to create or append to privileged script files and execute code as root/SYSTEM.", "other": {"cve": {"id": "CVE-2020-27519", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-30T14:15:08.163", "lastModified": "2021-05-11T12:37:47.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pritunl Client v1.2.2550.20 contains a local privilege escalation vulnerability in the pritunl-service component. The attack vector is: malicious openvpn config. A local attacker could leverage the log and log-append along with log injection to create or append to privileged script files and execute code as root/SYSTEM."}, {"lang": "es", "value": "Pritunl Client versi\u00f3n v1.2.2550.20, contiene una vulnerabilidad de escalada de privilegios local en el componente pritunl-service.&#xa0;El vector de ataque es: configuraci\u00f3n maliciosa de openvpn.&#xa0;Un atacante local podr\u00eda aprovechar el registro y agregar registros junto con la inyecci\u00f3n de registros para crear o agregar archivos de script privilegiados y ejecutar c\u00f3digo como root y SYSTEM."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pritunl:pritunl-client-electron:1.2.2550.20:*:*:*:*:*:*:*", "matchCriteriaId": "F81D56CD-1862-4F58-9B1B-B5A02A656400"}]}]}], "references": [{"url": "https://github.com/pritunl/pritunl-client-electron/commit/87ceeae9b8ee415541d7d71de10675e699a76e5e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pritunl/pritunl-client-electron/commit/87ceeae9b8ee415541d7d71de10675e699a76e5e#diff-5c6a264bee3576f2a147b8db70332e9a16dd43d073782cf6d32a372abb22b899", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pritunl/pritunl-client-electron/commit/c0aeb159351e5e99d752c27b87133eca299bdfce", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pritunl/pritunl-client-electron/commit/87ceeae9b8ee415541d7d71de10675e699a76e5e"}}