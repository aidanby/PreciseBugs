{"buggy_code": ["package fsutil\n\nimport (\n\t\"archive/zip\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n)\n\n// Mkdir alias of os.MkdirAll()\nfunc Mkdir(dirPath string, perm os.FileMode) error {\n\treturn os.MkdirAll(dirPath, perm)\n}\n\n// MkParentDir quick create parent dir\nfunc MkParentDir(fpath string) error {\n\tdirPath := filepath.Dir(fpath)\n\tif !IsDir(dirPath) {\n\t\treturn os.MkdirAll(dirPath, 0775)\n\t}\n\treturn nil\n}\n\n// DiscardReader anything from the reader\nfunc DiscardReader(src io.Reader) {\n\t_, _ = io.Copy(ioutil.Discard, src)\n}\n\n// MustReadFile read file contents, will panic on error\nfunc MustReadFile(filePath string) []byte {\n\tbs, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn bs\n}\n\n// MustReadReader read contents from io.Reader, will panic on error\nfunc MustReadReader(r io.Reader) []byte {\n\t// TODO go 1.16+ bs, err := io.ReadAll(r)\n\tbs, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bs\n}\n\n// GetContents read contents from path or io.Reader, will panic on error\nfunc GetContents(in interface{}) []byte {\n\tif fPath, ok := in.(string); ok {\n\t\treturn MustReadFile(fPath)\n\t}\n\n\tif r, ok := in.(io.Reader); ok {\n\t\treturn MustReadReader(r)\n\t}\n\n\tpanic(\"invalid type of input\")\n}\n\n// ReadExistFile read file contents if existed, will panic on error\nfunc ReadExistFile(filePath string) []byte {\n\tif IsFile(filePath) {\n\t\tbs, err := ioutil.ReadFile(filePath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn bs\n\t}\n\treturn nil\n}\n\n// ************************************************************\n//\topen/create files\n// ************************************************************\n\n// some flag consts for open file\nconst (\n\tFsCWAFlags = os.O_CREATE | os.O_WRONLY | os.O_APPEND // create, append write-only\n\tFsCWTFlags = os.O_CREATE | os.O_WRONLY | os.O_TRUNC  // create, override write-only\n\tFsCWFlags  = os.O_CREATE | os.O_WRONLY               // create, write-only\n\tFsRFlags   = os.O_RDONLY                             // read-only\n)\n\n// OpenFile like os.OpenFile, but will auto create dir.\nfunc OpenFile(filepath string, flag int, perm os.FileMode) (*os.File, error) {\n\tfileDir := path.Dir(filepath)\n\tif err := os.MkdirAll(fileDir, DefaultDirPerm); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfile, err := os.OpenFile(filepath, flag, perm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\n/* TODO MustOpenFile() */\n\n// QuickOpenFile like os.OpenFile, open for write, if not exists, will create it.\n//\n// Tip: file flag default is FsCWAFlags\nfunc QuickOpenFile(filepath string, fileFlag ...int) (*os.File, error) {\n\tflag := FsCWAFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\treturn OpenFile(filepath, flag, DefaultFilePerm)\n}\n\n// OpenReadFile like os.OpenFile, open file for read contents\nfunc OpenReadFile(filepath string) (*os.File, error) {\n\treturn os.OpenFile(filepath, FsRFlags, OnlyReadFilePerm)\n}\n\n// CreateFile create file if not exists\n//\n// Usage:\n//\n//\tCreateFile(\"path/to/file.txt\", 0664, 0666)\nfunc CreateFile(fpath string, filePerm, dirPerm os.FileMode, fileFlag ...int) (*os.File, error) {\n\tdirPath := path.Dir(fpath)\n\tif !IsDir(dirPath) {\n\t\terr := os.MkdirAll(dirPath, dirPerm)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tflag := FsCWTFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\treturn os.OpenFile(fpath, flag, filePerm)\n}\n\n// MustCreateFile create file, will panic on error\nfunc MustCreateFile(filePath string, filePerm, dirPerm os.FileMode) *os.File {\n\tfile, err := CreateFile(filePath, filePerm, dirPerm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn file\n}\n\n// ************************************************************\n//\twrite, copy files\n// ************************************************************\n\n// PutContents create file and write contents to file at once.\n//\n// data type allow: string, []byte, io.Reader\n//\n// Tip: file flag default is FsCWAFlags\n//\n// Usage:\n//\n//\tfsutil.PutContents(filePath, contents, fsutil.FsCWTFlags)\nfunc PutContents(filePath string, data interface{}, fileFlag ...int) (int, error) {\n\t// create and open file\n\tdstFile, err := QuickOpenFile(filePath, fileFlag...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tdefer dstFile.Close()\n\tswitch typData := data.(type) {\n\tcase []byte:\n\t\treturn dstFile.Write(typData)\n\tcase string:\n\t\treturn dstFile.WriteString(typData)\n\tcase io.Reader: // eg: buffer\n\t\tn, err := io.Copy(dstFile, typData)\n\t\treturn int(n), err\n\tdefault:\n\t\tpanic(\"PutContents: data type only allow: []byte, string, io.Reader\")\n\t}\n}\n\n// WriteFile create file and write contents to file, can set perm for file.\n//\n// data type allow: string, []byte, io.Reader\n//\n// Tip: file flag default is FsCWTFlags\n//\n// Usage:\n//\n//\tfsutil.WriteFile(filePath, contents, 0666, fsutil.FsCWAFlags)\nfunc WriteFile(filePath string, data interface{}, perm os.FileMode, fileFlag ...int) error {\n\tflag := FsCWTFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\tf, err := os.OpenFile(filePath, flag, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch typData := data.(type) {\n\tcase []byte:\n\t\t_, err = f.Write(typData)\n\tcase string:\n\t\t_, err = f.WriteString(typData)\n\tcase io.Reader: // eg: buffer\n\t\t_, err = io.Copy(f, typData)\n\tdefault:\n\t\t_ = f.Close()\n\t\tpanic(\"WriteFile: data type only allow: []byte, string, io.Reader\")\n\t}\n\n\tif err1 := f.Close(); err1 != nil && err == nil {\n\t\terr = err1\n\t}\n\treturn err\n}\n\n// CopyFile copy a file to another file path.\nfunc CopyFile(srcPath, dstPath string) error {\n\tsrcFile, err := os.OpenFile(srcPath, FsRFlags, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer srcFile.Close()\n\n\t// create and open file\n\tdstFile, err := QuickOpenFile(dstPath, FsCWTFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dstFile.Close()\n\n\t_, err = io.Copy(dstFile, srcFile)\n\treturn err\n}\n\n// MustCopyFile copy file to another path.\nfunc MustCopyFile(srcPath, dstPath string) {\n\terr := CopyFile(srcPath, dstPath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// ************************************************************\n//\tremove files\n// ************************************************************\n\n// alias methods\nvar (\n\t// MustRm removes the named file or (empty) directory.\n\tMustRm = MustRemove\n\t// QuietRm removes the named file or (empty) directory.\n\tQuietRm = QuietRemove\n)\n\n// Remove removes the named file or (empty) directory.\nfunc Remove(fPath string) error {\n\treturn os.Remove(fPath)\n}\n\n// MustRemove removes the named file or (empty) directory.\n// NOTICE: will panic on error\nfunc MustRemove(fPath string) {\n\tif err := os.Remove(fPath); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// QuietRemove removes the named file or (empty) directory.\n//\n// NOTICE: will ignore error\nfunc QuietRemove(fPath string) { _ = os.Remove(fPath) }\n\n// RmIfExist removes the named file or (empty) directory on exists.\nfunc RmIfExist(fPath string) error { return DeleteIfExist(fPath) }\n\n// DeleteIfExist removes the named file or (empty) directory on exists.\nfunc DeleteIfExist(fPath string) error {\n\tif PathExists(fPath) {\n\t\treturn os.Remove(fPath)\n\t}\n\treturn nil\n}\n\n// RmFileIfExist removes the named file on exists.\nfunc RmFileIfExist(fPath string) error { return DeleteIfFileExist(fPath) }\n\n// DeleteIfFileExist removes the named file on exists.\nfunc DeleteIfFileExist(fPath string) error {\n\tif IsFile(fPath) {\n\t\treturn os.Remove(fPath)\n\t}\n\treturn nil\n}\n\n// ************************************************************\n//\tother operates\n// ************************************************************\n\n// Unzip a zip archive\n// from https://blog.csdn.net/wangshubo1989/article/details/71743374\nfunc Unzip(archive, targetDir string) (err error) {\n\treader, err := zip.OpenReader(archive)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.MkdirAll(targetDir, DefaultDirPerm); err != nil {\n\t\treturn\n\t}\n\n\tfor _, file := range reader.File {\n\t\tfullPath := filepath.Join(targetDir, file.Name)\n\t\tif file.FileInfo().IsDir() {\n\t\t\terr = os.MkdirAll(fullPath, file.Mode())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfileReader, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttargetFile, err := os.OpenFile(fullPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())\n\t\tif err != nil {\n\t\t\t_ = fileReader.Close()\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.Copy(targetFile, fileReader)\n\n\t\t// close all\n\t\t_ = fileReader.Close()\n\t\ttargetFile.Close()\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn\n}\n"], "fixing_code": ["package fsutil\n\nimport (\n\t\"archive/zip\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Mkdir alias of os.MkdirAll()\nfunc Mkdir(dirPath string, perm os.FileMode) error {\n\treturn os.MkdirAll(dirPath, perm)\n}\n\n// MkParentDir quick create parent dir\nfunc MkParentDir(fpath string) error {\n\tdirPath := filepath.Dir(fpath)\n\tif !IsDir(dirPath) {\n\t\treturn os.MkdirAll(dirPath, 0775)\n\t}\n\treturn nil\n}\n\n// DiscardReader anything from the reader\nfunc DiscardReader(src io.Reader) {\n\t_, _ = io.Copy(ioutil.Discard, src)\n}\n\n// MustReadFile read file contents, will panic on error\nfunc MustReadFile(filePath string) []byte {\n\tbs, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn bs\n}\n\n// MustReadReader read contents from io.Reader, will panic on error\nfunc MustReadReader(r io.Reader) []byte {\n\t// TODO go 1.16+ bs, err := io.ReadAll(r)\n\tbs, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bs\n}\n\n// GetContents read contents from path or io.Reader, will panic on error\nfunc GetContents(in interface{}) []byte {\n\tif fPath, ok := in.(string); ok {\n\t\treturn MustReadFile(fPath)\n\t}\n\n\tif r, ok := in.(io.Reader); ok {\n\t\treturn MustReadReader(r)\n\t}\n\n\tpanic(\"invalid type of input\")\n}\n\n// ReadExistFile read file contents if existed, will panic on error\nfunc ReadExistFile(filePath string) []byte {\n\tif IsFile(filePath) {\n\t\tbs, err := ioutil.ReadFile(filePath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn bs\n\t}\n\treturn nil\n}\n\n// ************************************************************\n//\topen/create files\n// ************************************************************\n\n// some flag consts for open file\nconst (\n\tFsCWAFlags = os.O_CREATE | os.O_WRONLY | os.O_APPEND // create, append write-only\n\tFsCWTFlags = os.O_CREATE | os.O_WRONLY | os.O_TRUNC  // create, override write-only\n\tFsCWFlags  = os.O_CREATE | os.O_WRONLY               // create, write-only\n\tFsRFlags   = os.O_RDONLY                             // read-only\n)\n\n// OpenFile like os.OpenFile, but will auto create dir.\nfunc OpenFile(filepath string, flag int, perm os.FileMode) (*os.File, error) {\n\tfileDir := path.Dir(filepath)\n\tif err := os.MkdirAll(fileDir, DefaultDirPerm); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfile, err := os.OpenFile(filepath, flag, perm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn file, nil\n}\n\n/* TODO MustOpenFile() */\n\n// QuickOpenFile like os.OpenFile, open for write, if not exists, will create it.\n//\n// Tip: file flag default is FsCWAFlags\nfunc QuickOpenFile(filepath string, fileFlag ...int) (*os.File, error) {\n\tflag := FsCWAFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\treturn OpenFile(filepath, flag, DefaultFilePerm)\n}\n\n// OpenReadFile like os.OpenFile, open file for read contents\nfunc OpenReadFile(filepath string) (*os.File, error) {\n\treturn os.OpenFile(filepath, FsRFlags, OnlyReadFilePerm)\n}\n\n// CreateFile create file if not exists\n//\n// Usage:\n//\n//\tCreateFile(\"path/to/file.txt\", 0664, 0666)\nfunc CreateFile(fpath string, filePerm, dirPerm os.FileMode, fileFlag ...int) (*os.File, error) {\n\tdirPath := path.Dir(fpath)\n\tif !IsDir(dirPath) {\n\t\terr := os.MkdirAll(dirPath, dirPerm)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tflag := FsCWTFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\treturn os.OpenFile(fpath, flag, filePerm)\n}\n\n// MustCreateFile create file, will panic on error\nfunc MustCreateFile(filePath string, filePerm, dirPerm os.FileMode) *os.File {\n\tfile, err := CreateFile(filePath, filePerm, dirPerm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn file\n}\n\n// ************************************************************\n//\twrite, copy files\n// ************************************************************\n\n// PutContents create file and write contents to file at once.\n//\n// data type allow: string, []byte, io.Reader\n//\n// Tip: file flag default is FsCWAFlags\n//\n// Usage:\n//\n//\tfsutil.PutContents(filePath, contents, fsutil.FsCWTFlags)\nfunc PutContents(filePath string, data interface{}, fileFlag ...int) (int, error) {\n\t// create and open file\n\tdstFile, err := QuickOpenFile(filePath, fileFlag...)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tdefer dstFile.Close()\n\tswitch typData := data.(type) {\n\tcase []byte:\n\t\treturn dstFile.Write(typData)\n\tcase string:\n\t\treturn dstFile.WriteString(typData)\n\tcase io.Reader: // eg: buffer\n\t\tn, err := io.Copy(dstFile, typData)\n\t\treturn int(n), err\n\tdefault:\n\t\tpanic(\"PutContents: data type only allow: []byte, string, io.Reader\")\n\t}\n}\n\n// WriteFile create file and write contents to file, can set perm for file.\n//\n// data type allow: string, []byte, io.Reader\n//\n// Tip: file flag default is FsCWTFlags\n//\n// Usage:\n//\n//\tfsutil.WriteFile(filePath, contents, 0666, fsutil.FsCWAFlags)\nfunc WriteFile(filePath string, data interface{}, perm os.FileMode, fileFlag ...int) error {\n\tflag := FsCWTFlags\n\tif len(fileFlag) > 0 {\n\t\tflag = fileFlag[0]\n\t}\n\n\tf, err := os.OpenFile(filePath, flag, perm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch typData := data.(type) {\n\tcase []byte:\n\t\t_, err = f.Write(typData)\n\tcase string:\n\t\t_, err = f.WriteString(typData)\n\tcase io.Reader: // eg: buffer\n\t\t_, err = io.Copy(f, typData)\n\tdefault:\n\t\t_ = f.Close()\n\t\tpanic(\"WriteFile: data type only allow: []byte, string, io.Reader\")\n\t}\n\n\tif err1 := f.Close(); err1 != nil && err == nil {\n\t\terr = err1\n\t}\n\treturn err\n}\n\n// CopyFile copy a file to another file path.\nfunc CopyFile(srcPath, dstPath string) error {\n\tsrcFile, err := os.OpenFile(srcPath, FsRFlags, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer srcFile.Close()\n\n\t// create and open file\n\tdstFile, err := QuickOpenFile(dstPath, FsCWTFlags)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dstFile.Close()\n\n\t_, err = io.Copy(dstFile, srcFile)\n\treturn err\n}\n\n// MustCopyFile copy file to another path.\nfunc MustCopyFile(srcPath, dstPath string) {\n\terr := CopyFile(srcPath, dstPath)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// ************************************************************\n//\tremove files\n// ************************************************************\n\n// alias methods\nvar (\n\t// MustRm removes the named file or (empty) directory.\n\tMustRm = MustRemove\n\t// QuietRm removes the named file or (empty) directory.\n\tQuietRm = QuietRemove\n)\n\n// Remove removes the named file or (empty) directory.\nfunc Remove(fPath string) error {\n\treturn os.Remove(fPath)\n}\n\n// MustRemove removes the named file or (empty) directory.\n// NOTICE: will panic on error\nfunc MustRemove(fPath string) {\n\tif err := os.Remove(fPath); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// QuietRemove removes the named file or (empty) directory.\n//\n// NOTICE: will ignore error\nfunc QuietRemove(fPath string) { _ = os.Remove(fPath) }\n\n// RmIfExist removes the named file or (empty) directory on exists.\nfunc RmIfExist(fPath string) error { return DeleteIfExist(fPath) }\n\n// DeleteIfExist removes the named file or (empty) directory on exists.\nfunc DeleteIfExist(fPath string) error {\n\tif PathExists(fPath) {\n\t\treturn os.Remove(fPath)\n\t}\n\treturn nil\n}\n\n// RmFileIfExist removes the named file on exists.\nfunc RmFileIfExist(fPath string) error { return DeleteIfFileExist(fPath) }\n\n// DeleteIfFileExist removes the named file on exists.\nfunc DeleteIfFileExist(fPath string) error {\n\tif IsFile(fPath) {\n\t\treturn os.Remove(fPath)\n\t}\n\treturn nil\n}\n\n// ************************************************************\n//\tother operates\n// ************************************************************\n\n// Unzip a zip archive\n// from https://blog.csdn.net/wangshubo1989/article/details/71743374\nfunc Unzip(archive, targetDir string) (err error) {\n\treader, err := zip.OpenReader(archive)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.MkdirAll(targetDir, DefaultDirPerm); err != nil {\n\t\treturn\n\t}\n\n\tfor _, file := range reader.File {\n\n\t\tif strings.Contains(file.Name, \"..\") {\n\t\t\treturn fmt.Errorf(\"illegal file path in zip: %v\", file.Name)\n\t\t}\n\n\t\tfullPath := filepath.Join(targetDir, file.Name)\n\n\t\tif file.FileInfo().IsDir() {\n\t\t\terr = os.MkdirAll(fullPath, file.Mode())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfileReader, err := file.Open()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttargetFile, err := os.OpenFile(fullPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())\n\t\tif err != nil {\n\t\t\t_ = fileReader.Close()\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.Copy(targetFile, fileReader)\n\n\t\t// close all\n\t\t_ = fileReader.Close()\n\t\ttargetFile.Close()\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn\n}\n"], "filenames": ["fsutil/operate.go"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [320], "fixing_code_start_loc": [5], "fixing_code_end_loc": [329], "type": "CWE-22", "message": "Goutil is a collection of miscellaneous functionality for the go language. In versions prior to 0.6.0 when users use fsutil.Unzip to unzip zip files from a malicious attacker, they may be vulnerable to path traversal. This vulnerability is known as a ZipSlip. This issue has been fixed in version 0.6.0, users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-27475", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-07T18:15:09.170", "lastModified": "2023-04-27T15:15:12.573", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Goutil is a collection of miscellaneous functionality for the go language. In versions prior to 0.6.0 when users use fsutil.Unzip to unzip zip files from a malicious attacker, they may be vulnerable to path traversal. This vulnerability is known as a ZipSlip. This issue has been fixed in version 0.6.0, users are advised to upgrade. There are no known workarounds for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:goutil_project:goutil:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.6.0", "matchCriteriaId": "1CC7D2F2-6B6B-43DC-9044-B5C85025519B"}]}]}], "references": [{"url": "https://github.com/gookit/goutil/commit/d7b94fede71f018f129f7d21feb58c895d28dadc", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/gookit/goutil/security/advisories/GHSA-fx2v-qfhr-4chv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230427-0003/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/gookit/goutil/commit/d7b94fede71f018f129f7d21feb58c895d28dadc"}}