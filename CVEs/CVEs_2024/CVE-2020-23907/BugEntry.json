{"buggy_code": ["/**\n* @file src/bin2llvmir/optimizations/decoder/ir_modifications.cpp\n* @brief Decode input binary into LLVM IR.\n* @copyright (c) 2017 Avast Software, licensed under the MIT license\n*/\n\n#include \"retdec/bin2llvmir/optimizations/decoder/decoder.h\"\n\nusing namespace retdec::utils;\nusing namespace llvm;\n\nnamespace retdec {\nnamespace bin2llvmir {\n\nllvm::CallInst* Decoder::transformToCall(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Function* callee)\n{\n\tauto* c = CallInst::Create(callee);\n\tc->insertAfter(pseudo);\n\n\tif (auto* retObj = getCallReturnObject())\n\t{\n\t\tauto* cc = cast<Instruction>(\n\t\t\t\tIrModifier::convertValueToTypeAfter(c, retObj->getValueType(), c));\n\t\tauto* s = new StoreInst(cc, retObj);\n\t\ts->insertAfter(cc);\n\t}\n\n\treturn c;\n}\n\nllvm::CallInst* Decoder::transformToCondCall(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* cond,\n\t\tllvm::Function* callee,\n\t\tllvm::BasicBlock* falseBb)\n{\n\tauto* oldBb = pseudo->getParent();\n\tauto* newBb = oldBb->splitBasicBlock(pseudo);\n\t// We do NOT want to name or give address to this block.\n\n\tauto* oldTerm = oldBb->getTerminator();\n\tBranchInst::Create(newBb, falseBb, cond, oldTerm);\n\toldTerm->eraseFromParent();\n\n\tauto* newTerm = newBb->getTerminator();\n\tBranchInst::Create(falseBb, newTerm);\n\tnewTerm->eraseFromParent();\n\n\tauto* c = CallInst::Create(callee);\n\tc->insertAfter(pseudo);\n\n\treturn c;\n}\n\nllvm::ReturnInst* Decoder::transformToReturn(llvm::CallInst* pseudo)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* r = ReturnInst::Create(\n\t\t\tpseudo->getModule()->getContext(),\n\t\t\tUndefValue::get(pseudo->getFunction()->getReturnType()),\n\t\t\tterm);\n\tterm->eraseFromParent();\n\n\treturn r;\n}\n\nllvm::BranchInst* Decoder::transformToBranch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::BasicBlock* branchee)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* br = BranchInst::Create(branchee, term);\n\tterm->eraseFromParent();\n\n\treturn br;\n}\n\nllvm::BranchInst* Decoder::transformToCondBranch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* cond,\n\t\tllvm::BasicBlock* trueBb,\n\t\tllvm::BasicBlock* falseBb)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* br = BranchInst::Create(trueBb, falseBb, cond, term);\n\tterm->eraseFromParent();\n\n\treturn br;\n}\n\nllvm::SwitchInst* Decoder::transformToSwitch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* val,\n\t\tllvm::BasicBlock* defaultBb,\n\t\tconst std::vector<llvm::BasicBlock*>& cases)\n{\n\tunsigned numCases = 0;\n\tfor (auto* c : cases)\n\t{\n\t\tif (c != defaultBb)\n\t\t{\n\t\t\t++numCases;\n\t\t}\n\t}\n\n\t// If we do not do this, this can happen:\n\t// \"Instruction does not dominate all uses\"\n\tauto* insn = dyn_cast<Instruction>(val);\n\tif (insn && insn->getType())\n\t{\n\t\tauto* gv = new GlobalVariable(\n\t\t\t\t*insn->getModule(),\n\t\t\t\tinsn->getType(),\n\t\t\t\tfalse,\n\t\t\t\tGlobalValue::ExternalLinkage,\n\t\t\t\tnullptr);\n\t\tauto* s = new StoreInst(insn, gv);\n\t\ts->insertAfter(insn);\n\n\t\tval = new LoadInst(gv, \"\", pseudo);\n\t}\n\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* intType = cast<IntegerType>(val->getType());\n\tauto* sw = SwitchInst::Create(val, defaultBb, numCases, term);\n\tunsigned cntr = 0;\n\tfor (auto& c : cases)\n\t{\n\t\tif (c != defaultBb)\n\t\t{\n\t\t\tsw->addCase(ConstantInt::get(intType, cntr), c);\n\t\t}\n\t\t++cntr;\n\t}\n\tterm->eraseFromParent();\n\n\treturn sw;\n}\n\n/**\n * TODO: We should get registers based on the ABI the function is using,\n * not the same register for all calls on an architecture.\n */\nllvm::GlobalVariable* Decoder::getCallReturnObject()\n{\n\tif (_config->getConfig().architecture.isX86_32())\n\t{\n\t\treturn _abi->getRegister(X86_REG_EAX);\n\t}\n\telse if (_config->getConfig().architecture.isX86_64())\n\t{\n\t\treturn _abi->getRegister(X86_REG_RAX);\n\t}\n\telse if (_config->getConfig().architecture.isMipsOrPic32())\n\t{\n\t\treturn _abi->getRegister(MIPS_REG_V0);\n\t}\n\telse if (_config->getConfig().architecture.isPpc())\n\t{\n\t\treturn _abi->getRegister(PPC_REG_R3);\n\t}\n\telse if (_config->getConfig().architecture.isArm32OrThumb())\n\t{\n\t\treturn _abi->getRegister(ARM_REG_R0);\n\t}\n\telse if (_config->getConfig().architecture.isArm64())\n\t{\n\t\treturn _config->getLlvmRegister(\"r0\");\n\t}\n\n\tassert(false);\n\treturn nullptr;\n}\n\n/**\n * Primary: try to create function for \\p addr target and fill \\p tFnc with\n * the result. If successful, \\p tBb is also filled.\n * Secondary: if function not created, try to create BB for \\p addr target and\n * fill \\p tBb with the result.\n */\nvoid Decoder::getOrCreateCallTarget(\n\t\tutils::Address addr,\n\t\tllvm::Function*& tFnc,\n\t\tllvm::BasicBlock*& tBb)\n{\n\ttBb = nullptr;\n\ttFnc = nullptr;\n\n\tif (auto* f = getFunctionAtAddress(addr))\n\t{\n\t\ttFnc = f;\n\t\ttBb = tFnc->empty() ? nullptr : &tFnc->front();\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getFunctionAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (auto* f = splitFunctionOn(addr))\n\t{\n\t\ttFnc = f;\n\t\ttBb = tFnc->empty() ? nullptr : &tFnc->front();\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: splitFunctionOn() @ \" << addr << std::endl;\n\t}\n\telse if (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\ttBb = bb;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getBasicBlockAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (getBasicBlockContainingAddress(addr))\n\t{\n\t\t// Nothing - we are not splitting BBs here.\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getBasicBlockContainingAddress() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n\telse if (getFunctionContainingAddress(addr))\n\t{\n\t\tauto* bb = getBasicBlockBeforeAddress(addr);\n\t\tassert(bb);\n\t\ttBb = createBasicBlock(addr, bb->getParent(), bb);\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getFunctionContainingAddress() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n\telse\n\t{\n\t\ttFnc = createFunction(addr);\n\t\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : nullptr;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: createFunction() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n}\n\n/**\n *\n */\nvoid Decoder::getOrCreateBranchTarget(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock*& tBb,\n\t\tllvm::Function*& tFnc,\n\t\tllvm::Instruction* from)\n{\n\ttBb = nullptr;\n\ttFnc = nullptr;\n\n\tauto* fromFnc = from->getFunction();\n\n\tif (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\ttBb = bb;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getBasicBlockAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (getBasicBlockContainingAddress(addr))\n\t{\n\t\tauto ai = AsmInstruction(_module, addr);\n\t\tif (ai.isInvalid())\n\t\t{\n\t\t\t// Target in existing block, but not at existing instruction.\n\t\t\t// Something is wrong, nothing we can do.\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: invalid ASM @ \" << addr << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (ai.getFunction() == fromFnc)\n\t\t{\n\t\t\ttBb = ai.makeStart();\n\t\t\taddBasicBlock(addr, tBb);\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: addBasicBlock @ \" << addr << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Target at existing instruction, but in different function.\n\t\t\t// Do not split existing block in other functions here.\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: ASM in diff fnc @ \" << addr << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t// Function without BBs (e.g. import declarations).\n\telse if (auto* targetFnc = getFunctionAtAddress(addr))\n\t{\n\t\ttFnc = targetFnc;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getFunctionAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (auto* bb = getBasicBlockBeforeAddress(addr))\n\t{\n\t\ttBb = createBasicBlock(addr, bb->getParent(), bb);\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getBasicBlockBeforeAddress() @ \" << addr << std::endl;\n\t}\n\telse\n\t{\n\t\ttFnc = createFunction(addr);\n\t\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : nullptr;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: default @ \" << addr << std::endl;\n\t}\n\n\tif (tBb && tBb->getPrevNode() == nullptr)\n\t{\n\t\ttFnc = tBb->getParent();\n\t}\n\n\tif (tBb && tBb->getParent() == fromFnc)\n\t{\n\t\treturn;\n\t}\n\tif (tFnc)\n\t{\n\t\treturn;\n\t}\n\n\tLOG << \"\\t\\t\\t\\t\" << \"B: splitFunctionOn @ \" << addr << std::endl;\n\ttFnc = splitFunctionOn(addr);\n\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : tBb;\n}\n\n/**\n * \\return \\c True if it is allowed to split function on basic block \\p bb.\n */\nbool Decoder::canSplitFunctionOn(llvm::BasicBlock* bb)\n{\n\tfor (auto* u : bb->users())\n\t{\n\t\t// All users must be unconditional branch instructions.\n\t\t//\n\t\tauto* br = dyn_cast<BranchInst>(u);\n\t\tif (br == nullptr || br->isConditional())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\\t\" << \"!CAN : user not uncond for \"\n\t\t\t\t\t<< llvmObjToString(u)\n\t\t\t\t\t<< \", user = \" << llvmObjToString(br) << std::endl;\n\t\t\treturn false;\n\t\t}\n\n\t\t// Branch can not come from istruction right before basic block.\n\t\t// This expects that such branches were created\n\t\t// TODO: if\n\t\t//\n\t\tAsmInstruction brAsm(br);\n\t\tAsmInstruction bbAsm(bb);\n\t\tif (brAsm.getEndAddress() == bbAsm.getAddress())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\\t\" << \"branch from ASM insn right before: \"\n\t\t\t\t\t<< brAsm.getAddress() << \" -> \" << bbAsm.getAddress()\n\t\t\t\t\t<< std::endl;\n\t\t\treturn false;\n\t\t}\n\n\t\t// BB must be true branch in all users.\n\t\t//\n//\t\tif (br->getSuccessor(0) != bb)\n//\t\t{\n//\t\t\treturn false;\n//\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * \\return \\c True if it is allowed to split function on basic block \\p bb.\n *\n * TODO:\n * The problem here is, that function may became unsplittable after it was\n * split. What then? Merge them back together and transform calls to JUMP_OUTs?\n * Or defer splits/calls/etc only after basic decoding of all functions is done?\n * E.g.\n * fnc1():\n *     ...\n *     b lab_in_2\n *     ...\n *\n * fnc2(): (nothing decoded yet)\n *     ...\n *     // should not be split here, but it can, because flow from fnc2()\n *     // start does not exist yet.\n *     lab_in_2:\n *     ...\n *     fnc2 end\n */\nbool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\n//\t\t\tAddress bAddr = getBasicBlockAddress(&b);\n\t\t\tAddress bAddr;\n\t\t\t// TODO: shitty\n\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\n//\t\t\t\tAddress pAddr = getBasicBlockAddress(p);\n\t\t\t\tAddress pAddr;\n\t\t\t\t// TODO: shitty\n\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * This can create new BB at \\p addr even if it then cannot split function\n * on this new BB. Is this desirable behavior?\n */\nllvm::Function* Decoder::splitFunctionOn(utils::Address addr)\n{\n\tif (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: splitFunctionOn @ \" << addr << std::endl;\n\t\treturn bb->getPrevNode()\n\t\t\t\t? splitFunctionOn(addr, bb)\n\t\t\t\t: bb->getParent();\n\t}\n\t// There is an instruction at address, but not BB -> do not split\n\t// existing blocks to create functions.\n\t//\n\telse if (auto ai = AsmInstruction(_module, addr))\n\t{\n\t\tif (ai.isInvalid())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"S: invalid ASM @ \" << addr << std::endl;\n\t\t\treturn nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"S: ASM @ \" << addr << std::endl;\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\telse if (getFunctionContainingAddress(addr))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: getFunctionContainingAddress() @ \" << addr << std::endl;\n\t\tauto* before = getBasicBlockBeforeAddress(addr);\n\t\tassert(before);\n\t\tauto* newBb = createBasicBlock(addr, before->getParent(), before);\n\t\treturn splitFunctionOn(addr, newBb);\n\t}\n\telse\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: createFunction() @ \" << addr << std::endl;\n\t\treturn createFunction(addr);\n\t}\n}\n\nllvm::Function* Decoder::splitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitOnBb)\n{\n\tLOG << \"\\t\\t\\t\\t\" << \"S: splitFunctionOn @ \" << addr << \" on \"\n\t\t\t<< splitOnBb->getName().str() << std::endl;\n\n\tif (splitOnBb->getPrevNode() == nullptr)\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: BB first @ \" << addr << std::endl;\n\t\treturn splitOnBb->getParent();\n\t}\n\tstd::set<BasicBlock*> newFncStarts;\n\tif (!canSplitFunctionOn(addr, splitOnBb, newFncStarts))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: !canSplitFunctionOn() @ \" << addr << std::endl;\n\t\treturn nullptr;\n\t}\n\n\tllvm::Function* ret = nullptr;\n\tstd::set<Function*> newFncs;\n\tfor (auto* splitBb : newFncStarts)\n\t{\n\t\tAddress splitAddr = getBasicBlockAddress(splitBb);\n\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: splitting @ \" << splitAddr << \" on \"\n\t\t\t\t<< splitBb->getName().str() << std::endl;\n\n\t\tstd::string name = _names->getPreferredNameForAddress(splitAddr);\n\t\tif (name.empty())\n\t\t{\n\t\t\tname = names::generateFunctionName(splitAddr, _config->getConfig().isIda());\n\t\t}\n\n\t\tFunction* oldFnc = splitBb->getParent();\n\t\tFunction* newFnc = Function::Create(\n\t\t\t\tFunctionType::get(oldFnc->getReturnType(), false),\n\t\t\t\toldFnc->getLinkage(),\n\t\t\t\tname);\n\t\toldFnc->getParent()->getFunctionList().insertAfter(\n\t\t\t\toldFnc->getIterator(),\n\t\t\t\tnewFnc);\n\n\t\taddFunction(splitAddr, newFnc);\n\n\t\tnewFnc->getBasicBlockList().splice(\n\t\t\t\tnewFnc->begin(),\n\t\t\t\toldFnc->getBasicBlockList(),\n\t\t\t\tsplitBb->getIterator(),\n\t\t\t\toldFnc->getBasicBlockList().end());\n\n\t\tnewFncs.insert(oldFnc);\n\t\tnewFncs.insert(newFnc);\n\t\tif (splitOnBb == splitBb)\n\t\t{\n\t\t\tret = newFnc;\n\t\t}\n\t}\n\tassert(ret);\n\n\tfor (Function* f : newFncs)\n\tfor (BasicBlock& b : *f)\n\t{\n\t\tauto* br = dyn_cast<BranchInst>(b.getTerminator());\n\t\tif (br\n\t\t\t\t&& (br->getSuccessor(0)->getParent() != br->getFunction()\n\t\t\t\t|| br->getSuccessor(0)->getPrevNode() == nullptr))\n\t\t{\n\t\t\tauto* callee = br->getSuccessor(0)->getParent();\n\t\t\tauto* c = CallInst::Create(callee, \"\", br);\n\t\t\tif (auto* retObj = getCallReturnObject())\n\t\t\t{\n\t\t\t\tauto* cc = cast<Instruction>(\n\t\t\t\t\t\tIrModifier::convertValueToTypeAfter(c, retObj->getValueType(), c));\n\t\t\t\tauto* s = new StoreInst(cc, retObj);\n\t\t\t\ts->insertAfter(cc);\n\t\t\t}\n\n\t\t\tReturnInst::Create(\n\t\t\t\t\tbr->getModule()->getContext(),\n\t\t\t\t\tUndefValue::get(br->getFunction()->getReturnType()),\n\t\t\t\t\tbr);\n\t\t\tbr->eraseFromParent();\n\t\t}\n\n\t\t// Test.\n\t\tfor (auto* s : successors(&b))\n\t\t{\n\t\t\tif (b.getParent() != s->getParent())\n\t\t\t{\n\t\t\t\tdumpModuleToFile(_module, _config->getOutputDirectory());\n\t\t\t}\n\t\t\tassert(b.getParent() == s->getParent());\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n} // namespace bin2llvmir\n} // namespace retdec\n"], "fixing_code": ["/**\n* @file src/bin2llvmir/optimizations/decoder/ir_modifications.cpp\n* @brief Decode input binary into LLVM IR.\n* @copyright (c) 2017 Avast Software, licensed under the MIT license\n*/\n\n#include \"retdec/bin2llvmir/optimizations/decoder/decoder.h\"\n\nusing namespace retdec::utils;\nusing namespace llvm;\n\nnamespace retdec {\nnamespace bin2llvmir {\n\nllvm::CallInst* Decoder::transformToCall(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Function* callee)\n{\n\tauto* c = CallInst::Create(callee);\n\tc->insertAfter(pseudo);\n\n\tif (auto* retObj = getCallReturnObject())\n\t{\n\t\tauto* cc = cast<Instruction>(\n\t\t\t\tIrModifier::convertValueToTypeAfter(c, retObj->getValueType(), c));\n\t\tauto* s = new StoreInst(cc, retObj);\n\t\ts->insertAfter(cc);\n\t}\n\n\treturn c;\n}\n\nllvm::CallInst* Decoder::transformToCondCall(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* cond,\n\t\tllvm::Function* callee,\n\t\tllvm::BasicBlock* falseBb)\n{\n\tauto* oldBb = pseudo->getParent();\n\tauto* newBb = oldBb->splitBasicBlock(pseudo);\n\t// We do NOT want to name or give address to this block.\n\n\tauto* oldTerm = oldBb->getTerminator();\n\tBranchInst::Create(newBb, falseBb, cond, oldTerm);\n\toldTerm->eraseFromParent();\n\n\tauto* newTerm = newBb->getTerminator();\n\tBranchInst::Create(falseBb, newTerm);\n\tnewTerm->eraseFromParent();\n\n\tauto* c = CallInst::Create(callee);\n\tc->insertAfter(pseudo);\n\n\treturn c;\n}\n\nllvm::ReturnInst* Decoder::transformToReturn(llvm::CallInst* pseudo)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* r = ReturnInst::Create(\n\t\t\tpseudo->getModule()->getContext(),\n\t\t\tUndefValue::get(pseudo->getFunction()->getReturnType()),\n\t\t\tterm);\n\tterm->eraseFromParent();\n\n\treturn r;\n}\n\nllvm::BranchInst* Decoder::transformToBranch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::BasicBlock* branchee)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* br = BranchInst::Create(branchee, term);\n\tterm->eraseFromParent();\n\n\treturn br;\n}\n\nllvm::BranchInst* Decoder::transformToCondBranch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* cond,\n\t\tllvm::BasicBlock* trueBb,\n\t\tllvm::BasicBlock* falseBb)\n{\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* br = BranchInst::Create(trueBb, falseBb, cond, term);\n\tterm->eraseFromParent();\n\n\treturn br;\n}\n\nllvm::SwitchInst* Decoder::transformToSwitch(\n\t\tllvm::CallInst* pseudo,\n\t\tllvm::Value* val,\n\t\tllvm::BasicBlock* defaultBb,\n\t\tconst std::vector<llvm::BasicBlock*>& cases)\n{\n\tunsigned numCases = 0;\n\tfor (auto* c : cases)\n\t{\n\t\tif (c != defaultBb)\n\t\t{\n\t\t\t++numCases;\n\t\t}\n\t}\n\n\t// If we do not do this, this can happen:\n\t// \"Instruction does not dominate all uses\"\n\tauto* insn = dyn_cast<Instruction>(val);\n\tif (insn && insn->getType())\n\t{\n\t\tauto* gv = new GlobalVariable(\n\t\t\t\t*insn->getModule(),\n\t\t\t\tinsn->getType(),\n\t\t\t\tfalse,\n\t\t\t\tGlobalValue::ExternalLinkage,\n\t\t\t\tnullptr);\n\t\tauto* s = new StoreInst(insn, gv);\n\t\ts->insertAfter(insn);\n\n\t\tval = new LoadInst(gv, \"\", pseudo);\n\t}\n\n\tauto* term = pseudo->getParent()->getTerminator();\n\tassert(pseudo->getNextNode() == term);\n\tauto* intType = cast<IntegerType>(val->getType());\n\tauto* sw = SwitchInst::Create(val, defaultBb, numCases, term);\n\tunsigned cntr = 0;\n\tfor (auto& c : cases)\n\t{\n\t\tif (c != defaultBb)\n\t\t{\n\t\t\tsw->addCase(ConstantInt::get(intType, cntr), c);\n\t\t}\n\t\t++cntr;\n\t}\n\tterm->eraseFromParent();\n\n\treturn sw;\n}\n\n/**\n * TODO: We should get registers based on the ABI the function is using,\n * not the same register for all calls on an architecture.\n */\nllvm::GlobalVariable* Decoder::getCallReturnObject()\n{\n\tif (_config->getConfig().architecture.isX86_32())\n\t{\n\t\treturn _abi->getRegister(X86_REG_EAX);\n\t}\n\telse if (_config->getConfig().architecture.isX86_64())\n\t{\n\t\treturn _abi->getRegister(X86_REG_RAX);\n\t}\n\telse if (_config->getConfig().architecture.isMipsOrPic32())\n\t{\n\t\treturn _abi->getRegister(MIPS_REG_V0);\n\t}\n\telse if (_config->getConfig().architecture.isPpc())\n\t{\n\t\treturn _abi->getRegister(PPC_REG_R3);\n\t}\n\telse if (_config->getConfig().architecture.isArm32OrThumb())\n\t{\n\t\treturn _abi->getRegister(ARM_REG_R0);\n\t}\n\telse if (_config->getConfig().architecture.isArm64())\n\t{\n\t\treturn _config->getLlvmRegister(\"r0\");\n\t}\n\n\tassert(false);\n\treturn nullptr;\n}\n\n/**\n * Primary: try to create function for \\p addr target and fill \\p tFnc with\n * the result. If successful, \\p tBb is also filled.\n * Secondary: if function not created, try to create BB for \\p addr target and\n * fill \\p tBb with the result.\n */\nvoid Decoder::getOrCreateCallTarget(\n\t\tutils::Address addr,\n\t\tllvm::Function*& tFnc,\n\t\tllvm::BasicBlock*& tBb)\n{\n\ttBb = nullptr;\n\ttFnc = nullptr;\n\n\tif (auto* f = getFunctionAtAddress(addr))\n\t{\n\t\ttFnc = f;\n\t\ttBb = tFnc->empty() ? nullptr : &tFnc->front();\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getFunctionAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (auto* f = splitFunctionOn(addr))\n\t{\n\t\ttFnc = f;\n\t\ttBb = tFnc->empty() ? nullptr : &tFnc->front();\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: splitFunctionOn() @ \" << addr << std::endl;\n\t}\n\telse if (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\ttBb = bb;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getBasicBlockAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (getBasicBlockContainingAddress(addr))\n\t{\n\t\t// Nothing - we are not splitting BBs here.\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getBasicBlockContainingAddress() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n\telse if (getFunctionContainingAddress(addr))\n\t{\n\t\tauto* bb = getBasicBlockBeforeAddress(addr);\n\t\tassert(bb);\n\t\ttBb = createBasicBlock(addr, bb->getParent(), bb);\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: getFunctionContainingAddress() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n\telse\n\t{\n\t\ttFnc = createFunction(addr);\n\t\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : nullptr;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"F: createFunction() @ \"\n\t\t\t\t<< addr << std::endl;\n\t}\n}\n\n/**\n *\n */\nvoid Decoder::getOrCreateBranchTarget(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock*& tBb,\n\t\tllvm::Function*& tFnc,\n\t\tllvm::Instruction* from)\n{\n\ttBb = nullptr;\n\ttFnc = nullptr;\n\n\tauto* fromFnc = from->getFunction();\n\n\tif (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\ttBb = bb;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getBasicBlockAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (getBasicBlockContainingAddress(addr))\n\t{\n\t\tauto ai = AsmInstruction(_module, addr);\n\t\tif (ai.isInvalid())\n\t\t{\n\t\t\t// Target in existing block, but not at existing instruction.\n\t\t\t// Something is wrong, nothing we can do.\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: invalid ASM @ \" << addr << std::endl;\n\t\t\treturn;\n\t\t}\n\t\telse if (ai.getFunction() == fromFnc)\n\t\t{\n\t\t\ttBb = ai.makeStart();\n\t\t\taddBasicBlock(addr, tBb);\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: addBasicBlock @ \" << addr << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Target at existing instruction, but in different function.\n\t\t\t// Do not split existing block in other functions here.\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"B: ASM in diff fnc @ \" << addr << std::endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t// Function without BBs (e.g. import declarations).\n\telse if (auto* targetFnc = getFunctionAtAddress(addr))\n\t{\n\t\ttFnc = targetFnc;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getFunctionAtAddress() @ \" << addr << std::endl;\n\t}\n\telse if (auto* bb = getBasicBlockBeforeAddress(addr))\n\t{\n\t\ttBb = createBasicBlock(addr, bb->getParent(), bb);\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: getBasicBlockBeforeAddress() @ \" << addr << std::endl;\n\t}\n\telse\n\t{\n\t\ttFnc = createFunction(addr);\n\t\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : nullptr;\n\t\tLOG << \"\\t\\t\\t\\t\" << \"B: default @ \" << addr << std::endl;\n\t}\n\n\tif (tBb && tBb->getPrevNode() == nullptr)\n\t{\n\t\ttFnc = tBb->getParent();\n\t}\n\n\tif (tBb && tBb->getParent() == fromFnc)\n\t{\n\t\treturn;\n\t}\n\tif (tFnc)\n\t{\n\t\treturn;\n\t}\n\n\tLOG << \"\\t\\t\\t\\t\" << \"B: splitFunctionOn @ \" << addr << std::endl;\n\ttFnc = splitFunctionOn(addr);\n\ttBb = tFnc && !tFnc->empty() ? &tFnc->front() : tBb;\n}\n\n/**\n * \\return \\c True if it is allowed to split function on basic block \\p bb.\n */\nbool Decoder::canSplitFunctionOn(llvm::BasicBlock* bb)\n{\n\tfor (auto* u : bb->users())\n\t{\n\t\t// All users must be unconditional branch instructions.\n\t\t//\n\t\tauto* br = dyn_cast<BranchInst>(u);\n\t\tif (br == nullptr || br->isConditional())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\\t\" << \"!CAN : user not uncond for \"\n\t\t\t\t\t<< llvmObjToString(u)\n\t\t\t\t\t<< \", user = \" << llvmObjToString(br) << std::endl;\n\t\t\treturn false;\n\t\t}\n\n\t\t// Branch can not come from istruction right before basic block.\n\t\t// This expects that such branches were created\n\t\t// TODO: if\n\t\t//\n\t\tAsmInstruction brAsm(br);\n\t\tAsmInstruction bbAsm(bb);\n\t\tif (brAsm.getEndAddress() == bbAsm.getAddress())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\\t\" << \"branch from ASM insn right before: \"\n\t\t\t\t\t<< brAsm.getAddress() << \" -> \" << bbAsm.getAddress()\n\t\t\t\t\t<< std::endl;\n\t\t\treturn false;\n\t\t}\n\n\t\t// BB must be true branch in all users.\n\t\t//\n//\t\tif (br->getSuccessor(0) != bb)\n//\t\t{\n//\t\t\treturn false;\n//\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * \\return \\c True if it is allowed to split function on basic block \\p bb.\n *\n * TODO:\n * The problem here is, that function may became unsplittable after it was\n * split. What then? Merge them back together and transform calls to JUMP_OUTs?\n * Or defer splits/calls/etc only after basic decoding of all functions is done?\n * E.g.\n * fnc1():\n *     ...\n *     b lab_in_2\n *     ...\n *\n * fnc2(): (nothing decoded yet)\n *     ...\n *     // should not be split here, but it can, because flow from fnc2()\n *     // start does not exist yet.\n *     lab_in_2:\n *     ...\n *     fnc2 end\n */\nbool Decoder::canSplitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitBb,\n\t\tstd::set<llvm::BasicBlock*>& newFncStarts)\n{\n\tnewFncStarts.insert(splitBb);\n\n\tauto* f = splitBb->getParent();\n\tauto fAddr = getFunctionAddress(f);\n\n\tauto fSzIt = _fnc2sz.find(f);\n\tif (fSzIt != _fnc2sz.end())\n\t{\n\t\tif (fAddr <= addr && addr < (fAddr+fSzIt->second))\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"!CAN S: addr cond @ \" << addr << std::endl;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstd::set<Address> fncStarts;\n\tfncStarts.insert(fAddr);\n\tfncStarts.insert(addr);\n\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << fAddr << std::endl;\n\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << addr << std::endl;\n\n\tbool changed = true;\n\twhile (changed)\n\t{\n\t\tchanged = false;\n\t\tfor (BasicBlock& b : *f)\n\t\t{\n//\t\t\tAddress bAddr = getBasicBlockAddress(&b);\n\t\t\tAddress bAddr;\n\t\t\t// TODO: shitty\n\t\t\tBasicBlock* bPrev = &b;\n\t\t\twhile (bAddr.isUndefined() && bPrev)\n\t\t\t{\n\t\t\t\tbAddr = getBasicBlockAddress(bPrev);\n\t\t\t\tbPrev = bPrev->getPrevNode();\n\t\t\t}\n\t\t\tif (bAddr.isUndefined())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto up = fncStarts.upper_bound(bAddr);\n\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\treturn false;\n\t\t\t}\t\n\t\t\t--up;\n\t\t\tAddress bFnc = *up;\n\n\t\t\tfor (auto* p : predecessors(&b))\n\t\t\t{\n//\t\t\t\tAddress pAddr = getBasicBlockAddress(p);\n\t\t\t\tAddress pAddr;\n\t\t\t\t// TODO: shitty\n\t\t\t\tBasicBlock* pPrev = p;\n\t\t\t\twhile (pAddr.isUndefined() && pPrev)\n\t\t\t\t{\n\t\t\t\t\tpAddr = getBasicBlockAddress(pPrev);\n\t\t\t\t\tpPrev = pPrev->getPrevNode();\n\t\t\t\t}\n\t\t\t\tif (pAddr.isUndefined())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto up = fncStarts.upper_bound(pAddr);\n\t\t\t\tif (up == fncStarts.begin()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t--up;\n\t\t\t\tAddress pFnc = *up;\n\n\t\t\t\tif (bFnc != pFnc)\n\t\t\t\t{\n\t\t\t\t\tif (!canSplitFunctionOn(&b))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged |= newFncStarts.insert(&b).second;\n\t\t\t\t\tchanged |= fncStarts.insert(bAddr).second;\n\n\t\t\t\t\tLOG << \"\\t\\t\\t\\t\\t\" << \"CAN S: split @ \" << bAddr << std::endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * This can create new BB at \\p addr even if it then cannot split function\n * on this new BB. Is this desirable behavior?\n */\nllvm::Function* Decoder::splitFunctionOn(utils::Address addr)\n{\n\tif (auto* bb = getBasicBlockAtAddress(addr))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: splitFunctionOn @ \" << addr << std::endl;\n\t\treturn bb->getPrevNode()\n\t\t\t\t? splitFunctionOn(addr, bb)\n\t\t\t\t: bb->getParent();\n\t}\n\t// There is an instruction at address, but not BB -> do not split\n\t// existing blocks to create functions.\n\t//\n\telse if (auto ai = AsmInstruction(_module, addr))\n\t{\n\t\tif (ai.isInvalid())\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"S: invalid ASM @ \" << addr << std::endl;\n\t\t\treturn nullptr;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG << \"\\t\\t\\t\\t\" << \"S: ASM @ \" << addr << std::endl;\n\t\t\treturn nullptr;\n\t\t}\n\t}\n\telse if (getFunctionContainingAddress(addr))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: getFunctionContainingAddress() @ \" << addr << std::endl;\n\t\tauto* before = getBasicBlockBeforeAddress(addr);\n\t\tassert(before);\n\t\tauto* newBb = createBasicBlock(addr, before->getParent(), before);\n\t\treturn splitFunctionOn(addr, newBb);\n\t}\n\telse\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: createFunction() @ \" << addr << std::endl;\n\t\treturn createFunction(addr);\n\t}\n}\n\nllvm::Function* Decoder::splitFunctionOn(\n\t\tutils::Address addr,\n\t\tllvm::BasicBlock* splitOnBb)\n{\n\tLOG << \"\\t\\t\\t\\t\" << \"S: splitFunctionOn @ \" << addr << \" on \"\n\t\t\t<< splitOnBb->getName().str() << std::endl;\n\n\tif (splitOnBb->getPrevNode() == nullptr)\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: BB first @ \" << addr << std::endl;\n\t\treturn splitOnBb->getParent();\n\t}\n\tstd::set<BasicBlock*> newFncStarts;\n\tif (!canSplitFunctionOn(addr, splitOnBb, newFncStarts))\n\t{\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: !canSplitFunctionOn() @ \" << addr << std::endl;\n\t\treturn nullptr;\n\t}\n\n\tllvm::Function* ret = nullptr;\n\tstd::set<Function*> newFncs;\n\tfor (auto* splitBb : newFncStarts)\n\t{\n\t\tAddress splitAddr = getBasicBlockAddress(splitBb);\n\n\t\tLOG << \"\\t\\t\\t\\t\" << \"S: splitting @ \" << splitAddr << \" on \"\n\t\t\t\t<< splitBb->getName().str() << std::endl;\n\n\t\tstd::string name = _names->getPreferredNameForAddress(splitAddr);\n\t\tif (name.empty())\n\t\t{\n\t\t\tname = names::generateFunctionName(splitAddr, _config->getConfig().isIda());\n\t\t}\n\n\t\tFunction* oldFnc = splitBb->getParent();\n\t\tFunction* newFnc = Function::Create(\n\t\t\t\tFunctionType::get(oldFnc->getReturnType(), false),\n\t\t\t\toldFnc->getLinkage(),\n\t\t\t\tname);\n\t\toldFnc->getParent()->getFunctionList().insertAfter(\n\t\t\t\toldFnc->getIterator(),\n\t\t\t\tnewFnc);\n\n\t\taddFunction(splitAddr, newFnc);\n\n\t\tnewFnc->getBasicBlockList().splice(\n\t\t\t\tnewFnc->begin(),\n\t\t\t\toldFnc->getBasicBlockList(),\n\t\t\t\tsplitBb->getIterator(),\n\t\t\t\toldFnc->getBasicBlockList().end());\n\n\t\tnewFncs.insert(oldFnc);\n\t\tnewFncs.insert(newFnc);\n\t\tif (splitOnBb == splitBb)\n\t\t{\n\t\t\tret = newFnc;\n\t\t}\n\t}\n\tassert(ret);\n\n\tfor (Function* f : newFncs)\n\tfor (BasicBlock& b : *f)\n\t{\n\t\tauto* br = dyn_cast<BranchInst>(b.getTerminator());\n\t\tif (br\n\t\t\t\t&& (br->getSuccessor(0)->getParent() != br->getFunction()\n\t\t\t\t|| br->getSuccessor(0)->getPrevNode() == nullptr))\n\t\t{\n\t\t\tauto* callee = br->getSuccessor(0)->getParent();\n\t\t\tauto* c = CallInst::Create(callee, \"\", br);\n\t\t\tif (auto* retObj = getCallReturnObject())\n\t\t\t{\n\t\t\t\tauto* cc = cast<Instruction>(\n\t\t\t\t\t\tIrModifier::convertValueToTypeAfter(c, retObj->getValueType(), c));\n\t\t\t\tauto* s = new StoreInst(cc, retObj);\n\t\t\t\ts->insertAfter(cc);\n\t\t\t}\n\n\t\t\tReturnInst::Create(\n\t\t\t\t\tbr->getModule()->getContext(),\n\t\t\t\t\tUndefValue::get(br->getFunction()->getReturnType()),\n\t\t\t\t\tbr);\n\t\t\tbr->eraseFromParent();\n\t\t}\n\n\t\t// Test.\n\t\tfor (auto* s : successors(&b))\n\t\t{\n\t\t\tif (b.getParent() != s->getParent())\n\t\t\t{\n\t\t\t\tdumpModuleToFile(_module, _config->getOutputDirectory());\n\t\t\t}\n\t\t\tassert(b.getParent() == s->getParent());\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n} // namespace bin2llvmir\n} // namespace retdec\n"], "filenames": ["src/bin2llvmir/optimizations/decoder/ir_modifications.cpp"], "buggy_code_start_loc": [425], "buggy_code_end_loc": [444], "fixing_code_start_loc": [426], "fixing_code_end_loc": [451], "type": "CWE-787", "message": "An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution.", "other": {"cve": {"id": "CVE-2020-23907", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-21T18:15:08.173", "lastModified": "2021-04-26T18:12:48.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution."}, {"lang": "es", "value": "Se detect\u00f3 un problema en retdec versi\u00f3n v3.3.&#xa0;En la funci\u00f3n canSplitFunctionOn() del archivo ir_modifications.cpp, se presenta una posible lectura fuera de l\u00edmites debido a un desbordamiento del b\u00fafer de la pila.&#xa0;El impacto es: una Denegaci\u00f3n de Servicio, una Divulgaci\u00f3n de Memoria y una Posible Ejecuci\u00f3n de C\u00f3digo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:avast:retdec:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "11698B96-5CD8-4793-A92B-02DBFD231D7D"}]}]}], "references": [{"url": "https://github.com/avast/retdec/commit/517298bafaaff0a8e3dd60dd055a67c41b545807", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/avast/retdec/issues/637", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/avast/retdec/commit/517298bafaaff0a8e3dd60dd055a67c41b545807"}}