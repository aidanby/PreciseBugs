{"buggy_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include \"precompile.h\"\n\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"hwplib.h\"\n#include \"hwpfile.h\"\n#include \"hiodev.h\"\n#include \"hfont.h\"\n#include \"hstyle.h\"\n#include \"hbox.h\"\n#include \"hpara.h\"\n#include \"htags.h\"\n#include \"hcode.h\"\n#include \"hstream.hxx\"\n\n#include <osl/diagnose.h>\n\nHWPFile *HWPFile::cur_doc = nullptr;\nstatic int ccount = 0;\nstatic int pcount = 0;\nstatic int datecodecount = 0;\n\nHWPFile::HWPFile()\n    : version(HWP_V30)\n    , compressed(false)\n    , encrypted(false)\n    , linenumber(0)\n    , info_block_len(0)\n    , error_code(HWP_NoError)\n    , oledata(nullptr)\n    , m_nCurrentPage(1)\n    , m_nMaxSettedPage(0)\n    , hiodev(nullptr)\n    , currenthyper(0)\n{\n    SetCurrentDoc(this);\n}\n\nHWPFile::~HWPFile()\n{\n    delete oledata;\n    delete hiodev;\n\n    std::list < ColumnInfo* >::iterator it_column = columnlist.begin();\n    for (; it_column != columnlist.end(); ++it_column)\n        delete *it_column;\n\n    std::list < HWPPara* >::iterator it = plist.begin();\n    for (; it != plist.end(); ++it)\n        delete *it;\n\n    std::vector< Table* >::iterator tbl = tables.begin();\n    for (; tbl != tables.end(); ++tbl)\n        delete *tbl;\n\n    std::list<EmPicture*>::iterator emb = emblist.begin();\n    for (; emb != emblist.end(); ++emb)\n        delete *emb;\n\n    std::list<HyperText*>::iterator hyp = hyperlist.begin();\n    for (; hyp != hyperlist.end(); ++hyp)\n        delete *hyp;\n}\n\nint HWPFile::ReadHwpFile(HStream * stream)\n{\n    if (Open(stream) != HWP_NoError)\n        return State();\n    InfoRead();\n    FontRead();\n    StyleRead();\n    AddColumnInfo();\n    ParaListRead();\n    TagsRead();\n\n    return State();\n}\n\nint detect_hwp_version(const char *str)\n{\n    if (memcmp(V20SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V20;\n    else if (memcmp(V21SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V21;\n    else if (memcmp(V30SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V30;\n    return 0;\n}\n\n// HIODev wrapper\n\nint HWPFile::Open(HStream * stream)\n{\n    HStreamIODev *hstreamio = new HStreamIODev(stream);\n\n    if (!hstreamio->open())\n    {\n        delete hstreamio;\n\n        return SetState(HWP_EMPTY_FILE);\n    }\n\n    HIODev *pPrev = SetIODevice(hstreamio);\n    delete pPrev;\n\n    char idstr[HWPIDLen];\n\n    if (ReadBlock(idstr, HWPIDLen) < HWPIDLen\n        || HWP_V30 != (version = detect_hwp_version(idstr)))\n    {\n        return SetState(HWP_UNSUPPORTED_VERSION);\n    }\n    return HWP_NoError;\n}\n\nint HWPFile::SetState(int errcode)\n{\n    error_code = errcode;\n    return error_code;\n}\n\nbool HWPFile::Read1b(char &out)\n{\n    unsigned char tmp8;\n    if (!hiodev || !hiodev->read1b(tmp8))\n        return false;\n    out = tmp8;\n    return true;\n}\n\nbool HWPFile::Read2b(unsigned short &out)\n{\n    return hiodev && hiodev->read2b(out);\n}\n\nbool HWPFile::Read4b(unsigned int &out)\n{\n    return hiodev && hiodev->read4b(out);\n}\n\nbool HWPFile::Read4b(int &out)\n{\n    unsigned int tmp32;\n    if (!Read4b(tmp32))\n        return false;\n    out = tmp32;\n    return true;\n}\n\nint HWPFile::Read1b(void *ptr, size_t nmemb)\n{\n    return hiodev ? hiodev->read1b(ptr, nmemb) : 0;\n}\n\nvoid HWPFile::Read2b(void *ptr, size_t nmemb)\n{\n    if (hiodev)\n        hiodev->read2b(ptr, nmemb);\n}\n\n\nvoid HWPFile::Read4b(void *ptr, size_t nmemb)\n{\n    if (hiodev)\n        hiodev->read4b(ptr, nmemb);\n}\n\n\nsize_t HWPFile::ReadBlock(void *ptr, size_t size)\n{\n    return hiodev ? hiodev->readBlock(ptr, size) : 0;\n}\n\n\nsize_t HWPFile::SkipBlock(size_t size)\n{\n    return hiodev ? hiodev->skipBlock(size) : 0;\n}\n\n\nvoid HWPFile::SetCompressed(bool flag)\n{\n    if (hiodev)\n        hiodev->setCompressed(flag);\n}\n\n\nHIODev *HWPFile::SetIODevice(HIODev * new_hiodev)\n{\n    HIODev *old_hiodev = hiodev;\n\n    hiodev = new_hiodev;\n\n    return old_hiodev;\n}\n\n\n// end of HIODev wrapper\n\nvoid HWPFile::InfoRead()\n{\n    _hwpInfo.Read(*this);\n}\n\n\nvoid HWPFile::FontRead()\n{\n    _hwpFont.Read(*this);\n}\n\n\nvoid HWPFile::StyleRead()\n{\n    _hwpStyle.Read(*this);\n}\n\n\nvoid HWPFile::ParaListRead()\n{\n    ReadParaList(plist);\n}\n\nbool HWPFile::ReadParaList(std::list < HWPPara* > &aplist, unsigned char flag)\n{\n    HWPPara *spNode = new HWPPara;\n     unsigned char tmp_etcflag;\n     unsigned char prev_etcflag = 0;\n    while (spNode->Read(*this, flag))\n    {\n         if( !(spNode->etcflag & 0x04) ){\n          tmp_etcflag = spNode->etcflag;\n          spNode->etcflag = prev_etcflag;\n          prev_etcflag = tmp_etcflag;\n         }\n        if (spNode->nch && spNode->reuse_shape)\n        {\n            if (!aplist.empty()){\n                     spNode->pshape = aplist.back()->pshape;\n                }\n                else{\n                     spNode->nch = 0;\n                     spNode->reuse_shape = 0;\n                }\n        }\n          spNode->pshape.pagebreak = spNode->etcflag;\n          if( spNode->nch )\n                AddParaShape( &spNode->pshape );\n\n        if (!aplist.empty())\n            aplist.back()->SetNext(spNode);\n        aplist.push_back(spNode);\n        spNode = new HWPPara;\n    }\n    delete spNode;\n\n    return true;\n}\n\nvoid HWPFile::TagsRead()\n{\n    while (true)\n    {\n        uint tag;\n        if (!Read4b(tag))\n            return;\n        int size;\n        if (!Read4b(size))\n            return;\n        if (size <= 0 && tag > 0){\n            continue;\n          }\n\n        if (tag == FILETAG_END_OF_COMPRESSED ||\n            tag == FILETAG_END_OF_UNCOMPRESSED)\n            return;\n        switch (tag)\n        {\n            case FILETAG_EMBEDDED_PICTURE:\n            {\n                EmPicture *emb = new EmPicture(size);\n\n                if (emb->Read(*this))\n                    emblist.push_back(emb);\n                else\n                    delete emb;\n            }\n            break;\n            case FILETAG_OLE_OBJECT:\n                delete oledata;\n                oledata = new OlePicture(size);\n                oledata->Read(*this);\n                break;\n            case FILETAG_HYPERTEXT:\n            {\n                if( (size % 617) != 0 )\n                    SkipBlock( size );\n                else\n                {\n                    for( int i = 0 ; i < size/617 ; i++)\n                    {\n                        HyperText *hypert = new HyperText;\n                        hypert->Read(*this);\n                        hyperlist.push_back(hypert);\n                    }\n                }\n                break;\n            }\n                case 6:\n                {\n                     ReadBlock(_hwpInfo.back_info.reserved1, 8);\n                     if (!Read4b(_hwpInfo.back_info.luminance))\n                        return;\n                     if (!Read4b(_hwpInfo.back_info.contrast))\n                        return;\n                     if (!Read1b(_hwpInfo.back_info.effect))\n                        return;\n                     ReadBlock(_hwpInfo.back_info.reserved2, 7);\n                     ReadBlock(_hwpInfo.back_info.filename, 260);\n                     ReadBlock(_hwpInfo.back_info.color, 3);\n                     unsigned short nFlag;\n                     if (!Read2b(nFlag))\n                        return;\n                     _hwpInfo.back_info.flag = nFlag >> 8 ;\n                     int nRange;\n                     if (!Read4b(nRange))\n                        return;\n                     _hwpInfo.back_info.range = nRange >> 24;\n                     ReadBlock(_hwpInfo.back_info.reserved3, 27);\n                     if (!Read4b(_hwpInfo.back_info.size))\n                        return;\n\n                     if (_hwpInfo.back_info.size < 0)\n                     {\n                        _hwpInfo.back_info.size = 0;\n                        return;\n                     }\n\n                     //read potentially compressed data in blocks as its more\n                     //likely large values are simply broken and we'll run out\n                     //of data before we need to realloc\n                     for (int i = 0; i < _hwpInfo.back_info.size; i+= SAL_MAX_UINT16)\n                     {\n                        int nOldSize = _hwpInfo.back_info.data.size();\n                        size_t nBlock = std::min<int>(SAL_MAX_UINT16, _hwpInfo.back_info.size - nOldSize);\n                        _hwpInfo.back_info.data.resize(nOldSize + nBlock);\n                        size_t nReadBlock = ReadBlock(_hwpInfo.back_info.data.data() + nOldSize, nBlock);\n                        if (nBlock != nReadBlock)\n                        {\n                            _hwpInfo.back_info.data.resize(nOldSize + nReadBlock);\n                            break;\n                        }\n                     }\n                     _hwpInfo.back_info.size = _hwpInfo.back_info.data.size();\n\n                     if( _hwpInfo.back_info.size > 0 )\n                          _hwpInfo.back_info.type = 2;\n                     else if( _hwpInfo.back_info.filename[0] )\n                          _hwpInfo.back_info.type = 1;\n                     else\n                          _hwpInfo.back_info.type = 0;\n\n\n                     _hwpInfo.back_info.isset = true;\n\n                     break;\n                }\n            case FILETAG_PRESENTATION:\n            case FILETAG_PREVIEW_IMAGE:\n            case FILETAG_PREVIEW_TEXT:\n            default:\n                SkipBlock(size);\n        }\n    }\n}\n\n\nColumnDef *HWPFile::GetColumnDef(int num)\n{\n    std::list<ColumnInfo*>::iterator it = columnlist.begin();\n\n    for(int i = 0; it != columnlist.end() ; ++it, i++){\n        if( i == num )\n            break;\n    }\n\n    if( it != columnlist.end() )\n        return (*it)->coldef;\n    else\n        return nullptr;\n}\n/* Index of @return starts from 1 */\nint HWPFile::GetPageMasterNum(int page)\n{\n    std::list<ColumnInfo*>::iterator it = columnlist.begin();\n    int i;\n\n    for( i = 1 ; it != columnlist.end() ; ++it, i++){\n        ColumnInfo *now = *it;\n        if( page < now->start_page )\n            return i-1;\n    }\n    return i-1;\n}\n\nHyperText *HWPFile::GetHyperText()\n{\n    std::list<HyperText*>::iterator it = hyperlist.begin();\n\n    for( int i = 0; it != hyperlist.end(); ++it, i++ ){\n        if( i == currenthyper )\n          break;\n    }\n\n    currenthyper++;\n    return it != hyperlist.end() ? *it : nullptr;\n}\n\nEmPicture *HWPFile::GetEmPicture(Picture * pic)\n{\n    char *name = pic->picinfo.picembed.embname;\n\n    name[0] = 'H';\n    name[1] = 'W';\n    name[2] = 'P';\n\n    std::list < EmPicture* >::iterator it = emblist.begin();\n    for (; it != emblist.end(); ++it)\n        if (strcmp(name, (*it)->name) == 0)\n            return *it;\n    return nullptr;\n}\n\nEmPicture *HWPFile::GetEmPictureByName(char * name)\n{\n    name[0] = 'H';\n    name[1] = 'W';\n    name[2] = 'P';\n\n    std::list < EmPicture* >::iterator it = emblist.begin();\n    for (; it != emblist.end(); ++it)\n        if (strcmp(name, (*it)->name) == 0)\n            return *it;\n    return nullptr;\n}\n\n\nvoid HWPFile::AddBox(FBox * box)\n{\n// LATER if we don't use box->next(),\n// AddBox() and GetBoxHead() are useless;\n    if (!blist.empty())\n    {\n        box->prev = blist.back();\n        box->prev->next = box;\n    }\n    else\n        box->prev = nullptr;\n    blist.push_back(box);\n}\n\nParaShape *HWPFile::getParaShape(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= pslist.size())\n        return nullptr;\n    return pslist[index];\n}\n\nCharShape *HWPFile::getCharShape(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= cslist.size())\n        return nullptr;\n    return cslist[index];\n}\n\nFBoxStyle *HWPFile::getFBoxStyle(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= fbslist.size())\n        return nullptr;\n    return fbslist[index];\n}\n\nDateCode *HWPFile::getDateCode(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= datecodes.size())\n        return nullptr;\n    return datecodes[index];\n}\n\nHeaderFooter *HWPFile::getHeaderFooter(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= headerfooters.size())\n        return nullptr;\n    return headerfooters[index];\n}\n\nShowPageNum *HWPFile::getPageNumber(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= pagenumbers.size())\n        return nullptr;\n    return pagenumbers[index];\n}\n\nTable *HWPFile::getTable(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= tables.size())\n        return nullptr;\n    return tables[index];\n}\n\nvoid HWPFile::AddParaShape(ParaShape * pshape)\n{\n    int nscount = 0;\n    for(int j = 0 ; j < MAXTABS-1 ; j++)\n    {\n        if( j > 0 && pshape->tabs[j].position == 0 )\n          break;\n        if( pshape->tabs[0].position == 0 ){\n            if( pshape->tabs[j].type || pshape->tabs[j].dot_continue ||\n                 (pshape->tabs[j].position != 1000 *j) )\n                      nscount = j;\n        }\n        else {\n            if( pshape->tabs[j].type || pshape->tabs[j].dot_continue ||\n                (pshape->tabs[j].position != 1000 * (j + 1)) )\n                    nscount = j;\n          }\n    }\n    if( nscount )\n        pshape->tabs[MAXTABS-1].type = sal::static_int_cast<char>(nscount);\n\n    int value = compareParaShape(pshape);\n\n    if( value == 0 || nscount )\n    {\n        pshape->index = ++pcount;\n        pslist.push_back(pshape);\n    }\n    else\n        pshape->index = value;\n}\n\n\nvoid HWPFile::AddCharShape(CharShape * cshape)\n{\n    int value = compareCharShape(cshape);\n    if( value == 0 )\n    {\n        cshape->index = ++ccount;\n        cslist.push_back(cshape);\n    }\n    else\n        cshape->index = value;\n}\n\nvoid HWPFile::AddColumnInfo()\n{\n    ColumnInfo *cinfo = new ColumnInfo(m_nCurrentPage);\n    columnlist.push_back(cinfo);\n    setMaxSettedPage();\n}\n\nvoid HWPFile::SetColumnDef(ColumnDef *coldef)\n{\n    ColumnInfo *cinfo = columnlist.back();\n    if( cinfo->bIsSet )\n        return;\n    cinfo->coldef = coldef;\n    cinfo->bIsSet = true;\n}\n\nvoid HWPFile::AddDateFormat(DateCode * hbox)\n{\n    hbox->key = sal::static_int_cast<char>(++datecodecount);\n    datecodes.push_back(hbox);\n}\n\nvoid HWPFile::AddPageNumber(ShowPageNum * hbox)\n{\n    pagenumbers.push_back(hbox);\n}\n\nvoid HWPFile::AddHeaderFooter(HeaderFooter * hbox)\n{\n    headerfooters.push_back(hbox);\n}\n\nvoid HWPFile::AddTable(Table * hbox)\n{\n    tables.push_back(hbox);\n}\n\nvoid HWPFile::AddFBoxStyle(FBoxStyle * fbstyle)\n{\n    fbslist.push_back(fbstyle);\n}\n\nint HWPFile::compareCharShape(CharShape *shape)\n{\n    int count = cslist.size();\n    if( count > 0 )\n    {\n        for(int i = 0; i< count; i++)\n        {\n            CharShape *cshape = getCharShape(i);\n\n            if( shape->size == cshape->size &&\n                shape->font[0] == cshape->font[0] &&\n                shape->ratio[0] == cshape->ratio[0] &&\n                shape->space[0] == cshape->space[0] &&\n                shape->color[1] == cshape->color[1] &&\n                shape->color[0] == cshape->color[0] &&\n                shape->shade == cshape->shade &&\n                shape->attr == cshape->attr )\n            {\n                return cshape->index;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint HWPFile::compareParaShape(ParaShape *shape)\n{\n    int count = pslist.size();\n    if( count > 0 )\n    {\n        for(int i = 0; i< count; i++)\n        {\n            ParaShape *pshape = getParaShape(i);\n            if( shape->left_margin == pshape->left_margin &&\n                shape->right_margin == pshape->right_margin &&\n                shape->pspacing_prev == pshape->pspacing_prev &&\n                shape->pspacing_next == pshape->pspacing_next &&\n                shape->indent == pshape->indent &&\n                shape->lspacing == pshape->lspacing &&\n                shape->arrange_type == pshape->arrange_type &&\n                shape->outline == pshape->outline  &&\n                     shape->pagebreak == pshape->pagebreak)\n            {\n                    if( shape->cshape && pshape->cshape &&\n                         shape->cshape->size == pshape->cshape->size &&\n                         shape->cshape->font[0] == pshape->cshape->font[0] &&\n                         shape->cshape->ratio[0] == pshape->cshape->ratio[0] &&\n                         shape->cshape->space[0] == pshape->cshape->space[0] &&\n                         shape->cshape->color[1] == pshape->cshape->color[1] &&\n                         shape->cshape->color[0] == pshape->cshape->color[0] &&\n                         shape->cshape->shade == pshape->cshape->shade &&\n                         shape->cshape->attr == pshape->cshape->attr )\n                    {\n                         return pshape->index;\n                    }\n            }\n        }\n    }\n    return 0;\n}\n\n\nHWPFile *GetCurrentDoc()\n{\n    return HWPFile::cur_doc;\n}\n\n\nHWPFile *SetCurrentDoc(HWPFile * hwpfp)\n{\n    HWPFile *org = HWPFile::cur_doc;\n\n    HWPFile::cur_doc = hwpfp;\n    return org;\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "fixing_code": ["/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n/*\n * This file is part of the LibreOffice project.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This file incorporates work covered by the following license notice:\n *\n *   Licensed to the Apache Software Foundation (ASF) under one or more\n *   contributor license agreements. See the NOTICE file distributed\n *   with this work for additional information regarding copyright\n *   ownership. The ASF licenses this file to you under the Apache\n *   License, Version 2.0 (the \"License\"); you may not use this file\n *   except in compliance with the License. You may obtain a copy of\n *   the License at http://www.apache.org/licenses/LICENSE-2.0 .\n */\n\n#include \"precompile.h\"\n\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"hwplib.h\"\n#include \"hwpfile.h\"\n#include \"hiodev.h\"\n#include \"hfont.h\"\n#include \"hstyle.h\"\n#include \"hbox.h\"\n#include \"hpara.h\"\n#include \"htags.h\"\n#include \"hcode.h\"\n#include \"hstream.hxx\"\n\n#include <osl/diagnose.h>\n\nHWPFile *HWPFile::cur_doc = nullptr;\nstatic int ccount = 0;\nstatic int pcount = 0;\nstatic int datecodecount = 0;\n\nHWPFile::HWPFile()\n    : version(HWP_V30)\n    , compressed(false)\n    , encrypted(false)\n    , linenumber(0)\n    , info_block_len(0)\n    , error_code(HWP_NoError)\n    , oledata(nullptr)\n    , m_nCurrentPage(1)\n    , m_nMaxSettedPage(0)\n    , hiodev(nullptr)\n    , currenthyper(0)\n{\n    SetCurrentDoc(this);\n}\n\nHWPFile::~HWPFile()\n{\n    delete oledata;\n    delete hiodev;\n\n    std::list < ColumnInfo* >::iterator it_column = columnlist.begin();\n    for (; it_column != columnlist.end(); ++it_column)\n        delete *it_column;\n\n    std::list < HWPPara* >::iterator it = plist.begin();\n    for (; it != plist.end(); ++it)\n        delete *it;\n\n    std::vector< Table* >::iterator tbl = tables.begin();\n    for (; tbl != tables.end(); ++tbl)\n        delete *tbl;\n\n    std::list<EmPicture*>::iterator emb = emblist.begin();\n    for (; emb != emblist.end(); ++emb)\n        delete *emb;\n\n    std::list<HyperText*>::iterator hyp = hyperlist.begin();\n    for (; hyp != hyperlist.end(); ++hyp)\n        delete *hyp;\n}\n\nint HWPFile::ReadHwpFile(HStream * stream)\n{\n    if (Open(stream) != HWP_NoError)\n        return State();\n    InfoRead();\n    FontRead();\n    StyleRead();\n    AddColumnInfo();\n    ParaListRead();\n    TagsRead();\n\n    return State();\n}\n\nint detect_hwp_version(const char *str)\n{\n    if (memcmp(V20SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V20;\n    else if (memcmp(V21SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V21;\n    else if (memcmp(V30SIGNATURE, str, HWPIDLen) == 0)\n        return HWP_V30;\n    return 0;\n}\n\n// HIODev wrapper\n\nint HWPFile::Open(HStream * stream)\n{\n    HStreamIODev *hstreamio = new HStreamIODev(stream);\n\n    if (!hstreamio->open())\n    {\n        delete hstreamio;\n\n        return SetState(HWP_EMPTY_FILE);\n    }\n\n    HIODev *pPrev = SetIODevice(hstreamio);\n    delete pPrev;\n\n    char idstr[HWPIDLen];\n\n    if (ReadBlock(idstr, HWPIDLen) < HWPIDLen\n        || HWP_V30 != (version = detect_hwp_version(idstr)))\n    {\n        return SetState(HWP_UNSUPPORTED_VERSION);\n    }\n    return HWP_NoError;\n}\n\nint HWPFile::SetState(int errcode)\n{\n    error_code = errcode;\n    return error_code;\n}\n\nbool HWPFile::Read1b(char &out)\n{\n    unsigned char tmp8;\n    if (!hiodev || !hiodev->read1b(tmp8))\n        return false;\n    out = tmp8;\n    return true;\n}\n\nbool HWPFile::Read2b(unsigned short &out)\n{\n    return hiodev && hiodev->read2b(out);\n}\n\nbool HWPFile::Read4b(unsigned int &out)\n{\n    return hiodev && hiodev->read4b(out);\n}\n\nbool HWPFile::Read4b(int &out)\n{\n    unsigned int tmp32;\n    if (!Read4b(tmp32))\n        return false;\n    out = tmp32;\n    return true;\n}\n\nint HWPFile::Read1b(void *ptr, size_t nmemb)\n{\n    return hiodev ? hiodev->read1b(ptr, nmemb) : 0;\n}\n\nvoid HWPFile::Read2b(void *ptr, size_t nmemb)\n{\n    if (hiodev)\n        hiodev->read2b(ptr, nmemb);\n}\n\n\nvoid HWPFile::Read4b(void *ptr, size_t nmemb)\n{\n    if (hiodev)\n        hiodev->read4b(ptr, nmemb);\n}\n\n\nsize_t HWPFile::ReadBlock(void *ptr, size_t size)\n{\n    return hiodev ? hiodev->readBlock(ptr, size) : 0;\n}\n\n\nsize_t HWPFile::SkipBlock(size_t size)\n{\n    return hiodev ? hiodev->skipBlock(size) : 0;\n}\n\n\nvoid HWPFile::SetCompressed(bool flag)\n{\n    if (hiodev)\n        hiodev->setCompressed(flag);\n}\n\n\nHIODev *HWPFile::SetIODevice(HIODev * new_hiodev)\n{\n    HIODev *old_hiodev = hiodev;\n\n    hiodev = new_hiodev;\n\n    return old_hiodev;\n}\n\n\n// end of HIODev wrapper\n\nvoid HWPFile::InfoRead()\n{\n    _hwpInfo.Read(*this);\n}\n\n\nvoid HWPFile::FontRead()\n{\n    _hwpFont.Read(*this);\n}\n\n\nvoid HWPFile::StyleRead()\n{\n    _hwpStyle.Read(*this);\n}\n\n\nvoid HWPFile::ParaListRead()\n{\n    ReadParaList(plist);\n}\n\nbool HWPFile::ReadParaList(std::list < HWPPara* > &aplist, unsigned char flag)\n{\n    HWPPara *spNode = new HWPPara;\n     unsigned char tmp_etcflag;\n     unsigned char prev_etcflag = 0;\n    while (spNode->Read(*this, flag))\n    {\n         if( !(spNode->etcflag & 0x04) ){\n          tmp_etcflag = spNode->etcflag;\n          spNode->etcflag = prev_etcflag;\n          prev_etcflag = tmp_etcflag;\n         }\n        if (spNode->nch && spNode->reuse_shape)\n        {\n            if (!aplist.empty()){\n                     spNode->pshape = aplist.back()->pshape;\n                }\n                else{\n                     spNode->nch = 0;\n                     spNode->reuse_shape = 0;\n                }\n        }\n          spNode->pshape.pagebreak = spNode->etcflag;\n          if( spNode->nch )\n                AddParaShape( &spNode->pshape );\n\n        if (!aplist.empty())\n            aplist.back()->SetNext(spNode);\n        aplist.push_back(spNode);\n        spNode = new HWPPara;\n    }\n    delete spNode;\n\n    return true;\n}\n\nvoid HWPFile::TagsRead()\n{\n    while (true)\n    {\n        uint tag;\n        if (!Read4b(tag))\n            return;\n        int size;\n        if (!Read4b(size))\n            return;\n        if (size <= 0 && tag > 0){\n            continue;\n          }\n\n        if (tag == FILETAG_END_OF_COMPRESSED ||\n            tag == FILETAG_END_OF_UNCOMPRESSED)\n            return;\n        switch (tag)\n        {\n            case FILETAG_EMBEDDED_PICTURE:\n            {\n                EmPicture *emb = new EmPicture(size);\n\n                if (emb->Read(*this))\n                    emblist.push_back(emb);\n                else\n                    delete emb;\n            }\n            break;\n            case FILETAG_OLE_OBJECT:\n                delete oledata;\n                oledata = new OlePicture(size);\n                oledata->Read(*this);\n                break;\n            case FILETAG_HYPERTEXT:\n            {\n                if( (size % 617) != 0 )\n                    SkipBlock( size );\n                else\n                {\n                    for( int i = 0 ; i < size/617 ; i++)\n                    {\n                        HyperText *hypert = new HyperText;\n                        hypert->Read(*this);\n                        hyperlist.push_back(hypert);\n                    }\n                }\n                break;\n            }\n                case 6:\n                {\n                     ReadBlock(_hwpInfo.back_info.reserved1, 8);\n                     if (!Read4b(_hwpInfo.back_info.luminance))\n                        return;\n                     if (!Read4b(_hwpInfo.back_info.contrast))\n                        return;\n                     if (!Read1b(_hwpInfo.back_info.effect))\n                        return;\n                     ReadBlock(_hwpInfo.back_info.reserved2, 7);\n                     ReadBlock(_hwpInfo.back_info.filename, 260);\n                     ReadBlock(_hwpInfo.back_info.color, 3);\n                     unsigned short nFlag;\n                     if (!Read2b(nFlag))\n                        return;\n                     _hwpInfo.back_info.flag = nFlag >> 8 ;\n                     int nRange;\n                     if (!Read4b(nRange))\n                        return;\n                     _hwpInfo.back_info.range = nRange >> 24;\n                     ReadBlock(_hwpInfo.back_info.reserved3, 27);\n                     if (!Read4b(_hwpInfo.back_info.size))\n                        return;\n\n                     if (_hwpInfo.back_info.size < 0)\n                     {\n                        _hwpInfo.back_info.size = 0;\n                        return;\n                     }\n\n                     _hwpInfo.back_info.data.clear();\n\n                     //read potentially compressed data in blocks as its more\n                     //likely large values are simply broken and we'll run out\n                     //of data before we need to realloc\n                     for (int i = 0; i < _hwpInfo.back_info.size; i+= SAL_MAX_UINT16)\n                     {\n                        int nOldSize = _hwpInfo.back_info.data.size();\n                        size_t nBlock = std::min<int>(SAL_MAX_UINT16, _hwpInfo.back_info.size - nOldSize);\n                        _hwpInfo.back_info.data.resize(nOldSize + nBlock);\n                        size_t nReadBlock = ReadBlock(_hwpInfo.back_info.data.data() + nOldSize, nBlock);\n                        if (nBlock != nReadBlock)\n                        {\n                            _hwpInfo.back_info.data.resize(nOldSize + nReadBlock);\n                            break;\n                        }\n                     }\n                     _hwpInfo.back_info.size = _hwpInfo.back_info.data.size();\n\n                     if( _hwpInfo.back_info.size > 0 )\n                          _hwpInfo.back_info.type = 2;\n                     else if( _hwpInfo.back_info.filename[0] )\n                          _hwpInfo.back_info.type = 1;\n                     else\n                          _hwpInfo.back_info.type = 0;\n\n\n                     _hwpInfo.back_info.isset = true;\n\n                     break;\n                }\n            case FILETAG_PRESENTATION:\n            case FILETAG_PREVIEW_IMAGE:\n            case FILETAG_PREVIEW_TEXT:\n            default:\n                SkipBlock(size);\n        }\n    }\n}\n\n\nColumnDef *HWPFile::GetColumnDef(int num)\n{\n    std::list<ColumnInfo*>::iterator it = columnlist.begin();\n\n    for(int i = 0; it != columnlist.end() ; ++it, i++){\n        if( i == num )\n            break;\n    }\n\n    if( it != columnlist.end() )\n        return (*it)->coldef;\n    else\n        return nullptr;\n}\n/* Index of @return starts from 1 */\nint HWPFile::GetPageMasterNum(int page)\n{\n    std::list<ColumnInfo*>::iterator it = columnlist.begin();\n    int i;\n\n    for( i = 1 ; it != columnlist.end() ; ++it, i++){\n        ColumnInfo *now = *it;\n        if( page < now->start_page )\n            return i-1;\n    }\n    return i-1;\n}\n\nHyperText *HWPFile::GetHyperText()\n{\n    std::list<HyperText*>::iterator it = hyperlist.begin();\n\n    for( int i = 0; it != hyperlist.end(); ++it, i++ ){\n        if( i == currenthyper )\n          break;\n    }\n\n    currenthyper++;\n    return it != hyperlist.end() ? *it : nullptr;\n}\n\nEmPicture *HWPFile::GetEmPicture(Picture * pic)\n{\n    char *name = pic->picinfo.picembed.embname;\n\n    name[0] = 'H';\n    name[1] = 'W';\n    name[2] = 'P';\n\n    std::list < EmPicture* >::iterator it = emblist.begin();\n    for (; it != emblist.end(); ++it)\n        if (strcmp(name, (*it)->name) == 0)\n            return *it;\n    return nullptr;\n}\n\nEmPicture *HWPFile::GetEmPictureByName(char * name)\n{\n    name[0] = 'H';\n    name[1] = 'W';\n    name[2] = 'P';\n\n    std::list < EmPicture* >::iterator it = emblist.begin();\n    for (; it != emblist.end(); ++it)\n        if (strcmp(name, (*it)->name) == 0)\n            return *it;\n    return nullptr;\n}\n\n\nvoid HWPFile::AddBox(FBox * box)\n{\n// LATER if we don't use box->next(),\n// AddBox() and GetBoxHead() are useless;\n    if (!blist.empty())\n    {\n        box->prev = blist.back();\n        box->prev->next = box;\n    }\n    else\n        box->prev = nullptr;\n    blist.push_back(box);\n}\n\nParaShape *HWPFile::getParaShape(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= pslist.size())\n        return nullptr;\n    return pslist[index];\n}\n\nCharShape *HWPFile::getCharShape(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= cslist.size())\n        return nullptr;\n    return cslist[index];\n}\n\nFBoxStyle *HWPFile::getFBoxStyle(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= fbslist.size())\n        return nullptr;\n    return fbslist[index];\n}\n\nDateCode *HWPFile::getDateCode(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= datecodes.size())\n        return nullptr;\n    return datecodes[index];\n}\n\nHeaderFooter *HWPFile::getHeaderFooter(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= headerfooters.size())\n        return nullptr;\n    return headerfooters[index];\n}\n\nShowPageNum *HWPFile::getPageNumber(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= pagenumbers.size())\n        return nullptr;\n    return pagenumbers[index];\n}\n\nTable *HWPFile::getTable(int index)\n{\n    if (index < 0 || static_cast<unsigned int>(index) >= tables.size())\n        return nullptr;\n    return tables[index];\n}\n\nvoid HWPFile::AddParaShape(ParaShape * pshape)\n{\n    int nscount = 0;\n    for(int j = 0 ; j < MAXTABS-1 ; j++)\n    {\n        if( j > 0 && pshape->tabs[j].position == 0 )\n          break;\n        if( pshape->tabs[0].position == 0 ){\n            if( pshape->tabs[j].type || pshape->tabs[j].dot_continue ||\n                 (pshape->tabs[j].position != 1000 *j) )\n                      nscount = j;\n        }\n        else {\n            if( pshape->tabs[j].type || pshape->tabs[j].dot_continue ||\n                (pshape->tabs[j].position != 1000 * (j + 1)) )\n                    nscount = j;\n          }\n    }\n    if( nscount )\n        pshape->tabs[MAXTABS-1].type = sal::static_int_cast<char>(nscount);\n\n    int value = compareParaShape(pshape);\n\n    if( value == 0 || nscount )\n    {\n        pshape->index = ++pcount;\n        pslist.push_back(pshape);\n    }\n    else\n        pshape->index = value;\n}\n\n\nvoid HWPFile::AddCharShape(CharShape * cshape)\n{\n    int value = compareCharShape(cshape);\n    if( value == 0 )\n    {\n        cshape->index = ++ccount;\n        cslist.push_back(cshape);\n    }\n    else\n        cshape->index = value;\n}\n\nvoid HWPFile::AddColumnInfo()\n{\n    ColumnInfo *cinfo = new ColumnInfo(m_nCurrentPage);\n    columnlist.push_back(cinfo);\n    setMaxSettedPage();\n}\n\nvoid HWPFile::SetColumnDef(ColumnDef *coldef)\n{\n    ColumnInfo *cinfo = columnlist.back();\n    if( cinfo->bIsSet )\n        return;\n    cinfo->coldef = coldef;\n    cinfo->bIsSet = true;\n}\n\nvoid HWPFile::AddDateFormat(DateCode * hbox)\n{\n    hbox->key = sal::static_int_cast<char>(++datecodecount);\n    datecodes.push_back(hbox);\n}\n\nvoid HWPFile::AddPageNumber(ShowPageNum * hbox)\n{\n    pagenumbers.push_back(hbox);\n}\n\nvoid HWPFile::AddHeaderFooter(HeaderFooter * hbox)\n{\n    headerfooters.push_back(hbox);\n}\n\nvoid HWPFile::AddTable(Table * hbox)\n{\n    tables.push_back(hbox);\n}\n\nvoid HWPFile::AddFBoxStyle(FBoxStyle * fbstyle)\n{\n    fbslist.push_back(fbstyle);\n}\n\nint HWPFile::compareCharShape(CharShape *shape)\n{\n    int count = cslist.size();\n    if( count > 0 )\n    {\n        for(int i = 0; i< count; i++)\n        {\n            CharShape *cshape = getCharShape(i);\n\n            if( shape->size == cshape->size &&\n                shape->font[0] == cshape->font[0] &&\n                shape->ratio[0] == cshape->ratio[0] &&\n                shape->space[0] == cshape->space[0] &&\n                shape->color[1] == cshape->color[1] &&\n                shape->color[0] == cshape->color[0] &&\n                shape->shade == cshape->shade &&\n                shape->attr == cshape->attr )\n            {\n                return cshape->index;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint HWPFile::compareParaShape(ParaShape *shape)\n{\n    int count = pslist.size();\n    if( count > 0 )\n    {\n        for(int i = 0; i< count; i++)\n        {\n            ParaShape *pshape = getParaShape(i);\n            if( shape->left_margin == pshape->left_margin &&\n                shape->right_margin == pshape->right_margin &&\n                shape->pspacing_prev == pshape->pspacing_prev &&\n                shape->pspacing_next == pshape->pspacing_next &&\n                shape->indent == pshape->indent &&\n                shape->lspacing == pshape->lspacing &&\n                shape->arrange_type == pshape->arrange_type &&\n                shape->outline == pshape->outline  &&\n                     shape->pagebreak == pshape->pagebreak)\n            {\n                    if( shape->cshape && pshape->cshape &&\n                         shape->cshape->size == pshape->cshape->size &&\n                         shape->cshape->font[0] == pshape->cshape->font[0] &&\n                         shape->cshape->ratio[0] == pshape->cshape->ratio[0] &&\n                         shape->cshape->space[0] == pshape->cshape->space[0] &&\n                         shape->cshape->color[1] == pshape->cshape->color[1] &&\n                         shape->cshape->color[0] == pshape->cshape->color[0] &&\n                         shape->cshape->shade == pshape->cshape->shade &&\n                         shape->cshape->attr == pshape->cshape->attr )\n                    {\n                         return pshape->index;\n                    }\n            }\n        }\n    }\n    return 0;\n}\n\n\nHWPFile *GetCurrentDoc()\n{\n    return HWPFile::cur_doc;\n}\n\n\nHWPFile *SetCurrentDoc(HWPFile * hwpfp)\n{\n    HWPFile *org = HWPFile::cur_doc;\n\n    HWPFile::cur_doc = hwpfp;\n    return org;\n}\n\n/* vim:set shiftwidth=4 softtabstop=4 expandtab: */\n"], "filenames": ["hwpfilter/source/hwpfile.cxx"], "buggy_code_start_loc": [359], "buggy_code_end_loc": [359], "fixing_code_start_loc": [360], "fixing_code_end_loc": [362], "type": "CWE-787", "message": "LibreOffice before 2017-03-14 has an out-of-bounds write related to the HWPFile::TagsRead function in hwpfilter/source/hwpfile.cxx.", "other": {"cve": {"id": "CVE-2017-7882", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-15T16:59:00.410", "lastModified": "2017-11-15T02:29:10.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "LibreOffice before 2017-03-14 has an out-of-bounds write related to the HWPFile::TagsRead function in hwpfilter/source/hwpfile.cxx."}, {"lang": "es", "value": "LibreOffice en versiones anteriores a 14-03-2017 tiene una escritura fuera de l\u00edmites relacionada con la funci\u00f3n HWPFile::TagsRead en hwpfilter/source/hwpfile.cxx."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreoffice:libreoffice:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.2.6", "matchCriteriaId": "DD6FB845-4F3E-48DD-B9BB-9986BD4F48FC"}]}]}], "references": [{"url": "http://www.libreoffice.org/about-us/security/advisories/cve-2017-7882/", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97684", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=860", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/LibreOffice/core/commit/65dcd1d8195069c8c8acb3a188b8e5616c51029c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreOffice/core/commit/65dcd1d8195069c8c8acb3a188b8e5616c51029c"}}