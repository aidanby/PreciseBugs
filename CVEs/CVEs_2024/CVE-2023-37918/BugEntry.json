{"buggy_code": ["# Dapr 1.11.2 [security]\n\nThis update contains security fixes:\n\n  - [Security: Potential DoS in avro dependency (CVE-2023-37475)](#security-potential-dos-in-avro-dependency-cve-2023-37475)\n\nAdditionally, this patch release contains bug fixes:\n\n  - [Fixed: unbounded history batch save in Workflows](#fixed-unbounded-history-batch-save-in-workflows)\n  - [Fixed: Workflows not working in some Kubernetes clusters](#fixed-workflows-not-working-in-some-kubernetes-clusters)\n  - [Fixed a number of bugs in the gRPC Configuration Subscribe API](#fixed-a-number-of-bugs-in-the-grpc-configuration-subscribe-api)\n\n## Security: Potential DoS in avro dependency (CVE-2023-37475)\n\n### Problem\n\n[CVE-2023-37475](https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45)\n\nAn issue in the third-party avro dependency could cause a resource exhaustion and a DoS for Dapr.\n\n### Impact\n\nThis issue impacts users of Dapr that use the Pulsar components.\n\n### Root cause\n\nThe issue was in a third-party dependency.\n\n### Solution\n\nWe have upgraded the avro dependency to version 2.13.0 which contains a fix for the reported issue.\n\n## Fixed: unbounded history batch save in Workflows\n\n### Problem\n\nDue to a bug in the workflow engine, the full workflow history was saved on each checkpoint, rather than only the deltas. This resulted in two problems:\n\n- The I/O cost of saving workflow state increased over the lifetime of the workflow\n- Using state stores which have limits on transaction batch sizes, for example Azure Cosmos DB, caused workflows with more than a few actions to fail permanently\n\n### Impact\n\nThe issue impacts users of Dapr Workflow on Dapr 1.10 and higher.\n\n### Root cause\n\nThe problem was caused by a coding issue: an object was passed by reference rather than as a pointer.\n\n### Solution\n\nWe fixed the issue in the source code and added new tests to prevent regressions.\n\n## Fixed: Workflows not working in some Kubernetes clusters\n\n### Problem\n\nIn some Kubernetes clusters, the workflow engine may not have been able to process work items and tasks that were part of a workflow. Calls to the workflow engine would time out and fail.\n\n### Impact\n\nThe issue impacts users of Dapr Workflows which run the Dapr gRPC server listening on more than one address. This is the default behavior on Kubernetes, where Dapr normally listens on both `127.0.0.1` (IPv4) an `[::1]` (IPv6). The issue can appear also outside of Kubernetes if users run Dapr with multiple values for `--dapr-listen-addresses`.\n\n### Root cause\n\nA new instance of the workflow engine was attached to each Dapr gRPC listener independently. Depending on what protocol the application was using to connect to Dapr (IPv4 or IPv6), the request could hit a workflow engine that was not currently processing tasks, causing a deadlock.\n\n### Solution\n\nWe have changed the initialization code to ensure that Dapr uses a single instance of the workflow engine across all listeners.\n\n## Fixed a number of bugs in the gRPC Configuration Subscribe API\n\n### Problem\n\nWe identified a number of bugs, especially race conditions, in the gRPC implementation for the Configuration Subscribe API, which became stable in Dapr 1.11.0. These bugs could have caused the Subscribe API to behave unexpectedly.\n\n### Impact\n\nThe issue can impact users that are invoking the Configuration building block APIs using gRPC.\n\n### Root cause\n\nThe issues were traced back to a number of race conditions in the way the gRPC stream was handled.\n\n### Solution\n\nWe refactored the code to remove the race conditions and fix the bugs.\n", "/*\nCopyright 2021 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage http\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcors \"github.com/AdhityaRamadhanus/fasthttpcors\"\n\trouting \"github.com/fasthttp/router\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/valyala/fasthttp\"\n\t\"github.com/valyala/fasthttp/pprofhandler\"\n\n\t\"github.com/dapr/dapr/pkg/config\"\n\tcorsDapr \"github.com/dapr/dapr/pkg/cors\"\n\tdiag \"github.com/dapr/dapr/pkg/diagnostics\"\n\tdiagUtils \"github.com/dapr/dapr/pkg/diagnostics/utils\"\n\thttpMiddleware \"github.com/dapr/dapr/pkg/middleware/http\"\n\tauth \"github.com/dapr/dapr/pkg/runtime/security\"\n\tauthConsts \"github.com/dapr/dapr/pkg/runtime/security/consts\"\n\t\"github.com/dapr/dapr/utils/fasthttpadaptor\"\n\t\"github.com/dapr/dapr/utils/nethttpadaptor\"\n\t\"github.com/dapr/kit/logger\"\n)\n\nvar (\n\tlog     = logger.NewLogger(\"dapr.runtime.http\")\n\tinfoLog = logger.NewLogger(\"dapr.runtime.http-info\")\n)\n\n// Server is an interface for the Dapr HTTP server.\ntype Server interface {\n\tio.Closer\n\tStartNonBlocking() error\n}\n\ntype server struct {\n\tconfig             ServerConfig\n\ttracingSpec        config.TracingSpec\n\tmetricSpec         config.MetricSpec\n\tpipeline           httpMiddleware.Pipeline\n\tapi                API\n\tapiSpec            config.APISpec\n\tservers            []*fasthttp.Server\n\tprofilingListeners []net.Listener\n}\n\n// NewServerOpts are the options for NewServer.\ntype NewServerOpts struct {\n\tAPI         API\n\tConfig      ServerConfig\n\tTracingSpec config.TracingSpec\n\tMetricSpec  config.MetricSpec\n\tPipeline    httpMiddleware.Pipeline\n\tAPISpec     config.APISpec\n}\n\n// NewServer returns a new HTTP server.\nfunc NewServer(opts NewServerOpts) Server {\n\tinfoLog.SetOutputLevel(logger.LogLevel(\"info\"))\n\treturn &server{\n\t\tapi:         opts.API,\n\t\tconfig:      opts.Config,\n\t\ttracingSpec: opts.TracingSpec,\n\t\tmetricSpec:  opts.MetricSpec,\n\t\tpipeline:    opts.Pipeline,\n\t\tapiSpec:     opts.APISpec,\n\t}\n}\n\n// StartNonBlocking starts a new server in a goroutine.\nfunc (s *server) StartNonBlocking() error {\n\thandler := s.useRouter()\n\thandler = s.useComponents(handler)\n\thandler = s.useCors(handler)\n\thandler = useAPIAuthentication(handler)\n\thandler = s.useMetrics(handler)\n\thandler = s.useTracing(handler)\n\n\tvar listeners []net.Listener\n\tvar profilingListeners []net.Listener\n\tif s.config.UnixDomainSocket != \"\" {\n\t\tsocket := fmt.Sprintf(\"%s/dapr-%s-http.socket\", s.config.UnixDomainSocket, s.config.AppID)\n\t\tl, err := net.Listen(\"unix\", socket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlog.Infof(\"HTTP server listening on UNIX socket: %s\", socket)\n\t\tlisteners = append(listeners, l)\n\t} else {\n\t\tfor _, apiListenAddress := range s.config.APIListenAddresses {\n\t\t\taddr := apiListenAddress + \":\" + strconv.Itoa(s.config.Port)\n\t\t\tl, err := net.Listen(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debugf(\"Failed to listen for HTTP server on TCP address %s with error: %v\", addr, err)\n\t\t\t} else {\n\t\t\t\tlog.Infof(\"HTTP server listening on TCP address: %s\", addr)\n\t\t\t\tlisteners = append(listeners, l)\n\t\t\t}\n\t\t}\n\t}\n\tif len(listeners) == 0 {\n\t\treturn errors.New(\"could not listen on any endpoint\")\n\t}\n\n\tfor _, listener := range listeners {\n\t\t// customServer is created in a loop because each instance\n\t\t// has a handle on the underlying listener.\n\t\tcustomServer := &fasthttp.Server{\n\t\t\tHandler:               handler,\n\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\tReadBufferSize:        s.config.ReadBufferSize * 1024,\n\t\t\tNoDefaultServerHeader: true,\n\t\t}\n\t\ts.servers = append(s.servers, customServer)\n\n\t\tgo func(l net.Listener) {\n\t\t\tif err := customServer.Serve(l); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(listener)\n\t}\n\n\tif s.config.PublicPort != nil {\n\t\tpublicHandler := s.usePublicRouter()\n\t\tpublicHandler = s.useMetrics(publicHandler)\n\t\tpublicHandler = s.useTracing(publicHandler)\n\n\t\thealthServer := &fasthttp.Server{\n\t\t\tHandler:               publicHandler,\n\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\tNoDefaultServerHeader: true,\n\t\t}\n\t\ts.servers = append(s.servers, healthServer)\n\n\t\tgo func() {\n\t\t\tif err := healthServer.ListenAndServe(fmt.Sprintf(\":%d\", *s.config.PublicPort)); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif s.config.EnableProfiling {\n\t\tfor _, apiListenAddress := range s.config.APIListenAddresses {\n\t\t\taddr := apiListenAddress + \":\" + strconv.Itoa(s.config.ProfilePort)\n\t\t\tpl, err := net.Listen(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debugf(\"Failed to listen for profiling server on TCP address %s with error: %v\", addr, err)\n\t\t\t} else {\n\t\t\t\tlog.Infof(\"HTTP profiling server listening on: %s\", addr)\n\t\t\t\tprofilingListeners = append(profilingListeners, pl)\n\t\t\t}\n\t\t}\n\n\t\tif len(profilingListeners) == 0 {\n\t\t\treturn errors.New(\"could not listen on any endpoint for profiling API\")\n\t\t}\n\n\t\ts.profilingListeners = profilingListeners\n\t\tfor _, listener := range profilingListeners {\n\t\t\t// profServer is created in a loop because each instance\n\t\t\t// has a handle on the underlying listener.\n\t\t\tprofServer := &fasthttp.Server{\n\t\t\t\tHandler:               pprofhandler.PprofHandler,\n\t\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\t\tNoDefaultServerHeader: true,\n\t\t\t}\n\t\t\ts.servers = append(s.servers, profServer)\n\n\t\t\tgo func(l net.Listener) {\n\t\t\t\tif err := profServer.Serve(l); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}(listener)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *server) Close() error {\n\tvar merr error\n\n\tfor _, ln := range s.servers {\n\t\t// This calls `Close()` on the underlying listener.\n\t\tif err := ln.Shutdown(); err != nil {\n\t\t\tmerr = multierror.Append(merr, err)\n\t\t}\n\t}\n\n\treturn merr\n}\n\nfunc (s *server) useTracing(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif diagUtils.IsTracingEnabled(s.tracingSpec.SamplingRate) {\n\t\tlog.Infof(\"enabled tracing http middleware\")\n\t\treturn diag.HTTPTraceMiddleware(next, s.config.AppID, s.tracingSpec)\n\t}\n\treturn next\n}\n\nfunc (s *server) useMetrics(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif s.metricSpec.Enabled {\n\t\tlog.Infof(\"enabled metrics http middleware\")\n\n\t\treturn diag.DefaultHTTPMonitoring.FastHTTPMiddleware(next)\n\t}\n\n\treturn next\n}\n\nfunc (s *server) apiLoggingInfo(route string, next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tfields := make(map[string]any, 2)\n\t\tif s.config.APILoggingObfuscateURLs {\n\t\t\tfields[\"method\"] = string(ctx.Method()) + \" \" + route\n\t\t} else {\n\t\t\tfields[\"method\"] = string(ctx.Method()) + \" \" + string(ctx.Path())\n\t\t}\n\t\tif userAgent := string(ctx.Request.Header.Peek(\"User-Agent\")); userAgent != \"\" {\n\t\t\tfields[\"useragent\"] = userAgent\n\t\t}\n\n\t\tinfoLog.WithFields(fields).Info(\"HTTP API Called\")\n\t\tnext(ctx)\n\t}\n}\n\nfunc (s *server) useRouter() fasthttp.RequestHandler {\n\tendpoints := s.api.APIEndpoints()\n\trouter := s.getRouter(endpoints)\n\n\treturn router.Handler\n}\n\nfunc (s *server) usePublicRouter() fasthttp.RequestHandler {\n\tendpoints := s.api.PublicEndpoints()\n\trouter := s.getRouter(endpoints)\n\n\treturn router.Handler\n}\n\nfunc (s *server) useComponents(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn fasthttpadaptor.NewFastHTTPHandler(\n\t\ts.pipeline.Apply(\n\t\t\tnethttpadaptor.NewNetHTTPHandlerFunc(next),\n\t\t),\n\t)\n}\n\nfunc (s *server) useCors(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif s.config.AllowedOrigins == corsDapr.DefaultAllowedOrigins {\n\t\treturn next\n\t}\n\n\tlog.Infof(\"enabled cors http middleware\")\n\torigins := strings.Split(s.config.AllowedOrigins, \",\")\n\tcorsHandler := s.getCorsHandler(origins)\n\treturn corsHandler.CorsMiddleware(next)\n}\n\nfunc useAPIAuthentication(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\ttoken := auth.GetAPIToken()\n\tif token == \"\" {\n\t\treturn next\n\t}\n\tlog.Info(\"enabled token authentication on http server\")\n\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tv := ctx.Request.Header.Peek(authConsts.APITokenHeader)\n\t\tif auth.ExcludedRoute(string(ctx.Request.URI().FullURI())) || string(v) == token {\n\t\t\tctx.Request.Header.Del(authConsts.APITokenHeader)\n\t\t\tnext(ctx)\n\t\t} else {\n\t\t\tctx.Error(\"invalid api token\", http.StatusUnauthorized)\n\t\t}\n\t}\n}\n\nfunc (s *server) getCorsHandler(allowedOrigins []string) *cors.CorsHandler {\n\treturn cors.NewCorsHandler(cors.Options{\n\t\tAllowedOrigins: allowedOrigins,\n\t\tDebug:          false,\n\t})\n}\n\nfunc (s *server) unescapeRequestParametersHandler(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tparseError := false\n\t\tunescapeRequestParameters := func(parameter []byte, valI interface{}) {\n\t\t\tvalue, ok := valI.(string)\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !parseError {\n\t\t\t\tparameterUnescapedValue, err := url.QueryUnescape(value)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctx.SetUserValueBytes(parameter, parameterUnescapedValue)\n\t\t\t\t} else {\n\t\t\t\t\tparseError = true\n\t\t\t\t\terrorMessage := fmt.Sprintf(\"Failed to unescape request parameter %s with value %s. Error: %s\", parameter, value, err.Error())\n\t\t\t\t\tlog.Debug(errorMessage)\n\t\t\t\t\tctx.Error(errorMessage, fasthttp.StatusBadRequest)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.VisitUserValues(unescapeRequestParameters)\n\n\t\tif !parseError {\n\t\t\tnext(ctx)\n\t\t}\n\t}\n}\n\nfunc (s *server) getRouter(endpoints []Endpoint) *routing.Router {\n\trouter := routing.New()\n\tparameterFinder, _ := regexp.Compile(\"/{.*}\")\n\n\t// Build the API allowlist and denylist\n\tallowedAPIs := s.apiSpec.Allowed.GetRulesByProtocol(config.APIAccessRuleProtocolHTTP)\n\tdeniedAPIs := s.apiSpec.Denied.GetRulesByProtocol(config.APIAccessRuleProtocolHTTP)\n\n\tfor _, e := range endpoints {\n\t\tif !e.IsAllowed(allowedAPIs, deniedAPIs) {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.handle(e, parameterFinder, \"/\"+e.Version+\"/\"+e.Route, router)\n\n\t\tif e.Alias != \"\" {\n\t\t\ts.handle(e, parameterFinder, \"/\"+e.Alias, router)\n\t\t}\n\t}\n\n\treturn router\n}\n\nfunc (s *server) handle(e Endpoint, parameterFinder *regexp.Regexp, path string, router *routing.Router) {\n\tpathIncludesParameters := parameterFinder.MatchString(path)\n\n\tfor _, m := range e.Methods {\n\t\thandler := e.Handler\n\n\t\tif pathIncludesParameters && !e.KeepParamUnescape {\n\t\t\thandler = s.unescapeRequestParametersHandler(handler)\n\t\t}\n\n\t\tif s.config.EnableAPILogging && (!e.IsHealthCheck || s.config.APILogHealthChecks) {\n\t\t\thandler = s.apiLoggingInfo(path, handler)\n\t\t}\n\n\t\trouter.Handle(m, path, handler)\n\t}\n}\n", "/*\nCopyright 2022 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage security\n\nimport (\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/dapr/dapr/pkg/runtime/security/consts\"\n)\n\nvar excludedRoutes = []string{\"/healthz\"}\n\n// GetAPIToken returns the value of the api token from an environment variable.\nfunc GetAPIToken() string {\n\treturn os.Getenv(consts.APITokenEnvVar)\n}\n\n// GetAppToken returns the value of the app api token from an environment variable.\nfunc GetAppToken() string {\n\treturn os.Getenv(consts.AppAPITokenEnvVar)\n}\n\n// ExcludedRoute returns whether a given route should be excluded from a token check.\nfunc ExcludedRoute(route string) bool {\n\tfor _, r := range excludedRoutes {\n\t\tif strings.Contains(route, r) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n", "/*\nCopyright 2022 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage security\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/dapr/dapr/pkg/runtime/security/consts\"\n)\n\nfunc TestAPIToken(t *testing.T) {\n\tt.Run(\"existing token\", func(t *testing.T) {\n\t\t/* #nosec */\n\t\ttoken := \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4\"\n\t\tt.Setenv(consts.APITokenEnvVar, token)\n\n\t\tapitoken := GetAPIToken()\n\t\tassert.Equal(t, token, apitoken)\n\t})\n\n\tt.Run(\"non-existent token\", func(t *testing.T) {\n\t\ttoken := GetAPIToken()\n\t\tassert.Equal(t, \"\", token)\n\t})\n}\n\nfunc TestAppToken(t *testing.T) {\n\tt.Run(\"existing token\", func(t *testing.T) {\n\t\t/* #nosec */\n\t\ttoken := \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4\"\n\t\tt.Setenv(consts.AppAPITokenEnvVar, token)\n\n\t\tapitoken := GetAppToken()\n\t\tassert.Equal(t, token, apitoken)\n\t})\n\n\tt.Run(\"non-existent token\", func(t *testing.T) {\n\t\ttoken := GetAppToken()\n\t\tassert.Equal(t, \"\", token)\n\t})\n}\n\nfunc TestExcludedRoute(t *testing.T) {\n\tt.Run(\"healthz route is excluded\", func(t *testing.T) {\n\t\troute := \"v1.0/healthz\"\n\t\texcluded := ExcludedRoute(route)\n\t\tassert.True(t, excluded)\n\t})\n\n\tt.Run(\"custom route is not excluded\", func(t *testing.T) {\n\t\troute := \"v1.0/state\"\n\t\texcluded := ExcludedRoute(route)\n\t\tassert.False(t, excluded)\n\t})\n}\n"], "fixing_code": ["# Dapr 1.11.2 [security]\n\nThis update contains security fixes:\n\n  - [Security: API token authentication bypass in HTTP endpoints](#security-api-token-authentication-bypass-in-http-endpoints) ([Security advisory](https://github.com/dapr/dapr/security/advisories/GHSA-59m6-82qm-vqgj))\n  - [Security: Potential DoS in avro dependency](#security-potential-dos-in-avro-dependency-cve-2023-37475) ([CVE-2023-37475](https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45))\n\nAdditionally, this patch release contains bug fixes:\n\n  - [Fixed: unbounded history batch save in Workflows](#fixed-unbounded-history-batch-save-in-workflows)\n  - [Fixed: Workflows not working in some Kubernetes clusters](#fixed-workflows-not-working-in-some-kubernetes-clusters)\n  - [Fixed a number of bugs in the gRPC Configuration Subscribe API](#fixed-a-number-of-bugs-in-the-grpc-configuration-subscribe-api)\n\n## Security: API token authentication bypass in HTTP endpoints\n\n### Problem\n\n[Security advisory](https://github.com/dapr/dapr/security/advisories/GHSA-59m6-82qm-vqgj)\n\nA high-severity vulnerability has been found in Dapr that allows bypassing [API token authentication](https://docs.dapr.io/operations/security/api-token/), which is used by the Dapr sidecar to authenticate calls coming from the application, with a well-crafted HTTP request.\n\n### Impact\n\nThe vulnerability impacts all users on Dapr <=1.10.9 and <=1.11.2 who are using API token authentication.\n\n### Root cause\n\nThe Dapr sidecar allowed all requests containing `/healthz` in the URL (including query string) to bypass API token authentication.\n\n### Solution\n\nWe have changed the API token authentication middleware to allow bypassing the authentication only for healthcheck endpoints more strictly.\n\n## Security: Potential DoS in avro dependency (CVE-2023-37475)\n\n### Problem\n\n[CVE-2023-37475](https://github.com/hamba/avro/security/advisories/GHSA-9x44-9pgq-cf45)\n\nAn issue in the third-party avro dependency could cause a resource exhaustion and a DoS for Dapr.\n\n### Impact\n\nThis issue impacts users of Dapr that use the Pulsar components.\n\n### Root cause\n\nThe issue was in a third-party dependency.\n\n### Solution\n\nWe have upgraded the avro dependency to version 2.13.0 which contains a fix for the reported issue.\n\n## Fixed: unbounded history batch save in Workflows\n\n### Problem\n\nDue to a bug in the workflow engine, the full workflow history was saved on each checkpoint, rather than only the deltas. This resulted in two problems:\n\n- The I/O cost of saving workflow state increased over the lifetime of the workflow\n- Using state stores which have limits on transaction batch sizes, for example Azure Cosmos DB, caused workflows with more than a few actions to fail permanently\n\n### Impact\n\nThe issue impacts users of Dapr Workflow on Dapr 1.10 and higher.\n\n### Root cause\n\nThe problem was caused by a coding issue: an object was passed by reference rather than as a pointer.\n\n### Solution\n\nWe fixed the issue in the source code and added new tests to prevent regressions.\n\n## Fixed: Workflows not working in some Kubernetes clusters\n\n### Problem\n\nIn some Kubernetes clusters, the workflow engine may not have been able to process work items and tasks that were part of a workflow. Calls to the workflow engine would time out and fail.\n\n### Impact\n\nThe issue impacts users of Dapr Workflows which run the Dapr gRPC server listening on more than one address. This is the default behavior on Kubernetes, where Dapr normally listens on both `127.0.0.1` (IPv4) an `[::1]` (IPv6). The issue can appear also outside of Kubernetes if users run Dapr with multiple values for `--dapr-listen-addresses`.\n\n### Root cause\n\nA new instance of the workflow engine was attached to each Dapr gRPC listener independently. Depending on what protocol the application was using to connect to Dapr (IPv4 or IPv6), the request could hit a workflow engine that was not currently processing tasks, causing a deadlock.\n\n### Solution\n\nWe have changed the initialization code to ensure that Dapr uses a single instance of the workflow engine across all listeners.\n\n## Fixed a number of bugs in the gRPC Configuration Subscribe API\n\n### Problem\n\nWe identified a number of bugs, especially race conditions, in the gRPC implementation for the Configuration Subscribe API, which became stable in Dapr 1.11.0. These bugs could have caused the Subscribe API to behave unexpectedly.\n\n### Impact\n\nThe issue can impact users that are invoking the Configuration building block APIs using gRPC.\n\n### Root cause\n\nThe issues were traced back to a number of race conditions in the way the gRPC stream was handled.\n\n### Solution\n\nWe refactored the code to remove the race conditions and fix the bugs.\n", "/*\nCopyright 2021 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage http\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\tcors \"github.com/AdhityaRamadhanus/fasthttpcors\"\n\trouting \"github.com/fasthttp/router\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/valyala/fasthttp\"\n\t\"github.com/valyala/fasthttp/pprofhandler\"\n\n\t\"github.com/dapr/dapr/pkg/config\"\n\tcorsDapr \"github.com/dapr/dapr/pkg/cors\"\n\tdiag \"github.com/dapr/dapr/pkg/diagnostics\"\n\tdiagUtils \"github.com/dapr/dapr/pkg/diagnostics/utils\"\n\thttpMiddleware \"github.com/dapr/dapr/pkg/middleware/http\"\n\tauth \"github.com/dapr/dapr/pkg/runtime/security\"\n\tauthConsts \"github.com/dapr/dapr/pkg/runtime/security/consts\"\n\t\"github.com/dapr/dapr/utils/fasthttpadaptor\"\n\t\"github.com/dapr/dapr/utils/nethttpadaptor\"\n\t\"github.com/dapr/kit/logger\"\n)\n\nvar (\n\tlog     = logger.NewLogger(\"dapr.runtime.http\")\n\tinfoLog = logger.NewLogger(\"dapr.runtime.http-info\")\n)\n\n// Server is an interface for the Dapr HTTP server.\ntype Server interface {\n\tio.Closer\n\tStartNonBlocking() error\n}\n\ntype server struct {\n\tconfig             ServerConfig\n\ttracingSpec        config.TracingSpec\n\tmetricSpec         config.MetricSpec\n\tpipeline           httpMiddleware.Pipeline\n\tapi                API\n\tapiSpec            config.APISpec\n\tservers            []*fasthttp.Server\n\tprofilingListeners []net.Listener\n}\n\n// NewServerOpts are the options for NewServer.\ntype NewServerOpts struct {\n\tAPI         API\n\tConfig      ServerConfig\n\tTracingSpec config.TracingSpec\n\tMetricSpec  config.MetricSpec\n\tPipeline    httpMiddleware.Pipeline\n\tAPISpec     config.APISpec\n}\n\n// NewServer returns a new HTTP server.\nfunc NewServer(opts NewServerOpts) Server {\n\tinfoLog.SetOutputLevel(logger.LogLevel(\"info\"))\n\treturn &server{\n\t\tapi:         opts.API,\n\t\tconfig:      opts.Config,\n\t\ttracingSpec: opts.TracingSpec,\n\t\tmetricSpec:  opts.MetricSpec,\n\t\tpipeline:    opts.Pipeline,\n\t\tapiSpec:     opts.APISpec,\n\t}\n}\n\n// StartNonBlocking starts a new server in a goroutine.\nfunc (s *server) StartNonBlocking() error {\n\thandler := s.useRouter()\n\thandler = s.useComponents(handler)\n\thandler = s.useCors(handler)\n\thandler = useAPIAuthentication(handler)\n\thandler = s.useMetrics(handler)\n\thandler = s.useTracing(handler)\n\n\tvar listeners []net.Listener\n\tvar profilingListeners []net.Listener\n\tif s.config.UnixDomainSocket != \"\" {\n\t\tsocket := fmt.Sprintf(\"%s/dapr-%s-http.socket\", s.config.UnixDomainSocket, s.config.AppID)\n\t\tl, err := net.Listen(\"unix\", socket)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlog.Infof(\"HTTP server listening on UNIX socket: %s\", socket)\n\t\tlisteners = append(listeners, l)\n\t} else {\n\t\tfor _, apiListenAddress := range s.config.APIListenAddresses {\n\t\t\taddr := apiListenAddress + \":\" + strconv.Itoa(s.config.Port)\n\t\t\tl, err := net.Listen(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debugf(\"Failed to listen for HTTP server on TCP address %s with error: %v\", addr, err)\n\t\t\t} else {\n\t\t\t\tlog.Infof(\"HTTP server listening on TCP address: %s\", addr)\n\t\t\t\tlisteners = append(listeners, l)\n\t\t\t}\n\t\t}\n\t}\n\tif len(listeners) == 0 {\n\t\treturn errors.New(\"could not listen on any endpoint\")\n\t}\n\n\tfor _, listener := range listeners {\n\t\t// customServer is created in a loop because each instance\n\t\t// has a handle on the underlying listener.\n\t\tcustomServer := &fasthttp.Server{\n\t\t\tHandler:               handler,\n\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\tReadBufferSize:        s.config.ReadBufferSize * 1024,\n\t\t\tNoDefaultServerHeader: true,\n\t\t}\n\t\ts.servers = append(s.servers, customServer)\n\n\t\tgo func(l net.Listener) {\n\t\t\tif err := customServer.Serve(l); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}(listener)\n\t}\n\n\tif s.config.PublicPort != nil {\n\t\tpublicHandler := s.usePublicRouter()\n\t\tpublicHandler = s.useMetrics(publicHandler)\n\t\tpublicHandler = s.useTracing(publicHandler)\n\n\t\thealthServer := &fasthttp.Server{\n\t\t\tHandler:               publicHandler,\n\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\tNoDefaultServerHeader: true,\n\t\t}\n\t\ts.servers = append(s.servers, healthServer)\n\n\t\tgo func() {\n\t\t\tif err := healthServer.ListenAndServe(fmt.Sprintf(\":%d\", *s.config.PublicPort)); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif s.config.EnableProfiling {\n\t\tfor _, apiListenAddress := range s.config.APIListenAddresses {\n\t\t\taddr := apiListenAddress + \":\" + strconv.Itoa(s.config.ProfilePort)\n\t\t\tpl, err := net.Listen(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debugf(\"Failed to listen for profiling server on TCP address %s with error: %v\", addr, err)\n\t\t\t} else {\n\t\t\t\tlog.Infof(\"HTTP profiling server listening on: %s\", addr)\n\t\t\t\tprofilingListeners = append(profilingListeners, pl)\n\t\t\t}\n\t\t}\n\n\t\tif len(profilingListeners) == 0 {\n\t\t\treturn errors.New(\"could not listen on any endpoint for profiling API\")\n\t\t}\n\n\t\ts.profilingListeners = profilingListeners\n\t\tfor _, listener := range profilingListeners {\n\t\t\t// profServer is created in a loop because each instance\n\t\t\t// has a handle on the underlying listener.\n\t\t\tprofServer := &fasthttp.Server{\n\t\t\t\tHandler:               pprofhandler.PprofHandler,\n\t\t\t\tMaxRequestBodySize:    s.config.MaxRequestBodySize * 1024 * 1024,\n\t\t\t\tNoDefaultServerHeader: true,\n\t\t\t}\n\t\t\ts.servers = append(s.servers, profServer)\n\n\t\t\tgo func(l net.Listener) {\n\t\t\t\tif err := profServer.Serve(l); err != nil {\n\t\t\t\t\tlog.Fatal(err)\n\t\t\t\t}\n\t\t\t}(listener)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *server) Close() error {\n\tvar merr error\n\n\tfor _, ln := range s.servers {\n\t\t// This calls `Close()` on the underlying listener.\n\t\tif err := ln.Shutdown(); err != nil {\n\t\t\tmerr = multierror.Append(merr, err)\n\t\t}\n\t}\n\n\treturn merr\n}\n\nfunc (s *server) useTracing(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif diagUtils.IsTracingEnabled(s.tracingSpec.SamplingRate) {\n\t\tlog.Infof(\"enabled tracing http middleware\")\n\t\treturn diag.HTTPTraceMiddleware(next, s.config.AppID, s.tracingSpec)\n\t}\n\treturn next\n}\n\nfunc (s *server) useMetrics(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif s.metricSpec.Enabled {\n\t\tlog.Infof(\"enabled metrics http middleware\")\n\n\t\treturn diag.DefaultHTTPMonitoring.FastHTTPMiddleware(next)\n\t}\n\n\treturn next\n}\n\nfunc (s *server) apiLoggingInfo(route string, next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tfields := make(map[string]any, 2)\n\t\tif s.config.APILoggingObfuscateURLs {\n\t\t\tfields[\"method\"] = string(ctx.Method()) + \" \" + route\n\t\t} else {\n\t\t\tfields[\"method\"] = string(ctx.Method()) + \" \" + string(ctx.Path())\n\t\t}\n\t\tif userAgent := string(ctx.Request.Header.Peek(\"User-Agent\")); userAgent != \"\" {\n\t\t\tfields[\"useragent\"] = userAgent\n\t\t}\n\n\t\tinfoLog.WithFields(fields).Info(\"HTTP API Called\")\n\t\tnext(ctx)\n\t}\n}\n\nfunc (s *server) useRouter() fasthttp.RequestHandler {\n\tendpoints := s.api.APIEndpoints()\n\trouter := s.getRouter(endpoints)\n\n\treturn router.Handler\n}\n\nfunc (s *server) usePublicRouter() fasthttp.RequestHandler {\n\tendpoints := s.api.PublicEndpoints()\n\trouter := s.getRouter(endpoints)\n\n\treturn router.Handler\n}\n\nfunc (s *server) useComponents(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn fasthttpadaptor.NewFastHTTPHandler(\n\t\ts.pipeline.Apply(\n\t\t\tnethttpadaptor.NewNetHTTPHandlerFunc(next),\n\t\t),\n\t)\n}\n\nfunc (s *server) useCors(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\tif s.config.AllowedOrigins == corsDapr.DefaultAllowedOrigins {\n\t\treturn next\n\t}\n\n\tlog.Infof(\"enabled cors http middleware\")\n\torigins := strings.Split(s.config.AllowedOrigins, \",\")\n\tcorsHandler := s.getCorsHandler(origins)\n\treturn corsHandler.CorsMiddleware(next)\n}\n\nfunc useAPIAuthentication(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\ttoken := auth.GetAPIToken()\n\tif token == \"\" {\n\t\treturn next\n\t}\n\tlog.Info(\"enabled token authentication on http server\")\n\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tv := ctx.Request.Header.Peek(authConsts.APITokenHeader)\n\t\tif string(v) != token && !isRouteExcludedFromAPITokenAuth(string(ctx.Request.Header.Method()), string(ctx.Request.URI().FullURI())) {\n\t\t\tctx.Error(\"invalid api token\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tctx.Request.Header.Del(authConsts.APITokenHeader)\n\t\tnext(ctx)\n\t}\n}\n\nfunc isRouteExcludedFromAPITokenAuth(method string, urlString string) bool {\n\tu, err := url.Parse(urlString)\n\tif err != nil {\n\t\treturn false\n\t}\n\tpath := strings.Trim(u.Path, \"/\")\n\tswitch path {\n\tcase apiVersionV1 + \"/healthz\":\n\t\treturn method == http.MethodGet\n\tcase apiVersionV1 + \"/healthz/outbound\":\n\t\treturn method == http.MethodGet\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (s *server) getCorsHandler(allowedOrigins []string) *cors.CorsHandler {\n\treturn cors.NewCorsHandler(cors.Options{\n\t\tAllowedOrigins: allowedOrigins,\n\t\tDebug:          false,\n\t})\n}\n\nfunc (s *server) unescapeRequestParametersHandler(next fasthttp.RequestHandler) fasthttp.RequestHandler {\n\treturn func(ctx *fasthttp.RequestCtx) {\n\t\tparseError := false\n\t\tunescapeRequestParameters := func(parameter []byte, valI interface{}) {\n\t\t\tvalue, ok := valI.(string)\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !parseError {\n\t\t\t\tparameterUnescapedValue, err := url.QueryUnescape(value)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctx.SetUserValueBytes(parameter, parameterUnescapedValue)\n\t\t\t\t} else {\n\t\t\t\t\tparseError = true\n\t\t\t\t\terrorMessage := fmt.Sprintf(\"Failed to unescape request parameter %s with value %s. Error: %s\", parameter, value, err.Error())\n\t\t\t\t\tlog.Debug(errorMessage)\n\t\t\t\t\tctx.Error(errorMessage, fasthttp.StatusBadRequest)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx.VisitUserValues(unescapeRequestParameters)\n\n\t\tif !parseError {\n\t\t\tnext(ctx)\n\t\t}\n\t}\n}\n\nfunc (s *server) getRouter(endpoints []Endpoint) *routing.Router {\n\trouter := routing.New()\n\tparameterFinder, _ := regexp.Compile(\"/{.*}\")\n\n\t// Build the API allowlist and denylist\n\tallowedAPIs := s.apiSpec.Allowed.GetRulesByProtocol(config.APIAccessRuleProtocolHTTP)\n\tdeniedAPIs := s.apiSpec.Denied.GetRulesByProtocol(config.APIAccessRuleProtocolHTTP)\n\n\tfor _, e := range endpoints {\n\t\tif !e.IsAllowed(allowedAPIs, deniedAPIs) {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.handle(e, parameterFinder, \"/\"+e.Version+\"/\"+e.Route, router)\n\n\t\tif e.Alias != \"\" {\n\t\t\ts.handle(e, parameterFinder, \"/\"+e.Alias, router)\n\t\t}\n\t}\n\n\treturn router\n}\n\nfunc (s *server) handle(e Endpoint, parameterFinder *regexp.Regexp, path string, router *routing.Router) {\n\tpathIncludesParameters := parameterFinder.MatchString(path)\n\n\tfor _, m := range e.Methods {\n\t\thandler := e.Handler\n\n\t\tif pathIncludesParameters && !e.KeepParamUnescape {\n\t\t\thandler = s.unescapeRequestParametersHandler(handler)\n\t\t}\n\n\t\tif s.config.EnableAPILogging && (!e.IsHealthCheck || s.config.APILogHealthChecks) {\n\t\t\thandler = s.apiLoggingInfo(path, handler)\n\t\t}\n\n\t\trouter.Handle(m, path, handler)\n\t}\n}\n", "/*\nCopyright 2022 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage security\n\nimport (\n\t\"os\"\n\n\t\"github.com/dapr/dapr/pkg/runtime/security/consts\"\n)\n\n// GetAPIToken returns the value of the api token from an environment variable.\nfunc GetAPIToken() string {\n\treturn os.Getenv(consts.APITokenEnvVar)\n}\n\n// GetAppToken returns the value of the app api token from an environment variable.\nfunc GetAppToken() string {\n\treturn os.Getenv(consts.AppAPITokenEnvVar)\n}\n", "/*\nCopyright 2022 The Dapr Authors\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n\thttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage security\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/dapr/dapr/pkg/runtime/security/consts\"\n)\n\nfunc TestAPIToken(t *testing.T) {\n\tt.Run(\"existing token\", func(t *testing.T) {\n\t\t/* #nosec */\n\t\ttoken := \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4\"\n\t\tt.Setenv(consts.APITokenEnvVar, token)\n\n\t\tapitoken := GetAPIToken()\n\t\tassert.Equal(t, token, apitoken)\n\t})\n\n\tt.Run(\"non-existent token\", func(t *testing.T) {\n\t\ttoken := GetAPIToken()\n\t\tassert.Equal(t, \"\", token)\n\t})\n}\n\nfunc TestAppToken(t *testing.T) {\n\tt.Run(\"existing token\", func(t *testing.T) {\n\t\t/* #nosec */\n\t\ttoken := \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE1OTA1NTQ1NzMsImV4cCI6MTYyMjA5MDU3MywiYXVkIjoid3d3LmV4YW1wbGUuY29tIiwic3ViIjoianJvY2tldEBleGFtcGxlLmNvbSIsIkdpdmVuTmFtZSI6IkpvaG5ueSIsIlN1cm5hbWUiOiJSb2NrZXQiLCJFbWFpbCI6Impyb2NrZXRAZXhhbXBsZS5jb20iLCJSb2xlIjpbIk1hbmFnZXIiLCJQcm9qZWN0IEFkbWluaXN0cmF0b3IiXX0.QLFl8ZqC48DOsT7SmXA794nivmqGgylzjrUu6JhXPW4\"\n\t\tt.Setenv(consts.AppAPITokenEnvVar, token)\n\n\t\tapitoken := GetAppToken()\n\t\tassert.Equal(t, token, apitoken)\n\t})\n\n\tt.Run(\"non-existent token\", func(t *testing.T) {\n\t\ttoken := GetAppToken()\n\t\tassert.Equal(t, \"\", token)\n\t})\n}\n"], "filenames": ["docs/release_notes/v1.11.2.md", "pkg/http/server.go", "pkg/runtime/security/token.go", "pkg/runtime/security/token_test.go"], "buggy_code_start_loc": [5, 290, 18, 57], "buggy_code_end_loc": [11, 296, 44, 71], "fixing_code_start_loc": [5, 290, 17, 56], "fixing_code_end_loc": [33, 313, 30, 56], "type": "CWE-287", "message": "Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge. A vulnerability has been found in Dapr that allows bypassing API token authentication, which is used by the Dapr sidecar to authenticate calls coming from the application, with a well-crafted HTTP request. Users who leverage API token authentication are encouraged to upgrade Dapr to 1.10.9 or to 1.11.2. This vulnerability impacts Dapr users who have configured API token authentication. An attacker could craft a request that is always allowed by the Dapr sidecar over HTTP, even if the `dapr-api-token` in the request is invalid or missing. The issue has been fixed in Dapr 1.10.9 or to 1.11.2. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-37918", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-21T21:15:11.657", "lastModified": "2023-07-31T17:30:24.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Dapr is a portable, event-driven, runtime for building distributed applications across cloud and edge. A vulnerability has been found in Dapr that allows bypassing API token authentication, which is used by the Dapr sidecar to authenticate calls coming from the application, with a well-crafted HTTP request. Users who leverage API token authentication are encouraged to upgrade Dapr to 1.10.9 or to 1.11.2. This vulnerability impacts Dapr users who have configured API token authentication. An attacker could craft a request that is always allowed by the Dapr sidecar over HTTP, even if the `dapr-api-token` in the request is invalid or missing. The issue has been fixed in Dapr 1.10.9 or to 1.11.2. There are no known workarounds for this vulnerability.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dapr:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.9", "matchCriteriaId": "B132174A-53F6-44DE-9E4D-0EFA56B77D7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:dapr:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.0", "versionEndExcluding": "1.11.2", "matchCriteriaId": "DD6E2E5B-FB46-4726-B10F-6FDE8F949D37"}]}]}], "references": [{"url": "https://docs.dapr.io/operations/security/api-token/", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/dapr/dapr/commit/83ca1abb11ffe34211db55dcd36d96b94252827a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/dapr/dapr/security/advisories/GHSA-59m6-82qm-vqgj", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/dapr/dapr/commit/83ca1abb11ffe34211db55dcd36d96b94252827a"}}