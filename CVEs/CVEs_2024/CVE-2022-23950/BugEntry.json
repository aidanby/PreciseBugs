{"buggy_code": ["'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nfrom multiprocessing import Process\nimport threading\nimport functools\nimport time\nimport os\nimport sys\n\nimport requests\nimport zmq\n\nfrom keylime import config\nfrom keylime import crypto\nfrom keylime import json\nfrom keylime import keylime_logging\nfrom keylime import secure_mount\n\n\nlogger = keylime_logging.init_logging('revocation_notifier')\nbroker_proc = None\n\n\ndef start_broker():\n    def worker():\n        context = zmq.Context(1)\n        frontend = context.socket(zmq.SUB)\n        frontend.bind(\"ipc:///tmp/keylime.verifier.ipc\")\n\n        frontend.setsockopt(zmq.SUBSCRIBE, b'')\n\n        # Socket facing services\n        backend = context.socket(zmq.PUB)\n        backend.bind(\n            f\"tcp://{config.get('cloud_verifier', 'revocation_notifier_ip')}:\"\n            f\"{config.getint('cloud_verifier', 'revocation_notifier_port')}\"\n        )\n        try:\n            zmq.device(zmq.FORWARDER, frontend, backend)\n        except (KeyboardInterrupt, SystemExit):\n            context.destroy()\n\n    global broker_proc\n    broker_proc = Process(target=worker)\n    broker_proc.start()\n\n\ndef stop_broker():\n    global broker_proc\n    if broker_proc is not None:\n        # Remove the socket file before  we kill the process\n        if os.path.exists(\"/tmp/keylime.verifier.ipc\"):\n            os.remove(\"/tmp/keylime.verifier.ipc\")\n        logger.info(\"Stopping revocation notifier...\")\n        broker_proc.terminate()\n        broker_proc.join()\n\n\ndef notify(tosend):\n    def worker(tosend):\n        context = zmq.Context()\n        mysock = context.socket(zmq.PUB)\n        mysock.connect(\"ipc:///tmp/keylime.verifier.ipc\")\n        # wait 100ms for connect to happen\n        time.sleep(0.2)\n        # now send it out via 0mq\n        logger.info(\"Sending revocation event to listening nodes...\")\n        for i in range(config.getint('cloud_verifier', 'max_retries')):\n            try:\n                mysock.send_string(json.dumps(tosend))\n                break\n            except Exception as e:\n                logger.debug(\"Unable to publish revocation message %d times, trying again in %f seconds: %s\" % (\n                    i, config.getfloat('cloud_verifier', 'retry_interval'), e))\n                time.sleep(config.getfloat('cloud_verifier', 'retry_interval'))\n        mysock.close()\n\n    cb = functools.partial(worker, tosend)\n    t = threading.Thread(target=cb)\n    t.start()\n\n\ndef notify_webhook(tosend):\n    url = config.get('cloud_verifier', 'webhook_url', fallback='')\n    # Check if a url was specified\n    if url == '':\n        return\n\n    def worker_webhook(tosend, url):\n        retry_interval = config.getfloat('cloud_verifier', 'retry_interval')\n        session = requests.session()\n        logger.info(\"Sending revocation event via webhook...\")\n        for i in range(config.getint('cloud_verifier', 'max_retries')):\n            try:\n                response = session.post(url, json=tosend)\n                if response.status_code in [200, 202]:\n                    break\n\n                logger.debug(f\"Unable to publish revocation message {i} times via webhook, \"\n                             f\"trying again in {retry_interval} seconds. \"\n                             f\"Server returned status code: {response.status_code}\")\n            except requests.exceptions.RequestException as e:\n                logger.debug(f\"Unable to publish revocation message {i} times via webhook, \"\n                             f\"trying again in {retry_interval} seconds: {e} \")\n\n            time.sleep(retry_interval)\n\n    w = functools.partial(worker_webhook, tosend, url)\n    t = threading.Thread(target=w)\n    t.start()\n\n\ncert_key = None\n\n\ndef await_notifications(callback, revocation_cert_path):\n    global cert_key\n\n    if revocation_cert_path is None:\n        raise Exception(\"must specify revocation_cert_path\")\n\n    context = zmq.Context()\n    mysock = context.socket(zmq.SUB)\n    mysock.setsockopt(zmq.SUBSCRIBE, b'')\n    mysock.connect(\n        f\"tcp://{config.get('general', 'receive_revocation_ip')}:\"\n        f\"{config.getint('general', 'receive_revocation_port')}\"\n    )\n\n    logger.info('Waiting for revocation messages on 0mq %s:%s' %\n                (config.get('general', 'receive_revocation_ip'), config.getint('general', 'receive_revocation_port')))\n\n    while True:\n        rawbody = mysock.recv()\n        body = json.loads(rawbody)\n\n        if cert_key is None:\n            # load up the CV signing public key\n            if revocation_cert_path is not None and os.path.exists(revocation_cert_path):\n                logger.info(\n                    \"Lazy loading the revocation certificate from %s\" % revocation_cert_path)\n                with open(revocation_cert_path, \"rb\") as f:\n                    certpem = f.read()\n                cert_key = crypto.x509_import_pubkey(certpem)\n\n        if cert_key is None:\n            logger.warning(\n                \"Unable to check signature of revocation message: %s not available\" % revocation_cert_path)\n        elif 'signature' not in body or body['signature'] == 'none':\n            logger.warning(\"No signature on revocation message from server\")\n        elif not crypto.rsa_verify(cert_key, body['msg'].encode('utf-8'), body['signature'].encode('utf-8')):\n            logger.error(\"Invalid revocation message siganture %s\" % body)\n        else:\n            message = json.loads(body['msg'])\n            logger.debug(\n                \"Revocation signature validated for revocation: %s\" % message)\n            callback(message)\n\n\ndef main():\n    start_broker()\n\n    def worker():\n        def print_notification(revocation):\n            logger.warning(\"Received revocation: %s\" % revocation)\n\n        keypath = '%s/unzipped/RevocationNotifier-cert.crt' % (\n            secure_mount.mount())\n        await_notifications(print_notification, revocation_cert_path=keypath)\n\n    t = threading.Thread(target=worker)\n    t.start()\n    # time.sleep(0.5)\n\n    json_body2 = {\n        'v': 'vbaby',\n        'agent_id': '2094aqrea3',\n        'cloudagent_ip': 'ipaddy',\n        'cloudagent_port': '39843',\n        'tpm_policy': '{\"ab\":\"1\"}',\n        'vtpm_policy': '{\"ab\":\"1\"}',\n        'metadata': '{\"cert_serial\":\"1\"}',\n        'allowlist': '{}',\n        'ima_sign_verification_keys': '{}',\n        'revocation_key': '',\n        'revocation': '{\"cert_serial\":\"1\"}',\n    }\n\n    print(\"sending notification\")\n    notify(json_body2)\n\n    time.sleep(2)\n    print(\"shutting down\")\n    stop_broker()\n    print(\"exiting...\")\n    sys.exit(0)\n    print(\"done\")\n\n\nif __name__ == \"__main__\":\n    main()\n"], "fixing_code": ["'''\nSPDX-License-Identifier: Apache-2.0\nCopyright 2017 Massachusetts Institute of Technology.\n'''\n\nfrom multiprocessing import Process\nimport threading\nimport functools\nimport time\nimport os\nimport sys\n\nimport requests\nimport zmq\n\nfrom keylime import config\nfrom keylime import crypto\nfrom keylime import json\nfrom keylime import keylime_logging\nfrom keylime import secure_mount\n\n\nlogger = keylime_logging.init_logging('revocation_notifier')\nbroker_proc = None\n\n_SOCKET_PATH = \"/var/run/keylime/keylime.verifier.ipc\"\n\n\ndef start_broker():\n    def worker():\n        dir_name = os.path.dirname(_SOCKET_PATH)\n        if not os.path.exists(dir_name):\n            os.makedirs(dir_name, 0o700)\n        else:\n            if os.stat(_SOCKET_PATH).st_mode & 0o777 != 0o700:\n                msg = f\"{_SOCKET_PATH} present with wrong permissions\"\n                logger.error(msg)\n                raise Exception(msg)\n\n        context = zmq.Context(1)\n        frontend = context.socket(zmq.SUB)\n        frontend.bind(f\"ipc://{_SOCKET_PATH}\")\n\n        frontend.setsockopt(zmq.SUBSCRIBE, b'')\n\n        # Socket facing services\n        backend = context.socket(zmq.PUB)\n        backend.bind(\n            f\"tcp://{config.get('cloud_verifier', 'revocation_notifier_ip')}:\"\n            f\"{config.getint('cloud_verifier', 'revocation_notifier_port')}\"\n        )\n        try:\n            zmq.device(zmq.FORWARDER, frontend, backend)\n        except (KeyboardInterrupt, SystemExit):\n            context.destroy()\n\n    global broker_proc\n    broker_proc = Process(target=worker)\n    broker_proc.start()\n\n\ndef stop_broker():\n    global broker_proc\n    if broker_proc is not None:\n        # Remove the socket file before  we kill the process\n        if os.path.exists(f\"ipc://{_SOCKET_PATH}\"):\n            os.remove(f\"ipc://{_SOCKET_PATH}\")\n        logger.info(\"Stopping revocation notifier...\")\n        broker_proc.terminate()\n        broker_proc.join()\n\n\ndef notify(tosend):\n    def worker(tosend):\n        context = zmq.Context()\n        mysock = context.socket(zmq.PUB)\n        mysock.connect(f\"ipc://{_SOCKET_PATH}\")\n        # wait 100ms for connect to happen\n        time.sleep(0.2)\n        # now send it out via 0mq\n        logger.info(\"Sending revocation event to listening nodes...\")\n        for i in range(config.getint('cloud_verifier', 'max_retries')):\n            try:\n                mysock.send_string(json.dumps(tosend))\n                break\n            except Exception as e:\n                logger.debug(\"Unable to publish revocation message %d times, trying again in %f seconds: %s\" % (\n                    i, config.getfloat('cloud_verifier', 'retry_interval'), e))\n                time.sleep(config.getfloat('cloud_verifier', 'retry_interval'))\n        mysock.close()\n\n    cb = functools.partial(worker, tosend)\n    t = threading.Thread(target=cb)\n    t.start()\n\n\ndef notify_webhook(tosend):\n    url = config.get('cloud_verifier', 'webhook_url', fallback='')\n    # Check if a url was specified\n    if url == '':\n        return\n\n    def worker_webhook(tosend, url):\n        retry_interval = config.getfloat('cloud_verifier', 'retry_interval')\n        session = requests.session()\n        logger.info(\"Sending revocation event via webhook...\")\n        for i in range(config.getint('cloud_verifier', 'max_retries')):\n            try:\n                response = session.post(url, json=tosend)\n                if response.status_code in [200, 202]:\n                    break\n\n                logger.debug(f\"Unable to publish revocation message {i} times via webhook, \"\n                             f\"trying again in {retry_interval} seconds. \"\n                             f\"Server returned status code: {response.status_code}\")\n            except requests.exceptions.RequestException as e:\n                logger.debug(f\"Unable to publish revocation message {i} times via webhook, \"\n                             f\"trying again in {retry_interval} seconds: {e} \")\n\n            time.sleep(retry_interval)\n\n    w = functools.partial(worker_webhook, tosend, url)\n    t = threading.Thread(target=w)\n    t.start()\n\n\ncert_key = None\n\n\ndef await_notifications(callback, revocation_cert_path):\n    global cert_key\n\n    if revocation_cert_path is None:\n        raise Exception(\"must specify revocation_cert_path\")\n\n    context = zmq.Context()\n    mysock = context.socket(zmq.SUB)\n    mysock.setsockopt(zmq.SUBSCRIBE, b'')\n    mysock.connect(\n        f\"tcp://{config.get('general', 'receive_revocation_ip')}:\"\n        f\"{config.getint('general', 'receive_revocation_port')}\"\n    )\n\n    logger.info('Waiting for revocation messages on 0mq %s:%s' %\n                (config.get('general', 'receive_revocation_ip'), config.getint('general', 'receive_revocation_port')))\n\n    while True:\n        rawbody = mysock.recv()\n        body = json.loads(rawbody)\n\n        if cert_key is None:\n            # load up the CV signing public key\n            if revocation_cert_path is not None and os.path.exists(revocation_cert_path):\n                logger.info(\n                    \"Lazy loading the revocation certificate from %s\" % revocation_cert_path)\n                with open(revocation_cert_path, \"rb\") as f:\n                    certpem = f.read()\n                cert_key = crypto.x509_import_pubkey(certpem)\n\n        if cert_key is None:\n            logger.warning(\n                \"Unable to check signature of revocation message: %s not available\" % revocation_cert_path)\n        elif 'signature' not in body or body['signature'] == 'none':\n            logger.warning(\"No signature on revocation message from server\")\n        elif not crypto.rsa_verify(cert_key, body['msg'].encode('utf-8'), body['signature'].encode('utf-8')):\n            logger.error(\"Invalid revocation message siganture %s\" % body)\n        else:\n            message = json.loads(body['msg'])\n            logger.debug(\n                \"Revocation signature validated for revocation: %s\" % message)\n            callback(message)\n\n\ndef main():\n    start_broker()\n\n    def worker():\n        def print_notification(revocation):\n            logger.warning(\"Received revocation: %s\" % revocation)\n\n        keypath = '%s/unzipped/RevocationNotifier-cert.crt' % (\n            secure_mount.mount())\n        await_notifications(print_notification, revocation_cert_path=keypath)\n\n    t = threading.Thread(target=worker)\n    t.start()\n    # time.sleep(0.5)\n\n    json_body2 = {\n        'v': 'vbaby',\n        'agent_id': '2094aqrea3',\n        'cloudagent_ip': 'ipaddy',\n        'cloudagent_port': '39843',\n        'tpm_policy': '{\"ab\":\"1\"}',\n        'vtpm_policy': '{\"ab\":\"1\"}',\n        'metadata': '{\"cert_serial\":\"1\"}',\n        'allowlist': '{}',\n        'ima_sign_verification_keys': '{}',\n        'revocation_key': '',\n        'revocation': '{\"cert_serial\":\"1\"}',\n    }\n\n    print(\"sending notification\")\n    notify(json_body2)\n\n    time.sleep(2)\n    print(\"shutting down\")\n    stop_broker()\n    print(\"exiting...\")\n    sys.exit(0)\n    print(\"done\")\n\n\nif __name__ == \"__main__\":\n    main()\n"], "filenames": ["keylime/revocation_notifier.py"], "buggy_code_start_loc": [25], "buggy_code_end_loc": [67], "fixing_code_start_loc": [26], "fixing_code_end_loc": [78], "type": "CWE-668", "message": "In Keylime before 6.3.0, Revocation Notifier uses a fixed /tmp path for UNIX domain socket which can allow unprivileged users a method to prohibit keylime operations.", "other": {"cve": {"id": "CVE-2022-23950", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2022-09-21T19:15:10.120", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Keylime before 6.3.0, Revocation Notifier uses a fixed /tmp path for UNIX domain socket which can allow unprivileged users a method to prohibit keylime operations."}, {"lang": "es", "value": "En Keylime versiones anteriores a 6.3.0, el notificador de revocaci\u00f3n usa una ruta /tmp fija para el socket de dominio UNIX que puede permitir a usuarios no privilegiado un m\u00e9todo para prohibir las operaciones de Keylime"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-379"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:keylime:keylime:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.3.0", "matchCriteriaId": "8BF970A4-62CA-4D1A-BDCC-4E5C717AD6C5"}]}]}], "references": [{"url": "https://github.com/keylime/keylime/commit/ea5d0373fa2c050d5d95404eb779be7e8327b911", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keylime/keylime/security/advisories/GHSA-9r9r-f8xc-m875", "source": "patrick@puiterwijk.org", "tags": ["Third Party Advisory"]}, {"url": "https://seclists.org/oss-sec/2022/q1/101", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keylime/keylime/commit/ea5d0373fa2c050d5d95404eb779be7e8327b911"}}