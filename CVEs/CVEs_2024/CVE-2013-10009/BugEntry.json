{"buggy_code": ["# -*- coding: utf-8 -*-\nfrom pysqlite2 import dbapi2 as sqlite3\nimport os.path\n\nclass mod_fun(object):\n    def __init__(self,parent,config):\n        self.config = config\n        self.parent = parent\n        parent.register_callback(u'!snack', self.snack, 'Several small fuckups')\n        for key in config['items'].keys():\n            words = config['items'][key]\n            parent.register_callback('+%s'%key,self.factory('+',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n            parent.register_callback('-%s'%key,self.factory('-',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n            parent.register_callback('?%s'%key,self.factory('?',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n        #parent.register_callback('+keks',self.keks,u'Verschenke einen Keks!')\n        #parent.register_callback('-keks',self.klauen,u'Klaue jemanden einen Keks!')\n        #parent.register_callback('?keks',self.readkeks,u'Sieh nach wieviele Kekse jemand hat.')\n        \n        dbpath = os.path.join(os.path.dirname(__file__), config['dbpath']).replace('\\\\','/')\n        self.connectDB(dbpath)\n        \n    def factory(self, cmd, name, words):\n        if (cmd=='+'):\n            func = self.geben\n        elif (cmd=='-'):\n            func = self.klauen\n        else:\n            func = self.lesen\n        def rss_func(params):\n            func(params, name, words)\n        return rss_func\n\n    def connectDB(self, dbpath):\n        self.parent.print_notice(\"SQLite-Database: \"+dbpath)\n        self.DBconn = sqlite3.connect(dbpath)\n        self.DBcursor = self.DBconn.cursor()\n\n    def snack(self, params):\n        self.parent.privmsg(u':)', params.channel)\n\n    def geben(self, params, name, words):\n        if (self.check_name(params.args[0], params.channel)):\n            return\n        if len(params.args) == 1:\n            if params.target == params.args[0]:\n                keks = self.aendern(params.target, 0, name)\n                self.parent.privmsg(u'Sei nicht so selbsts\u00fcchtig! Du hast bereits %i %s.' % (keks, words['plural']), params.channel)\n                return\n            keks = self.aendern(params.args[0], 1, name)\n            self.parent.privmsg(u'%s hat jetzt %i %s.' % (params.args[0], keks, words['plural']), params.channel)\n        else:\n            self.parent.privmsg(u'hast du nicht was vergessen? (Du hast %i %s)' % (self.aendern(params.target, 0, name), words['plural']), params.channel)\n    \n    def klauen(self, params, name, words):\n        if (self.check_name(params.args[0], params.channel)):\n            return\n        if len(params.args) == 1:\n            if params.target == params.args[0]:\n                self.parent.privmsg(u'Du klaust dir selber 1 %s. Das war eine drastische \u00c4nderung. NICHT!' % words['singular'], params.channel)\n                return\n            keks = self.aendern(params.args[0], -1, name)\n            if (keks!=-999):\n                keks2 = self.aendern(params.target, 1, name)\n                if (keks == 0):\n                    self.parent.privmsg(u'Na toll, du hast %s allerletztes %s geklaut. Du hast jetzt %i %s.' % (params.args[0], words['singular'], keks2, words['plural']), params.channel)\n                else:\n                    self.parent.privmsg(u'Du klaust %s einen %s (hat jetzt %i). Du hast jetzt %i %s' % (params.args[0], words['singular'], keks, keks2, words['plural']), params.channel)\n            else:\n                self.parent.privmsg(u'Geht nicht!', params.channel)\n        else:\n            self.parent.privmsg(u'hast du nicht was vergessen?', params.channel)\n    \n    def aendern(self, name, amount, item):\n        keks = self.DBcursor.execute(u\"SELECT nickname, count from kekse WHERE nickname like '%s' AND item =='%s' LIMIT 1\" % (name, item)).fetchall()\n        if(len(keks)>0 and len(keks[0]) > 1):\n            keks = keks[0][1]\n            if amount == 0:\n                return keks\n            keks2 = keks+amount\n            if (keks2 >= 1):\n                self.DBcursor.execute(u\"UPDATE kekse set count=? WHERE item==? AND nickname like ?\", (keks2, item, name))\n                self.DBconn.commit()\n                return keks2\n            else:\n                self.DBcursor.execute(u\"UPDATE kekse set count=? WHERE nickname like ? AND item==?\", (0, name, item))\n                self.DBconn.commit()\n                if keks>0:\n                    return 0\n                return -999\n        else:\n            if (amount >= 0):\n                self.DBcursor.execute(u\"INSERT INTO kekse (nickname, count, item) VALUES (?, ?, ?)\", (name, amount, item))\n                self.DBconn.commit()\n                return amount\n            else:\n                return -999;\n    \n    def lesen(self, params, name, words):\n        if len(params.args) == 1:\n            keks = 0\n            anrede = u\"Du hast\"\n            if params.args[0]==params.target:\n                keks = self.aendern(params.target, 0, name)\n            else:\n                keks = self.aendern(params.args[0],0, name)\n                anrede=u\"%s hat\" % params.args[0]\n            self.parent.privmsg(u\"%s %i %s.\" % (anrede, keks, words['plural']), params.channel)\n        elif len(params.args) == 0:\n            keks = self.DBcursor.execute(u\"SELECT `nickname`, `count` from kekse WHERE item=='%s' AND `count`>=1 ORDER BY `count` DESC LIMIT 10\" % (name)).fetchall()\n            if len(keks) <= 0:\n                self.parent.privmsg(u\"Es gibt noch keine %s?\" % words['plural'], params.channel)\n                return\n            kekst = u\"[Top-%s-Sammler] \" % words['singular']\n            first = True\n            for keksi in keks:\n                if len(keksi) > 1:\n                    if first:\n                        kekst += u\"%s hat %i\" % keksi\n                        first = False\n                    else:\n                        kekst += u\", %s hat %i\" %keksi\n            self.parent.privmsg(kekst, params.channel)\n        else:\n            self.parent.privmsg(u\"Ich hab keine Ahnung was du mir damit sagen willst...\", params.channel)\n            return\n\n    def check_name(self, target, channel):\n        valid_names = self.parent.channels[channel]\n        invalid = target not in valid_names\n        if (invalid):\n            self.parent.privmsg(u'%s ist gar nicht hier...' % target, channel)\n        return invalid"], "fixing_code": ["# -*- coding: utf-8 -*-\nfrom pysqlite2 import dbapi2 as sqlite3\nimport os.path\n\nclass mod_fun(object):\n    def __init__(self,parent,config):\n        self.config = config\n        self.parent = parent\n        parent.register_callback(u'!snack', self.snack, 'Several small fuckups')\n        for key in config['items'].keys():\n            words = config['items'][key]\n            parent.register_callback('+%s'%key,self.factory('+',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n            parent.register_callback('-%s'%key,self.factory('-',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n            parent.register_callback('?%s'%key,self.factory('?',key, words),config['help']+\" (%s verweist auf %s)\" % (key, config['items'][key]))\n        #parent.register_callback('+keks',self.keks,u'Verschenke einen Keks!')\n        #parent.register_callback('-keks',self.klauen,u'Klaue jemanden einen Keks!')\n        #parent.register_callback('?keks',self.readkeks,u'Sieh nach wieviele Kekse jemand hat.')\n        \n        dbpath = os.path.join(os.path.dirname(__file__), config['dbpath']).replace('\\\\','/')\n        self.connectDB(dbpath)\n        \n    def factory(self, cmd, name, words):\n        if (cmd=='+'):\n            func = self.geben\n        elif (cmd=='-'):\n            func = self.klauen\n        else:\n            func = self.lesen\n        def rss_func(params):\n            func(params, name, words)\n        return rss_func\n\n    def connectDB(self, dbpath):\n        self.parent.print_notice(\"SQLite-Database: \"+dbpath)\n        self.DBconn = sqlite3.connect(dbpath)\n        self.DBcursor = self.DBconn.cursor()\n\n    def snack(self, params):\n        self.parent.privmsg(u':)', params.channel)\n\n    def geben(self, params, name, words):\n        if (self.check_name(params.args[0], params.channel)):\n            return\n        if len(params.args) == 1:\n            if params.target == params.args[0]:\n                keks = self.aendern(params.target, 0, name)\n                self.parent.privmsg(u'Sei nicht so selbsts\u00fcchtig! Du hast bereits %i %s.' % (keks, words['plural']), params.channel)\n                return\n            keks = self.aendern(params.args[0], 1, name)\n            self.parent.privmsg(u'%s hat jetzt %i %s.' % (params.args[0], keks, words['plural']), params.channel)\n        else:\n            self.parent.privmsg(u'hast du nicht was vergessen? (Du hast %i %s)' % (self.aendern(params.target, 0, name), words['plural']), params.channel)\n    \n    def klauen(self, params, name, words):\n        if (self.check_name(params.args[0], params.channel)):\n            return\n        if len(params.args) == 1:\n            if params.target == params.args[0]:\n                self.parent.privmsg(u'Du klaust dir selber 1 %s. Das war eine drastische \u00c4nderung. NICHT!' % words['singular'], params.channel)\n                return\n            keks = self.aendern(params.args[0], -1, name)\n            if (keks!=-999):\n                keks2 = self.aendern(params.target, 1, name)\n                if (keks == 0):\n                    self.parent.privmsg(u'Na toll, du hast %s allerletztes %s geklaut. Du hast jetzt %i %s.' % (params.args[0], words['singular'], keks2, words['plural']), params.channel)\n                else:\n                    self.parent.privmsg(u'Du klaust %s einen %s (hat jetzt %i). Du hast jetzt %i %s' % (params.args[0], words['singular'], keks, keks2, words['plural']), params.channel)\n            else:\n                self.parent.privmsg(u'Geht nicht!', params.channel)\n        else:\n            self.parent.privmsg(u'hast du nicht was vergessen?', params.channel)\n    \n    def aendern(self, name, amount, item):\n        keks = self.DBcursor.execute(u\"SELECT nickname, count from kekse WHERE nickname like ? AND item ==? LIMIT 1\", (name, item)).fetchall()\n        if(len(keks)>0 and len(keks[0]) > 1):\n            keks = keks[0][1]\n            if amount == 0:\n                return keks\n            keks2 = keks+amount\n            if (keks2 >= 1):\n                self.DBcursor.execute(u\"UPDATE kekse set count=? WHERE item==? AND nickname like ?\", (keks2, item, name))\n                self.DBconn.commit()\n                return keks2\n            else:\n                self.DBcursor.execute(u\"UPDATE kekse set count=? WHERE nickname like ? AND item==?\", (0, name, item))\n                self.DBconn.commit()\n                if keks>0:\n                    return 0\n                return -999\n        else:\n            if (amount >= 0):\n                self.DBcursor.execute(u\"INSERT INTO kekse (nickname, count, item) VALUES (?, ?, ?)\", (name, amount, item))\n                self.DBconn.commit()\n                return amount\n            else:\n                return -999;\n    \n    def lesen(self, params, name, words):\n        if len(params.args) == 1:\n            keks = 0\n            anrede = u\"Du hast\"\n            if params.args[0]==params.target:\n                keks = self.aendern(params.target, 0, name)\n            else:\n                keks = self.aendern(params.args[0],0, name)\n                anrede=u\"%s hat\" % params.args[0]\n            self.parent.privmsg(u\"%s %i %s.\" % (anrede, keks, words['plural']), params.channel)\n        elif len(params.args) == 0:\n            keks = self.DBcursor.execute(u\"SELECT `nickname`, `count` from kekse WHERE item==? AND `count`>=1 ORDER BY `count` DESC LIMIT 10\", (name)).fetchall()\n            if len(keks) <= 0:\n                self.parent.privmsg(u\"Es gibt noch keine %s?\" % words['plural'], params.channel)\n                return\n            kekst = u\"[Top-%s-Sammler] \" % words['singular']\n            first = True\n            for keksi in keks:\n                if len(keksi) > 1:\n                    if first:\n                        kekst += u\"%s hat %i\" % keksi\n                        first = False\n                    else:\n                        kekst += u\", %s hat %i\" %keksi\n            self.parent.privmsg(kekst, params.channel)\n        else:\n            self.parent.privmsg(u\"Ich hab keine Ahnung was du mir damit sagen willst...\", params.channel)\n            return\n\n    def check_name(self, target, channel):\n        valid_names = self.parent.channels[channel]\n        invalid = target not in valid_names\n        if (invalid):\n            self.parent.privmsg(u'%s ist gar nicht hier...' % target, channel)\n        return invalid"], "filenames": ["mod_fun/__init__.py"], "buggy_code_start_loc": [74], "buggy_code_end_loc": [110], "fixing_code_start_loc": [74], "fixing_code_end_loc": [110], "type": "CWE-89", "message": "A vulnerability was found in DrAzraelTod pyChao and classified as critical. Affected by this issue is the function klauen/lesen of the file mod_fun/__init__.py. The manipulation leads to sql injection. The name of the patch is 9d8adbc07c384ba51c2583ce0819c9abb77dc648. It is recommended to apply a patch to fix this issue. VDB-217634 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2013-10009", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-07T20:15:08.887", "lastModified": "2023-01-12T18:30:04.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in DrAzraelTod pyChao and classified as critical. Affected by this issue is the function klauen/lesen of the file mod_fun/__init__.py. The manipulation leads to sql injection. The name of the patch is 9d8adbc07c384ba51c2583ce0819c9abb77dc648. It is recommended to apply a patch to fix this issue. VDB-217634 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pychao_project:pychao:*:*:*:*:*:*:*:*", "versionEndExcluding": "2013-11-03", "matchCriteriaId": "C5014CC5-59D5-41D5-958B-EFBF6F5E578A"}]}]}], "references": [{"url": "https://github.com/DrAzraelTod/pyChao/commit/9d8adbc07c384ba51c2583ce0819c9abb77dc648", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DrAzraelTod/pyChao/pull/1", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217634", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217634", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DrAzraelTod/pyChao/commit/9d8adbc07c384ba51c2583ce0819c9abb77dc648"}}