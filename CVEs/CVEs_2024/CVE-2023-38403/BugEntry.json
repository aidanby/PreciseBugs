{"buggy_code": ["/*\n * iperf, Copyright (c) 2014-2022, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE file\n * for complete information.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#define __USE_GNU\n\n#include \"iperf_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <getopt.h>\n#include <errno.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <stdarg.h>\n#include <math.h>\n\n#if defined(HAVE_CPUSET_SETAFFINITY)\n#include <sys/param.h>\n#include <sys/cpuset.h>\n#endif /* HAVE_CPUSET_SETAFFINITY */\n\n#if defined(__CYGWIN__) || defined(_WIN32) || defined(_WIN64) || defined(__WINDOWS__)\n#define CPU_SETSIZE __CPU_SETSIZE\n#endif /* __CYGWIN__, _WIN32, _WIN64, __WINDOWS__ */\n\n#if defined(HAVE_SETPROCESSAFFINITYMASK)\n#include <Windows.h>\n#endif /* HAVE_SETPROCESSAFFINITYMASK */\n\n#include \"net.h\"\n#include \"iperf.h\"\n#include \"iperf_api.h\"\n#include \"iperf_udp.h\"\n#include \"iperf_tcp.h\"\n#if defined(HAVE_SCTP_H)\n#include \"iperf_sctp.h\"\n#endif /* HAVE_SCTP_H */\n#include \"timer.h\"\n\n#include \"cjson.h\"\n#include \"units.h\"\n#include \"iperf_util.h\"\n#include \"iperf_locale.h\"\n#include \"version.h\"\n#if defined(HAVE_SSL)\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include \"iperf_auth.h\"\n#endif /* HAVE_SSL */\n\n/* Forwards. */\nstatic int send_parameters(struct iperf_test *test);\nstatic int get_parameters(struct iperf_test *test);\nstatic int send_results(struct iperf_test *test);\nstatic int get_results(struct iperf_test *test);\nstatic int diskfile_send(struct iperf_stream *sp);\nstatic int diskfile_recv(struct iperf_stream *sp);\nstatic int JSON_write(int fd, cJSON *json);\nstatic void print_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams);\nstatic cJSON *JSON_read(int fd);\n\n\n/*************************** Print usage functions ****************************/\n\nvoid\nusage()\n{\n    fputs(usage_shortstr, stderr);\n}\n\n\nvoid\nusage_long(FILE *f)\n{\n    fprintf(f, usage_longstr, DEFAULT_NO_MSG_RCVD_TIMEOUT, UDP_RATE / (1024*1024), DEFAULT_PACING_TIMER, DURATION, DEFAULT_TCP_BLKSIZE / 1024, DEFAULT_UDP_BLKSIZE);\n}\n\n\nvoid warning(const char *str)\n{\n    fprintf(stderr, \"warning: %s\\n\", str);\n}\n\n\n/************** Getter routines for some fields inside iperf_test *************/\n\nint\niperf_get_verbose(struct iperf_test *ipt)\n{\n    return ipt->verbose;\n}\n\nint\niperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}\n\nint\niperf_get_control_socket_mss(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck_mss;\n}\n\nint\niperf_get_test_omit(struct iperf_test *ipt)\n{\n    return ipt->omit;\n}\n\nint\niperf_get_test_duration(struct iperf_test *ipt)\n{\n    return ipt->duration;\n}\n\nuint64_t\niperf_get_test_rate(struct iperf_test *ipt)\n{\n    return ipt->settings->rate;\n}\n\nuint64_t\niperf_get_test_bitrate_limit(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit;\n}\n\ndouble\niperf_get_test_bitrate_limit_interval(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit_interval;\n}\n\nint\niperf_get_test_bitrate_limit_stats_per_interval(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit_stats_per_interval;\n}\n\nuint64_t\niperf_get_test_fqrate(struct iperf_test *ipt)\n{\n    return ipt->settings->fqrate;\n}\n\nint\niperf_get_test_pacing_timer(struct iperf_test *ipt)\n{\n    return ipt->settings->pacing_timer;\n}\n\nuint64_t\niperf_get_test_bytes(struct iperf_test *ipt)\n{\n    return (uint64_t) ipt->settings->bytes;\n}\n\nuint64_t\niperf_get_test_blocks(struct iperf_test *ipt)\n{\n    return (uint64_t) ipt->settings->blocks;\n}\n\nint\niperf_get_test_burst(struct iperf_test *ipt)\n{\n    return ipt->settings->burst;\n}\n\nchar\niperf_get_test_role(struct iperf_test *ipt)\n{\n    return ipt->role;\n}\n\nint\niperf_get_test_reverse(struct iperf_test *ipt)\n{\n    return ipt->reverse;\n}\n\nint\niperf_get_test_bidirectional(struct iperf_test *ipt)\n{\n    return ipt->bidirectional;\n}\n\nint\niperf_get_test_blksize(struct iperf_test *ipt)\n{\n    return ipt->settings->blksize;\n}\n\nFILE *\niperf_get_test_outfile (struct iperf_test *ipt)\n{\n    return ipt->outfile;\n}\n\nint\niperf_get_test_socket_bufsize(struct iperf_test *ipt)\n{\n    return ipt->settings->socket_bufsize;\n}\n\ndouble\niperf_get_test_reporter_interval(struct iperf_test *ipt)\n{\n    return ipt->reporter_interval;\n}\n\ndouble\niperf_get_test_stats_interval(struct iperf_test *ipt)\n{\n    return ipt->stats_interval;\n}\n\nint\niperf_get_test_num_streams(struct iperf_test *ipt)\n{\n    return ipt->num_streams;\n}\n\nint\niperf_get_test_timestamps(struct iperf_test *ipt)\n{\n    return ipt->timestamps;\n}\n\nconst char *\niperf_get_test_timestamp_format(struct iperf_test *ipt)\n{\n    return ipt->timestamp_format;\n}\n\nint\niperf_get_test_repeating_payload(struct iperf_test *ipt)\n{\n    return ipt->repeating_payload;\n}\n\nint\niperf_get_test_bind_port(struct iperf_test *ipt)\n{\n    return ipt->bind_port;\n}\n\nint\niperf_get_test_server_port(struct iperf_test *ipt)\n{\n    return ipt->server_port;\n}\n\nchar*\niperf_get_test_server_hostname(struct iperf_test *ipt)\n{\n    return ipt->server_hostname;\n}\n\nchar*\niperf_get_test_template(struct iperf_test *ipt)\n{\n    return ipt->tmp_template;\n}\n\nint\niperf_get_test_protocol_id(struct iperf_test *ipt)\n{\n    return ipt->protocol->id;\n}\n\nint\niperf_get_test_json_output(struct iperf_test *ipt)\n{\n    return ipt->json_output;\n}\n\nchar *\niperf_get_test_json_output_string(struct iperf_test *ipt)\n{\n    return ipt->json_output_string;\n}\n\nint\niperf_get_test_zerocopy(struct iperf_test *ipt)\n{\n    return ipt->zerocopy;\n}\n\nint\niperf_get_test_get_server_output(struct iperf_test *ipt)\n{\n    return ipt->get_server_output;\n}\n\nchar\niperf_get_test_unit_format(struct iperf_test *ipt)\n{\n    return ipt->settings->unit_format;\n}\n\nchar *\niperf_get_test_bind_address(struct iperf_test *ipt)\n{\n    return ipt->bind_address;\n}\n\nchar *\niperf_get_test_bind_dev(struct iperf_test *ipt)\n{\n    return ipt->bind_dev;\n}\n\nint\niperf_get_test_udp_counters_64bit(struct iperf_test *ipt)\n{\n    return ipt->udp_counters_64bit;\n}\n\nint\niperf_get_test_one_off(struct iperf_test *ipt)\n{\n    return ipt->one_off;\n}\n\nint\niperf_get_test_tos(struct iperf_test *ipt)\n{\n    return ipt->settings->tos;\n}\n\nchar *\niperf_get_test_extra_data(struct iperf_test *ipt)\n{\n    return ipt->extra_data;\n}\n\nstatic const char iperf_version[] = IPERF_VERSION;\nchar *\niperf_get_iperf_version(void)\n{\n    return (char*)iperf_version;\n}\n\nint\niperf_get_test_no_delay(struct iperf_test *ipt)\n{\n    return ipt->no_delay;\n}\n\nint\niperf_get_test_connect_timeout(struct iperf_test *ipt)\n{\n    return ipt->settings->connect_timeout;\n}\n\nint\niperf_get_test_idle_timeout(struct iperf_test *ipt)\n{\n    return ipt->settings->idle_timeout;\n}\n\nint\niperf_get_dont_fragment(struct iperf_test *ipt)\n{\n    return ipt->settings->dont_fragment;\n}\n\nstruct iperf_time*\niperf_get_test_rcv_timeout(struct iperf_test *ipt)\n{\n    return &ipt->settings->rcv_timeout;\n}\n\nchar*\niperf_get_test_congestion_control(struct iperf_test* ipt)\n{\n    return ipt->congestion;\n}\n\nint\niperf_get_test_mss(struct iperf_test *ipt)\n{\n    return ipt->settings->mss;\n}\n\nint\niperf_get_mapped_v4(struct iperf_test* ipt)\n{\n    return ipt->mapped_v4;\n}\n\n/************** Setter routines for some fields inside iperf_test *************/\n\nvoid\niperf_set_verbose(struct iperf_test *ipt, int verbose)\n{\n    ipt->verbose = verbose;\n}\n\nvoid\niperf_set_control_socket(struct iperf_test *ipt, int ctrl_sck)\n{\n    ipt->ctrl_sck = ctrl_sck;\n}\n\nvoid\niperf_set_test_omit(struct iperf_test *ipt, int omit)\n{\n    ipt->omit = omit;\n}\n\nvoid\niperf_set_test_duration(struct iperf_test *ipt, int duration)\n{\n    ipt->duration = duration;\n}\n\nvoid\niperf_set_test_reporter_interval(struct iperf_test *ipt, double reporter_interval)\n{\n    ipt->reporter_interval = reporter_interval;\n}\n\nvoid\niperf_set_test_stats_interval(struct iperf_test *ipt, double stats_interval)\n{\n    ipt->stats_interval = stats_interval;\n}\n\nvoid\niperf_set_test_state(struct iperf_test *ipt, signed char state)\n{\n    ipt->state = state;\n}\n\nvoid\niperf_set_test_blksize(struct iperf_test *ipt, int blksize)\n{\n    ipt->settings->blksize = blksize;\n}\n\nvoid\niperf_set_test_logfile(struct iperf_test *ipt, const char *logfile)\n{\n    ipt->logfile = strdup(logfile);\n}\n\nvoid\niperf_set_test_rate(struct iperf_test *ipt, uint64_t rate)\n{\n    ipt->settings->rate = rate;\n}\n\nvoid\niperf_set_test_bitrate_limit_maximum(struct iperf_test *ipt, uint64_t total_rate)\n{\n    ipt->settings->bitrate_limit = total_rate;\n}\n\nvoid\niperf_set_test_bitrate_limit_interval(struct iperf_test *ipt, uint64_t bitrate_limit_interval)\n{\n    ipt->settings->bitrate_limit_interval = bitrate_limit_interval;\n}\n\nvoid\niperf_set_test_bitrate_limit_stats_per_interval(struct iperf_test *ipt, uint64_t bitrate_limit_stats_per_interval)\n{\n    ipt->settings->bitrate_limit_stats_per_interval = bitrate_limit_stats_per_interval;\n}\n\nvoid\niperf_set_test_fqrate(struct iperf_test *ipt, uint64_t fqrate)\n{\n    ipt->settings->fqrate = fqrate;\n}\n\nvoid\niperf_set_test_pacing_timer(struct iperf_test *ipt, int pacing_timer)\n{\n    ipt->settings->pacing_timer = pacing_timer;\n}\n\nvoid\niperf_set_test_bytes(struct iperf_test *ipt, uint64_t bytes)\n{\n    ipt->settings->bytes = (iperf_size_t) bytes;\n}\n\nvoid\niperf_set_test_blocks(struct iperf_test *ipt, uint64_t blocks)\n{\n    ipt->settings->blocks = (iperf_size_t) blocks;\n}\n\nvoid\niperf_set_test_burst(struct iperf_test *ipt, int burst)\n{\n    ipt->settings->burst = burst;\n}\n\nvoid\niperf_set_test_bind_port(struct iperf_test *ipt, int bind_port)\n{\n    ipt->bind_port = bind_port;\n}\n\nvoid\niperf_set_test_server_port(struct iperf_test *ipt, int srv_port)\n{\n    ipt->server_port = srv_port;\n}\n\nvoid\niperf_set_test_socket_bufsize(struct iperf_test *ipt, int socket_bufsize)\n{\n    ipt->settings->socket_bufsize = socket_bufsize;\n}\n\nvoid\niperf_set_test_num_streams(struct iperf_test *ipt, int num_streams)\n{\n    ipt->num_streams = num_streams;\n}\n\nvoid\niperf_set_test_repeating_payload(struct iperf_test *ipt, int repeating_payload)\n{\n    ipt->repeating_payload = repeating_payload;\n}\n\nvoid\niperf_set_test_timestamps(struct iperf_test *ipt, int timestamps)\n{\n    ipt->timestamps = timestamps;\n}\n\nvoid\niperf_set_test_timestamp_format(struct iperf_test *ipt, const char *tf)\n{\n    ipt->timestamp_format = strdup(tf);\n}\n\nvoid\niperf_set_mapped_v4(struct iperf_test *ipt, const int val)\n{\n    ipt->mapped_v4 = val;\n}\n\nstatic void\ncheck_sender_has_retransmits(struct iperf_test *ipt)\n{\n    if (ipt->mode != RECEIVER && ipt->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\tipt->sender_has_retransmits = 1;\n    else\n\tipt->sender_has_retransmits = 0;\n}\n\nvoid\niperf_set_test_role(struct iperf_test *ipt, char role)\n{\n    ipt->role = role;\n    if (!ipt->reverse) {\n        if (ipt->bidirectional)\n            ipt->mode = BIDIRECTIONAL;\n        else if (role == 'c')\n            ipt->mode = SENDER;\n        else if (role == 's')\n            ipt->mode = RECEIVER;\n    } else {\n        if (role == 'c')\n            ipt->mode = RECEIVER;\n        else if (role == 's')\n            ipt->mode = SENDER;\n    }\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_server_hostname(struct iperf_test *ipt, const char *server_hostname)\n{\n    ipt->server_hostname = strdup(server_hostname);\n}\n\nvoid\niperf_set_test_template(struct iperf_test *ipt, const char *tmp_template)\n{\n    ipt->tmp_template = strdup(tmp_template);\n}\n\nvoid\niperf_set_test_reverse(struct iperf_test *ipt, int reverse)\n{\n    ipt->reverse = reverse;\n    if (!ipt->reverse) {\n        if (ipt->role == 'c')\n            ipt->mode = SENDER;\n        else if (ipt->role == 's')\n            ipt->mode = RECEIVER;\n    } else {\n        if (ipt->role == 'c')\n            ipt->mode = RECEIVER;\n        else if (ipt->role == 's')\n            ipt->mode = SENDER;\n    }\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_json_output(struct iperf_test *ipt, int json_output)\n{\n    ipt->json_output = json_output;\n}\n\nint\niperf_has_zerocopy( void )\n{\n    return has_sendfile();\n}\n\nvoid\niperf_set_test_zerocopy(struct iperf_test *ipt, int zerocopy)\n{\n    ipt->zerocopy = (zerocopy && has_sendfile());\n}\n\nvoid\niperf_set_test_get_server_output(struct iperf_test *ipt, int get_server_output)\n{\n    ipt->get_server_output = get_server_output;\n}\n\nvoid\niperf_set_test_unit_format(struct iperf_test *ipt, char unit_format)\n{\n    ipt->settings->unit_format = unit_format;\n}\n\n#if defined(HAVE_SSL)\nvoid\niperf_set_test_client_username(struct iperf_test *ipt, const char *client_username)\n{\n    ipt->settings->client_username = strdup(client_username);\n}\n\nvoid\niperf_set_test_client_password(struct iperf_test *ipt, const char *client_password)\n{\n    ipt->settings->client_password = strdup(client_password);\n}\n\nvoid\niperf_set_test_client_rsa_pubkey(struct iperf_test *ipt, const char *client_rsa_pubkey_base64)\n{\n    ipt->settings->client_rsa_pubkey = load_pubkey_from_base64(client_rsa_pubkey_base64);\n}\n\nvoid\niperf_set_test_server_authorized_users(struct iperf_test *ipt, const char *server_authorized_users)\n{\n    ipt->server_authorized_users = strdup(server_authorized_users);\n}\n\nvoid\niperf_set_test_server_skew_threshold(struct iperf_test *ipt, int server_skew_threshold)\n{\n    ipt->server_skew_threshold = server_skew_threshold;\n}\n\nvoid\niperf_set_test_server_rsa_privkey(struct iperf_test *ipt, const char *server_rsa_privkey_base64)\n{\n    ipt->server_rsa_private_key = load_privkey_from_base64(server_rsa_privkey_base64);\n}\n#endif // HAVE_SSL\n\nvoid\niperf_set_test_bind_address(struct iperf_test *ipt, const char *bnd_address)\n{\n    ipt->bind_address = strdup(bnd_address);\n}\n\nvoid\niperf_set_test_bind_dev(struct iperf_test *ipt, const char *bnd_dev)\n{\n    ipt->bind_dev = strdup(bnd_dev);\n}\n\nvoid\niperf_set_test_udp_counters_64bit(struct iperf_test *ipt, int udp_counters_64bit)\n{\n    ipt->udp_counters_64bit = udp_counters_64bit;\n}\n\nvoid\niperf_set_test_one_off(struct iperf_test *ipt, int one_off)\n{\n    ipt->one_off = one_off;\n}\n\nvoid\niperf_set_test_tos(struct iperf_test *ipt, int tos)\n{\n    ipt->settings->tos = tos;\n}\n\nvoid\niperf_set_test_extra_data(struct iperf_test *ipt, const char *dat)\n{\n    ipt->extra_data = strdup(dat);\n}\n\nvoid\niperf_set_test_bidirectional(struct iperf_test* ipt, int bidirectional)\n{\n    ipt->bidirectional = bidirectional;\n    if (bidirectional)\n        ipt->mode = BIDIRECTIONAL;\n    else\n        iperf_set_test_reverse(ipt, ipt->reverse);\n}\n\nvoid\niperf_set_test_no_delay(struct iperf_test* ipt, int no_delay)\n{\n    ipt->no_delay = no_delay;\n}\n\nvoid\niperf_set_test_connect_timeout(struct iperf_test* ipt, int ct)\n{\n    ipt->settings->connect_timeout = ct;\n}\n\nvoid\niperf_set_test_idle_timeout(struct iperf_test* ipt, int to)\n{\n    ipt->settings->idle_timeout = to;\n}\n\nvoid\niperf_set_dont_fragment(struct iperf_test* ipt, int dnf)\n{\n    ipt->settings->dont_fragment = dnf;\n}\n\nvoid\niperf_set_test_rcv_timeout(struct iperf_test* ipt, struct iperf_time* to)\n{\n    ipt->settings->rcv_timeout.secs = to->secs;\n    ipt->settings->rcv_timeout.usecs = to->usecs;\n}\n\nvoid\niperf_set_test_congestion_control(struct iperf_test* ipt, char* cc)\n{\n    ipt->congestion = strdup(cc);\n}\n\nvoid\niperf_set_test_mss(struct iperf_test *ipt, int mss)\n{\n    ipt->settings->mss = mss;\n}\n\n/********************** Get/set test protocol structure ***********************/\n\nstruct protocol *\nget_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id)\n            break;\n    }\n\n    if (prot == NULL)\n        i_errno = IEPROTOCOL;\n\n    return prot;\n}\n\nint\nset_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot = NULL;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id) {\n            test->protocol = prot;\n\t    check_sender_has_retransmits(test);\n            return 0;\n        }\n    }\n\n    i_errno = IEPROTOCOL;\n    return -1;\n}\n\n\n/************************** Iperf callback functions **************************/\n\nvoid\niperf_on_new_stream(struct iperf_stream *sp)\n{\n    connect_msg(sp);\n}\n\nvoid\niperf_on_test_start(struct iperf_test *test)\n{\n    if (test->json_output) {\n\tcJSON_AddItemToObject(test->json_start, \"test_start\", iperf_json_printf(\"protocol: %s  num_streams: %d  blksize: %d  omit: %d  duration: %d  bytes: %d  blocks: %d  reverse: %d  tos: %d  target_bitrate: %d bidir: %d fqrate: %d\", test->protocol->name, (int64_t) test->num_streams, (int64_t) test->settings->blksize, (int64_t) test->omit, (int64_t) test->duration, (int64_t) test->settings->bytes, (int64_t) test->settings->blocks, test->reverse?(int64_t)1:(int64_t)0, (int64_t) test->settings->tos, (int64_t) test->settings->rate, (int64_t) test->bidirectional, (uint64_t) test->settings->fqrate));\n    } else {\n\tif (test->verbose) {\n\t    if (test->settings->bytes)\n\t\tiperf_printf(test, test_start_bytes, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->bytes, test->settings->tos);\n\t    else if (test->settings->blocks)\n\t\tiperf_printf(test, test_start_blocks, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->blocks, test->settings->tos);\n\t    else\n\t\tiperf_printf(test, test_start_time, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->duration, test->settings->tos);\n\t}\n    }\n}\n\n/* This converts an IPv6 string address from IPv4-mapped format into regular\n** old IPv4 format, which is easier on the eyes of network veterans.\n**\n** If the v6 address is not v4-mapped it is left alone.\n**\n** Returns 1 if the v6 address is v4-mapped, 0 otherwise.\n*/\nstatic int\nmapped_v4_to_regular_v4(char *str)\n{\n    char *prefix = \"::ffff:\";\n    int prefix_len;\n\n    prefix_len = strlen(prefix);\n    if (strncmp(str, prefix, prefix_len) == 0) {\n\tint str_len = strlen(str);\n\tmemmove(str, str + prefix_len, str_len - prefix_len + 1);\n\treturn 1;\n    }\n    return 0;\n}\n\nvoid\niperf_on_connect(struct iperf_test *test)\n{\n    time_t now_secs;\n    const char* rfc1123_fmt = \"%a, %d %b %Y %H:%M:%S %Z\";\n    char now_str[100];\n    char ipr[INET6_ADDRSTRLEN];\n    int port;\n    struct sockaddr_storage sa;\n    struct sockaddr_in *sa_inP;\n    struct sockaddr_in6 *sa_in6P;\n    socklen_t len;\n\n    now_secs = time((time_t*) 0);\n    (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&now_secs));\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_start, \"timestamp\", iperf_json_printf(\"time: %s  timesecs: %d\", now_str, (int64_t) now_secs));\n    else if (test->verbose)\n\tiperf_printf(test, report_time, now_str);\n\n    if (test->role == 'c') {\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"connecting_to\", iperf_json_printf(\"host: %s  port: %d\", test->server_hostname, (int64_t) test->server_port));\n\telse {\n\t    iperf_printf(test, report_connecting, test->server_hostname, test->server_port);\n\t    if (test->reverse)\n\t\tiperf_printf(test, report_reverse, test->server_hostname);\n\t}\n    } else {\n        len = sizeof(sa);\n        getpeername(test->ctrl_sck, (struct sockaddr *) &sa, &len);\n        if (getsockdomain(test->ctrl_sck) == AF_INET) {\n\t    sa_inP = (struct sockaddr_in *) &sa;\n            inet_ntop(AF_INET, &sa_inP->sin_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_inP->sin_port);\n        } else {\n\t    sa_in6P = (struct sockaddr_in6 *) &sa;\n            inet_ntop(AF_INET6, &sa_in6P->sin6_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_in6P->sin6_port);\n        }\n\tif (mapped_v4_to_regular_v4(ipr)) {\n\t    iperf_set_mapped_v4(test, 1);\n\t}\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"accepted_connection\", iperf_json_printf(\"host: %s  port: %d\", ipr, (int64_t) port));\n\telse\n\t    iperf_printf(test, report_accepted, ipr, port);\n    }\n    if (test->json_output) {\n\tcJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n\t    if (test->settings->mss)\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n\t    else {\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", test->ctrl_sck_mss);\n\t    }\n        }\n\t// Duplicate to make sure it appears on all output\n        cJSON_AddNumberToObject(test->json_start, \"target_bitrate\", test->settings->rate);\n        cJSON_AddNumberToObject(test->json_start, \"fq_rate\", test->settings->fqrate);\n    } else if (test->verbose) {\n        iperf_printf(test, report_cookie, test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n            if (test->settings->mss)\n                iperf_printf(test, \"      TCP MSS: %d\\n\", test->settings->mss);\n            else {\n                iperf_printf(test, \"      TCP MSS: %d (default)\\n\", test->ctrl_sck_mss);\n            }\n        }\n        if (test->settings->rate)\n            iperf_printf(test, \"      Target Bitrate: %\"PRIu64\"\\n\", test->settings->rate);\n    }\n}\n\nvoid\niperf_on_test_finish(struct iperf_test *test)\n{\n}\n\n\n/******************************************************************************/\n\n/*\n * iperf_parse_hostname tries to split apart a string into hostname %\n * interface parts, which are returned in **p and **p1, if they\n * exist. If the %interface part is detected, and it's not an IPv6\n * link local address, then returns 1, else returns 0.\n *\n * Modifies the string pointed to by spec in-place due to the use of\n * strtok(3). The caller should strdup(3) or otherwise copy the string\n * if an unmodified copy is needed.\n */\nint\niperf_parse_hostname(struct iperf_test *test, char *spec, char **p, char **p1) {\n    struct in6_addr ipv6_addr;\n\n    // Format is <addr>[%<device>]\n    if ((*p = strtok(spec, \"%\")) != NULL &&\n        (*p1 = strtok(NULL, \"%\")) != NULL) {\n\n        /*\n         * If an IPv6 literal for a link-local address, then\n         * tell the caller to leave the \"%\" in the hostname.\n         */\n        if (inet_pton(AF_INET6, *p, &ipv6_addr) == 1 &&\n            IN6_IS_ADDR_LINKLOCAL(&ipv6_addr)) {\n            if (test->debug) {\n                iperf_printf(test, \"IPv6 link-local address literal detected\\n\");\n            }\n            return 0;\n        }\n        /*\n         * Other kind of address or FQDN. The interface name after\n         * \"%\" is a shorthand for --bind-dev.\n         */\n        else {\n            if (test->debug) {\n                iperf_printf(test, \"p %s p1 %s\\n\", *p, *p1);\n            }\n            return 1;\n        }\n    }\n    else {\n        if (test->debug) {\n            iperf_printf(test, \"noparse\\n\");\n        }\n        return 0;\n    }\n}\n\nint\niperf_parse_arguments(struct iperf_test *test, int argc, char **argv)\n{\n    static struct option longopts[] =\n    {\n        {\"port\", required_argument, NULL, 'p'},\n        {\"format\", required_argument, NULL, 'f'},\n        {\"interval\", required_argument, NULL, 'i'},\n        {\"daemon\", no_argument, NULL, 'D'},\n        {\"one-off\", no_argument, NULL, '1'},\n        {\"verbose\", no_argument, NULL, 'V'},\n        {\"json\", no_argument, NULL, 'J'},\n        {\"version\", no_argument, NULL, 'v'},\n        {\"server\", no_argument, NULL, 's'},\n        {\"client\", required_argument, NULL, 'c'},\n        {\"udp\", no_argument, NULL, 'u'},\n        {\"bitrate\", required_argument, NULL, 'b'},\n        {\"bandwidth\", required_argument, NULL, 'b'},\n\t{\"server-bitrate-limit\", required_argument, NULL, OPT_SERVER_BITRATE_LIMIT},\n        {\"time\", required_argument, NULL, 't'},\n        {\"bytes\", required_argument, NULL, 'n'},\n        {\"blockcount\", required_argument, NULL, 'k'},\n        {\"length\", required_argument, NULL, 'l'},\n        {\"parallel\", required_argument, NULL, 'P'},\n        {\"reverse\", no_argument, NULL, 'R'},\n        {\"bidir\", no_argument, NULL, OPT_BIDIRECTIONAL},\n        {\"window\", required_argument, NULL, 'w'},\n        {\"bind\", required_argument, NULL, 'B'},\n#if defined(HAVE_SO_BINDTODEVICE)\n        {\"bind-dev\", required_argument, NULL, OPT_BIND_DEV},\n#endif /* HAVE_SO_BINDTODEVICE */\n        {\"cport\", required_argument, NULL, OPT_CLIENT_PORT},\n        {\"set-mss\", required_argument, NULL, 'M'},\n        {\"no-delay\", no_argument, NULL, 'N'},\n        {\"version4\", no_argument, NULL, '4'},\n        {\"version6\", no_argument, NULL, '6'},\n        {\"tos\", required_argument, NULL, 'S'},\n        {\"dscp\", required_argument, NULL, OPT_DSCP},\n\t{\"extra-data\", required_argument, NULL, OPT_EXTRA_DATA},\n#if defined(HAVE_FLOWLABEL)\n        {\"flowlabel\", required_argument, NULL, 'L'},\n#endif /* HAVE_FLOWLABEL */\n        {\"zerocopy\", no_argument, NULL, 'Z'},\n        {\"omit\", required_argument, NULL, 'O'},\n        {\"file\", required_argument, NULL, 'F'},\n        {\"repeating-payload\", no_argument, NULL, OPT_REPEATING_PAYLOAD},\n        {\"timestamps\", optional_argument, NULL, OPT_TIMESTAMPS},\n#if defined(HAVE_CPU_AFFINITY)\n        {\"affinity\", required_argument, NULL, 'A'},\n#endif /* HAVE_CPU_AFFINITY */\n        {\"title\", required_argument, NULL, 'T'},\n#if defined(HAVE_TCP_CONGESTION)\n        {\"congestion\", required_argument, NULL, 'C'},\n        {\"linux-congestion\", required_argument, NULL, 'C'},\n#endif /* HAVE_TCP_CONGESTION */\n#if defined(HAVE_SCTP_H)\n        {\"sctp\", no_argument, NULL, OPT_SCTP},\n        {\"nstreams\", required_argument, NULL, OPT_NUMSTREAMS},\n        {\"xbind\", required_argument, NULL, 'X'},\n#endif\n\t{\"pidfile\", required_argument, NULL, 'I'},\n\t{\"logfile\", required_argument, NULL, OPT_LOGFILE},\n\t{\"forceflush\", no_argument, NULL, OPT_FORCEFLUSH},\n\t{\"get-server-output\", no_argument, NULL, OPT_GET_SERVER_OUTPUT},\n\t{\"udp-counters-64bit\", no_argument, NULL, OPT_UDP_COUNTERS_64BIT},\n \t{\"no-fq-socket-pacing\", no_argument, NULL, OPT_NO_FQ_SOCKET_PACING},\n#if defined(HAVE_DONT_FRAGMENT)\n\t{\"dont-fragment\", no_argument, NULL, OPT_DONT_FRAGMENT},\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n    {\"username\", required_argument, NULL, OPT_CLIENT_USERNAME},\n    {\"rsa-public-key-path\", required_argument, NULL, OPT_CLIENT_RSA_PUBLIC_KEY},\n    {\"rsa-private-key-path\", required_argument, NULL, OPT_SERVER_RSA_PRIVATE_KEY},\n    {\"authorized-users-path\", required_argument, NULL, OPT_SERVER_AUTHORIZED_USERS},\n    {\"time-skew-threshold\", required_argument, NULL, OPT_SERVER_SKEW_THRESHOLD},\n#endif /* HAVE_SSL */\n\t{\"fq-rate\", required_argument, NULL, OPT_FQ_RATE},\n\t{\"pacing-timer\", required_argument, NULL, OPT_PACING_TIMER},\n\t{\"connect-timeout\", required_argument, NULL, OPT_CONNECT_TIMEOUT},\n        {\"idle-timeout\", required_argument, NULL, OPT_IDLE_TIMEOUT},\n        {\"rcv-timeout\", required_argument, NULL, OPT_RCV_TIMEOUT},\n        {\"snd-timeout\", required_argument, NULL, OPT_SND_TIMEOUT},\n        {\"debug\", optional_argument, NULL, 'd'},\n        {\"help\", no_argument, NULL, 'h'},\n        {NULL, 0, NULL, 0}\n    };\n    int flag;\n    int portno;\n    int blksize;\n    int server_flag, client_flag, rate_flag, duration_flag, rcv_timeout_flag, snd_timeout_flag;\n    char *endptr;\n#if defined(HAVE_CPU_AFFINITY)\n    char* comma;\n#endif /* HAVE_CPU_AFFINITY */\n    char* slash;\n    char *p, *p1;\n    struct xbind_entry *xbe;\n    double farg;\n    int rcv_timeout_in = 0;\n\n    blksize = 0;\n    server_flag = client_flag = rate_flag = duration_flag = rcv_timeout_flag = snd_timeout_flag =0;\n#if defined(HAVE_SSL)\n    char *client_username = NULL, *client_rsa_public_key = NULL, *server_rsa_private_key = NULL;\n#endif /* HAVE_SSL */\n\n    while ((flag = getopt_long(argc, argv, \"p:f:i:D1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dI:hX:\", longopts, NULL)) != -1) {\n        switch (flag) {\n            case 'p':\n\t\tportno = atoi(optarg);\n\t\tif (portno < 1 || portno > 65535) {\n\t\t    i_errno = IEBADPORT;\n\t\t    return -1;\n\t\t}\n\t\ttest->server_port = portno;\n                break;\n            case 'f':\n\t\tif (!optarg) {\n\t\t    i_errno = IEBADFORMAT;\n\t\t    return -1;\n\t\t}\n\t\ttest->settings->unit_format = *optarg;\n\t\tif (test->settings->unit_format == 'k' ||\n\t\t    test->settings->unit_format == 'K' ||\n\t\t    test->settings->unit_format == 'm' ||\n\t\t    test->settings->unit_format == 'M' ||\n\t\t    test->settings->unit_format == 'g' ||\n\t\t    test->settings->unit_format == 'G' ||\n\t\t    test->settings->unit_format == 't' ||\n\t\t    test->settings->unit_format == 'T') {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t    i_errno = IEBADFORMAT;\n\t\t    return -1;\n\t\t}\n                break;\n            case 'i':\n                /* XXX: could potentially want separate stat collection and reporting intervals,\n                   but just set them to be the same for now */\n                test->stats_interval = test->reporter_interval = atof(optarg);\n                if ((test->stats_interval < MIN_INTERVAL || test->stats_interval > MAX_INTERVAL) && test->stats_interval != 0) {\n                    i_errno = IEINTERVAL;\n                    return -1;\n                }\n                break;\n            case 'D':\n\t\ttest->daemon = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case '1':\n\t\ttest->one_off = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case 'V':\n                test->verbose = 1;\n                break;\n            case 'J':\n                test->json_output = 1;\n                break;\n            case 'v':\n                printf(\"%s (cJSON %s)\\n%s\\n%s\\n\", version, cJSON_Version(), get_system_info(),\n\t\t       get_optional_features());\n                exit(0);\n            case 's':\n                if (test->role == 'c') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 's');\n                break;\n            case 'c':\n                if (test->role == 's') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 'c');\n\t\tiperf_set_test_server_hostname(test, optarg);\n\n                if (iperf_parse_hostname(test, optarg, &p, &p1)) {\n#if defined(HAVE_SO_BINDTODEVICE)\n                    /* Get rid of the hostname we saved earlier. */\n                    free(iperf_get_test_server_hostname(test));\n                    iperf_set_test_server_hostname(test, p);\n                    iperf_set_test_bind_dev(test, p1);\n#else /* HAVE_SO_BINDTODEVICE */\n                    i_errno = IEBINDDEVNOSUPPORT;\n                    return -1;\n#endif /* HAVE_SO_BINDTODEVICE */\n                }\n                break;\n            case 'u':\n                set_protocol(test, Pudp);\n\t\tclient_flag = 1;\n                break;\n            case OPT_SCTP:\n#if defined(HAVE_SCTP_H)\n                set_protocol(test, Psctp);\n                client_flag = 1;\n                break;\n#else /* HAVE_SCTP_H */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_SCTP_H */\n\n            case OPT_NUMSTREAMS:\n#if defined(linux) || defined(__FreeBSD__)\n                test->settings->num_ostreams = unit_atoi(optarg);\n                client_flag = 1;\n#else /* linux */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* linux */\n            case 'b':\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->burst = atoi(slash);\n\t\t    if (test->settings->burst <= 0 ||\n\t\t        test->settings->burst > MAX_BURST) {\n\t\t\ti_errno = IEBURST;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n                test->settings->rate = unit_atof_rate(optarg);\n\t\trate_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case OPT_SERVER_BITRATE_LIMIT:\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->bitrate_limit_interval = atof(slash);\n\t\t    if (test->settings->bitrate_limit_interval != 0 &&\t/* Using same Max/Min limits as for Stats Interval */\n\t\t        (test->settings->bitrate_limit_interval < MIN_INTERVAL || test->settings->bitrate_limit_interval > MAX_INTERVAL) ) {\n\t\t\ti_errno = IETOTALINTERVAL;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n\t\ttest->settings->bitrate_limit = unit_atof_rate(optarg);\n\t\tserver_flag = 1;\n\t        break;\n            case 't':\n                test->duration = atoi(optarg);\n                if (test->duration > MAX_TIME) {\n                    i_errno = IEDURATION;\n                    return -1;\n                }\n\t\tduration_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'n':\n                test->settings->bytes = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'k':\n                test->settings->blocks = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'l':\n                blksize = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'P':\n                test->num_streams = atoi(optarg);\n                if (test->num_streams > MAX_STREAMS) {\n                    i_errno = IENUMSTREAMS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'R':\n                if (test->bidirectional) {\n                    i_errno = IEREVERSEBIDIR;\n                    return -1;\n                }\n\t\tiperf_set_test_reverse(test, 1);\n\t\tclient_flag = 1;\n                break;\n            case OPT_BIDIRECTIONAL:\n                if (test->reverse) {\n                    i_errno = IEREVERSEBIDIR;\n                    return -1;\n                }\n                iperf_set_test_bidirectional(test, 1);\n                client_flag = 1;\n                break;\n            case 'w':\n                // XXX: This is a socket buffer, not specific to TCP\n\t\t// Do sanity checks as double-precision floating point\n\t\t// to avoid possible integer overflows.\n                farg = unit_atof(optarg);\n                if (farg > (double) MAX_TCP_BUFFER) {\n                    i_errno = IEBUFSIZE;\n                    return -1;\n                }\n                test->settings->socket_bufsize = (int) farg;\n\t\tclient_flag = 1;\n                break;\n\n            case 'B':\n                iperf_set_test_bind_address(test, optarg);\n\n                if (iperf_parse_hostname(test, optarg, &p, &p1)) {\n#if defined(HAVE_SO_BINDTODEVICE)\n                    /* Get rid of the hostname we saved earlier. */\n                    free(iperf_get_test_bind_address(test));\n                    iperf_set_test_bind_address(test, p);\n                    iperf_set_test_bind_dev(test, p1);\n#else /* HAVE_SO_BINDTODEVICE */\n                    i_errno = IEBINDDEVNOSUPPORT;\n                    return -1;\n#endif /* HAVE_SO_BINDTODEVICE */\n                }\n                break;\n#if defined (HAVE_SO_BINDTODEVICE)\n            case OPT_BIND_DEV:\n                iperf_set_test_bind_dev(test, optarg);\n                break;\n#endif /* HAVE_SO_BINDTODEVICE */\n            case OPT_CLIENT_PORT:\n\t\tportno = atoi(optarg);\n\t\tif (portno < 1 || portno > 65535) {\n\t\t    i_errno = IEBADPORT;\n\t\t    return -1;\n\t\t}\n                test->bind_port = portno;\n                break;\n            case 'M':\n                test->settings->mss = atoi(optarg);\n                if (test->settings->mss > MAX_MSS) {\n                    i_errno = IEMSS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'N':\n                test->no_delay = 1;\n\t\tclient_flag = 1;\n                break;\n            case '4':\n                test->settings->domain = AF_INET;\n                break;\n            case '6':\n                test->settings->domain = AF_INET6;\n                break;\n            case 'S':\n                test->settings->tos = strtol(optarg, &endptr, 0);\n\t\tif (endptr == optarg ||\n\t\t    test->settings->tos < 0 ||\n\t\t    test->settings->tos > 255) {\n\t\t    i_errno = IEBADTOS;\n\t\t    return -1;\n\t\t}\n\t\tclient_flag = 1;\n                break;\n\t    case OPT_DSCP:\n                test->settings->tos = parse_qos(optarg);\n\t\tif(test->settings->tos < 0) {\n\t\t\ti_errno = IEBADTOS;\n\t\t\treturn -1;\n\t\t}\n\t\tclient_flag = 1;\n                break;\n\t    case OPT_EXTRA_DATA:\n\t\ttest->extra_data = strdup(optarg);\n\t\tclient_flag = 1;\n\t        break;\n            case 'L':\n#if defined(HAVE_FLOWLABEL)\n                test->settings->flowlabel = strtol(optarg, &endptr, 0);\n\t\tif (endptr == optarg ||\n\t\t    test->settings->flowlabel < 1 || test->settings->flowlabel > 0xfffff) {\n                    i_errno = IESETFLOW;\n                    return -1;\n\t\t}\n\t\tclient_flag = 1;\n#else /* HAVE_FLOWLABEL */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_FLOWLABEL */\n                break;\n            case 'X':\n\t\txbe = (struct xbind_entry *)malloc(sizeof(struct xbind_entry));\n                if (!xbe) {\n\t\t    i_errno = IESETSCTPBINDX;\n                    return -1;\n                }\n\t        memset(xbe, 0, sizeof(*xbe));\n                xbe->name = strdup(optarg);\n                if (!xbe->name) {\n\t\t    i_errno = IESETSCTPBINDX;\n                    return -1;\n                }\n\t\tTAILQ_INSERT_TAIL(&test->xbind_addrs, xbe, link);\n                break;\n            case 'Z':\n                if (!has_sendfile()) {\n                    i_errno = IENOSENDFILE;\n                    return -1;\n                }\n                test->zerocopy = 1;\n\t\tclient_flag = 1;\n                break;\n            case OPT_REPEATING_PAYLOAD:\n                test->repeating_payload = 1;\n                client_flag = 1;\n                break;\n            case OPT_TIMESTAMPS:\n                iperf_set_test_timestamps(test, 1);\n\t\tif (optarg) {\n\t\t    iperf_set_test_timestamp_format(test, optarg);\n\t\t}\n\t\telse {\n\t\t    iperf_set_test_timestamp_format(test, TIMESTAMP_FORMAT);\n\t\t}\n                break;\n            case 'O':\n                test->omit = atoi(optarg);\n                if (test->omit < 0 || test->omit > 60) {\n                    i_errno = IEOMIT;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'F':\n                test->diskfile_name = optarg;\n                break;\n            case OPT_IDLE_TIMEOUT:\n                test->settings->idle_timeout = atoi(optarg);\n                if (test->settings->idle_timeout < 1 || test->settings->idle_timeout > MAX_TIME) {\n                    i_errno = IEIDLETIMEOUT;\n                    return -1;\n                }\n\t\tserver_flag = 1;\n\t        break;\n            case OPT_RCV_TIMEOUT:\n                rcv_timeout_in = atoi(optarg);\n                if (rcv_timeout_in < MIN_NO_MSG_RCVD_TIMEOUT || rcv_timeout_in > MAX_TIME * SEC_TO_mS) {\n                    i_errno = IERCVTIMEOUT;\n                    return -1;\n                }\n                test->settings->rcv_timeout.secs = rcv_timeout_in / SEC_TO_mS;\n                test->settings->rcv_timeout.usecs = (rcv_timeout_in % SEC_TO_mS) * mS_TO_US;\n                rcv_timeout_flag = 1;\n\t        break;\n#if defined(HAVE_TCP_USER_TIMEOUT)\n            case OPT_SND_TIMEOUT:\n                test->settings->snd_timeout = atoi(optarg);\n                if (test->settings->snd_timeout < 0 || test->settings->snd_timeout > MAX_TIME * SEC_TO_mS) {\n                    i_errno = IESNDTIMEOUT;\n                    return -1;\n                }\n                snd_timeout_flag = 1;\n\t        break;\n#endif /* HAVE_TCP_USER_TIMEOUT */\n            case 'A':\n#if defined(HAVE_CPU_AFFINITY)\n                test->affinity = strtol(optarg, &endptr, 0);\n                if (endptr == optarg ||\n\t\t    test->affinity < 0 || test->affinity > 1024) {\n                    i_errno = IEAFFINITY;\n                    return -1;\n                }\n\t\tcomma = strchr(optarg, ',');\n\t\tif (comma != NULL) {\n\t\t    test->server_affinity = atoi(comma+1);\n\t\t    if (test->server_affinity < 0 || test->server_affinity > 1024) {\n\t\t\ti_errno = IEAFFINITY;\n\t\t\treturn -1;\n\t\t    }\n\t\t    client_flag = 1;\n\t\t}\n#else /* HAVE_CPU_AFFINITY */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_CPU_AFFINITY */\n                break;\n            case 'T':\n                test->title = strdup(optarg);\n\t\tclient_flag = 1;\n                break;\n\t    case 'C':\n#if defined(HAVE_TCP_CONGESTION)\n\t\ttest->congestion = strdup(optarg);\n\t\tclient_flag = 1;\n#else /* HAVE_TCP_CONGESTION */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif /* HAVE_TCP_CONGESTION */\n\t\tbreak;\n\t    case 'd':\n\t\ttest->debug = 1;\n                test->debug_level = DEBUG_LEVEL_MAX;\n                if (optarg) {\n                    test->debug_level = atoi(optarg);\n                    if (test->debug_level < 0)\n                        test->debug_level = DEBUG_LEVEL_MAX;\n                }\n\t\tbreak;\n\t    case 'I':\n\t\ttest->pidfile = strdup(optarg);\n\t        break;\n\t    case OPT_LOGFILE:\n\t\ttest->logfile = strdup(optarg);\n\t\tbreak;\n\t    case OPT_FORCEFLUSH:\n\t\ttest->forceflush = 1;\n\t\tbreak;\n\t    case OPT_GET_SERVER_OUTPUT:\n\t\ttest->get_server_output = 1;\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case OPT_UDP_COUNTERS_64BIT:\n\t\ttest->udp_counters_64bit = 1;\n\t\tbreak;\n\t    case OPT_NO_FQ_SOCKET_PACING:\n#if defined(HAVE_SO_MAX_PACING_RATE)\n\t\tprintf(\"Warning:  --no-fq-socket-pacing is deprecated\\n\");\n\t\ttest->settings->fqrate = 0;\n\t\tclient_flag = 1;\n#else /* HAVE_SO_MAX_PACING_RATE */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif\n\t\tbreak;\n\t    case OPT_FQ_RATE:\n#if defined(HAVE_SO_MAX_PACING_RATE)\n\t\ttest->settings->fqrate = unit_atof_rate(optarg);\n\t\tclient_flag = 1;\n#else /* HAVE_SO_MAX_PACING_RATE */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif\n\t\tbreak;\n#if defined(HAVE_DONT_FRAGMENT)\n        case OPT_DONT_FRAGMENT:\n            test->settings->dont_fragment = 1;\n            client_flag = 1;\n            break;\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n        case OPT_CLIENT_USERNAME:\n            client_username = strdup(optarg);\n            break;\n        case OPT_CLIENT_RSA_PUBLIC_KEY:\n            client_rsa_public_key = strdup(optarg);\n            break;\n        case OPT_SERVER_RSA_PRIVATE_KEY:\n            server_rsa_private_key = strdup(optarg);\n            break;\n        case OPT_SERVER_AUTHORIZED_USERS:\n            test->server_authorized_users = strdup(optarg);\n            break;\n        case OPT_SERVER_SKEW_THRESHOLD:\n            test->server_skew_threshold = atoi(optarg);\n            if(test->server_skew_threshold <= 0){\n                i_errno = IESKEWTHRESHOLD;\n                return -1;\n            }\n            break;\n#endif /* HAVE_SSL */\n\t    case OPT_PACING_TIMER:\n\t\ttest->settings->pacing_timer = unit_atoi(optarg);\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case OPT_CONNECT_TIMEOUT:\n\t\ttest->settings->connect_timeout = unit_atoi(optarg);\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case 'h':\n\t\tusage_long(stdout);\n\t\texit(0);\n            default:\n                fprintf(stderr, \"\\n\");\n                usage();\n                exit(1);\n        }\n    }\n\n    /* Check flag / role compatibility. */\n    if (test->role == 'c' && server_flag) {\n        i_errno = IESERVERONLY;\n        return -1;\n    }\n    if (test->role == 's' && client_flag) {\n        i_errno = IECLIENTONLY;\n        return -1;\n    }\n\n#if defined(HAVE_SSL)\n\n    if (test->role == 's' && (client_username || client_rsa_public_key)){\n        i_errno = IECLIENTONLY;\n        return -1;\n    } else if (test->role == 'c' && (client_username || client_rsa_public_key) &&\n        !(client_username && client_rsa_public_key)) {\n        i_errno = IESETCLIENTAUTH;\n        return -1;\n    } else if (test->role == 'c' && (client_username && client_rsa_public_key)){\n\n        char *client_password = NULL;\n        size_t s;\n        if (test_load_pubkey_from_file(client_rsa_public_key) < 0){\n            iperf_err(test, \"%s\\n\", ERR_error_string(ERR_get_error(), NULL));\n            i_errno = IESETCLIENTAUTH;\n            return -1;\n        }\n        /* Need to copy env var, so we can do a common free */\n        if ((client_password = getenv(\"IPERF3_PASSWORD\")) != NULL)\n             client_password = strdup(client_password);\n        else if (iperf_getpass(&client_password, &s, stdin) < 0){\n            i_errno = IESETCLIENTAUTH;\n            return -1;\n        }\n\n        test->settings->client_username = client_username;\n        test->settings->client_password = client_password;\n        test->settings->client_rsa_pubkey = load_pubkey_from_file(client_rsa_public_key);\n\tfree(client_rsa_public_key);\n\tclient_rsa_public_key = NULL;\n    }\n\n    if (test->role == 'c' && (server_rsa_private_key || test->server_authorized_users)){\n        i_errno = IESERVERONLY;\n        return -1;\n    } else if (test->role == 'c' && (test->server_skew_threshold != 0)){\n        i_errno = IESERVERONLY;\n        return -1;\n    } else if (test->role == 'c' && rcv_timeout_flag && test->mode == SENDER){\n        i_errno = IERVRSONLYRCVTIMEOUT;\n        return -1;\n    } else if (test->role == 's' && (server_rsa_private_key || test->server_authorized_users) &&\n        !(server_rsa_private_key && test->server_authorized_users)) {\n         i_errno = IESETSERVERAUTH;\n        return -1;\n    } else if (test->role == 's' && server_rsa_private_key) {\n        test->server_rsa_private_key = load_privkey_from_file(server_rsa_private_key);\n        if (test->server_rsa_private_key == NULL){\n            iperf_err(test, \"%s\\n\", ERR_error_string(ERR_get_error(), NULL));\n            i_errno = IESETSERVERAUTH;\n            return -1;\n        }\n\t    free(server_rsa_private_key);\n\t    server_rsa_private_key = NULL;\n\n        if(test->server_skew_threshold == 0){\n            // Set default value for time skew threshold\n            test->server_skew_threshold=10;\n        }\n    }\n\n#endif //HAVE_SSL\n\n    // File cannot be transferred using UDP because of the UDP packets header (packet number, etc.)\n    if(test->role == 'c' && test->diskfile_name != (char*) 0 && test->protocol->id == Pudp) {\n        i_errno = IEUDPFILETRANSFER;\n        return -1;\n    }\n\n    if (blksize == 0) {\n\tif (test->protocol->id == Pudp)\n\t    blksize = 0;\t/* try to dynamically determine from MSS */\n\telse if (test->protocol->id == Psctp)\n\t    blksize = DEFAULT_SCTP_BLKSIZE;\n\telse\n\t    blksize = DEFAULT_TCP_BLKSIZE;\n    }\n    if ((test->protocol->id != Pudp && blksize <= 0)\n\t|| blksize > MAX_BLOCKSIZE) {\n\ti_errno = IEBLOCKSIZE;\n\treturn -1;\n    }\n    if (test->protocol->id == Pudp &&\n\t(blksize > 0 &&\n\t    (blksize < MIN_UDP_BLOCKSIZE || blksize > MAX_UDP_BLOCKSIZE))) {\n\ti_errno = IEUDPBLOCKSIZE;\n\treturn -1;\n    }\n    test->settings->blksize = blksize;\n\n    if (!rate_flag)\n\ttest->settings->rate = test->protocol->id == Pudp ? UDP_RATE : 0;\n\n    /* if no bytes or blocks specified, nor a duration_flag, and we have -F,\n    ** get the file-size as the bytes count to be transferred\n    */\n    if (test->settings->bytes == 0 &&\n        test->settings->blocks == 0 &&\n        ! duration_flag &&\n        test->diskfile_name != (char*) 0 &&\n        test->role == 'c'\n        ){\n        struct stat st;\n        if( stat(test->diskfile_name, &st) == 0 ){\n            iperf_size_t file_bytes = st.st_size;\n            test->settings->bytes = file_bytes;\n            if (test->debug)\n                printf(\"End condition set to file-size: %\"PRIu64\" bytes\\n\", test->settings->bytes);\n        }\n        // if failing to read file stat, it should fallback to default duration mode\n    }\n\n    if ((test->settings->bytes != 0 || test->settings->blocks != 0) && ! duration_flag)\n        test->duration = 0;\n\n    /* Disallow specifying multiple test end conditions. The code actually\n    ** works just fine without this prohibition. As soon as any one of the\n    ** three possible end conditions is met, the test ends. So this check\n    ** could be removed if desired.\n    */\n    if ((duration_flag && test->settings->bytes != 0) ||\n        (duration_flag && test->settings->blocks != 0) ||\n\t(test->settings->bytes != 0 && test->settings->blocks != 0)) {\n        i_errno = IEENDCONDITIONS;\n        return -1;\n    }\n\n    /* For subsequent calls to getopt */\n#ifdef __APPLE__\n    optreset = 1;\n#endif\n    optind = 0;\n\n    if ((test->role != 'c') && (test->role != 's')) {\n        i_errno = IENOROLE;\n        return -1;\n    }\n\n    /* Set Total-rate average interval to multiplicity of State interval */\n    if (test->settings->bitrate_limit_interval != 0) {\n\ttest->settings->bitrate_limit_stats_per_interval =\n\t    (test->settings->bitrate_limit_interval <= test->stats_interval ?\n\t    1 : round(test->settings->bitrate_limit_interval/test->stats_interval) );\n    }\n\n    /* Show warning if JSON output is used with explicit report format */\n    if ((test->json_output) && (test->settings->unit_format != 'a')) {\n        warning(\"Report format (-f) flag ignored with JSON output (-J)\");\n    }\n\n    /* Show warning if JSON output is used with verbose or debug flags */\n    if (test->json_output && test->verbose) {\n        warning(\"Verbose output (-v) may interfere with JSON output (-J)\");\n    }\n    if (test->json_output && test->debug) {\n        warning(\"Debug output (-d) may interfere with JSON output (-J)\");\n    }\n\n    return 0;\n}\n\n/*\n * Open the file specified by test->logfile and set test->outfile to its' FD.\n */\nint iperf_open_logfile(struct iperf_test *test)\n{\n    test->outfile = fopen(test->logfile, \"a+\");\n    if (test->outfile == NULL) {\n        i_errno = IELOGFILE;\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid iperf_close_logfile(struct iperf_test *test)\n{\n    if (test->outfile && test->outfile != stdout) {\n        fclose(test->outfile);\n        test->outfile = NULL;\n    }\n}\n\nint\niperf_set_send_state(struct iperf_test *test, signed char state)\n{\n    if (test->ctrl_sck >= 0) {\n        test->state = state;\n        if (Nwrite(test->ctrl_sck, (char*) &state, sizeof(state), Ptcp) < 0) {\n\t    i_errno = IESENDMESSAGE;\n\t    return -1;\n        }\n    }\n    return 0;\n}\n\nvoid\niperf_check_throttle(struct iperf_stream *sp, struct iperf_time *nowP)\n{\n    struct iperf_time temp_time;\n    double seconds;\n    uint64_t bits_per_second;\n\n    if (sp->test->done || sp->test->settings->rate == 0)\n        return;\n    iperf_time_diff(&sp->result->start_time_fixed, nowP, &temp_time);\n    seconds = iperf_time_in_secs(&temp_time);\n    bits_per_second = sp->result->bytes_sent * 8 / seconds;\n    if (bits_per_second < sp->test->settings->rate) {\n        sp->green_light = 1;\n        FD_SET(sp->socket, &sp->test->write_set);\n    } else {\n        sp->green_light = 0;\n        FD_CLR(sp->socket, &sp->test->write_set);\n    }\n}\n\n/* Verify that average traffic is not greater than the specified limit */\nvoid\niperf_check_total_rate(struct iperf_test *test, iperf_size_t last_interval_bytes_transferred)\n{\n    double seconds;\n    uint64_t bits_per_second;\n    iperf_size_t total_bytes;\n    int i;\n\n    if (test->done || test->settings->bitrate_limit == 0)    // Continue only if check should be done\n        return;\n\n    /* Add last inetrval's transferred bytes to the array */\n    if (++test->bitrate_limit_last_interval_index >= test->settings->bitrate_limit_stats_per_interval)\n        test->bitrate_limit_last_interval_index = 0;\n    test->bitrate_limit_intervals_traffic_bytes[test->bitrate_limit_last_interval_index] = last_interval_bytes_transferred;\n\n    /* Ensure that enough stats periods passed to allow averaging throughput */\n    test->bitrate_limit_stats_count += 1;\n    if (test->bitrate_limit_stats_count < test->settings->bitrate_limit_stats_per_interval)\n        return;\n\n     /* Calculating total bytes traffic to be averaged */\n    for (total_bytes = 0, i = 0; i < test->settings->bitrate_limit_stats_per_interval; i++) {\n        total_bytes += test->bitrate_limit_intervals_traffic_bytes[i];\n    }\n\n    seconds = test->stats_interval * test->settings->bitrate_limit_stats_per_interval;\n    bits_per_second = total_bytes * 8 / seconds;\n    if (test->debug) {\n        iperf_printf(test,\"Interval %\" PRIu64 \" - throughput %\" PRIu64 \" bps (limit %\" PRIu64 \")\\n\", test->bitrate_limit_stats_count, bits_per_second, test->settings->bitrate_limit);\n    }\n\n    if (bits_per_second  > test->settings->bitrate_limit) {\n        if (iperf_get_verbose(test))\n            iperf_err(test, \"Total throughput of %\" PRIu64 \" bps exceeded %\" PRIu64 \" bps limit\", bits_per_second, test->settings->bitrate_limit);\n\ttest->bitrate_limit_exceeded = 1;\n    }\n}\n\nint\niperf_send(struct iperf_test *test, fd_set *write_setP)\n{\n    register int multisend, r, streams_active;\n    register struct iperf_stream *sp;\n    struct iperf_time now;\n    int no_throttle_check;\n\n    /* Can we do multisend mode? */\n    if (test->settings->burst != 0)\n        multisend = test->settings->burst;\n    else if (test->settings->rate == 0)\n        multisend = test->multisend;\n    else\n        multisend = 1;\t/* nope */\n\n    /* Should bitrate throttle be checked for every send */\n    no_throttle_check = test->settings->rate != 0 && test->settings->burst == 0;\n\n    for (; multisend > 0; --multisend) {\n\tif (no_throttle_check)\n\t    iperf_time_now(&now);\n\tstreams_active = 0;\n\tSLIST_FOREACH(sp, &test->streams, streams) {\n\t    if ((sp->green_light && sp->sender &&\n\t\t (write_setP == NULL || FD_ISSET(sp->socket, write_setP)))) {\n        if (multisend > 1 && test->settings->bytes != 0 && test->bytes_sent >= test->settings->bytes)\n            break;\n        if (multisend > 1 && test->settings->blocks != 0 && test->blocks_sent >= test->settings->blocks)\n            break;\n\t\tif ((r = sp->snd(sp)) < 0) {\n\t\t    if (r == NET_SOFTERROR)\n\t\t\tbreak;\n\t\t    i_errno = IESTREAMWRITE;\n\t\t    return r;\n\t\t}\n\t\tstreams_active = 1;\n\t\ttest->bytes_sent += r;\n\t\tif (!sp->pending_size)\n\t\t    ++test->blocks_sent;\n                if (no_throttle_check)\n\t\t    iperf_check_throttle(sp, &now);\n\t    }\n\t}\n\tif (!streams_active)\n\t    break;\n    }\n    if (!no_throttle_check) {   /* Throttle check if was not checked for each send */\n\tiperf_time_now(&now);\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (sp->sender)\n\t        iperf_check_throttle(sp, &now);\n    }\n    if (write_setP != NULL)\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (FD_ISSET(sp->socket, write_setP))\n\t\tFD_CLR(sp->socket, write_setP);\n\n    return 0;\n}\n\nint\niperf_recv(struct iperf_test *test, fd_set *read_setP)\n{\n    int r;\n    struct iperf_stream *sp;\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (FD_ISSET(sp->socket, read_setP) && !sp->sender) {\n\t    if ((r = sp->rcv(sp)) < 0) {\n\t\ti_errno = IESTREAMREAD;\n\t\treturn r;\n\t    }\n\t    test->bytes_received += r;\n\t    ++test->blocks_received;\n\t    FD_CLR(sp->socket, read_setP);\n\t}\n    }\n\n    return 0;\n}\n\nint\niperf_init_test(struct iperf_test *test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n\n    if (test->protocol->init) {\n        if (test->protocol->init(test) < 0)\n            return -1;\n    }\n\n    /* Init each stream. */\n    if (iperf_time_now(&now) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->result->start_time = sp->result->start_time_fixed = now;\n    }\n\n    if (test->on_test_start)\n        test->on_test_start(test);\n\n    return 0;\n}\n\nstatic void\nsend_timer_proc(TimerClientData client_data, struct iperf_time *nowP)\n{\n    struct iperf_stream *sp = client_data.p;\n\n    /* All we do here is set or clear the flag saying that this stream may\n    ** be sent to.  The actual sending gets done in the send proc, after\n    ** checking the flag.\n    */\n    iperf_check_throttle(sp, nowP);\n}\n\nint\niperf_create_send_timers(struct iperf_test * test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n    TimerClientData cd;\n\n    if (iperf_time_now(&now) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        sp->green_light = 1;\n\tif (test->settings->rate != 0 && sp->sender) {\n\t    cd.p = sp;\n\t    sp->send_timer = tmr_create(NULL, send_timer_proc, cd, test->settings->pacing_timer, 1);\n\t    if (sp->send_timer == NULL) {\n\t\ti_errno = IEINITTEST;\n\t\treturn -1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n#if defined(HAVE_SSL)\nint test_is_authorized(struct iperf_test *test){\n    if ( !(test->server_rsa_private_key && test->server_authorized_users)) {\n        return 0;\n    }\n\n    if (test->settings->authtoken){\n        char *username = NULL, *password = NULL;\n        time_t ts;\n        int rc = decode_auth_setting(test->debug, test->settings->authtoken, test->server_rsa_private_key, &username, &password, &ts);\n\tif (rc) {\n\t    return -1;\n\t}\n        int ret = check_authentication(username, password, ts, test->server_authorized_users, test->server_skew_threshold);\n        if (ret == 0){\n            if (test->debug) {\n              iperf_printf(test, report_authentication_succeeded, username, ts);\n            }\n            free(username);\n            free(password);\n            return 0;\n        } else {\n            if (test->debug) {\n                iperf_printf(test, report_authentication_failed, ret, username, ts);\n            }\n            free(username);\n            free(password);\n            return -1;\n        }\n    }\n    return -1;\n}\n#endif //HAVE_SSL\n\n/**\n * iperf_exchange_parameters - handles the param_Exchange part for client\n *\n */\n\nint\niperf_exchange_parameters(struct iperf_test *test)\n{\n    int s;\n    int32_t err;\n\n    if (test->role == 'c') {\n\n        if (send_parameters(test) < 0)\n            return -1;\n\n    } else {\n\n        if (get_parameters(test) < 0)\n            return -1;\n\n#if defined(HAVE_SSL)\n        if (test_is_authorized(test) < 0){\n            if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            i_errno = IEAUTHTEST;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n#endif //HAVE_SSL\n\n        if ((s = test->protocol->listen(test)) < 0) {\n\t        if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            err = htonl(errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n\n        FD_SET(s, &test->read_set);\n        test->max_fd = (s > test->max_fd) ? s : test->max_fd;\n        test->prot_listener = s;\n\n        // Send the control message to create streams and start the test\n\tif (iperf_set_send_state(test, CREATE_STREAMS) != 0)\n            return -1;\n\n    }\n\n    return 0;\n}\n\n/*************************************************************/\n\nint\niperf_exchange_results(struct iperf_test *test)\n{\n    if (test->role == 'c') {\n        /* Send results to server. */\n\tif (send_results(test) < 0)\n            return -1;\n        /* Get server results. */\n        if (get_results(test) < 0)\n            return -1;\n    } else {\n        /* Get client results. */\n        if (get_results(test) < 0)\n            return -1;\n        /* Send results to client. */\n\tif (send_results(test) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n/*************************************************************/\n\nstatic int\nsend_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n\t    cJSON_AddTrueToObject(j, \"tcp\");\n\telse if (test->protocol->id == Pudp)\n\t    cJSON_AddTrueToObject(j, \"udp\");\n        else if (test->protocol->id == Psctp)\n            cJSON_AddTrueToObject(j, \"sctp\");\n\tcJSON_AddNumberToObject(j, \"omit\", test->omit);\n\tif (test->server_affinity != -1)\n\t    cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);\n\tcJSON_AddNumberToObject(j, \"time\", test->duration);\n        cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);\n        cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);\n\tif (test->settings->mss)\n\t    cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);\n\tif (test->no_delay)\n\t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddNumberToObject(j, \"parallel\", test->num_streams);\n\tif (test->reverse)\n\t    cJSON_AddTrueToObject(j, \"reverse\");\n\tif (test->bidirectional)\n\t            cJSON_AddTrueToObject(j, \"bidirectional\");\n\tif (test->settings->socket_bufsize)\n\t    cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);\n\tif (test->settings->blksize)\n\t    cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);\n\tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);\n\tif (test->settings->fqrate)\n\t    cJSON_AddNumberToObject(j, \"fqrate\", test->settings->fqrate);\n\tif (test->settings->pacing_timer)\n\t    cJSON_AddNumberToObject(j, \"pacing_timer\", test->settings->pacing_timer);\n\tif (test->settings->burst)\n\t    cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);\n\tif (test->settings->tos)\n\t    cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);\n\tif (test->settings->flowlabel)\n\t    cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);\n\tif (test->title)\n\t    cJSON_AddStringToObject(j, \"title\", test->title);\n\tif (test->extra_data)\n\t    cJSON_AddStringToObject(j, \"extra_data\", test->extra_data);\n\tif (test->congestion)\n\t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n\tif (test->congestion_used)\n\t    cJSON_AddStringToObject(j, \"congestion_used\", test->congestion_used);\n\tif (test->get_server_output)\n\t    cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n\tif (test->udp_counters_64bit)\n\t    cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));\n\tif (test->repeating_payload)\n\t    cJSON_AddNumberToObject(j, \"repeating_payload\", test->repeating_payload);\n\tif (test->zerocopy)\n\t    cJSON_AddNumberToObject(j, \"zerocopy\", test->zerocopy);\n#if defined(HAVE_DONT_FRAGMENT)\n\tif (test->settings->dont_fragment)\n\t    cJSON_AddNumberToObject(j, \"dont_fragment\", test->settings->dont_fragment);\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n\t/* Send authentication parameters */\n\tif (test->settings->client_username && test->settings->client_password && test->settings->client_rsa_pubkey){\n\t    int rc = encode_auth_setting(test->settings->client_username, test->settings->client_password, test->settings->client_rsa_pubkey, &test->settings->authtoken);\n\n\t    if (rc) {\n\t\tcJSON_Delete(j);\n\t\ti_errno = IESENDPARAMS;\n\t\treturn -1;\n\t    }\n\n\t    cJSON_AddStringToObject(j, \"authtoken\", test->settings->authtoken);\n\t}\n#endif // HAVE_SSL\n\tcJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);\n\n\tif (test->debug) {\n\t    char *str = cJSON_Print(j);\n\t    printf(\"send_parameters:\\n%s\\n\", str);\n\t    cJSON_free(str);\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_p;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVPARAMS;\n        r = -1;\n    } else {\n\tif (test->debug) {\n            char *str;\n            str = cJSON_Print(j);\n            printf(\"get_parameters:\\n%s\\n\", str );\n            cJSON_free(str);\n\t}\n\n\tif ((j_p = cJSON_GetObjectItem(j, \"tcp\")) != NULL)\n\t    set_protocol(test, Ptcp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp\")) != NULL)\n\t    set_protocol(test, Pudp);\n        if ((j_p = cJSON_GetObjectItem(j, \"sctp\")) != NULL)\n            set_protocol(test, Psctp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"omit\")) != NULL)\n\t    test->omit = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"server_affinity\")) != NULL)\n\t    test->server_affinity = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"time\")) != NULL)\n\t    test->duration = j_p->valueint;\n        test->settings->bytes = 0;\n\tif ((j_p = cJSON_GetObjectItem(j, \"num\")) != NULL)\n\t    test->settings->bytes = j_p->valueint;\n        test->settings->blocks = 0;\n\tif ((j_p = cJSON_GetObjectItem(j, \"blockcount\")) != NULL)\n\t    test->settings->blocks = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"MSS\")) != NULL)\n\t    test->settings->mss = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"nodelay\")) != NULL)\n\t    test->no_delay = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"parallel\")) != NULL)\n\t    test->num_streams = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"reverse\")) != NULL)\n\t    iperf_set_test_reverse(test, 1);\n        if ((j_p = cJSON_GetObjectItem(j, \"bidirectional\")) != NULL)\n            iperf_set_test_bidirectional(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"window\")) != NULL)\n\t    test->settings->socket_bufsize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"len\")) != NULL)\n\t    test->settings->blksize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"bandwidth\")) != NULL)\n\t    test->settings->rate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"fqrate\")) != NULL)\n\t    test->settings->fqrate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"pacing_timer\")) != NULL)\n\t    test->settings->pacing_timer = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"burst\")) != NULL)\n\t    test->settings->burst = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"TOS\")) != NULL)\n\t    test->settings->tos = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"flowlabel\")) != NULL)\n\t    test->settings->flowlabel = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"title\")) != NULL)\n\t    test->title = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"extra_data\")) != NULL)\n\t    test->extra_data = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion\")) != NULL)\n\t    test->congestion = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion_used\")) != NULL)\n\t    test->congestion_used = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"get_server_output\")) != NULL)\n\t    iperf_set_test_get_server_output(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp_counters_64bit\")) != NULL)\n\t    iperf_set_test_udp_counters_64bit(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"repeating_payload\")) != NULL)\n\t    test->repeating_payload = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"zerocopy\")) != NULL)\n\t    test->zerocopy = j_p->valueint;\n#if defined(HAVE_DONT_FRAGMENT)\n\tif ((j_p = cJSON_GetObjectItem(j, \"dont_fragment\")) != NULL)\n\t    test->settings->dont_fragment = j_p->valueint;\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n\tif ((j_p = cJSON_GetObjectItem(j, \"authtoken\")) != NULL)\n        test->settings->authtoken = strdup(j_p->valuestring);\n#endif //HAVE_SSL\n\tif (test->mode && test->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\t    test->sender_has_retransmits = 1;\n\tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(test->json_start, \"target_bitrate\", test->settings->rate);\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nsend_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_streams;\n    struct iperf_stream *sp;\n    cJSON *j_stream;\n    int sender_has_retransmits;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_time temp_time;\n    double start_time, end_time;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IEPACKAGERESULTS;\n\tr = -1;\n    } else {\n\tcJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n\tif ( test->mode == RECEIVER )\n\t    sender_has_retransmits = -1;\n\telse\n\t    sender_has_retransmits = test->sender_has_retransmits;\n\tcJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n\tif ( test->congestion_used ) {\n\t    cJSON_AddStringToObject(j, \"congestion_used\", test->congestion_used);\n\t}\n\n\t/* If on the server and sending server output, then do this */\n\tif (test->role == 's' && test->get_server_output) {\n\t    if (test->json_output) {\n\t\t/* Add JSON output */\n\t\tcJSON_AddItemReferenceToObject(j, \"server_output_json\", test->json_top);\n\t    }\n\t    else {\n\t\t/* Add textual output */\n\t\tsize_t buflen = 0;\n\n\t\t/* Figure out how much room we need to hold the complete output string */\n\t\tstruct iperf_textline *t;\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    buflen += strlen(t->line);\n\t\t}\n\n\t\t/* Allocate and build it up from the component lines */\n\t\tchar *output = calloc(buflen + 1, 1);\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    strncat(output, t->line, buflen);\n\t\t    buflen -= strlen(t->line);\n\t\t}\n\n\t\tcJSON_AddStringToObject(j, \"server_output_text\", output);\n        free(output);\n\t    }\n\t}\n\n\tj_streams = cJSON_CreateArray();\n\tif (j_streams == NULL) {\n\t    i_errno = IEPACKAGERESULTS;\n\t    r = -1;\n\t} else {\n\t    cJSON_AddItemToObject(j, \"streams\", j_streams);\n\t    SLIST_FOREACH(sp, &test->streams, streams) {\n\t\tj_stream = cJSON_CreateObject();\n\t\tif (j_stream == NULL) {\n\t\t    i_errno = IEPACKAGERESULTS;\n\t\t    r = -1;\n\t\t} else {\n\t\t    cJSON_AddItemToArray(j_streams, j_stream);\n\t\t    bytes_transferred = sp->sender ? (sp->result->bytes_sent - sp->result->bytes_sent_omit) : sp->result->bytes_received;\n\t\t    retransmits = (sp->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n\t\t    cJSON_AddNumberToObject(j_stream, \"id\", sp->id);\n\t\t    cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);\n\t\t    cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);\n\t\t    cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);\n\t\t    cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);\n                    cJSON_AddNumberToObject(j_stream, \"omitted_errors\", sp->omitted_cnt_error);\n\t\t    cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);\n                    cJSON_AddNumberToObject(j_stream, \"omitted_packets\", sp->omitted_packet_count);\n\n\t\t    iperf_time_diff(&sp->result->start_time, &sp->result->start_time, &temp_time);\n\t\t    start_time = iperf_time_in_secs(&temp_time);\n\t\t    iperf_time_diff(&sp->result->start_time, &sp->result->end_time, &temp_time);\n\t\t    end_time = iperf_time_in_secs(&temp_time);\n\t\t    cJSON_AddNumberToObject(j_stream, \"start_time\", start_time);\n\t\t    cJSON_AddNumberToObject(j_stream, \"end_time\", end_time);\n\n\t\t}\n\t    }\n\t    if (r == 0 && test->debug) {\n                char *str = cJSON_Print(j);\n\t\tprintf(\"send_results\\n%s\\n\", str);\n                cJSON_free(str);\n\t    }\n\t    if (r == 0 && JSON_write(test->ctrl_sck, j) < 0) {\n\t\ti_errno = IESENDRESULTS;\n\t\tr = -1;\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_remote_congestion_used;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_omitted_errors;\n    cJSON *j_packets;\n    cJSON *j_omitted_packets;\n    cJSON *j_server_output;\n    cJSON *j_start_time, *j_end_time;\n    int sid;\n    int64_t cerror, pcount, omitted_cerror, omitted_pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n                char *str = cJSON_Print(j);\n                printf(\"get_results\\n%s\\n\", str);\n                cJSON_free(str);\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if ( test->mode == RECEIVER ) {\n\t        test->sender_has_retransmits = result_has_retransmits;\n\t        test->other_side_has_retransmits = 0;\n\t    }\n\t    else if ( test->mode == BIDIRECTIONAL )\n\t        test->other_side_has_retransmits = result_has_retransmits;\n\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n                        j_omitted_errors = cJSON_GetObjectItem(j_stream, \"omitted_errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n                        j_omitted_packets = cJSON_GetObjectItem(j_stream, \"omitted_packets\");\n\t\t\tj_start_time = cJSON_GetObjectItem(j_stream, \"start_time\");\n\t\t\tj_end_time = cJSON_GetObjectItem(j_stream, \"end_time\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n                        } else if ( (j_omitted_errors == NULL && j_omitted_packets != NULL) || (j_omitted_errors != NULL && j_omitted_packets == NULL) ) {\n                            /* For backward compatibility allow to not receive \"omitted\" statistcs */\n                            i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuedouble;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n                            if (j_omitted_packets != NULL) {\n                                omitted_cerror = j_omitted_errors->valueint;\n                                omitted_pcount = j_omitted_packets->valueint;\n                            }\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (sp->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->peer_packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n                                    if (j_omitted_packets != NULL) {\n                                        sp->omitted_cnt_error = omitted_cerror;\n                                        sp->peer_omitted_packet_count = omitted_pcount;\n                                    } else {\n                                        sp->peer_omitted_packet_count = sp->omitted_packet_count;\n                                        if (sp->peer_omitted_packet_count > 0) {\n                                            /* -1 indicates unknown error count since it includes the omitted count */\n                                            sp->omitted_cnt_error = (sp->cnt_error > 0) ? -1 : 0;\n                                        } else {\n                                            sp->omitted_cnt_error = sp->cnt_error;\n                                        }\n                                    }\n\t\t\t\t    /*\n\t\t\t\t     * We have to handle the possibility that\n\t\t\t\t     * start_time and end_time might not be\n\t\t\t\t     * available; this is the case for older (pre-3.2)\n\t\t\t\t     * servers.\n\t\t\t\t     *\n\t\t\t\t     * We need to have result structure members to hold\n\t\t\t\t     * the both sides' start_time and end_time.\n\t\t\t\t     */\n\t\t\t\t    if (j_start_time && j_end_time) {\n\t\t\t\t\tsp->result->receiver_time = j_end_time->valuedouble - j_start_time->valuedouble;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\tsp->result->receiver_time = 0.0;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    sp->peer_packet_count = pcount;\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n                                    if (j_omitted_packets != NULL) {\n                                        sp->peer_omitted_packet_count = omitted_pcount;\n                                    } else {\n                                        sp->peer_omitted_packet_count = sp->peer_packet_count;\n                                    }\n\t\t\t\t    if (j_start_time && j_end_time) {\n\t\t\t\t\tsp->result->sender_time = j_end_time->valuedouble - j_start_time->valuedouble;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\tsp->result->sender_time = 0.0;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tj_remote_congestion_used = cJSON_GetObjectItem(j, \"congestion_used\");\n\tif (j_remote_congestion_used != NULL) {\n\t    test->remote_congestion_used = strdup(j_remote_congestion_used->valuestring);\n\t}\n\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nJSON_write(int fd, cJSON *json)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    int r = 0;\n\n    str = cJSON_PrintUnformatted(json);\n    if (str == NULL)\n\tr = -1;\n    else {\n\thsize = strlen(str);\n\tnsize = htonl(hsize);\n\tif (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)\n\t    r = -1;\n\telse {\n\t    if (Nwrite(fd, str, hsize, Ptcp) < 0)\n\t\tr = -1;\n\t}\n\tcJSON_free(str);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n\n    /*\n     * Read a four-byte integer, which is the length of the JSON to follow.\n     * Then read the JSON into a buffer and parse it.  Return a parsed JSON\n     * structure, NULL if there was an error.\n     */\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\t/* Allocate a buffer to hold the JSON */\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t/* +1 for trailing null */\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\t/*\n\t\t * We should be reading in the number of bytes corresponding to the\n\t\t * length in that 4-byte integer.  If we don't the socket might have\n\t\t * prematurely closed.  Only do the JSON parsing if we got the\n\t\t * correct number of bytes.\n\t\t */\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}\n\n/*************************************************************/\n/**\n * add_to_interval_list -- adds new interval to the interval_list\n */\n\nvoid\nadd_to_interval_list(struct iperf_stream_result * rp, struct iperf_interval_results * new)\n{\n    struct iperf_interval_results *irp;\n\n    irp = (struct iperf_interval_results *) malloc(sizeof(struct iperf_interval_results));\n    memcpy(irp, new, sizeof(struct iperf_interval_results));\n    TAILQ_INSERT_TAIL(&rp->interval_results, irp, irlistentries);\n}\n\n\n/************************************************************/\n\n/**\n * connect_msg -- displays connection message\n * denoting sender/receiver details\n *\n */\n\nvoid\nconnect_msg(struct iperf_stream *sp)\n{\n    char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];\n    int lport, rport;\n\n    if (getsockdomain(sp->socket) == AF_INET) {\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->remote_addr)->sin_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in *) &sp->local_addr)->sin_port);\n        rport = ntohs(((struct sockaddr_in *) &sp->remote_addr)->sin_port);\n    } else {\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->local_addr)->sin6_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->remote_addr)->sin6_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in6 *) &sp->local_addr)->sin6_port);\n        rport = ntohs(((struct sockaddr_in6 *) &sp->remote_addr)->sin6_port);\n    }\n\n    if (sp->test->json_output)\n        cJSON_AddItemToArray(sp->test->json_connected, iperf_json_printf(\"socket: %d  local_host: %s  local_port: %d  remote_host: %s  remote_port: %d\", (int64_t) sp->socket, ipl, (int64_t) lport, ipr, (int64_t) rport));\n    else\n\tiperf_printf(sp->test, report_connected, sp->socket, ipl, lport, ipr, rport);\n}\n\n\n/**************************************************************************/\n\nstruct iperf_test *\niperf_new_test()\n{\n    struct iperf_test *test;\n\n    test = (struct iperf_test *) malloc(sizeof(struct iperf_test));\n    if (!test) {\n        i_errno = IENEWTEST;\n        return NULL;\n    }\n    /* initialize everything to zero */\n    memset(test, 0, sizeof(struct iperf_test));\n\n    test->settings = (struct iperf_settings *) malloc(sizeof(struct iperf_settings));\n    if (!test->settings) {\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->settings, 0, sizeof(struct iperf_settings));\n\n    test->bitrate_limit_intervals_traffic_bytes = (iperf_size_t *) malloc(sizeof(iperf_size_t) * MAX_INTERVAL);\n    if (!test->bitrate_limit_intervals_traffic_bytes) {\n        free(test->settings);\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->bitrate_limit_intervals_traffic_bytes, 0, sizeof(sizeof(iperf_size_t) * MAX_INTERVAL));\n\n    /* By default all output goes to stdout */\n    test->outfile = stdout;\n\n    return test;\n}\n\n/**************************************************************************/\n\nstruct protocol *\nprotocol_new(void)\n{\n    struct protocol *proto;\n\n    proto = malloc(sizeof(struct protocol));\n    if(!proto) {\n        return NULL;\n    }\n    memset(proto, 0, sizeof(struct protocol));\n\n    return proto;\n}\n\nvoid\nprotocol_free(struct protocol *proto)\n{\n    free(proto);\n}\n\n/**************************************************************************/\nint\niperf_defaults(struct iperf_test *testp)\n{\n    struct protocol *tcp, *udp;\n#if defined(HAVE_SCTP_H)\n    struct protocol *sctp;\n#endif /* HAVE_SCTP_H */\n\n    testp->omit = OMIT;\n    testp->duration = DURATION;\n    testp->diskfile_name = (char*) 0;\n    testp->affinity = -1;\n    testp->server_affinity = -1;\n    TAILQ_INIT(&testp->xbind_addrs);\n#if defined(HAVE_CPUSET_SETAFFINITY)\n    CPU_ZERO(&testp->cpumask);\n#endif /* HAVE_CPUSET_SETAFFINITY */\n    testp->title = NULL;\n    testp->extra_data = NULL;\n    testp->congestion = NULL;\n    testp->congestion_used = NULL;\n    testp->remote_congestion_used = NULL;\n    testp->server_port = PORT;\n    testp->ctrl_sck = -1;\n    testp->listener = -1;\n    testp->prot_listener = -1;\n    testp->other_side_has_retransmits = 0;\n\n    testp->stats_callback = iperf_stats_callback;\n    testp->reporter_callback = iperf_reporter_callback;\n\n    testp->stats_interval = testp->reporter_interval = 1;\n    testp->num_streams = 1;\n\n    testp->settings->domain = AF_UNSPEC;\n    testp->settings->unit_format = 'a';\n    testp->settings->socket_bufsize = 0;    /* use autotuning */\n    testp->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    testp->settings->rate = 0;\n    testp->settings->bitrate_limit = 0;\n    testp->settings->bitrate_limit_interval = 5;\n    testp->settings->bitrate_limit_stats_per_interval = 0;\n    testp->settings->fqrate = 0;\n    testp->settings->pacing_timer = DEFAULT_PACING_TIMER;\n    testp->settings->burst = 0;\n    testp->settings->mss = 0;\n    testp->settings->bytes = 0;\n    testp->settings->blocks = 0;\n    testp->settings->connect_timeout = -1;\n    testp->settings->rcv_timeout.secs = DEFAULT_NO_MSG_RCVD_TIMEOUT / SEC_TO_mS;\n    testp->settings->rcv_timeout.usecs = (DEFAULT_NO_MSG_RCVD_TIMEOUT % SEC_TO_mS) * mS_TO_US;\n    testp->zerocopy = 0;\n\n    memset(testp->cookie, 0, COOKIE_SIZE);\n\n    testp->multisend = 10;\t/* arbitrary */\n\n    /* Set up protocol list */\n    SLIST_INIT(&testp->streams);\n    SLIST_INIT(&testp->protocols);\n\n    tcp = protocol_new();\n    if (!tcp)\n        return -1;\n\n    tcp->id = Ptcp;\n    tcp->name = \"TCP\";\n    tcp->accept = iperf_tcp_accept;\n    tcp->listen = iperf_tcp_listen;\n    tcp->connect = iperf_tcp_connect;\n    tcp->send = iperf_tcp_send;\n    tcp->recv = iperf_tcp_recv;\n    tcp->init = NULL;\n    SLIST_INSERT_HEAD(&testp->protocols, tcp, protocols);\n\n    udp = protocol_new();\n    if (!udp) {\n        protocol_free(tcp);\n        return -1;\n    }\n\n    udp->id = Pudp;\n    udp->name = \"UDP\";\n    udp->accept = iperf_udp_accept;\n    udp->listen = iperf_udp_listen;\n    udp->connect = iperf_udp_connect;\n    udp->send = iperf_udp_send;\n    udp->recv = iperf_udp_recv;\n    udp->init = iperf_udp_init;\n    SLIST_INSERT_AFTER(tcp, udp, protocols);\n\n    set_protocol(testp, Ptcp);\n\n#if defined(HAVE_SCTP_H)\n    sctp = protocol_new();\n    if (!sctp) {\n        protocol_free(tcp);\n        protocol_free(udp);\n        return -1;\n    }\n\n    sctp->id = Psctp;\n    sctp->name = \"SCTP\";\n    sctp->accept = iperf_sctp_accept;\n    sctp->listen = iperf_sctp_listen;\n    sctp->connect = iperf_sctp_connect;\n    sctp->send = iperf_sctp_send;\n    sctp->recv = iperf_sctp_recv;\n    sctp->init = iperf_sctp_init;\n\n    SLIST_INSERT_AFTER(udp, sctp, protocols);\n#endif /* HAVE_SCTP_H */\n\n    testp->on_new_stream = iperf_on_new_stream;\n    testp->on_test_start = iperf_on_test_start;\n    testp->on_connect = iperf_on_connect;\n    testp->on_test_finish = iperf_on_test_finish;\n\n    TAILQ_INIT(&testp->server_output_list);\n\n    return 0;\n}\n\n\n/**************************************************************************/\nvoid\niperf_free_test(struct iperf_test *test)\n{\n    struct protocol *prot;\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->server_hostname)\n\tfree(test->server_hostname);\n    if (test->tmp_template)\n\tfree(test->tmp_template);\n    if (test->bind_address)\n\tfree(test->bind_address);\n    if (test->bind_dev)\n\tfree(test->bind_dev);\n    if (!TAILQ_EMPTY(&test->xbind_addrs)) {\n        struct xbind_entry *xbe;\n\n        while (!TAILQ_EMPTY(&test->xbind_addrs)) {\n            xbe = TAILQ_FIRST(&test->xbind_addrs);\n            TAILQ_REMOVE(&test->xbind_addrs, xbe, link);\n            if (xbe->ai)\n                freeaddrinfo(xbe->ai);\n            free(xbe->name);\n            free(xbe);\n        }\n    }\n#if defined(HAVE_SSL)\n\n    if (test->server_rsa_private_key)\n      EVP_PKEY_free(test->server_rsa_private_key);\n    test->server_rsa_private_key = NULL;\n\n    free(test->settings->authtoken);\n    test->settings->authtoken = NULL;\n\n    free(test->settings->client_username);\n    test->settings->client_username = NULL;\n\n    free(test->settings->client_password);\n    test->settings->client_password = NULL;\n\n    if (test->settings->client_rsa_pubkey)\n      EVP_PKEY_free(test->settings->client_rsa_pubkey);\n    test->settings->client_rsa_pubkey = NULL;\n#endif /* HAVE_SSL */\n\n    if (test->settings)\n    free(test->settings);\n    if (test->title)\n\tfree(test->title);\n    if (test->extra_data)\n\tfree(test->extra_data);\n    if (test->congestion)\n\tfree(test->congestion);\n    if (test->congestion_used)\n\tfree(test->congestion_used);\n    if (test->remote_congestion_used)\n\tfree(test->remote_congestion_used);\n    if (test->timestamp_format)\n\tfree(test->timestamp_format);\n    if (test->omit_timer != NULL)\n\ttmr_cancel(test->omit_timer);\n    if (test->timer != NULL)\n\ttmr_cancel(test->timer);\n    if (test->stats_timer != NULL)\n\ttmr_cancel(test->stats_timer);\n    if (test->reporter_timer != NULL)\n\ttmr_cancel(test->reporter_timer);\n\n    /* Free protocol list */\n    while (!SLIST_EMPTY(&test->protocols)) {\n        prot = SLIST_FIRST(&test->protocols);\n        SLIST_REMOVE_HEAD(&test->protocols, protocols);\n        free(prot);\n    }\n\n    if (test->logfile) {\n\tfree(test->logfile);\n\ttest->logfile = NULL;\n        iperf_close_logfile(test);\n    }\n\n    if (test->server_output_text) {\n\tfree(test->server_output_text);\n\ttest->server_output_text = NULL;\n    }\n\n    if (test->json_output_string) {\n\tfree(test->json_output_string);\n\ttest->json_output_string = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n\n    /* sctp_bindx: do not free the arguments, only the resolver results */\n    if (!TAILQ_EMPTY(&test->xbind_addrs)) {\n        struct xbind_entry *xbe;\n\n        TAILQ_FOREACH(xbe, &test->xbind_addrs, link) {\n            if (xbe->ai) {\n                freeaddrinfo(xbe->ai);\n                xbe->ai = NULL;\n            }\n        }\n    }\n\n    /* Free interval's traffic array for average rate calculations */\n    if (test->bitrate_limit_intervals_traffic_bytes != NULL)\n        free(test->bitrate_limit_intervals_traffic_bytes);\n\n    /* XXX: Why are we setting these values to NULL? */\n    // test->streams = NULL;\n    test->stats_callback = NULL;\n    test->reporter_callback = NULL;\n    free(test);\n}\n\n\nvoid\niperf_reset_test(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    int i;\n\n    iperf_close_logfile(test);\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->omit_timer != NULL) {\n\ttmr_cancel(test->omit_timer);\n\ttest->omit_timer = NULL;\n    }\n    if (test->timer != NULL) {\n\ttmr_cancel(test->timer);\n\ttest->timer = NULL;\n    }\n    if (test->stats_timer != NULL) {\n\ttmr_cancel(test->stats_timer);\n\ttest->stats_timer = NULL;\n    }\n    if (test->reporter_timer != NULL) {\n\ttmr_cancel(test->reporter_timer);\n\ttest->reporter_timer = NULL;\n    }\n    test->done = 0;\n\n    SLIST_INIT(&test->streams);\n\n    if (test->remote_congestion_used)\n        free(test->remote_congestion_used);\n    test->remote_congestion_used = NULL;\n    test->role = 's';\n    test->mode = RECEIVER;\n    test->sender_has_retransmits = 0;\n    set_protocol(test, Ptcp);\n    test->omit = OMIT;\n    test->duration = DURATION;\n    test->server_affinity = -1;\n#if defined(HAVE_CPUSET_SETAFFINITY)\n    CPU_ZERO(&test->cpumask);\n#endif /* HAVE_CPUSET_SETAFFINITY */\n    test->state = 0;\n\n    test->ctrl_sck = -1;\n    test->listener = -1;\n    test->prot_listener = -1;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n\n    test->bytes_received = 0;\n    test->blocks_received = 0;\n\n    test->other_side_has_retransmits = 0;\n\n    test->bitrate_limit_stats_count = 0;\n    test->bitrate_limit_last_interval_index = 0;\n    test->bitrate_limit_exceeded = 0;\n\n    for (i = 0; i < MAX_INTERVAL; i++)\n        test->bitrate_limit_intervals_traffic_bytes[i] = 0;\n\n    test->reverse = 0;\n    test->bidirectional = 0;\n    test->no_delay = 0;\n\n    FD_ZERO(&test->read_set);\n    FD_ZERO(&test->write_set);\n\n    test->num_streams = 1;\n    test->settings->socket_bufsize = 0;\n    test->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    test->settings->rate = 0;\n    test->settings->burst = 0;\n    test->settings->mss = 0;\n    test->settings->tos = 0;\n    test->settings->dont_fragment = 0;\n    test->zerocopy = 0;\n\n#if defined(HAVE_SSL)\n    if (test->settings->authtoken) {\n        free(test->settings->authtoken);\n        test->settings->authtoken = NULL;\n    }\n    if (test->settings->client_username) {\n        free(test->settings->client_username);\n        test->settings->client_username = NULL;\n    }\n    if (test->settings->client_password) {\n        free(test->settings->client_password);\n        test->settings->client_password = NULL;\n    }\n    if (test->settings->client_rsa_pubkey) {\n        EVP_PKEY_free(test->settings->client_rsa_pubkey);\n        test->settings->client_rsa_pubkey = NULL;\n    }\n#endif /* HAVE_SSL */\n\n    memset(test->cookie, 0, COOKIE_SIZE);\n    test->multisend = 10;\t/* arbitrary */\n    test->udp_counters_64bit = 0;\n    if (test->title) {\n\tfree(test->title);\n\ttest->title = NULL;\n    }\n    if (test->extra_data) {\n\tfree(test->extra_data);\n\ttest->extra_data = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n}\n\n\n/* Reset all of a test's stats back to zero.  Called when the omitting\n** period is over.\n*/\nvoid\niperf_reset_stats(struct iperf_test *test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n    iperf_time_now(&now);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->omitted_packet_count = sp->packet_count;\n        sp->omitted_cnt_error = sp->cnt_error;\n        sp->omitted_outoforder_packets = sp->outoforder_packets;\n\tsp->jitter = 0;\n\trp = sp->result;\n        rp->bytes_sent_omit = rp->bytes_sent;\n        rp->bytes_received = 0;\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n\tif (test->sender_has_retransmits == 1) {\n\t    struct iperf_interval_results ir; /* temporary results structure */\n\t    save_tcpinfo(sp, &ir);\n\t    rp->stream_prev_total_retrans = get_total_retransmits(&ir);\n\t}\n\trp->stream_retrans = 0;\n\trp->start_time = now;\n    }\n}\n\n\n/**************************************************************************/\n\n/**\n * Gather statistics during a test.\n * This function works for both the client and server side.\n */\nvoid\niperf_stats_callback(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp = NULL;\n    struct iperf_interval_results *irp, temp;\n    struct iperf_time temp_time;\n    iperf_size_t total_interval_bytes_transferred = 0;\n\n    temp.omitted = test->omitting;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        rp = sp->result;\n\ttemp.bytes_transferred = sp->sender ? rp->bytes_sent_this_interval : rp->bytes_received_this_interval;\n\n        // Total bytes transferred this interval\n\ttotal_interval_bytes_transferred += rp->bytes_sent_this_interval + rp->bytes_received_this_interval;\n\n\tirp = TAILQ_LAST(&rp->interval_results, irlisthead);\n        /* result->end_time contains timestamp of previous interval */\n        if ( irp != NULL ) /* not the 1st interval */\n            memcpy(&temp.interval_start_time, &rp->end_time, sizeof(struct iperf_time));\n        else /* or use timestamp from beginning */\n            memcpy(&temp.interval_start_time, &rp->start_time, sizeof(struct iperf_time));\n        /* now save time of end of this interval */\n        iperf_time_now(&rp->end_time);\n        memcpy(&temp.interval_end_time, &rp->end_time, sizeof(struct iperf_time));\n        iperf_time_diff(&temp.interval_start_time, &temp.interval_end_time, &temp_time);\n        temp.interval_duration = iperf_time_in_secs(&temp_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if ( has_tcpinfo()) {\n\t\tsave_tcpinfo(sp, &temp);\n\t\tif (test->sender_has_retransmits == 1) {\n\t\t    long total_retrans = get_total_retransmits(&temp);\n\t\t    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;\n\t\t    rp->stream_retrans += temp.interval_retrans;\n\t\t    rp->stream_prev_total_retrans = total_retrans;\n\n\t\t    temp.snd_cwnd = get_snd_cwnd(&temp);\n\t\t    if (temp.snd_cwnd > rp->stream_max_snd_cwnd) {\n\t\t\trp->stream_max_snd_cwnd = temp.snd_cwnd;\n\t\t    }\n\n\t\t    temp.snd_wnd = get_snd_wnd(&temp);\n\t\t    if (temp.snd_wnd > rp->stream_max_snd_wnd) {\n\t\t\trp->stream_max_snd_wnd = temp.snd_wnd;\n\t\t    }\n\n\t\t    temp.rtt = get_rtt(&temp);\n\t\t    if (temp.rtt > rp->stream_max_rtt) {\n\t\t\trp->stream_max_rtt = temp.rtt;\n\t\t    }\n\t\t    if (rp->stream_min_rtt == 0 ||\n\t\t\ttemp.rtt < rp->stream_min_rtt) {\n\t\t\trp->stream_min_rtt = temp.rtt;\n\t\t    }\n\t\t    rp->stream_sum_rtt += temp.rtt;\n\t\t    rp->stream_count_rtt++;\n\n\t\t    temp.rttvar = get_rttvar(&temp);\n\t\t    temp.pmtu = get_pmtu(&temp);\n\t\t}\n\t    }\n\t} else {\n\t    if (irp == NULL) {\n\t\ttemp.interval_packet_count = sp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error;\n\t    } else {\n\t\ttemp.interval_packet_count = sp->packet_count - irp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error - irp->cnt_error;\n\t    }\n\t    temp.packet_count = sp->packet_count;\n\t    temp.jitter = sp->jitter;\n\t    temp.outoforder_packets = sp->outoforder_packets;\n\t    temp.cnt_error = sp->cnt_error;\n\t}\n        add_to_interval_list(rp, &temp);\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n    }\n\n    /* Verify that total server's throughput is not above specified limit */\n    if (test->role == 's') {\n\tiperf_check_total_rate(test, total_interval_bytes_transferred);\n    }\n}\n\n/**\n * Print intermediate results during a test (interval report).\n * Uses print_interval_results to print the results for each stream,\n * then prints an interval summary for all streams in this\n * interval.\n */\nstatic void\niperf_print_intermediate(struct iperf_test *test)\n{\n    struct iperf_stream *sp = NULL;\n    struct iperf_interval_results *irp;\n    struct iperf_time temp_time;\n    cJSON *json_interval;\n    cJSON *json_interval_streams;\n\n    int lower_mode, upper_mode;\n    int current_mode;\n\n    /*\n     * Due to timing oddities, there can be cases, especially on the\n     * server side, where at the end of a test there is a fairly short\n     * interval with no data transferred.  This could caused by\n     * the control and data flows sharing the same path in the network,\n     * and having the control messages for stopping the test being\n     * queued behind the data packets.\n     *\n     * We'd like to try to omit that last interval when it happens, to\n     * avoid cluttering data and output with useless stuff.\n     * So we're going to try to ignore very short intervals (less than\n     * 10% of the interval time) that have no data.\n     */\n    int interval_ok = 0;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tirp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n\tif (irp) {\n\t    iperf_time_diff(&irp->interval_start_time, &irp->interval_end_time, &temp_time);\n\t    double interval_len = iperf_time_in_secs(&temp_time);\n\t    if (test->debug) {\n\t\tprintf(\"interval_len %f bytes_transferred %\" PRIu64 \"\\n\", interval_len, irp->bytes_transferred);\n\t    }\n\n\t    /*\n\t     * If the interval is at least 10% the normal interval\n\t     * length, or if there were actual bytes transferred,\n\t     * then we want to keep this interval.\n\t     */\n\t    if (interval_len >= test->stats_interval * 0.10 ||\n\t\tirp->bytes_transferred > 0) {\n\t\tinterval_ok = 1;\n\t\tif (test->debug) {\n\t\t    printf(\"interval forces keep\\n\");\n\t\t}\n\t    }\n\t}\n    }\n    if (!interval_ok) {\n\tif (test->debug) {\n\t    printf(\"ignoring short interval with no data\\n\");\n\t}\n\treturn;\n    }\n\n    if (test->json_output) {\n        json_interval = cJSON_CreateObject();\n\tif (json_interval == NULL)\n\t    return;\n\tcJSON_AddItemToArray(test->json_intervals, json_interval);\n        json_interval_streams = cJSON_CreateArray();\n\tif (json_interval_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(json_interval, \"streams\", json_interval_streams);\n    } else {\n        json_interval = NULL;\n        json_interval_streams = NULL;\n    }\n\n    /*\n     * We must to sum streams separately.\n     * For bidirectional mode we must to display\n     * information about sender and receiver streams.\n     * For client side we must handle sender streams\n     * firstly and receiver streams for server side.\n     * The following design allows us to do this.\n     */\n\n    if (test->mode == BIDIRECTIONAL) {\n        if (test->role == 'c') {\n            lower_mode = -1;\n            upper_mode = 0;\n        } else {\n            lower_mode = 0;\n            upper_mode = 1;\n        }\n    } else {\n        lower_mode = test->mode;\n        upper_mode = lower_mode;\n    }\n\n\n    for (current_mode = lower_mode; current_mode <= upper_mode; ++current_mode) {\n        char ubuf[UNIT_LEN];\n        char nbuf[UNIT_LEN];\n        char mbuf[UNIT_LEN];\n        char zbuf[] = \"          \";\n\n        iperf_size_t bytes = 0;\n        double bandwidth;\n        int retransmits = 0;\n        double start_time, end_time;\n\n        int64_t total_packets = 0, lost_packets = 0;\n        double avg_jitter = 0.0, lost_percent;\n        int stream_must_be_sender = current_mode * current_mode;\n\n        char *sum_name;\n\n        /*  Print stream role just for bidirectional mode. */\n\n        if (test->mode == BIDIRECTIONAL) {\n            sprintf(mbuf, \"[%s-%s]\", stream_must_be_sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n        } else {\n            mbuf[0] = '\\0';\n            zbuf[0] = '\\0';\n        }\n\n        SLIST_FOREACH(sp, &test->streams, streams) {\n            if (sp->sender == stream_must_be_sender) {\n                print_interval_results(test, sp, json_interval_streams);\n                /* sum up all streams */\n                irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n                if (irp == NULL) {\n                    iperf_err(test,\n                            \"iperf_print_intermediate error: interval_results is NULL\");\n                    return;\n                }\n                bytes += irp->bytes_transferred;\n                if (test->protocol->id == Ptcp) {\n                    if (test->sender_has_retransmits == 1) {\n                        retransmits += irp->interval_retrans;\n                    }\n                } else {\n                    total_packets += irp->interval_packet_count;\n                    lost_packets += irp->interval_cnt_error;\n                    avg_jitter += irp->jitter;\n                }\n            }\n        }\n\n        /* next build string with sum of all streams */\n        if (test->num_streams > 1 || test->json_output) {\n            /*\n             * With BIDIR give a different JSON object name to the one sent/receive sums.\n             * The different name is given to the data sent from the server, which is\n             * the \"reverse\" channel.  This makes sure that the name reported on the server\n             * and client are compatible, and the names are the same as with non-bidir,\n             * except for when reverse is used.\n             */\n            sum_name = \"sum\";\n            if (test->mode == BIDIRECTIONAL) {\n                if ((test->role == 'c' && !stream_must_be_sender) ||\n                    (test->role != 'c' && stream_must_be_sender))\n                {\n                    sum_name = \"sum_bidir_reverse\";\n                }\n            }\n\n            sp = SLIST_FIRST(&test->streams); /* reset back to 1st stream */\n            /* Only do this of course if there was a first stream */\n            if (sp) {\n\t    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);    /* use 1st stream for timing info */\n\n\t    unit_snprintf(ubuf, UNIT_LEN, (double) bytes, 'A');\n\t    bandwidth = (double) bytes / (double) irp->interval_duration;\n\t    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n\t    iperf_time_diff(&sp->result->start_time,&irp->interval_start_time, &temp_time);\n\t    start_time = iperf_time_in_secs(&temp_time);\n\t    iperf_time_diff(&sp->result->start_time,&irp->interval_end_time, &temp_time);\n\t    end_time = iperf_time_in_secs(&temp_time);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits == 1 && stream_must_be_sender) {\n                        /* Interval sum, TCP with retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) retransmits, irp->omitted, stream_must_be_sender)); /* XXX irp->omitted or test->omitting? */\n                        else\n                            iperf_printf(test, report_sum_bw_retrans_format, mbuf, start_time, end_time, ubuf, nbuf, retransmits, irp->omitted?report_omitted:\"\"); /* XXX irp->omitted or test->omitting? */\n                    } else {\n                        /* Interval sum, TCP without retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_format, mbuf, start_time, end_time, ubuf, nbuf, test->omitting?report_omitted:\"\");\n                    }\n                } else {\n                    /* Interval sum, UDP. */\n                    if (stream_must_be_sender) {\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) total_packets, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_udp_sender_format, mbuf, start_time, end_time, ubuf, nbuf, zbuf, total_packets, test->omitting?report_omitted:\"\");\n                    } else {\n                        avg_jitter /= test->num_streams;\n                        if (total_packets > 0) {\n                            lost_percent = 100.0 * lost_packets / total_packets;\n                        }\n                        else {\n                            lost_percent = 0.0;\n                        }\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, test->omitting?report_omitted:\"\");\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Print overall summary statistics at the end of a test.\n */\nstatic void\niperf_print_results(struct iperf_test *test)\n{\n\n    cJSON *json_summary_streams = NULL;\n\n    int lower_mode, upper_mode;\n    int current_mode;\n\n    char *sum_sent_name, *sum_received_name, *sum_name;\n\n    int tmp_sender_has_retransmits = test->sender_has_retransmits;\n\n    /* print final summary for all intervals */\n\n    if (test->json_output) {\n        json_summary_streams = cJSON_CreateArray();\n\tif (json_summary_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(test->json_end, \"streams\", json_summary_streams);\n    } else {\n\tiperf_printf(test, \"%s\", report_bw_separator);\n\tif (test->verbose)\n\t    iperf_printf(test, \"%s\", report_summary);\n\tif (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\t    if (test->sender_has_retransmits || test->other_side_has_retransmits) {\n\t        if (test->bidirectional)\n\t            iperf_printf(test, \"%s\", report_bw_retrans_header_bidir);\n\t        else\n\t            iperf_printf(test, \"%s\", report_bw_retrans_header);\n\t    }\n\t    else {\n\t        if (test->bidirectional)\n\t            iperf_printf(test, \"%s\", report_bw_header_bidir);\n\t        else\n\t            iperf_printf(test, \"%s\", report_bw_header);\n\t    }\n\t} else {\n\t    if (test->bidirectional)\n\t        iperf_printf(test, \"%s\", report_bw_udp_header_bidir);\n\t    else\n\t        iperf_printf(test, \"%s\", report_bw_udp_header);\n\t}\n    }\n\n    /*\n     * We must to sum streams separately.\n     * For bidirectional mode we must to display\n     * information about sender and receiver streams.\n     * For client side we must handle sender streams\n     * firstly and receiver streams for server side.\n     * The following design allows us to do this.\n     */\n\n    if (test->mode == BIDIRECTIONAL) {\n        if (test->role == 'c') {\n            lower_mode = -1;\n            upper_mode = 0;\n        } else {\n            lower_mode = 0;\n            upper_mode = 1;\n        }\n    } else {\n        lower_mode = test->mode;\n        upper_mode = lower_mode;\n    }\n\n\n    for (current_mode = lower_mode; current_mode <= upper_mode; ++current_mode) {\n        cJSON *json_summary_stream = NULL;\n        int64_t total_retransmits = 0;\n        int64_t total_packets = 0, lost_packets = 0;\n        int64_t sender_packet_count = 0, receiver_packet_count = 0; /* for this stream, this interval */\n        int64_t sender_omitted_packet_count = 0, receiver_omitted_packet_count = 0; /* for this stream, this interval */\n        int64_t sender_total_packets = 0, receiver_total_packets = 0; /* running total */\n        char ubuf[UNIT_LEN];\n        char nbuf[UNIT_LEN];\n        struct stat sb;\n        char sbuf[UNIT_LEN];\n        struct iperf_stream *sp = NULL;\n        iperf_size_t bytes_sent, total_sent = 0;\n        iperf_size_t bytes_received, total_received = 0;\n        double start_time, end_time = 0.0, avg_jitter = 0.0, lost_percent = 0.0;\n        double sender_time = 0.0, receiver_time = 0.0;\n        struct iperf_time temp_time;\n        double bandwidth;\n\n        char mbuf[UNIT_LEN];\n        int stream_must_be_sender = current_mode * current_mode;\n\n\n        /*  Print stream role just for bidirectional mode. */\n\n        if (test->mode == BIDIRECTIONAL) {\n            sprintf(mbuf, \"[%s-%s]\", stream_must_be_sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n        } else {\n            mbuf[0] = '\\0';\n        }\n\n        /* Get sender_has_retransmits for each sender side (client and server) */\n        if (test->mode == BIDIRECTIONAL && stream_must_be_sender)\n            test->sender_has_retransmits = tmp_sender_has_retransmits;\n        else if (test->mode == BIDIRECTIONAL && !stream_must_be_sender)\n            test->sender_has_retransmits = test->other_side_has_retransmits;\n\n        start_time = 0.;\n        sp = SLIST_FIRST(&test->streams);\n\n        /*\n         * If there is at least one stream, then figure out the length of time\n         * we were running the tests and print out some statistics about\n         * the streams.  It's possible to not have any streams at all\n         * if the client got interrupted before it got to do anything.\n         *\n         * Also note that we try to keep separate values for the sender\n         * and receiver ending times.  Earlier iperf (3.1 and earlier)\n         * servers didn't send that to the clients, so in this case we fall\n         * back to using the client's ending timestamp.  The fallback is\n         * basically emulating what iperf 3.1 did.\n         */\n\n        if (sp) {\n        iperf_time_diff(&sp->result->start_time, &sp->result->end_time, &temp_time);\n        end_time = iperf_time_in_secs(&temp_time);\n        if (sp->sender) {\n            sp->result->sender_time = end_time;\n            if (sp->result->receiver_time == 0.0) {\n                sp->result->receiver_time = sp->result->sender_time;\n            }\n        }\n        else {\n            sp->result->receiver_time = end_time;\n            if (sp->result->sender_time == 0.0) {\n                sp->result->sender_time = sp->result->receiver_time;\n            }\n        }\n        sender_time = sp->result->sender_time;\n        receiver_time = sp->result->receiver_time;\n        SLIST_FOREACH(sp, &test->streams, streams) {\n            if (sp->sender == stream_must_be_sender) {\n                if (test->json_output) {\n                    json_summary_stream = cJSON_CreateObject();\n                    if (json_summary_stream == NULL)\n                        return;\n                    cJSON_AddItemToArray(json_summary_streams, json_summary_stream);\n                }\n\n                bytes_sent = sp->result->bytes_sent - sp->result->bytes_sent_omit;\n                bytes_received = sp->result->bytes_received;\n                total_sent += bytes_sent;\n                total_received += bytes_received;\n\n                if (sp->sender) {\n                    sender_packet_count = sp->packet_count;\n                    sender_omitted_packet_count = sp->omitted_packet_count;\n                    receiver_packet_count = sp->peer_packet_count;\n                    receiver_omitted_packet_count = sp->peer_omitted_packet_count;\n                }\n                else {\n                    sender_packet_count = sp->peer_packet_count;\n                    sender_omitted_packet_count = sp->peer_omitted_packet_count;\n                    receiver_packet_count = sp->packet_count;\n                    receiver_omitted_packet_count = sp->omitted_packet_count;\n                }\n\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits) {\n                        total_retransmits += sp->result->stream_retrans;\n                    }\n                } else {\n                    /*\n                     * Running total of the total number of packets.  Use the sender packet count if we\n                     * have it, otherwise use the receiver packet count.\n                     */\n                    int64_t packet_count = sender_packet_count ? sender_packet_count : receiver_packet_count;\n                    total_packets += (packet_count - sp->omitted_packet_count);\n                    sender_total_packets += (sender_packet_count - sender_omitted_packet_count);\n                    receiver_total_packets += (receiver_packet_count - receiver_omitted_packet_count);\n                    lost_packets += sp->cnt_error;\n                    if (sp->omitted_cnt_error > -1)\n                         lost_packets -= sp->omitted_cnt_error;\n                    avg_jitter += sp->jitter;\n                }\n\n                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_sent, 'A');\n                if (sender_time > 0.0) {\n                    bandwidth = (double) bytes_sent / (double) sender_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits) {\n                        /* Sender summary, TCP and SCTP with retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, report_sender, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  max_snd_cwnd:  %d  max_snd_wnd:  %d  max_rtt:  %d  min_rtt:  %d  mean_rtt:  %d sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8, (int64_t) sp->result->stream_retrans, (int64_t) sp->result->stream_max_snd_cwnd, (int64_t) sp->result->stream_max_snd_wnd, (int64_t) sp->result->stream_max_rtt, (int64_t) sp->result->stream_min_rtt, (int64_t) ((sp->result->stream_count_rtt == 0) ? 0 : sp->result->stream_sum_rtt / sp->result->stream_count_rtt), stream_must_be_sender));\n                        else\n                            if (test->role == 's' && !sp->sender) {\n                                if (test->verbose)\n                                    iperf_printf(test, report_sender_not_available_format, sp->socket);\n                            }\n                            else {\n                                iperf_printf(test, report_bw_retrans_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, sp->result->stream_retrans, report_sender);\n                            }\n                    } else {\n                        /* Sender summary, TCP and SCTP without retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, report_sender, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8,  stream_must_be_sender));\n                        else\n                            if (test->role == 's' && !sp->sender) {\n                                if (test->verbose)\n                                    iperf_printf(test, report_sender_not_available_format, sp->socket);\n                            }\n                            else {\n                                iperf_printf(test, report_bw_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, report_sender);\n                            }\n                    }\n                } else {\n                    /* Sender summary, UDP. */\n                    if (sender_packet_count - sender_omitted_packet_count > 0) {\n                        lost_percent = 100.0 * (sp->cnt_error - sp->omitted_cnt_error) / (sender_packet_count - sender_omitted_packet_count);\n                    }\n                    else {\n                        lost_percent = 0.0;\n                    }\n                    if (test->json_output) {\n                        /*\n                         * For historical reasons, we only emit one JSON\n                         * object for the UDP summary, and it contains\n                         * information for both the sender and receiver\n                         * side.\n                         *\n                         * The JSON format as currently defined only includes one\n                         * value for the number of packets.  We usually want that\n                         * to be the sender's value (how many packets were sent\n                         * by the sender).  However this value might not be\n                         * available on the receiver in certain circumstances\n                         * specifically on the server side for a normal test or\n                         * the client side for a reverse-mode test.  If this\n                         * is the case, then use the receiver's count of packets\n                         * instead.\n                         */\n                        int64_t packet_count = sender_packet_count ? sender_packet_count : receiver_packet_count;\n                        cJSON_AddItemToObject(json_summary_stream, \"udp\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  out_of_order: %d sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8, (double) sp->jitter * 1000.0, (int64_t) (sp->cnt_error - sp->omitted_cnt_error), (int64_t) (packet_count - sp->omitted_packet_count), (double) lost_percent, (int64_t) (sp->outoforder_packets - sp->omitted_outoforder_packets), stream_must_be_sender));\n                    }\n                    else {\n                        /*\n                         * Due to ordering of messages on the control channel,\n                         * the server cannot report on client-side summary\n                         * statistics.  If we're the server, omit one set of\n                         * summary statistics to avoid giving meaningless\n                         * results.\n                         */\n                        if (test->role == 's' && !sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_format, sp->socket);\n                        }\n                        else {\n                            iperf_printf(test, report_bw_udp_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, 0.0, 0, (sender_packet_count - sender_omitted_packet_count), (double) 0, report_sender);\n                        }\n                        if ((sp->outoforder_packets - sp->omitted_outoforder_packets) > 0)\n                          iperf_printf(test, report_sum_outoforder, mbuf, start_time, sender_time, (sp->outoforder_packets - sp->omitted_outoforder_packets));\n                    }\n                }\n\n                if (sp->diskfile_fd >= 0) {\n                    if (fstat(sp->diskfile_fd, &sb) == 0) {\n                        /* In the odd case that it's a zero-sized file, say it was all transferred. */\n                        int percent_sent = 100, percent_received = 100;\n                        if (sb.st_size > 0) {\n                            percent_sent = (int) ( ( (double) bytes_sent / (double) sb.st_size ) * 100.0 );\n                            percent_received = (int) ( ( (double) bytes_received / (double) sb.st_size ) * 100.0 );\n                        }\n                        unit_snprintf(sbuf, UNIT_LEN, (double) sb.st_size, 'A');\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, \"diskfile\", iperf_json_printf(\"sent: %d  received: %d  size: %d  percent_sent: %d  percent_received: %d  filename: %s\", (int64_t) bytes_sent, (int64_t) bytes_received, (int64_t) sb.st_size, (int64_t) percent_sent, (int64_t) percent_received, test->diskfile_name));\n                        else\n                            if (stream_must_be_sender) {\n                                iperf_printf(test, report_diskfile, ubuf, sbuf, percent_sent, test->diskfile_name);\n                            }\n                            else {\n                                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n                                iperf_printf(test, report_diskfile, ubuf, sbuf, percent_received, test->diskfile_name);\n                            }\n                    }\n                }\n\n                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n                if (receiver_time > 0) {\n                    bandwidth = (double) bytes_received / (double) receiver_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    /* Receiver summary, TCP and SCTP */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(json_summary_stream, report_receiver, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (int64_t) sp->socket, (double) start_time, (double) receiver_time, (double) end_time, (int64_t) bytes_received, bandwidth * 8, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_receiver_not_available_format, sp->socket);\n                        }\n                        else {\n                            iperf_printf(test, report_bw_format, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);\n                        }\n                }\n                else {\n                    /*\n                     * Receiver summary, UDP.  Note that JSON was emitted with\n                     * the sender summary, so we only deal with human-readable\n                     * data here.\n                     */\n                    if (! test->json_output) {\n                        if (receiver_packet_count - receiver_omitted_packet_count > 0 && sp->omitted_cnt_error > -1) {\n                            lost_percent = 100.0 * (sp->cnt_error - sp->omitted_cnt_error) / (receiver_packet_count - receiver_omitted_packet_count);\n                        }\n                        else {\n                            lost_percent = 0.0;\n                        }\n\n                        if (test->role == 's' && sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_receiver_not_available_format, sp->socket);\n                        }\n                        else {\n                            if (sp->omitted_cnt_error > -1) {\n                                iperf_printf(test, report_bw_udp_format, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, sp->jitter * 1000.0, (sp->cnt_error - sp->omitted_cnt_error), (receiver_packet_count - receiver_omitted_packet_count), lost_percent, report_receiver);\n                            } else {\n                                iperf_printf(test, report_bw_udp_format_no_omitted_error, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, sp->jitter * 1000.0, (receiver_packet_count - receiver_omitted_packet_count), report_receiver);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        }\n\n        if (test->num_streams > 1 || test->json_output) {\n            /*\n             * With BIDIR give a different JSON object name to the one sent/receive sums.\n             * The different name is given to the data sent from the server, which is\n             * the \"reverse\" channel.  This makes sure that the name reported on the server\n             * and client are compatible, and the names are the same as with non-bidir,\n             * except for when reverse is used.\n             */\n            sum_name = \"sum\";\n            sum_sent_name = \"sum_sent\";\n            sum_received_name = \"sum_received\";\n            if (test->mode == BIDIRECTIONAL) {\n                if ((test->role == 'c' && !stream_must_be_sender) ||\n                    (test->role != 'c' && stream_must_be_sender))\n                {\n                    sum_name = \"sum_bidir_reverse\";\n                    sum_sent_name = \"sum_sent_bidir_reverse\";\n                    sum_received_name = \"sum_received_bidir_reverse\";\n                }\n\n            }\n\n            unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n            /* If no tests were run, arbitrarily set bandwidth to 0. */\n            if (sender_time > 0.0) {\n                bandwidth = (double) total_sent / (double) sender_time;\n            }\n            else {\n                bandwidth = 0.0;\n            }\n            unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n            if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                if (test->sender_has_retransmits) {\n                    /* Summary sum, TCP with retransmits. */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, bandwidth * 8, (int64_t) total_retransmits, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && !stream_must_be_sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_summary_format, \"SUM\");\n                        }\n                        else {\n                          iperf_printf(test, report_sum_bw_retrans_format, mbuf, start_time, sender_time, ubuf, nbuf, total_retransmits, report_sender);\n                        }\n                } else {\n                    /* Summary sum, TCP without retransmits. */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, bandwidth * 8, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && !stream_must_be_sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_summary_format, \"SUM\");\n                        }\n                        else {\n                            iperf_printf(test, report_sum_bw_format, mbuf, start_time, sender_time, ubuf, nbuf, report_sender);\n                        }\n                }\n                unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n                /* If no tests were run, set received bandwidth to 0 */\n                if (receiver_time > 0.0) {\n                    bandwidth = (double) total_received / (double) receiver_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->json_output)\n                    cJSON_AddItemToObject(test->json_end, sum_received_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_received, bandwidth * 8, stream_must_be_sender));\n                else\n                    if (test->role == 's' && stream_must_be_sender) {\n                        if (test->verbose)\n                            iperf_printf(test, report_receiver_not_available_summary_format, \"SUM\");\n                    }\n                    else {\n                        iperf_printf(test, report_sum_bw_format, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);\n                    }\n            } else {\n                /* Summary sum, UDP. */\n                avg_jitter /= test->num_streams;\n                /* If no packets were sent, arbitrarily set loss percentage to 0. */\n                if (total_packets > 0) {\n                    lost_percent = 100.0 * lost_packets / total_packets;\n                }\n                else {\n                    lost_percent = 0.0;\n                }\n                if (test->json_output) {\n                    /*\n                     * Original, summary structure. Using this\n                     * structure is not recommended due to\n                     * ambiguities between the sender and receiver.\n                     */\n                    cJSON_AddItemToObject(test->json_end, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_sent, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, stream_must_be_sender));\n                    /*\n                     * Separate sum_sent and sum_received structures.\n                     * Using these structures to get the most complete\n                     * information about UDP transfer.\n                     */\n                    cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, (double) total_sent * 8 / sender_time, (double) 0.0, (int64_t) 0, (int64_t) sender_total_packets, (double) 0.0, 1));\n                    cJSON_AddItemToObject(test->json_end, sum_received_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_received, (double) total_received * 8 / receiver_time, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) receiver_total_packets, (double) lost_percent, 0));\n                } else {\n                    /*\n                     * On the client we have both sender and receiver overall summary\n                     * stats.  On the server we have only the side that was on the\n                     * server.  Output whatever we have.\n                     */\n                    if (! (test->role == 's' && !stream_must_be_sender) ) {\n                        unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n                        iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, sender_time, ubuf, nbuf, 0.0, 0, sender_total_packets, 0.0, report_sender);\n                    }\n                    if (! (test->role == 's' && stream_must_be_sender) ) {\n\n                        unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n                        /* Compute received bandwidth. */\n                        if (end_time > 0.0) {\n                            bandwidth = (double) total_received / (double) receiver_time;\n                        }\n                        else {\n                            bandwidth = 0.0;\n                        }\n                        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                        iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, receiver_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, receiver_total_packets, lost_percent, report_receiver);\n                    }\n                }\n            }\n        }\n\n        if (test->json_output && current_mode == upper_mode) {\n            cJSON_AddItemToObject(test->json_end, \"cpu_utilization_percent\", iperf_json_printf(\"host_total: %f  host_user: %f  host_system: %f  remote_total: %f  remote_user: %f  remote_system: %f\", (double) test->cpu_util[0], (double) test->cpu_util[1], (double) test->cpu_util[2], (double) test->remote_cpu_util[0], (double) test->remote_cpu_util[1], (double) test->remote_cpu_util[2]));\n            if (test->protocol->id == Ptcp) {\n                char *snd_congestion = NULL, *rcv_congestion = NULL;\n                if (stream_must_be_sender) {\n                    snd_congestion = test->congestion_used;\n                    rcv_congestion = test->remote_congestion_used;\n                }\n                else {\n                    snd_congestion = test->remote_congestion_used;\n                    rcv_congestion = test->congestion_used;\n                }\n                if (snd_congestion) {\n                    cJSON_AddStringToObject(test->json_end, \"sender_tcp_congestion\", snd_congestion);\n                }\n                if (rcv_congestion) {\n                    cJSON_AddStringToObject(test->json_end, \"receiver_tcp_congestion\", rcv_congestion);\n                }\n            }\n        }\n        else {\n            if (test->verbose) {\n                if (stream_must_be_sender) {\n                    if (test->bidirectional) {\n                        iperf_printf(test, report_cpu, report_local, stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                        iperf_printf(test, report_cpu, report_local, !stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, !stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                    } else\n                        iperf_printf(test, report_cpu, report_local, stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                }\n                if (test->protocol->id == Ptcp) {\n                    char *snd_congestion = NULL, *rcv_congestion = NULL;\n                    if (stream_must_be_sender) {\n                        snd_congestion = test->congestion_used;\n                        rcv_congestion = test->remote_congestion_used;\n                    }\n                    else {\n                        snd_congestion = test->remote_congestion_used;\n                        rcv_congestion = test->congestion_used;\n                    }\n                    if (snd_congestion) {\n                        iperf_printf(test, \"snd_tcp_congestion %s\\n\", snd_congestion);\n                    }\n                    if (rcv_congestion) {\n                        iperf_printf(test, \"rcv_tcp_congestion %s\\n\", rcv_congestion);\n                    }\n                }\n            }\n\n            /* Print server output if we're on the client and it was requested/provided */\n            if (test->role == 'c' && iperf_get_test_get_server_output(test) && !test->json_output) {\n                if (test->json_server_output) {\n\t\t    char *str = cJSON_Print(test->json_server_output);\n                    iperf_printf(test, \"\\nServer JSON output:\\n%s\\n\", str);\n\t\t    cJSON_free(str);\n                    cJSON_Delete(test->json_server_output);\n                    test->json_server_output = NULL;\n                }\n                if (test->server_output_text) {\n                    iperf_printf(test, \"\\nServer output:\\n%s\\n\", test->server_output_text);\n                    test->server_output_text = NULL;\n                }\n            }\n        }\n    }\n\n    /* Set real sender_has_retransmits for current side */\n    if (test->mode == BIDIRECTIONAL)\n        test->sender_has_retransmits = tmp_sender_has_retransmits;\n}\n\n/**************************************************************************/\n\n/**\n * Main report-printing callback.\n * Prints results either during a test (interval report only) or\n * after the entire test has been run (last interval report plus\n * overall summary).\n */\nvoid\niperf_reporter_callback(struct iperf_test *test)\n{\n    switch (test->state) {\n        case TEST_RUNNING:\n        case STREAM_RUNNING:\n            /* print interval results for each stream */\n            iperf_print_intermediate(test);\n            break;\n        case TEST_END:\n        case DISPLAY_RESULTS:\n            iperf_print_intermediate(test);\n            iperf_print_results(test);\n            break;\n    }\n\n}\n\n/**\n * Print the interval results for one stream.\n * This function needs to know about the overall test so it can determine the\n * context for printing headers, separators, etc.\n */\nstatic void\nprint_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    char cbuf[UNIT_LEN];\n    char mbuf[UNIT_LEN];\n    char zbuf[] = \"          \";\n    double st = 0., et = 0.;\n    struct iperf_time temp_time;\n    struct iperf_interval_results *irp = NULL;\n    double bandwidth, lost_percent;\n\n    if (test->mode == BIDIRECTIONAL) {\n        sprintf(mbuf, \"[%s-%s]\", sp->sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n    } else {\n        mbuf[0] = '\\0';\n        zbuf[0] = '\\0';\n    }\n\n    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead); /* get last entry in linked list */\n    if (irp == NULL) {\n\tiperf_err(test, \"print_interval_results error: interval_results is NULL\");\n        return;\n    }\n    if (!test->json_output) {\n\t/* First stream? */\n\tif (sp == SLIST_FIRST(&test->streams)) {\n\t    /* It it's the first interval, print the header;\n\t    ** else if there's more than one stream, print the separator;\n\t    ** else nothing.\n\t    */\n\t    if (iperf_time_compare(&sp->result->start_time, &irp->interval_start_time) == 0) {\n\t\tif (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\t\t    if (test->sender_has_retransmits == 1) {\n\t\t        if (test->bidirectional)\n\t\t            iperf_printf(test, \"%s\", report_bw_retrans_cwnd_header_bidir);\n\t\t        else\n\t\t            iperf_printf(test, \"%s\", report_bw_retrans_cwnd_header);\n\t\t    }\n\t\t    else {\n\t                if (test->bidirectional)\n\t                    iperf_printf(test, \"%s\", report_bw_header_bidir);\n\t                else\n\t                    iperf_printf(test, \"%s\", report_bw_header);\n\t            }\n\t\t} else {\n\t\t    if (test->mode == SENDER) {\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_sender_header);\n\t\t    } else if (test->mode == RECEIVER){\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_header);\n\t\t    } else {\n\t\t        /* BIDIRECTIONAL */\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_header_bidir);\n\t\t    }\n\t\t}\n\t    } else if (test->num_streams > 1)\n\t\tiperf_printf(test, \"%s\", report_bw_separator);\n\t}\n    }\n\n    unit_snprintf(ubuf, UNIT_LEN, (double) (irp->bytes_transferred), 'A');\n    if (irp->interval_duration > 0.0) {\n\tbandwidth = (double) irp->bytes_transferred / (double) irp->interval_duration;\n    }\n    else {\n\tbandwidth = 0.0;\n    }\n    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n    iperf_time_diff(&sp->result->start_time, &irp->interval_start_time, &temp_time);\n    st = iperf_time_in_secs(&temp_time);\n    iperf_time_diff(&sp->result->start_time, &irp->interval_end_time, &temp_time);\n    et = iperf_time_in_secs(&temp_time);\n\n    if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\tif (test->sender_has_retransmits == 1 && sp->sender) {\n\t    /* Interval, TCP with retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  snd_cwnd:  %d  snd_wnd:  %d  rtt:  %d  rttvar: %d  pmtu: %d  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_retrans, (int64_t) irp->snd_cwnd, (int64_t) irp->snd_wnd, (int64_t) irp->rtt, (int64_t) irp->rttvar, (int64_t) irp->pmtu, irp->omitted, sp->sender));\n\t    else {\n\t\tunit_snprintf(cbuf, UNIT_LEN, irp->snd_cwnd, 'A');\n\t\tiperf_printf(test, report_bw_retrans_cwnd_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->interval_retrans, cbuf, irp->omitted?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval, TCP without retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->omitted?report_omitted:\"\");\n\t}\n    } else {\n\t/* Interval, UDP. */\n\tif (sp->sender) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_packet_count, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_udp_sender_format, sp->socket, mbuf, st, et, ubuf, nbuf, zbuf, irp->interval_packet_count, irp->omitted?report_omitted:\"\");\n\t} else {\n\t    if (irp->interval_packet_count > 0) {\n\t\tlost_percent = 100.0 * irp->interval_cnt_error / irp->interval_packet_count;\n\t    }\n\t    else {\n\t\tlost_percent = 0.0;\n\t    }\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (double) irp->jitter * 1000.0, (int64_t) irp->interval_cnt_error, (int64_t) irp->interval_packet_count, (double) lost_percent, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_udp_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent, irp->omitted?report_omitted:\"\");\n\t}\n    }\n\n    if (test->logfile || test->forceflush)\n        iflush(test);\n}\n\n/**************************************************************************/\nvoid\niperf_free_stream(struct iperf_stream *sp)\n{\n    struct iperf_interval_results *irp, *nirp;\n\n    /* XXX: need to free interval list too! */\n    munmap(sp->buffer, sp->test->settings->blksize);\n    close(sp->buffer_fd);\n    if (sp->diskfile_fd >= 0)\n\tclose(sp->diskfile_fd);\n    for (irp = TAILQ_FIRST(&sp->result->interval_results); irp != NULL; irp = nirp) {\n        nirp = TAILQ_NEXT(irp, irlistentries);\n        free(irp);\n    }\n    free(sp->result);\n    if (sp->send_timer != NULL)\n\ttmr_cancel(sp->send_timer);\n    free(sp);\n}\n\n/**************************************************************************/\nstruct iperf_stream *\niperf_new_stream(struct iperf_test *test, int s, int sender)\n{\n    struct iperf_stream *sp;\n    int ret = 0;\n\n    char template[1024];\n    if (test->tmp_template) {\n        snprintf(template, sizeof(template) / sizeof(char), \"%s\", test->tmp_template);\n    } else {\n        //find the system temporary dir *unix, windows, cygwin support\n        char* tempdir = getenv(\"TMPDIR\");\n        if (tempdir == 0){\n            tempdir = getenv(\"TEMP\");\n        }\n        if (tempdir == 0){\n            tempdir = getenv(\"TMP\");\n        }\n        if (tempdir == 0){\n#if defined(__ANDROID__)\n            tempdir = \"/data/local/tmp\";\n#else\n            tempdir = \"/tmp\";\n#endif\n        }\n        snprintf(template, sizeof(template) / sizeof(char), \"%s/iperf3.XXXXXX\", tempdir);\n    }\n\n    sp = (struct iperf_stream *) malloc(sizeof(struct iperf_stream));\n    if (!sp) {\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp, 0, sizeof(struct iperf_stream));\n\n    sp->sender = sender;\n    sp->test = test;\n    sp->settings = test->settings;\n    sp->result = (struct iperf_stream_result *) malloc(sizeof(struct iperf_stream_result));\n    if (!sp->result) {\n        free(sp);\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp->result, 0, sizeof(struct iperf_stream_result));\n    TAILQ_INIT(&sp->result->interval_results);\n\n    /* Create and randomize the buffer */\n    sp->buffer_fd = mkstemp(template);\n    if (sp->buffer_fd == -1) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (unlink(template) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (ftruncate(sp->buffer_fd, test->settings->blksize) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->buffer = (char *) mmap(NULL, test->settings->blksize, PROT_READ|PROT_WRITE, MAP_PRIVATE, sp->buffer_fd, 0);\n    if (sp->buffer == MAP_FAILED) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->pending_size = 0;\n\n    /* Set socket */\n    sp->socket = s;\n\n    sp->snd = test->protocol->send;\n    sp->rcv = test->protocol->recv;\n\n    if (test->diskfile_name != (char*) 0) {\n\tsp->diskfile_fd = open(test->diskfile_name, sender ? O_RDONLY : (O_WRONLY|O_CREAT|O_TRUNC), S_IRUSR|S_IWUSR);\n\tif (sp->diskfile_fd == -1) {\n\t    i_errno = IEFILE;\n            munmap(sp->buffer, sp->test->settings->blksize);\n            free(sp->result);\n            free(sp);\n\t    return NULL;\n\t}\n        sp->snd2 = sp->snd;\n\tsp->snd = diskfile_send;\n\tsp->rcv2 = sp->rcv;\n\tsp->rcv = diskfile_recv;\n    } else\n        sp->diskfile_fd = -1;\n\n    /* Initialize stream */\n    if (test->repeating_payload)\n        fill_with_repeating_pattern(sp->buffer, test->settings->blksize);\n    else\n        ret = readentropy(sp->buffer, test->settings->blksize);\n\n    if ((ret < 0) || (iperf_init_stream(sp, test) < 0)) {\n        close(sp->buffer_fd);\n        munmap(sp->buffer, sp->test->settings->blksize);\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    iperf_add_stream(test, sp);\n\n    return sp;\n}\n\n/**************************************************************************/\nint\niperf_common_sockopts(struct iperf_test *test, int s)\n{\n    int opt;\n\n    /* Set IP TOS */\n    if ((opt = test->settings->tos)) {\n\tif (getsockdomain(s) == AF_INET6) {\n#ifdef IPV6_TCLASS\n\t    if (setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETCOS;\n                return -1;\n            }\n\n\t    /* if the control connection was established with a mapped v4 address\n\t       then set IP_TOS on v6 stream socket as well */\n\t    if (iperf_get_mapped_v4(test)) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                    /* ignore any failure of v4 TOS in IPv6 case */\n                }\n            }\n#else\n            i_errno = IESETCOS;\n            return -1;\n#endif\n        } else {\n            if (setsockopt(s, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETTOS;\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**************************************************************************/\nint\niperf_init_stream(struct iperf_stream *sp, struct iperf_test *test)\n{\n    int opt;\n    socklen_t len;\n\n    len = sizeof(struct sockaddr_storage);\n    if (getsockname(sp->socket, (struct sockaddr *) &sp->local_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n    len = sizeof(struct sockaddr_storage);\n    if (getpeername(sp->socket, (struct sockaddr *) &sp->remote_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n\n#if defined(HAVE_DONT_FRAGMENT)\n    /* Set Don't Fragment (DF). Only applicable to IPv4/UDP tests. */\n    if (iperf_get_test_protocol_id(test) == Pudp &&\n        getsockdomain(sp->socket) == AF_INET &&\n        iperf_get_dont_fragment(test)) {\n\n        /*\n         * There are multiple implementations of this feature depending on the OS.\n         * We need to handle separately Linux, UNIX, and Windows, as well as\n         * the case that DF isn't supported at all (such as on macOS).\n         */\n#if defined(IP_MTU_DISCOVER) /* Linux version of IP_DONTFRAG */\n        opt = IP_PMTUDISC_DO;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_MTU_DISCOVER, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n#if defined(IP_DONTFRAG) /* UNIX does IP_DONTFRAG */\n        opt = 1;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_DONTFRAG, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n#if defined(IP_DONTFRAGMENT) /* Windows does IP_DONTFRAGMENT */\n        opt = 1;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_DONTFRAGMENT, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n\ti_errno = IESETDONTFRAGMENT;\n\treturn -1;\n#endif /* IP_DONTFRAGMENT */\n#endif /* IP_DONTFRAG */\n#endif /* IP_MTU_DISCOVER */\n    }\n#endif /* HAVE_DONT_FRAGMENT */\n\n    return 0;\n}\n\n/**************************************************************************/\nvoid\niperf_add_stream(struct iperf_test *test, struct iperf_stream *sp)\n{\n    int i;\n    struct iperf_stream *n, *prev;\n\n    if (SLIST_EMPTY(&test->streams)) {\n        SLIST_INSERT_HEAD(&test->streams, sp, streams);\n        sp->id = 1;\n    } else {\n        // for (n = test->streams, i = 2; n->next; n = n->next, ++i);\n        // NOTE: this would ideally be set to 1, however this will not\n        //       be changed since it is not causing a significant problem\n        //       and changing it would break multi-stream tests between old\n        //       and new iperf3 versions.\n        i = 2;\n        prev = NULL;\n        SLIST_FOREACH(n, &test->streams, streams) {\n            prev = n;\n            ++i;\n        }\n        if (prev) {\n            SLIST_INSERT_AFTER(prev, sp, streams);\n            sp->id = i;\n         }\n    }\n}\n\n/* This pair of routines gets inserted into the snd/rcv function pointers\n** when there's a -F flag. They handle the file stuff and call the real\n** snd/rcv functions, which have been saved in snd2/rcv2.\n**\n** The advantage of doing it this way is that in the much more common\n** case of no -F flag, there is zero extra overhead.\n*/\n\nstatic int\ndiskfile_send(struct iperf_stream *sp)\n{\n    int r;\n    int buffer_left = sp->diskfile_left; // represents total data in buffer to be sent out\n    static int rtot;\n\n    /* if needed, read enough data from the disk to fill up the buffer */\n    if (sp->diskfile_left < sp->test->settings->blksize && !sp->test->done) {\n    \tr = read(sp->diskfile_fd, sp->buffer, sp->test->settings->blksize -\n    \t\t sp->diskfile_left);\n        buffer_left += r;\n    \trtot += r;\n    \tif (sp->test->debug) {\n    \t    printf(\"read %d bytes from file, %d total\\n\", r, rtot);\n    \t}\n\n        // If the buffer doesn't contain a full buffer at this point,\n        // adjust the size of the data to send.\n        if (buffer_left != sp->test->settings->blksize) {\n            if (sp->test->debug)\n                printf(\"possible eof\\n\");\n            // setting data size to be sent,\n            // which is less than full block/buffer size\n            // (to be used by iperf_tcp_send, etc.)\n            sp->pending_size = buffer_left;\n        }\n\n        // If there's no work left, we're done.\n        if (buffer_left == 0) {\n    \t    sp->test->done = 1;\n    \t    if (sp->test->debug)\n    \t\t  printf(\"done\\n\");\n    \t}\n    }\n\n    // If there's no data left in the file or in the buffer, we're done.\n    // No more data available to be sent.\n    // Return without sending data to the network\n    if( sp->test->done || buffer_left == 0 ){\n        if (sp->test->debug)\n              printf(\"already done\\n\");\n        sp->test->done = 1;\n        return 0;\n    }\n\n    r = sp->snd2(sp);\n    if (r < 0) {\n\treturn r;\n    }\n    /*\n     * Compute how much data is in the buffer but didn't get sent.\n     * If there are bytes that got left behind, slide them to the\n     * front of the buffer so they can hopefully go out on the next\n     * pass.\n     */\n    sp->diskfile_left = buffer_left - r;\n    if (sp->diskfile_left && sp->diskfile_left < sp->test->settings->blksize) {\n\tmemcpy(sp->buffer,\n\t       sp->buffer + (sp->test->settings->blksize - sp->diskfile_left),\n\t       sp->diskfile_left);\n\tif (sp->test->debug)\n\t    printf(\"Shifting %d bytes by %d\\n\", sp->diskfile_left, (sp->test->settings->blksize - sp->diskfile_left));\n    }\n    return r;\n}\n\nstatic int\ndiskfile_recv(struct iperf_stream *sp)\n{\n    int r;\n\n    r = sp->rcv2(sp);\n    if (r > 0) {\n\t// NOTE: Currently ignoring the return value of writing to disk\n\t(void) (write(sp->diskfile_fd, sp->buffer, r) + 1);\n    }\n    return r;\n}\n\n\nvoid\niperf_catch_sigend(void (*handler)(int))\n{\n#ifdef SIGINT\n    signal(SIGINT, handler);\n#endif\n#ifdef SIGTERM\n    signal(SIGTERM, handler);\n#endif\n#ifdef SIGHUP\n    signal(SIGHUP, handler);\n#endif\n}\n\n/**\n * Called as a result of getting a signal.\n * Depending on the current state of the test (and the role of this\n * process) compute and report one more set of ending statistics\n * before cleaning up and exiting.\n */\nvoid\niperf_got_sigend(struct iperf_test *test)\n{\n    /*\n     * If we're the client, or if we're a server and running a test,\n     * then dump out the accumulated stats so far.\n     */\n    if (test->role == 'c' ||\n      (test->role == 's' && test->state == TEST_RUNNING)) {\n\n\ttest->done = 1;\n\tcpu_util(test->cpu_util);\n\ttest->stats_callback(test);\n\ttest->state = DISPLAY_RESULTS; /* change local state only */\n\tif (test->on_test_finish)\n\t    test->on_test_finish(test);\n\ttest->reporter_callback(test);\n    }\n\n    if (test->ctrl_sck >= 0) {\n\ttest->state = (test->role == 'c') ? CLIENT_TERMINATE : SERVER_TERMINATE;\n\t(void) Nwrite(test->ctrl_sck, (char*) &test->state, sizeof(signed char), Ptcp);\n    }\n    i_errno = (test->role == 'c') ? IECLIENTTERM : IESERVERTERM;\n    iperf_errexit(test, \"interrupt - %s\", iperf_strerror(i_errno));\n}\n\n/* Try to write a PID file if requested, return -1 on an error. */\nint\niperf_create_pidfile(struct iperf_test *test)\n{\n    if (test->pidfile) {\n\tint fd;\n\tchar buf[8];\n\n\t/* See if the file already exists and we can read it. */\n\tfd = open(test->pidfile, O_RDONLY, 0);\n\tif (fd >= 0) {\n\t    if (read(fd, buf, sizeof(buf) - 1) >= 0) {\n\n\t\t/* We read some bytes, see if they correspond to a valid PID */\n\t\tpid_t pid;\n\t\tpid = atoi(buf);\n\t\tif (pid > 0) {\n\n\t\t    /* See if the process exists. */\n\t\t    if (kill(pid, 0) == 0) {\n\t\t\t/*\n\t\t\t * Make sure not to try to delete existing PID file by\n\t\t\t * scribbling over the pathname we'd use to refer to it.\n\t\t\t * Then exit with an error.\n\t\t\t */\n\t\t\tfree(test->pidfile);\n\t\t\ttest->pidfile = NULL;\n\t\t\tiperf_errexit(test, \"Another instance of iperf3 appears to be running\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * File didn't exist, we couldn't read it, or it didn't correspond to\n\t * a running process.  Try to create it.\n\t */\n\tfd = open(test->pidfile, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR);\n\tif (fd < 0) {\n\t    return -1;\n\t}\n\tsnprintf(buf, sizeof(buf), \"%d\", getpid()); /* no trailing newline */\n\tif (write(fd, buf, strlen(buf)) < 0) {\n\t    (void)close(fd);\n\t    return -1;\n\t}\n\tif (close(fd) < 0) {\n\t    return -1;\n\t};\n    }\n    return 0;\n}\n\n/* Get rid of a PID file, return -1 on error. */\nint\niperf_delete_pidfile(struct iperf_test *test)\n{\n    if (test->pidfile) {\n\tif (unlink(test->pidfile) < 0) {\n\t    return -1;\n\t}\n    }\n    return 0;\n}\n\nint\niperf_json_start(struct iperf_test *test)\n{\n    test->json_top = cJSON_CreateObject();\n    if (test->json_top == NULL)\n        return -1;\n    test->json_start = cJSON_CreateObject();\n    if (test->json_start == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"start\", test->json_start);\n    test->json_connected = cJSON_CreateArray();\n    if (test->json_connected == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_start, \"connected\", test->json_connected);\n    test->json_intervals = cJSON_CreateArray();\n    if (test->json_intervals == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"intervals\", test->json_intervals);\n    test->json_end = cJSON_CreateObject();\n    if (test->json_end == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"end\", test->json_end);\n    return 0;\n}\n\nint\niperf_json_finish(struct iperf_test *test)\n{\n    if (test->json_top) {\n        if (test->title) {\n            cJSON_AddStringToObject(test->json_top, \"title\", test->title);\n        }\n        if (test->extra_data) {\n            cJSON_AddStringToObject(test->json_top, \"extra_data\", test->extra_data);\n        }\n        /* Include server output */\n        if (test->json_server_output) {\n            cJSON_AddItemToObject(test->json_top, \"server_output_json\", test->json_server_output);\n        }\n        if (test->server_output_text) {\n            cJSON_AddStringToObject(test->json_top, \"server_output_text\", test->server_output_text);\n        }\n        // Get ASCII rendering of JSON structure.  Then make our\n        // own copy of it and return the storage that cJSON allocated\n        // on our behalf.  We keep our own copy around.\n        char *str = cJSON_Print(test->json_top);\n        if (str == NULL) {\n            return -1;\n        }\n        test->json_output_string = strdup(str);\n        cJSON_free(str);\n        if (test->json_output_string == NULL) {\n            return -1;\n        }\n        fprintf(test->outfile, \"%s\\n\", test->json_output_string);\n        iflush(test);\n        cJSON_Delete(test->json_top);\n        test->json_top = NULL;\n    }\n    test->json_start = test->json_connected = test->json_intervals = test->json_server_output = test->json_end = NULL;\n    return 0;\n}\n\n\n/* CPU affinity stuff - Linux, FreeBSD, and Windows only. */\n\nint\niperf_setaffinity(struct iperf_test *test, int affinity)\n{\n#if defined(HAVE_SCHED_SETAFFINITY)\n    cpu_set_t cpu_set;\n\n    CPU_ZERO(&cpu_set);\n    CPU_SET(affinity, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_CPUSET_SETAFFINITY)\n    cpuset_t cpumask;\n\n    if(cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &test->cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n\n    CPU_ZERO(&cpumask);\n    CPU_SET(affinity, &cpumask);\n\n    if(cpuset_setaffinity(CPU_LEVEL_WHICH,CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_SETPROCESSAFFINITYMASK)\n\tHANDLE process = GetCurrentProcess();\n\tDWORD_PTR processAffinityMask = 1 << affinity;\n\n\tif (SetProcessAffinityMask(process, processAffinityMask) == 0) {\n\t\ti_errno = IEAFFINITY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n}\n\nint\niperf_clearaffinity(struct iperf_test *test)\n{\n#if defined(HAVE_SCHED_SETAFFINITY)\n    cpu_set_t cpu_set;\n    int i;\n\n    CPU_ZERO(&cpu_set);\n    for (i = 0; i < CPU_SETSIZE; ++i)\n\tCPU_SET(i, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_CPUSET_SETAFFINITY)\n    if(cpuset_setaffinity(CPU_LEVEL_WHICH,CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &test->cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_SETPROCESSAFFINITYMASK)\n\tHANDLE process = GetCurrentProcess();\n\tDWORD_PTR processAffinityMask;\n\tDWORD_PTR lpSystemAffinityMask;\n\n\tif (GetProcessAffinityMask(process, &processAffinityMask, &lpSystemAffinityMask) == 0\n\t\t\t|| SetProcessAffinityMask(process, lpSystemAffinityMask) == 0) {\n\t\ti_errno = IEAFFINITY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n}\n\nstatic char iperf_timestr[100];\nstatic char linebuffer[1024];\n\nint\niperf_printf(struct iperf_test *test, const char* format, ...)\n{\n    va_list argp;\n    int r = 0, r0;\n    time_t now;\n    struct tm *ltm = NULL;\n    char *ct = NULL;\n\n    /* Timestamp if requested */\n    if (iperf_get_test_timestamps(test)) {\n\ttime(&now);\n\tltm = localtime(&now);\n\tstrftime(iperf_timestr, sizeof(iperf_timestr), iperf_get_test_timestamp_format(test), ltm);\n\tct = iperf_timestr;\n    }\n\n    /*\n     * There are roughly two use cases here.  If we're the client,\n     * want to print stuff directly to the output stream.\n     * If we're the sender we might need to buffer up output to send\n     * to the client.\n     *\n     * This doesn't make a whole lot of difference except there are\n     * some chunks of output on the client (on particular the whole\n     * of the server output with --get-server-output) that could\n     * easily exceed the size of the line buffer, but which don't need\n     * to be buffered up anyway.\n     */\n    if (test->role == 'c') {\n\tif (ct) {\n            r0 = fprintf(test->outfile, \"%s\", ct);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n\t}\n\tif (test->title) {\n\t    r0 = fprintf(test->outfile, \"%s:  \", test->title);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n        }\n\tva_start(argp, format);\n\tr0 = vfprintf(test->outfile, format, argp);\n\tva_end(argp);\n        if (r0 < 0)\n            return r0;\n        r += r0;\n    }\n    else if (test->role == 's') {\n\tif (ct) {\n\t    r0 = snprintf(linebuffer, sizeof(linebuffer), \"%s\", ct);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n\t}\n        /* Should always be true as long as sizeof(ct) < sizeof(linebuffer) */\n        if (r < sizeof(linebuffer)) {\n            va_start(argp, format);\n            r0 = vsnprintf(linebuffer + r, sizeof(linebuffer) - r, format, argp);\n            va_end(argp);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n        }\n\tfprintf(test->outfile, \"%s\", linebuffer);\n\n\tif (test->role == 's' && iperf_get_test_get_server_output(test)) {\n\t    struct iperf_textline *l = (struct iperf_textline *) malloc(sizeof(struct iperf_textline));\n\t    l->line = strdup(linebuffer);\n\t    TAILQ_INSERT_TAIL(&(test->server_output_list), l, textlineentries);\n\t}\n    }\n    return r;\n}\n\nint\niflush(struct iperf_test *test)\n{\n    return fflush(test->outfile);\n}\n"], "fixing_code": ["/*\n * iperf, Copyright (c) 2014-2022, The Regents of the University of\n * California, through Lawrence Berkeley National Laboratory (subject\n * to receipt of any required approvals from the U.S. Dept. of\n * Energy).  All rights reserved.\n *\n * If you have questions about your rights to use or distribute this\n * software, please contact Berkeley Lab's Technology Transfer\n * Department at TTD@lbl.gov.\n *\n * NOTICE.  This software is owned by the U.S. Department of Energy.\n * As such, the U.S. Government has been granted for itself and others\n * acting on its behalf a paid-up, nonexclusive, irrevocable,\n * worldwide license in the Software to reproduce, prepare derivative\n * works, and perform publicly and display publicly.  Beginning five\n * (5) years after the date permission to assert copyright is obtained\n * from the U.S. Department of Energy, and subject to any subsequent\n * five (5) year renewals, the U.S. Government is granted for itself\n * and others acting on its behalf a paid-up, nonexclusive,\n * irrevocable, worldwide license in the Software to reproduce,\n * prepare derivative works, distribute copies to the public, perform\n * publicly and display publicly, and to permit others to do so.\n *\n * This code is distributed under a BSD style license, see the LICENSE file\n * for complete information.\n */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#define __USE_GNU\n\n#include \"iperf_config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <getopt.h>\n#include <errno.h>\n#include <signal.h>\n#include <unistd.h>\n#include <assert.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <stdarg.h>\n#include <math.h>\n\n#if defined(HAVE_CPUSET_SETAFFINITY)\n#include <sys/param.h>\n#include <sys/cpuset.h>\n#endif /* HAVE_CPUSET_SETAFFINITY */\n\n#if defined(__CYGWIN__) || defined(_WIN32) || defined(_WIN64) || defined(__WINDOWS__)\n#define CPU_SETSIZE __CPU_SETSIZE\n#endif /* __CYGWIN__, _WIN32, _WIN64, __WINDOWS__ */\n\n#if defined(HAVE_SETPROCESSAFFINITYMASK)\n#include <Windows.h>\n#endif /* HAVE_SETPROCESSAFFINITYMASK */\n\n#include \"net.h\"\n#include \"iperf.h\"\n#include \"iperf_api.h\"\n#include \"iperf_udp.h\"\n#include \"iperf_tcp.h\"\n#if defined(HAVE_SCTP_H)\n#include \"iperf_sctp.h\"\n#endif /* HAVE_SCTP_H */\n#include \"timer.h\"\n\n#include \"cjson.h\"\n#include \"units.h\"\n#include \"iperf_util.h\"\n#include \"iperf_locale.h\"\n#include \"version.h\"\n#if defined(HAVE_SSL)\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include \"iperf_auth.h\"\n#endif /* HAVE_SSL */\n\n/* Forwards. */\nstatic int send_parameters(struct iperf_test *test);\nstatic int get_parameters(struct iperf_test *test);\nstatic int send_results(struct iperf_test *test);\nstatic int get_results(struct iperf_test *test);\nstatic int diskfile_send(struct iperf_stream *sp);\nstatic int diskfile_recv(struct iperf_stream *sp);\nstatic int JSON_write(int fd, cJSON *json);\nstatic void print_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams);\nstatic cJSON *JSON_read(int fd);\n\n\n/*************************** Print usage functions ****************************/\n\nvoid\nusage()\n{\n    fputs(usage_shortstr, stderr);\n}\n\n\nvoid\nusage_long(FILE *f)\n{\n    fprintf(f, usage_longstr, DEFAULT_NO_MSG_RCVD_TIMEOUT, UDP_RATE / (1024*1024), DEFAULT_PACING_TIMER, DURATION, DEFAULT_TCP_BLKSIZE / 1024, DEFAULT_UDP_BLKSIZE);\n}\n\n\nvoid warning(const char *str)\n{\n    fprintf(stderr, \"warning: %s\\n\", str);\n}\n\n\n/************** Getter routines for some fields inside iperf_test *************/\n\nint\niperf_get_verbose(struct iperf_test *ipt)\n{\n    return ipt->verbose;\n}\n\nint\niperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}\n\nint\niperf_get_control_socket_mss(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck_mss;\n}\n\nint\niperf_get_test_omit(struct iperf_test *ipt)\n{\n    return ipt->omit;\n}\n\nint\niperf_get_test_duration(struct iperf_test *ipt)\n{\n    return ipt->duration;\n}\n\nuint64_t\niperf_get_test_rate(struct iperf_test *ipt)\n{\n    return ipt->settings->rate;\n}\n\nuint64_t\niperf_get_test_bitrate_limit(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit;\n}\n\ndouble\niperf_get_test_bitrate_limit_interval(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit_interval;\n}\n\nint\niperf_get_test_bitrate_limit_stats_per_interval(struct iperf_test *ipt)\n{\n    return ipt->settings->bitrate_limit_stats_per_interval;\n}\n\nuint64_t\niperf_get_test_fqrate(struct iperf_test *ipt)\n{\n    return ipt->settings->fqrate;\n}\n\nint\niperf_get_test_pacing_timer(struct iperf_test *ipt)\n{\n    return ipt->settings->pacing_timer;\n}\n\nuint64_t\niperf_get_test_bytes(struct iperf_test *ipt)\n{\n    return (uint64_t) ipt->settings->bytes;\n}\n\nuint64_t\niperf_get_test_blocks(struct iperf_test *ipt)\n{\n    return (uint64_t) ipt->settings->blocks;\n}\n\nint\niperf_get_test_burst(struct iperf_test *ipt)\n{\n    return ipt->settings->burst;\n}\n\nchar\niperf_get_test_role(struct iperf_test *ipt)\n{\n    return ipt->role;\n}\n\nint\niperf_get_test_reverse(struct iperf_test *ipt)\n{\n    return ipt->reverse;\n}\n\nint\niperf_get_test_bidirectional(struct iperf_test *ipt)\n{\n    return ipt->bidirectional;\n}\n\nint\niperf_get_test_blksize(struct iperf_test *ipt)\n{\n    return ipt->settings->blksize;\n}\n\nFILE *\niperf_get_test_outfile (struct iperf_test *ipt)\n{\n    return ipt->outfile;\n}\n\nint\niperf_get_test_socket_bufsize(struct iperf_test *ipt)\n{\n    return ipt->settings->socket_bufsize;\n}\n\ndouble\niperf_get_test_reporter_interval(struct iperf_test *ipt)\n{\n    return ipt->reporter_interval;\n}\n\ndouble\niperf_get_test_stats_interval(struct iperf_test *ipt)\n{\n    return ipt->stats_interval;\n}\n\nint\niperf_get_test_num_streams(struct iperf_test *ipt)\n{\n    return ipt->num_streams;\n}\n\nint\niperf_get_test_timestamps(struct iperf_test *ipt)\n{\n    return ipt->timestamps;\n}\n\nconst char *\niperf_get_test_timestamp_format(struct iperf_test *ipt)\n{\n    return ipt->timestamp_format;\n}\n\nint\niperf_get_test_repeating_payload(struct iperf_test *ipt)\n{\n    return ipt->repeating_payload;\n}\n\nint\niperf_get_test_bind_port(struct iperf_test *ipt)\n{\n    return ipt->bind_port;\n}\n\nint\niperf_get_test_server_port(struct iperf_test *ipt)\n{\n    return ipt->server_port;\n}\n\nchar*\niperf_get_test_server_hostname(struct iperf_test *ipt)\n{\n    return ipt->server_hostname;\n}\n\nchar*\niperf_get_test_template(struct iperf_test *ipt)\n{\n    return ipt->tmp_template;\n}\n\nint\niperf_get_test_protocol_id(struct iperf_test *ipt)\n{\n    return ipt->protocol->id;\n}\n\nint\niperf_get_test_json_output(struct iperf_test *ipt)\n{\n    return ipt->json_output;\n}\n\nchar *\niperf_get_test_json_output_string(struct iperf_test *ipt)\n{\n    return ipt->json_output_string;\n}\n\nint\niperf_get_test_zerocopy(struct iperf_test *ipt)\n{\n    return ipt->zerocopy;\n}\n\nint\niperf_get_test_get_server_output(struct iperf_test *ipt)\n{\n    return ipt->get_server_output;\n}\n\nchar\niperf_get_test_unit_format(struct iperf_test *ipt)\n{\n    return ipt->settings->unit_format;\n}\n\nchar *\niperf_get_test_bind_address(struct iperf_test *ipt)\n{\n    return ipt->bind_address;\n}\n\nchar *\niperf_get_test_bind_dev(struct iperf_test *ipt)\n{\n    return ipt->bind_dev;\n}\n\nint\niperf_get_test_udp_counters_64bit(struct iperf_test *ipt)\n{\n    return ipt->udp_counters_64bit;\n}\n\nint\niperf_get_test_one_off(struct iperf_test *ipt)\n{\n    return ipt->one_off;\n}\n\nint\niperf_get_test_tos(struct iperf_test *ipt)\n{\n    return ipt->settings->tos;\n}\n\nchar *\niperf_get_test_extra_data(struct iperf_test *ipt)\n{\n    return ipt->extra_data;\n}\n\nstatic const char iperf_version[] = IPERF_VERSION;\nchar *\niperf_get_iperf_version(void)\n{\n    return (char*)iperf_version;\n}\n\nint\niperf_get_test_no_delay(struct iperf_test *ipt)\n{\n    return ipt->no_delay;\n}\n\nint\niperf_get_test_connect_timeout(struct iperf_test *ipt)\n{\n    return ipt->settings->connect_timeout;\n}\n\nint\niperf_get_test_idle_timeout(struct iperf_test *ipt)\n{\n    return ipt->settings->idle_timeout;\n}\n\nint\niperf_get_dont_fragment(struct iperf_test *ipt)\n{\n    return ipt->settings->dont_fragment;\n}\n\nstruct iperf_time*\niperf_get_test_rcv_timeout(struct iperf_test *ipt)\n{\n    return &ipt->settings->rcv_timeout;\n}\n\nchar*\niperf_get_test_congestion_control(struct iperf_test* ipt)\n{\n    return ipt->congestion;\n}\n\nint\niperf_get_test_mss(struct iperf_test *ipt)\n{\n    return ipt->settings->mss;\n}\n\nint\niperf_get_mapped_v4(struct iperf_test* ipt)\n{\n    return ipt->mapped_v4;\n}\n\n/************** Setter routines for some fields inside iperf_test *************/\n\nvoid\niperf_set_verbose(struct iperf_test *ipt, int verbose)\n{\n    ipt->verbose = verbose;\n}\n\nvoid\niperf_set_control_socket(struct iperf_test *ipt, int ctrl_sck)\n{\n    ipt->ctrl_sck = ctrl_sck;\n}\n\nvoid\niperf_set_test_omit(struct iperf_test *ipt, int omit)\n{\n    ipt->omit = omit;\n}\n\nvoid\niperf_set_test_duration(struct iperf_test *ipt, int duration)\n{\n    ipt->duration = duration;\n}\n\nvoid\niperf_set_test_reporter_interval(struct iperf_test *ipt, double reporter_interval)\n{\n    ipt->reporter_interval = reporter_interval;\n}\n\nvoid\niperf_set_test_stats_interval(struct iperf_test *ipt, double stats_interval)\n{\n    ipt->stats_interval = stats_interval;\n}\n\nvoid\niperf_set_test_state(struct iperf_test *ipt, signed char state)\n{\n    ipt->state = state;\n}\n\nvoid\niperf_set_test_blksize(struct iperf_test *ipt, int blksize)\n{\n    ipt->settings->blksize = blksize;\n}\n\nvoid\niperf_set_test_logfile(struct iperf_test *ipt, const char *logfile)\n{\n    ipt->logfile = strdup(logfile);\n}\n\nvoid\niperf_set_test_rate(struct iperf_test *ipt, uint64_t rate)\n{\n    ipt->settings->rate = rate;\n}\n\nvoid\niperf_set_test_bitrate_limit_maximum(struct iperf_test *ipt, uint64_t total_rate)\n{\n    ipt->settings->bitrate_limit = total_rate;\n}\n\nvoid\niperf_set_test_bitrate_limit_interval(struct iperf_test *ipt, uint64_t bitrate_limit_interval)\n{\n    ipt->settings->bitrate_limit_interval = bitrate_limit_interval;\n}\n\nvoid\niperf_set_test_bitrate_limit_stats_per_interval(struct iperf_test *ipt, uint64_t bitrate_limit_stats_per_interval)\n{\n    ipt->settings->bitrate_limit_stats_per_interval = bitrate_limit_stats_per_interval;\n}\n\nvoid\niperf_set_test_fqrate(struct iperf_test *ipt, uint64_t fqrate)\n{\n    ipt->settings->fqrate = fqrate;\n}\n\nvoid\niperf_set_test_pacing_timer(struct iperf_test *ipt, int pacing_timer)\n{\n    ipt->settings->pacing_timer = pacing_timer;\n}\n\nvoid\niperf_set_test_bytes(struct iperf_test *ipt, uint64_t bytes)\n{\n    ipt->settings->bytes = (iperf_size_t) bytes;\n}\n\nvoid\niperf_set_test_blocks(struct iperf_test *ipt, uint64_t blocks)\n{\n    ipt->settings->blocks = (iperf_size_t) blocks;\n}\n\nvoid\niperf_set_test_burst(struct iperf_test *ipt, int burst)\n{\n    ipt->settings->burst = burst;\n}\n\nvoid\niperf_set_test_bind_port(struct iperf_test *ipt, int bind_port)\n{\n    ipt->bind_port = bind_port;\n}\n\nvoid\niperf_set_test_server_port(struct iperf_test *ipt, int srv_port)\n{\n    ipt->server_port = srv_port;\n}\n\nvoid\niperf_set_test_socket_bufsize(struct iperf_test *ipt, int socket_bufsize)\n{\n    ipt->settings->socket_bufsize = socket_bufsize;\n}\n\nvoid\niperf_set_test_num_streams(struct iperf_test *ipt, int num_streams)\n{\n    ipt->num_streams = num_streams;\n}\n\nvoid\niperf_set_test_repeating_payload(struct iperf_test *ipt, int repeating_payload)\n{\n    ipt->repeating_payload = repeating_payload;\n}\n\nvoid\niperf_set_test_timestamps(struct iperf_test *ipt, int timestamps)\n{\n    ipt->timestamps = timestamps;\n}\n\nvoid\niperf_set_test_timestamp_format(struct iperf_test *ipt, const char *tf)\n{\n    ipt->timestamp_format = strdup(tf);\n}\n\nvoid\niperf_set_mapped_v4(struct iperf_test *ipt, const int val)\n{\n    ipt->mapped_v4 = val;\n}\n\nstatic void\ncheck_sender_has_retransmits(struct iperf_test *ipt)\n{\n    if (ipt->mode != RECEIVER && ipt->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\tipt->sender_has_retransmits = 1;\n    else\n\tipt->sender_has_retransmits = 0;\n}\n\nvoid\niperf_set_test_role(struct iperf_test *ipt, char role)\n{\n    ipt->role = role;\n    if (!ipt->reverse) {\n        if (ipt->bidirectional)\n            ipt->mode = BIDIRECTIONAL;\n        else if (role == 'c')\n            ipt->mode = SENDER;\n        else if (role == 's')\n            ipt->mode = RECEIVER;\n    } else {\n        if (role == 'c')\n            ipt->mode = RECEIVER;\n        else if (role == 's')\n            ipt->mode = SENDER;\n    }\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_server_hostname(struct iperf_test *ipt, const char *server_hostname)\n{\n    ipt->server_hostname = strdup(server_hostname);\n}\n\nvoid\niperf_set_test_template(struct iperf_test *ipt, const char *tmp_template)\n{\n    ipt->tmp_template = strdup(tmp_template);\n}\n\nvoid\niperf_set_test_reverse(struct iperf_test *ipt, int reverse)\n{\n    ipt->reverse = reverse;\n    if (!ipt->reverse) {\n        if (ipt->role == 'c')\n            ipt->mode = SENDER;\n        else if (ipt->role == 's')\n            ipt->mode = RECEIVER;\n    } else {\n        if (ipt->role == 'c')\n            ipt->mode = RECEIVER;\n        else if (ipt->role == 's')\n            ipt->mode = SENDER;\n    }\n    check_sender_has_retransmits(ipt);\n}\n\nvoid\niperf_set_test_json_output(struct iperf_test *ipt, int json_output)\n{\n    ipt->json_output = json_output;\n}\n\nint\niperf_has_zerocopy( void )\n{\n    return has_sendfile();\n}\n\nvoid\niperf_set_test_zerocopy(struct iperf_test *ipt, int zerocopy)\n{\n    ipt->zerocopy = (zerocopy && has_sendfile());\n}\n\nvoid\niperf_set_test_get_server_output(struct iperf_test *ipt, int get_server_output)\n{\n    ipt->get_server_output = get_server_output;\n}\n\nvoid\niperf_set_test_unit_format(struct iperf_test *ipt, char unit_format)\n{\n    ipt->settings->unit_format = unit_format;\n}\n\n#if defined(HAVE_SSL)\nvoid\niperf_set_test_client_username(struct iperf_test *ipt, const char *client_username)\n{\n    ipt->settings->client_username = strdup(client_username);\n}\n\nvoid\niperf_set_test_client_password(struct iperf_test *ipt, const char *client_password)\n{\n    ipt->settings->client_password = strdup(client_password);\n}\n\nvoid\niperf_set_test_client_rsa_pubkey(struct iperf_test *ipt, const char *client_rsa_pubkey_base64)\n{\n    ipt->settings->client_rsa_pubkey = load_pubkey_from_base64(client_rsa_pubkey_base64);\n}\n\nvoid\niperf_set_test_server_authorized_users(struct iperf_test *ipt, const char *server_authorized_users)\n{\n    ipt->server_authorized_users = strdup(server_authorized_users);\n}\n\nvoid\niperf_set_test_server_skew_threshold(struct iperf_test *ipt, int server_skew_threshold)\n{\n    ipt->server_skew_threshold = server_skew_threshold;\n}\n\nvoid\niperf_set_test_server_rsa_privkey(struct iperf_test *ipt, const char *server_rsa_privkey_base64)\n{\n    ipt->server_rsa_private_key = load_privkey_from_base64(server_rsa_privkey_base64);\n}\n#endif // HAVE_SSL\n\nvoid\niperf_set_test_bind_address(struct iperf_test *ipt, const char *bnd_address)\n{\n    ipt->bind_address = strdup(bnd_address);\n}\n\nvoid\niperf_set_test_bind_dev(struct iperf_test *ipt, const char *bnd_dev)\n{\n    ipt->bind_dev = strdup(bnd_dev);\n}\n\nvoid\niperf_set_test_udp_counters_64bit(struct iperf_test *ipt, int udp_counters_64bit)\n{\n    ipt->udp_counters_64bit = udp_counters_64bit;\n}\n\nvoid\niperf_set_test_one_off(struct iperf_test *ipt, int one_off)\n{\n    ipt->one_off = one_off;\n}\n\nvoid\niperf_set_test_tos(struct iperf_test *ipt, int tos)\n{\n    ipt->settings->tos = tos;\n}\n\nvoid\niperf_set_test_extra_data(struct iperf_test *ipt, const char *dat)\n{\n    ipt->extra_data = strdup(dat);\n}\n\nvoid\niperf_set_test_bidirectional(struct iperf_test* ipt, int bidirectional)\n{\n    ipt->bidirectional = bidirectional;\n    if (bidirectional)\n        ipt->mode = BIDIRECTIONAL;\n    else\n        iperf_set_test_reverse(ipt, ipt->reverse);\n}\n\nvoid\niperf_set_test_no_delay(struct iperf_test* ipt, int no_delay)\n{\n    ipt->no_delay = no_delay;\n}\n\nvoid\niperf_set_test_connect_timeout(struct iperf_test* ipt, int ct)\n{\n    ipt->settings->connect_timeout = ct;\n}\n\nvoid\niperf_set_test_idle_timeout(struct iperf_test* ipt, int to)\n{\n    ipt->settings->idle_timeout = to;\n}\n\nvoid\niperf_set_dont_fragment(struct iperf_test* ipt, int dnf)\n{\n    ipt->settings->dont_fragment = dnf;\n}\n\nvoid\niperf_set_test_rcv_timeout(struct iperf_test* ipt, struct iperf_time* to)\n{\n    ipt->settings->rcv_timeout.secs = to->secs;\n    ipt->settings->rcv_timeout.usecs = to->usecs;\n}\n\nvoid\niperf_set_test_congestion_control(struct iperf_test* ipt, char* cc)\n{\n    ipt->congestion = strdup(cc);\n}\n\nvoid\niperf_set_test_mss(struct iperf_test *ipt, int mss)\n{\n    ipt->settings->mss = mss;\n}\n\n/********************** Get/set test protocol structure ***********************/\n\nstruct protocol *\nget_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id)\n            break;\n    }\n\n    if (prot == NULL)\n        i_errno = IEPROTOCOL;\n\n    return prot;\n}\n\nint\nset_protocol(struct iperf_test *test, int prot_id)\n{\n    struct protocol *prot = NULL;\n\n    SLIST_FOREACH(prot, &test->protocols, protocols) {\n        if (prot->id == prot_id) {\n            test->protocol = prot;\n\t    check_sender_has_retransmits(test);\n            return 0;\n        }\n    }\n\n    i_errno = IEPROTOCOL;\n    return -1;\n}\n\n\n/************************** Iperf callback functions **************************/\n\nvoid\niperf_on_new_stream(struct iperf_stream *sp)\n{\n    connect_msg(sp);\n}\n\nvoid\niperf_on_test_start(struct iperf_test *test)\n{\n    if (test->json_output) {\n\tcJSON_AddItemToObject(test->json_start, \"test_start\", iperf_json_printf(\"protocol: %s  num_streams: %d  blksize: %d  omit: %d  duration: %d  bytes: %d  blocks: %d  reverse: %d  tos: %d  target_bitrate: %d bidir: %d fqrate: %d\", test->protocol->name, (int64_t) test->num_streams, (int64_t) test->settings->blksize, (int64_t) test->omit, (int64_t) test->duration, (int64_t) test->settings->bytes, (int64_t) test->settings->blocks, test->reverse?(int64_t)1:(int64_t)0, (int64_t) test->settings->tos, (int64_t) test->settings->rate, (int64_t) test->bidirectional, (uint64_t) test->settings->fqrate));\n    } else {\n\tif (test->verbose) {\n\t    if (test->settings->bytes)\n\t\tiperf_printf(test, test_start_bytes, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->bytes, test->settings->tos);\n\t    else if (test->settings->blocks)\n\t\tiperf_printf(test, test_start_blocks, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->settings->blocks, test->settings->tos);\n\t    else\n\t\tiperf_printf(test, test_start_time, test->protocol->name, test->num_streams, test->settings->blksize, test->omit, test->duration, test->settings->tos);\n\t}\n    }\n}\n\n/* This converts an IPv6 string address from IPv4-mapped format into regular\n** old IPv4 format, which is easier on the eyes of network veterans.\n**\n** If the v6 address is not v4-mapped it is left alone.\n**\n** Returns 1 if the v6 address is v4-mapped, 0 otherwise.\n*/\nstatic int\nmapped_v4_to_regular_v4(char *str)\n{\n    char *prefix = \"::ffff:\";\n    int prefix_len;\n\n    prefix_len = strlen(prefix);\n    if (strncmp(str, prefix, prefix_len) == 0) {\n\tint str_len = strlen(str);\n\tmemmove(str, str + prefix_len, str_len - prefix_len + 1);\n\treturn 1;\n    }\n    return 0;\n}\n\nvoid\niperf_on_connect(struct iperf_test *test)\n{\n    time_t now_secs;\n    const char* rfc1123_fmt = \"%a, %d %b %Y %H:%M:%S %Z\";\n    char now_str[100];\n    char ipr[INET6_ADDRSTRLEN];\n    int port;\n    struct sockaddr_storage sa;\n    struct sockaddr_in *sa_inP;\n    struct sockaddr_in6 *sa_in6P;\n    socklen_t len;\n\n    now_secs = time((time_t*) 0);\n    (void) strftime(now_str, sizeof(now_str), rfc1123_fmt, gmtime(&now_secs));\n    if (test->json_output)\n\tcJSON_AddItemToObject(test->json_start, \"timestamp\", iperf_json_printf(\"time: %s  timesecs: %d\", now_str, (int64_t) now_secs));\n    else if (test->verbose)\n\tiperf_printf(test, report_time, now_str);\n\n    if (test->role == 'c') {\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"connecting_to\", iperf_json_printf(\"host: %s  port: %d\", test->server_hostname, (int64_t) test->server_port));\n\telse {\n\t    iperf_printf(test, report_connecting, test->server_hostname, test->server_port);\n\t    if (test->reverse)\n\t\tiperf_printf(test, report_reverse, test->server_hostname);\n\t}\n    } else {\n        len = sizeof(sa);\n        getpeername(test->ctrl_sck, (struct sockaddr *) &sa, &len);\n        if (getsockdomain(test->ctrl_sck) == AF_INET) {\n\t    sa_inP = (struct sockaddr_in *) &sa;\n            inet_ntop(AF_INET, &sa_inP->sin_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_inP->sin_port);\n        } else {\n\t    sa_in6P = (struct sockaddr_in6 *) &sa;\n            inet_ntop(AF_INET6, &sa_in6P->sin6_addr, ipr, sizeof(ipr));\n\t    port = ntohs(sa_in6P->sin6_port);\n        }\n\tif (mapped_v4_to_regular_v4(ipr)) {\n\t    iperf_set_mapped_v4(test, 1);\n\t}\n\tif (test->json_output)\n\t    cJSON_AddItemToObject(test->json_start, \"accepted_connection\", iperf_json_printf(\"host: %s  port: %d\", ipr, (int64_t) port));\n\telse\n\t    iperf_printf(test, report_accepted, ipr, port);\n    }\n    if (test->json_output) {\n\tcJSON_AddStringToObject(test->json_start, \"cookie\", test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n\t    if (test->settings->mss)\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss\", test->settings->mss);\n\t    else {\n\t\tcJSON_AddNumberToObject(test->json_start, \"tcp_mss_default\", test->ctrl_sck_mss);\n\t    }\n        }\n\t// Duplicate to make sure it appears on all output\n        cJSON_AddNumberToObject(test->json_start, \"target_bitrate\", test->settings->rate);\n        cJSON_AddNumberToObject(test->json_start, \"fq_rate\", test->settings->fqrate);\n    } else if (test->verbose) {\n        iperf_printf(test, report_cookie, test->cookie);\n        if (test->protocol->id == SOCK_STREAM) {\n            if (test->settings->mss)\n                iperf_printf(test, \"      TCP MSS: %d\\n\", test->settings->mss);\n            else {\n                iperf_printf(test, \"      TCP MSS: %d (default)\\n\", test->ctrl_sck_mss);\n            }\n        }\n        if (test->settings->rate)\n            iperf_printf(test, \"      Target Bitrate: %\"PRIu64\"\\n\", test->settings->rate);\n    }\n}\n\nvoid\niperf_on_test_finish(struct iperf_test *test)\n{\n}\n\n\n/******************************************************************************/\n\n/*\n * iperf_parse_hostname tries to split apart a string into hostname %\n * interface parts, which are returned in **p and **p1, if they\n * exist. If the %interface part is detected, and it's not an IPv6\n * link local address, then returns 1, else returns 0.\n *\n * Modifies the string pointed to by spec in-place due to the use of\n * strtok(3). The caller should strdup(3) or otherwise copy the string\n * if an unmodified copy is needed.\n */\nint\niperf_parse_hostname(struct iperf_test *test, char *spec, char **p, char **p1) {\n    struct in6_addr ipv6_addr;\n\n    // Format is <addr>[%<device>]\n    if ((*p = strtok(spec, \"%\")) != NULL &&\n        (*p1 = strtok(NULL, \"%\")) != NULL) {\n\n        /*\n         * If an IPv6 literal for a link-local address, then\n         * tell the caller to leave the \"%\" in the hostname.\n         */\n        if (inet_pton(AF_INET6, *p, &ipv6_addr) == 1 &&\n            IN6_IS_ADDR_LINKLOCAL(&ipv6_addr)) {\n            if (test->debug) {\n                iperf_printf(test, \"IPv6 link-local address literal detected\\n\");\n            }\n            return 0;\n        }\n        /*\n         * Other kind of address or FQDN. The interface name after\n         * \"%\" is a shorthand for --bind-dev.\n         */\n        else {\n            if (test->debug) {\n                iperf_printf(test, \"p %s p1 %s\\n\", *p, *p1);\n            }\n            return 1;\n        }\n    }\n    else {\n        if (test->debug) {\n            iperf_printf(test, \"noparse\\n\");\n        }\n        return 0;\n    }\n}\n\nint\niperf_parse_arguments(struct iperf_test *test, int argc, char **argv)\n{\n    static struct option longopts[] =\n    {\n        {\"port\", required_argument, NULL, 'p'},\n        {\"format\", required_argument, NULL, 'f'},\n        {\"interval\", required_argument, NULL, 'i'},\n        {\"daemon\", no_argument, NULL, 'D'},\n        {\"one-off\", no_argument, NULL, '1'},\n        {\"verbose\", no_argument, NULL, 'V'},\n        {\"json\", no_argument, NULL, 'J'},\n        {\"version\", no_argument, NULL, 'v'},\n        {\"server\", no_argument, NULL, 's'},\n        {\"client\", required_argument, NULL, 'c'},\n        {\"udp\", no_argument, NULL, 'u'},\n        {\"bitrate\", required_argument, NULL, 'b'},\n        {\"bandwidth\", required_argument, NULL, 'b'},\n\t{\"server-bitrate-limit\", required_argument, NULL, OPT_SERVER_BITRATE_LIMIT},\n        {\"time\", required_argument, NULL, 't'},\n        {\"bytes\", required_argument, NULL, 'n'},\n        {\"blockcount\", required_argument, NULL, 'k'},\n        {\"length\", required_argument, NULL, 'l'},\n        {\"parallel\", required_argument, NULL, 'P'},\n        {\"reverse\", no_argument, NULL, 'R'},\n        {\"bidir\", no_argument, NULL, OPT_BIDIRECTIONAL},\n        {\"window\", required_argument, NULL, 'w'},\n        {\"bind\", required_argument, NULL, 'B'},\n#if defined(HAVE_SO_BINDTODEVICE)\n        {\"bind-dev\", required_argument, NULL, OPT_BIND_DEV},\n#endif /* HAVE_SO_BINDTODEVICE */\n        {\"cport\", required_argument, NULL, OPT_CLIENT_PORT},\n        {\"set-mss\", required_argument, NULL, 'M'},\n        {\"no-delay\", no_argument, NULL, 'N'},\n        {\"version4\", no_argument, NULL, '4'},\n        {\"version6\", no_argument, NULL, '6'},\n        {\"tos\", required_argument, NULL, 'S'},\n        {\"dscp\", required_argument, NULL, OPT_DSCP},\n\t{\"extra-data\", required_argument, NULL, OPT_EXTRA_DATA},\n#if defined(HAVE_FLOWLABEL)\n        {\"flowlabel\", required_argument, NULL, 'L'},\n#endif /* HAVE_FLOWLABEL */\n        {\"zerocopy\", no_argument, NULL, 'Z'},\n        {\"omit\", required_argument, NULL, 'O'},\n        {\"file\", required_argument, NULL, 'F'},\n        {\"repeating-payload\", no_argument, NULL, OPT_REPEATING_PAYLOAD},\n        {\"timestamps\", optional_argument, NULL, OPT_TIMESTAMPS},\n#if defined(HAVE_CPU_AFFINITY)\n        {\"affinity\", required_argument, NULL, 'A'},\n#endif /* HAVE_CPU_AFFINITY */\n        {\"title\", required_argument, NULL, 'T'},\n#if defined(HAVE_TCP_CONGESTION)\n        {\"congestion\", required_argument, NULL, 'C'},\n        {\"linux-congestion\", required_argument, NULL, 'C'},\n#endif /* HAVE_TCP_CONGESTION */\n#if defined(HAVE_SCTP_H)\n        {\"sctp\", no_argument, NULL, OPT_SCTP},\n        {\"nstreams\", required_argument, NULL, OPT_NUMSTREAMS},\n        {\"xbind\", required_argument, NULL, 'X'},\n#endif\n\t{\"pidfile\", required_argument, NULL, 'I'},\n\t{\"logfile\", required_argument, NULL, OPT_LOGFILE},\n\t{\"forceflush\", no_argument, NULL, OPT_FORCEFLUSH},\n\t{\"get-server-output\", no_argument, NULL, OPT_GET_SERVER_OUTPUT},\n\t{\"udp-counters-64bit\", no_argument, NULL, OPT_UDP_COUNTERS_64BIT},\n \t{\"no-fq-socket-pacing\", no_argument, NULL, OPT_NO_FQ_SOCKET_PACING},\n#if defined(HAVE_DONT_FRAGMENT)\n\t{\"dont-fragment\", no_argument, NULL, OPT_DONT_FRAGMENT},\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n    {\"username\", required_argument, NULL, OPT_CLIENT_USERNAME},\n    {\"rsa-public-key-path\", required_argument, NULL, OPT_CLIENT_RSA_PUBLIC_KEY},\n    {\"rsa-private-key-path\", required_argument, NULL, OPT_SERVER_RSA_PRIVATE_KEY},\n    {\"authorized-users-path\", required_argument, NULL, OPT_SERVER_AUTHORIZED_USERS},\n    {\"time-skew-threshold\", required_argument, NULL, OPT_SERVER_SKEW_THRESHOLD},\n#endif /* HAVE_SSL */\n\t{\"fq-rate\", required_argument, NULL, OPT_FQ_RATE},\n\t{\"pacing-timer\", required_argument, NULL, OPT_PACING_TIMER},\n\t{\"connect-timeout\", required_argument, NULL, OPT_CONNECT_TIMEOUT},\n        {\"idle-timeout\", required_argument, NULL, OPT_IDLE_TIMEOUT},\n        {\"rcv-timeout\", required_argument, NULL, OPT_RCV_TIMEOUT},\n        {\"snd-timeout\", required_argument, NULL, OPT_SND_TIMEOUT},\n        {\"debug\", optional_argument, NULL, 'd'},\n        {\"help\", no_argument, NULL, 'h'},\n        {NULL, 0, NULL, 0}\n    };\n    int flag;\n    int portno;\n    int blksize;\n    int server_flag, client_flag, rate_flag, duration_flag, rcv_timeout_flag, snd_timeout_flag;\n    char *endptr;\n#if defined(HAVE_CPU_AFFINITY)\n    char* comma;\n#endif /* HAVE_CPU_AFFINITY */\n    char* slash;\n    char *p, *p1;\n    struct xbind_entry *xbe;\n    double farg;\n    int rcv_timeout_in = 0;\n\n    blksize = 0;\n    server_flag = client_flag = rate_flag = duration_flag = rcv_timeout_flag = snd_timeout_flag =0;\n#if defined(HAVE_SSL)\n    char *client_username = NULL, *client_rsa_public_key = NULL, *server_rsa_private_key = NULL;\n#endif /* HAVE_SSL */\n\n    while ((flag = getopt_long(argc, argv, \"p:f:i:D1VJvsc:ub:t:n:k:l:P:Rw:B:M:N46S:L:ZO:F:A:T:C:dI:hX:\", longopts, NULL)) != -1) {\n        switch (flag) {\n            case 'p':\n\t\tportno = atoi(optarg);\n\t\tif (portno < 1 || portno > 65535) {\n\t\t    i_errno = IEBADPORT;\n\t\t    return -1;\n\t\t}\n\t\ttest->server_port = portno;\n                break;\n            case 'f':\n\t\tif (!optarg) {\n\t\t    i_errno = IEBADFORMAT;\n\t\t    return -1;\n\t\t}\n\t\ttest->settings->unit_format = *optarg;\n\t\tif (test->settings->unit_format == 'k' ||\n\t\t    test->settings->unit_format == 'K' ||\n\t\t    test->settings->unit_format == 'm' ||\n\t\t    test->settings->unit_format == 'M' ||\n\t\t    test->settings->unit_format == 'g' ||\n\t\t    test->settings->unit_format == 'G' ||\n\t\t    test->settings->unit_format == 't' ||\n\t\t    test->settings->unit_format == 'T') {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t    i_errno = IEBADFORMAT;\n\t\t    return -1;\n\t\t}\n                break;\n            case 'i':\n                /* XXX: could potentially want separate stat collection and reporting intervals,\n                   but just set them to be the same for now */\n                test->stats_interval = test->reporter_interval = atof(optarg);\n                if ((test->stats_interval < MIN_INTERVAL || test->stats_interval > MAX_INTERVAL) && test->stats_interval != 0) {\n                    i_errno = IEINTERVAL;\n                    return -1;\n                }\n                break;\n            case 'D':\n\t\ttest->daemon = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case '1':\n\t\ttest->one_off = 1;\n\t\tserver_flag = 1;\n\t        break;\n            case 'V':\n                test->verbose = 1;\n                break;\n            case 'J':\n                test->json_output = 1;\n                break;\n            case 'v':\n                printf(\"%s (cJSON %s)\\n%s\\n%s\\n\", version, cJSON_Version(), get_system_info(),\n\t\t       get_optional_features());\n                exit(0);\n            case 's':\n                if (test->role == 'c') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 's');\n                break;\n            case 'c':\n                if (test->role == 's') {\n                    i_errno = IESERVCLIENT;\n                    return -1;\n                }\n\t\tiperf_set_test_role(test, 'c');\n\t\tiperf_set_test_server_hostname(test, optarg);\n\n                if (iperf_parse_hostname(test, optarg, &p, &p1)) {\n#if defined(HAVE_SO_BINDTODEVICE)\n                    /* Get rid of the hostname we saved earlier. */\n                    free(iperf_get_test_server_hostname(test));\n                    iperf_set_test_server_hostname(test, p);\n                    iperf_set_test_bind_dev(test, p1);\n#else /* HAVE_SO_BINDTODEVICE */\n                    i_errno = IEBINDDEVNOSUPPORT;\n                    return -1;\n#endif /* HAVE_SO_BINDTODEVICE */\n                }\n                break;\n            case 'u':\n                set_protocol(test, Pudp);\n\t\tclient_flag = 1;\n                break;\n            case OPT_SCTP:\n#if defined(HAVE_SCTP_H)\n                set_protocol(test, Psctp);\n                client_flag = 1;\n                break;\n#else /* HAVE_SCTP_H */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_SCTP_H */\n\n            case OPT_NUMSTREAMS:\n#if defined(linux) || defined(__FreeBSD__)\n                test->settings->num_ostreams = unit_atoi(optarg);\n                client_flag = 1;\n#else /* linux */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* linux */\n            case 'b':\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->burst = atoi(slash);\n\t\t    if (test->settings->burst <= 0 ||\n\t\t        test->settings->burst > MAX_BURST) {\n\t\t\ti_errno = IEBURST;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n                test->settings->rate = unit_atof_rate(optarg);\n\t\trate_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case OPT_SERVER_BITRATE_LIMIT:\n\t\tslash = strchr(optarg, '/');\n\t\tif (slash) {\n\t\t    *slash = '\\0';\n\t\t    ++slash;\n\t\t    test->settings->bitrate_limit_interval = atof(slash);\n\t\t    if (test->settings->bitrate_limit_interval != 0 &&\t/* Using same Max/Min limits as for Stats Interval */\n\t\t        (test->settings->bitrate_limit_interval < MIN_INTERVAL || test->settings->bitrate_limit_interval > MAX_INTERVAL) ) {\n\t\t\ti_errno = IETOTALINTERVAL;\n\t\t\treturn -1;\n\t\t    }\n\t\t}\n\t\ttest->settings->bitrate_limit = unit_atof_rate(optarg);\n\t\tserver_flag = 1;\n\t        break;\n            case 't':\n                test->duration = atoi(optarg);\n                if (test->duration > MAX_TIME) {\n                    i_errno = IEDURATION;\n                    return -1;\n                }\n\t\tduration_flag = 1;\n\t\tclient_flag = 1;\n                break;\n            case 'n':\n                test->settings->bytes = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'k':\n                test->settings->blocks = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'l':\n                blksize = unit_atoi(optarg);\n\t\tclient_flag = 1;\n                break;\n            case 'P':\n                test->num_streams = atoi(optarg);\n                if (test->num_streams > MAX_STREAMS) {\n                    i_errno = IENUMSTREAMS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'R':\n                if (test->bidirectional) {\n                    i_errno = IEREVERSEBIDIR;\n                    return -1;\n                }\n\t\tiperf_set_test_reverse(test, 1);\n\t\tclient_flag = 1;\n                break;\n            case OPT_BIDIRECTIONAL:\n                if (test->reverse) {\n                    i_errno = IEREVERSEBIDIR;\n                    return -1;\n                }\n                iperf_set_test_bidirectional(test, 1);\n                client_flag = 1;\n                break;\n            case 'w':\n                // XXX: This is a socket buffer, not specific to TCP\n\t\t// Do sanity checks as double-precision floating point\n\t\t// to avoid possible integer overflows.\n                farg = unit_atof(optarg);\n                if (farg > (double) MAX_TCP_BUFFER) {\n                    i_errno = IEBUFSIZE;\n                    return -1;\n                }\n                test->settings->socket_bufsize = (int) farg;\n\t\tclient_flag = 1;\n                break;\n\n            case 'B':\n                iperf_set_test_bind_address(test, optarg);\n\n                if (iperf_parse_hostname(test, optarg, &p, &p1)) {\n#if defined(HAVE_SO_BINDTODEVICE)\n                    /* Get rid of the hostname we saved earlier. */\n                    free(iperf_get_test_bind_address(test));\n                    iperf_set_test_bind_address(test, p);\n                    iperf_set_test_bind_dev(test, p1);\n#else /* HAVE_SO_BINDTODEVICE */\n                    i_errno = IEBINDDEVNOSUPPORT;\n                    return -1;\n#endif /* HAVE_SO_BINDTODEVICE */\n                }\n                break;\n#if defined (HAVE_SO_BINDTODEVICE)\n            case OPT_BIND_DEV:\n                iperf_set_test_bind_dev(test, optarg);\n                break;\n#endif /* HAVE_SO_BINDTODEVICE */\n            case OPT_CLIENT_PORT:\n\t\tportno = atoi(optarg);\n\t\tif (portno < 1 || portno > 65535) {\n\t\t    i_errno = IEBADPORT;\n\t\t    return -1;\n\t\t}\n                test->bind_port = portno;\n                break;\n            case 'M':\n                test->settings->mss = atoi(optarg);\n                if (test->settings->mss > MAX_MSS) {\n                    i_errno = IEMSS;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'N':\n                test->no_delay = 1;\n\t\tclient_flag = 1;\n                break;\n            case '4':\n                test->settings->domain = AF_INET;\n                break;\n            case '6':\n                test->settings->domain = AF_INET6;\n                break;\n            case 'S':\n                test->settings->tos = strtol(optarg, &endptr, 0);\n\t\tif (endptr == optarg ||\n\t\t    test->settings->tos < 0 ||\n\t\t    test->settings->tos > 255) {\n\t\t    i_errno = IEBADTOS;\n\t\t    return -1;\n\t\t}\n\t\tclient_flag = 1;\n                break;\n\t    case OPT_DSCP:\n                test->settings->tos = parse_qos(optarg);\n\t\tif(test->settings->tos < 0) {\n\t\t\ti_errno = IEBADTOS;\n\t\t\treturn -1;\n\t\t}\n\t\tclient_flag = 1;\n                break;\n\t    case OPT_EXTRA_DATA:\n\t\ttest->extra_data = strdup(optarg);\n\t\tclient_flag = 1;\n\t        break;\n            case 'L':\n#if defined(HAVE_FLOWLABEL)\n                test->settings->flowlabel = strtol(optarg, &endptr, 0);\n\t\tif (endptr == optarg ||\n\t\t    test->settings->flowlabel < 1 || test->settings->flowlabel > 0xfffff) {\n                    i_errno = IESETFLOW;\n                    return -1;\n\t\t}\n\t\tclient_flag = 1;\n#else /* HAVE_FLOWLABEL */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_FLOWLABEL */\n                break;\n            case 'X':\n\t\txbe = (struct xbind_entry *)malloc(sizeof(struct xbind_entry));\n                if (!xbe) {\n\t\t    i_errno = IESETSCTPBINDX;\n                    return -1;\n                }\n\t        memset(xbe, 0, sizeof(*xbe));\n                xbe->name = strdup(optarg);\n                if (!xbe->name) {\n\t\t    i_errno = IESETSCTPBINDX;\n                    return -1;\n                }\n\t\tTAILQ_INSERT_TAIL(&test->xbind_addrs, xbe, link);\n                break;\n            case 'Z':\n                if (!has_sendfile()) {\n                    i_errno = IENOSENDFILE;\n                    return -1;\n                }\n                test->zerocopy = 1;\n\t\tclient_flag = 1;\n                break;\n            case OPT_REPEATING_PAYLOAD:\n                test->repeating_payload = 1;\n                client_flag = 1;\n                break;\n            case OPT_TIMESTAMPS:\n                iperf_set_test_timestamps(test, 1);\n\t\tif (optarg) {\n\t\t    iperf_set_test_timestamp_format(test, optarg);\n\t\t}\n\t\telse {\n\t\t    iperf_set_test_timestamp_format(test, TIMESTAMP_FORMAT);\n\t\t}\n                break;\n            case 'O':\n                test->omit = atoi(optarg);\n                if (test->omit < 0 || test->omit > 60) {\n                    i_errno = IEOMIT;\n                    return -1;\n                }\n\t\tclient_flag = 1;\n                break;\n            case 'F':\n                test->diskfile_name = optarg;\n                break;\n            case OPT_IDLE_TIMEOUT:\n                test->settings->idle_timeout = atoi(optarg);\n                if (test->settings->idle_timeout < 1 || test->settings->idle_timeout > MAX_TIME) {\n                    i_errno = IEIDLETIMEOUT;\n                    return -1;\n                }\n\t\tserver_flag = 1;\n\t        break;\n            case OPT_RCV_TIMEOUT:\n                rcv_timeout_in = atoi(optarg);\n                if (rcv_timeout_in < MIN_NO_MSG_RCVD_TIMEOUT || rcv_timeout_in > MAX_TIME * SEC_TO_mS) {\n                    i_errno = IERCVTIMEOUT;\n                    return -1;\n                }\n                test->settings->rcv_timeout.secs = rcv_timeout_in / SEC_TO_mS;\n                test->settings->rcv_timeout.usecs = (rcv_timeout_in % SEC_TO_mS) * mS_TO_US;\n                rcv_timeout_flag = 1;\n\t        break;\n#if defined(HAVE_TCP_USER_TIMEOUT)\n            case OPT_SND_TIMEOUT:\n                test->settings->snd_timeout = atoi(optarg);\n                if (test->settings->snd_timeout < 0 || test->settings->snd_timeout > MAX_TIME * SEC_TO_mS) {\n                    i_errno = IESNDTIMEOUT;\n                    return -1;\n                }\n                snd_timeout_flag = 1;\n\t        break;\n#endif /* HAVE_TCP_USER_TIMEOUT */\n            case 'A':\n#if defined(HAVE_CPU_AFFINITY)\n                test->affinity = strtol(optarg, &endptr, 0);\n                if (endptr == optarg ||\n\t\t    test->affinity < 0 || test->affinity > 1024) {\n                    i_errno = IEAFFINITY;\n                    return -1;\n                }\n\t\tcomma = strchr(optarg, ',');\n\t\tif (comma != NULL) {\n\t\t    test->server_affinity = atoi(comma+1);\n\t\t    if (test->server_affinity < 0 || test->server_affinity > 1024) {\n\t\t\ti_errno = IEAFFINITY;\n\t\t\treturn -1;\n\t\t    }\n\t\t    client_flag = 1;\n\t\t}\n#else /* HAVE_CPU_AFFINITY */\n                i_errno = IEUNIMP;\n                return -1;\n#endif /* HAVE_CPU_AFFINITY */\n                break;\n            case 'T':\n                test->title = strdup(optarg);\n\t\tclient_flag = 1;\n                break;\n\t    case 'C':\n#if defined(HAVE_TCP_CONGESTION)\n\t\ttest->congestion = strdup(optarg);\n\t\tclient_flag = 1;\n#else /* HAVE_TCP_CONGESTION */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif /* HAVE_TCP_CONGESTION */\n\t\tbreak;\n\t    case 'd':\n\t\ttest->debug = 1;\n                test->debug_level = DEBUG_LEVEL_MAX;\n                if (optarg) {\n                    test->debug_level = atoi(optarg);\n                    if (test->debug_level < 0)\n                        test->debug_level = DEBUG_LEVEL_MAX;\n                }\n\t\tbreak;\n\t    case 'I':\n\t\ttest->pidfile = strdup(optarg);\n\t        break;\n\t    case OPT_LOGFILE:\n\t\ttest->logfile = strdup(optarg);\n\t\tbreak;\n\t    case OPT_FORCEFLUSH:\n\t\ttest->forceflush = 1;\n\t\tbreak;\n\t    case OPT_GET_SERVER_OUTPUT:\n\t\ttest->get_server_output = 1;\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case OPT_UDP_COUNTERS_64BIT:\n\t\ttest->udp_counters_64bit = 1;\n\t\tbreak;\n\t    case OPT_NO_FQ_SOCKET_PACING:\n#if defined(HAVE_SO_MAX_PACING_RATE)\n\t\tprintf(\"Warning:  --no-fq-socket-pacing is deprecated\\n\");\n\t\ttest->settings->fqrate = 0;\n\t\tclient_flag = 1;\n#else /* HAVE_SO_MAX_PACING_RATE */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif\n\t\tbreak;\n\t    case OPT_FQ_RATE:\n#if defined(HAVE_SO_MAX_PACING_RATE)\n\t\ttest->settings->fqrate = unit_atof_rate(optarg);\n\t\tclient_flag = 1;\n#else /* HAVE_SO_MAX_PACING_RATE */\n\t\ti_errno = IEUNIMP;\n\t\treturn -1;\n#endif\n\t\tbreak;\n#if defined(HAVE_DONT_FRAGMENT)\n        case OPT_DONT_FRAGMENT:\n            test->settings->dont_fragment = 1;\n            client_flag = 1;\n            break;\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n        case OPT_CLIENT_USERNAME:\n            client_username = strdup(optarg);\n            break;\n        case OPT_CLIENT_RSA_PUBLIC_KEY:\n            client_rsa_public_key = strdup(optarg);\n            break;\n        case OPT_SERVER_RSA_PRIVATE_KEY:\n            server_rsa_private_key = strdup(optarg);\n            break;\n        case OPT_SERVER_AUTHORIZED_USERS:\n            test->server_authorized_users = strdup(optarg);\n            break;\n        case OPT_SERVER_SKEW_THRESHOLD:\n            test->server_skew_threshold = atoi(optarg);\n            if(test->server_skew_threshold <= 0){\n                i_errno = IESKEWTHRESHOLD;\n                return -1;\n            }\n            break;\n#endif /* HAVE_SSL */\n\t    case OPT_PACING_TIMER:\n\t\ttest->settings->pacing_timer = unit_atoi(optarg);\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case OPT_CONNECT_TIMEOUT:\n\t\ttest->settings->connect_timeout = unit_atoi(optarg);\n\t\tclient_flag = 1;\n\t\tbreak;\n\t    case 'h':\n\t\tusage_long(stdout);\n\t\texit(0);\n            default:\n                fprintf(stderr, \"\\n\");\n                usage();\n                exit(1);\n        }\n    }\n\n    /* Check flag / role compatibility. */\n    if (test->role == 'c' && server_flag) {\n        i_errno = IESERVERONLY;\n        return -1;\n    }\n    if (test->role == 's' && client_flag) {\n        i_errno = IECLIENTONLY;\n        return -1;\n    }\n\n#if defined(HAVE_SSL)\n\n    if (test->role == 's' && (client_username || client_rsa_public_key)){\n        i_errno = IECLIENTONLY;\n        return -1;\n    } else if (test->role == 'c' && (client_username || client_rsa_public_key) &&\n        !(client_username && client_rsa_public_key)) {\n        i_errno = IESETCLIENTAUTH;\n        return -1;\n    } else if (test->role == 'c' && (client_username && client_rsa_public_key)){\n\n        char *client_password = NULL;\n        size_t s;\n        if (test_load_pubkey_from_file(client_rsa_public_key) < 0){\n            iperf_err(test, \"%s\\n\", ERR_error_string(ERR_get_error(), NULL));\n            i_errno = IESETCLIENTAUTH;\n            return -1;\n        }\n        /* Need to copy env var, so we can do a common free */\n        if ((client_password = getenv(\"IPERF3_PASSWORD\")) != NULL)\n             client_password = strdup(client_password);\n        else if (iperf_getpass(&client_password, &s, stdin) < 0){\n            i_errno = IESETCLIENTAUTH;\n            return -1;\n        }\n\n        test->settings->client_username = client_username;\n        test->settings->client_password = client_password;\n        test->settings->client_rsa_pubkey = load_pubkey_from_file(client_rsa_public_key);\n\tfree(client_rsa_public_key);\n\tclient_rsa_public_key = NULL;\n    }\n\n    if (test->role == 'c' && (server_rsa_private_key || test->server_authorized_users)){\n        i_errno = IESERVERONLY;\n        return -1;\n    } else if (test->role == 'c' && (test->server_skew_threshold != 0)){\n        i_errno = IESERVERONLY;\n        return -1;\n    } else if (test->role == 'c' && rcv_timeout_flag && test->mode == SENDER){\n        i_errno = IERVRSONLYRCVTIMEOUT;\n        return -1;\n    } else if (test->role == 's' && (server_rsa_private_key || test->server_authorized_users) &&\n        !(server_rsa_private_key && test->server_authorized_users)) {\n         i_errno = IESETSERVERAUTH;\n        return -1;\n    } else if (test->role == 's' && server_rsa_private_key) {\n        test->server_rsa_private_key = load_privkey_from_file(server_rsa_private_key);\n        if (test->server_rsa_private_key == NULL){\n            iperf_err(test, \"%s\\n\", ERR_error_string(ERR_get_error(), NULL));\n            i_errno = IESETSERVERAUTH;\n            return -1;\n        }\n\t    free(server_rsa_private_key);\n\t    server_rsa_private_key = NULL;\n\n        if(test->server_skew_threshold == 0){\n            // Set default value for time skew threshold\n            test->server_skew_threshold=10;\n        }\n    }\n\n#endif //HAVE_SSL\n\n    // File cannot be transferred using UDP because of the UDP packets header (packet number, etc.)\n    if(test->role == 'c' && test->diskfile_name != (char*) 0 && test->protocol->id == Pudp) {\n        i_errno = IEUDPFILETRANSFER;\n        return -1;\n    }\n\n    if (blksize == 0) {\n\tif (test->protocol->id == Pudp)\n\t    blksize = 0;\t/* try to dynamically determine from MSS */\n\telse if (test->protocol->id == Psctp)\n\t    blksize = DEFAULT_SCTP_BLKSIZE;\n\telse\n\t    blksize = DEFAULT_TCP_BLKSIZE;\n    }\n    if ((test->protocol->id != Pudp && blksize <= 0)\n\t|| blksize > MAX_BLOCKSIZE) {\n\ti_errno = IEBLOCKSIZE;\n\treturn -1;\n    }\n    if (test->protocol->id == Pudp &&\n\t(blksize > 0 &&\n\t    (blksize < MIN_UDP_BLOCKSIZE || blksize > MAX_UDP_BLOCKSIZE))) {\n\ti_errno = IEUDPBLOCKSIZE;\n\treturn -1;\n    }\n    test->settings->blksize = blksize;\n\n    if (!rate_flag)\n\ttest->settings->rate = test->protocol->id == Pudp ? UDP_RATE : 0;\n\n    /* if no bytes or blocks specified, nor a duration_flag, and we have -F,\n    ** get the file-size as the bytes count to be transferred\n    */\n    if (test->settings->bytes == 0 &&\n        test->settings->blocks == 0 &&\n        ! duration_flag &&\n        test->diskfile_name != (char*) 0 &&\n        test->role == 'c'\n        ){\n        struct stat st;\n        if( stat(test->diskfile_name, &st) == 0 ){\n            iperf_size_t file_bytes = st.st_size;\n            test->settings->bytes = file_bytes;\n            if (test->debug)\n                printf(\"End condition set to file-size: %\"PRIu64\" bytes\\n\", test->settings->bytes);\n        }\n        // if failing to read file stat, it should fallback to default duration mode\n    }\n\n    if ((test->settings->bytes != 0 || test->settings->blocks != 0) && ! duration_flag)\n        test->duration = 0;\n\n    /* Disallow specifying multiple test end conditions. The code actually\n    ** works just fine without this prohibition. As soon as any one of the\n    ** three possible end conditions is met, the test ends. So this check\n    ** could be removed if desired.\n    */\n    if ((duration_flag && test->settings->bytes != 0) ||\n        (duration_flag && test->settings->blocks != 0) ||\n\t(test->settings->bytes != 0 && test->settings->blocks != 0)) {\n        i_errno = IEENDCONDITIONS;\n        return -1;\n    }\n\n    /* For subsequent calls to getopt */\n#ifdef __APPLE__\n    optreset = 1;\n#endif\n    optind = 0;\n\n    if ((test->role != 'c') && (test->role != 's')) {\n        i_errno = IENOROLE;\n        return -1;\n    }\n\n    /* Set Total-rate average interval to multiplicity of State interval */\n    if (test->settings->bitrate_limit_interval != 0) {\n\ttest->settings->bitrate_limit_stats_per_interval =\n\t    (test->settings->bitrate_limit_interval <= test->stats_interval ?\n\t    1 : round(test->settings->bitrate_limit_interval/test->stats_interval) );\n    }\n\n    /* Show warning if JSON output is used with explicit report format */\n    if ((test->json_output) && (test->settings->unit_format != 'a')) {\n        warning(\"Report format (-f) flag ignored with JSON output (-J)\");\n    }\n\n    /* Show warning if JSON output is used with verbose or debug flags */\n    if (test->json_output && test->verbose) {\n        warning(\"Verbose output (-v) may interfere with JSON output (-J)\");\n    }\n    if (test->json_output && test->debug) {\n        warning(\"Debug output (-d) may interfere with JSON output (-J)\");\n    }\n\n    return 0;\n}\n\n/*\n * Open the file specified by test->logfile and set test->outfile to its' FD.\n */\nint iperf_open_logfile(struct iperf_test *test)\n{\n    test->outfile = fopen(test->logfile, \"a+\");\n    if (test->outfile == NULL) {\n        i_errno = IELOGFILE;\n        return -1;\n    }\n\n    return 0;\n}\n\nvoid iperf_close_logfile(struct iperf_test *test)\n{\n    if (test->outfile && test->outfile != stdout) {\n        fclose(test->outfile);\n        test->outfile = NULL;\n    }\n}\n\nint\niperf_set_send_state(struct iperf_test *test, signed char state)\n{\n    if (test->ctrl_sck >= 0) {\n        test->state = state;\n        if (Nwrite(test->ctrl_sck, (char*) &state, sizeof(state), Ptcp) < 0) {\n\t    i_errno = IESENDMESSAGE;\n\t    return -1;\n        }\n    }\n    return 0;\n}\n\nvoid\niperf_check_throttle(struct iperf_stream *sp, struct iperf_time *nowP)\n{\n    struct iperf_time temp_time;\n    double seconds;\n    uint64_t bits_per_second;\n\n    if (sp->test->done || sp->test->settings->rate == 0)\n        return;\n    iperf_time_diff(&sp->result->start_time_fixed, nowP, &temp_time);\n    seconds = iperf_time_in_secs(&temp_time);\n    bits_per_second = sp->result->bytes_sent * 8 / seconds;\n    if (bits_per_second < sp->test->settings->rate) {\n        sp->green_light = 1;\n        FD_SET(sp->socket, &sp->test->write_set);\n    } else {\n        sp->green_light = 0;\n        FD_CLR(sp->socket, &sp->test->write_set);\n    }\n}\n\n/* Verify that average traffic is not greater than the specified limit */\nvoid\niperf_check_total_rate(struct iperf_test *test, iperf_size_t last_interval_bytes_transferred)\n{\n    double seconds;\n    uint64_t bits_per_second;\n    iperf_size_t total_bytes;\n    int i;\n\n    if (test->done || test->settings->bitrate_limit == 0)    // Continue only if check should be done\n        return;\n\n    /* Add last inetrval's transferred bytes to the array */\n    if (++test->bitrate_limit_last_interval_index >= test->settings->bitrate_limit_stats_per_interval)\n        test->bitrate_limit_last_interval_index = 0;\n    test->bitrate_limit_intervals_traffic_bytes[test->bitrate_limit_last_interval_index] = last_interval_bytes_transferred;\n\n    /* Ensure that enough stats periods passed to allow averaging throughput */\n    test->bitrate_limit_stats_count += 1;\n    if (test->bitrate_limit_stats_count < test->settings->bitrate_limit_stats_per_interval)\n        return;\n\n     /* Calculating total bytes traffic to be averaged */\n    for (total_bytes = 0, i = 0; i < test->settings->bitrate_limit_stats_per_interval; i++) {\n        total_bytes += test->bitrate_limit_intervals_traffic_bytes[i];\n    }\n\n    seconds = test->stats_interval * test->settings->bitrate_limit_stats_per_interval;\n    bits_per_second = total_bytes * 8 / seconds;\n    if (test->debug) {\n        iperf_printf(test,\"Interval %\" PRIu64 \" - throughput %\" PRIu64 \" bps (limit %\" PRIu64 \")\\n\", test->bitrate_limit_stats_count, bits_per_second, test->settings->bitrate_limit);\n    }\n\n    if (bits_per_second  > test->settings->bitrate_limit) {\n        if (iperf_get_verbose(test))\n            iperf_err(test, \"Total throughput of %\" PRIu64 \" bps exceeded %\" PRIu64 \" bps limit\", bits_per_second, test->settings->bitrate_limit);\n\ttest->bitrate_limit_exceeded = 1;\n    }\n}\n\nint\niperf_send(struct iperf_test *test, fd_set *write_setP)\n{\n    register int multisend, r, streams_active;\n    register struct iperf_stream *sp;\n    struct iperf_time now;\n    int no_throttle_check;\n\n    /* Can we do multisend mode? */\n    if (test->settings->burst != 0)\n        multisend = test->settings->burst;\n    else if (test->settings->rate == 0)\n        multisend = test->multisend;\n    else\n        multisend = 1;\t/* nope */\n\n    /* Should bitrate throttle be checked for every send */\n    no_throttle_check = test->settings->rate != 0 && test->settings->burst == 0;\n\n    for (; multisend > 0; --multisend) {\n\tif (no_throttle_check)\n\t    iperf_time_now(&now);\n\tstreams_active = 0;\n\tSLIST_FOREACH(sp, &test->streams, streams) {\n\t    if ((sp->green_light && sp->sender &&\n\t\t (write_setP == NULL || FD_ISSET(sp->socket, write_setP)))) {\n        if (multisend > 1 && test->settings->bytes != 0 && test->bytes_sent >= test->settings->bytes)\n            break;\n        if (multisend > 1 && test->settings->blocks != 0 && test->blocks_sent >= test->settings->blocks)\n            break;\n\t\tif ((r = sp->snd(sp)) < 0) {\n\t\t    if (r == NET_SOFTERROR)\n\t\t\tbreak;\n\t\t    i_errno = IESTREAMWRITE;\n\t\t    return r;\n\t\t}\n\t\tstreams_active = 1;\n\t\ttest->bytes_sent += r;\n\t\tif (!sp->pending_size)\n\t\t    ++test->blocks_sent;\n                if (no_throttle_check)\n\t\t    iperf_check_throttle(sp, &now);\n\t    }\n\t}\n\tif (!streams_active)\n\t    break;\n    }\n    if (!no_throttle_check) {   /* Throttle check if was not checked for each send */\n\tiperf_time_now(&now);\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (sp->sender)\n\t        iperf_check_throttle(sp, &now);\n    }\n    if (write_setP != NULL)\n\tSLIST_FOREACH(sp, &test->streams, streams)\n\t    if (FD_ISSET(sp->socket, write_setP))\n\t\tFD_CLR(sp->socket, write_setP);\n\n    return 0;\n}\n\nint\niperf_recv(struct iperf_test *test, fd_set *read_setP)\n{\n    int r;\n    struct iperf_stream *sp;\n\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tif (FD_ISSET(sp->socket, read_setP) && !sp->sender) {\n\t    if ((r = sp->rcv(sp)) < 0) {\n\t\ti_errno = IESTREAMREAD;\n\t\treturn r;\n\t    }\n\t    test->bytes_received += r;\n\t    ++test->blocks_received;\n\t    FD_CLR(sp->socket, read_setP);\n\t}\n    }\n\n    return 0;\n}\n\nint\niperf_init_test(struct iperf_test *test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n\n    if (test->protocol->init) {\n        if (test->protocol->init(test) < 0)\n            return -1;\n    }\n\n    /* Init each stream. */\n    if (iperf_time_now(&now) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->result->start_time = sp->result->start_time_fixed = now;\n    }\n\n    if (test->on_test_start)\n        test->on_test_start(test);\n\n    return 0;\n}\n\nstatic void\nsend_timer_proc(TimerClientData client_data, struct iperf_time *nowP)\n{\n    struct iperf_stream *sp = client_data.p;\n\n    /* All we do here is set or clear the flag saying that this stream may\n    ** be sent to.  The actual sending gets done in the send proc, after\n    ** checking the flag.\n    */\n    iperf_check_throttle(sp, nowP);\n}\n\nint\niperf_create_send_timers(struct iperf_test * test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n    TimerClientData cd;\n\n    if (iperf_time_now(&now) < 0) {\n\ti_errno = IEINITTEST;\n\treturn -1;\n    }\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        sp->green_light = 1;\n\tif (test->settings->rate != 0 && sp->sender) {\n\t    cd.p = sp;\n\t    sp->send_timer = tmr_create(NULL, send_timer_proc, cd, test->settings->pacing_timer, 1);\n\t    if (sp->send_timer == NULL) {\n\t\ti_errno = IEINITTEST;\n\t\treturn -1;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n#if defined(HAVE_SSL)\nint test_is_authorized(struct iperf_test *test){\n    if ( !(test->server_rsa_private_key && test->server_authorized_users)) {\n        return 0;\n    }\n\n    if (test->settings->authtoken){\n        char *username = NULL, *password = NULL;\n        time_t ts;\n        int rc = decode_auth_setting(test->debug, test->settings->authtoken, test->server_rsa_private_key, &username, &password, &ts);\n\tif (rc) {\n\t    return -1;\n\t}\n        int ret = check_authentication(username, password, ts, test->server_authorized_users, test->server_skew_threshold);\n        if (ret == 0){\n            if (test->debug) {\n              iperf_printf(test, report_authentication_succeeded, username, ts);\n            }\n            free(username);\n            free(password);\n            return 0;\n        } else {\n            if (test->debug) {\n                iperf_printf(test, report_authentication_failed, ret, username, ts);\n            }\n            free(username);\n            free(password);\n            return -1;\n        }\n    }\n    return -1;\n}\n#endif //HAVE_SSL\n\n/**\n * iperf_exchange_parameters - handles the param_Exchange part for client\n *\n */\n\nint\niperf_exchange_parameters(struct iperf_test *test)\n{\n    int s;\n    int32_t err;\n\n    if (test->role == 'c') {\n\n        if (send_parameters(test) < 0)\n            return -1;\n\n    } else {\n\n        if (get_parameters(test) < 0)\n            return -1;\n\n#if defined(HAVE_SSL)\n        if (test_is_authorized(test) < 0){\n            if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            i_errno = IEAUTHTEST;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n#endif //HAVE_SSL\n\n        if ((s = test->protocol->listen(test)) < 0) {\n\t        if (iperf_set_send_state(test, SERVER_ERROR) != 0)\n                return -1;\n            err = htonl(i_errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            err = htonl(errno);\n            if (Nwrite(test->ctrl_sck, (char*) &err, sizeof(err), Ptcp) < 0) {\n                i_errno = IECTRLWRITE;\n                return -1;\n            }\n            return -1;\n        }\n\n        FD_SET(s, &test->read_set);\n        test->max_fd = (s > test->max_fd) ? s : test->max_fd;\n        test->prot_listener = s;\n\n        // Send the control message to create streams and start the test\n\tif (iperf_set_send_state(test, CREATE_STREAMS) != 0)\n            return -1;\n\n    }\n\n    return 0;\n}\n\n/*************************************************************/\n\nint\niperf_exchange_results(struct iperf_test *test)\n{\n    if (test->role == 'c') {\n        /* Send results to server. */\n\tif (send_results(test) < 0)\n            return -1;\n        /* Get server results. */\n        if (get_results(test) < 0)\n            return -1;\n    } else {\n        /* Get client results. */\n        if (get_results(test) < 0)\n            return -1;\n        /* Send results to client. */\n\tif (send_results(test) < 0)\n            return -1;\n    }\n    return 0;\n}\n\n/*************************************************************/\n\nstatic int\nsend_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IESENDPARAMS;\n\tr = -1;\n    } else {\n\tif (test->protocol->id == Ptcp)\n\t    cJSON_AddTrueToObject(j, \"tcp\");\n\telse if (test->protocol->id == Pudp)\n\t    cJSON_AddTrueToObject(j, \"udp\");\n        else if (test->protocol->id == Psctp)\n            cJSON_AddTrueToObject(j, \"sctp\");\n\tcJSON_AddNumberToObject(j, \"omit\", test->omit);\n\tif (test->server_affinity != -1)\n\t    cJSON_AddNumberToObject(j, \"server_affinity\", test->server_affinity);\n\tcJSON_AddNumberToObject(j, \"time\", test->duration);\n        cJSON_AddNumberToObject(j, \"num\", test->settings->bytes);\n        cJSON_AddNumberToObject(j, \"blockcount\", test->settings->blocks);\n\tif (test->settings->mss)\n\t    cJSON_AddNumberToObject(j, \"MSS\", test->settings->mss);\n\tif (test->no_delay)\n\t    cJSON_AddTrueToObject(j, \"nodelay\");\n\tcJSON_AddNumberToObject(j, \"parallel\", test->num_streams);\n\tif (test->reverse)\n\t    cJSON_AddTrueToObject(j, \"reverse\");\n\tif (test->bidirectional)\n\t            cJSON_AddTrueToObject(j, \"bidirectional\");\n\tif (test->settings->socket_bufsize)\n\t    cJSON_AddNumberToObject(j, \"window\", test->settings->socket_bufsize);\n\tif (test->settings->blksize)\n\t    cJSON_AddNumberToObject(j, \"len\", test->settings->blksize);\n\tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(j, \"bandwidth\", test->settings->rate);\n\tif (test->settings->fqrate)\n\t    cJSON_AddNumberToObject(j, \"fqrate\", test->settings->fqrate);\n\tif (test->settings->pacing_timer)\n\t    cJSON_AddNumberToObject(j, \"pacing_timer\", test->settings->pacing_timer);\n\tif (test->settings->burst)\n\t    cJSON_AddNumberToObject(j, \"burst\", test->settings->burst);\n\tif (test->settings->tos)\n\t    cJSON_AddNumberToObject(j, \"TOS\", test->settings->tos);\n\tif (test->settings->flowlabel)\n\t    cJSON_AddNumberToObject(j, \"flowlabel\", test->settings->flowlabel);\n\tif (test->title)\n\t    cJSON_AddStringToObject(j, \"title\", test->title);\n\tif (test->extra_data)\n\t    cJSON_AddStringToObject(j, \"extra_data\", test->extra_data);\n\tif (test->congestion)\n\t    cJSON_AddStringToObject(j, \"congestion\", test->congestion);\n\tif (test->congestion_used)\n\t    cJSON_AddStringToObject(j, \"congestion_used\", test->congestion_used);\n\tif (test->get_server_output)\n\t    cJSON_AddNumberToObject(j, \"get_server_output\", iperf_get_test_get_server_output(test));\n\tif (test->udp_counters_64bit)\n\t    cJSON_AddNumberToObject(j, \"udp_counters_64bit\", iperf_get_test_udp_counters_64bit(test));\n\tif (test->repeating_payload)\n\t    cJSON_AddNumberToObject(j, \"repeating_payload\", test->repeating_payload);\n\tif (test->zerocopy)\n\t    cJSON_AddNumberToObject(j, \"zerocopy\", test->zerocopy);\n#if defined(HAVE_DONT_FRAGMENT)\n\tif (test->settings->dont_fragment)\n\t    cJSON_AddNumberToObject(j, \"dont_fragment\", test->settings->dont_fragment);\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n\t/* Send authentication parameters */\n\tif (test->settings->client_username && test->settings->client_password && test->settings->client_rsa_pubkey){\n\t    int rc = encode_auth_setting(test->settings->client_username, test->settings->client_password, test->settings->client_rsa_pubkey, &test->settings->authtoken);\n\n\t    if (rc) {\n\t\tcJSON_Delete(j);\n\t\ti_errno = IESENDPARAMS;\n\t\treturn -1;\n\t    }\n\n\t    cJSON_AddStringToObject(j, \"authtoken\", test->settings->authtoken);\n\t}\n#endif // HAVE_SSL\n\tcJSON_AddStringToObject(j, \"client_version\", IPERF_VERSION);\n\n\tif (test->debug) {\n\t    char *str = cJSON_Print(j);\n\t    printf(\"send_parameters:\\n%s\\n\", str);\n\t    cJSON_free(str);\n\t}\n\n\tif (JSON_write(test->ctrl_sck, j) < 0) {\n\t    i_errno = IESENDPARAMS;\n\t    r = -1;\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_parameters(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_p;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVPARAMS;\n        r = -1;\n    } else {\n\tif (test->debug) {\n            char *str;\n            str = cJSON_Print(j);\n            printf(\"get_parameters:\\n%s\\n\", str );\n            cJSON_free(str);\n\t}\n\n\tif ((j_p = cJSON_GetObjectItem(j, \"tcp\")) != NULL)\n\t    set_protocol(test, Ptcp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp\")) != NULL)\n\t    set_protocol(test, Pudp);\n        if ((j_p = cJSON_GetObjectItem(j, \"sctp\")) != NULL)\n            set_protocol(test, Psctp);\n\tif ((j_p = cJSON_GetObjectItem(j, \"omit\")) != NULL)\n\t    test->omit = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"server_affinity\")) != NULL)\n\t    test->server_affinity = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"time\")) != NULL)\n\t    test->duration = j_p->valueint;\n        test->settings->bytes = 0;\n\tif ((j_p = cJSON_GetObjectItem(j, \"num\")) != NULL)\n\t    test->settings->bytes = j_p->valueint;\n        test->settings->blocks = 0;\n\tif ((j_p = cJSON_GetObjectItem(j, \"blockcount\")) != NULL)\n\t    test->settings->blocks = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"MSS\")) != NULL)\n\t    test->settings->mss = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"nodelay\")) != NULL)\n\t    test->no_delay = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"parallel\")) != NULL)\n\t    test->num_streams = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"reverse\")) != NULL)\n\t    iperf_set_test_reverse(test, 1);\n        if ((j_p = cJSON_GetObjectItem(j, \"bidirectional\")) != NULL)\n            iperf_set_test_bidirectional(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"window\")) != NULL)\n\t    test->settings->socket_bufsize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"len\")) != NULL)\n\t    test->settings->blksize = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"bandwidth\")) != NULL)\n\t    test->settings->rate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"fqrate\")) != NULL)\n\t    test->settings->fqrate = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"pacing_timer\")) != NULL)\n\t    test->settings->pacing_timer = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"burst\")) != NULL)\n\t    test->settings->burst = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"TOS\")) != NULL)\n\t    test->settings->tos = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"flowlabel\")) != NULL)\n\t    test->settings->flowlabel = j_p->valueint;\n\tif ((j_p = cJSON_GetObjectItem(j, \"title\")) != NULL)\n\t    test->title = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"extra_data\")) != NULL)\n\t    test->extra_data = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion\")) != NULL)\n\t    test->congestion = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"congestion_used\")) != NULL)\n\t    test->congestion_used = strdup(j_p->valuestring);\n\tif ((j_p = cJSON_GetObjectItem(j, \"get_server_output\")) != NULL)\n\t    iperf_set_test_get_server_output(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"udp_counters_64bit\")) != NULL)\n\t    iperf_set_test_udp_counters_64bit(test, 1);\n\tif ((j_p = cJSON_GetObjectItem(j, \"repeating_payload\")) != NULL)\n\t    test->repeating_payload = 1;\n\tif ((j_p = cJSON_GetObjectItem(j, \"zerocopy\")) != NULL)\n\t    test->zerocopy = j_p->valueint;\n#if defined(HAVE_DONT_FRAGMENT)\n\tif ((j_p = cJSON_GetObjectItem(j, \"dont_fragment\")) != NULL)\n\t    test->settings->dont_fragment = j_p->valueint;\n#endif /* HAVE_DONT_FRAGMENT */\n#if defined(HAVE_SSL)\n\tif ((j_p = cJSON_GetObjectItem(j, \"authtoken\")) != NULL)\n        test->settings->authtoken = strdup(j_p->valuestring);\n#endif //HAVE_SSL\n\tif (test->mode && test->protocol->id == Ptcp && has_tcpinfo_retransmits())\n\t    test->sender_has_retransmits = 1;\n\tif (test->settings->rate)\n\t    cJSON_AddNumberToObject(test->json_start, \"target_bitrate\", test->settings->rate);\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nsend_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_streams;\n    struct iperf_stream *sp;\n    cJSON *j_stream;\n    int sender_has_retransmits;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_time temp_time;\n    double start_time, end_time;\n\n    j = cJSON_CreateObject();\n    if (j == NULL) {\n\ti_errno = IEPACKAGERESULTS;\n\tr = -1;\n    } else {\n\tcJSON_AddNumberToObject(j, \"cpu_util_total\", test->cpu_util[0]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_user\", test->cpu_util[1]);\n\tcJSON_AddNumberToObject(j, \"cpu_util_system\", test->cpu_util[2]);\n\tif ( test->mode == RECEIVER )\n\t    sender_has_retransmits = -1;\n\telse\n\t    sender_has_retransmits = test->sender_has_retransmits;\n\tcJSON_AddNumberToObject(j, \"sender_has_retransmits\", sender_has_retransmits);\n\tif ( test->congestion_used ) {\n\t    cJSON_AddStringToObject(j, \"congestion_used\", test->congestion_used);\n\t}\n\n\t/* If on the server and sending server output, then do this */\n\tif (test->role == 's' && test->get_server_output) {\n\t    if (test->json_output) {\n\t\t/* Add JSON output */\n\t\tcJSON_AddItemReferenceToObject(j, \"server_output_json\", test->json_top);\n\t    }\n\t    else {\n\t\t/* Add textual output */\n\t\tsize_t buflen = 0;\n\n\t\t/* Figure out how much room we need to hold the complete output string */\n\t\tstruct iperf_textline *t;\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    buflen += strlen(t->line);\n\t\t}\n\n\t\t/* Allocate and build it up from the component lines */\n\t\tchar *output = calloc(buflen + 1, 1);\n\t\tTAILQ_FOREACH(t, &(test->server_output_list), textlineentries) {\n\t\t    strncat(output, t->line, buflen);\n\t\t    buflen -= strlen(t->line);\n\t\t}\n\n\t\tcJSON_AddStringToObject(j, \"server_output_text\", output);\n        free(output);\n\t    }\n\t}\n\n\tj_streams = cJSON_CreateArray();\n\tif (j_streams == NULL) {\n\t    i_errno = IEPACKAGERESULTS;\n\t    r = -1;\n\t} else {\n\t    cJSON_AddItemToObject(j, \"streams\", j_streams);\n\t    SLIST_FOREACH(sp, &test->streams, streams) {\n\t\tj_stream = cJSON_CreateObject();\n\t\tif (j_stream == NULL) {\n\t\t    i_errno = IEPACKAGERESULTS;\n\t\t    r = -1;\n\t\t} else {\n\t\t    cJSON_AddItemToArray(j_streams, j_stream);\n\t\t    bytes_transferred = sp->sender ? (sp->result->bytes_sent - sp->result->bytes_sent_omit) : sp->result->bytes_received;\n\t\t    retransmits = (sp->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n\t\t    cJSON_AddNumberToObject(j_stream, \"id\", sp->id);\n\t\t    cJSON_AddNumberToObject(j_stream, \"bytes\", bytes_transferred);\n\t\t    cJSON_AddNumberToObject(j_stream, \"retransmits\", retransmits);\n\t\t    cJSON_AddNumberToObject(j_stream, \"jitter\", sp->jitter);\n\t\t    cJSON_AddNumberToObject(j_stream, \"errors\", sp->cnt_error);\n                    cJSON_AddNumberToObject(j_stream, \"omitted_errors\", sp->omitted_cnt_error);\n\t\t    cJSON_AddNumberToObject(j_stream, \"packets\", sp->packet_count);\n                    cJSON_AddNumberToObject(j_stream, \"omitted_packets\", sp->omitted_packet_count);\n\n\t\t    iperf_time_diff(&sp->result->start_time, &sp->result->start_time, &temp_time);\n\t\t    start_time = iperf_time_in_secs(&temp_time);\n\t\t    iperf_time_diff(&sp->result->start_time, &sp->result->end_time, &temp_time);\n\t\t    end_time = iperf_time_in_secs(&temp_time);\n\t\t    cJSON_AddNumberToObject(j_stream, \"start_time\", start_time);\n\t\t    cJSON_AddNumberToObject(j_stream, \"end_time\", end_time);\n\n\t\t}\n\t    }\n\t    if (r == 0 && test->debug) {\n                char *str = cJSON_Print(j);\n\t\tprintf(\"send_results\\n%s\\n\", str);\n                cJSON_free(str);\n\t    }\n\t    if (r == 0 && JSON_write(test->ctrl_sck, j) < 0) {\n\t\ti_errno = IESENDRESULTS;\n\t\tr = -1;\n\t    }\n\t}\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nget_results(struct iperf_test *test)\n{\n    int r = 0;\n    cJSON *j;\n    cJSON *j_cpu_util_total;\n    cJSON *j_cpu_util_user;\n    cJSON *j_cpu_util_system;\n    cJSON *j_remote_congestion_used;\n    cJSON *j_sender_has_retransmits;\n    int result_has_retransmits;\n    cJSON *j_streams;\n    int n, i;\n    cJSON *j_stream;\n    cJSON *j_id;\n    cJSON *j_bytes;\n    cJSON *j_retransmits;\n    cJSON *j_jitter;\n    cJSON *j_errors;\n    cJSON *j_omitted_errors;\n    cJSON *j_packets;\n    cJSON *j_omitted_packets;\n    cJSON *j_server_output;\n    cJSON *j_start_time, *j_end_time;\n    int sid;\n    int64_t cerror, pcount, omitted_cerror, omitted_pcount;\n    double jitter;\n    iperf_size_t bytes_transferred;\n    int retransmits;\n    struct iperf_stream *sp;\n\n    j = JSON_read(test->ctrl_sck);\n    if (j == NULL) {\n\ti_errno = IERECVRESULTS;\n        r = -1;\n    } else {\n\tj_cpu_util_total = cJSON_GetObjectItem(j, \"cpu_util_total\");\n\tj_cpu_util_user = cJSON_GetObjectItem(j, \"cpu_util_user\");\n\tj_cpu_util_system = cJSON_GetObjectItem(j, \"cpu_util_system\");\n\tj_sender_has_retransmits = cJSON_GetObjectItem(j, \"sender_has_retransmits\");\n\tif (j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL) {\n\t    i_errno = IERECVRESULTS;\n\t    r = -1;\n\t} else {\n\t    if (test->debug) {\n                char *str = cJSON_Print(j);\n                printf(\"get_results\\n%s\\n\", str);\n                cJSON_free(str);\n\t    }\n\n\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n\t    result_has_retransmits = j_sender_has_retransmits->valueint;\n\t    if ( test->mode == RECEIVER ) {\n\t        test->sender_has_retransmits = result_has_retransmits;\n\t        test->other_side_has_retransmits = 0;\n\t    }\n\t    else if ( test->mode == BIDIRECTIONAL )\n\t        test->other_side_has_retransmits = result_has_retransmits;\n\n\t    j_streams = cJSON_GetObjectItem(j, \"streams\");\n\t    if (j_streams == NULL) {\n\t\ti_errno = IERECVRESULTS;\n\t\tr = -1;\n\t    } else {\n\t        n = cJSON_GetArraySize(j_streams);\n\t\tfor (i=0; i<n; ++i) {\n\t\t    j_stream = cJSON_GetArrayItem(j_streams, i);\n\t\t    if (j_stream == NULL) {\n\t\t\ti_errno = IERECVRESULTS;\n\t\t\tr = -1;\n\t\t    } else {\n\t\t\tj_id = cJSON_GetObjectItem(j_stream, \"id\");\n\t\t\tj_bytes = cJSON_GetObjectItem(j_stream, \"bytes\");\n\t\t\tj_retransmits = cJSON_GetObjectItem(j_stream, \"retransmits\");\n\t\t\tj_jitter = cJSON_GetObjectItem(j_stream, \"jitter\");\n\t\t\tj_errors = cJSON_GetObjectItem(j_stream, \"errors\");\n                        j_omitted_errors = cJSON_GetObjectItem(j_stream, \"omitted_errors\");\n\t\t\tj_packets = cJSON_GetObjectItem(j_stream, \"packets\");\n                        j_omitted_packets = cJSON_GetObjectItem(j_stream, \"omitted_packets\");\n\t\t\tj_start_time = cJSON_GetObjectItem(j_stream, \"start_time\");\n\t\t\tj_end_time = cJSON_GetObjectItem(j_stream, \"end_time\");\n\t\t\tif (j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL) {\n\t\t\t    i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n                        } else if ( (j_omitted_errors == NULL && j_omitted_packets != NULL) || (j_omitted_errors != NULL && j_omitted_packets == NULL) ) {\n                            /* For backward compatibility allow to not receive \"omitted\" statistcs */\n                            i_errno = IERECVRESULTS;\n\t\t\t    r = -1;\n\t\t\t} else {\n\t\t\t    sid = j_id->valueint;\n\t\t\t    bytes_transferred = j_bytes->valueint;\n\t\t\t    retransmits = j_retransmits->valueint;\n\t\t\t    jitter = j_jitter->valuedouble;\n\t\t\t    cerror = j_errors->valueint;\n\t\t\t    pcount = j_packets->valueint;\n                            if (j_omitted_packets != NULL) {\n                                omitted_cerror = j_omitted_errors->valueint;\n                                omitted_pcount = j_omitted_packets->valueint;\n                            }\n\t\t\t    SLIST_FOREACH(sp, &test->streams, streams)\n\t\t\t\tif (sp->id == sid) break;\n\t\t\t    if (sp == NULL) {\n\t\t\t\ti_errno = IESTREAMID;\n\t\t\t\tr = -1;\n\t\t\t    } else {\n\t\t\t\tif (sp->sender) {\n\t\t\t\t    sp->jitter = jitter;\n\t\t\t\t    sp->cnt_error = cerror;\n\t\t\t\t    sp->peer_packet_count = pcount;\n\t\t\t\t    sp->result->bytes_received = bytes_transferred;\n                                    if (j_omitted_packets != NULL) {\n                                        sp->omitted_cnt_error = omitted_cerror;\n                                        sp->peer_omitted_packet_count = omitted_pcount;\n                                    } else {\n                                        sp->peer_omitted_packet_count = sp->omitted_packet_count;\n                                        if (sp->peer_omitted_packet_count > 0) {\n                                            /* -1 indicates unknown error count since it includes the omitted count */\n                                            sp->omitted_cnt_error = (sp->cnt_error > 0) ? -1 : 0;\n                                        } else {\n                                            sp->omitted_cnt_error = sp->cnt_error;\n                                        }\n                                    }\n\t\t\t\t    /*\n\t\t\t\t     * We have to handle the possibility that\n\t\t\t\t     * start_time and end_time might not be\n\t\t\t\t     * available; this is the case for older (pre-3.2)\n\t\t\t\t     * servers.\n\t\t\t\t     *\n\t\t\t\t     * We need to have result structure members to hold\n\t\t\t\t     * the both sides' start_time and end_time.\n\t\t\t\t     */\n\t\t\t\t    if (j_start_time && j_end_time) {\n\t\t\t\t\tsp->result->receiver_time = j_end_time->valuedouble - j_start_time->valuedouble;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\tsp->result->receiver_time = 0.0;\n\t\t\t\t    }\n\t\t\t\t} else {\n\t\t\t\t    sp->peer_packet_count = pcount;\n\t\t\t\t    sp->result->bytes_sent = bytes_transferred;\n\t\t\t\t    sp->result->stream_retrans = retransmits;\n                                    if (j_omitted_packets != NULL) {\n                                        sp->peer_omitted_packet_count = omitted_pcount;\n                                    } else {\n                                        sp->peer_omitted_packet_count = sp->peer_packet_count;\n                                    }\n\t\t\t\t    if (j_start_time && j_end_time) {\n\t\t\t\t\tsp->result->sender_time = j_end_time->valuedouble - j_start_time->valuedouble;\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\tsp->result->sender_time = 0.0;\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t/*\n\t\t * If we're the client and we're supposed to get remote results,\n\t\t * look them up and process accordingly.\n\t\t */\n\t\tif (test->role == 'c' && iperf_get_test_get_server_output(test)) {\n\t\t    /* Look for JSON.  If we find it, grab the object so it doesn't get deleted. */\n\t\t    j_server_output = cJSON_DetachItemFromObject(j, \"server_output_json\");\n\t\t    if (j_server_output != NULL) {\n\t\t\ttest->json_server_output = j_server_output;\n\t\t    }\n\t\t    else {\n\t\t\t/* No JSON, look for textual output.  Make a copy of the text for later. */\n\t\t\tj_server_output = cJSON_GetObjectItem(j, \"server_output_text\");\n\t\t\tif (j_server_output != NULL) {\n\t\t\t    test->server_output_text = strdup(j_server_output->valuestring);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tj_remote_congestion_used = cJSON_GetObjectItem(j, \"congestion_used\");\n\tif (j_remote_congestion_used != NULL) {\n\t    test->remote_congestion_used = strdup(j_remote_congestion_used->valuestring);\n\t}\n\n\tcJSON_Delete(j);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic int\nJSON_write(int fd, cJSON *json)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    int r = 0;\n\n    str = cJSON_PrintUnformatted(json);\n    if (str == NULL)\n\tr = -1;\n    else {\n\thsize = strlen(str);\n\tnsize = htonl(hsize);\n\tif (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)\n\t    r = -1;\n\telse {\n\t    if (Nwrite(fd, str, hsize, Ptcp) < 0)\n\t\tr = -1;\n\t}\n\tcJSON_free(str);\n    }\n    return r;\n}\n\n/*************************************************************/\n\nstatic cJSON *\nJSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    size_t strsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n\n    /*\n     * Read a four-byte integer, which is the length of the JSON to follow.\n     * Then read the JSON into a buffer and parse it.  Return a parsed JSON\n     * structure, NULL if there was an error.\n     */\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\t/* Allocate a buffer to hold the JSON */\n\tstrsize = hsize + 1;              /* +1 for trailing NULL */\n\tif (strsize) {\n\tstr = (char *) calloc(sizeof(char), strsize);\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\t/*\n\t\t * We should be reading in the number of bytes corresponding to the\n\t\t * length in that 4-byte integer.  If we don't the socket might have\n\t\t * prematurely closed.  Only do the JSON parsing if we got the\n\t\t * correct number of bytes.\n\t\t */\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n\t}\n\telse {\n\t    printf(\"WARNING:  Data length overflow\\n\");\n\t}\n    }\n    return json;\n}\n\n/*************************************************************/\n/**\n * add_to_interval_list -- adds new interval to the interval_list\n */\n\nvoid\nadd_to_interval_list(struct iperf_stream_result * rp, struct iperf_interval_results * new)\n{\n    struct iperf_interval_results *irp;\n\n    irp = (struct iperf_interval_results *) malloc(sizeof(struct iperf_interval_results));\n    memcpy(irp, new, sizeof(struct iperf_interval_results));\n    TAILQ_INSERT_TAIL(&rp->interval_results, irp, irlistentries);\n}\n\n\n/************************************************************/\n\n/**\n * connect_msg -- displays connection message\n * denoting sender/receiver details\n *\n */\n\nvoid\nconnect_msg(struct iperf_stream *sp)\n{\n    char ipl[INET6_ADDRSTRLEN], ipr[INET6_ADDRSTRLEN];\n    int lport, rport;\n\n    if (getsockdomain(sp->socket) == AF_INET) {\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->local_addr)->sin_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET, (void *) &((struct sockaddr_in *) &sp->remote_addr)->sin_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in *) &sp->local_addr)->sin_port);\n        rport = ntohs(((struct sockaddr_in *) &sp->remote_addr)->sin_port);\n    } else {\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->local_addr)->sin6_addr, ipl, sizeof(ipl));\n\tmapped_v4_to_regular_v4(ipl);\n        inet_ntop(AF_INET6, (void *) &((struct sockaddr_in6 *) &sp->remote_addr)->sin6_addr, ipr, sizeof(ipr));\n\tmapped_v4_to_regular_v4(ipr);\n        lport = ntohs(((struct sockaddr_in6 *) &sp->local_addr)->sin6_port);\n        rport = ntohs(((struct sockaddr_in6 *) &sp->remote_addr)->sin6_port);\n    }\n\n    if (sp->test->json_output)\n        cJSON_AddItemToArray(sp->test->json_connected, iperf_json_printf(\"socket: %d  local_host: %s  local_port: %d  remote_host: %s  remote_port: %d\", (int64_t) sp->socket, ipl, (int64_t) lport, ipr, (int64_t) rport));\n    else\n\tiperf_printf(sp->test, report_connected, sp->socket, ipl, lport, ipr, rport);\n}\n\n\n/**************************************************************************/\n\nstruct iperf_test *\niperf_new_test()\n{\n    struct iperf_test *test;\n\n    test = (struct iperf_test *) malloc(sizeof(struct iperf_test));\n    if (!test) {\n        i_errno = IENEWTEST;\n        return NULL;\n    }\n    /* initialize everything to zero */\n    memset(test, 0, sizeof(struct iperf_test));\n\n    test->settings = (struct iperf_settings *) malloc(sizeof(struct iperf_settings));\n    if (!test->settings) {\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->settings, 0, sizeof(struct iperf_settings));\n\n    test->bitrate_limit_intervals_traffic_bytes = (iperf_size_t *) malloc(sizeof(iperf_size_t) * MAX_INTERVAL);\n    if (!test->bitrate_limit_intervals_traffic_bytes) {\n        free(test->settings);\n        free(test);\n\ti_errno = IENEWTEST;\n\treturn NULL;\n    }\n    memset(test->bitrate_limit_intervals_traffic_bytes, 0, sizeof(sizeof(iperf_size_t) * MAX_INTERVAL));\n\n    /* By default all output goes to stdout */\n    test->outfile = stdout;\n\n    return test;\n}\n\n/**************************************************************************/\n\nstruct protocol *\nprotocol_new(void)\n{\n    struct protocol *proto;\n\n    proto = malloc(sizeof(struct protocol));\n    if(!proto) {\n        return NULL;\n    }\n    memset(proto, 0, sizeof(struct protocol));\n\n    return proto;\n}\n\nvoid\nprotocol_free(struct protocol *proto)\n{\n    free(proto);\n}\n\n/**************************************************************************/\nint\niperf_defaults(struct iperf_test *testp)\n{\n    struct protocol *tcp, *udp;\n#if defined(HAVE_SCTP_H)\n    struct protocol *sctp;\n#endif /* HAVE_SCTP_H */\n\n    testp->omit = OMIT;\n    testp->duration = DURATION;\n    testp->diskfile_name = (char*) 0;\n    testp->affinity = -1;\n    testp->server_affinity = -1;\n    TAILQ_INIT(&testp->xbind_addrs);\n#if defined(HAVE_CPUSET_SETAFFINITY)\n    CPU_ZERO(&testp->cpumask);\n#endif /* HAVE_CPUSET_SETAFFINITY */\n    testp->title = NULL;\n    testp->extra_data = NULL;\n    testp->congestion = NULL;\n    testp->congestion_used = NULL;\n    testp->remote_congestion_used = NULL;\n    testp->server_port = PORT;\n    testp->ctrl_sck = -1;\n    testp->listener = -1;\n    testp->prot_listener = -1;\n    testp->other_side_has_retransmits = 0;\n\n    testp->stats_callback = iperf_stats_callback;\n    testp->reporter_callback = iperf_reporter_callback;\n\n    testp->stats_interval = testp->reporter_interval = 1;\n    testp->num_streams = 1;\n\n    testp->settings->domain = AF_UNSPEC;\n    testp->settings->unit_format = 'a';\n    testp->settings->socket_bufsize = 0;    /* use autotuning */\n    testp->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    testp->settings->rate = 0;\n    testp->settings->bitrate_limit = 0;\n    testp->settings->bitrate_limit_interval = 5;\n    testp->settings->bitrate_limit_stats_per_interval = 0;\n    testp->settings->fqrate = 0;\n    testp->settings->pacing_timer = DEFAULT_PACING_TIMER;\n    testp->settings->burst = 0;\n    testp->settings->mss = 0;\n    testp->settings->bytes = 0;\n    testp->settings->blocks = 0;\n    testp->settings->connect_timeout = -1;\n    testp->settings->rcv_timeout.secs = DEFAULT_NO_MSG_RCVD_TIMEOUT / SEC_TO_mS;\n    testp->settings->rcv_timeout.usecs = (DEFAULT_NO_MSG_RCVD_TIMEOUT % SEC_TO_mS) * mS_TO_US;\n    testp->zerocopy = 0;\n\n    memset(testp->cookie, 0, COOKIE_SIZE);\n\n    testp->multisend = 10;\t/* arbitrary */\n\n    /* Set up protocol list */\n    SLIST_INIT(&testp->streams);\n    SLIST_INIT(&testp->protocols);\n\n    tcp = protocol_new();\n    if (!tcp)\n        return -1;\n\n    tcp->id = Ptcp;\n    tcp->name = \"TCP\";\n    tcp->accept = iperf_tcp_accept;\n    tcp->listen = iperf_tcp_listen;\n    tcp->connect = iperf_tcp_connect;\n    tcp->send = iperf_tcp_send;\n    tcp->recv = iperf_tcp_recv;\n    tcp->init = NULL;\n    SLIST_INSERT_HEAD(&testp->protocols, tcp, protocols);\n\n    udp = protocol_new();\n    if (!udp) {\n        protocol_free(tcp);\n        return -1;\n    }\n\n    udp->id = Pudp;\n    udp->name = \"UDP\";\n    udp->accept = iperf_udp_accept;\n    udp->listen = iperf_udp_listen;\n    udp->connect = iperf_udp_connect;\n    udp->send = iperf_udp_send;\n    udp->recv = iperf_udp_recv;\n    udp->init = iperf_udp_init;\n    SLIST_INSERT_AFTER(tcp, udp, protocols);\n\n    set_protocol(testp, Ptcp);\n\n#if defined(HAVE_SCTP_H)\n    sctp = protocol_new();\n    if (!sctp) {\n        protocol_free(tcp);\n        protocol_free(udp);\n        return -1;\n    }\n\n    sctp->id = Psctp;\n    sctp->name = \"SCTP\";\n    sctp->accept = iperf_sctp_accept;\n    sctp->listen = iperf_sctp_listen;\n    sctp->connect = iperf_sctp_connect;\n    sctp->send = iperf_sctp_send;\n    sctp->recv = iperf_sctp_recv;\n    sctp->init = iperf_sctp_init;\n\n    SLIST_INSERT_AFTER(udp, sctp, protocols);\n#endif /* HAVE_SCTP_H */\n\n    testp->on_new_stream = iperf_on_new_stream;\n    testp->on_test_start = iperf_on_test_start;\n    testp->on_connect = iperf_on_connect;\n    testp->on_test_finish = iperf_on_test_finish;\n\n    TAILQ_INIT(&testp->server_output_list);\n\n    return 0;\n}\n\n\n/**************************************************************************/\nvoid\niperf_free_test(struct iperf_test *test)\n{\n    struct protocol *prot;\n    struct iperf_stream *sp;\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->server_hostname)\n\tfree(test->server_hostname);\n    if (test->tmp_template)\n\tfree(test->tmp_template);\n    if (test->bind_address)\n\tfree(test->bind_address);\n    if (test->bind_dev)\n\tfree(test->bind_dev);\n    if (!TAILQ_EMPTY(&test->xbind_addrs)) {\n        struct xbind_entry *xbe;\n\n        while (!TAILQ_EMPTY(&test->xbind_addrs)) {\n            xbe = TAILQ_FIRST(&test->xbind_addrs);\n            TAILQ_REMOVE(&test->xbind_addrs, xbe, link);\n            if (xbe->ai)\n                freeaddrinfo(xbe->ai);\n            free(xbe->name);\n            free(xbe);\n        }\n    }\n#if defined(HAVE_SSL)\n\n    if (test->server_rsa_private_key)\n      EVP_PKEY_free(test->server_rsa_private_key);\n    test->server_rsa_private_key = NULL;\n\n    free(test->settings->authtoken);\n    test->settings->authtoken = NULL;\n\n    free(test->settings->client_username);\n    test->settings->client_username = NULL;\n\n    free(test->settings->client_password);\n    test->settings->client_password = NULL;\n\n    if (test->settings->client_rsa_pubkey)\n      EVP_PKEY_free(test->settings->client_rsa_pubkey);\n    test->settings->client_rsa_pubkey = NULL;\n#endif /* HAVE_SSL */\n\n    if (test->settings)\n    free(test->settings);\n    if (test->title)\n\tfree(test->title);\n    if (test->extra_data)\n\tfree(test->extra_data);\n    if (test->congestion)\n\tfree(test->congestion);\n    if (test->congestion_used)\n\tfree(test->congestion_used);\n    if (test->remote_congestion_used)\n\tfree(test->remote_congestion_used);\n    if (test->timestamp_format)\n\tfree(test->timestamp_format);\n    if (test->omit_timer != NULL)\n\ttmr_cancel(test->omit_timer);\n    if (test->timer != NULL)\n\ttmr_cancel(test->timer);\n    if (test->stats_timer != NULL)\n\ttmr_cancel(test->stats_timer);\n    if (test->reporter_timer != NULL)\n\ttmr_cancel(test->reporter_timer);\n\n    /* Free protocol list */\n    while (!SLIST_EMPTY(&test->protocols)) {\n        prot = SLIST_FIRST(&test->protocols);\n        SLIST_REMOVE_HEAD(&test->protocols, protocols);\n        free(prot);\n    }\n\n    if (test->logfile) {\n\tfree(test->logfile);\n\ttest->logfile = NULL;\n        iperf_close_logfile(test);\n    }\n\n    if (test->server_output_text) {\n\tfree(test->server_output_text);\n\ttest->server_output_text = NULL;\n    }\n\n    if (test->json_output_string) {\n\tfree(test->json_output_string);\n\ttest->json_output_string = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n\n    /* sctp_bindx: do not free the arguments, only the resolver results */\n    if (!TAILQ_EMPTY(&test->xbind_addrs)) {\n        struct xbind_entry *xbe;\n\n        TAILQ_FOREACH(xbe, &test->xbind_addrs, link) {\n            if (xbe->ai) {\n                freeaddrinfo(xbe->ai);\n                xbe->ai = NULL;\n            }\n        }\n    }\n\n    /* Free interval's traffic array for average rate calculations */\n    if (test->bitrate_limit_intervals_traffic_bytes != NULL)\n        free(test->bitrate_limit_intervals_traffic_bytes);\n\n    /* XXX: Why are we setting these values to NULL? */\n    // test->streams = NULL;\n    test->stats_callback = NULL;\n    test->reporter_callback = NULL;\n    free(test);\n}\n\n\nvoid\niperf_reset_test(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    int i;\n\n    iperf_close_logfile(test);\n\n    /* Free streams */\n    while (!SLIST_EMPTY(&test->streams)) {\n        sp = SLIST_FIRST(&test->streams);\n        SLIST_REMOVE_HEAD(&test->streams, streams);\n        iperf_free_stream(sp);\n    }\n    if (test->omit_timer != NULL) {\n\ttmr_cancel(test->omit_timer);\n\ttest->omit_timer = NULL;\n    }\n    if (test->timer != NULL) {\n\ttmr_cancel(test->timer);\n\ttest->timer = NULL;\n    }\n    if (test->stats_timer != NULL) {\n\ttmr_cancel(test->stats_timer);\n\ttest->stats_timer = NULL;\n    }\n    if (test->reporter_timer != NULL) {\n\ttmr_cancel(test->reporter_timer);\n\ttest->reporter_timer = NULL;\n    }\n    test->done = 0;\n\n    SLIST_INIT(&test->streams);\n\n    if (test->remote_congestion_used)\n        free(test->remote_congestion_used);\n    test->remote_congestion_used = NULL;\n    test->role = 's';\n    test->mode = RECEIVER;\n    test->sender_has_retransmits = 0;\n    set_protocol(test, Ptcp);\n    test->omit = OMIT;\n    test->duration = DURATION;\n    test->server_affinity = -1;\n#if defined(HAVE_CPUSET_SETAFFINITY)\n    CPU_ZERO(&test->cpumask);\n#endif /* HAVE_CPUSET_SETAFFINITY */\n    test->state = 0;\n\n    test->ctrl_sck = -1;\n    test->listener = -1;\n    test->prot_listener = -1;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n\n    test->bytes_received = 0;\n    test->blocks_received = 0;\n\n    test->other_side_has_retransmits = 0;\n\n    test->bitrate_limit_stats_count = 0;\n    test->bitrate_limit_last_interval_index = 0;\n    test->bitrate_limit_exceeded = 0;\n\n    for (i = 0; i < MAX_INTERVAL; i++)\n        test->bitrate_limit_intervals_traffic_bytes[i] = 0;\n\n    test->reverse = 0;\n    test->bidirectional = 0;\n    test->no_delay = 0;\n\n    FD_ZERO(&test->read_set);\n    FD_ZERO(&test->write_set);\n\n    test->num_streams = 1;\n    test->settings->socket_bufsize = 0;\n    test->settings->blksize = DEFAULT_TCP_BLKSIZE;\n    test->settings->rate = 0;\n    test->settings->burst = 0;\n    test->settings->mss = 0;\n    test->settings->tos = 0;\n    test->settings->dont_fragment = 0;\n    test->zerocopy = 0;\n\n#if defined(HAVE_SSL)\n    if (test->settings->authtoken) {\n        free(test->settings->authtoken);\n        test->settings->authtoken = NULL;\n    }\n    if (test->settings->client_username) {\n        free(test->settings->client_username);\n        test->settings->client_username = NULL;\n    }\n    if (test->settings->client_password) {\n        free(test->settings->client_password);\n        test->settings->client_password = NULL;\n    }\n    if (test->settings->client_rsa_pubkey) {\n        EVP_PKEY_free(test->settings->client_rsa_pubkey);\n        test->settings->client_rsa_pubkey = NULL;\n    }\n#endif /* HAVE_SSL */\n\n    memset(test->cookie, 0, COOKIE_SIZE);\n    test->multisend = 10;\t/* arbitrary */\n    test->udp_counters_64bit = 0;\n    if (test->title) {\n\tfree(test->title);\n\ttest->title = NULL;\n    }\n    if (test->extra_data) {\n\tfree(test->extra_data);\n\ttest->extra_data = NULL;\n    }\n\n    /* Free output line buffers, if any (on the server only) */\n    struct iperf_textline *t;\n    while (!TAILQ_EMPTY(&test->server_output_list)) {\n\tt = TAILQ_FIRST(&test->server_output_list);\n\tTAILQ_REMOVE(&test->server_output_list, t, textlineentries);\n\tfree(t->line);\n\tfree(t);\n    }\n}\n\n\n/* Reset all of a test's stats back to zero.  Called when the omitting\n** period is over.\n*/\nvoid\niperf_reset_stats(struct iperf_test *test)\n{\n    struct iperf_time now;\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp;\n\n    test->bytes_sent = 0;\n    test->blocks_sent = 0;\n    iperf_time_now(&now);\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tsp->omitted_packet_count = sp->packet_count;\n        sp->omitted_cnt_error = sp->cnt_error;\n        sp->omitted_outoforder_packets = sp->outoforder_packets;\n\tsp->jitter = 0;\n\trp = sp->result;\n        rp->bytes_sent_omit = rp->bytes_sent;\n        rp->bytes_received = 0;\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n\tif (test->sender_has_retransmits == 1) {\n\t    struct iperf_interval_results ir; /* temporary results structure */\n\t    save_tcpinfo(sp, &ir);\n\t    rp->stream_prev_total_retrans = get_total_retransmits(&ir);\n\t}\n\trp->stream_retrans = 0;\n\trp->start_time = now;\n    }\n}\n\n\n/**************************************************************************/\n\n/**\n * Gather statistics during a test.\n * This function works for both the client and server side.\n */\nvoid\niperf_stats_callback(struct iperf_test *test)\n{\n    struct iperf_stream *sp;\n    struct iperf_stream_result *rp = NULL;\n    struct iperf_interval_results *irp, temp;\n    struct iperf_time temp_time;\n    iperf_size_t total_interval_bytes_transferred = 0;\n\n    temp.omitted = test->omitting;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n        rp = sp->result;\n\ttemp.bytes_transferred = sp->sender ? rp->bytes_sent_this_interval : rp->bytes_received_this_interval;\n\n        // Total bytes transferred this interval\n\ttotal_interval_bytes_transferred += rp->bytes_sent_this_interval + rp->bytes_received_this_interval;\n\n\tirp = TAILQ_LAST(&rp->interval_results, irlisthead);\n        /* result->end_time contains timestamp of previous interval */\n        if ( irp != NULL ) /* not the 1st interval */\n            memcpy(&temp.interval_start_time, &rp->end_time, sizeof(struct iperf_time));\n        else /* or use timestamp from beginning */\n            memcpy(&temp.interval_start_time, &rp->start_time, sizeof(struct iperf_time));\n        /* now save time of end of this interval */\n        iperf_time_now(&rp->end_time);\n        memcpy(&temp.interval_end_time, &rp->end_time, sizeof(struct iperf_time));\n        iperf_time_diff(&temp.interval_start_time, &temp.interval_end_time, &temp_time);\n        temp.interval_duration = iperf_time_in_secs(&temp_time);\n\tif (test->protocol->id == Ptcp) {\n\t    if ( has_tcpinfo()) {\n\t\tsave_tcpinfo(sp, &temp);\n\t\tif (test->sender_has_retransmits == 1) {\n\t\t    long total_retrans = get_total_retransmits(&temp);\n\t\t    temp.interval_retrans = total_retrans - rp->stream_prev_total_retrans;\n\t\t    rp->stream_retrans += temp.interval_retrans;\n\t\t    rp->stream_prev_total_retrans = total_retrans;\n\n\t\t    temp.snd_cwnd = get_snd_cwnd(&temp);\n\t\t    if (temp.snd_cwnd > rp->stream_max_snd_cwnd) {\n\t\t\trp->stream_max_snd_cwnd = temp.snd_cwnd;\n\t\t    }\n\n\t\t    temp.snd_wnd = get_snd_wnd(&temp);\n\t\t    if (temp.snd_wnd > rp->stream_max_snd_wnd) {\n\t\t\trp->stream_max_snd_wnd = temp.snd_wnd;\n\t\t    }\n\n\t\t    temp.rtt = get_rtt(&temp);\n\t\t    if (temp.rtt > rp->stream_max_rtt) {\n\t\t\trp->stream_max_rtt = temp.rtt;\n\t\t    }\n\t\t    if (rp->stream_min_rtt == 0 ||\n\t\t\ttemp.rtt < rp->stream_min_rtt) {\n\t\t\trp->stream_min_rtt = temp.rtt;\n\t\t    }\n\t\t    rp->stream_sum_rtt += temp.rtt;\n\t\t    rp->stream_count_rtt++;\n\n\t\t    temp.rttvar = get_rttvar(&temp);\n\t\t    temp.pmtu = get_pmtu(&temp);\n\t\t}\n\t    }\n\t} else {\n\t    if (irp == NULL) {\n\t\ttemp.interval_packet_count = sp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error;\n\t    } else {\n\t\ttemp.interval_packet_count = sp->packet_count - irp->packet_count;\n\t\ttemp.interval_outoforder_packets = sp->outoforder_packets - irp->outoforder_packets;\n\t\ttemp.interval_cnt_error = sp->cnt_error - irp->cnt_error;\n\t    }\n\t    temp.packet_count = sp->packet_count;\n\t    temp.jitter = sp->jitter;\n\t    temp.outoforder_packets = sp->outoforder_packets;\n\t    temp.cnt_error = sp->cnt_error;\n\t}\n        add_to_interval_list(rp, &temp);\n        rp->bytes_sent_this_interval = rp->bytes_received_this_interval = 0;\n    }\n\n    /* Verify that total server's throughput is not above specified limit */\n    if (test->role == 's') {\n\tiperf_check_total_rate(test, total_interval_bytes_transferred);\n    }\n}\n\n/**\n * Print intermediate results during a test (interval report).\n * Uses print_interval_results to print the results for each stream,\n * then prints an interval summary for all streams in this\n * interval.\n */\nstatic void\niperf_print_intermediate(struct iperf_test *test)\n{\n    struct iperf_stream *sp = NULL;\n    struct iperf_interval_results *irp;\n    struct iperf_time temp_time;\n    cJSON *json_interval;\n    cJSON *json_interval_streams;\n\n    int lower_mode, upper_mode;\n    int current_mode;\n\n    /*\n     * Due to timing oddities, there can be cases, especially on the\n     * server side, where at the end of a test there is a fairly short\n     * interval with no data transferred.  This could caused by\n     * the control and data flows sharing the same path in the network,\n     * and having the control messages for stopping the test being\n     * queued behind the data packets.\n     *\n     * We'd like to try to omit that last interval when it happens, to\n     * avoid cluttering data and output with useless stuff.\n     * So we're going to try to ignore very short intervals (less than\n     * 10% of the interval time) that have no data.\n     */\n    int interval_ok = 0;\n    SLIST_FOREACH(sp, &test->streams, streams) {\n\tirp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n\tif (irp) {\n\t    iperf_time_diff(&irp->interval_start_time, &irp->interval_end_time, &temp_time);\n\t    double interval_len = iperf_time_in_secs(&temp_time);\n\t    if (test->debug) {\n\t\tprintf(\"interval_len %f bytes_transferred %\" PRIu64 \"\\n\", interval_len, irp->bytes_transferred);\n\t    }\n\n\t    /*\n\t     * If the interval is at least 10% the normal interval\n\t     * length, or if there were actual bytes transferred,\n\t     * then we want to keep this interval.\n\t     */\n\t    if (interval_len >= test->stats_interval * 0.10 ||\n\t\tirp->bytes_transferred > 0) {\n\t\tinterval_ok = 1;\n\t\tif (test->debug) {\n\t\t    printf(\"interval forces keep\\n\");\n\t\t}\n\t    }\n\t}\n    }\n    if (!interval_ok) {\n\tif (test->debug) {\n\t    printf(\"ignoring short interval with no data\\n\");\n\t}\n\treturn;\n    }\n\n    if (test->json_output) {\n        json_interval = cJSON_CreateObject();\n\tif (json_interval == NULL)\n\t    return;\n\tcJSON_AddItemToArray(test->json_intervals, json_interval);\n        json_interval_streams = cJSON_CreateArray();\n\tif (json_interval_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(json_interval, \"streams\", json_interval_streams);\n    } else {\n        json_interval = NULL;\n        json_interval_streams = NULL;\n    }\n\n    /*\n     * We must to sum streams separately.\n     * For bidirectional mode we must to display\n     * information about sender and receiver streams.\n     * For client side we must handle sender streams\n     * firstly and receiver streams for server side.\n     * The following design allows us to do this.\n     */\n\n    if (test->mode == BIDIRECTIONAL) {\n        if (test->role == 'c') {\n            lower_mode = -1;\n            upper_mode = 0;\n        } else {\n            lower_mode = 0;\n            upper_mode = 1;\n        }\n    } else {\n        lower_mode = test->mode;\n        upper_mode = lower_mode;\n    }\n\n\n    for (current_mode = lower_mode; current_mode <= upper_mode; ++current_mode) {\n        char ubuf[UNIT_LEN];\n        char nbuf[UNIT_LEN];\n        char mbuf[UNIT_LEN];\n        char zbuf[] = \"          \";\n\n        iperf_size_t bytes = 0;\n        double bandwidth;\n        int retransmits = 0;\n        double start_time, end_time;\n\n        int64_t total_packets = 0, lost_packets = 0;\n        double avg_jitter = 0.0, lost_percent;\n        int stream_must_be_sender = current_mode * current_mode;\n\n        char *sum_name;\n\n        /*  Print stream role just for bidirectional mode. */\n\n        if (test->mode == BIDIRECTIONAL) {\n            sprintf(mbuf, \"[%s-%s]\", stream_must_be_sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n        } else {\n            mbuf[0] = '\\0';\n            zbuf[0] = '\\0';\n        }\n\n        SLIST_FOREACH(sp, &test->streams, streams) {\n            if (sp->sender == stream_must_be_sender) {\n                print_interval_results(test, sp, json_interval_streams);\n                /* sum up all streams */\n                irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);\n                if (irp == NULL) {\n                    iperf_err(test,\n                            \"iperf_print_intermediate error: interval_results is NULL\");\n                    return;\n                }\n                bytes += irp->bytes_transferred;\n                if (test->protocol->id == Ptcp) {\n                    if (test->sender_has_retransmits == 1) {\n                        retransmits += irp->interval_retrans;\n                    }\n                } else {\n                    total_packets += irp->interval_packet_count;\n                    lost_packets += irp->interval_cnt_error;\n                    avg_jitter += irp->jitter;\n                }\n            }\n        }\n\n        /* next build string with sum of all streams */\n        if (test->num_streams > 1 || test->json_output) {\n            /*\n             * With BIDIR give a different JSON object name to the one sent/receive sums.\n             * The different name is given to the data sent from the server, which is\n             * the \"reverse\" channel.  This makes sure that the name reported on the server\n             * and client are compatible, and the names are the same as with non-bidir,\n             * except for when reverse is used.\n             */\n            sum_name = \"sum\";\n            if (test->mode == BIDIRECTIONAL) {\n                if ((test->role == 'c' && !stream_must_be_sender) ||\n                    (test->role != 'c' && stream_must_be_sender))\n                {\n                    sum_name = \"sum_bidir_reverse\";\n                }\n            }\n\n            sp = SLIST_FIRST(&test->streams); /* reset back to 1st stream */\n            /* Only do this of course if there was a first stream */\n            if (sp) {\n\t    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead);    /* use 1st stream for timing info */\n\n\t    unit_snprintf(ubuf, UNIT_LEN, (double) bytes, 'A');\n\t    bandwidth = (double) bytes / (double) irp->interval_duration;\n\t    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n\t    iperf_time_diff(&sp->result->start_time,&irp->interval_start_time, &temp_time);\n\t    start_time = iperf_time_in_secs(&temp_time);\n\t    iperf_time_diff(&sp->result->start_time,&irp->interval_end_time, &temp_time);\n\t    end_time = iperf_time_in_secs(&temp_time);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits == 1 && stream_must_be_sender) {\n                        /* Interval sum, TCP with retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) retransmits, irp->omitted, stream_must_be_sender)); /* XXX irp->omitted or test->omitting? */\n                        else\n                            iperf_printf(test, report_sum_bw_retrans_format, mbuf, start_time, end_time, ubuf, nbuf, retransmits, irp->omitted?report_omitted:\"\"); /* XXX irp->omitted or test->omitting? */\n                    } else {\n                        /* Interval sum, TCP without retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_format, mbuf, start_time, end_time, ubuf, nbuf, test->omitting?report_omitted:\"\");\n                    }\n                } else {\n                    /* Interval sum, UDP. */\n                    if (stream_must_be_sender) {\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (int64_t) total_packets, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_udp_sender_format, mbuf, start_time, end_time, ubuf, nbuf, zbuf, total_packets, test->omitting?report_omitted:\"\");\n                    } else {\n                        avg_jitter /= test->num_streams;\n                        if (total_packets > 0) {\n                            lost_percent = 100.0 * lost_packets / total_packets;\n                        }\n                        else {\n                            lost_percent = 0.0;\n                        }\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_interval, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b\", (double) start_time, (double) end_time, (double) irp->interval_duration, (int64_t) bytes, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, test->omitting, stream_must_be_sender));\n                        else\n                            iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, end_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, total_packets, lost_percent, test->omitting?report_omitted:\"\");\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Print overall summary statistics at the end of a test.\n */\nstatic void\niperf_print_results(struct iperf_test *test)\n{\n\n    cJSON *json_summary_streams = NULL;\n\n    int lower_mode, upper_mode;\n    int current_mode;\n\n    char *sum_sent_name, *sum_received_name, *sum_name;\n\n    int tmp_sender_has_retransmits = test->sender_has_retransmits;\n\n    /* print final summary for all intervals */\n\n    if (test->json_output) {\n        json_summary_streams = cJSON_CreateArray();\n\tif (json_summary_streams == NULL)\n\t    return;\n\tcJSON_AddItemToObject(test->json_end, \"streams\", json_summary_streams);\n    } else {\n\tiperf_printf(test, \"%s\", report_bw_separator);\n\tif (test->verbose)\n\t    iperf_printf(test, \"%s\", report_summary);\n\tif (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\t    if (test->sender_has_retransmits || test->other_side_has_retransmits) {\n\t        if (test->bidirectional)\n\t            iperf_printf(test, \"%s\", report_bw_retrans_header_bidir);\n\t        else\n\t            iperf_printf(test, \"%s\", report_bw_retrans_header);\n\t    }\n\t    else {\n\t        if (test->bidirectional)\n\t            iperf_printf(test, \"%s\", report_bw_header_bidir);\n\t        else\n\t            iperf_printf(test, \"%s\", report_bw_header);\n\t    }\n\t} else {\n\t    if (test->bidirectional)\n\t        iperf_printf(test, \"%s\", report_bw_udp_header_bidir);\n\t    else\n\t        iperf_printf(test, \"%s\", report_bw_udp_header);\n\t}\n    }\n\n    /*\n     * We must to sum streams separately.\n     * For bidirectional mode we must to display\n     * information about sender and receiver streams.\n     * For client side we must handle sender streams\n     * firstly and receiver streams for server side.\n     * The following design allows us to do this.\n     */\n\n    if (test->mode == BIDIRECTIONAL) {\n        if (test->role == 'c') {\n            lower_mode = -1;\n            upper_mode = 0;\n        } else {\n            lower_mode = 0;\n            upper_mode = 1;\n        }\n    } else {\n        lower_mode = test->mode;\n        upper_mode = lower_mode;\n    }\n\n\n    for (current_mode = lower_mode; current_mode <= upper_mode; ++current_mode) {\n        cJSON *json_summary_stream = NULL;\n        int64_t total_retransmits = 0;\n        int64_t total_packets = 0, lost_packets = 0;\n        int64_t sender_packet_count = 0, receiver_packet_count = 0; /* for this stream, this interval */\n        int64_t sender_omitted_packet_count = 0, receiver_omitted_packet_count = 0; /* for this stream, this interval */\n        int64_t sender_total_packets = 0, receiver_total_packets = 0; /* running total */\n        char ubuf[UNIT_LEN];\n        char nbuf[UNIT_LEN];\n        struct stat sb;\n        char sbuf[UNIT_LEN];\n        struct iperf_stream *sp = NULL;\n        iperf_size_t bytes_sent, total_sent = 0;\n        iperf_size_t bytes_received, total_received = 0;\n        double start_time, end_time = 0.0, avg_jitter = 0.0, lost_percent = 0.0;\n        double sender_time = 0.0, receiver_time = 0.0;\n        struct iperf_time temp_time;\n        double bandwidth;\n\n        char mbuf[UNIT_LEN];\n        int stream_must_be_sender = current_mode * current_mode;\n\n\n        /*  Print stream role just for bidirectional mode. */\n\n        if (test->mode == BIDIRECTIONAL) {\n            sprintf(mbuf, \"[%s-%s]\", stream_must_be_sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n        } else {\n            mbuf[0] = '\\0';\n        }\n\n        /* Get sender_has_retransmits for each sender side (client and server) */\n        if (test->mode == BIDIRECTIONAL && stream_must_be_sender)\n            test->sender_has_retransmits = tmp_sender_has_retransmits;\n        else if (test->mode == BIDIRECTIONAL && !stream_must_be_sender)\n            test->sender_has_retransmits = test->other_side_has_retransmits;\n\n        start_time = 0.;\n        sp = SLIST_FIRST(&test->streams);\n\n        /*\n         * If there is at least one stream, then figure out the length of time\n         * we were running the tests and print out some statistics about\n         * the streams.  It's possible to not have any streams at all\n         * if the client got interrupted before it got to do anything.\n         *\n         * Also note that we try to keep separate values for the sender\n         * and receiver ending times.  Earlier iperf (3.1 and earlier)\n         * servers didn't send that to the clients, so in this case we fall\n         * back to using the client's ending timestamp.  The fallback is\n         * basically emulating what iperf 3.1 did.\n         */\n\n        if (sp) {\n        iperf_time_diff(&sp->result->start_time, &sp->result->end_time, &temp_time);\n        end_time = iperf_time_in_secs(&temp_time);\n        if (sp->sender) {\n            sp->result->sender_time = end_time;\n            if (sp->result->receiver_time == 0.0) {\n                sp->result->receiver_time = sp->result->sender_time;\n            }\n        }\n        else {\n            sp->result->receiver_time = end_time;\n            if (sp->result->sender_time == 0.0) {\n                sp->result->sender_time = sp->result->receiver_time;\n            }\n        }\n        sender_time = sp->result->sender_time;\n        receiver_time = sp->result->receiver_time;\n        SLIST_FOREACH(sp, &test->streams, streams) {\n            if (sp->sender == stream_must_be_sender) {\n                if (test->json_output) {\n                    json_summary_stream = cJSON_CreateObject();\n                    if (json_summary_stream == NULL)\n                        return;\n                    cJSON_AddItemToArray(json_summary_streams, json_summary_stream);\n                }\n\n                bytes_sent = sp->result->bytes_sent - sp->result->bytes_sent_omit;\n                bytes_received = sp->result->bytes_received;\n                total_sent += bytes_sent;\n                total_received += bytes_received;\n\n                if (sp->sender) {\n                    sender_packet_count = sp->packet_count;\n                    sender_omitted_packet_count = sp->omitted_packet_count;\n                    receiver_packet_count = sp->peer_packet_count;\n                    receiver_omitted_packet_count = sp->peer_omitted_packet_count;\n                }\n                else {\n                    sender_packet_count = sp->peer_packet_count;\n                    sender_omitted_packet_count = sp->peer_omitted_packet_count;\n                    receiver_packet_count = sp->packet_count;\n                    receiver_omitted_packet_count = sp->omitted_packet_count;\n                }\n\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits) {\n                        total_retransmits += sp->result->stream_retrans;\n                    }\n                } else {\n                    /*\n                     * Running total of the total number of packets.  Use the sender packet count if we\n                     * have it, otherwise use the receiver packet count.\n                     */\n                    int64_t packet_count = sender_packet_count ? sender_packet_count : receiver_packet_count;\n                    total_packets += (packet_count - sp->omitted_packet_count);\n                    sender_total_packets += (sender_packet_count - sender_omitted_packet_count);\n                    receiver_total_packets += (receiver_packet_count - receiver_omitted_packet_count);\n                    lost_packets += sp->cnt_error;\n                    if (sp->omitted_cnt_error > -1)\n                         lost_packets -= sp->omitted_cnt_error;\n                    avg_jitter += sp->jitter;\n                }\n\n                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_sent, 'A');\n                if (sender_time > 0.0) {\n                    bandwidth = (double) bytes_sent / (double) sender_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    if (test->sender_has_retransmits) {\n                        /* Sender summary, TCP and SCTP with retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, report_sender, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  max_snd_cwnd:  %d  max_snd_wnd:  %d  max_rtt:  %d  min_rtt:  %d  mean_rtt:  %d sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8, (int64_t) sp->result->stream_retrans, (int64_t) sp->result->stream_max_snd_cwnd, (int64_t) sp->result->stream_max_snd_wnd, (int64_t) sp->result->stream_max_rtt, (int64_t) sp->result->stream_min_rtt, (int64_t) ((sp->result->stream_count_rtt == 0) ? 0 : sp->result->stream_sum_rtt / sp->result->stream_count_rtt), stream_must_be_sender));\n                        else\n                            if (test->role == 's' && !sp->sender) {\n                                if (test->verbose)\n                                    iperf_printf(test, report_sender_not_available_format, sp->socket);\n                            }\n                            else {\n                                iperf_printf(test, report_bw_retrans_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, sp->result->stream_retrans, report_sender);\n                            }\n                    } else {\n                        /* Sender summary, TCP and SCTP without retransmits. */\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, report_sender, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8,  stream_must_be_sender));\n                        else\n                            if (test->role == 's' && !sp->sender) {\n                                if (test->verbose)\n                                    iperf_printf(test, report_sender_not_available_format, sp->socket);\n                            }\n                            else {\n                                iperf_printf(test, report_bw_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, report_sender);\n                            }\n                    }\n                } else {\n                    /* Sender summary, UDP. */\n                    if (sender_packet_count - sender_omitted_packet_count > 0) {\n                        lost_percent = 100.0 * (sp->cnt_error - sp->omitted_cnt_error) / (sender_packet_count - sender_omitted_packet_count);\n                    }\n                    else {\n                        lost_percent = 0.0;\n                    }\n                    if (test->json_output) {\n                        /*\n                         * For historical reasons, we only emit one JSON\n                         * object for the UDP summary, and it contains\n                         * information for both the sender and receiver\n                         * side.\n                         *\n                         * The JSON format as currently defined only includes one\n                         * value for the number of packets.  We usually want that\n                         * to be the sender's value (how many packets were sent\n                         * by the sender).  However this value might not be\n                         * available on the receiver in certain circumstances\n                         * specifically on the server side for a normal test or\n                         * the client side for a reverse-mode test.  If this\n                         * is the case, then use the receiver's count of packets\n                         * instead.\n                         */\n                        int64_t packet_count = sender_packet_count ? sender_packet_count : receiver_packet_count;\n                        cJSON_AddItemToObject(json_summary_stream, \"udp\", iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  out_of_order: %d sender: %b\", (int64_t) sp->socket, (double) start_time, (double) sender_time, (double) sender_time, (int64_t) bytes_sent, bandwidth * 8, (double) sp->jitter * 1000.0, (int64_t) (sp->cnt_error - sp->omitted_cnt_error), (int64_t) (packet_count - sp->omitted_packet_count), (double) lost_percent, (int64_t) (sp->outoforder_packets - sp->omitted_outoforder_packets), stream_must_be_sender));\n                    }\n                    else {\n                        /*\n                         * Due to ordering of messages on the control channel,\n                         * the server cannot report on client-side summary\n                         * statistics.  If we're the server, omit one set of\n                         * summary statistics to avoid giving meaningless\n                         * results.\n                         */\n                        if (test->role == 's' && !sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_format, sp->socket);\n                        }\n                        else {\n                            iperf_printf(test, report_bw_udp_format, sp->socket, mbuf, start_time, sender_time, ubuf, nbuf, 0.0, 0, (sender_packet_count - sender_omitted_packet_count), (double) 0, report_sender);\n                        }\n                        if ((sp->outoforder_packets - sp->omitted_outoforder_packets) > 0)\n                          iperf_printf(test, report_sum_outoforder, mbuf, start_time, sender_time, (sp->outoforder_packets - sp->omitted_outoforder_packets));\n                    }\n                }\n\n                if (sp->diskfile_fd >= 0) {\n                    if (fstat(sp->diskfile_fd, &sb) == 0) {\n                        /* In the odd case that it's a zero-sized file, say it was all transferred. */\n                        int percent_sent = 100, percent_received = 100;\n                        if (sb.st_size > 0) {\n                            percent_sent = (int) ( ( (double) bytes_sent / (double) sb.st_size ) * 100.0 );\n                            percent_received = (int) ( ( (double) bytes_received / (double) sb.st_size ) * 100.0 );\n                        }\n                        unit_snprintf(sbuf, UNIT_LEN, (double) sb.st_size, 'A');\n                        if (test->json_output)\n                            cJSON_AddItemToObject(json_summary_stream, \"diskfile\", iperf_json_printf(\"sent: %d  received: %d  size: %d  percent_sent: %d  percent_received: %d  filename: %s\", (int64_t) bytes_sent, (int64_t) bytes_received, (int64_t) sb.st_size, (int64_t) percent_sent, (int64_t) percent_received, test->diskfile_name));\n                        else\n                            if (stream_must_be_sender) {\n                                iperf_printf(test, report_diskfile, ubuf, sbuf, percent_sent, test->diskfile_name);\n                            }\n                            else {\n                                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n                                iperf_printf(test, report_diskfile, ubuf, sbuf, percent_received, test->diskfile_name);\n                            }\n                    }\n                }\n\n                unit_snprintf(ubuf, UNIT_LEN, (double) bytes_received, 'A');\n                if (receiver_time > 0) {\n                    bandwidth = (double) bytes_received / (double) receiver_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                    /* Receiver summary, TCP and SCTP */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(json_summary_stream, report_receiver, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (int64_t) sp->socket, (double) start_time, (double) receiver_time, (double) end_time, (int64_t) bytes_received, bandwidth * 8, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_receiver_not_available_format, sp->socket);\n                        }\n                        else {\n                            iperf_printf(test, report_bw_format, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);\n                        }\n                }\n                else {\n                    /*\n                     * Receiver summary, UDP.  Note that JSON was emitted with\n                     * the sender summary, so we only deal with human-readable\n                     * data here.\n                     */\n                    if (! test->json_output) {\n                        if (receiver_packet_count - receiver_omitted_packet_count > 0 && sp->omitted_cnt_error > -1) {\n                            lost_percent = 100.0 * (sp->cnt_error - sp->omitted_cnt_error) / (receiver_packet_count - receiver_omitted_packet_count);\n                        }\n                        else {\n                            lost_percent = 0.0;\n                        }\n\n                        if (test->role == 's' && sp->sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_receiver_not_available_format, sp->socket);\n                        }\n                        else {\n                            if (sp->omitted_cnt_error > -1) {\n                                iperf_printf(test, report_bw_udp_format, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, sp->jitter * 1000.0, (sp->cnt_error - sp->omitted_cnt_error), (receiver_packet_count - receiver_omitted_packet_count), lost_percent, report_receiver);\n                            } else {\n                                iperf_printf(test, report_bw_udp_format_no_omitted_error, sp->socket, mbuf, start_time, receiver_time, ubuf, nbuf, sp->jitter * 1000.0, (receiver_packet_count - receiver_omitted_packet_count), report_receiver);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        }\n\n        if (test->num_streams > 1 || test->json_output) {\n            /*\n             * With BIDIR give a different JSON object name to the one sent/receive sums.\n             * The different name is given to the data sent from the server, which is\n             * the \"reverse\" channel.  This makes sure that the name reported on the server\n             * and client are compatible, and the names are the same as with non-bidir,\n             * except for when reverse is used.\n             */\n            sum_name = \"sum\";\n            sum_sent_name = \"sum_sent\";\n            sum_received_name = \"sum_received\";\n            if (test->mode == BIDIRECTIONAL) {\n                if ((test->role == 'c' && !stream_must_be_sender) ||\n                    (test->role != 'c' && stream_must_be_sender))\n                {\n                    sum_name = \"sum_bidir_reverse\";\n                    sum_sent_name = \"sum_sent_bidir_reverse\";\n                    sum_received_name = \"sum_received_bidir_reverse\";\n                }\n\n            }\n\n            unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n            /* If no tests were run, arbitrarily set bandwidth to 0. */\n            if (sender_time > 0.0) {\n                bandwidth = (double) total_sent / (double) sender_time;\n            }\n            else {\n                bandwidth = 0.0;\n            }\n            unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n            if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n                if (test->sender_has_retransmits) {\n                    /* Summary sum, TCP with retransmits. */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, bandwidth * 8, (int64_t) total_retransmits, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && !stream_must_be_sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_summary_format, \"SUM\");\n                        }\n                        else {\n                          iperf_printf(test, report_sum_bw_retrans_format, mbuf, start_time, sender_time, ubuf, nbuf, total_retransmits, report_sender);\n                        }\n                } else {\n                    /* Summary sum, TCP without retransmits. */\n                    if (test->json_output)\n                        cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, bandwidth * 8, stream_must_be_sender));\n                    else\n                        if (test->role == 's' && !stream_must_be_sender) {\n                            if (test->verbose)\n                                iperf_printf(test, report_sender_not_available_summary_format, \"SUM\");\n                        }\n                        else {\n                            iperf_printf(test, report_sum_bw_format, mbuf, start_time, sender_time, ubuf, nbuf, report_sender);\n                        }\n                }\n                unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n                /* If no tests were run, set received bandwidth to 0 */\n                if (receiver_time > 0.0) {\n                    bandwidth = (double) total_received / (double) receiver_time;\n                }\n                else {\n                    bandwidth = 0.0;\n                }\n                unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                if (test->json_output)\n                    cJSON_AddItemToObject(test->json_end, sum_received_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_received, bandwidth * 8, stream_must_be_sender));\n                else\n                    if (test->role == 's' && stream_must_be_sender) {\n                        if (test->verbose)\n                            iperf_printf(test, report_receiver_not_available_summary_format, \"SUM\");\n                    }\n                    else {\n                        iperf_printf(test, report_sum_bw_format, mbuf, start_time, receiver_time, ubuf, nbuf, report_receiver);\n                    }\n            } else {\n                /* Summary sum, UDP. */\n                avg_jitter /= test->num_streams;\n                /* If no packets were sent, arbitrarily set loss percentage to 0. */\n                if (total_packets > 0) {\n                    lost_percent = 100.0 * lost_packets / total_packets;\n                }\n                else {\n                    lost_percent = 0.0;\n                }\n                if (test->json_output) {\n                    /*\n                     * Original, summary structure. Using this\n                     * structure is not recommended due to\n                     * ambiguities between the sender and receiver.\n                     */\n                    cJSON_AddItemToObject(test->json_end, sum_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_sent, bandwidth * 8, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) total_packets, (double) lost_percent, stream_must_be_sender));\n                    /*\n                     * Separate sum_sent and sum_received structures.\n                     * Using these structures to get the most complete\n                     * information about UDP transfer.\n                     */\n                    cJSON_AddItemToObject(test->json_end, sum_sent_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  sender: %b\", (double) start_time, (double) sender_time, (double) sender_time, (int64_t) total_sent, (double) total_sent * 8 / sender_time, (double) 0.0, (int64_t) 0, (int64_t) sender_total_packets, (double) 0.0, 1));\n                    cJSON_AddItemToObject(test->json_end, sum_received_name, iperf_json_printf(\"start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  sender: %b\", (double) start_time, (double) receiver_time, (double) receiver_time, (int64_t) total_received, (double) total_received * 8 / receiver_time, (double) avg_jitter * 1000.0, (int64_t) lost_packets, (int64_t) receiver_total_packets, (double) lost_percent, 0));\n                } else {\n                    /*\n                     * On the client we have both sender and receiver overall summary\n                     * stats.  On the server we have only the side that was on the\n                     * server.  Output whatever we have.\n                     */\n                    if (! (test->role == 's' && !stream_must_be_sender) ) {\n                        unit_snprintf(ubuf, UNIT_LEN, (double) total_sent, 'A');\n                        iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, sender_time, ubuf, nbuf, 0.0, 0, sender_total_packets, 0.0, report_sender);\n                    }\n                    if (! (test->role == 's' && stream_must_be_sender) ) {\n\n                        unit_snprintf(ubuf, UNIT_LEN, (double) total_received, 'A');\n                        /* Compute received bandwidth. */\n                        if (end_time > 0.0) {\n                            bandwidth = (double) total_received / (double) receiver_time;\n                        }\n                        else {\n                            bandwidth = 0.0;\n                        }\n                        unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n                        iperf_printf(test, report_sum_bw_udp_format, mbuf, start_time, receiver_time, ubuf, nbuf, avg_jitter * 1000.0, lost_packets, receiver_total_packets, lost_percent, report_receiver);\n                    }\n                }\n            }\n        }\n\n        if (test->json_output && current_mode == upper_mode) {\n            cJSON_AddItemToObject(test->json_end, \"cpu_utilization_percent\", iperf_json_printf(\"host_total: %f  host_user: %f  host_system: %f  remote_total: %f  remote_user: %f  remote_system: %f\", (double) test->cpu_util[0], (double) test->cpu_util[1], (double) test->cpu_util[2], (double) test->remote_cpu_util[0], (double) test->remote_cpu_util[1], (double) test->remote_cpu_util[2]));\n            if (test->protocol->id == Ptcp) {\n                char *snd_congestion = NULL, *rcv_congestion = NULL;\n                if (stream_must_be_sender) {\n                    snd_congestion = test->congestion_used;\n                    rcv_congestion = test->remote_congestion_used;\n                }\n                else {\n                    snd_congestion = test->remote_congestion_used;\n                    rcv_congestion = test->congestion_used;\n                }\n                if (snd_congestion) {\n                    cJSON_AddStringToObject(test->json_end, \"sender_tcp_congestion\", snd_congestion);\n                }\n                if (rcv_congestion) {\n                    cJSON_AddStringToObject(test->json_end, \"receiver_tcp_congestion\", rcv_congestion);\n                }\n            }\n        }\n        else {\n            if (test->verbose) {\n                if (stream_must_be_sender) {\n                    if (test->bidirectional) {\n                        iperf_printf(test, report_cpu, report_local, stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                        iperf_printf(test, report_cpu, report_local, !stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, !stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                    } else\n                        iperf_printf(test, report_cpu, report_local, stream_must_be_sender?report_sender:report_receiver, test->cpu_util[0], test->cpu_util[1], test->cpu_util[2], report_remote, stream_must_be_sender?report_receiver:report_sender, test->remote_cpu_util[0], test->remote_cpu_util[1], test->remote_cpu_util[2]);\n                }\n                if (test->protocol->id == Ptcp) {\n                    char *snd_congestion = NULL, *rcv_congestion = NULL;\n                    if (stream_must_be_sender) {\n                        snd_congestion = test->congestion_used;\n                        rcv_congestion = test->remote_congestion_used;\n                    }\n                    else {\n                        snd_congestion = test->remote_congestion_used;\n                        rcv_congestion = test->congestion_used;\n                    }\n                    if (snd_congestion) {\n                        iperf_printf(test, \"snd_tcp_congestion %s\\n\", snd_congestion);\n                    }\n                    if (rcv_congestion) {\n                        iperf_printf(test, \"rcv_tcp_congestion %s\\n\", rcv_congestion);\n                    }\n                }\n            }\n\n            /* Print server output if we're on the client and it was requested/provided */\n            if (test->role == 'c' && iperf_get_test_get_server_output(test) && !test->json_output) {\n                if (test->json_server_output) {\n\t\t    char *str = cJSON_Print(test->json_server_output);\n                    iperf_printf(test, \"\\nServer JSON output:\\n%s\\n\", str);\n\t\t    cJSON_free(str);\n                    cJSON_Delete(test->json_server_output);\n                    test->json_server_output = NULL;\n                }\n                if (test->server_output_text) {\n                    iperf_printf(test, \"\\nServer output:\\n%s\\n\", test->server_output_text);\n                    test->server_output_text = NULL;\n                }\n            }\n        }\n    }\n\n    /* Set real sender_has_retransmits for current side */\n    if (test->mode == BIDIRECTIONAL)\n        test->sender_has_retransmits = tmp_sender_has_retransmits;\n}\n\n/**************************************************************************/\n\n/**\n * Main report-printing callback.\n * Prints results either during a test (interval report only) or\n * after the entire test has been run (last interval report plus\n * overall summary).\n */\nvoid\niperf_reporter_callback(struct iperf_test *test)\n{\n    switch (test->state) {\n        case TEST_RUNNING:\n        case STREAM_RUNNING:\n            /* print interval results for each stream */\n            iperf_print_intermediate(test);\n            break;\n        case TEST_END:\n        case DISPLAY_RESULTS:\n            iperf_print_intermediate(test);\n            iperf_print_results(test);\n            break;\n    }\n\n}\n\n/**\n * Print the interval results for one stream.\n * This function needs to know about the overall test so it can determine the\n * context for printing headers, separators, etc.\n */\nstatic void\nprint_interval_results(struct iperf_test *test, struct iperf_stream *sp, cJSON *json_interval_streams)\n{\n    char ubuf[UNIT_LEN];\n    char nbuf[UNIT_LEN];\n    char cbuf[UNIT_LEN];\n    char mbuf[UNIT_LEN];\n    char zbuf[] = \"          \";\n    double st = 0., et = 0.;\n    struct iperf_time temp_time;\n    struct iperf_interval_results *irp = NULL;\n    double bandwidth, lost_percent;\n\n    if (test->mode == BIDIRECTIONAL) {\n        sprintf(mbuf, \"[%s-%s]\", sp->sender?\"TX\":\"RX\", test->role == 'c'?\"C\":\"S\");\n    } else {\n        mbuf[0] = '\\0';\n        zbuf[0] = '\\0';\n    }\n\n    irp = TAILQ_LAST(&sp->result->interval_results, irlisthead); /* get last entry in linked list */\n    if (irp == NULL) {\n\tiperf_err(test, \"print_interval_results error: interval_results is NULL\");\n        return;\n    }\n    if (!test->json_output) {\n\t/* First stream? */\n\tif (sp == SLIST_FIRST(&test->streams)) {\n\t    /* It it's the first interval, print the header;\n\t    ** else if there's more than one stream, print the separator;\n\t    ** else nothing.\n\t    */\n\t    if (iperf_time_compare(&sp->result->start_time, &irp->interval_start_time) == 0) {\n\t\tif (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\t\t    if (test->sender_has_retransmits == 1) {\n\t\t        if (test->bidirectional)\n\t\t            iperf_printf(test, \"%s\", report_bw_retrans_cwnd_header_bidir);\n\t\t        else\n\t\t            iperf_printf(test, \"%s\", report_bw_retrans_cwnd_header);\n\t\t    }\n\t\t    else {\n\t                if (test->bidirectional)\n\t                    iperf_printf(test, \"%s\", report_bw_header_bidir);\n\t                else\n\t                    iperf_printf(test, \"%s\", report_bw_header);\n\t            }\n\t\t} else {\n\t\t    if (test->mode == SENDER) {\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_sender_header);\n\t\t    } else if (test->mode == RECEIVER){\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_header);\n\t\t    } else {\n\t\t        /* BIDIRECTIONAL */\n\t\t        iperf_printf(test, \"%s\", report_bw_udp_header_bidir);\n\t\t    }\n\t\t}\n\t    } else if (test->num_streams > 1)\n\t\tiperf_printf(test, \"%s\", report_bw_separator);\n\t}\n    }\n\n    unit_snprintf(ubuf, UNIT_LEN, (double) (irp->bytes_transferred), 'A');\n    if (irp->interval_duration > 0.0) {\n\tbandwidth = (double) irp->bytes_transferred / (double) irp->interval_duration;\n    }\n    else {\n\tbandwidth = 0.0;\n    }\n    unit_snprintf(nbuf, UNIT_LEN, bandwidth, test->settings->unit_format);\n\n    iperf_time_diff(&sp->result->start_time, &irp->interval_start_time, &temp_time);\n    st = iperf_time_in_secs(&temp_time);\n    iperf_time_diff(&sp->result->start_time, &irp->interval_end_time, &temp_time);\n    et = iperf_time_in_secs(&temp_time);\n\n    if (test->protocol->id == Ptcp || test->protocol->id == Psctp) {\n\tif (test->sender_has_retransmits == 1 && sp->sender) {\n\t    /* Interval, TCP with retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  retransmits: %d  snd_cwnd:  %d  snd_wnd:  %d  rtt:  %d  rttvar: %d  pmtu: %d  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_retrans, (int64_t) irp->snd_cwnd, (int64_t) irp->snd_wnd, (int64_t) irp->rtt, (int64_t) irp->rttvar, (int64_t) irp->pmtu, irp->omitted, sp->sender));\n\t    else {\n\t\tunit_snprintf(cbuf, UNIT_LEN, irp->snd_cwnd, 'A');\n\t\tiperf_printf(test, report_bw_retrans_cwnd_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->interval_retrans, cbuf, irp->omitted?report_omitted:\"\");\n\t    }\n\t} else {\n\t    /* Interval, TCP without retransmits. */\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->omitted?report_omitted:\"\");\n\t}\n    } else {\n\t/* Interval, UDP. */\n\tif (sp->sender) {\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  packets: %d  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (int64_t) irp->interval_packet_count, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_udp_sender_format, sp->socket, mbuf, st, et, ubuf, nbuf, zbuf, irp->interval_packet_count, irp->omitted?report_omitted:\"\");\n\t} else {\n\t    if (irp->interval_packet_count > 0) {\n\t\tlost_percent = 100.0 * irp->interval_cnt_error / irp->interval_packet_count;\n\t    }\n\t    else {\n\t\tlost_percent = 0.0;\n\t    }\n\t    if (test->json_output)\n\t\tcJSON_AddItemToArray(json_interval_streams, iperf_json_printf(\"socket: %d  start: %f  end: %f  seconds: %f  bytes: %d  bits_per_second: %f  jitter_ms: %f  lost_packets: %d  packets: %d  lost_percent: %f  omitted: %b sender: %b\", (int64_t) sp->socket, (double) st, (double) et, (double) irp->interval_duration, (int64_t) irp->bytes_transferred, bandwidth * 8, (double) irp->jitter * 1000.0, (int64_t) irp->interval_cnt_error, (int64_t) irp->interval_packet_count, (double) lost_percent, irp->omitted, sp->sender));\n\t    else\n\t\tiperf_printf(test, report_bw_udp_format, sp->socket, mbuf, st, et, ubuf, nbuf, irp->jitter * 1000.0, irp->interval_cnt_error, irp->interval_packet_count, lost_percent, irp->omitted?report_omitted:\"\");\n\t}\n    }\n\n    if (test->logfile || test->forceflush)\n        iflush(test);\n}\n\n/**************************************************************************/\nvoid\niperf_free_stream(struct iperf_stream *sp)\n{\n    struct iperf_interval_results *irp, *nirp;\n\n    /* XXX: need to free interval list too! */\n    munmap(sp->buffer, sp->test->settings->blksize);\n    close(sp->buffer_fd);\n    if (sp->diskfile_fd >= 0)\n\tclose(sp->diskfile_fd);\n    for (irp = TAILQ_FIRST(&sp->result->interval_results); irp != NULL; irp = nirp) {\n        nirp = TAILQ_NEXT(irp, irlistentries);\n        free(irp);\n    }\n    free(sp->result);\n    if (sp->send_timer != NULL)\n\ttmr_cancel(sp->send_timer);\n    free(sp);\n}\n\n/**************************************************************************/\nstruct iperf_stream *\niperf_new_stream(struct iperf_test *test, int s, int sender)\n{\n    struct iperf_stream *sp;\n    int ret = 0;\n\n    char template[1024];\n    if (test->tmp_template) {\n        snprintf(template, sizeof(template) / sizeof(char), \"%s\", test->tmp_template);\n    } else {\n        //find the system temporary dir *unix, windows, cygwin support\n        char* tempdir = getenv(\"TMPDIR\");\n        if (tempdir == 0){\n            tempdir = getenv(\"TEMP\");\n        }\n        if (tempdir == 0){\n            tempdir = getenv(\"TMP\");\n        }\n        if (tempdir == 0){\n#if defined(__ANDROID__)\n            tempdir = \"/data/local/tmp\";\n#else\n            tempdir = \"/tmp\";\n#endif\n        }\n        snprintf(template, sizeof(template) / sizeof(char), \"%s/iperf3.XXXXXX\", tempdir);\n    }\n\n    sp = (struct iperf_stream *) malloc(sizeof(struct iperf_stream));\n    if (!sp) {\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp, 0, sizeof(struct iperf_stream));\n\n    sp->sender = sender;\n    sp->test = test;\n    sp->settings = test->settings;\n    sp->result = (struct iperf_stream_result *) malloc(sizeof(struct iperf_stream_result));\n    if (!sp->result) {\n        free(sp);\n        i_errno = IECREATESTREAM;\n        return NULL;\n    }\n\n    memset(sp->result, 0, sizeof(struct iperf_stream_result));\n    TAILQ_INIT(&sp->result->interval_results);\n\n    /* Create and randomize the buffer */\n    sp->buffer_fd = mkstemp(template);\n    if (sp->buffer_fd == -1) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (unlink(template) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    if (ftruncate(sp->buffer_fd, test->settings->blksize) < 0) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->buffer = (char *) mmap(NULL, test->settings->blksize, PROT_READ|PROT_WRITE, MAP_PRIVATE, sp->buffer_fd, 0);\n    if (sp->buffer == MAP_FAILED) {\n        i_errno = IECREATESTREAM;\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    sp->pending_size = 0;\n\n    /* Set socket */\n    sp->socket = s;\n\n    sp->snd = test->protocol->send;\n    sp->rcv = test->protocol->recv;\n\n    if (test->diskfile_name != (char*) 0) {\n\tsp->diskfile_fd = open(test->diskfile_name, sender ? O_RDONLY : (O_WRONLY|O_CREAT|O_TRUNC), S_IRUSR|S_IWUSR);\n\tif (sp->diskfile_fd == -1) {\n\t    i_errno = IEFILE;\n            munmap(sp->buffer, sp->test->settings->blksize);\n            free(sp->result);\n            free(sp);\n\t    return NULL;\n\t}\n        sp->snd2 = sp->snd;\n\tsp->snd = diskfile_send;\n\tsp->rcv2 = sp->rcv;\n\tsp->rcv = diskfile_recv;\n    } else\n        sp->diskfile_fd = -1;\n\n    /* Initialize stream */\n    if (test->repeating_payload)\n        fill_with_repeating_pattern(sp->buffer, test->settings->blksize);\n    else\n        ret = readentropy(sp->buffer, test->settings->blksize);\n\n    if ((ret < 0) || (iperf_init_stream(sp, test) < 0)) {\n        close(sp->buffer_fd);\n        munmap(sp->buffer, sp->test->settings->blksize);\n        free(sp->result);\n        free(sp);\n        return NULL;\n    }\n    iperf_add_stream(test, sp);\n\n    return sp;\n}\n\n/**************************************************************************/\nint\niperf_common_sockopts(struct iperf_test *test, int s)\n{\n    int opt;\n\n    /* Set IP TOS */\n    if ((opt = test->settings->tos)) {\n\tif (getsockdomain(s) == AF_INET6) {\n#ifdef IPV6_TCLASS\n\t    if (setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETCOS;\n                return -1;\n            }\n\n\t    /* if the control connection was established with a mapped v4 address\n\t       then set IP_TOS on v6 stream socket as well */\n\t    if (iperf_get_mapped_v4(test)) {\n\t\tif (setsockopt(s, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                    /* ignore any failure of v4 TOS in IPv6 case */\n                }\n            }\n#else\n            i_errno = IESETCOS;\n            return -1;\n#endif\n        } else {\n            if (setsockopt(s, IPPROTO_IP, IP_TOS, &opt, sizeof(opt)) < 0) {\n                i_errno = IESETTOS;\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**************************************************************************/\nint\niperf_init_stream(struct iperf_stream *sp, struct iperf_test *test)\n{\n    int opt;\n    socklen_t len;\n\n    len = sizeof(struct sockaddr_storage);\n    if (getsockname(sp->socket, (struct sockaddr *) &sp->local_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n    len = sizeof(struct sockaddr_storage);\n    if (getpeername(sp->socket, (struct sockaddr *) &sp->remote_addr, &len) < 0) {\n        i_errno = IEINITSTREAM;\n        return -1;\n    }\n\n#if defined(HAVE_DONT_FRAGMENT)\n    /* Set Don't Fragment (DF). Only applicable to IPv4/UDP tests. */\n    if (iperf_get_test_protocol_id(test) == Pudp &&\n        getsockdomain(sp->socket) == AF_INET &&\n        iperf_get_dont_fragment(test)) {\n\n        /*\n         * There are multiple implementations of this feature depending on the OS.\n         * We need to handle separately Linux, UNIX, and Windows, as well as\n         * the case that DF isn't supported at all (such as on macOS).\n         */\n#if defined(IP_MTU_DISCOVER) /* Linux version of IP_DONTFRAG */\n        opt = IP_PMTUDISC_DO;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_MTU_DISCOVER, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n#if defined(IP_DONTFRAG) /* UNIX does IP_DONTFRAG */\n        opt = 1;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_DONTFRAG, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n#if defined(IP_DONTFRAGMENT) /* Windows does IP_DONTFRAGMENT */\n        opt = 1;\n        if (setsockopt(sp->socket, IPPROTO_IP, IP_DONTFRAGMENT, &opt, sizeof(opt)) < 0) {\n            i_errno = IESETDONTFRAGMENT;\n            return -1;\n        }\n#else\n\ti_errno = IESETDONTFRAGMENT;\n\treturn -1;\n#endif /* IP_DONTFRAGMENT */\n#endif /* IP_DONTFRAG */\n#endif /* IP_MTU_DISCOVER */\n    }\n#endif /* HAVE_DONT_FRAGMENT */\n\n    return 0;\n}\n\n/**************************************************************************/\nvoid\niperf_add_stream(struct iperf_test *test, struct iperf_stream *sp)\n{\n    int i;\n    struct iperf_stream *n, *prev;\n\n    if (SLIST_EMPTY(&test->streams)) {\n        SLIST_INSERT_HEAD(&test->streams, sp, streams);\n        sp->id = 1;\n    } else {\n        // for (n = test->streams, i = 2; n->next; n = n->next, ++i);\n        // NOTE: this would ideally be set to 1, however this will not\n        //       be changed since it is not causing a significant problem\n        //       and changing it would break multi-stream tests between old\n        //       and new iperf3 versions.\n        i = 2;\n        prev = NULL;\n        SLIST_FOREACH(n, &test->streams, streams) {\n            prev = n;\n            ++i;\n        }\n        if (prev) {\n            SLIST_INSERT_AFTER(prev, sp, streams);\n            sp->id = i;\n         }\n    }\n}\n\n/* This pair of routines gets inserted into the snd/rcv function pointers\n** when there's a -F flag. They handle the file stuff and call the real\n** snd/rcv functions, which have been saved in snd2/rcv2.\n**\n** The advantage of doing it this way is that in the much more common\n** case of no -F flag, there is zero extra overhead.\n*/\n\nstatic int\ndiskfile_send(struct iperf_stream *sp)\n{\n    int r;\n    int buffer_left = sp->diskfile_left; // represents total data in buffer to be sent out\n    static int rtot;\n\n    /* if needed, read enough data from the disk to fill up the buffer */\n    if (sp->diskfile_left < sp->test->settings->blksize && !sp->test->done) {\n    \tr = read(sp->diskfile_fd, sp->buffer, sp->test->settings->blksize -\n    \t\t sp->diskfile_left);\n        buffer_left += r;\n    \trtot += r;\n    \tif (sp->test->debug) {\n    \t    printf(\"read %d bytes from file, %d total\\n\", r, rtot);\n    \t}\n\n        // If the buffer doesn't contain a full buffer at this point,\n        // adjust the size of the data to send.\n        if (buffer_left != sp->test->settings->blksize) {\n            if (sp->test->debug)\n                printf(\"possible eof\\n\");\n            // setting data size to be sent,\n            // which is less than full block/buffer size\n            // (to be used by iperf_tcp_send, etc.)\n            sp->pending_size = buffer_left;\n        }\n\n        // If there's no work left, we're done.\n        if (buffer_left == 0) {\n    \t    sp->test->done = 1;\n    \t    if (sp->test->debug)\n    \t\t  printf(\"done\\n\");\n    \t}\n    }\n\n    // If there's no data left in the file or in the buffer, we're done.\n    // No more data available to be sent.\n    // Return without sending data to the network\n    if( sp->test->done || buffer_left == 0 ){\n        if (sp->test->debug)\n              printf(\"already done\\n\");\n        sp->test->done = 1;\n        return 0;\n    }\n\n    r = sp->snd2(sp);\n    if (r < 0) {\n\treturn r;\n    }\n    /*\n     * Compute how much data is in the buffer but didn't get sent.\n     * If there are bytes that got left behind, slide them to the\n     * front of the buffer so they can hopefully go out on the next\n     * pass.\n     */\n    sp->diskfile_left = buffer_left - r;\n    if (sp->diskfile_left && sp->diskfile_left < sp->test->settings->blksize) {\n\tmemcpy(sp->buffer,\n\t       sp->buffer + (sp->test->settings->blksize - sp->diskfile_left),\n\t       sp->diskfile_left);\n\tif (sp->test->debug)\n\t    printf(\"Shifting %d bytes by %d\\n\", sp->diskfile_left, (sp->test->settings->blksize - sp->diskfile_left));\n    }\n    return r;\n}\n\nstatic int\ndiskfile_recv(struct iperf_stream *sp)\n{\n    int r;\n\n    r = sp->rcv2(sp);\n    if (r > 0) {\n\t// NOTE: Currently ignoring the return value of writing to disk\n\t(void) (write(sp->diskfile_fd, sp->buffer, r) + 1);\n    }\n    return r;\n}\n\n\nvoid\niperf_catch_sigend(void (*handler)(int))\n{\n#ifdef SIGINT\n    signal(SIGINT, handler);\n#endif\n#ifdef SIGTERM\n    signal(SIGTERM, handler);\n#endif\n#ifdef SIGHUP\n    signal(SIGHUP, handler);\n#endif\n}\n\n/**\n * Called as a result of getting a signal.\n * Depending on the current state of the test (and the role of this\n * process) compute and report one more set of ending statistics\n * before cleaning up and exiting.\n */\nvoid\niperf_got_sigend(struct iperf_test *test)\n{\n    /*\n     * If we're the client, or if we're a server and running a test,\n     * then dump out the accumulated stats so far.\n     */\n    if (test->role == 'c' ||\n      (test->role == 's' && test->state == TEST_RUNNING)) {\n\n\ttest->done = 1;\n\tcpu_util(test->cpu_util);\n\ttest->stats_callback(test);\n\ttest->state = DISPLAY_RESULTS; /* change local state only */\n\tif (test->on_test_finish)\n\t    test->on_test_finish(test);\n\ttest->reporter_callback(test);\n    }\n\n    if (test->ctrl_sck >= 0) {\n\ttest->state = (test->role == 'c') ? CLIENT_TERMINATE : SERVER_TERMINATE;\n\t(void) Nwrite(test->ctrl_sck, (char*) &test->state, sizeof(signed char), Ptcp);\n    }\n    i_errno = (test->role == 'c') ? IECLIENTTERM : IESERVERTERM;\n    iperf_errexit(test, \"interrupt - %s\", iperf_strerror(i_errno));\n}\n\n/* Try to write a PID file if requested, return -1 on an error. */\nint\niperf_create_pidfile(struct iperf_test *test)\n{\n    if (test->pidfile) {\n\tint fd;\n\tchar buf[8];\n\n\t/* See if the file already exists and we can read it. */\n\tfd = open(test->pidfile, O_RDONLY, 0);\n\tif (fd >= 0) {\n\t    if (read(fd, buf, sizeof(buf) - 1) >= 0) {\n\n\t\t/* We read some bytes, see if they correspond to a valid PID */\n\t\tpid_t pid;\n\t\tpid = atoi(buf);\n\t\tif (pid > 0) {\n\n\t\t    /* See if the process exists. */\n\t\t    if (kill(pid, 0) == 0) {\n\t\t\t/*\n\t\t\t * Make sure not to try to delete existing PID file by\n\t\t\t * scribbling over the pathname we'd use to refer to it.\n\t\t\t * Then exit with an error.\n\t\t\t */\n\t\t\tfree(test->pidfile);\n\t\t\ttest->pidfile = NULL;\n\t\t\tiperf_errexit(test, \"Another instance of iperf3 appears to be running\");\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * File didn't exist, we couldn't read it, or it didn't correspond to\n\t * a running process.  Try to create it.\n\t */\n\tfd = open(test->pidfile, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR|S_IWUSR);\n\tif (fd < 0) {\n\t    return -1;\n\t}\n\tsnprintf(buf, sizeof(buf), \"%d\", getpid()); /* no trailing newline */\n\tif (write(fd, buf, strlen(buf)) < 0) {\n\t    (void)close(fd);\n\t    return -1;\n\t}\n\tif (close(fd) < 0) {\n\t    return -1;\n\t};\n    }\n    return 0;\n}\n\n/* Get rid of a PID file, return -1 on error. */\nint\niperf_delete_pidfile(struct iperf_test *test)\n{\n    if (test->pidfile) {\n\tif (unlink(test->pidfile) < 0) {\n\t    return -1;\n\t}\n    }\n    return 0;\n}\n\nint\niperf_json_start(struct iperf_test *test)\n{\n    test->json_top = cJSON_CreateObject();\n    if (test->json_top == NULL)\n        return -1;\n    test->json_start = cJSON_CreateObject();\n    if (test->json_start == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"start\", test->json_start);\n    test->json_connected = cJSON_CreateArray();\n    if (test->json_connected == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_start, \"connected\", test->json_connected);\n    test->json_intervals = cJSON_CreateArray();\n    if (test->json_intervals == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"intervals\", test->json_intervals);\n    test->json_end = cJSON_CreateObject();\n    if (test->json_end == NULL)\n        return -1;\n    cJSON_AddItemToObject(test->json_top, \"end\", test->json_end);\n    return 0;\n}\n\nint\niperf_json_finish(struct iperf_test *test)\n{\n    if (test->json_top) {\n        if (test->title) {\n            cJSON_AddStringToObject(test->json_top, \"title\", test->title);\n        }\n        if (test->extra_data) {\n            cJSON_AddStringToObject(test->json_top, \"extra_data\", test->extra_data);\n        }\n        /* Include server output */\n        if (test->json_server_output) {\n            cJSON_AddItemToObject(test->json_top, \"server_output_json\", test->json_server_output);\n        }\n        if (test->server_output_text) {\n            cJSON_AddStringToObject(test->json_top, \"server_output_text\", test->server_output_text);\n        }\n        // Get ASCII rendering of JSON structure.  Then make our\n        // own copy of it and return the storage that cJSON allocated\n        // on our behalf.  We keep our own copy around.\n        char *str = cJSON_Print(test->json_top);\n        if (str == NULL) {\n            return -1;\n        }\n        test->json_output_string = strdup(str);\n        cJSON_free(str);\n        if (test->json_output_string == NULL) {\n            return -1;\n        }\n        fprintf(test->outfile, \"%s\\n\", test->json_output_string);\n        iflush(test);\n        cJSON_Delete(test->json_top);\n        test->json_top = NULL;\n    }\n    test->json_start = test->json_connected = test->json_intervals = test->json_server_output = test->json_end = NULL;\n    return 0;\n}\n\n\n/* CPU affinity stuff - Linux, FreeBSD, and Windows only. */\n\nint\niperf_setaffinity(struct iperf_test *test, int affinity)\n{\n#if defined(HAVE_SCHED_SETAFFINITY)\n    cpu_set_t cpu_set;\n\n    CPU_ZERO(&cpu_set);\n    CPU_SET(affinity, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_CPUSET_SETAFFINITY)\n    cpuset_t cpumask;\n\n    if(cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &test->cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n\n    CPU_ZERO(&cpumask);\n    CPU_SET(affinity, &cpumask);\n\n    if(cpuset_setaffinity(CPU_LEVEL_WHICH,CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_SETPROCESSAFFINITYMASK)\n\tHANDLE process = GetCurrentProcess();\n\tDWORD_PTR processAffinityMask = 1 << affinity;\n\n\tif (SetProcessAffinityMask(process, processAffinityMask) == 0) {\n\t\ti_errno = IEAFFINITY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n}\n\nint\niperf_clearaffinity(struct iperf_test *test)\n{\n#if defined(HAVE_SCHED_SETAFFINITY)\n    cpu_set_t cpu_set;\n    int i;\n\n    CPU_ZERO(&cpu_set);\n    for (i = 0; i < CPU_SETSIZE; ++i)\n\tCPU_SET(i, &cpu_set);\n    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu_set) != 0) {\n\ti_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_CPUSET_SETAFFINITY)\n    if(cpuset_setaffinity(CPU_LEVEL_WHICH,CPU_WHICH_PID, -1,\n                          sizeof(cpuset_t), &test->cpumask) != 0) {\n        i_errno = IEAFFINITY;\n        return -1;\n    }\n    return 0;\n#elif defined(HAVE_SETPROCESSAFFINITYMASK)\n\tHANDLE process = GetCurrentProcess();\n\tDWORD_PTR processAffinityMask;\n\tDWORD_PTR lpSystemAffinityMask;\n\n\tif (GetProcessAffinityMask(process, &processAffinityMask, &lpSystemAffinityMask) == 0\n\t\t\t|| SetProcessAffinityMask(process, lpSystemAffinityMask) == 0) {\n\t\ti_errno = IEAFFINITY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#else /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n    i_errno = IEAFFINITY;\n    return -1;\n#endif /* neither HAVE_SCHED_SETAFFINITY nor HAVE_CPUSET_SETAFFINITY nor HAVE_SETPROCESSAFFINITYMASK */\n}\n\nstatic char iperf_timestr[100];\nstatic char linebuffer[1024];\n\nint\niperf_printf(struct iperf_test *test, const char* format, ...)\n{\n    va_list argp;\n    int r = 0, r0;\n    time_t now;\n    struct tm *ltm = NULL;\n    char *ct = NULL;\n\n    /* Timestamp if requested */\n    if (iperf_get_test_timestamps(test)) {\n\ttime(&now);\n\tltm = localtime(&now);\n\tstrftime(iperf_timestr, sizeof(iperf_timestr), iperf_get_test_timestamp_format(test), ltm);\n\tct = iperf_timestr;\n    }\n\n    /*\n     * There are roughly two use cases here.  If we're the client,\n     * want to print stuff directly to the output stream.\n     * If we're the sender we might need to buffer up output to send\n     * to the client.\n     *\n     * This doesn't make a whole lot of difference except there are\n     * some chunks of output on the client (on particular the whole\n     * of the server output with --get-server-output) that could\n     * easily exceed the size of the line buffer, but which don't need\n     * to be buffered up anyway.\n     */\n    if (test->role == 'c') {\n\tif (ct) {\n            r0 = fprintf(test->outfile, \"%s\", ct);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n\t}\n\tif (test->title) {\n\t    r0 = fprintf(test->outfile, \"%s:  \", test->title);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n        }\n\tva_start(argp, format);\n\tr0 = vfprintf(test->outfile, format, argp);\n\tva_end(argp);\n        if (r0 < 0)\n            return r0;\n        r += r0;\n    }\n    else if (test->role == 's') {\n\tif (ct) {\n\t    r0 = snprintf(linebuffer, sizeof(linebuffer), \"%s\", ct);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n\t}\n        /* Should always be true as long as sizeof(ct) < sizeof(linebuffer) */\n        if (r < sizeof(linebuffer)) {\n            va_start(argp, format);\n            r0 = vsnprintf(linebuffer + r, sizeof(linebuffer) - r, format, argp);\n            va_end(argp);\n            if (r0 < 0)\n                return r0;\n            r += r0;\n        }\n\tfprintf(test->outfile, \"%s\", linebuffer);\n\n\tif (test->role == 's' && iperf_get_test_get_server_output(test)) {\n\t    struct iperf_textline *l = (struct iperf_textline *) malloc(sizeof(struct iperf_textline));\n\t    l->line = strdup(linebuffer);\n\t    TAILQ_INSERT_TAIL(&(test->server_output_list), l, textlineentries);\n\t}\n    }\n    return r;\n}\n\nint\niflush(struct iperf_test *test)\n{\n    return fflush(test->outfile);\n}\n"], "filenames": ["src/iperf_api.c"], "buggy_code_start_loc": [2672], "buggy_code_end_loc": [2703], "fixing_code_start_loc": [2673], "fixing_code_end_loc": [2711], "type": "CWE-190", "message": "iperf3 before 3.14 allows peers to cause an integer overflow and heap corruption via a crafted length field.", "other": {"cve": {"id": "CVE-2023-38403", "sourceIdentifier": "cve@mitre.org", "published": "2023-07-17T21:15:09.800", "lastModified": "2024-01-09T02:53:19.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "iperf3 before 3.14 allows peers to cause an integer overflow and heap corruption via a crafted length field."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:es:iperf3:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14", "matchCriteriaId": "CB06DF8B-3E48-4F3A-B510-50B8CE67FC1A"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}, {"vulnerable": true, "criteria": "cpe:2.3:o:netapp:clustered_data_ontap:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "C3ED302E-F464-40DE-A976-FD518E42D95D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.6.1", "matchCriteriaId": "7AC99BA0-CC79-4E06-87CA-CA3525CEF81E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:14.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FE27DF1-3AF9-4BE4-8541-565FE5BC16A2"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Oct/24", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2023/Oct/26", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.debian.org/1040830", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cwe.mitre.org/data/definitions/130.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://downloads.es.net/pub/iperf/esnet-secadv-2023-0001.txt.asc", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/esnet/iperf/commit/0ef151550d96cc4460f98832df84b4a1e87c65e9", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/esnet/iperf/issues/1542", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/07/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/BV6EBWWF4PEQKROEVXGYSTIT2MGBTLU7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce%40lists.fedoraproject.org/message/M25Z5FHTO3XWMGP37JHJ7IIIHSGCLKEV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230818-0016/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213984", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213985", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/esnet/iperf/commit/0ef151550d96cc4460f98832df84b4a1e87c65e9"}}