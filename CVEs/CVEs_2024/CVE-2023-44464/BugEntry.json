{"buggy_code": ["#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport datetime\nimport mimetypes\nimport os\nfrom decimal import Decimal\nfrom zoneinfo import ZoneInfo\n\nimport django_filters\nfrom django.db import transaction\nfrom django.db.models import (\n    Exists, F, OuterRef, Prefetch, Q, Subquery, prefetch_related_objects,\n)\nfrom django.db.models.functions import Coalesce, Concat\nfrom django.http import FileResponse, HttpResponse\nfrom django.shortcuts import get_object_or_404\nfrom django.utils.timezone import make_aware, now\nfrom django.utils.translation import gettext as _\nfrom django_filters.rest_framework import DjangoFilterBackend, FilterSet\nfrom django_scopes import scopes_disabled\nfrom PIL import Image\nfrom rest_framework import serializers, status, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.exceptions import (\n    APIException, NotFound, PermissionDenied, ValidationError,\n)\nfrom rest_framework.mixins import CreateModelMixin\nfrom rest_framework.response import Response\n\nfrom pretix.api.models import OAuthAccessToken\nfrom pretix.api.pagination import TotalOrderingFilter\nfrom pretix.api.serializers.order import (\n    BlockedTicketSecretSerializer, InvoiceSerializer, OrderCreateSerializer,\n    OrderPaymentCreateSerializer, OrderPaymentSerializer,\n    OrderPositionSerializer, OrderRefundCreateSerializer,\n    OrderRefundSerializer, OrderSerializer, PriceCalcSerializer,\n    RevokedTicketSecretSerializer, SimulatedOrderSerializer,\n)\nfrom pretix.api.serializers.orderchange import (\n    BlockNameSerializer, OrderChangeOperationSerializer,\n    OrderFeeChangeSerializer, OrderPositionChangeSerializer,\n    OrderPositionCreateForExistingOrderSerializer,\n    OrderPositionInfoPatchSerializer,\n)\nfrom pretix.api.views import RichOrderingFilter\nfrom pretix.base.i18n import language\nfrom pretix.base.models import (\n    CachedCombinedTicket, CachedTicket, Checkin, Device, EventMetaValue,\n    Invoice, InvoiceAddress, ItemMetaValue, ItemVariation,\n    ItemVariationMetaValue, Order, OrderFee, OrderPayment, OrderPosition,\n    OrderRefund, Quota, ReusableMedium, SubEvent, SubEventMetaValue, TaxRule,\n    TeamAPIToken, generate_secret,\n)\nfrom pretix.base.models.orders import (\n    BlockedTicketSecret, QuestionAnswer, RevokedTicketSecret,\n)\nfrom pretix.base.payment import PaymentException\nfrom pretix.base.pdf import get_images\nfrom pretix.base.secrets import assign_ticket_secret\nfrom pretix.base.services import tickets\nfrom pretix.base.services.invoices import (\n    generate_cancellation, generate_invoice, invoice_pdf, invoice_qualified,\n    regenerate_invoice,\n)\nfrom pretix.base.services.mail import SendMailException\nfrom pretix.base.services.orders import (\n    OrderChangeManager, OrderError, _order_placed_email,\n    _order_placed_email_attendee, approve_order, cancel_order, deny_order,\n    extend_order, mark_order_expired, mark_order_refunded, reactivate_order,\n)\nfrom pretix.base.services.pricing import get_price\nfrom pretix.base.services.tickets import generate\nfrom pretix.base.signals import (\n    order_modified, order_paid, order_placed, register_ticket_outputs,\n)\nfrom pretix.base.templatetags.money import money_filter\nfrom pretix.control.signals import order_search_filter_q\n\nwith scopes_disabled():\n    class OrderFilter(FilterSet):\n        email = django_filters.CharFilter(field_name='email', lookup_expr='iexact')\n        code = django_filters.CharFilter(field_name='code', lookup_expr='iexact')\n        status = django_filters.CharFilter(field_name='status', lookup_expr='iexact')\n        modified_since = django_filters.IsoDateTimeFilter(field_name='last_modified', lookup_expr='gte')\n        created_since = django_filters.IsoDateTimeFilter(field_name='datetime', lookup_expr='gte')\n        subevent_after = django_filters.IsoDateTimeFilter(method='subevent_after_qs')\n        subevent_before = django_filters.IsoDateTimeFilter(method='subevent_before_qs')\n        search = django_filters.CharFilter(method='search_qs')\n        item = django_filters.CharFilter(field_name='all_positions', lookup_expr='item_id', distinct=True)\n        variation = django_filters.CharFilter(field_name='all_positions', lookup_expr='variation_id', distinct=True)\n        subevent = django_filters.CharFilter(field_name='all_positions', lookup_expr='subevent_id', distinct=True)\n\n        class Meta:\n            model = Order\n            fields = ['code', 'status', 'email', 'locale', 'testmode', 'require_approval']\n\n        @scopes_disabled()\n        def subevent_after_qs(self, qs, name, value):\n            qs = qs.filter(\n                pk__in=Subquery(\n                    OrderPosition.all.filter(\n                        subevent_id__in=SubEvent.objects.filter(\n                            Q(date_to__gt=value) | Q(date_from__gt=value, date_to__isnull=True),\n                            event=self.request.event\n                        ).values_list('id'),\n                    ).values_list('order_id')\n                )\n            )\n            return qs\n\n        def subevent_before_qs(self, qs, name, value):\n            qs = qs.filter(\n                pk__in=Subquery(\n                    OrderPosition.all.filter(\n                        subevent_id__in=SubEvent.objects.filter(\n                            Q(date_from__lt=value),\n                            event=self.request.event\n                        ).values_list('id'),\n                    ).values_list('order_id')\n                )\n            )\n            return qs\n\n        def search_qs(self, qs, name, value):\n            u = value\n            if \"-\" in value:\n                code = (Q(event__slug__icontains=u.rsplit(\"-\", 1)[0])\n                        & Q(code__icontains=Order.normalize_code(u.rsplit(\"-\", 1)[1])))\n            else:\n                code = Q(code__icontains=Order.normalize_code(u))\n\n            invoice_nos = {u, u.upper()}\n            if u.isdigit():\n                for i in range(2, 12):\n                    invoice_nos.add(u.zfill(i))\n\n            matching_invoices = Invoice.objects.filter(\n                Q(invoice_no__in=invoice_nos)\n                | Q(full_invoice_no__iexact=u)\n            ).values_list('order_id', flat=True)\n\n            matching_positions = OrderPosition.objects.filter(\n                Q(order=OuterRef('pk')) & Q(\n                    Q(attendee_name_cached__icontains=u) | Q(attendee_email__icontains=u)\n                    | Q(secret__istartswith=u)\n                    # | Q(voucher__code__icontains=u)  # temporarily removed since it caused bad query performance on postgres\n                )\n            ).values('id')\n\n            matching_media = ReusableMedium.objects.filter(identifier=u).values_list('linked_orderposition__order_id', flat=True)\n\n            mainq = (\n                code\n                | Q(email__icontains=u)\n                | Q(invoice_address__name_cached__icontains=u)\n                | Q(invoice_address__company__icontains=u)\n                | Q(pk__in=matching_invoices)\n                | Q(pk__in=matching_media)\n                | Q(comment__icontains=u)\n                | Q(has_pos=True)\n            )\n            for recv, q in order_search_filter_q.send(sender=getattr(self, 'event', None), query=u):\n                mainq = mainq | q\n            return qs.annotate(has_pos=Exists(matching_positions)).filter(\n                mainq\n            )\n\n\nclass OrderViewSet(viewsets.ModelViewSet):\n    serializer_class = OrderSerializer\n    queryset = Order.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('datetime',)\n    ordering_fields = ('datetime', 'code', 'status', 'last_modified')\n    filterset_class = OrderFilter\n    lookup_field = 'code'\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['event'] = self.request.event\n        ctx['pdf_data'] = self.request.query_params.get('pdf_data', 'false') == 'true'\n        ctx['exclude'] = self.request.query_params.getlist('exclude')\n        ctx['include'] = self.request.query_params.getlist('include')\n        return ctx\n\n    def get_queryset(self):\n        qs = self.request.event.orders\n        if 'fees' not in self.request.GET.getlist('exclude'):\n            if self.request.query_params.get('include_canceled_fees', 'false') == 'true':\n                fqs = OrderFee.all\n            else:\n                fqs = OrderFee.objects\n            qs = qs.prefetch_related(Prefetch('fees', queryset=fqs.all()))\n        if 'payments' not in self.request.GET.getlist('exclude'):\n            qs = qs.prefetch_related('payments')\n        if 'refunds' not in self.request.GET.getlist('exclude'):\n            qs = qs.prefetch_related('refunds', 'refunds__payment')\n        if 'invoice_address' not in self.request.GET.getlist('exclude'):\n            qs = qs.select_related('invoice_address')\n\n        qs = qs.prefetch_related(self._positions_prefetch(self.request))\n        return qs\n\n    def _positions_prefetch(self, request):\n        if request.query_params.get('include_canceled_positions', 'false') == 'true':\n            opq = OrderPosition.all\n        else:\n            opq = OrderPosition.objects\n        if request.query_params.get('pdf_data', 'false') == 'true':\n            prefetch_related_objects([request.organizer], 'meta_properties')\n            prefetch_related_objects(\n                [request.event],\n                Prefetch('meta_values', queryset=EventMetaValue.objects.select_related('property'), to_attr='meta_values_cached'),\n                'questions',\n                'item_meta_properties',\n            )\n            return Prefetch(\n                'positions',\n                opq.all().prefetch_related(\n                    Prefetch('checkins', queryset=Checkin.objects.all()),\n                    Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                        Prefetch('meta_values', ItemMetaValue.objects.select_related('property'), to_attr='meta_values_cached')\n                    )),\n                    Prefetch('variation', queryset=ItemVariation.objects.prefetch_related(\n                        Prefetch('meta_values', ItemVariationMetaValue.objects.select_related('property'), to_attr='meta_values_cached')\n                    )),\n                    'answers', 'answers__options', 'answers__question',\n                    'item__category',\n                    'addon_to__answers', 'addon_to__answers__options', 'addon_to__answers__question',\n                    Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                        Prefetch('meta_values', to_attr='meta_values_cached', queryset=SubEventMetaValue.objects.select_related('property'))\n                    )),\n                    Prefetch('addons', opq.select_related('item', 'variation', 'seat')),\n                    'linked_media',\n                ).select_related('seat', 'addon_to', 'addon_to__seat')\n            )\n        else:\n            return Prefetch(\n                'positions',\n                opq.all().prefetch_related(\n                    Prefetch('checkins', queryset=Checkin.objects.all()),\n                    'item', 'variation',\n                    Prefetch('answers', queryset=QuestionAnswer.objects.prefetch_related('options', 'question').order_by('question__position')),\n                    'seat',\n                )\n            )\n\n    def _get_output_provider(self, identifier):\n        responses = register_ticket_outputs.send(self.request.event)\n        for receiver, response in responses:\n            prov = response(self.request.event)\n            if prov.identifier == identifier:\n                return prov\n        raise NotFound('Unknown output provider.')\n\n    @scopes_disabled()  # we are sure enough that get_queryset() is correct, so we save some perforamnce\n    def list(self, request, **kwargs):\n        date = serializers.DateTimeField().to_representation(now())\n        queryset = self.filter_queryset(self.get_queryset())\n\n        page = self.paginate_queryset(queryset)\n        if page is not None:\n            serializer = self.get_serializer(page, many=True)\n            resp = self.get_paginated_response(serializer.data)\n            resp['X-Page-Generated'] = date\n            return resp\n\n        serializer = self.get_serializer(queryset, many=True)\n        return Response(serializer.data, headers={'X-Page-Generated': date})\n\n    @action(detail=True, url_name='download', url_path='download/(?P<output>[^/]+)')\n    def download(self, request, output, **kwargs):\n        provider = self._get_output_provider(output)\n        order = self.get_object()\n\n        if order.status in (Order.STATUS_CANCELED, Order.STATUS_EXPIRED):\n            raise PermissionDenied(\"Downloads are not available for canceled or expired orders.\")\n\n        if order.status == Order.STATUS_PENDING and not (order.valid_if_pending or request.event.settings.ticket_download_pending):\n            raise PermissionDenied(\"Downloads are not available for pending orders.\")\n\n        ct = CachedCombinedTicket.objects.filter(\n            order=order, provider=provider.identifier, file__isnull=False\n        ).last()\n        if not ct or not ct.file:\n            generate.apply_async(args=('order', order.pk, provider.identifier))\n            raise RetryException()\n        else:\n            if ct.type == 'text/uri-list':\n                resp = HttpResponse(ct.file.file.read(), content_type='text/uri-list')\n                return resp\n            else:\n                resp = FileResponse(ct.file.file, content_type=ct.type)\n                resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}{}\"'.format(\n                    self.request.event.slug.upper(), order.code,\n                    provider.identifier, ct.extension\n                )\n                return resp\n\n    @action(detail=True, methods=['POST'])\n    def mark_paid(self, request, **kwargs):\n        order = self.get_object()\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        if order.status in (Order.STATUS_PENDING, Order.STATUS_EXPIRED):\n\n            ps = order.pending_sum\n            try:\n                p = order.payments.get(\n                    state__in=(OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED),\n                    provider='manual',\n                    amount=ps\n                )\n            except OrderPayment.DoesNotExist:\n                for p in order.payments.filter(state__in=(OrderPayment.PAYMENT_STATE_PENDING,\n                                                          OrderPayment.PAYMENT_STATE_CREATED)):\n                    try:\n                        with transaction.atomic():\n                            p.payment_provider.cancel_payment(p)\n                            order.log_action('pretix.event.order.payment.canceled', {\n                                'local_id': p.local_id,\n                                'provider': p.provider,\n                            }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n                    except PaymentException as e:\n                        order.log_action(\n                            'pretix.event.order.payment.canceled.failed',\n                            {\n                                'local_id': p.local_id,\n                                'provider': p.provider,\n                                'error': str(e)\n                            },\n                            user=self.request.user if self.request.user.is_authenticated else None,\n                            auth=self.request.auth\n                        )\n                p = order.payments.create(\n                    state=OrderPayment.PAYMENT_STATE_CREATED,\n                    provider='manual',\n                    amount=ps,\n                    fee=None\n                )\n\n            try:\n                p.confirm(auth=self.request.auth,\n                          user=self.request.user if request.user.is_authenticated else None,\n                          send_mail=send_mail,\n                          count_waitinglist=False)\n            except Quota.QuotaExceededException as e:\n                return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n            except PaymentException as e:\n                return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n            except SendMailException:\n                pass\n\n            return self.retrieve(request, [], **kwargs)\n        return Response(\n            {'detail': 'The order is not pending or expired.'},\n            status=status.HTTP_400_BAD_REQUEST\n        )\n\n    @action(detail=True, methods=['POST'])\n    def mark_canceled(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        comment = request.data.get('comment', None)\n        cancellation_fee = request.data.get('cancellation_fee', None)\n        if cancellation_fee:\n            try:\n                cancellation_fee = float(Decimal(cancellation_fee))\n            except:\n                cancellation_fee = None\n\n        order = self.get_object()\n        if not order.cancel_allowed():\n            return Response(\n                {'detail': 'The order is not allowed to be canceled.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        try:\n            cancel_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                api_token=request.auth if isinstance(request.auth, TeamAPIToken) else None,\n                device=request.auth if isinstance(request.auth, Device) else None,\n                oauth_application=request.auth.application if isinstance(request.auth, OAuthAccessToken) else None,\n                send_mail=send_mail,\n                email_comment=comment,\n                cancellation_fee=cancellation_fee\n            )\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def reactivate(self, request, **kwargs):\n\n        order = self.get_object()\n        if order.status != Order.STATUS_CANCELED:\n            return Response(\n                {'detail': 'The order is not allowed to be reactivated.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        try:\n            reactivate_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n            )\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def approve(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        order = self.get_object()\n        try:\n            approve_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n                send_mail=send_mail,\n            )\n        except Quota.QuotaExceededException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except OrderError as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def deny(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        comment = request.data.get('comment', '')\n\n        order = self.get_object()\n        try:\n            deny_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n                send_mail=send_mail,\n                comment=comment,\n            )\n        except OrderError as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_pending(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PAID:\n            return Response(\n                {'detail': 'The order is not paid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        order.status = Order.STATUS_PENDING\n        order.save(update_fields=['status'])\n        order.log_action(\n            'pretix.event.order.unpaid',\n            user=request.user if request.user.is_authenticated else None,\n            auth=request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_expired(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PENDING:\n            return Response(\n                {'detail': 'The order is not pending.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        mark_order_expired(\n            order,\n            user=request.user if request.user.is_authenticated else None,\n            auth=request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_refunded(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PAID:\n            return Response(\n                {'detail': 'The order is not paid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        mark_order_refunded(\n            order,\n            user=request.user if request.user.is_authenticated else None,\n            auth=(request.auth if isinstance(request.auth, (TeamAPIToken, OAuthAccessToken, Device)) else None),\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def create_invoice(self, request, **kwargs):\n        order = self.get_object()\n        has_inv = order.invoices.exists() and not (\n            order.status in (Order.STATUS_PAID, Order.STATUS_PENDING)\n            and order.invoices.filter(is_cancellation=True).count() >= order.invoices.filter(is_cancellation=False).count()\n        )\n        if self.request.event.settings.get('invoice_generate') not in ('admin', 'user', 'paid', 'True') or not invoice_qualified(order):\n            return Response(\n                {'detail': _('You cannot generate an invoice for this order.')},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        elif has_inv:\n            return Response(\n                {'detail': _('An invoice for this order already exists.')},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        inv = generate_invoice(order)\n        order.log_action(\n            'pretix.event.order.invoice.generated',\n            user=self.request.user,\n            auth=self.request.auth,\n            data={\n                'invoice': inv.pk\n            }\n        )\n        return Response(\n            InvoiceSerializer(inv).data,\n            status=status.HTTP_201_CREATED\n        )\n\n    @action(detail=True, methods=['POST'])\n    def resend_link(self, request, **kwargs):\n        order = self.get_object()\n        if not order.email:\n            return Response({'detail': 'There is no email address associated with this order.'}, status=status.HTTP_400_BAD_REQUEST)\n        try:\n            order.resend_link(user=self.request.user, auth=self.request.auth)\n        except SendMailException:\n            return Response({'detail': _('There was an error sending the mail. Please try again later.')}, status=status.HTTP_503_SERVICE_UNAVAILABLE)\n\n        return Response(\n            status=status.HTTP_204_NO_CONTENT\n        )\n\n    @action(detail=True, methods=['POST'])\n    @transaction.atomic\n    def regenerate_secrets(self, request, **kwargs):\n        order = self.get_object()\n        order.secret = generate_secret()\n        for op in order.all_positions.all():\n            assign_ticket_secret(\n                request.event, op, force_invalidate=True, save=True\n            )\n        order.save(update_fields=['secret'])\n        CachedTicket.objects.filter(order_position__order=order).delete()\n        CachedCombinedTicket.objects.filter(order=order).delete()\n        tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk,\n                                                     'order': order.pk})\n        order.log_action(\n            'pretix.event.order.secret.changed',\n            user=self.request.user,\n            auth=self.request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def extend(self, request, **kwargs):\n        new_date = request.data.get('expires', None)\n        force = request.data.get('force', False)\n        if not new_date:\n            return Response(\n                {'detail': 'New date is missing.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        df = serializers.DateField()\n        try:\n            new_date = df.to_internal_value(new_date)\n        except:\n            return Response(\n                {'detail': 'New date is invalid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        tz = ZoneInfo(self.request.event.settings.timezone)\n        new_date = make_aware(datetime.datetime.combine(\n            new_date,\n            datetime.time(hour=23, minute=59, second=59)\n        ), tz)\n\n        order = self.get_object()\n\n        try:\n            extend_order(\n                order,\n                new_date=new_date,\n                force=force,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth,\n            )\n            return self.retrieve(request, [], **kwargs)\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n    def create(self, request, *args, **kwargs):\n        if 'send_mail' in request.data and 'send_email' not in request.data:\n            request.data['send_email'] = request.data['send_mail']\n        serializer = OrderCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            try:\n                self.perform_create(serializer)\n            except TaxRule.SaleNotAllowed:\n                raise ValidationError(_('One of the selected products is not available in the selected country.'))\n            send_mail = serializer._send_mail\n            order = serializer.instance\n\n            if not order.pk:\n                # Simulation -- exit here\n                serializer = SimulatedOrderSerializer(order, context=serializer.context)\n                return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n            order.log_action(\n                'pretix.event.order.placed',\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth,\n            )\n\n        with language(order.locale, self.request.event.settings.region):\n            payment = order.payments.last()\n            # OrderCreateSerializer creates at most one payment\n            if payment and payment.state == OrderPayment.PAYMENT_STATE_CONFIRMED:\n                order.log_action(\n                    'pretix.event.order.payment.confirmed', {\n                        'local_id': payment.local_id,\n                        'provider': payment.provider,\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth,\n                )\n            order_placed.send(self.request.event, order=order)\n            if order.status == Order.STATUS_PAID:\n                order_paid.send(self.request.event, order=order)\n                order.log_action(\n                    'pretix.event.order.paid',\n                    {\n                        'provider': payment.provider if payment else None,\n                        'info': {},\n                        'date': now().isoformat(),\n                        'force': False\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth,\n                )\n\n            gen_invoice = invoice_qualified(order) and (\n                (order.event.settings.get('invoice_generate') == 'True') or\n                (order.event.settings.get('invoice_generate') == 'paid' and order.status == Order.STATUS_PAID)\n            ) and not order.invoices.last()\n            invoice = None\n            if gen_invoice:\n                invoice = generate_invoice(order, trigger_pdf=True)\n\n            # Refresh serializer only after running signals\n            prefetch_related_objects([order], self._positions_prefetch(request))\n            serializer = OrderSerializer(order, context=serializer.context)\n\n            if send_mail:\n                free_flow = (\n                    payment and order.total == Decimal('0.00') and order.status == Order.STATUS_PAID and\n                    not order.require_approval and payment.provider in (\"free\", \"boxoffice\")\n                )\n                if order.require_approval:\n                    email_template = request.event.settings.mail_text_order_placed_require_approval\n                    subject_template = request.event.settings.mail_subject_order_placed_require_approval\n                    log_entry = 'pretix.event.order.email.order_placed_require_approval'\n                    email_attendees = False\n                elif free_flow:\n                    email_template = request.event.settings.mail_text_order_free\n                    subject_template = request.event.settings.mail_subject_order_free\n                    log_entry = 'pretix.event.order.email.order_free'\n                    email_attendees = request.event.settings.mail_send_order_free_attendee\n                    email_attendees_template = request.event.settings.mail_text_order_free_attendee\n                    subject_attendees_template = request.event.settings.mail_subject_order_free_attendee\n                else:\n                    email_template = request.event.settings.mail_text_order_placed\n                    subject_template = request.event.settings.mail_subject_order_placed\n                    log_entry = 'pretix.event.order.email.order_placed'\n                    email_attendees = request.event.settings.mail_send_order_placed_attendee\n                    email_attendees_template = request.event.settings.mail_text_order_placed_attendee\n                    subject_attendees_template = request.event.settings.mail_subject_order_placed_attendee\n\n                _order_placed_email(\n                    request.event, order, email_template, subject_template,\n                    log_entry, invoice, [payment] if payment else [], is_free=free_flow\n                )\n                if email_attendees:\n                    for p in order.positions.all():\n                        if p.addon_to_id is None and p.attendee_email and p.attendee_email != order.email:\n                            _order_placed_email_attendee(request.event, order, p, email_attendees_template, subject_attendees_template,\n                                                         log_entry, is_free=free_flow)\n\n                if not free_flow and order.status == Order.STATUS_PAID and payment:\n                    payment._send_paid_mail(invoice, None, '')\n                    if self.request.event.settings.mail_send_order_paid_attendee:\n                        for p in order.positions.all():\n                            if p.addon_to_id is None and p.attendee_email and p.attendee_email != order.email:\n                                payment._send_paid_mail_attendee(p, None)\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.get('partial', False)\n        if not partial:\n            return Response(\n                {\"detail\": \"Method \\\"PUT\\\" not allowed.\"},\n                status=status.HTTP_405_METHOD_NOT_ALLOWED,\n            )\n        return super().update(request, *args, **kwargs)\n\n    def perform_update(self, serializer):\n        with transaction.atomic():\n            if 'comment' in self.request.data and serializer.instance.comment != self.request.data.get('comment'):\n                serializer.instance.log_action(\n                    'pretix.event.order.comment',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_comment': self.request.data.get('comment')\n                    }\n                )\n\n            if 'custom_followup_at' in self.request.data and serializer.instance.custom_followup_at != self.request.data.get('custom_followup_at'):\n                serializer.instance.log_action(\n                    'pretix.event.order.custom_followup_at',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_custom_followup_at': self.request.data.get('custom_followup_at')\n                    }\n                )\n\n            if 'checkin_attention' in self.request.data and serializer.instance.checkin_attention != self.request.data.get('checkin_attention'):\n                serializer.instance.log_action(\n                    'pretix.event.order.checkin_attention',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_value': self.request.data.get('checkin_attention')\n                    }\n                )\n\n            if 'valid_if_pending' in self.request.data and serializer.instance.valid_if_pending != self.request.data.get('valid_if_pending'):\n                serializer.instance.log_action(\n                    'pretix.event.order.valid_if_pending',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_value': self.request.data.get('valid_if_pending')\n                    }\n                )\n\n            if 'email' in self.request.data and serializer.instance.email != self.request.data.get('email'):\n                serializer.instance.email_known_to_work = False\n                serializer.instance.log_action(\n                    'pretix.event.order.contact.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_email': serializer.instance.email,\n                        'new_email': self.request.data.get('email'),\n                    }\n                )\n\n            if 'phone' in self.request.data and serializer.instance.phone != self.request.data.get('phone'):\n                serializer.instance.log_action(\n                    'pretix.event.order.phone.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_phone': serializer.instance.phone,\n                        'new_phone': self.request.data.get('phone'),\n                    }\n                )\n\n            if 'locale' in self.request.data and serializer.instance.locale != self.request.data.get('locale'):\n                serializer.instance.log_action(\n                    'pretix.event.order.locale.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_locale': serializer.instance.locale,\n                        'new_locale': self.request.data.get('locale'),\n                    }\n                )\n\n            if 'invoice_address' in self.request.data:\n                serializer.instance.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'invoice_data': self.request.data.get('invoice_address'),\n                    }\n                )\n\n            serializer.save()\n            tickets.invalidate_cache.apply_async(kwargs={'event': serializer.instance.event.pk, 'order': serializer.instance.pk})\n\n        if 'invoice_address' in self.request.data:\n            order_modified.send(sender=serializer.instance.event, order=serializer.instance)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    def perform_destroy(self, instance):\n        if not instance.testmode:\n            raise PermissionDenied('Only test mode orders can be deleted.')\n\n        with transaction.atomic():\n            self.get_object().gracefully_delete(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n\n    @action(detail=True, methods=['POST'])\n    def change(self, request, **kwargs):\n        order = self.get_object()\n\n        serializer = OrderChangeOperationSerializer(\n            context={'order': order, **self.get_serializer_context()},\n            data=request.data,\n        )\n        serializer.is_valid(raise_exception=True)\n\n        try:\n            ocm = OrderChangeManager(\n                order=order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=serializer.validated_data.get('send_email', False),\n                reissue_invoice=serializer.validated_data.get('reissue_invoice', True),\n            )\n\n            canceled_positions = set()\n            for r in serializer.validated_data.get('cancel_positions', []):\n                ocm.cancel(r['position'])\n                canceled_positions.add(r['position'])\n\n            for r in serializer.validated_data.get('patch_positions', []):\n                if r['position'] in canceled_positions:\n                    continue\n                pos_serializer = OrderPositionChangeSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                    partial=True,\n                )\n                pos_serializer.update(r['position'], r['body'])\n\n            for r in serializer.validated_data.get('split_positions', []):\n                if r['position'] in canceled_positions:\n                    continue\n                ocm.split(r['position'])\n\n            for r in serializer.validated_data.get('create_positions', []):\n                pos_serializer = OrderPositionCreateForExistingOrderSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                )\n                pos_serializer.create(r)\n\n            canceled_fees = set()\n            for r in serializer.validated_data.get('cancel_fees', []):\n                ocm.cancel_fee(r['fee'])\n                canceled_fees.add(r['fee'])\n\n            for r in serializer.validated_data.get('patch_fees', []):\n                if r['fee'] in canceled_fees:\n                    continue\n                pos_serializer = OrderFeeChangeSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                )\n                pos_serializer.update(r['fee'], r['body'])\n\n            if serializer.validated_data.get('recalculate_taxes') == 'keep_net':\n                ocm.recalculate_taxes(keep='net')\n            elif serializer.validated_data.get('recalculate_taxes') == 'keep_gross':\n                ocm.recalculate_taxes(keep='gross')\n\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n\n        order.refresh_from_db()\n        serializer = OrderSerializer(\n            instance=order,\n            context=self.get_serializer_context(),\n        )\n        return Response(serializer.data)\n\n\nwith scopes_disabled():\n    class OrderPositionFilter(FilterSet):\n        order = django_filters.CharFilter(field_name='order', lookup_expr='code__iexact')\n        has_checkin = django_filters.rest_framework.BooleanFilter(method='has_checkin_qs')\n        attendee_name = django_filters.CharFilter(method='attendee_name_qs')\n        search = django_filters.CharFilter(method='search_qs')\n\n        def search_qs(self, queryset, name, value):\n            matching_media = ReusableMedium.objects.filter(identifier=value).values_list('linked_orderposition', flat=True)\n            return queryset.filter(\n                Q(secret__istartswith=value)\n                | Q(attendee_name_cached__icontains=value)\n                | Q(addon_to__attendee_name_cached__icontains=value)\n                | Q(attendee_email__icontains=value)\n                | Q(addon_to__attendee_email__icontains=value)\n                | Q(order__code__istartswith=value)\n                | Q(order__invoice_address__name_cached__icontains=value)\n                | Q(order__invoice_address__company__icontains=value)\n                | Q(order__email__icontains=value)\n                | Q(pk__in=matching_media)\n            )\n\n        def has_checkin_qs(self, queryset, name, value):\n            return queryset.alias(ce=Exists(Checkin.objects.filter(position=OuterRef('pk')))).filter(ce=value)\n\n        def attendee_name_qs(self, queryset, name, value):\n            return queryset.filter(Q(attendee_name_cached__iexact=value) | Q(addon_to__attendee_name_cached__iexact=value))\n\n        class Meta:\n            model = OrderPosition\n            fields = {\n                'item': ['exact', 'in'],\n                'variation': ['exact', 'in'],\n                'secret': ['exact'],\n                'order__status': ['exact', 'in'],\n                'addon_to': ['exact', 'in'],\n                'subevent': ['exact', 'in'],\n                'pseudonymization_id': ['exact'],\n                'voucher__code': ['exact'],\n                'voucher': ['exact'],\n            }\n\n\nclass OrderPositionViewSet(viewsets.ModelViewSet):\n    serializer_class = OrderPositionSerializer\n    queryset = OrderPosition.all.none()\n    filter_backends = (DjangoFilterBackend, RichOrderingFilter)\n    ordering = ('order__datetime', 'positionid')\n    ordering_fields = ('order__code', 'order__datetime', 'positionid', 'attendee_name', 'order__status',)\n    filterset_class = OrderPositionFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    ordering_custom = {\n        'attendee_name': {\n            '_order': F('display_name').asc(nulls_first=True),\n            'display_name': Coalesce('attendee_name_cached', 'addon_to__attendee_name_cached')\n        },\n        '-attendee_name': {\n            '_order': F('display_name').asc(nulls_last=True),\n            'display_name': Coalesce('attendee_name_cached', 'addon_to__attendee_name_cached')\n        },\n    }\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['event'] = self.request.event\n        ctx['pdf_data'] = self.request.query_params.get('pdf_data', 'false') == 'true'\n        return ctx\n\n    def get_queryset(self):\n        if self.request.query_params.get('include_canceled_positions', 'false') == 'true':\n            qs = OrderPosition.all\n        else:\n            qs = OrderPosition.objects\n\n        qs = qs.filter(order__event=self.request.event)\n        if self.request.query_params.get('pdf_data', 'false') == 'true':\n            prefetch_related_objects([self.request.organizer], 'meta_properties')\n            prefetch_related_objects(\n                [self.request.event],\n                Prefetch('meta_values', queryset=EventMetaValue.objects.select_related('property'), to_attr='meta_values_cached'),\n                'questions',\n                'item_meta_properties',\n            )\n            qs = qs.prefetch_related(\n                Prefetch('checkins', queryset=Checkin.objects.all()),\n                Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                    Prefetch('meta_values', ItemMetaValue.objects.select_related('property'),\n                             to_attr='meta_values_cached')\n                )),\n                'variation',\n                'answers', 'answers__options', 'answers__question',\n                'item__category',\n                'addon_to__answers', 'addon_to__answers__options', 'addon_to__answers__question',\n                Prefetch('addons', qs.select_related('item', 'variation')),\n                Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                    Prefetch('meta_values', to_attr='meta_values_cached',\n                             queryset=SubEventMetaValue.objects.select_related('property'))\n                )),\n                'linked_media',\n                Prefetch('order', self.request.event.orders.select_related('invoice_address').prefetch_related(\n                    Prefetch(\n                        'positions',\n                        qs.prefetch_related(\n                            Prefetch('checkins', queryset=Checkin.objects.all()),\n                            Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                                Prefetch('meta_values', ItemMetaValue.objects.select_related('property'),\n                                         to_attr='meta_values_cached')\n                            )),\n                            Prefetch('variation', queryset=self.request.event.items.prefetch_related(\n                                Prefetch('meta_values', ItemVariationMetaValue.objects.select_related('property'),\n                                         to_attr='meta_values_cached')\n                            )),\n                            'answers', 'answers__options', 'answers__question',\n                            'item__category',\n                            Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                                Prefetch('meta_values', to_attr='meta_values_cached',\n                                         queryset=SubEventMetaValue.objects.select_related('property'))\n                            )),\n                            Prefetch('addons', qs.select_related('item', 'variation', 'seat'))\n                        ).select_related('addon_to', 'seat', 'addon_to__seat')\n                    )\n                ))\n            ).select_related(\n                'addon_to', 'seat', 'addon_to__seat'\n            )\n        else:\n            qs = qs.prefetch_related(\n                Prefetch('checkins', queryset=Checkin.objects.all()),\n                'answers', 'answers__options', 'answers__question',\n            ).select_related(\n                'item', 'order', 'order__event', 'order__event__organizer', 'seat'\n            )\n        return qs\n\n    def _get_output_provider(self, identifier):\n        responses = register_ticket_outputs.send(self.request.event)\n        for receiver, response in responses:\n            prov = response(self.request.event)\n            if prov.identifier == identifier:\n                return prov\n        raise NotFound('Unknown output provider.')\n\n    @action(detail=True, methods=['POST'], url_name='price_calc')\n    def price_calc(self, request, *args, **kwargs):\n        \"\"\"\n        This calculates the price assuming a change of product or subevent. This endpoint\n        is deliberately not documented and considered a private API, only to be used by\n        pretix' web interface.\n\n        Sample input:\n\n        {\n            \"item\": 2,\n            \"variation\": null,\n            \"subevent\": 3,\n            \"tax_rule\": 4,\n        }\n\n        Sample output:\n\n        {\n            \"gross\": \"2.34\",\n            \"gross_formatted\": \"2,34\",\n            \"net\": \"2.34\",\n            \"tax\": \"0.00\",\n            \"rate\": \"0.00\",\n            \"name\": \"VAT\"\n        }\n        \"\"\"\n        serializer = PriceCalcSerializer(data=request.data, event=request.event)\n        serializer.is_valid(raise_exception=True)\n        data = serializer.validated_data\n        pos = self.get_object()\n\n        try:\n            ia = pos.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = InvoiceAddress()\n\n        kwargs = {\n            'item': pos.item,\n            'variation': pos.variation,\n            'voucher': pos.voucher,\n            'subevent': pos.subevent,\n            'addon_to': pos.addon_to,\n            'invoice_address': ia,\n        }\n\n        if data.get('item'):\n            item = data.get('item')\n            kwargs['item'] = item\n\n            if item.has_variations:\n                variation = data.get('variation') or pos.variation\n                if not variation:\n                    raise ValidationError('No variation given')\n                if variation.item != item:\n                    raise ValidationError('Variation does not belong to item')\n                kwargs['variation'] = variation\n            else:\n                variation = None\n                kwargs['variation'] = None\n\n            if pos.voucher and not pos.voucher.applies_to(item, variation):\n                kwargs['voucher'] = None\n\n        if data.get('subevent'):\n            kwargs['subevent'] = data.get('subevent')\n\n        if data.get('tax_rule'):\n            kwargs['tax_rule'] = data.get('tax_rule')\n\n        price = get_price(**kwargs)\n        tr = kwargs.get('tax_rule', kwargs.get('item').tax_rule)\n        with language(data.get('locale') or self.request.event.settings.locale, self.request.event.settings.region):\n            return Response({\n                'gross': price.gross,\n                'gross_formatted': money_filter(price.gross, self.request.event.currency, hide_currency=True),\n                'net': price.net,\n                'rate': price.rate,\n                'name': str(price.name),\n                'tax': price.tax,\n                'tax_rule': tr.pk if tr else None,\n            })\n\n    @action(detail=True, url_name='answer', url_path=r'answer/(?P<question>\\d+)')\n    def answer(self, request, **kwargs):\n        pos = self.get_object()\n        answer = get_object_or_404(\n            QuestionAnswer,\n            orderposition=self.get_object(),\n            question_id=kwargs.get('question')\n        )\n        if not answer.file:\n            raise NotFound()\n\n        ftype, ignored = mimetypes.guess_type(answer.file.name)\n        resp = FileResponse(answer.file, content_type=ftype or 'application/binary')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}\"'.format(\n            self.request.event.slug.upper(),\n            pos.order.code,\n            pos.positionid,\n            os.path.basename(answer.file.name).split('.', 1)[1]\n        )\n        return resp\n\n    @action(detail=True, url_name='pdf_image', url_path=r'pdf_image/(?P<key>[^/]+)')\n    def pdf_image(self, request, key, **kwargs):\n        pos = self.get_object()\n\n        image_vars = get_images(request.event)\n        if key not in image_vars:\n            raise NotFound('Unknown key')\n\n        image_file = image_vars[key]['evaluate'](pos, pos.order, pos.subevent or self.request.event)\n        if image_file is None:\n            raise NotFound('No image available')\n\n        if getattr(image_file, 'name', ''):\n            ftype, ignored = mimetypes.guess_type(image_file.name)\n            extension = os.path.basename(image_file.name).split('.')[-1]\n        else:\n            img = Image.open(image_file)\n            ftype = Image.MIME[img.format]\n            extensions = {\n                'GIF': 'gif', 'TIFF': 'tif', 'BMP': 'bmp', 'JPEG': 'jpg', 'PNG': 'png'\n            }\n            extension = extensions.get(img.format, 'bin')\n            if hasattr(image_file, 'seek'):\n                image_file.seek(0)\n\n        resp = FileResponse(image_file, content_type=ftype or 'application/binary')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}.{}\"'.format(\n            self.request.event.slug.upper(),\n            pos.order.code,\n            pos.positionid,\n            key,\n            extension,\n        )\n        return resp\n\n    @action(detail=True, url_name='download', url_path='download/(?P<output>[^/]+)')\n    def download(self, request, output, **kwargs):\n        provider = self._get_output_provider(output)\n        pos = self.get_object()\n\n        if pos.order.status in (Order.STATUS_CANCELED, Order.STATUS_EXPIRED):\n            raise PermissionDenied(\"Downloads are not available for canceled or expired orders.\")\n\n        if pos.order.status == Order.STATUS_PENDING and not (pos.order.valid_if_pending or request.event.settings.ticket_download_pending):\n            raise PermissionDenied(\"Downloads are not available for pending orders.\")\n        if not pos.generate_ticket:\n            raise PermissionDenied(\"Downloads are not enabled for this product.\")\n\n        ct = CachedTicket.objects.filter(\n            order_position=pos, provider=provider.identifier, file__isnull=False\n        ).last()\n        if not ct or not ct.file:\n            generate.apply_async(args=('orderposition', pos.pk, provider.identifier))\n            raise RetryException()\n        else:\n            if ct.type == 'text/uri-list':\n                resp = HttpResponse(ct.file.file.read(), content_type='text/uri-list')\n                return resp\n            else:\n                resp = FileResponse(ct.file.file, content_type=ct.type)\n                resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}{}\"'.format(\n                    self.request.event.slug.upper(), pos.order.code, pos.positionid,\n                    provider.identifier, ct.extension\n                )\n                return resp\n\n    @action(detail=True, methods=['POST'])\n    def regenerate_secrets(self, request, **kwargs):\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.regenerate_secret(instance)\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def add_block(self, request, **kwargs):\n        serializer = BlockNameSerializer(\n            data=request.data,\n            context=self.get_serializer_context(),\n        )\n        serializer.is_valid(raise_exception=True)\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.add_block(instance, serializer.validated_data['name'])\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def remove_block(self, request, **kwargs):\n        serializer = BlockNameSerializer(\n            data=request.data,\n            context=self.get_serializer_context(),\n        )\n        serializer.is_valid(raise_exception=True)\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.remove_block(instance, serializer.validated_data['name'])\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    def perform_destroy(self, instance):\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False\n            )\n            ocm.cancel(instance)\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n\n    def create(self, request, *args, **kwargs):\n        with transaction.atomic():\n            serializer = OrderPositionCreateForExistingOrderSerializer(\n                data=request.data,\n                context=self.get_serializer_context(),\n            )\n            serializer.is_valid(raise_exception=True)\n            order = serializer.validated_data['order']\n            ocm = OrderChangeManager(\n                order=order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            serializer.context['ocm'] = ocm\n            serializer.save()\n\n            # Fields that can be easily patched after the position was added\n            old_data = OrderPositionInfoPatchSerializer(instance=serializer.instance, context=self.get_serializer_context()).data\n            serializer = OrderPositionInfoPatchSerializer(\n                instance=serializer.instance,\n                context=self.get_serializer_context(),\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            new_data = serializer.data\n\n            if old_data != new_data:\n                log_data = self.request.data\n                if 'answers' in log_data:\n                    for a in new_data['answers']:\n                        log_data[f'question_{a[\"question\"]}'] = a[\"answer\"]\n                    log_data.pop('answers', None)\n                serializer.instance.order.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'data': [\n                            dict(\n                                position=serializer.instance.pk,\n                                **log_data\n                            )\n                        ]\n                    }\n                )\n                tickets.invalidate_cache.apply_async(\n                    kwargs={'event': serializer.instance.order.event.pk, 'order': serializer.instance.order.pk})\n                order_modified.send(sender=serializer.instance.order.event, order=serializer.instance.order)\n        return Response(\n            OrderPositionSerializer(serializer.instance, context=self.get_serializer_context()).data,\n            status=status.HTTP_201_CREATED,\n        )\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.get('partial', False)\n        if not partial:\n            return Response(\n                {\"detail\": \"Method \\\"PUT\\\" not allowed.\"},\n                status=status.HTTP_405_METHOD_NOT_ALLOWED,\n            )\n\n        with transaction.atomic():\n            instance = self.get_object()\n            ocm = OrderChangeManager(\n                order=instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n\n            # Field that need to go through OrderChangeManager\n            serializer = OrderPositionChangeSerializer(\n                instance=instance,\n                context={'ocm': ocm, **self.get_serializer_context()},\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n\n            # Fields that can be easily patched\n            old_data = OrderPositionInfoPatchSerializer(instance=instance, context=self.get_serializer_context()).data\n            serializer = OrderPositionInfoPatchSerializer(\n                instance=instance,\n                context=self.get_serializer_context(),\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            new_data = serializer.data\n\n            if old_data != new_data:\n                log_data = self.request.data\n                if 'answers' in log_data:\n                    for a in new_data['answers']:\n                        log_data[f'question_{a[\"question\"]}'] = a[\"answer\"]\n                    log_data.pop('answers', None)\n                serializer.instance.order.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'data': [\n                            dict(\n                                position=serializer.instance.pk,\n                                **log_data\n                            )\n                        ]\n                    }\n                )\n                tickets.invalidate_cache.apply_async(kwargs={'event': serializer.instance.order.event.pk, 'order': serializer.instance.order.pk})\n                order_modified.send(sender=serializer.instance.order.event, order=serializer.instance.order)\n\n        return Response(self.get_serializer_class()(instance=serializer.instance, context=self.get_serializer_context()).data)\n\n\nclass PaymentViewSet(CreateModelMixin, viewsets.ReadOnlyModelViewSet):\n    serializer_class = OrderPaymentSerializer\n    queryset = OrderPayment.objects.none()\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    lookup_field = 'local_id'\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['order'] = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        ctx['event'] = self.request.event\n        return ctx\n\n    def get_queryset(self):\n        order = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return order.payments.all()\n\n    def create(self, request, *args, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        serializer = OrderPaymentCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            mark_confirmed = False\n            if serializer.validated_data['state'] == OrderPayment.PAYMENT_STATE_CONFIRMED:\n                serializer.validated_data['state'] = OrderPayment.PAYMENT_STATE_PENDING\n                mark_confirmed = True\n            self.perform_create(serializer)\n            r = serializer.instance\n            if mark_confirmed:\n                try:\n                    r.confirm(\n                        user=self.request.user if self.request.user.is_authenticated else None,\n                        auth=self.request.auth,\n                        count_waitinglist=False,\n                        force=request.data.get('force', False),\n                        send_mail=send_mail,\n                    )\n                except Quota.QuotaExceededException:\n                    pass\n                except SendMailException:\n                    pass\n\n            serializer = OrderPaymentSerializer(r, context=serializer.context)\n\n            r.order.log_action(\n                'pretix.event.order.payment.started', {\n                    'local_id': r.local_id,\n                    'provider': r.provider,\n                },\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth\n            )\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    @action(detail=True, methods=['POST'])\n    def confirm(self, request, **kwargs):\n        payment = self.get_object()\n        force = request.data.get('force', False)\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        if payment.state not in (OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED):\n            return Response({'detail': 'Invalid state of payment'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            payment.confirm(user=self.request.user if self.request.user.is_authenticated else None,\n                            auth=self.request.auth,\n                            count_waitinglist=False,\n                            send_mail=send_mail,\n                            force=force)\n        except Quota.QuotaExceededException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except PaymentException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except SendMailException:\n            pass\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def refund(self, request, **kwargs):\n        payment = self.get_object()\n        amount = serializers.DecimalField(max_digits=13, decimal_places=2).to_internal_value(\n            request.data.get('amount', str(payment.amount))\n        )\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.get('mark_refunded', False)\n        else:\n            mark_refunded = request.data.get('mark_canceled', False)\n\n        if payment.state != OrderPayment.PAYMENT_STATE_CONFIRMED:\n            return Response({'detail': 'Invalid state of payment.'}, status=status.HTTP_400_BAD_REQUEST)\n\n        full_refund_possible = payment.payment_provider.payment_refund_supported(payment)\n        partial_refund_possible = payment.payment_provider.payment_partial_refund_supported(payment)\n        available_amount = payment.amount - payment.refunded_amount\n\n        if amount <= 0:\n            return Response({'amount': ['Invalid refund amount.']}, status=status.HTTP_400_BAD_REQUEST)\n        if amount > available_amount:\n            return Response(\n                {'amount': ['Invalid refund amount, only {} are available to refund.'.format(available_amount)]},\n                status=status.HTTP_400_BAD_REQUEST)\n        if amount != payment.amount and not partial_refund_possible:\n            return Response({'amount': ['Partial refund not available for this payment method.']},\n                            status=status.HTTP_400_BAD_REQUEST)\n        if amount == payment.amount and not full_refund_possible:\n            return Response({'amount': ['Full refund not available for this payment method.']},\n                            status=status.HTTP_400_BAD_REQUEST)\n        r = payment.order.refunds.create(\n            payment=payment,\n            source=OrderRefund.REFUND_SOURCE_ADMIN,\n            state=OrderRefund.REFUND_STATE_CREATED,\n            amount=amount,\n            provider=payment.provider,\n            info='{}',\n        )\n        payment.order.log_action('pretix.event.order.refund.created', {\n            'local_id': r.local_id,\n            'provider': r.provider,\n        }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n\n        try:\n            r.payment_provider.execute_refund(r)\n        except PaymentException as e:\n            r.state = OrderRefund.REFUND_STATE_FAILED\n            r.save()\n            payment.order.log_action('pretix.event.order.refund.failed', {\n                'local_id': r.local_id,\n                'provider': r.provider,\n                'error': str(e)\n            })\n            return Response({'detail': 'External error: {}'.format(str(e))},\n                            status=status.HTTP_400_BAD_REQUEST)\n        else:\n            if payment.order.pending_sum > 0:\n                if mark_refunded:\n                    mark_order_refunded(payment.order,\n                                        user=self.request.user if self.request.user.is_authenticated else None,\n                                        auth=self.request.auth)\n                else:\n                    payment.order.status = Order.STATUS_PENDING\n                    payment.order.set_expires(\n                        now(),\n                        payment.order.event.subevents.filter(\n                            id__in=payment.order.positions.values_list('subevent_id', flat=True))\n                    )\n                    payment.order.save(update_fields=['status', 'expires'])\n            return Response(OrderRefundSerializer(r).data, status=status.HTTP_200_OK)\n\n    @action(detail=True, methods=['POST'])\n    def cancel(self, request, **kwargs):\n        payment = self.get_object()\n\n        if payment.state not in (OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED):\n            return Response({'detail': 'Invalid state of payment'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            with transaction.atomic():\n                payment.payment_provider.cancel_payment(payment)\n                payment.order.log_action('pretix.event.order.payment.canceled', {\n                    'local_id': payment.local_id,\n                    'provider': payment.provider,\n                }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        except PaymentException as e:\n            return Response({'detail': 'External error: {}'.format(str(e))},\n                            status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n\nclass RefundViewSet(CreateModelMixin, viewsets.ReadOnlyModelViewSet):\n    serializer_class = OrderRefundSerializer\n    queryset = OrderRefund.objects.none()\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    lookup_field = 'local_id'\n\n    def get_queryset(self):\n        order = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return order.refunds.all()\n\n    @action(detail=True, methods=['POST'])\n    def cancel(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state not in (OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT,\n                                OrderRefund.REFUND_STATE_EXTERNAL):\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        with transaction.atomic():\n            refund.state = OrderRefund.REFUND_STATE_CANCELED\n            refund.save()\n            refund.order.log_action('pretix.event.order.refund.canceled', {\n                'local_id': refund.local_id,\n                'provider': refund.provider,\n            }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def process(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state != OrderRefund.REFUND_STATE_EXTERNAL:\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        refund.done(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.get('mark_refunded', False)\n        else:\n            mark_refunded = request.data.get('mark_canceled', False)\n        if mark_refunded:\n            mark_order_refunded(refund.order, user=self.request.user if self.request.user.is_authenticated else None,\n                                auth=self.request.auth)\n        elif not (refund.order.status == Order.STATUS_PAID and refund.order.pending_sum <= 0):\n            refund.order.status = Order.STATUS_PENDING\n            refund.order.set_expires(\n                now(),\n                refund.order.event.subevents.filter(\n                    id__in=refund.order.positions.values_list('subevent_id', flat=True))\n            )\n            refund.order.save(update_fields=['status', 'expires'])\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def done(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state not in (OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT):\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        refund.done(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        return self.retrieve(request, [], **kwargs)\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['order'] = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return ctx\n\n    def create(self, request, *args, **kwargs):\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.pop('mark_refunded', False)\n        else:\n            mark_refunded = request.data.pop('mark_canceled', False)\n        mark_pending = request.data.pop('mark_pending', False)\n        serializer = OrderRefundCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            self.perform_create(serializer)\n            r = serializer.instance\n            serializer = OrderRefundSerializer(r, context=serializer.context)\n\n            r.order.log_action(\n                'pretix.event.order.refund.created', {\n                    'local_id': r.local_id,\n                    'provider': r.provider,\n                },\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth\n            )\n\n            if r.state in (OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_CANCELED, OrderRefund.REFUND_STATE_FAILED):\n                r.order.log_action(\n                    f'pretix.event.order.refund.{r.state}', {\n                        'local_id': r.local_id,\n                        'provider': r.provider,\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth\n                )\n\n            if mark_refunded:\n                try:\n                    mark_order_refunded(\n                        r.order,\n                        user=request.user if request.user.is_authenticated else None,\n                        auth=(request.auth if request.auth else None),\n                    )\n                except OrderError as e:\n                    raise ValidationError(str(e))\n            elif mark_pending:\n                if r.order.status == Order.STATUS_PAID and r.order.pending_sum > 0:\n                    r.order.status = Order.STATUS_PENDING\n                    r.order.set_expires(\n                        now(),\n                        r.order.event.subevents.filter(\n                            id__in=r.order.positions.values_list('subevent_id', flat=True))\n                    )\n                    r.order.save(update_fields=['status', 'expires'])\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n\nwith scopes_disabled():\n    class InvoiceFilter(FilterSet):\n        refers = django_filters.CharFilter(method='refers_qs')\n        number = django_filters.CharFilter(method='nr_qs')\n        order = django_filters.CharFilter(field_name='order', lookup_expr='code__iexact')\n\n        def refers_qs(self, queryset, name, value):\n            return queryset.annotate(\n                refers_nr=Concat('refers__prefix', 'refers__invoice_no')\n            ).filter(refers_nr__iexact=value)\n\n        def nr_qs(self, queryset, name, value):\n            return queryset.filter(nr__iexact=value)\n\n        class Meta:\n            model = Invoice\n            fields = ['order', 'number', 'is_cancellation', 'refers', 'locale']\n\n\nclass RetryException(APIException):\n    status_code = 409\n    default_detail = 'The requested resource is not ready, please retry later.'\n    default_code = 'retry_later'\n\n\nclass InvoiceViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = InvoiceSerializer\n    queryset = Invoice.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('nr',)\n    ordering_fields = ('nr', 'date')\n    filterset_class = InvoiceFilter\n    permission = 'can_view_orders'\n    lookup_url_kwarg = 'number'\n    lookup_field = 'nr'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return self.request.event.invoices.prefetch_related('lines').select_related('order', 'refers').annotate(\n            nr=Concat('prefix', 'invoice_no')\n        )\n\n    @action(detail=True, )\n    def download(self, request, **kwargs):\n        invoice = self.get_object()\n\n        if not invoice.file:\n            invoice_pdf(invoice.pk)\n            invoice.refresh_from_db()\n\n        if invoice.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n\n        if not invoice.file:\n            raise RetryException()\n\n        resp = FileResponse(invoice.file.file, content_type='application/pdf')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}.pdf\"'.format(invoice.number)\n        return resp\n\n    @action(detail=True, methods=['POST'])\n    def regenerate(self, request, **kwarts):\n        inv = self.get_object()\n        if inv.canceled:\n            raise ValidationError('The invoice has already been canceled.')\n        if not inv.event.settings.invoice_regenerate_allowed:\n            raise PermissionDenied('Invoices may not be changed after they are created.')\n        elif inv.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n        elif inv.sent_to_organizer:\n            raise PermissionDenied('The invoice file has already been exported.')\n        elif now().astimezone(self.request.event.timezone).date() - inv.date > datetime.timedelta(days=1):\n            raise PermissionDenied('The invoice file is too old to be regenerated.')\n        else:\n            inv = regenerate_invoice(inv)\n            inv.order.log_action(\n                'pretix.event.order.invoice.regenerated',\n                data={\n                    'invoice': inv.pk\n                },\n                user=self.request.user,\n                auth=self.request.auth,\n            )\n            return Response(status=204)\n\n    @action(detail=True, methods=['POST'])\n    def reissue(self, request, **kwarts):\n        inv = self.get_object()\n        if inv.canceled:\n            raise ValidationError('The invoice has already been canceled.')\n        elif inv.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n        else:\n            c = generate_cancellation(inv)\n            if inv.order.status != Order.STATUS_CANCELED:\n                inv = generate_invoice(inv.order)\n            else:\n                inv = c\n            inv.order.log_action(\n                'pretix.event.order.invoice.reissued',\n                data={\n                    'invoice': inv.pk\n                },\n                user=self.request.user,\n                auth=self.request.auth,\n            )\n            return Response(status=204)\n\n\nwith scopes_disabled():\n    class RevokedSecretFilter(FilterSet):\n        created_since = django_filters.IsoDateTimeFilter(field_name='created', lookup_expr='gte')\n\n        class Meta:\n            model = RevokedTicketSecret\n            fields = []\n\n\nclass RevokedSecretViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = RevokedTicketSecretSerializer\n    queryset = RevokedTicketSecret.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('-created',)\n    ordering_fields = ('created', 'secret')\n    filterset_class = RevokedSecretFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return RevokedTicketSecret.objects.filter(event=self.request.event)\n\n\nwith scopes_disabled():\n    class BlockedSecretFilter(FilterSet):\n        updated_since = django_filters.IsoDateTimeFilter(field_name='updated', lookup_expr='gte')\n\n        class Meta:\n            model = BlockedTicketSecret\n            fields = ['blocked']\n\n\nclass BlockedSecretViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = BlockedTicketSecretSerializer\n    queryset = BlockedTicketSecret.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('-updated', '-pk')\n    filterset_class = BlockedSecretFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return BlockedTicketSecret.objects.filter(event=self.request.event)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Andreas Teuber, Flavia Bastos\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport json\nimport logging\nfrom datetime import timedelta\nfrom decimal import Decimal\nfrom io import BytesIO\nfrom zoneinfo import ZoneInfo\n\nimport dateutil.parser\nimport pycountry\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.gis.geoip2 import GeoIP2\nfrom django.core.exceptions import ValidationError\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.core.validators import (\n    MaxValueValidator, MinValueValidator, RegexValidator,\n)\nfrom django.db.models import QuerySet\nfrom django.forms import Select, widgets\nfrom django.forms.widgets import FILE_INPUT_CONTRADICTION\nfrom django.utils.formats import date_format\nfrom django.utils.html import escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import get_current_timezone, now\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_countries import countries\nfrom django_countries.fields import Country, CountryField\nfrom geoip2.errors import AddressNotFoundError\nfrom phonenumber_field.formfields import PhoneNumberField\nfrom phonenumber_field.phonenumber import PhoneNumber\nfrom phonenumber_field.widgets import PhoneNumberPrefixWidget\nfrom phonenumbers import NumberParseException, national_significant_number\nfrom phonenumbers.data import _COUNTRY_CODE_TO_REGION_CODE\nfrom PIL import ImageOps\n\nfrom pretix.base.forms.widgets import (\n    BusinessBooleanRadio, DatePickerWidget, SplitDateTimePickerWidget,\n    TimePickerWidget, UploadedFileWidget,\n)\nfrom pretix.base.i18n import (\n    get_babel_locale, get_language_without_region, language,\n)\nfrom pretix.base.models import InvoiceAddress, Item, Question, QuestionOption\nfrom pretix.base.models.tax import VAT_ID_COUNTRIES, ask_for_vat_id\nfrom pretix.base.services.tax import (\n    VATIDFinalError, VATIDTemporaryError, validate_vat_id,\n)\nfrom pretix.base.settings import (\n    COUNTRIES_WITH_STATE_IN_ADDRESS, PERSON_NAME_SALUTATIONS,\n    PERSON_NAME_SCHEMES, PERSON_NAME_TITLE_GROUPS,\n)\nfrom pretix.base.templatetags.rich_text import rich_text\nfrom pretix.control.forms import (\n    ExtFileField, ExtValidationMixin, SizeValidationMixin, SplitDateTimeField,\n)\nfrom pretix.helpers.countries import (\n    CachedCountries, get_phone_prefixes_sorted_and_localized,\n)\nfrom pretix.helpers.escapejson import escapejson_attr\nfrom pretix.helpers.http import get_client_ip\nfrom pretix.helpers.i18n import get_format_without_seconds\nfrom pretix.presale.signals import question_form_fields\n\nlogger = logging.getLogger(__name__)\n\n\nREQUIRED_NAME_PARTS = ['salutation', 'given_name', 'family_name', 'full_name']\n\n\nclass NamePartsWidget(forms.MultiWidget):\n    widget = forms.TextInput\n    autofill_map = {\n        'given_name': 'given-name',\n        'family_name': 'family-name',\n        'middle_name': 'additional-name',\n        'title': 'honorific-prefix',\n        'full_name': 'name',\n        'calling_name': 'nickname',\n    }\n\n    def __init__(self, scheme: dict, field: forms.Field, attrs=None, titles: list=None):\n        widgets = []\n        self.scheme = scheme\n        self.field = field\n        self.titles = titles\n        for fname, label, size in self.scheme['fields']:\n            a = copy.copy(attrs) or {}\n            a['data-fname'] = fname\n            if fname == 'title' and self.titles:\n                widgets.append(Select(attrs=a, choices=[('', '')] + [(d, d) for d in self.titles[1]]))\n            elif fname == 'salutation':\n                widgets.append(Select(attrs=a, choices=[('', '---')] + PERSON_NAME_SALUTATIONS))\n            else:\n                widgets.append(self.widget(attrs=a))\n        super().__init__(widgets, attrs)\n\n    def decompress(self, value):\n        if value is None:\n            return None\n        data = []\n        for i, field in enumerate(self.scheme['fields']):\n            fname, label, size = field\n            data.append(value.get(fname, \"\"))\n        if '_legacy' in value and not data[-1]:\n            data[-1] = value.get('_legacy', '')\n        elif not any(d for d in data) and '_scheme' in value:\n            scheme = PERSON_NAME_SCHEMES[value['_scheme']]\n            data[-1] = scheme['concatenation'](value).strip()\n\n        return data\n\n    def render(self, name: str, value, attrs=None, renderer=None) -> str:\n        if not isinstance(value, list):\n            value = self.decompress(value)\n        output = []\n        final_attrs = self.build_attrs(attrs or {})\n        if 'required' in final_attrs:\n            del final_attrs['required']\n        id_ = final_attrs.get('id', None)\n        for i, widget in enumerate(self.widgets):\n            try:\n                widget_value = value[i]\n            except (IndexError, TypeError):\n                widget_value = None\n            if id_:\n                these_attrs = dict(\n                    final_attrs,\n                    id='%s_%s' % (id_, i),\n                    title=self.scheme['fields'][i][1],\n                )\n                if not isinstance(widget, widgets.Select):\n                    these_attrs['placeholder'] = self.scheme['fields'][i][1]\n                if self.scheme['fields'][i][0] in REQUIRED_NAME_PARTS:\n                    if self.field.required:\n                        these_attrs['required'] = 'required'\n                    these_attrs.pop('data-no-required-attr', None)\n                these_attrs['autocomplete'] = (self.attrs.get('autocomplete', '') + ' ' + self.autofill_map.get(self.scheme['fields'][i][0], 'off')).strip()\n                these_attrs['data-size'] = self.scheme['fields'][i][2]\n                if len(self.widgets) > 1:\n                    these_attrs['aria-label'] = self.scheme['fields'][i][1]\n            else:\n                these_attrs = final_attrs\n            output.append(widget.render(name + '_%s' % i, widget_value, these_attrs, renderer=renderer))\n        return mark_safe(self.format_output(output))\n\n    def format_output(self, rendered_widgets) -> str:\n        return '<div class=\"nameparts-form-group\">%s</div>' % ''.join(rendered_widgets)\n\n\nclass NamePartsFormField(forms.MultiValueField):\n    widget = NamePartsWidget\n\n    def compress(self, data_list) -> dict:\n        data = {}\n        data['_scheme'] = self.scheme_name\n        for i, value in enumerate(data_list):\n            data[self.scheme['fields'][i][0]] = value or ''\n        return data\n\n    def __init__(self, *args, **kwargs):\n        fields = []\n        defaults = {\n            'widget': self.widget,\n            'max_length': kwargs.pop('max_length', None),\n            'validators': [\n                RegexValidator(\n                    # The following characters should never appear in a name anywhere of\n                    # the world. However, they commonly appear in inputs generated by spam\n                    # bots.\n                    r'^[^$\u20ac/%\u00a7{}<>~]*$',\n                    message=_('Please do not use special characters in names.')\n                )\n            ]\n        }\n        self.scheme_name = kwargs.pop('scheme')\n        self.titles = kwargs.pop('titles')\n        self.scheme = PERSON_NAME_SCHEMES.get(self.scheme_name)\n        if self.titles:\n            self.scheme_titles = PERSON_NAME_TITLE_GROUPS.get(self.titles)\n        else:\n            self.scheme_titles = None\n        self.one_required = kwargs.get('required', True)\n        require_all_fields = kwargs.pop('require_all_fields', False)\n        kwargs['required'] = False\n        kwargs['widget'] = (kwargs.get('widget') or self.widget)(\n            scheme=self.scheme, titles=self.scheme_titles, field=self, **kwargs.pop('widget_kwargs', {})\n        )\n        defaults.update(**kwargs)\n        for fname, label, size in self.scheme['fields']:\n            defaults['label'] = label\n            if fname == 'title' and self.scheme_titles:\n                d = dict(defaults)\n                d.pop('max_length', None)\n                d.pop('validators', None)\n                field = forms.ChoiceField(\n                    **d,\n                    choices=[('', '')] + [(d, d) for d in self.scheme_titles[1]]\n                )\n\n            elif fname == 'salutation':\n                d = dict(defaults)\n                d.pop('max_length', None)\n                d.pop('validators', None)\n                field = forms.ChoiceField(\n                    **d,\n                    choices=[('', '---')] + PERSON_NAME_SALUTATIONS\n                )\n            else:\n                field = forms.CharField(**defaults)\n            field.part_name = fname\n            fields.append(field)\n        super().__init__(\n            fields=fields, require_all_fields=False, *args, **kwargs\n        )\n        self.require_all_fields = require_all_fields\n        self.required = self.one_required\n\n    def clean(self, value) -> dict:\n        value = super().clean(value)\n        if self.one_required and (not value or not any(v for v in value.values())):\n            raise forms.ValidationError(self.error_messages['required'], code='required')\n        if self.one_required:\n            for k, label, size in self.scheme['fields']:\n                if k in REQUIRED_NAME_PARTS and not value.get(k):\n                    raise forms.ValidationError(self.error_messages['required'], code='required')\n        if self.require_all_fields and not all(v for v in value):\n            raise forms.ValidationError(self.error_messages['incomplete'], code='required')\n\n        if sum(len(v) for v in value.values() if v) > 250:\n            raise forms.ValidationError(_('Please enter a shorter name.'), code='max_length')\n\n        return value\n\n\nclass WrappedPhonePrefixSelect(Select):\n    initial = None\n\n    def __init__(self, initial=None):\n        choices = [(\"\", \"---------\")]\n\n        if initial:\n            for prefix, values in _COUNTRY_CODE_TO_REGION_CODE.items():\n                if initial in values:\n                    self.initial = \"+%d\" % prefix\n                    break\n        choices += get_phone_prefixes_sorted_and_localized()\n        super().__init__(choices=choices, attrs={'aria-label': pgettext_lazy('phonenumber', 'International area code')})\n\n    def render(self, name, value, *args, **kwargs):\n        return super().render(name, value or self.initial, *args, **kwargs)\n\n    def get_context(self, name, value, attrs):\n        if value and self.choices[1][0] != value:\n            matching_choices = len([1 for p, c in self.choices if p == value])\n            if matching_choices > 1:\n                # Some countries share a phone prefix, for example +1 is used all over the Americas.\n                # This causes a UX problem: If the default value or the existing data is +12125552368,\n                # the widget will just show the first <option> entry with value=\"+1\" as selected,\n                # which alphabetically is America Samoa, although most numbers statistically are from\n                # the US. As a workaround, we detect this case and add an aditional choice value with\n                # just <option value=\"+1\">+1</option> without an explicit country.\n                self.choices.insert(1, (value, value))\n        context = super().get_context(name, value, attrs)\n        return context\n\n\nclass WrappedPhoneNumberPrefixWidget(PhoneNumberPrefixWidget):\n\n    def __init__(self, attrs=None, initial=None):\n        attrs = {\n            'aria-label': pgettext_lazy('phonenumber', 'Phone number (without international area code)')\n        }\n        widgets = (WrappedPhonePrefixSelect(initial), forms.TextInput(attrs=attrs))\n        super(PhoneNumberPrefixWidget, self).__init__(widgets, attrs)\n\n    def render(self, name, value, attrs=None, renderer=None):\n        output = super().render(name, value, attrs, renderer)\n        return mark_safe(self.format_output(output))\n\n    def format_output(self, rendered_widgets) -> str:\n        return '<div class=\"nameparts-form-group\">%s</div>' % ''.join(rendered_widgets)\n\n    def decompress(self, value):\n        \"\"\"\n        If an incomplete phone number (e.g. without country prefix) is currently entered,\n        the default implementation just discards the value and shows nothing at all.\n        Let's rather show something invalid, so the user is prompted to fix it, instead of\n        silently deleting data.\n        \"\"\"\n        if value:\n            if isinstance(value, str):\n                try:\n                    value = PhoneNumber.from_string(value)\n                except:\n                    pass\n            if isinstance(value, PhoneNumber):\n                if value.country_code and value.national_number:\n                    return [\n                        \"+%d\" % value.country_code,\n                        national_significant_number(value),\n                    ]\n                return [\n                    None,\n                    str(value)\n                ]\n            elif \".\" in value:\n                return value.split(\".\")\n            else:\n                return [None, value]\n        return [None, \"\"]\n\n    def value_from_datadict(self, data, files, name):\n        # In contrast to defualt implementation, do not silently fail if a number without\n        # country prefix is entered\n        values = super(PhoneNumberPrefixWidget, self).value_from_datadict(data, files, name)\n        if values[1]:\n            return \"%s.%s\" % tuple(values)\n        return \"\"\n\n\ndef guess_country_from_request(request, event):\n    if settings.HAS_GEOIP:\n        g = GeoIP2()\n        try:\n            res = g.country(get_client_ip(request))\n            if res['country_code'] and len(res['country_code']) == 2:\n                return Country(res['country_code'])\n        except AddressNotFoundError:\n            pass\n    return guess_country(event)\n\n\ndef guess_country(event):\n    # Try to guess the initial country from either the country of the merchant\n    # or the locale. This will hopefully save at least some users some scrolling :)\n    country = event.settings.region or event.settings.invoice_address_from_country\n    if not country:\n        country = get_country_by_locale(get_language_without_region())\n    return country\n\n\ndef get_country_by_locale(locale):\n    country = None\n    valid_countries = countries.countries\n    if '-' in locale:\n        parts = locale.split('-')\n        # TODO: does this actually work?\n        if parts[1].upper() in valid_countries:\n            country = Country(parts[1].upper())\n        elif parts[0].upper() in valid_countries:\n            country = Country(parts[0].upper())\n    else:\n        if locale.upper() in valid_countries:\n            country = Country(locale.upper())\n    return country\n\n\ndef guess_phone_prefix(event):\n    with language(get_babel_locale()):\n        country = str(guess_country(event))\n        return get_phone_prefix(country)\n\n\ndef guess_phone_prefix_from_request(request, event):\n    with language(get_babel_locale()):\n        country = str(guess_country_from_request(request, event))\n        return get_phone_prefix(country)\n\n\ndef get_phone_prefix(country):\n    for prefix, values in _COUNTRY_CODE_TO_REGION_CODE.items():\n        if country in values:\n            return prefix\n    return None\n\n\nclass QuestionCheckboxSelectMultiple(forms.CheckboxSelectMultiple):\n    option_template_name = 'pretixbase/forms/widgets/checkbox_option_with_links.html'\n\n\nclass MinDateValidator(MinValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'], 'SHORT_DATE_FORMAT')\n            raise e\n\n\nclass MinDateTimeValidator(MinValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'].astimezone(get_current_timezone()), 'SHORT_DATETIME_FORMAT')\n            raise e\n\n\nclass MaxDateValidator(MaxValueValidator):\n\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'], 'SHORT_DATE_FORMAT')\n            raise e\n\n\nclass MaxDateTimeValidator(MaxValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'].astimezone(get_current_timezone()), 'SHORT_DATETIME_FORMAT')\n            raise e\n\n\nclass PortraitImageWidget(UploadedFileWidget):\n    template_name = 'pretixbase/forms/widgets/portrait_image.html'\n\n    def value_from_datadict(self, data, files, name):\n        d = super().value_from_datadict(data, files, name)\n        if d is not None and d is not False and d is not FILE_INPUT_CONTRADICTION:\n            d._cropdata = json.loads(data.get(name + '_cropdata', '{}') or '{}')\n        return d\n\n\nclass PortraitImageField(SizeValidationMixin, ExtValidationMixin, forms.FileField):\n    widget = PortraitImageWidget\n    default_error_messages = {\n        'aspect_ratio_landscape': _(\n            \"You uploaded an image in landscape orientation. Please upload an image in portrait orientation.\"\n        ),\n        'aspect_ratio_not_3_by_4': _(\n            \"Please upload an image where the width is 3/4 of the height.\"\n        ),\n        'max_dimension': _(\n            \"The file you uploaded has a very large number of pixels, please upload an image no larger than 10000 x 10000 pixels.\"\n        ),\n        'invalid_image': _(\n            \"Upload a valid image. The file you uploaded was either not an \"\n            \"image or a corrupted image.\"\n        ),\n    }\n\n    def to_python(self, data):\n        \"\"\"\n        Based on Django's ImageField\n        \"\"\"\n        f = super().to_python(data)\n        if f is None:\n            return None\n\n        from PIL import Image\n\n        # We need to get a file object for Pillow. We might have a path or we might\n        # have to read the data into memory.\n        if hasattr(data, 'temporary_file_path'):\n            file = data.temporary_file_path()\n        else:\n            if hasattr(data, 'read'):\n                file = BytesIO(data.read())\n            else:\n                file = BytesIO(data['content'])\n\n        try:\n            image = Image.open(file)\n            # verify() must be called immediately after the constructor.\n            image.verify()\n\n            # We want to do more than just verify(), so we need to re-open the file\n            if hasattr(file, 'seek'):\n                file.seek(0)\n            image = Image.open(file)\n\n            # load() is a potential DoS vector (see Django bug #18520), so we verify the size first\n            if image.width > 10_000 or image.height > 10_000:\n                raise ValidationError(\n                    self.error_messages['max_dimension'],\n                    code='max_dimension',\n                )\n\n            image.load()\n\n            # Annotating so subclasses can reuse it for their own validation\n            f.image = image\n            # Pillow doesn't detect the MIME type of all formats. In those\n            # cases, content_type will be None.\n            f.content_type = Image.MIME.get(image.format)\n\n            # before we calc aspect ratio, we need to check and apply EXIF-orientation\n            image = ImageOps.exif_transpose(image)\n\n            if f._cropdata:\n                image = image.crop((\n                    f._cropdata.get('x', 0),\n                    f._cropdata.get('y', 0),\n                    f._cropdata.get('x', 0) + f._cropdata.get('width', image.width),\n                    f._cropdata.get('y', 0) + f._cropdata.get('height', image.height),\n                ))\n                with BytesIO() as output:\n                    # This might use a lot of memory, but temporary files are not a good option since\n                    # we don't control the cleanup\n                    image.save(output, format=f.image.format)\n                    f = SimpleUploadedFile(f.name, output.getvalue(), f.content_type)\n                    f.image = image\n\n            if image.width > image.height:\n                raise ValidationError(\n                    self.error_messages['aspect_ratio_landscape'],\n                    code='aspect_ratio_landscape',\n                )\n\n            if not 3 / 4 * .95 < image.width / image.height < 3 / 4 * 1.05:  # give it some tolerance\n                raise ValidationError(\n                    self.error_messages['aspect_ratio_not_3_by_4'],\n                    code='aspect_ratio_not_3_by_4',\n                )\n        except Exception as exc:\n            logger.exception('Could not parse image')\n            # Pillow doesn't recognize it as an image.\n            if isinstance(exc, ValidationError):\n                raise\n            raise ValidationError(\n                self.error_messages['invalid_image'],\n                code='invalid_image',\n            ) from exc\n        if hasattr(f, 'seek') and callable(f.seek):\n            f.seek(0)\n        return f\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('ext_whitelist', (\".png\", \".jpg\", \".jpeg\", \".jfif\", \".tif\", \".tiff\", \".bmp\"))\n        kwargs.setdefault('max_size', settings.FILE_UPLOAD_MAX_SIZE_IMAGE)\n        super().__init__(*args, **kwargs)\n\n\nclass BaseQuestionsForm(forms.Form):\n    \"\"\"\n    This form class is responsible for asking order-related questions. This includes\n    the attendee name for admission tickets, if the corresponding setting is enabled,\n    as well as additional questions defined by the organizer.\n    \"\"\"\n    address_validation = False\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Takes two additional keyword arguments:\n\n        :param cartpos: The cart position the form should be for\n        :param event: The event this belongs to\n        \"\"\"\n        request = kwargs.pop('request', None)\n        cartpos = self.cartpos = kwargs.pop('cartpos', None)\n        orderpos = self.orderpos = kwargs.pop('orderpos', None)\n        pos = cartpos or orderpos\n        item = pos.item\n        questions = pos.item.questions_to_ask\n        event = kwargs.pop('event')\n        self.all_optional = kwargs.pop('all_optional', False)\n\n        super().__init__(*args, **kwargs)\n\n        if cartpos and item.validity_mode == Item.VALIDITY_MODE_DYNAMIC and item.validity_dynamic_start_choice:\n            if item.validity_dynamic_start_choice_day_limit:\n                max_date = now().astimezone(event.timezone) + timedelta(days=item.validity_dynamic_start_choice_day_limit)\n            else:\n                max_date = None\n            if item.validity_dynamic_duration_months or item.validity_dynamic_duration_days:\n                attrs = {}\n                if max_date:\n                    attrs['data-max'] = max_date.date().isoformat()\n                self.fields['requested_valid_from'] = forms.DateField(\n                    label=_('Start date'),\n                    help_text=_('If you keep this empty, the ticket will be valid starting at the time of purchase.'),\n                    required=False,\n                    widget=DatePickerWidget(attrs),\n                    validators=[MaxDateValidator(max_date.date())] if max_date else []\n                )\n            else:\n                self.fields['requested_valid_from'] = forms.SplitDateTimeField(\n                    label=_('Start date'),\n                    help_text=_('If you keep this empty, the ticket will be valid starting at the time of purchase.'),\n                    required=False,\n                    widget=SplitDateTimePickerWidget(\n                        time_format=get_format_without_seconds('TIME_INPUT_FORMATS'),\n                        max_date=max_date\n                    ),\n                    validators=[MaxDateTimeValidator(max_date)] if max_date else []\n                )\n\n        add_fields = {}\n\n        if item.ask_attendee_data and event.settings.attendee_names_asked:\n            add_fields['attendee_name_parts'] = NamePartsFormField(\n                max_length=255,\n                required=event.settings.attendee_names_required and not self.all_optional,\n                scheme=event.settings.name_scheme,\n                titles=event.settings.name_scheme_titles,\n                label=_('Attendee name'),\n                initial=(cartpos.attendee_name_parts if cartpos else orderpos.attendee_name_parts),\n            )\n        if item.ask_attendee_data and event.settings.attendee_emails_asked:\n            add_fields['attendee_email'] = forms.EmailField(\n                required=event.settings.attendee_emails_required and not self.all_optional,\n                label=_('Attendee email'),\n                initial=(cartpos.attendee_email if cartpos else orderpos.attendee_email),\n                widget=forms.EmailInput(\n                    attrs={\n                        'autocomplete': 'email'\n                    }\n                )\n            )\n        if item.ask_attendee_data and event.settings.attendee_company_asked:\n            add_fields['company'] = forms.CharField(\n                required=event.settings.attendee_company_required and not self.all_optional,\n                label=_('Company'),\n                max_length=255,\n                initial=(cartpos.company if cartpos else orderpos.company),\n            )\n\n        if item.ask_attendee_data and event.settings.attendee_addresses_asked:\n            add_fields['street'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('Address'),\n                widget=forms.Textarea(attrs={\n                    'rows': 2,\n                    'placeholder': _('Street and Number'),\n                    'autocomplete': 'street-address'\n                }),\n                initial=(cartpos.street if cartpos else orderpos.street),\n            )\n            add_fields['zipcode'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                max_length=30,\n                label=_('ZIP code'),\n                initial=(cartpos.zipcode if cartpos else orderpos.zipcode),\n                widget=forms.TextInput(attrs={\n                    'autocomplete': 'postal-code',\n                }),\n            )\n            add_fields['city'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('City'),\n                max_length=255,\n                initial=(cartpos.city if cartpos else orderpos.city),\n                widget=forms.TextInput(attrs={\n                    'autocomplete': 'address-level2',\n                }),\n            )\n            country = (cartpos.country if cartpos else orderpos.country) or guess_country_from_request(request, event)\n            add_fields['country'] = CountryField(\n                countries=CachedCountries\n            ).formfield(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('Country'),\n                initial=country,\n                widget=forms.Select(attrs={\n                    'autocomplete': 'country',\n                }),\n            )\n            c = [('', pgettext_lazy('address', 'Select state'))]\n            fprefix = str(self.prefix) + '-' if self.prefix is not None and self.prefix != '-' else ''\n            cc = None\n            state = None\n            if fprefix + 'country' in self.data:\n                cc = str(self.data[fprefix + 'country'])\n            elif country:\n                cc = str(country)\n            if cc and cc in COUNTRIES_WITH_STATE_IN_ADDRESS:\n                types, form = COUNTRIES_WITH_STATE_IN_ADDRESS[cc]\n                statelist = [s for s in pycountry.subdivisions.get(country_code=cc) if s.type in types]\n                c += sorted([(s.code[3:], s.name) for s in statelist], key=lambda s: s[1])\n                state = (cartpos.state if cartpos else orderpos.state)\n            elif fprefix + 'state' in self.data:\n                self.data = self.data.copy()\n                del self.data[fprefix + 'state']\n\n            add_fields['state'] = forms.ChoiceField(\n                label=pgettext_lazy('address', 'State'),\n                required=False,\n                choices=c,\n                initial=state,\n                widget=forms.Select(attrs={\n                    'autocomplete': 'address-level1',\n                }),\n            )\n            add_fields['state'].widget.is_required = True\n\n        field_positions = list(\n            [\n                (n, event.settings.system_question_order.get(n if n != 'state' else 'country', 0))\n                for n in add_fields.keys()\n            ]\n        )\n\n        for q in questions:\n            # Do we already have an answer? Provide it as the initial value\n            answers = [a for a in pos.answerlist if a.question_id == q.id]\n            if answers:\n                initial = answers[0]\n            else:\n                initial = None\n            tz = ZoneInfo(event.settings.timezone)\n            help_text = rich_text(q.help_text)\n            label = escape(q.question)  # django-bootstrap3 calls mark_safe\n            required = q.required and not self.all_optional\n            if q.type == Question.TYPE_BOOLEAN:\n                if required:\n                    # For some reason, django-bootstrap3 does not set the required attribute\n                    # itself.\n                    widget = forms.CheckboxInput(attrs={'required': 'required'})\n                else:\n                    widget = forms.CheckboxInput()\n\n                if initial:\n                    initialbool = (initial.answer == \"True\")\n                else:\n                    initialbool = False\n\n                field = forms.BooleanField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=initialbool, widget=widget,\n                )\n            elif q.type == Question.TYPE_NUMBER:\n                field = forms.DecimalField(\n                    label=label, required=required,\n                    min_value=q.valid_number_min or Decimal('0.00'),\n                    max_value=q.valid_number_max,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_STRING:\n                field = forms.CharField(\n                    label=label, required=required,\n                    max_length=q.valid_string_length_max,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_TEXT:\n                field = forms.CharField(\n                    label=label, required=required,\n                    max_length=q.valid_string_length_max,\n                    help_text=help_text,\n                    widget=forms.Textarea,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_COUNTRYCODE:\n                field = CountryField(\n                    countries=CachedCountries,\n                    blank=True, null=True, blank_label=' ',\n                ).formfield(\n                    label=label, required=required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    empty_label=' ',\n                    initial=initial.answer if initial else (guess_country_from_request(request, event) if required else None),\n                )\n            elif q.type == Question.TYPE_CHOICE:\n                field = forms.ModelChoiceField(\n                    queryset=q.options,\n                    label=label, required=required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    to_field_name='identifier',\n                    empty_label='',\n                    initial=initial.options.first() if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE_MULTIPLE:\n                field = forms.ModelMultipleChoiceField(\n                    queryset=q.options,\n                    label=label, required=required,\n                    help_text=help_text,\n                    to_field_name='identifier',\n                    widget=QuestionCheckboxSelectMultiple,\n                    initial=initial.options.all() if initial else None,\n                )\n            elif q.type == Question.TYPE_FILE:\n                if q.valid_file_portrait:\n                    field = PortraitImageField(\n                        label=label, required=required,\n                        help_text=help_text,\n                        initial=initial.file if initial else None,\n                        widget=PortraitImageWidget(position=pos, event=event, answer=initial, attrs={'data-portrait-photo': 'true'}),\n                    )\n                else:\n                    field = ExtFileField(\n                        label=label, required=required,\n                        help_text=help_text,\n                        initial=initial.file if initial else None,\n                        widget=UploadedFileWidget(position=pos, event=event, answer=initial),\n                        ext_whitelist=(\n                            \".png\", \".jpg\", \".gif\", \".jpeg\", \".pdf\", \".txt\", \".docx\", \".gif\", \".svg\",\n                            \".pptx\", \".ppt\", \".doc\", \".xlsx\", \".xls\", \".jfif\", \".heic\", \".heif\", \".pages\",\n                            \".bmp\", \".tif\", \".tiff\"\n                        ),\n                        max_size=settings.FILE_UPLOAD_MAX_SIZE_OTHER,\n                    )\n            elif q.type == Question.TYPE_DATE:\n                attrs = {}\n                if q.valid_date_min:\n                    attrs['data-min'] = q.valid_date_min.isoformat()\n                if q.valid_date_max:\n                    attrs['data-max'] = q.valid_date_max.isoformat()\n                field = forms.DateField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).date() if initial and initial.answer else None,\n                    widget=DatePickerWidget(attrs),\n                )\n                if q.valid_date_min:\n                    field.validators.append(MinDateValidator(q.valid_date_min))\n                if q.valid_date_max:\n                    field.validators.append(MaxDateValidator(q.valid_date_max))\n            elif q.type == Question.TYPE_TIME:\n                field = forms.TimeField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).time() if initial and initial.answer else None,\n                    widget=TimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            elif q.type == Question.TYPE_DATETIME:\n                field = SplitDateTimeField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).astimezone(tz) if initial and initial.answer else None,\n                    widget=SplitDateTimePickerWidget(\n                        time_format=get_format_without_seconds('TIME_INPUT_FORMATS'),\n                        min_date=q.valid_datetime_min,\n                        max_date=q.valid_datetime_max\n                    ),\n                )\n                if q.valid_datetime_min:\n                    field.validators.append(MinDateTimeValidator(q.valid_datetime_min))\n                if q.valid_datetime_max:\n                    field.validators.append(MaxDateTimeValidator(q.valid_datetime_max))\n            elif q.type == Question.TYPE_PHONENUMBER:\n                if initial:\n                    try:\n                        initial = PhoneNumber().from_string(initial.answer)\n                    except NumberParseException:\n                        initial = None\n\n                if not initial:\n                    phone_prefix = guess_phone_prefix_from_request(request, event)\n                    if phone_prefix:\n                        initial = \"+{}.\".format(phone_prefix)\n\n                field = PhoneNumberField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    # We now exploit an implementation detail in PhoneNumberPrefixWidget to allow us to pass just\n                    # a country code but no number as an initial value. It's a bit hacky, but should be stable for\n                    # the future.\n                    initial=initial,\n                    widget=WrappedPhoneNumberPrefixWidget()\n                )\n            field.question = q\n            if answers:\n                # Cache the answer object for later use\n                field.answer = answers[0]\n\n            if q.dependency_question_id:\n                field.widget.attrs['data-question-dependency'] = q.dependency_question_id\n                field.widget.attrs['data-question-dependency-values'] = escapejson_attr(json.dumps(q.dependency_values))\n                if q.type != 'M':\n                    field.widget.attrs['required'] = q.required and not self.all_optional\n                    field._required = q.required and not self.all_optional\n                field.required = False\n\n            add_fields['question_%s' % q.id] = field\n            field_positions.append(('question_%s' % q.id, q.position))\n\n        field_positions.sort(key=lambda e: e[1])\n        for fname, p in field_positions:\n            self.fields[fname] = add_fields[fname]\n\n        responses = question_form_fields.send(sender=event, position=pos)\n        data = pos.meta_info_data\n        for r, response in sorted(responses, key=lambda r: str(r[0])):\n            for key, value in response.items():\n                # We need to be this explicit, since OrderedDict.update does not retain ordering\n                self.fields[key] = value\n                value.initial = data.get('question_form_data', {}).get(key)\n\n        for k, v in self.fields.items():\n            if v.widget.attrs.get('autocomplete') or k == 'attendee_name_parts':\n                v.widget.attrs['autocomplete'] = 'section-{} '.format(self.prefix) + v.widget.attrs.get('autocomplete', '')\n\n    def clean(self):\n        from pretix.base.addressvalidation import \\\n            validate_address  # local import to prevent impact on startup time\n\n        d = super().clean()\n\n        if self.address_validation:\n            self.cleaned_data = d = validate_address(d, True)\n\n        if d.get('city') and d.get('country') and str(d['country']) in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            if not d.get('state'):\n                self.add_error('state', _('This field is required.'))\n\n        question_cache = {f.question.pk: f.question for f in self.fields.values() if getattr(f, 'question', None)}\n\n        def question_is_visible(parentid, qvals):\n            if parentid not in question_cache:\n                return False\n            parentq = question_cache[parentid]\n            if parentq.dependency_question_id and not question_is_visible(parentq.dependency_question_id, parentq.dependency_values):\n                return False\n            if 'question_%d' % parentid not in d:\n                return False\n            dval = d.get('question_%d' % parentid)\n            return (\n                ('True' in qvals and dval)\n                or ('False' in qvals and not dval)\n                or (isinstance(dval, QuestionOption) and dval.identifier in qvals)\n                or (isinstance(dval, (list, QuerySet)) and any(qval in [o.identifier for o in dval] for qval in qvals))\n            )\n\n        def question_is_required(q):\n            return (\n                q.required and\n                (not q.dependency_question_id or question_is_visible(q.dependency_question_id, q.dependency_values))\n            )\n\n        if not self.all_optional:\n            for q in question_cache.values():\n                answer = d.get('question_%d' % q.pk)\n                field = self['question_%d' % q.pk]\n                if question_is_required(q) and not answer and answer != 0 and not field.errors:\n                    raise ValidationError({'question_%d' % q.pk: [_('This field is required.')]})\n\n        # Strip invisible question from cleaned_data so they don't end up in the database\n        for q in question_cache.values():\n            answer = d.get('question_%d' % q.pk)\n            if q.dependency_question_id and not question_is_visible(q.dependency_question_id, q.dependency_values) and answer is not None:\n                d['question_%d' % q.pk] = None\n\n        return d\n\n\nclass BaseInvoiceAddressForm(forms.ModelForm):\n    vat_warning = False\n    address_validation = False\n\n    class Meta:\n        model = InvoiceAddress\n        fields = ('is_business', 'company', 'name_parts', 'street', 'zipcode', 'city', 'country', 'state',\n                  'vat_id', 'internal_reference', 'beneficiary', 'custom_field')\n        widgets = {\n            'is_business': BusinessBooleanRadio,\n            'street': forms.Textarea(attrs={\n                'rows': 2,\n                'placeholder': _('Street and Number'),\n                'autocomplete': 'street-address'\n            }),\n            'beneficiary': forms.Textarea(attrs={'rows': 3}),\n            'country': forms.Select(attrs={\n                'autocomplete': 'country',\n            }),\n            'zipcode': forms.TextInput(attrs={\n                'autocomplete': 'postal-code',\n            }),\n            'city': forms.TextInput(attrs={\n                'autocomplete': 'address-level2',\n            }),\n            'company': forms.TextInput(attrs={\n                'data-display-dependency': '#id_is_business_1',\n                'autocomplete': 'organization',\n            }),\n            'vat_id': forms.TextInput(attrs={'data-display-dependency': '#id_is_business_1', 'data-countries-with-vat-id': ','.join(VAT_ID_COUNTRIES)}),\n            'internal_reference': forms.TextInput,\n        }\n        labels = {\n            'is_business': ''\n        }\n\n    def __init__(self, *args, **kwargs):\n        self.event = event = kwargs.pop('event')\n        self.request = kwargs.pop('request', None)\n        self.validate_vat_id = kwargs.pop('validate_vat_id')\n        self.all_optional = kwargs.pop('all_optional', False)\n\n        kwargs.setdefault('initial', {})\n        if not kwargs.get('instance') or not kwargs['instance'].country:\n            kwargs['initial']['country'] = guess_country_from_request(self.request, self.event)\n\n        super().__init__(*args, **kwargs)\n        if not event.settings.invoice_address_vatid:\n            del self.fields['vat_id']\n        elif self.validate_vat_id:\n            self.fields['vat_id'].help_text = '<br/>'.join([\n                str(_('Optional, but depending on the country you reside in we might need to charge you '\n                      'additional taxes if you do not enter it.')),\n                str(_('If you are registered in Switzerland, you can enter your UID instead.')),\n            ])\n        else:\n            self.fields['vat_id'].help_text = '<br/>'.join([\n                str(_('Optional, but it might be required for you to claim tax benefits on your invoice '\n                      'depending on your and the seller\u2019s country of residence.')),\n                str(_('If you are registered in Switzerland, you can enter your UID instead.')),\n            ])\n\n        self.fields['country'].choices = CachedCountries()\n\n        c = [('', pgettext_lazy('address', 'Select state'))]\n        fprefix = self.prefix + '-' if self.prefix else ''\n        cc = None\n        if fprefix + 'country' in self.data:\n            cc = str(self.data[fprefix + 'country'])\n        elif 'country' in self.initial:\n            cc = str(self.initial['country'])\n        elif self.instance and self.instance.country:\n            cc = str(self.instance.country)\n        if cc and cc in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            types, form = COUNTRIES_WITH_STATE_IN_ADDRESS[cc]\n            statelist = [s for s in pycountry.subdivisions.get(country_code=cc) if s.type in types]\n            c += sorted([(s.code[3:], s.name) for s in statelist], key=lambda s: s[1])\n        elif fprefix + 'state' in self.data:\n            self.data = self.data.copy()\n            del self.data[fprefix + 'state']\n\n        self.fields['state'] = forms.ChoiceField(\n            label=pgettext_lazy('address', 'State'),\n            required=False,\n            choices=c,\n            widget=forms.Select(attrs={\n                'autocomplete': 'address-level1',\n            }),\n        )\n        self.fields['state'].widget.is_required = True\n\n        # Without JavaScript the VAT ID field is not hidden, so we empty the field if a country outside the EU is selected.\n        if cc and not ask_for_vat_id(cc) and fprefix + 'vat_id' in self.data:\n            self.data = self.data.copy()\n            del self.data[fprefix + 'vat_id']\n\n        if not event.settings.invoice_address_required or self.all_optional:\n            for k, f in self.fields.items():\n                f.required = False\n                f.widget.is_required = False\n                if 'required' in f.widget.attrs:\n                    del f.widget.attrs['required']\n        elif event.settings.invoice_address_company_required and not self.all_optional:\n            self.initial['is_business'] = True\n\n            self.fields['is_business'].widget = BusinessBooleanRadio(require_business=True)\n            self.fields['company'].required = True\n            self.fields['company'].widget.is_required = True\n            self.fields['company'].widget.attrs['required'] = 'required'\n            del self.fields['company'].widget.attrs['data-display-dependency']\n\n        self.fields['name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=event.settings.invoice_name_required and not self.all_optional,\n            scheme=event.settings.name_scheme,\n            titles=event.settings.name_scheme_titles,\n            label=_('Name'),\n            initial=self.instance.name_parts,\n        )\n        if event.settings.invoice_address_required and not event.settings.invoice_address_company_required and not self.all_optional:\n            if not event.settings.invoice_name_required:\n                self.fields['name_parts'].widget.attrs['data-required-if'] = '#id_is_business_0'\n            self.fields['name_parts'].widget.attrs['data-no-required-attr'] = '1'\n            self.fields['company'].widget.attrs['data-required-if'] = '#id_is_business_1'\n\n        if not event.settings.invoice_address_beneficiary:\n            del self.fields['beneficiary']\n\n        if event.settings.invoice_address_custom_field:\n            self.fields['custom_field'].label = event.settings.invoice_address_custom_field\n        else:\n            del self.fields['custom_field']\n\n        for k, v in self.fields.items():\n            if v.widget.attrs.get('autocomplete') or k == 'name_parts':\n                v.widget.attrs['autocomplete'] = 'section-invoice billing ' + v.widget.attrs.get('autocomplete', '')\n\n    def clean(self):\n        from pretix.base.addressvalidation import \\\n            validate_address  # local import to prevent impact on startup time\n\n        data = self.cleaned_data\n        if not data.get('is_business'):\n            data['company'] = ''\n            data['vat_id'] = ''\n        if data.get('is_business') and not ask_for_vat_id(data.get('country')):\n            data['vat_id'] = ''\n        if self.event.settings.invoice_address_required:\n            if data.get('is_business') and not data.get('company'):\n                raise ValidationError(_('You need to provide a company name.'))\n            if not data.get('is_business') and not data.get('name_parts'):\n                raise ValidationError(_('You need to provide your name.'))\n\n        if 'vat_id' in self.changed_data or not data.get('vat_id'):\n            self.instance.vat_id_validated = False\n\n        if self.address_validation:\n            self.cleaned_data = data = validate_address(data, self.all_optional)\n\n        self.instance.name_parts = data.get('name_parts')\n\n        if all(\n                not v for k, v in data.items() if k not in ('is_business', 'country', 'name_parts')\n        ) and len(data.get('name_parts', {})) == 1:\n            # Do not save the country if it is the only field set -- we don't know the user even checked it!\n            self.cleaned_data['country'] = ''\n\n        if self.validate_vat_id and self.instance.vat_id_validated and 'vat_id' not in self.changed_data:\n            pass\n        elif self.validate_vat_id and data.get('is_business') and ask_for_vat_id(data.get('country')) and data.get('vat_id'):\n            try:\n                normalized_id = validate_vat_id(data.get('vat_id'), str(data.get('country')))\n                self.instance.vat_id_validated = True\n                self.instance.vat_id = normalized_id\n            except VATIDFinalError as e:\n                if self.all_optional:\n                    self.instance.vat_id_validated = False\n                    messages.warning(self.request, e.message)\n                else:\n                    raise ValidationError(e.message)\n            except VATIDTemporaryError as e:\n                self.instance.vat_id_validated = False\n                if self.request and self.vat_warning:\n                    messages.warning(self.request, e.message)\n        else:\n            self.instance.vat_id_validated = False\n\n\nclass BaseInvoiceNameForm(BaseInvoiceAddressForm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        for f in list(self.fields.keys()):\n            if f != 'name_parts':\n                del self.fields[f]\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexander Schwartz, Ayan Ginet, Daniel, Enrique Saez,\n# Flavia Bastos, Jakob Schnell, Sanket Dasgupta, Sohalt, Tobias Kunze, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport hashlib\nimport json\nimport logging\nimport string\nfrom collections import Counter\nfrom datetime import datetime, time, timedelta\nfrom decimal import Decimal\nfrom typing import Any, Dict, List, Union\nfrom zoneinfo import ZoneInfo\n\nimport dateutil\nimport pycountry\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.db import models, transaction\nfrom django.db.models import (\n    Case, Exists, F, Max, OuterRef, Q, Subquery, Sum, Value, When,\n)\nfrom django.db.models.functions import Coalesce, Greatest\nfrom django.db.models.signals import post_delete\nfrom django.dispatch import receiver\nfrom django.urls import reverse\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.formats import date_format\nfrom django.utils.functional import cached_property\nfrom django.utils.timezone import get_current_timezone, make_aware, now\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_countries.fields import Country\nfrom django_scopes import ScopedManager, scopes_disabled\nfrom i18nfield.strings import LazyI18nString\nfrom phonenumber_field.modelfields import PhoneNumberField\nfrom phonenumber_field.phonenumber import PhoneNumber\nfrom phonenumbers import NumberParseException\n\nfrom pretix.base.banlist import banned\nfrom pretix.base.decimal import round_decimal\nfrom pretix.base.email import get_email_context\nfrom pretix.base.i18n import language\nfrom pretix.base.models import Customer, User\nfrom pretix.base.reldate import RelativeDateWrapper\nfrom pretix.base.services.locking import LOCK_TIMEOUT, NoLockManager\nfrom pretix.base.settings import PERSON_NAME_SCHEMES\nfrom pretix.base.signals import order_gracefully_delete\n\nfrom ...helpers import OF_SELF\nfrom ...helpers.countries import CachedCountries, FastCountryField\nfrom ...helpers.format import format_map\nfrom ...helpers.names import build_name\nfrom ._transactions import (\n    _fail, _transactions_mark_order_clean, _transactions_mark_order_dirty,\n)\nfrom .base import LockModel, LoggedModel\nfrom .event import Event, SubEvent\nfrom .items import Item, ItemVariation, Question, QuestionOption, Quota\n\nlogger = logging.getLogger(__name__)\n\n\ndef generate_secret():\n    return get_random_string(length=16, allowed_chars=string.ascii_lowercase + string.digits)\n\n\ndef generate_position_secret():\n    raise TypeError(\"Function no longer exists, use secret generators\")\n\n\nclass Order(LockModel, LoggedModel):\n    \"\"\"\n    An order is created when a user clicks 'buy' on his cart. It holds\n    several OrderPositions and is connected to a user. It has an\n    expiration date: If items run out of capacity, orders which are over\n    their expiration date might be canceled.\n\n    An order -- like all objects -- has an ID, which is globally unique,\n    but also a code, which is shorter and easier to memorize, but only\n    unique within a single conference.\n\n    :param code: In addition to the ID, which is globally unique, every\n                 order has an order code, which is shorter and easier to\n                 memorize, but is only unique within a single conference.\n    :type code: str\n    :param status: The status of this order. One of:\n\n        * ``STATUS_PENDING``\n        * ``STATUS_PAID``\n        * ``STATUS_EXPIRED``\n        * ``STATUS_CANCELED``\n\n    :param valid_if_pending: Treat this order like a paid order for most purposes (such as check-in), even if it is\n                             still unpaid.\n    :type valid_if_pending: bool\n    :param event: The event this order belongs to\n    :type event: Event\n    :param customer: The customer this order belongs to\n    :type customer: Customer\n    :param email: The email of the person who ordered this\n    :type email: str\n    :param phone: The phone number of the person who ordered this\n    :type phone: str\n    :param testmode: Whether this is a test mode order\n    :type testmode: bool\n    :param locale: The locale of this order\n    :type locale: str\n    :param secret: A secret string that is required to modify the order\n    :type secret: str\n    :param datetime: The datetime of the order placement\n    :type datetime: datetime\n    :param expires: The date until this order has to be paid to guarantee the fulfillment\n    :type expires: datetime\n    :param total: The total amount of the order, including the payment fee\n    :type total: decimal.Decimal\n    :param comment: An internal comment that will only be visible to staff, and never displayed to the user\n    :type comment: str\n    :param download_reminder_sent: A field to indicate whether a download reminder has been sent.\n    :type download_reminder_sent: boolean\n    :param require_approval: If set to ``True``, this order is pending approval by an organizer\n    :type require_approval: bool\n    :param meta_info: Additional meta information on the order, JSON-encoded.\n    :type meta_info: str\n    :param sales_channel: Identifier of the sales channel this order was created through.\n    :type sales_channel: str\n    \"\"\"\n\n    STATUS_PENDING = \"n\"\n    STATUS_PAID = \"p\"\n    STATUS_EXPIRED = \"e\"\n    STATUS_CANCELED = \"c\"\n    STATUS_REFUNDED = \"c\"  # deprecated\n    STATUS_CHOICE = (\n        (STATUS_PENDING, _(\"pending\")),\n        (STATUS_PAID, _(\"paid\")),\n        (STATUS_EXPIRED, _(\"expired\")),\n        (STATUS_CANCELED, _(\"canceled\")),\n    )\n\n    code = models.CharField(\n        max_length=16,\n        verbose_name=_(\"Order code\"),\n        db_index=True\n    )\n    status = models.CharField(\n        max_length=3,\n        choices=STATUS_CHOICE,\n        verbose_name=_(\"Status\"),\n        db_index=True\n    )\n    valid_if_pending = models.BooleanField(\n        default=False,\n    )\n    testmode = models.BooleanField(default=False)\n    event = models.ForeignKey(\n        Event,\n        verbose_name=_(\"Event\"),\n        related_name=\"orders\",\n        on_delete=models.CASCADE\n    )\n    customer = models.ForeignKey(\n        Customer,\n        verbose_name=_(\"Customer\"),\n        related_name=\"orders\",\n        null=True, blank=True,\n        on_delete=models.SET_NULL\n    )\n    email = models.EmailField(\n        null=True, blank=True,\n        verbose_name=_('E-mail')\n    )\n    phone = PhoneNumberField(\n        null=True, blank=True,\n        verbose_name=_('Phone number'),\n    )\n    locale = models.CharField(\n        null=True, blank=True, max_length=32,\n        verbose_name=_('Locale')\n    )\n    secret = models.CharField(max_length=32, default=generate_secret)\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"), db_index=False\n    )\n    cancellation_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    expires = models.DateTimeField(\n        verbose_name=_(\"Expiration date\")\n    )\n    total = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Total amount\")\n    )\n    comment = models.TextField(\n        blank=True, verbose_name=_(\"Comment\"),\n        help_text=_(\"The text entered in this field will not be visible to the user and is available for your \"\n                    \"convenience.\")\n    )\n    custom_followup_at = models.DateField(\n        verbose_name=_(\"Follow-up date\"),\n        help_text=_('We\\'ll show you this order to be due for a follow-up on this day.'),\n        null=True, blank=True\n    )\n    checkin_attention = models.BooleanField(\n        verbose_name=_('Requires special attention'),\n        default=False,\n        help_text=_('If you set this, the check-in app will show a visible warning that tickets of this order require '\n                    'special attention. This will not show any details or custom message, so you need to brief your '\n                    'check-in staff how to handle these cases.')\n    )\n    expiry_reminder_sent = models.BooleanField(\n        default=False\n    )\n\n    download_reminder_sent = models.BooleanField(\n        default=False\n    )\n    meta_info = models.TextField(\n        verbose_name=_(\"Meta information\"),\n        null=True, blank=True\n    )\n    last_modified = models.DateTimeField(\n        auto_now=True, db_index=False\n    )\n    require_approval = models.BooleanField(\n        default=False\n    )\n    sales_channel = models.CharField(max_length=190, default=\"web\")\n    email_known_to_work = models.BooleanField(\n        default=False,\n        verbose_name=_('E-mail address verified')\n    )\n\n    objects = ScopedManager(organizer='event__organizer')\n\n    class Meta:\n        verbose_name = _(\"Order\")\n        verbose_name_plural = _(\"Orders\")\n        ordering = (\"-datetime\", \"-pk\")\n        index_together = [\n            [\"datetime\", \"id\"],\n            [\"last_modified\", \"id\"],\n        ]\n\n    def __str__(self):\n        return self.full_code\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if 'require_approval' not in self.get_deferred_fields() and 'status' not in self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def _transaction_key_reset(self):\n        self.__initial_status_paid_or_pending = self.status in (Order.STATUS_PENDING, Order.STATUS_PAID) and not self.require_approval\n\n    def gracefully_delete(self, user=None, auth=None):\n        from . import GiftCard, GiftCardTransaction, Membership, Voucher\n\n        if not self.testmode:\n            raise TypeError(\"Only test mode orders can be deleted.\")\n        self.event.log_action(\n            'pretix.event.order.deleted', user=user, auth=auth,\n            data={\n                'code': self.code,\n            }\n        )\n\n        order_gracefully_delete.send(self.event, order=self)\n\n        if self.status != Order.STATUS_CANCELED:\n            for position in self.positions.all():\n                if position.voucher:\n                    Voucher.objects.filter(pk=position.voucher.pk).update(redeemed=Greatest(0, F('redeemed') - 1))\n\n        GiftCardTransaction.objects.filter(payment__in=self.payments.all()).update(payment=None)\n        GiftCardTransaction.objects.filter(refund__in=self.refunds.all()).update(refund=None)\n        GiftCardTransaction.objects.filter(order=self).update(order=None)\n        GiftCard.objects.filter(issued_in__in=self.positions.all()).update(issued_in=None)\n        Membership.objects.filter(granted_in__order=self, testmode=True).update(granted_in=None)\n        OrderPosition.all.filter(order=self, addon_to__isnull=False).delete()\n        OrderPosition.all.filter(order=self).delete()\n        OrderFee.all.filter(order=self).delete()\n        Transaction.objects.filter(order=self).delete()\n        self.refunds.all().delete()\n        self.payments.all().delete()\n        self.event.cache.delete('complain_testmode_orders')\n        self.delete()\n\n    def email_confirm_hash(self):\n        return hashlib.sha256(settings.SECRET_KEY.encode() + self.secret.encode()).hexdigest()[:9]\n\n    @property\n    def fees(self):\n        \"\"\"\n        Related manager for all non-canceled fees. Use ``all_fees`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_fees(manager='objects')\n\n    @property\n    def custom_followup_due(self):\n        return self.custom_followup_at and self.custom_followup_at <= now().astimezone(get_current_timezone()).date()\n\n    @cached_property\n    @scopes_disabled()\n    def count_positions(self):\n        if hasattr(self, 'pcnt'):\n            return self.pcnt or 0\n        return self.positions.count()\n\n    @property\n    def positions(self):\n        \"\"\"\n        Related manager for all non-canceled positions. Use ``all_positions`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_positions(manager='objects')\n\n    @cached_property\n    def meta_info_data(self):\n        if not self.meta_info:\n            return {}\n        try:\n            return json.loads(self.meta_info)\n        except TypeError:\n            return None\n\n    @property\n    @scopes_disabled()\n    def payment_refund_sum(self):\n        payment_sum = self.payments.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        return payment_sum - refund_sum\n\n    @property\n    @scopes_disabled()\n    def pending_sum(self):\n        total = self.total\n        if self.status == Order.STATUS_CANCELED:\n            total = Decimal('0.00')\n        payment_sum = self.payments.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        return total - payment_sum + refund_sum\n\n    @classmethod\n    def annotate_overpayments(cls, qs, results=True, refunds=True, sums=False):\n        payment_sum = OrderPayment.objects.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED),\n            order=OuterRef('pk')\n        ).order_by().values('order').annotate(s=Sum('amount')).values('s')\n        refund_sum = OrderRefund.objects.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED),\n            order=OuterRef('pk')\n        ).order_by().values('order').annotate(s=Sum('amount')).values('s')\n        external_refund = OrderRefund.objects.filter(\n            state=OrderRefund.REFUND_STATE_EXTERNAL,\n            order=OuterRef('pk')\n        )\n        pending_refund = OrderRefund.objects.filter(\n            state__in=(OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT),\n            order=OuterRef('pk')\n        )\n        payment_sum_sq = Subquery(payment_sum, output_field=models.DecimalField(decimal_places=2, max_digits=13))\n        refund_sum_sq = Subquery(refund_sum, output_field=models.DecimalField(decimal_places=2, max_digits=13))\n        if sums:\n            qs = qs.annotate(\n                payment_sum=payment_sum_sq,\n                refund_sum=refund_sum_sq,\n            )\n            qs = qs.annotate(\n                computed_payment_refund_sum=Coalesce(payment_sum_sq, Decimal('0.00')) - Coalesce(refund_sum_sq, Decimal('0.00')),\n            )\n\n        qs = qs.annotate(\n            pending_sum_t=F('total') - Coalesce(payment_sum_sq, Decimal('0.00')) + Coalesce(refund_sum_sq, Decimal('0.00')),\n            pending_sum_rc=-1 * Coalesce(payment_sum_sq, Decimal('0.00')) + Coalesce(refund_sum_sq, Decimal('0.00')),\n        )\n        if refunds:\n            qs = qs.annotate(\n                has_external_refund=Exists(external_refund),\n                has_pending_refund=Exists(pending_refund),\n            )\n        if results:\n            qs = qs.annotate(\n                is_overpaid=Case(\n                    When(~Q(status=Order.STATUS_CANCELED) & Q(pending_sum_t__lt=-1e-8),\n                         then=Value(1)),\n                    When(Q(status=Order.STATUS_CANCELED) & Q(pending_sum_rc__lt=-1e-8),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                ),\n                is_pending_with_full_payment=Case(\n                    When(Q(status__in=(Order.STATUS_EXPIRED, Order.STATUS_PENDING)) & Q(pending_sum_t__lte=1e-8)\n                         & Q(require_approval=False),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                ),\n                is_underpaid=Case(\n                    When(Q(status=Order.STATUS_PAID) & Q(pending_sum_t__gt=1e-8),\n                         then=Value(1)),\n                    When(Q(status=Order.STATUS_CANCELED) & Q(pending_sum_rc__gt=1e-8),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                )\n            )\n        return qs\n\n    @property\n    def full_code(self):\n        \"\"\"\n        An order code which is unique among all events of a single organizer,\n        built by concatenating the event slug and the order code.\n        \"\"\"\n        return '{event}-{code}'.format(event=self.event.slug.upper(), code=self.code)\n\n    def save(self, **kwargs):\n        if 'update_fields' in kwargs:\n            kwargs['update_fields'] = {'last_modified'}.union(kwargs['update_fields'])\n        if not self.code:\n            self.assign_code()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'code'}.union(kwargs['update_fields'])\n        if not self.datetime:\n            self.datetime = now()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'datetime'}.union(kwargs['update_fields'])\n        if not self.expires:\n            self.set_expires()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'expires'}.union(kwargs['update_fields'])\n\n        is_new = not self.pk\n        update_fields = kwargs.get('update_fields', [])\n        if 'require_approval' not in self.get_deferred_fields() and 'status' not in self.get_deferred_fields():\n            status_paid_or_pending = self.status in (Order.STATUS_PENDING, Order.STATUS_PAID) and not self.require_approval\n            if status_paid_or_pending != self.__initial_status_paid_or_pending:\n                _transactions_mark_order_dirty(self.pk, using=kwargs.get('using', None))\n        elif (\n            not kwargs.get('force_save_with_deferred_fields', None) and\n            (not update_fields or ('require_approval' not in update_fields and 'status' not in update_fields))\n        ):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        r = super().save(**kwargs)\n\n        if is_new:\n            _transactions_mark_order_dirty(self.pk, using=kwargs.get('using', None))\n\n        return r\n\n    def touch(self):\n        self.save(update_fields=['last_modified'])\n\n    def set_expires(self, now_dt=None, subevents=None):\n        now_dt = now_dt or now()\n        tz = ZoneInfo(self.event.settings.timezone)\n        mode = self.event.settings.get('payment_term_mode')\n        if mode == 'days':\n            exp_by_date = now_dt.astimezone(tz) + timedelta(days=self.event.settings.get('payment_term_days', as_type=int))\n            exp_by_date = exp_by_date.astimezone(tz).replace(hour=23, minute=59, second=59, microsecond=0)\n            if self.event.settings.get('payment_term_weekdays'):\n                if exp_by_date.weekday() == 5:\n                    exp_by_date += timedelta(days=2)\n                elif exp_by_date.weekday() == 6:\n                    exp_by_date += timedelta(days=1)\n        elif mode == 'minutes':\n            exp_by_date = now_dt.astimezone(tz) + timedelta(minutes=self.event.settings.get('payment_term_minutes', as_type=int))\n        else:\n            raise ValueError(\"'payment_term_mode' has an invalid value '{}'.\".format(mode))\n\n        self.expires = exp_by_date\n\n        term_last = self.event.settings.get('payment_term_last', as_type=RelativeDateWrapper)\n        if term_last:\n            if self.event.has_subevents and subevents:\n                terms = [\n                    term_last.datetime(se).date()\n                    for se in subevents\n                ]\n                if not terms:\n                    return\n                term_last = min(terms)\n            else:\n                term_last = term_last.datetime(self.event).date()\n            term_last = make_aware(datetime.combine(\n                term_last,\n                time(hour=23, minute=59, second=59)\n            ), tz)\n            if term_last < self.expires:\n                self.expires = term_last\n\n    @cached_property\n    def tax_total(self):\n        return (self.positions.aggregate(s=Sum('tax_value'))['s'] or 0) + (self.fees.aggregate(s=Sum('tax_value'))['s'] or 0)\n\n    @property\n    def net_total(self):\n        return self.total - self.tax_total\n\n    def cancel_allowed(self):\n        return (\n            self.status in (Order.STATUS_PENDING, Order.STATUS_PAID, Order.STATUS_EXPIRED) and self.count_positions\n        )\n\n    @cached_property\n    def user_change_deadline(self):\n        until = self.event.settings.get('change_allow_user_until', as_type=RelativeDateWrapper)\n        if until:\n            if self.event.has_subevents:\n                terms = [\n                    until.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                return min(terms) if terms else None\n            else:\n                return until.datetime(self.event)\n\n    @cached_property\n    def user_cancel_deadline(self):\n        if self.status == Order.STATUS_PAID and self.total != Decimal('0.00'):\n            until = self.event.settings.get('cancel_allow_user_paid_until', as_type=RelativeDateWrapper)\n        else:\n            until = self.event.settings.get('cancel_allow_user_until', as_type=RelativeDateWrapper)\n        if until:\n            if self.event.has_subevents:\n                terms = [\n                    until.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                return min(terms) if terms else None\n            else:\n                return until.datetime(self.event)\n\n    @cached_property\n    def user_cancel_fee(self):\n        fee = Decimal('0.00')\n        if self.status == Order.STATUS_PAID:\n            if self.event.settings.cancel_allow_user_paid_keep_fees:\n                fee += self.fees.filter(\n                    fee_type__in=(OrderFee.FEE_TYPE_PAYMENT, OrderFee.FEE_TYPE_SHIPPING, OrderFee.FEE_TYPE_SERVICE,\n                                  OrderFee.FEE_TYPE_CANCELLATION)\n                ).aggregate(\n                    s=Sum('value')\n                )['s'] or 0\n            if self.event.settings.cancel_allow_user_paid_keep_percentage:\n                fee += self.event.settings.cancel_allow_user_paid_keep_percentage / Decimal('100.0') * (self.total - fee)\n            if self.event.settings.cancel_allow_user_paid_keep:\n                fee += self.event.settings.cancel_allow_user_paid_keep\n        else:\n            if self.event.settings.cancel_allow_user_unpaid_keep_fees:\n                fee += self.fees.filter(\n                    fee_type__in=(OrderFee.FEE_TYPE_PAYMENT, OrderFee.FEE_TYPE_SHIPPING, OrderFee.FEE_TYPE_SERVICE,\n                                  OrderFee.FEE_TYPE_CANCELLATION)\n                ).aggregate(\n                    s=Sum('value')\n                )['s'] or 0\n            if self.event.settings.cancel_allow_user_unpaid_keep_percentage:\n                fee += self.event.settings.cancel_allow_user_unpaid_keep_percentage / Decimal('100.0') * (self.total - fee)\n            if self.event.settings.cancel_allow_user_unpaid_keep:\n                fee += self.event.settings.cancel_allow_user_unpaid_keep\n        return round_decimal(min(fee, self.total), self.event.currency)\n\n    @property\n    @scopes_disabled()\n    def user_change_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be canceled by the user.\n        \"\"\"\n        from .checkin import Checkin\n        from .items import ItemAddOn\n\n        if self.status not in (Order.STATUS_PENDING, Order.STATUS_PAID) or not self.count_positions:\n            return False\n\n        if self.cancellation_requests.exists():\n            return False\n\n        if self.require_approval:\n            return False\n\n        positions = list(\n            self.positions.all().annotate(\n                has_variations=Exists(ItemVariation.objects.filter(item_id=OuterRef('item_id'))),\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        if self.event.settings.change_allow_user_if_checked_in:\n            cancelable = all([op.item.allow_cancel for op in positions])\n        else:\n            cancelable = all([op.item.allow_cancel and not op.has_checkin for op in positions])\n        if not cancelable or not positions:\n            return False\n        for op in positions:\n            if op.issued_gift_cards.all():\n                return False\n        if self.user_change_deadline and now() > self.user_change_deadline:\n            return False\n\n        return (\n            (self.event.settings.change_allow_user_variation and any([op.has_variations for op in positions])) or\n            (self.event.settings.change_allow_user_addons and ItemAddOn.objects.filter(base_item_id__in=[op.item_id for op in positions]).exists())\n        )\n\n    @property\n    @scopes_disabled()\n    def user_cancel_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be canceled by the user.\n        \"\"\"\n        from .checkin import Checkin\n\n        if self.cancellation_requests.exists() or not self.cancel_allowed():\n            return False\n        positions = list(\n            self.positions.all().annotate(\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        cancelable = all([op.item.allow_cancel and not op.has_checkin and not op.blocked for op in positions])\n        if not cancelable or not positions:\n            return False\n        for op in positions:\n            for gc in op.issued_gift_cards.all():\n                if gc.value != op.price:\n                    return False\n            if op.granted_memberships.with_usages().filter(usages__gt=0):\n                return False\n        if self.user_cancel_deadline and now() > self.user_cancel_deadline:\n            return False\n\n        if self.status == Order.STATUS_PAID:\n            if self.total == Decimal('0.00'):\n                return self.event.settings.cancel_allow_user\n            return self.event.settings.cancel_allow_user_paid\n        elif self.payment_refund_sum > Decimal('0.00'):\n            return False\n        elif self.status == Order.STATUS_PENDING:\n            return self.event.settings.cancel_allow_user\n        return False\n\n    def propose_auto_refunds(self, amount: Decimal, payments: list=None):\n        # Algorithm to choose which payments are to be refunded to create the least hassle\n        payments = payments or self.payments.filter(state=OrderPayment.PAYMENT_STATE_CONFIRMED)\n        for p in payments:\n            if p.payment_provider:\n                p.full_refund_possible = p.payment_provider.payment_refund_supported(p)\n                p.partial_refund_possible = p.payment_provider.payment_partial_refund_supported(p)\n                p.propose_refund = Decimal('0.00')\n                p.available_amount = p.amount - p.refunded_amount\n            else:\n                p.full_refund_possible = False\n                p.partial_refund_possible = False\n                p.propose_refund = Decimal('0.00')\n                p.available_amount = Decimal('0.00')\n\n        unused_payments = set(p for p in payments if p.full_refund_possible or p.partial_refund_possible)\n        to_refund = amount\n        proposals = {}\n\n        while to_refund and unused_payments:\n            bigger = sorted([\n                p for p in unused_payments\n                if p.available_amount > to_refund\n                and p.partial_refund_possible\n            ], key=lambda p: p.available_amount)\n            same = [\n                p for p in unused_payments\n                if p.available_amount == to_refund\n                and (p.full_refund_possible or p.partial_refund_possible)\n            ]\n            smaller = sorted([\n                p for p in unused_payments\n                if p.available_amount < to_refund\n                and (p.full_refund_possible or p.partial_refund_possible)\n            ], key=lambda p: p.available_amount, reverse=True)\n            if same:\n                payment = same[0]\n                proposals[payment] = payment.available_amount\n                to_refund -= payment.available_amount\n                unused_payments.remove(payment)\n            elif bigger:\n                payment = bigger[0]\n                proposals[payment] = to_refund\n                to_refund -= to_refund\n                unused_payments.remove(payment)\n            elif smaller:\n                payment = smaller[0]\n                proposals[payment] = payment.available_amount\n                to_refund -= payment.available_amount\n                unused_payments.remove(payment)\n            else:\n                break\n        return proposals\n\n    @staticmethod\n    def normalize_code(code, is_fallback=False):\n        d = {\n            '2': 'Z',\n            '4': 'A',\n            '5': 'S',\n            '6': 'G',\n        }\n        if is_fallback:\n            d['8'] = 'B'\n            # 8 has been removed from the character set only in 2021, which means there are a lot of order codes\n            # with an 8 in it around. We only want to replace this when this is used in a fallback.\n        tr = str.maketrans(d)\n        return code.upper().translate(tr)\n\n    def assign_code(self):\n        # This omits some character pairs completely because they are hard to read even on screens (1/I and O/0)\n        # and includes only one of two characters for some pairs because they are sometimes hard to distinguish in\n        # handwriting (2/Z, 4/A, 5/S, 6/G, 8/B). This allows for better detection e.g. in incoming wire transfers that\n        # might include OCR'd handwritten text\n        charset = list('ABCDEFGHJKLMNPQRSTUVWXYZ379')\n        iteration = 0\n        length = settings.ENTROPY['order_code']\n        while True:\n            code = get_random_string(length=length, allowed_chars=charset)\n            iteration += 1\n\n            if banned(code):\n                continue\n\n            if self.testmode:\n                # Subtle way to recognize test orders while debugging: They all contain a 0 at the second place,\n                # even though zeros are not used outside test mode.\n                code = code[0] + \"0\" + code[2:]\n\n            if not Order.objects.filter(event__organizer=self.event.organizer, code=code).exists():\n                self.code = code\n                return\n\n            if iteration > 20:\n                # Safeguard: If we don't find an unused and non-banlisted code within 20 iterations, we increase\n                # the length.\n                length += 1\n                iteration = 0\n\n    @property\n    def modify_deadline(self):\n        modify_deadline = self.event.settings.get('last_order_modification_date', as_type=RelativeDateWrapper)\n        if self.event.has_subevents and modify_deadline:\n            dates = [\n                modify_deadline.datetime(se)\n                for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n            ]\n            return min(dates) if dates else None\n        elif modify_deadline:\n            return modify_deadline.datetime(self.event)\n        return None\n\n    @property\n    def can_modify_answers(self) -> bool:\n        \"\"\"\n        ``True`` if the user can change the question answers / attendee names that are\n        related to the order. This checks order status and modification deadlines. It also\n        returns ``False`` if there are no questions that can be answered.\n        \"\"\"\n        from .checkin import Checkin\n\n        if self.status not in (Order.STATUS_PENDING, Order.STATUS_PAID, Order.STATUS_EXPIRED):\n            return False\n\n        modify_deadline = self.modify_deadline\n        if modify_deadline is not None and now() > modify_deadline:\n            return False\n\n        positions = list(\n            self.positions.all().annotate(\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('item__questions')\n        )\n        if not self.event.settings.allow_modifications_after_checkin:\n            for cp in positions:\n                if cp.has_checkin:\n                    return False\n\n        if self.event.settings.get('invoice_address_asked', as_type=bool):\n            return True\n        ask_names = self.event.settings.get('attendee_names_asked', as_type=bool)\n        for cp in positions:\n            if (cp.item.ask_attendee_data and ask_names) or cp.item.questions.all():\n                return True\n\n        return False  # nothing there to modify\n\n    @property\n    def is_expired_by_time(self):\n        return (\n            self.status == Order.STATUS_PENDING and not self.require_approval and self.expires < now()\n            and not self.event.settings.get('payment_term_expire_automatically')\n        )\n\n    @property\n    def ticket_download_date(self):\n        \"\"\"\n        Returns the first date the tickets for this order can be downloaded or ``None`` if there is no\n        restriction.\n        \"\"\"\n        dl_date = self.event.settings.get('ticket_download_date', as_type=RelativeDateWrapper)\n        if dl_date:\n            if self.event.has_subevents:\n                dates = [\n                    dl_date.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                dl_date = min(dates) if dates else None\n            else:\n                dl_date = dl_date.datetime(self.event)\n        return dl_date\n\n    @property\n    def ticket_download_available(self):\n        return self.event.settings.ticket_download and (\n            self.event.settings.ticket_download_date is None\n            or self.ticket_download_date is None\n            or now() > self.ticket_download_date\n        ) and (\n            self.status == Order.STATUS_PAID\n            or (\n                (self.valid_if_pending or self.event.settings.ticket_download_pending) and\n                self.status == Order.STATUS_PENDING and\n                not self.require_approval\n            )\n        )\n\n    @property\n    def payment_term_last(self):\n        tz = ZoneInfo(self.event.settings.timezone)\n        term_last = self.event.settings.get('payment_term_last', as_type=RelativeDateWrapper)\n        if term_last:\n            if self.event.has_subevents:\n                terms = [\n                    term_last.datetime(se).date()\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                if terms:\n                    term_last = min(terms)\n                else:\n                    return None\n            else:\n                term_last = term_last.datetime(self.event).date()\n            term_last = make_aware(datetime.combine(\n                term_last,\n                time(hour=23, minute=59, second=59)\n            ), tz)\n        return term_last\n\n    @property\n    def payment_term_expire_date(self):\n        delay = self.event.settings.get('payment_term_expire_delay_days', as_type=int)\n        if not delay:  # performance saver + backwards compatibility\n            return self.expires\n\n        term_last = self.payment_term_last\n        if term_last and self.expires > term_last:  # backwards compatibility\n            return self.expires\n\n        expires = self.expires.date() + timedelta(days=delay)\n        if self.event.settings.get('payment_term_weekdays'):\n            if expires.weekday() == 5:\n                expires += timedelta(days=2)\n            elif expires.weekday() == 6:\n                expires += timedelta(days=1)\n\n        tz = ZoneInfo(self.event.settings.timezone)\n        expires = make_aware(datetime.combine(\n            expires,\n            time(hour=23, minute=59, second=59)\n        ), tz)\n        if term_last:\n            return min(expires, term_last)\n        else:\n            return expires\n\n    def _can_be_paid(self, count_waitinglist=True, ignore_date=False, force=False) -> Union[bool, str]:\n        error_messages = {\n            'late_lastdate': _(\"The payment can not be accepted as the last date of payments configured in the \"\n                               \"payment settings is over.\"),\n            'late': _(\"The payment can not be accepted as the order is expired and you configured that no late \"\n                      \"payments should be accepted in the payment settings.\"),\n            'require_approval': _('This order is not yet approved by the event organizer.')\n        }\n        if not force:\n            if self.require_approval:\n                return error_messages['require_approval']\n            term_last = self.payment_term_last\n            if term_last and not ignore_date:\n                if now() > term_last:\n                    return error_messages['late_lastdate']\n\n        if self.status == self.STATUS_PENDING:\n            return True\n        if not self.event.settings.get('payment_term_accept_late') and not ignore_date and not force:\n            return error_messages['late']\n\n        return self._is_still_available(count_waitinglist=count_waitinglist, force=force)\n\n    def _is_still_available(self, now_dt: datetime=None, count_waitinglist=True, force=False,\n                            check_voucher_usage=False, check_memberships=False) -> Union[bool, str]:\n        from pretix.base.services.memberships import (\n            validate_memberships_in_order,\n        )\n\n        error_messages = {\n            'unavailable': _('The ordered product \"{item}\" is no longer available.'),\n            'seat_unavailable': _('The seat \"{seat}\" is no longer available.'),\n            'voucher_budget': _('The voucher \"{voucher}\" no longer has sufficient budget.'),\n            'voucher_usages': _('The voucher \"{voucher}\" has been used in the meantime.'),\n        }\n        now_dt = now_dt or now()\n        positions = list(self.positions.all().select_related('item', 'variation', 'seat', 'voucher'))\n        quota_cache = {}\n        v_budget = {}\n        v_usage = Counter()\n        try:\n            if check_memberships:\n                try:\n                    validate_memberships_in_order(self.customer, positions, self.event, lock=False, testmode=self.testmode)\n                except ValidationError as e:\n                    raise Quota.QuotaExceededException(e.message)\n\n            for i, op in enumerate(positions):\n                if op.seat:\n                    if not op.seat.is_available(ignore_orderpos=op):\n                        raise Quota.QuotaExceededException(error_messages['seat_unavailable'].format(seat=op.seat))\n                if force:\n                    continue\n\n                if op.voucher and op.voucher.budget is not None and op.voucher_budget_use:\n                    if op.voucher not in v_budget:\n                        v_budget[op.voucher] = op.voucher.budget - op.voucher.budget_used()\n                    disc = op.voucher_budget_use\n                    if disc > v_budget[op.voucher]:\n                        raise Quota.QuotaExceededException(error_messages['voucher_budget'].format(\n                            voucher=op.voucher.code\n                        ))\n                    v_budget[op.voucher] -= disc\n\n                if op.voucher and check_voucher_usage:\n                    v_usage[op.voucher.pk] += 1\n                    if v_usage[op.voucher.pk] + op.voucher.redeemed > op.voucher.max_usages:\n                        raise Quota.QuotaExceededException(error_messages['voucher_usages'].format(\n                            voucher=op.voucher.code\n                        ))\n\n                quotas = list(op.quotas)\n                if len(quotas) == 0:\n                    raise Quota.QuotaExceededException(error_messages['unavailable'].format(\n                        item=str(op.item) + (' - ' + str(op.variation) if op.variation else '')\n                    ))\n\n                for quota in quotas:\n                    if quota.id not in quota_cache:\n                        quota_cache[quota.id] = quota\n                        quota.cached_availability = quota.availability(now_dt, count_waitinglist=count_waitinglist)[1]\n                    else:\n                        # Use cached version\n                        quota = quota_cache[quota.id]\n                    if quota.cached_availability is not None:\n                        quota.cached_availability -= 1\n                        if quota.cached_availability < 0:\n                            # This quota is sold out/currently unavailable, so do not sell this at all\n                            raise Quota.QuotaExceededException(error_messages['unavailable'].format(\n                                item=str(op.item) + (' - ' + str(op.variation) if op.variation else '')\n                            ))\n        except Quota.QuotaExceededException as e:\n            return str(e)\n        return True\n\n    def send_mail(self, subject: Union[str, LazyI18nString], template: Union[str, LazyI18nString],\n                  context: Dict[str, Any]=None, log_entry_type: str='pretix.event.order.email.sent',\n                  user: User=None, headers: dict=None, sender: str=None, invoices: list=None,\n                  auth=None, attach_tickets=False, position: 'OrderPosition'=None, auto_email=True,\n                  attach_ical=False, attach_other_files: list=None, attach_cached_files: list=None):\n        \"\"\"\n        Sends an email to the user that placed this order. Basically, this method does two things:\n\n        * Call ``pretix.base.services.mail.mail`` with useful values for the ``event``, ``locale``, ``recipient`` and\n          ``order`` parameters.\n\n        * Create a ``LogEntry`` with the email contents.\n\n        :param subject: Subject of the email\n        :param template: LazyI18nString or template filename, see ``pretix.base.services.mail.mail`` for more details\n        :param context: Dictionary to use for rendering the template\n        :param log_entry_type: Key to be used for the log entry\n        :param user: Administrative user who triggered this mail to be sent\n        :param headers: Dictionary with additional mail headers\n        :param sender: Custom email sender.\n        :param attach_tickets: Attach tickets of this order, if they are existing and ready to download\n        :param attach_ical: Attach relevant ICS files\n        :param position: An order position this refers to. If given, no invoices will be attached, the tickets will\n                         only be attached for this position and child positions, the link will only point to the\n                         position and the attendee email will be used if available.\n        \"\"\"\n        from pretix.base.services.mail import (\n            SendMailException, mail, render_mail,\n        )\n\n        if not self.email and not (position and position.attendee_email):\n            return\n\n        for k, v in self.event.meta_data.items():\n            context['meta_' + k] = v\n\n        with language(self.locale, self.event.settings.region):\n            recipient = self.email\n            if position and position.attendee_email:\n                recipient = position.attendee_email\n\n            try:\n                email_content = render_mail(template, context)\n                subject = format_map(subject, context)\n                mail(\n                    recipient, subject, template, context,\n                    self.event, self.locale, self, headers=headers, sender=sender,\n                    invoices=invoices, attach_tickets=attach_tickets,\n                    position=position, auto_email=auto_email, attach_ical=attach_ical,\n                    attach_other_files=attach_other_files, attach_cached_files=attach_cached_files,\n                )\n            except SendMailException:\n                raise\n            else:\n                self.log_action(\n                    log_entry_type,\n                    user=user,\n                    auth=auth,\n                    data={\n                        'subject': subject,\n                        'message': email_content,\n                        'position': position.positionid if position else None,\n                        'recipient': recipient,\n                        'invoices': [i.pk for i in invoices] if invoices else [],\n                        'attach_tickets': attach_tickets,\n                        'attach_ical': attach_ical,\n                    }\n                )\n\n    def resend_link(self, user=None, auth=None):\n        with language(self.locale, self.event.settings.region):\n            email_template = self.event.settings.mail_text_resend_link\n            email_context = get_email_context(event=self.event, order=self)\n            email_subject = self.event.settings.mail_subject_resend_link\n            self.send_mail(\n                email_subject, email_template, email_context,\n                'pretix.event.order.email.resend', user=user, auth=auth,\n                attach_tickets=True,\n            )\n\n    @property\n    def positions_with_tickets(self):\n        for op in self.positions.select_related('item'):\n            if not op.generate_ticket:\n                continue\n            yield op\n\n    def create_transactions(self, is_new=False, positions=None, fees=None, dt_now=None, migrated=False,\n                            _backfill_before_cancellation=False, save=True):\n        dt_now = dt_now or now()\n\n        # Count the transactions we already have\n        current_transaction_count = Counter()\n        if not is_new:\n            for t in Transaction.objects.filter(order=self):  # do not use related manager, we want to avoid cached data\n                current_transaction_count[Transaction.key(t)] += t.count\n\n        # Count the transactions we'd actually need\n        target_transaction_count = Counter()\n        if (_backfill_before_cancellation or self.status in (Order.STATUS_PENDING, Order.STATUS_PAID)) and not self.require_approval:\n            positions = self.positions.all() if positions is None else positions\n            for p in positions:\n                if p.canceled and not _backfill_before_cancellation:\n                    continue\n                target_transaction_count[Transaction.key(p)] += 1\n                p._transaction_key_reset()\n\n            fees = self.fees.all() if fees is None else fees\n            for f in fees:\n                if f.canceled and not _backfill_before_cancellation:\n                    continue\n                target_transaction_count[Transaction.key(f)] += 1\n                f._transaction_key_reset()\n\n        keys = set(target_transaction_count.keys()) | set(current_transaction_count.keys())\n        create = []\n        for k in keys:\n            positionid, itemid, variationid, subeventid, price, taxrate, taxruleid, taxvalue, feetype, internaltype = k\n            d = target_transaction_count[k] - current_transaction_count[k]\n            if d:\n                create.append(Transaction(\n                    order=self,\n                    datetime=dt_now,\n                    migrated=migrated,\n                    positionid=positionid,\n                    count=d,\n                    item_id=itemid,\n                    variation_id=variationid,\n                    subevent_id=subeventid,\n                    price=price,\n                    tax_rate=taxrate,\n                    tax_rule_id=taxruleid,\n                    tax_value=taxvalue,\n                    fee_type=feetype,\n                    internal_type=internaltype,\n                ))\n        create.sort(key=lambda t: (0 if t.count < 0 else 1, t.positionid or 0))\n        if save:\n            Transaction.objects.bulk_create(create)\n        self._transaction_key_reset()\n        _transactions_mark_order_clean(self.pk)\n        return create\n\n\ndef answerfile_name(instance, filename: str) -> str:\n    secret = get_random_string(length=32, allowed_chars=string.ascii_letters + string.digits)\n    event = (instance.cartposition if instance.cartposition else instance.orderposition.order).event\n    return 'cachedfiles/answers/{org}/{ev}/{secret}.{filename}'.format(\n        org=event.organizer.slug,\n        ev=event.slug,\n        secret=secret,\n        filename=escape_uri_path(filename),\n    )\n\n\nclass QuestionAnswer(models.Model):\n    \"\"\"\n    The answer to a Question, connected to an OrderPosition or CartPosition.\n\n    :param orderposition: The order position this is related to, or null if this is\n                          related to a cart position.\n    :type orderposition: OrderPosition\n    :param cartposition: The cart position this is related to, or null if this is related\n                         to an order position.\n    :type cartposition: CartPosition\n    :param question: The question this is an answer for\n    :type question: Question\n    :param answer: The actual answer data\n    :type answer: str\n    \"\"\"\n    orderposition = models.ForeignKey(\n        'OrderPosition', null=True, blank=True,\n        related_name='answers', on_delete=models.CASCADE\n    )\n    cartposition = models.ForeignKey(\n        'CartPosition', null=True, blank=True,\n        related_name='answers', on_delete=models.CASCADE\n    )\n    question = models.ForeignKey(\n        Question, related_name='answers', on_delete=models.CASCADE\n    )\n    options = models.ManyToManyField(\n        QuestionOption, related_name='answers', blank=True\n    )\n    answer = models.TextField()\n    file = models.FileField(\n        null=True, blank=True, upload_to=answerfile_name,\n        max_length=255\n    )\n\n    objects = ScopedManager(organizer='question__event__organizer')\n\n    class Meta:\n        unique_together = [['orderposition', 'question'], ['cartposition', 'question']]\n\n    @property\n    def backend_file_url(self):\n        if self.file:\n            if self.orderposition:\n                return reverse('control:event.order.download.answer', kwargs={\n                    'code': self.orderposition.order.code,\n                    'event': self.orderposition.order.event.slug,\n                    'organizer': self.orderposition.order.event.organizer.slug,\n                    'answer': self.pk,\n                })\n        return \"\"\n\n    @property\n    def frontend_file_url(self):\n        from pretix.multidomain.urlreverse import eventreverse\n\n        if self.file:\n            if self.orderposition:\n                url = eventreverse(self.orderposition.order.event, 'presale:event.order.download.answer', kwargs={\n                    'order': self.orderposition.order.code,\n                    'secret': self.orderposition.order.secret,\n                    'answer': self.pk,\n                })\n            else:\n                url = eventreverse(self.cartposition.event, 'presale:event.cart.download.answer', kwargs={\n                    'answer': self.pk,\n                })\n\n            return url\n        return \"\"\n\n    @property\n    def is_image(self):\n        return any(self.file.name.lower().endswith(e) for e in ('.jpg', '.png', '.gif', '.tiff', '.bmp', '.jpeg'))\n\n    @property\n    def file_name(self):\n        return self.file.name.split('.', 1)[-1]\n\n    def __str__(self):\n        if self.question.type == Question.TYPE_BOOLEAN and self.answer == \"True\":\n            return str(_(\"Yes\"))\n        elif self.question.type == Question.TYPE_BOOLEAN and self.answer == \"False\":\n            return str(_(\"No\"))\n        elif self.question.type == Question.TYPE_FILE:\n            return str(_(\"<file>\"))\n        elif self.question.type == Question.TYPE_DATETIME and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                if self.orderposition:\n                    tz = ZoneInfo(self.orderposition.order.event.settings.timezone)\n                    d = d.astimezone(tz)\n                return date_format(d, \"SHORT_DATETIME_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_DATE and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                return date_format(d, \"SHORT_DATE_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_TIME and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                return date_format(d, \"TIME_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_COUNTRYCODE and self.answer:\n            return Country(self.answer).name or self.answer\n        elif self.question.type == Question.TYPE_PHONENUMBER and self.answer:\n            try:\n                return PhoneNumber.from_string(self.answer).as_international\n            except NumberParseException:\n                return self.answer\n        else:\n            return self.answer\n\n    def save(self, *args, **kwargs):\n        if self.orderposition and self.cartposition:\n            raise ValueError('QuestionAnswer cannot be linked to an order and a cart position at the same time.')\n        if self.orderposition:\n            self.orderposition.order.touch()\n        super().save(*args, **kwargs)\n\n    def delete(self, **kwargs):\n        if self.orderposition:\n            self.orderposition.order.touch()\n        super().delete(**kwargs)\n\n\nclass AbstractPosition(models.Model):\n    \"\"\"\n    A position can either be one line of an order or an item placed in a cart.\n\n    :param subevent: The date in the event series, if event series are enabled\n    :type subevent: SubEvent\n    :param item: The selected item\n    :type item: Item\n    :param variation: The selected ItemVariation or null, if the item has no variations\n    :type variation: ItemVariation\n    :param datetime: The datetime this item was put into the cart\n    :type datetime: datetime\n    :param expires: The date until this item is guaranteed to be reserved\n    :type expires: datetime\n    :param price: The price of this item\n    :type price: decimal.Decimal\n    :param attendee_name_parts: The parts of the attendee's name, if entered.\n    :type attendee_name_parts: str\n    :param attendee_name_cached: The concatenated version of the attendee's name, if entered.\n    :type attendee_name_cached: str\n    :param attendee_email: The attendee's email, if entered.\n    :type attendee_email: str\n    :param voucher: A voucher that has been applied to this sale\n    :type voucher: Voucher\n    :param meta_info: Additional meta information on the position, JSON-encoded.\n    :type meta_info: str\n    :param seat: Seat, if reserved seating is used.\n    :type seat: Seat\n    \"\"\"\n    subevent = models.ForeignKey(\n        SubEvent,\n        null=True, blank=True,\n        on_delete=models.PROTECT,\n        verbose_name=pgettext_lazy(\"subevent\", \"Date\"),\n    )\n    item = models.ForeignKey(\n        Item,\n        verbose_name=_(\"Item\"),\n        on_delete=models.PROTECT\n    )\n    variation = models.ForeignKey(\n        ItemVariation,\n        null=True, blank=True,\n        verbose_name=_(\"Variation\"),\n        on_delete=models.PROTECT\n    )\n    price = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Price\")\n    )\n    attendee_name_cached = models.CharField(\n        max_length=255,\n        verbose_name=_(\"Attendee name\"),\n        blank=True, null=True,\n        help_text=_(\"Empty, if this product is not an admission ticket\")\n    )\n    attendee_name_parts = models.JSONField(\n        blank=True, default=dict\n    )\n    attendee_email = models.EmailField(\n        verbose_name=_(\"Attendee email\"),\n        blank=True, null=True,\n        help_text=_(\"Empty, if this product is not an admission ticket\")\n    )\n    voucher = models.ForeignKey(\n        'Voucher', null=True, blank=True, on_delete=models.PROTECT\n    )\n    used_membership = models.ForeignKey(\n        'Membership', null=True, blank=True, on_delete=models.PROTECT\n    )\n    addon_to = models.ForeignKey(\n        'self', null=True, blank=True, on_delete=models.PROTECT, related_name='addons'\n    )\n    meta_info = models.TextField(\n        verbose_name=_(\"Meta information\"),\n        null=True, blank=True\n    )\n    seat = models.ForeignKey(\n        'Seat', null=True, blank=True, on_delete=models.PROTECT\n    )\n    is_bundled = models.BooleanField(default=False)\n\n    discount = models.ForeignKey(\n        'Discount', null=True, blank=True, on_delete=models.RESTRICT\n    )\n\n    company = models.CharField(max_length=255, blank=True, verbose_name=_('Company name'), null=True)\n    street = models.TextField(verbose_name=_('Address'), blank=True, null=True)\n    zipcode = models.CharField(max_length=30, verbose_name=_('ZIP code'), blank=True, null=True)\n    city = models.CharField(max_length=255, verbose_name=_('City'), blank=True, null=True)\n    country = FastCountryField(verbose_name=_('Country'), blank=True, blank_label=_('Select country'), null=True)\n    state = models.CharField(max_length=255, verbose_name=pgettext_lazy('address', 'State'), blank=True, null=True)\n\n    class Meta:\n        abstract = True\n\n    @property\n    def meta_info_data(self):\n        if self.meta_info:\n            return json.loads(self.meta_info)\n        else:\n            return {}\n\n    @property\n    def item_and_variation(self):\n        return self.item, self.variation\n\n    @meta_info_data.setter\n    def meta_info_data(self, d):\n        self.meta_info = json.dumps(d)\n\n    def cache_answers(self, all=True):\n        \"\"\"\n        Creates two properties on the object.\n        (1) answ: a dictionary of question.id \u2192 answer string\n        (2) questions: a list of Question objects, extended by an 'answer' property\n        \"\"\"\n        self.answ = {}\n        for a in getattr(self, 'answerlist', self.answers.all()):  # use prefetch_related cache from get_cart\n            self.answ[a.question_id] = a\n\n        # We need to clone our question objects, otherwise we will override the cached\n        # answers of other items in the same cart if the question objects have been\n        # selected via prefetch_related\n        if not all:\n            if hasattr(self.item, 'questions_to_ask'):\n                questions = list(copy.copy(q) for q in self.item.questions_to_ask)\n            else:\n                questions = list(copy.copy(q) for q in self.item.questions.filter(ask_during_checkin=False,\n                                                                                  hidden=False))\n        else:\n            questions = list(copy.copy(q) for q in self.item.questions.all())\n\n        question_cache = {\n            q.pk: q for q in questions\n        }\n\n        def question_is_visible(parentid, qvals):\n            if parentid not in question_cache:\n                return False\n            parentq = question_cache[parentid]\n            if parentq.dependency_question_id and not question_is_visible(parentq.dependency_question_id, parentq.dependency_values):\n                return False\n            if parentid not in self.answ:\n                return False\n            return (\n                ('True' in qvals and self.answ[parentid].answer == 'True')\n                or ('False' in qvals and self.answ[parentid].answer == 'False')\n                or (any(qval in [o.identifier for o in self.answ[parentid].options.all()] for qval in qvals))\n            )\n\n        self.questions = []\n        for q in questions:\n            if q.id in self.answ:\n                q.answer = self.answ[q.id]\n                q.answer.question = q  # cache object\n            else:\n                q.answer = \"\"\n            if not q.dependency_question_id or question_is_visible(q.dependency_question_id, q.dependency_values):\n                self.questions.append(q)\n\n    @property\n    def net_price(self):\n        return self.price - self.tax_value\n\n    @property\n    def quotas(self):\n        return (self.item.quotas.filter(subevent=self.subevent)\n                if self.variation is None\n                else self.variation.quotas.filter(subevent=self.subevent))\n\n    def save(self, *args, **kwargs):\n        update_fields = kwargs.get('update_fields', set())\n        if 'attendee_name_parts' in update_fields:\n            kwargs['update_fields'] = {'attendee_name_cached'}.union(kwargs['update_fields'])\n\n        name = self.attendee_name\n        if name != self.attendee_name_cached:\n            self.attendee_name_cached = name\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'attendee_name_cached'}.union(kwargs['update_fields'])\n\n        if self.attendee_name_parts is None:\n            self.attendee_name_parts = {}\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'attendee_name_parts'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n    @property\n    def attendee_name(self):\n        return build_name(self.attendee_name_parts, fallback_scheme=lambda: self.event.settings.name_scheme)\n\n    @property\n    def attendee_name_all_components(self):\n        return build_name(self.attendee_name_parts, \"concatenation_all_components\", fallback_scheme=lambda: self.event.settings.name_scheme)\n\n    @property\n    def state_name(self):\n        sd = pycountry.subdivisions.get(code='{}-{}'.format(self.country, self.state))\n        if sd:\n            return sd.name\n        return self.state\n\n    @property\n    def state_for_address(self):\n        from pretix.base.settings import COUNTRIES_WITH_STATE_IN_ADDRESS\n        if not self.state or str(self.country) not in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            return \"\"\n        if COUNTRIES_WITH_STATE_IN_ADDRESS[str(self.country)][1] == 'long':\n            return self.state_name\n        return self.state\n\n    def address_format(self):\n        lines = [\n            self.attendee_name,\n            self.company,\n            self.street,\n            (self.zipcode or '') + ' ' + (self.city or '') + ' ' + (self.state_for_address or ''),\n            self.country.name\n        ]\n        lines = [r.strip() for r in lines if r]\n        return '\\n'.join(lines).strip()\n\n    def requires_approval(self, invoice_address=None):\n        if self.item.require_approval:\n            return True\n        if self.variation and self.variation.require_approval:\n            return True\n        if self.item.tax_rule and self.item.tax_rule._require_approval(invoice_address):\n            return True\n        return False\n\n\nclass OrderPayment(models.Model):\n    \"\"\"\n    Represents a payment or payment attempt for an order.\n\n\n    :param id: A globally unique ID for this payment\n    :type id:\n    :param local_id: An ID of this payment, counting from one for every order independently.\n    :type local_id: int\n    :param state: The state of the payment, one of ``created``, ``pending``, ``confirmed``, ``failed``,\n      ``canceled``, or ``refunded``.\n    :type state: str\n    :param amount: The payment amount\n    :type amount: Decimal\n    :param order: The order that is paid\n    :type order: Order\n    :param created: The creation time of this record\n    :type created: datetime\n    :param payment_date: The completion time of this payment\n    :type payment_date: datetime\n    :param provider: The payment provider in use\n    :type provider: str\n    :param info: Provider-specific meta information (in JSON format)\n    :type info: str\n    :param fee: The ``OrderFee`` object used to track the fee for this order.\n    :type fee: pretix.base.models.OrderFee\n    :param process_initiated: Only for internal use inside pretix.presale to check which payments have started\n                              the execution process.\n    :type process_initiated: bool\n    \"\"\"\n    PAYMENT_STATE_CREATED = 'created'\n    PAYMENT_STATE_PENDING = 'pending'\n    PAYMENT_STATE_CONFIRMED = 'confirmed'\n    PAYMENT_STATE_FAILED = 'failed'\n    PAYMENT_STATE_CANCELED = 'canceled'\n    PAYMENT_STATE_REFUNDED = 'refunded'\n\n    PAYMENT_STATES = (\n        (PAYMENT_STATE_CREATED, pgettext_lazy('payment_state', 'created')),\n        (PAYMENT_STATE_PENDING, pgettext_lazy('payment_state', 'pending')),\n        (PAYMENT_STATE_CONFIRMED, pgettext_lazy('payment_state', 'confirmed')),\n        (PAYMENT_STATE_CANCELED, pgettext_lazy('payment_state', 'canceled')),\n        (PAYMENT_STATE_FAILED, pgettext_lazy('payment_state', 'failed')),\n        (PAYMENT_STATE_REFUNDED, pgettext_lazy('payment_state', 'refunded')),\n    )\n    local_id = models.PositiveIntegerField()\n    state = models.CharField(\n        max_length=190, choices=PAYMENT_STATES\n    )\n    amount = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Amount\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='payments',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True\n    )\n    payment_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    provider = models.CharField(\n        null=True, blank=True,\n        max_length=255,\n        verbose_name=_(\"Payment provider\")\n    )\n    info = models.TextField(\n        verbose_name=_(\"Payment information\"),\n        null=True, blank=True\n    )\n    fee = models.ForeignKey(\n        'OrderFee',\n        null=True, blank=True, related_name='payments', on_delete=models.SET_NULL\n    )\n    migrated = models.BooleanField(default=False)\n    process_initiated = models.BooleanField(\n        null=True  # null = created before this field was introduced\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n\n    class Meta:\n        ordering = ('local_id',)\n\n    def __str__(self):\n        return self.full_id\n\n    @property\n    def info_data(self):\n        \"\"\"\n        This property allows convenient access to the data stored in the ``info``\n        attribute by automatically encoding and decoding the content as JSON.\n        \"\"\"\n        return json.loads(self.info) if self.info else {}\n\n    @info_data.setter\n    def info_data(self, d):\n        self.info = json.dumps(d, sort_keys=True)\n\n    @cached_property\n    def payment_provider(self):\n        \"\"\"\n        Cached access to an instance of the payment provider in use.\n        \"\"\"\n        return self.order.event.get_payment_providers(cached=True).get(self.provider)\n\n    @transaction.atomic()\n    def _mark_paid_inner(self, force, count_waitinglist, user, auth, ignore_date=False, overpaid=False):\n        from pretix.base.signals import order_paid\n        can_be_paid = self.order._can_be_paid(count_waitinglist=count_waitinglist, ignore_date=ignore_date, force=force)\n        if can_be_paid is not True:\n            self.order.log_action('pretix.event.order.quotaexceeded', {\n                'message': can_be_paid\n            }, user=user, auth=auth)\n            raise Quota.QuotaExceededException(can_be_paid)\n        status_change = self.order.status != Order.STATUS_PENDING\n        self.order.status = Order.STATUS_PAID\n        self.order.save(update_fields=['status'])\n\n        self.order.log_action('pretix.event.order.paid', {\n            'provider': self.provider,\n            'info': self.info,\n            'date': self.payment_date,\n            'force': force\n        }, user=user, auth=auth)\n\n        if overpaid:\n            self.order.log_action('pretix.event.order.overpaid', {}, user=user, auth=auth)\n        order_paid.send(self.order.event, order=self.order)\n        if status_change:\n            self.order.create_transactions()\n\n    def fail(self, info=None, user=None, auth=None, log_data=None, send_mail=True):\n        \"\"\"\n        Marks the order as failed and sets info to ``info``, but only if the order is in ``created`` or ``pending``\n        state. This is equivalent to setting ``state`` to ``OrderPayment.PAYMENT_STATE_FAILED`` and logging a failure,\n        but it adds strong database logging since we do not want to report a failure for an order that has just\n        been marked as paid.\n        :param send_mail: Whether an email should be sent to the user about this event (default: ``True``).\n        \"\"\"\n        with transaction.atomic():\n            locked_instance = OrderPayment.objects.select_for_update(of=OF_SELF).get(pk=self.pk)\n            if locked_instance.state not in (OrderPayment.PAYMENT_STATE_CREATED, OrderPayment.PAYMENT_STATE_PENDING):\n                # Race condition detected, this payment is already confirmed\n                logger.info('Failed payment {} but ignored due to likely race condition.'.format(\n                    self.full_id,\n                ))\n                return False\n\n            if isinstance(info, str):\n                locked_instance.info = info\n            elif info:\n                locked_instance.info_data = info\n            locked_instance.state = OrderPayment.PAYMENT_STATE_FAILED\n            locked_instance.save(update_fields=['state', 'info'])\n\n        self.refresh_from_db()\n        self.order.log_action('pretix.event.order.payment.failed', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n            'info': info,\n            'data': log_data,\n        }, user=user, auth=auth)\n\n        if send_mail:\n            with language(self.order.locale, self.order.event.settings.region):\n                email_subject = self.order.event.settings.mail_subject_order_payment_failed\n                email_template = self.order.event.settings.mail_text_order_payment_failed\n                email_context = get_email_context(event=self.order.event, order=self.order)\n                self.order.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.payment_failed', user=user, auth=auth,\n                )\n\n        return True\n\n    def confirm(self, count_waitinglist=True, send_mail=True, force=False, user=None, auth=None, mail_text='',\n                ignore_date=False, lock=True, payment_date=None, generate_invoice=True):\n        \"\"\"\n        Marks the payment as complete. If possible, this also marks the order as paid if no further\n        payment is required\n\n        :param count_waitinglist: Whether, when calculating quota, people on the waiting list should be taken into\n                                  consideration (default: ``True``).\n        :type count_waitinglist: boolean\n        :param force: Whether this payment should be marked as paid even if no remaining\n                      quota is available (default: ``False``).\n        :param ignore_date: Whether this order should be marked as paid even when the last date of payments is over.\n        :type force: boolean\n        :param send_mail: Whether an email should be sent to the user about this event (default: ``True``).\n        :type send_mail: boolean\n        :param user: The user who performed the change\n        :param auth: The API auth token that performed the change\n        :param mail_text: Additional text to be included in the email\n        :type mail_text: str\n        :raises Quota.QuotaExceededException: if the quota is exceeded and ``force`` is ``False``\n        \"\"\"\n        with transaction.atomic():\n            locked_instance = OrderPayment.objects.select_for_update(of=OF_SELF).get(pk=self.pk)\n            if locked_instance.state == self.PAYMENT_STATE_CONFIRMED:\n                # Race condition detected, this payment is already confirmed\n                logger.info('Confirmed payment {} but ignored due to likely race condition.'.format(\n                    self.full_id,\n                ))\n                return\n\n            locked_instance.state = self.PAYMENT_STATE_CONFIRMED\n            locked_instance.payment_date = payment_date or now()\n            locked_instance.info = self.info  # required for backwards compatibility\n            locked_instance.save(update_fields=['state', 'payment_date', 'info'])\n\n            # Do a cheap manual \"refresh from db\" on non-complex fields\n            for field in self._meta.concrete_fields:\n                if not field.is_relation:\n                    setattr(self, field.attname, getattr(locked_instance, field.attname))\n\n        self.refresh_from_db()\n\n        self.order.log_action('pretix.event.order.payment.confirmed', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n        }, user=user, auth=auth)\n\n        if self.order.status in (Order.STATUS_PAID, Order.STATUS_CANCELED):\n            logger.info('Confirmed payment {} but order is in status {}.'.format(self.full_id, self.order.status))\n            return\n\n        payment_sum = self.order.payments.filter(\n            state__in=(self.PAYMENT_STATE_CONFIRMED, self.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.order.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        if payment_sum - refund_sum < self.order.total:\n            logger.info('Confirmed payment {} but payment sum is {} and refund sum is {}.'.format(\n                self.full_id, payment_sum, refund_sum\n            ))\n            return\n\n        self._mark_order_paid(count_waitinglist, send_mail, force, user, auth, mail_text, ignore_date, lock, payment_sum - refund_sum,\n                              generate_invoice)\n\n    def _mark_order_paid(self, count_waitinglist=True, send_mail=True, force=False, user=None, auth=None, mail_text='',\n                         ignore_date=False, lock=True, payment_refund_sum=0, allow_generate_invoice=True):\n        from pretix.base.services.invoices import (\n            generate_invoice, invoice_qualified,\n        )\n\n        if (self.order.status == Order.STATUS_PENDING and self.order.expires > now() + timedelta(seconds=LOCK_TIMEOUT * 2)) or not lock:\n            # Performance optimization. In this case, there's really no reason to lock everything and an atomic\n            # database transaction is more than enough.\n            lockfn = NoLockManager\n        else:\n            lockfn = self.order.event.lock\n\n        with lockfn():\n            self._mark_paid_inner(force, count_waitinglist, user, auth, overpaid=payment_refund_sum > self.order.total,\n                                  ignore_date=ignore_date)\n\n        invoice = None\n        if invoice_qualified(self.order) and allow_generate_invoice:\n            invoices = self.order.invoices.filter(is_cancellation=False).count()\n            cancellations = self.order.invoices.filter(is_cancellation=True).count()\n            gen_invoice = (\n                (invoices == 0 and self.order.event.settings.get('invoice_generate') in ('True', 'paid')) or\n                0 < invoices <= cancellations\n            )\n            if gen_invoice:\n                invoice = generate_invoice(\n                    self.order,\n                    trigger_pdf=not send_mail or not self.order.event.settings.invoice_email_attachment\n                )\n\n        if send_mail and self.order.sales_channel in self.order.event.settings.mail_sales_channel_placed_paid:\n            self._send_paid_mail(invoice, user, mail_text)\n            if self.order.event.settings.mail_send_order_paid_attendee:\n                for p in self.order.positions.all():\n                    if p.addon_to_id is None and p.attendee_email and p.attendee_email != self.order.email:\n                        self._send_paid_mail_attendee(p, user)\n\n    def _send_paid_mail_attendee(self, position, user):\n        from pretix.base.services.mail import SendMailException\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.order.event.settings.mail_text_order_paid_attendee\n            email_subject = self.order.event.settings.mail_subject_order_paid_attendee\n            email_context = get_email_context(event=self.order.event, order=self.order, position=position)\n            try:\n                position.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.order_paid', user,\n                    invoices=[],\n                    attach_tickets=True,\n                    attach_ical=self.order.event.settings.mail_attach_ical\n                )\n            except SendMailException:\n                logger.exception('Order paid email could not be sent')\n\n    def _send_paid_mail(self, invoice, user, mail_text):\n        from pretix.base.services.mail import SendMailException\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.order.event.settings.mail_text_order_paid\n            email_subject = self.order.event.settings.mail_subject_order_paid\n            email_context = get_email_context(event=self.order.event, order=self.order, payment_info=mail_text)\n            try:\n                self.order.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.order_paid', user,\n                    invoices=[invoice] if invoice and self.order.event.settings.invoice_email_attachment else [],\n                    attach_tickets=True,\n                    attach_ical=self.order.event.settings.mail_attach_ical\n                )\n            except SendMailException:\n                logger.exception('Order paid email could not be sent')\n\n    @property\n    def refunded_amount(self):\n        \"\"\"\n        The sum of all refund amounts in ``done``, ``transit``, or ``created`` states associated\n        with this payment.\n        \"\"\"\n        return self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n\n    @property\n    def full_id(self):\n        \"\"\"\n        The full human-readable ID of this payment, constructed by the order code and the ``local_id``\n        field with ``-P-`` in between.\n        :return:\n        \"\"\"\n        return '{}-P-{}'.format(self.order.code, self.local_id)\n\n    def save(self, *args, **kwargs):\n        if not self.local_id:\n            self.local_id = (self.order.payments.aggregate(m=Max('local_id'))['m'] or 0) + 1\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'local_id'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n    def create_external_refund(self, amount=None, execution_date=None, info='{}'):\n        \"\"\"\n        This should be called to create an OrderRefund object when a refund has triggered\n        by an external source, e.g. when a credit card payment has been refunded by the\n        credit card provider.\n\n        :param amount: Amount to refund. If not given, the full payment amount will be used.\n        :type amount: Decimal\n        :param execution_date: Date of the refund. Defaults to the current time.\n        :type execution_date: datetime\n        :param info: Additional information, defaults to ``\"{}\"``.\n        :type info: str\n        :return: OrderRefund\n        \"\"\"\n        r = self.order.refunds.create(\n            state=OrderRefund.REFUND_STATE_EXTERNAL,\n            source=OrderRefund.REFUND_SOURCE_EXTERNAL,\n            amount=amount if amount is not None else self.amount,\n            order=self.order,\n            payment=self,\n            execution_date=execution_date or now(),\n            provider=self.provider,\n            info=info\n        )\n        self.order.log_action('pretix.event.order.refund.created.externally', {\n            'local_id': r.local_id,\n            'provider': r.provider,\n        })\n\n        if self.order.pending_sum + r.amount == Decimal('0.00'):\n            r.done()\n\n        return r\n\n\nclass OrderRefund(models.Model):\n    \"\"\"\n    Represents a refund or refund attempt for an order.\n\n    :param id: A globally unique ID for this refund\n    :type id:\n    :param local_id: An ID of this refund, counting from one for every order independently.\n    :type local_id: int\n    :param state: The state of the refund, one of ``created``, ``transit``, ``external``, ``canceled``,\n      ``failed``, or ``done``.\n    :type state: str\n    :param source: How this refund was started, one of ``buyer``, ``admin``, or ``external``.\n    :param amount: The refund amount\n    :type amount: Decimal\n    :param order: The order that is refunded\n    :type order: Order\n    :param created: The creation time of this record\n    :type created: datetime\n    :param execution_date: The completion time of this refund\n    :type execution_date: datetime\n    :param provider: The payment provider in use\n    :type provider: str\n    :param info: Provider-specific meta information in JSON format\n    :type info: dict\n    \"\"\"\n    # REFUND_STATE_REQUESTED = 'requested'\n    # REFUND_STATE_APPROVED = 'approved'\n    REFUND_STATE_EXTERNAL = 'external'\n    REFUND_STATE_TRANSIT = 'transit'\n    REFUND_STATE_DONE = 'done'\n    # REFUND_STATE_REJECTED = 'rejected'\n    REFUND_STATE_CANCELED = 'canceled'\n    REFUND_STATE_CREATED = 'created'\n    REFUND_STATE_FAILED = 'failed'\n\n    REFUND_STATES = (\n        # (REFUND_STATE_REQUESTED, pgettext_lazy('refund_state', 'requested')),\n        # (REFUND_STATE_APPROVED, pgettext_lazy('refund_state', 'approved')),\n        (REFUND_STATE_EXTERNAL, pgettext_lazy('refund_state', 'started externally')),\n        (REFUND_STATE_CREATED, pgettext_lazy('refund_state', 'created')),\n        (REFUND_STATE_TRANSIT, pgettext_lazy('refund_state', 'in transit')),\n        (REFUND_STATE_DONE, pgettext_lazy('refund_state', 'done')),\n        (REFUND_STATE_FAILED, pgettext_lazy('refund_state', 'failed')),\n        # (REFUND_STATE_REJECTED, pgettext_lazy('refund_state', 'rejected')),\n        (REFUND_STATE_CANCELED, pgettext_lazy('refund_state', 'canceled')),\n    )\n\n    REFUND_SOURCE_BUYER = 'buyer'\n    REFUND_SOURCE_ADMIN = 'admin'\n    REFUND_SOURCE_EXTERNAL = 'external'\n\n    REFUND_SOURCES = (\n        (REFUND_SOURCE_ADMIN, pgettext_lazy('refund_source', 'Organizer')),\n        (REFUND_SOURCE_BUYER, pgettext_lazy('refund_source', 'Customer')),\n        (REFUND_SOURCE_EXTERNAL, pgettext_lazy('refund_source', 'External')),\n    )\n\n    local_id = models.PositiveIntegerField()\n    state = models.CharField(\n        max_length=190, choices=REFUND_STATES\n    )\n    source = models.CharField(\n        max_length=190, choices=REFUND_SOURCES\n    )\n    amount = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Amount\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='refunds',\n        on_delete=models.PROTECT\n    )\n    payment = models.ForeignKey(\n        OrderPayment,\n        null=True, blank=True,\n        related_name='refunds',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True\n    )\n    execution_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    provider = models.CharField(\n        null=True, blank=True,\n        max_length=255,\n        verbose_name=_(\"Payment provider\")\n    )\n    comment = models.TextField(\n        verbose_name=_(\"Refund reason\"),\n        help_text=_('May be shown to the end user or used e.g. as part of a payment reference.'),\n        null=True, blank=True\n    )\n    info = models.TextField(\n        verbose_name=_(\"Payment information\"),\n        null=True, blank=True\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n\n    class Meta:\n        ordering = ('local_id',)\n\n    def __str__(self):\n        return self.full_id\n\n    @property\n    def info_data(self):\n        \"\"\"\n        This property allows convenient access to the data stored in the ``info``\n        attribute by automatically encoding and decoding the content as JSON.\n        \"\"\"\n        return json.loads(self.info) if self.info else {}\n\n    @info_data.setter\n    def info_data(self, d):\n        self.info = json.dumps(d, sort_keys=True)\n\n    @cached_property\n    def payment_provider(self):\n        \"\"\"\n        Cached access to an instance of the payment provider in use.\n        \"\"\"\n        return self.order.event.get_payment_providers().get(self.provider)\n\n    @transaction.atomic\n    def done(self, user=None, auth=None):\n        \"\"\"\n        Marks the refund as complete. This does not modify the state of the order.\n\n        :param user: The user who performed the change\n        :param auth: The API auth token that performed the change\n        \"\"\"\n        self.state = self.REFUND_STATE_DONE\n        self.execution_date = self.execution_date or now()\n        self.save()\n\n        self.order.log_action('pretix.event.order.refund.done', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n        }, user=user, auth=auth)\n\n        if self.payment and self.payment.refunded_amount >= self.payment.amount:\n            self.payment.state = OrderPayment.PAYMENT_STATE_REFUNDED\n            self.payment.save(update_fields=['state'])\n\n    @property\n    def full_id(self):\n        \"\"\"\n        The full human-readable ID of this refund, constructed by the order code and the ``local_id``\n        field with ``-R-`` in between.\n        :return:\n        \"\"\"\n        return '{}-R-{}'.format(self.order.code, self.local_id)\n\n    def save(self, *args, **kwargs):\n        if not self.local_id:\n            self.local_id = (self.order.refunds.aggregate(m=Max('local_id'))['m'] or 0) + 1\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'local_id'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n\nclass ActivePositionManager(ScopedManager(organizer='order__event__organizer').__class__):\n    def get_queryset(self):\n        return super().get_queryset().filter(canceled=False)\n\n\nclass OrderFee(models.Model):\n    \"\"\"\n    An OrderFee object represents a fee that is added to the order total independently of\n    the actual positions. This might for example be a payment or a shipping fee.\n\n    The default ``OrderFee.objects`` manager only contains fees that are not ``canceled``. If\n    you ant all objects, you need to use ``OrderFee.all`` instead.\n\n    :param value: Gross price of this fee\n    :type value: Decimal\n    :param order: Order this fee is charged with\n    :type order: Order\n    :param fee_type: The type of the fee, currently ``payment``, ``shipping``, ``service``, ``giftcard``, or ``other``.\n    :type fee_type: str\n    :param description: A human-readable description of the fee\n    :type description: str\n    :param internal_type: An internal string to group fees by, e.g. the identifier string of a payment provider\n    :type internal_type: str\n    :param tax_rate: The tax rate applied to this fee\n    :type tax_rate: Decimal\n    :param tax_rule: The tax rule applied to this fee\n    :type tax_rule: TaxRule\n    :param tax_value: The tax amount included in the price\n    :type tax_value: Decimal\n    :param canceled: True, if this position is canceled and should no longer be regarded\n    :type canceled: bool\n    \"\"\"\n    FEE_TYPE_PAYMENT = \"payment\"\n    FEE_TYPE_SHIPPING = \"shipping\"\n    FEE_TYPE_SERVICE = \"service\"\n    FEE_TYPE_CANCELLATION = \"cancellation\"\n    FEE_TYPE_INSURANCE = \"insurance\"\n    FEE_TYPE_OTHER = \"other\"\n    FEE_TYPE_GIFTCARD = \"giftcard\"\n    FEE_TYPES = (\n        (FEE_TYPE_PAYMENT, _(\"Payment fee\")),\n        (FEE_TYPE_SHIPPING, _(\"Shipping fee\")),\n        (FEE_TYPE_SERVICE, _(\"Service fee\")),\n        (FEE_TYPE_CANCELLATION, _(\"Cancellation fee\")),\n        (FEE_TYPE_INSURANCE, _(\"Insurance fee\")),\n        (FEE_TYPE_OTHER, _(\"Other fees\")),\n        (FEE_TYPE_GIFTCARD, _(\"Gift card\")),\n    )\n\n    value = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Value\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='all_fees',\n        on_delete=models.PROTECT\n    )\n    fee_type = models.CharField(\n        max_length=100, choices=FEE_TYPES\n    )\n    description = models.CharField(max_length=190, blank=True)\n    internal_type = models.CharField(max_length=255, blank=True)\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n    canceled = models.BooleanField(default=False)\n\n    all = ScopedManager(organizer='order__event__organizer')\n    objects = ActivePositionManager()\n\n    @property\n    def net_value(self):\n        return self.value - self.tax_value\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def refresh_from_db(self, using=None, fields=None):\n        \"\"\"\n        Reload field values from the database. Similar to django's implementation\n        with adjustment for our method that forces us to create ``Transaction`` instances.\n        \"\"\"\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n        return super().refresh_from_db(using, fields)\n\n    def _transaction_key_reset(self):\n        self.__initial_transaction_key = Transaction.key(self)\n        self.__initial_canceled = self.canceled\n\n    def __str__(self):\n        if self.description:\n            return '{} - {}'.format(self.get_fee_type_display(), self.description)\n        else:\n            return self.get_fee_type_display()\n\n    def __repr__(self):\n        return '<OrderFee: type %s, value %d>' % (\n            self.fee_type, self.value\n        )\n\n    def _calculate_tax(self, tax_rule=None):\n        if tax_rule:\n            self.tax_rule = tax_rule\n\n        try:\n            ia = self.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = None\n\n        if not self.tax_rule and self.fee_type == \"payment\" and self.order.event.settings.tax_rate_default:\n            self.tax_rule = self.order.event.settings.tax_rate_default\n\n        if self.tax_rule:\n            tax = self.tax_rule.tax(self.value, base_price_is='gross', invoice_address=ia, force_fixed_gross_price=True)\n            self.tax_rate = tax.rate\n            self.tax_value = tax.tax\n        else:\n            self.tax_value = Decimal('0.00')\n            self.tax_rate = Decimal('0.00')\n\n    def save(self, *args, **kwargs):\n        if self.tax_rule and not self.tax_rule.rate and not self.tax_rule.pk:\n            self.tax_rule = None\n\n        if self.tax_rate is None:\n            self._calculate_tax()\n        self.order.touch()\n\n        if not self.get_deferred_fields():\n            if Transaction.key(self) != self.__initial_transaction_key or self.canceled != self.__initial_canceled or not self.pk:\n                _transactions_mark_order_dirty(self.order_id, using=kwargs.get('using', None))\n        elif not kwargs.get('force_save_with_deferred_fields', None):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        return super().save(*args, **kwargs)\n\n    def delete(self, **kwargs):\n        self.order.touch()\n        super().delete(**kwargs)\n\n\nclass OrderPosition(AbstractPosition):\n    \"\"\"\n    An OrderPosition is one line of an order, representing one ordered item\n    of a specified type (or variation). This has all properties of\n    AbstractPosition.\n\n    The default ``OrderPosition.objects`` manager only contains fees that are not ``canceled``. If\n    you want all objects, you need to use ``OrderPosition.all`` instead.\n\n    :param order: The order this position is a part of\n    :type order: Order\n    :param positionid: A local ID of this position, counted for each order individually\n    :type positionid: int\n    :param tax_rate: The tax rate applied to this position\n    :type tax_rate: Decimal\n    :param tax_rule: The tax rule applied to this position\n    :type tax_rule: TaxRule\n    :param tax_value: The tax amount included in the price\n    :type tax_value: Decimal\n    :param secret: The secret used for ticket QR codes\n    :type secret: str\n    :param canceled: True, if this position is canceled and should no longer be regarded\n    :type canceled: bool\n    :param pseudonymization_id: The QR code content for lead scanning\n    :type pseudonymization_id: str\n    :param blocked: A list of reasons why this order position is blocked. Blocked positions can't be used for check-in and\n                    other purposes. Each entry should be a short string that can be translated into a human-readable\n                    description by a plugin. If the position is not blocked, the value must be ``None``, not an empty\n                    list.\n    :type blocked: list\n    :param ignore_from_quota_while_blocked: Ignore this order position from quota, as long as ``blocked`` is set. Only\n                                            to be used carefully by specific plugins.\n    :type ignore_from_quota_while_blocked: boolean\n    :param valid_from: The ticket will not be considered valid before this date. If the value is ``None``, no check on\n                       ticket level is made.\n    :type valid_from: datetime\n    :param valid_until: The ticket will not be considered valid after this date. If the value is ``None``, no check on\n                       ticket level is made.\n    :type valid_until: datetime\n    \"\"\"\n    positionid = models.PositiveIntegerField(default=1)\n\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='all_positions',\n        on_delete=models.PROTECT\n    )\n\n    voucher_budget_use = models.DecimalField(\n        max_digits=13, decimal_places=2, null=True, blank=True,\n    )\n\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n\n    secret = models.CharField(max_length=255, null=False, blank=False, db_index=True)\n    web_secret = models.CharField(max_length=32, default=generate_secret, db_index=True)\n    pseudonymization_id = models.CharField(\n        max_length=16,\n        unique=True,\n        db_index=True\n    )\n\n    canceled = models.BooleanField(default=False)\n\n    blocked = models.JSONField(null=True, blank=True)\n    ignore_from_quota_while_blocked = models.BooleanField(default=False)\n    valid_from = models.DateTimeField(\n        verbose_name=_(\"Valid from\"),\n        null=True,\n        blank=True,\n    )\n    valid_until = models.DateTimeField(\n        verbose_name=_(\"Valid until\"),\n        null=True,\n        blank=True,\n    )\n\n    all = ScopedManager(organizer='order__event__organizer')\n    objects = ActivePositionManager()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def refresh_from_db(self, using=None, fields=None):\n        \"\"\"\n        Reload field values from the database. Similar to django's implementation\n        with adjustment for our method that forces us to create ``Transaction`` instances.\n        \"\"\"\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n        return super().refresh_from_db(using, fields)\n\n    def _transaction_key_reset(self):\n        self.__initial_transaction_key = Transaction.key(self)\n        self.__initial_canceled = self.canceled\n\n    class Meta:\n        verbose_name = _(\"Order position\")\n        verbose_name_plural = _(\"Order positions\")\n        ordering = (\"positionid\", \"id\")\n\n    @cached_property\n    def sort_key(self):\n        return self.addon_to.positionid if self.addon_to else self.positionid, self.addon_to_id or 0, self.positionid\n\n    @cached_property\n    def require_checkin_attention(self):\n        if self.order.checkin_attention or self.item.checkin_attention or (self.variation_id and self.variation.checkin_attention):\n            return True\n        return False\n\n    @property\n    def checkins(self):\n        \"\"\"\n        Related manager for all successful checkins. Use ``all_checkins`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_checkins(manager='objects')\n\n    @property\n    def generate_ticket(self):\n        if self.item.generate_tickets is not None:\n            return self.item.generate_tickets\n        if self.blocked:\n            return False\n        return (\n            (self.order.event.settings.ticket_download_addons or not self.addon_to_id) and\n            (self.event.settings.ticket_download_nonadm or self.item.admission)\n        )\n\n    @property\n    def blocked_reasons(self):\n        from ..signals import orderposition_blocked_display\n\n        if not self.blocked:\n            return []\n\n        reasons = {}\n        for b in self.blocked:\n            for recv, response in orderposition_blocked_display.send(self.event, orderposition=self, block_name=b):\n                if response:\n                    reasons[b] = response\n                    break\n            else:\n                reasons[b] = b\n        return reasons\n\n    @classmethod\n    def transform_cart_positions(cls, cp: List, order) -> list:\n        from . import Voucher\n\n        ops = []\n        cp_mapping = {}\n        # The sorting key ensures that all addons come directly after the position they refer to\n        for i, cartpos in enumerate(sorted(cp, key=lambda c: c.sort_key)):\n            op = OrderPosition(order=order)\n            for f in AbstractPosition._meta.fields:\n                if f.name == 'addon_to':\n                    setattr(op, f.name, cp_mapping.get(cartpos.addon_to_id))\n                else:\n                    setattr(op, f.name, getattr(cartpos, f.name))\n            op._calculate_tax()\n            if cartpos.voucher:\n                op.voucher_budget_use = cartpos.listed_price - cartpos.price_after_voucher\n\n            if cartpos.item.validity_mode:\n                valid_from, valid_until = cartpos.item.compute_validity(\n                    requested_start=(\n                        max(cartpos.requested_valid_from, now())\n                        if cartpos.requested_valid_from and cartpos.item.validity_dynamic_start_choice\n                        else now()\n                    ),\n                    enforce_start_limit=True,\n                    override_tz=order.event.timezone,\n                )\n                op.valid_from = valid_from\n                op.valid_until = valid_until\n\n            op.positionid = i + 1\n            op.save()\n            ops.append(op)\n            cp_mapping[cartpos.pk] = op\n            for answ in cartpos.answers.all():\n                answ.orderposition = op\n                answ.cartposition = None\n                answ.save()\n            if cartpos.voucher:\n                Voucher.objects.filter(pk=cartpos.voucher.pk).update(redeemed=F('redeemed') + 1)\n                cartpos.voucher.log_action('pretix.voucher.redeemed', {\n                    'order_code': order.code\n                })\n\n        # Delete afterwards. Deleting in between might cause deletion of things related to add-ons\n        # due to the deletion cascade.\n        for cartpos in cp:\n            if cartpos.pk:\n                cartpos.addons.all().delete()\n                cartpos.delete()\n        return ops\n\n    def __str__(self):\n        if self.variation:\n            return '#{} \u2013 {} \u2013 {}'.format(\n                self.positionid, str(self.item), str(self.variation)\n            )\n        return '#{} \u2013 {}'.format(self.positionid, str(self.item))\n\n    def __repr__(self):\n        return '<OrderPosition: item %d, variation %d for order %s>' % (\n            self.item.id, self.variation.id if self.variation else 0, self.order_id\n        )\n\n    def _calculate_tax(self, tax_rule=None):\n        self.tax_rule = tax_rule or self.item.tax_rule\n        try:\n            ia = self.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = None\n        if self.tax_rule:\n            tax = self.tax_rule.tax(self.price, invoice_address=ia, base_price_is='gross', force_fixed_gross_price=True)\n            self.tax_rate = tax.rate\n            self.tax_value = tax.tax\n            if tax.gross != self.price:\n                raise ValueError('Invalid tax calculation')\n        else:\n            self.tax_value = Decimal('0.00')\n            self.tax_rate = Decimal('0.00')\n\n    def save(self, *args, **kwargs):\n        from pretix.base.secrets import assign_ticket_secret\n\n        if self.tax_rate is None:\n            self._calculate_tax()\n\n        self.order.touch()\n        if not self.pk:\n            while not self.secret or OrderPosition.all.filter(\n                secret=self.secret, order__event__organizer_id=self.order.event.organizer_id\n            ).exists():\n                assign_ticket_secret(\n                    event=self.order.event, position=self, force_invalidate=True, save=False\n                )\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'secret'}.union(kwargs['update_fields'])\n\n        if not self.blocked and self.blocked is not None:\n            self.blocked = None\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'blocked'}.union(kwargs['update_fields'])\n        elif self.blocked and (not isinstance(self.blocked, list) or any(not isinstance(b, str) for b in self.blocked)):\n            raise TypeError(\"blocked needs to be a list of strings\")\n\n        if not self.pseudonymization_id:\n            self.assign_pseudonymization_id()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'pseudonymization_id'}.union(kwargs['update_fields'])\n\n        if not self.get_deferred_fields():\n            if Transaction.key(self) != self.__initial_transaction_key or self.canceled != self.__initial_canceled or not self.pk:\n                _transactions_mark_order_dirty(self.order_id, using=kwargs.get('using', None))\n        elif not kwargs.get('force_save_with_deferred_fields', None):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        return super().save(*args, **kwargs)\n\n    @scopes_disabled()\n    def assign_pseudonymization_id(self):\n        # This omits some character pairs completely because they are hard to read even on screens (1/I and O/0)\n        # and includes only one of two characters for some pairs because they are sometimes hard to distinguish in\n        # handwriting (2/Z, 4/A, 5/S, 6/G). This allows for better detection e.g. in incoming wire transfers that\n        # might include OCR'd handwritten text\n        charset = list('ABCDEFGHJKLMNPQRSTUVWXYZ3789')\n        while True:\n            code = get_random_string(length=10, allowed_chars=charset)\n            with scopes_disabled():\n                if not OrderPosition.all.filter(pseudonymization_id=code).exists():\n                    self.pseudonymization_id = code\n                    return\n\n    @property\n    def event(self):\n        return self.order.event\n\n    def send_mail(self, subject: str, template: Union[str, LazyI18nString],\n                  context: Dict[str, Any]=None, log_entry_type: str='pretix.event.order.email.sent',\n                  user: User=None, headers: dict=None, sender: str=None, invoices: list=None,\n                  auth=None, attach_tickets=False, attach_ical=False, attach_other_files: list=None):\n        \"\"\"\n        Sends an email to the attendee. Basically, this method does two things:\n\n        * Call ``pretix.base.services.mail.mail`` with useful values for the ``event``, ``locale``, ``recipient`` and\n          ``order`` parameters.\n\n        * Create a ``LogEntry`` with the email contents.\n\n        :param subject: Subject of the email\n        :param template: LazyI18nString or template filename, see ``pretix.base.services.mail.mail`` for more details\n        :param context: Dictionary to use for rendering the template\n        :param log_entry_type: Key to be used for the log entry\n        :param user: Administrative user who triggered this mail to be sent\n        :param headers: Dictionary with additional mail headers\n        :param sender: Custom email sender.\n        :param attach_tickets: Attach tickets of this order, if they are existing and ready to download\n        :param attach_ical: Attach relevant ICS files\n        \"\"\"\n        from pretix.base.services.mail import (\n            SendMailException, mail, render_mail,\n        )\n\n        if not self.attendee_email:\n            return\n\n        for k, v in self.event.meta_data.items():\n            context['meta_' + k] = v\n\n        with language(self.order.locale, self.order.event.settings.region):\n            recipient = self.attendee_email\n            try:\n                email_content = render_mail(template, context)\n                subject = format_map(subject, context)\n                mail(\n                    recipient, subject, template, context,\n                    self.event, self.order.locale, order=self.order, headers=headers, sender=sender,\n                    position=self,\n                    invoices=invoices,\n                    attach_tickets=attach_tickets,\n                    attach_ical=attach_ical,\n                    attach_other_files=attach_other_files,\n                )\n            except SendMailException:\n                raise\n            else:\n                self.order.log_action(\n                    log_entry_type,\n                    user=user,\n                    auth=auth,\n                    data={\n                        'subject': subject,\n                        'message': email_content,\n                        'recipient': recipient,\n                        'invoices': [i.pk for i in invoices] if invoices else [],\n                        'attach_tickets': attach_tickets,\n                        'attach_ical': attach_ical,\n                    }\n                )\n\n    def resend_link(self, user=None, auth=None):\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.event.settings.mail_text_resend_link\n            email_context = get_email_context(event=self.order.event, order=self.order, position=self)\n            email_subject = self.event.settings.mail_subject_resend_link\n            self.send_mail(\n                email_subject, email_template, email_context,\n                'pretix.event.order.email.resend', user=user, auth=auth,\n                attach_tickets=True\n            )\n\n    @property\n    @scopes_disabled()\n    def attendee_change_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be changed by the attendee.\n        \"\"\"\n        from .items import ItemAddOn\n\n        if not self.event.settings.change_allow_attendee or not self.order.user_change_allowed:\n            return False\n\n        positions = list(\n            self.order.positions.filter(Q(pk=self.pk) | Q(addon_to_id=self.pk)).annotate(\n                has_variations=Exists(ItemVariation.objects.filter(item_id=OuterRef('item_id'))),\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        return (\n            (self.order.event.settings.change_allow_user_variation and any([op.has_variations for op in positions])) or\n            (self.order.event.settings.change_allow_user_addons and ItemAddOn.objects.filter(base_item_id__in=[op.item_id for op in positions]).exists())\n        )\n\n\nclass Transaction(models.Model):\n    \"\"\"\n    Transactions are a data structure that is redundant on the first sight but makes it possible to create good\n    financial reporting.\n\n    To understand this, think of \"orders\" as something like a contractual relationship between the organizer and the\n    customer which requires to customer to pay some money and the organizer to provide a ticket.\n\n    The ``Order``, ``OrderPosition``, and ``OrderFee`` models combined give a representation of the current contractual\n    status of this relationship, i.e. how much and what is owed. The ``OrderPayment`` and ``OrderRefund`` models indicate\n    the \"other side\" of the relationship, i.e. how much of the financial obligation has been met so far.\n\n    However, while ``OrderPayment`` and ``OrderRefund`` objects are \"final\" and no longer change once they reached their\n    final state, ``Order``, ``OrderPosition`` and ``OrderFee`` are highly mutable and can change at any time, e.g. if\n    the customer moves their booking to a different day or a discount is applied retroactively.\n\n    Therefore those models can be used to answer the question \"how many tickets of type X have been sold for my event\n    as of today?\" but they cannot accurately answer the question \"how many tickets of type X have been sold for my event\n    as of last month?\" because they lack this kind of historical information.\n\n    Transactions help here because they are \"immutable copies\" or \"modification records\" of call positions and fees\n    at the time of their creation and change. They only record data that is usually relevant for financial reporting,\n    such as amounts, prices, products and dates involved. They do not record data like attendee names etc.\n\n    Even before the introduction of the Transaction Model pretix *did* store historical data for auditability in the\n    LogEntry model. However, it's almost impossible to do efficient reporting on that data.\n\n    Transactions should never be generated manually but only through the ``order.create_transactions()``\n    method which should be called **within the same database transaction**.\n\n    The big downside of this approach is that you need to remember to update transaction records every time you change\n    or create orders in new code paths. The mechanism introduced in ``pretix.base.models._transactions`` as well as\n    the ``save()`` methods of ``Order``, ``OrderPosition`` and ``OrderFee`` intends to help you notice if you missed\n    it. The only thing this *doesn't* catch is usage of ``OrderPosition.objects.bulk_create`` (and likewise for\n    ``bulk_update`` and ``OrderFee``).\n\n    :param id: ID of the transaction\n    :param order: Order the transaction belongs to\n    :param datetime: Date and time of the transaction\n    :param migrated: Whether this object was reconstructed because the order was created before transactions where introduced\n    :param positionid: Affected Position ID, in case this transaction represents a change in an order position\n    :param count: An amount, multiplicator for price etc. For order positions this can *currently* only be -1 or +1, for\n                  fees it can also be more in special cases\n    :param item: ``Item``, in case this transaction represents a change in an order position\n    :param variation: ``ItemVariation``, in case this transaction represents a change in an order position\n    :param subevent: ``subevent``, in case this transaction represents a change in an order position\n    :param price: Price of the changed position\n    :param tax_rate: Tax rate of the changed position\n    :param tax_rule: Used tax rule\n    :param tax_value: Tax value in event currency\n    :param fee_type: Fee type code in case this transaction represents a change in an order fee\n    :param internal_type: Internal fee type in case this transaction represents a change in an order fee\n    \"\"\"\n    id = models.BigAutoField(primary_key=True)\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='transactions',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True,\n        db_index=True,\n    )\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"),\n    )\n    migrated = models.BooleanField(\n        default=False\n    )\n    positionid = models.PositiveIntegerField(default=1, null=True, blank=True)\n    count = models.IntegerField(\n        default=1\n    )\n    item = models.ForeignKey(\n        Item,\n        null=True, blank=True,\n        verbose_name=_(\"Item\"),\n        on_delete=models.PROTECT\n    )\n    variation = models.ForeignKey(\n        ItemVariation,\n        null=True, blank=True,\n        verbose_name=_(\"Variation\"),\n        on_delete=models.PROTECT\n    )\n    subevent = models.ForeignKey(\n        SubEvent,\n        null=True, blank=True,\n        on_delete=models.PROTECT,\n        verbose_name=pgettext_lazy(\"subevent\", \"Date\"),\n    )\n    price = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Price\")\n    )\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n    fee_type = models.CharField(\n        max_length=100, choices=OrderFee.FEE_TYPES, null=True, blank=True\n    )\n    internal_type = models.CharField(max_length=255, null=True, blank=True)\n\n    class Meta:\n        ordering = 'datetime', 'pk'\n        index_together = [\n            ['datetime', 'id']\n        ]\n\n    def save(self, *args, **kwargs):\n        if not self.fee_type and not self.item:\n            raise ValidationError('Should set either item or fee type')\n        return super().save(*args, **kwargs)\n\n    @staticmethod\n    def key(obj):\n        if isinstance(obj, Transaction):\n            return (obj.positionid, obj.item_id, obj.variation_id, obj.subevent_id, obj.price, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, obj.fee_type, obj.internal_type)\n        elif isinstance(obj, OrderPosition):\n            return (obj.positionid, obj.item_id, obj.variation_id, obj.subevent_id, obj.price, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, None, None)\n        elif isinstance(obj, OrderFee):\n            return (None, None, None, None, obj.value, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, obj.fee_type, obj.internal_type)\n        raise ValueError('invalid state')  # noqa\n\n    @property\n    def full_price(self):\n        return self.price * self.count\n\n    @property\n    def full_tax_value(self):\n        return self.tax_value * self.count\n\n\nclass CartPosition(AbstractPosition):\n    \"\"\"\n    A cart position is similar to an order line, except that it is not\n    yet part of a binding order but just placed by some user in his or\n    her cart. It therefore normally has a much shorter expiration time\n    than an ordered position, but still blocks an item in the quota pool\n    as we do not want to throw out users while they're clicking through\n    the checkout process. This has all properties of AbstractPosition.\n\n    :param event: The event this belongs to\n    :type event: Event\n    :param cart_id: The user session that contains this cart position\n    :type cart_id: str\n    \"\"\"\n    event = models.ForeignKey(\n        Event,\n        verbose_name=_(\"Event\"),\n        on_delete=models.CASCADE\n    )\n    cart_id = models.CharField(\n        max_length=255, null=True, blank=True, db_index=True,\n        verbose_name=_(\"Cart ID (e.g. session key)\")\n    )\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"),\n        auto_now_add=True\n    )\n    expires = models.DateTimeField(\n        verbose_name=_(\"Expiration date\"),\n        db_index=True\n    )\n\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2, default=Decimal('0.00'),\n        verbose_name=_('Tax rate')\n    )\n    listed_price = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    price_after_voucher = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    custom_price_input = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    custom_price_input_is_net = models.BooleanField(\n        default=False,\n    )\n    line_price_gross = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    requested_valid_from = models.DateTimeField(\n        null=True,\n    )\n\n    objects = ScopedManager(organizer='event__organizer')\n\n    class Meta:\n        verbose_name = _(\"Cart position\")\n        verbose_name_plural = _(\"Cart positions\")\n\n    def __repr__(self):\n        return '<CartPosition: item %d, variation %d for cart %s>' % (\n            self.item.id, self.variation.id if self.variation else 0, self.cart_id\n        )\n\n    @property\n    def tax_value(self):\n        net = round_decimal(self.price - (self.price * (1 - 100 / (100 + self.tax_rate))),\n                            self.event.currency)\n        return self.price - net\n\n    @cached_property\n    def sort_key(self):\n        subevent_key = (self.subevent.date_from, str(self.subevent.name), self.subevent_id) if self.subevent_id else (0, \"\", 0)\n        category_key = (self.item.category.position, self.item.category.id) if self.item.category_id is not None else (0, 0)\n        item_key = self.item.position, self.item_id\n        variation_key = (self.variation.position, self.variation.id) if self.variation_id is not None else (0, 0)\n        line_key = (self.price, (self.voucher_id or 0), (self.seat.sorting_rank if self.seat_id else 0), self.pk)\n        sort_key = subevent_key + category_key + item_key + variation_key + line_key\n\n        if self.addon_to_id:\n            return self.addon_to.sort_key + (1 if self.is_bundled else 2,) + sort_key\n        else:\n            return sort_key\n\n    def update_listed_price_and_voucher(self, voucher_only=False, max_discount=None):\n        from pretix.base.services.pricing import (\n            get_listed_price, is_included_for_free,\n        )\n\n        if voucher_only:\n            listed_price = self.listed_price\n        else:\n            if self.addon_to_id and is_included_for_free(self.item, self.addon_to):\n                listed_price = Decimal('0.00')\n            else:\n                listed_price = get_listed_price(self.item, self.variation, self.subevent)\n\n        if self.voucher:\n            price_after_voucher = self.voucher.calculate_price(listed_price, max_discount)\n        else:\n            price_after_voucher = listed_price\n\n        if self.is_bundled:\n            bundle = self.addon_to.item.bundles.filter(bundled_item=self.item, bundled_variation=self.variation).first()\n            if bundle:\n                if self.addon_to.voucher_id and self.addon_to.voucher.all_bundles_included:\n                    listed_price = Decimal('0.00')\n                    price_after_voucher = Decimal('0.00')\n                else:\n                    listed_price = bundle.designated_price\n                    price_after_voucher = bundle.designated_price\n\n        if listed_price != self.listed_price or price_after_voucher != self.price_after_voucher:\n            self.listed_price = listed_price\n            self.price_after_voucher = price_after_voucher\n            self.save(update_fields=['listed_price', 'price_after_voucher'])\n\n    def migrate_free_price_if_necessary(self):\n        # Migrate from pre-discounts position\n        if self.item.free_price and self.custom_price_input is None:\n            custom_price = self.price\n            if custom_price > 99_999_999_999:\n                raise ValueError('price_too_high')\n            self.custom_price_input = custom_price\n            self.custom_price_input_is_net = not False\n            self.save(update_fields=['custom_price_input', 'custom_price_input_is_net'])\n\n    def update_line_price(self, invoice_address, bundled_positions):\n        from pretix.base.services.pricing import get_line_price\n\n        line_price = get_line_price(\n            price_after_voucher=self.price_after_voucher,\n            custom_price_input=self.custom_price_input,\n            custom_price_input_is_net=self.custom_price_input_is_net,\n            tax_rule=self.item.tax_rule,\n            invoice_address=invoice_address,\n            bundled_sum=sum([b.price_after_voucher for b in bundled_positions]),\n            is_bundled=self.is_bundled,\n        )\n        if line_price.gross != self.line_price_gross or line_price.rate != self.tax_rate:\n            self.line_price_gross = line_price.gross\n            self.tax_rate = line_price.rate\n            self.save(update_fields=['line_price_gross', 'tax_rate'])\n\n    @property\n    def addons_without_bundled(self):\n        addons = [op for op in self.addons.all() if not op.is_bundled]\n        return sorted(addons, key=lambda cp: cp.sort_key)\n\n    @cached_property\n    def predicted_validity(self):\n        return self.item.compute_validity(\n            requested_start=(\n                max(self.requested_valid_from, now())\n                if self.requested_valid_from and self.item.validity_dynamic_start_choice\n                else now()\n            ),\n            override_tz=self.event.timezone,\n        )\n\n    @property\n    def valid_from(self):\n        return self.predicted_validity[0]\n\n    @property\n    def valid_until(self):\n        return self.predicted_validity[1]\n\n\nclass InvoiceAddress(models.Model):\n    last_modified = models.DateTimeField(auto_now=True)\n    order = models.OneToOneField(Order, null=True, blank=True, related_name='invoice_address', on_delete=models.CASCADE)\n    customer = models.ForeignKey(\n        Customer,\n        related_name='invoice_addresses',\n        null=True, blank=True,\n        on_delete=models.CASCADE\n    )\n    is_business = models.BooleanField(default=False, verbose_name=_('Business customer'))\n    company = models.CharField(max_length=255, blank=True, verbose_name=_('Company name'))\n    name_cached = models.CharField(max_length=255, verbose_name=_('Full name'), blank=True)\n    name_parts = models.JSONField(default=dict)\n    street = models.TextField(verbose_name=_('Address'), blank=False)\n    zipcode = models.CharField(max_length=30, verbose_name=_('ZIP code'), blank=False)\n    city = models.CharField(max_length=255, verbose_name=_('City'), blank=False)\n    country_old = models.CharField(max_length=255, verbose_name=_('Country'), blank=False)\n    country = FastCountryField(verbose_name=_('Country'), blank=False, blank_label=_('Select country'),\n                               countries=CachedCountries)\n    state = models.CharField(max_length=255, verbose_name=pgettext_lazy('address', 'State'), blank=True)\n    vat_id = models.CharField(max_length=255, blank=True, verbose_name=_('VAT ID'))\n    vat_id_validated = models.BooleanField(default=False)\n    custom_field = models.CharField(max_length=255, null=True, blank=True)\n    internal_reference = models.TextField(\n        verbose_name=_('Internal reference'),\n        help_text=_('This reference will be printed on your invoice for your convenience.'),\n        blank=True,\n    )\n    beneficiary = models.TextField(\n        verbose_name=_('Beneficiary'),\n        blank=True\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n    profiles = ScopedManager(organizer='customer__organizer')\n\n    def save(self, **kwargs):\n        if self.order:\n            self.order.touch()\n\n        if self.name_parts:\n            name = self.name\n            if self.name_cached != name:\n                self.name_cached = self.name\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'name_cached'}.union(kwargs['update_fields'])\n        else:\n            if self.name_cached != \"\" or self.name_parts != {}:\n                self.name_cached = \"\"\n                self.name_parts = {}\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'name_cached', 'name_parts'}.union(kwargs['update_fields'])\n        super().save(**kwargs)\n\n    def describe(self):\n        parts = [\n            self.company,\n            self.name,\n            self.street,\n            (self.zipcode or '') + ' ' + (self.city or '') + ' ' + (self.state_for_address or ''),\n            self.country.name,\n            self.vat_id,\n            self.custom_field,\n            self.internal_reference,\n            (_('Beneficiary') + ': ' + self.beneficiary) if self.beneficiary else '',\n        ]\n        return '\\n'.join([str(p).strip() for p in parts if p and str(p).strip()])\n\n    @property\n    def is_empty(self):\n        return (\n            not self.name_cached and not self.company and not self.street and not self.zipcode and not self.city\n            and not self.internal_reference and not self.beneficiary\n        )\n\n    @property\n    def state_name(self):\n        sd = pycountry.subdivisions.get(code='{}-{}'.format(self.country, self.state))\n        if sd:\n            return sd.name\n        return self.state\n\n    @property\n    def state_for_address(self):\n        from pretix.base.settings import COUNTRIES_WITH_STATE_IN_ADDRESS\n        if not self.state or str(self.country) not in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            return \"\"\n        if COUNTRIES_WITH_STATE_IN_ADDRESS[str(self.country)][1] == 'long':\n            return self.state_name\n        return self.state\n\n    @property\n    def name(self):\n        return build_name(self.name_parts, fallback_scheme=lambda: self.order.event.settings.name_scheme) or \"\"\n\n    @property\n    def name_all_components(self):\n        return build_name(self.name_parts, \"concatenation_all_components\", fallback_scheme=lambda: self.order.event.settings.name_scheme) or \"\"\n\n    def for_js(self):\n        d = {}\n\n        if self.name_parts:\n            if '_scheme' in self.name_parts:\n                scheme = PERSON_NAME_SCHEMES[self.name_parts['_scheme']]\n                for i, (k, l, w) in enumerate(scheme['fields']):\n                    d[f'name_parts_{i}'] = self.name_parts.get(k) or ''\n\n        d.update({\n            'company': self.company,\n            'is_business': self.is_business,\n            'street': self.street,\n            'zipcode': self.zipcode,\n            'city': self.city,\n            'country': str(self.country) if self.country else None,\n            'state': str(self.state) if self.state else None,\n            'vat_id': self.vat_id,\n            'custom_field': self.custom_field,\n            'internal_reference': self.internal_reference,\n            'beneficiary': self.beneficiary,\n        })\n        return d\n\n\ndef cachedticket_name(instance, filename: str) -> str:\n    secret = get_random_string(length=16, allowed_chars=string.ascii_letters + string.digits)\n    return 'tickets/{org}/{ev}/{code}-{no}-{prov}-{secret}.dat'.format(\n        org=instance.order_position.order.event.organizer.slug,\n        ev=instance.order_position.order.event.slug,\n        prov=instance.provider,\n        no=instance.order_position.positionid,\n        code=instance.order_position.order.code,\n        secret=secret,\n    )\n\n\ndef cachedcombinedticket_name(instance, filename: str) -> str:\n    secret = get_random_string(length=16, allowed_chars=string.ascii_letters + string.digits)\n    return 'tickets/{org}/{ev}/{code}-{prov}-{secret}.dat'.format(\n        org=instance.order.event.organizer.slug,\n        ev=instance.order.event.slug,\n        prov=instance.provider,\n        code=instance.order.code,\n        secret=secret\n    )\n\n\nclass CachedTicket(models.Model):\n    order_position = models.ForeignKey(OrderPosition, on_delete=models.CASCADE)\n    provider = models.CharField(max_length=255)\n    type = models.CharField(max_length=255)\n    extension = models.CharField(max_length=255)\n    file = models.FileField(null=True, blank=True, upload_to=cachedticket_name, max_length=255)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass CachedCombinedTicket(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE)\n    provider = models.CharField(max_length=255)\n    type = models.CharField(max_length=255)\n    extension = models.CharField(max_length=255)\n    file = models.FileField(null=True, blank=True, upload_to=cachedcombinedticket_name, max_length=255)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass CancellationRequest(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='cancellation_requests')\n    created = models.DateTimeField(auto_now_add=True)\n    cancellation_fee = models.DecimalField(max_digits=13, decimal_places=2)\n    refund_as_giftcard = models.BooleanField(default=False)\n\n\nclass RevokedTicketSecret(models.Model):\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='revoked_secrets')\n    position = models.ForeignKey(\n        OrderPosition,\n        on_delete=models.SET_NULL,\n        related_name='revoked_secrets',\n        null=True,\n    )\n    secret = models.TextField(db_index=True)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass BlockedTicketSecret(models.Model):\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='blocked_secrets')\n    position = models.ForeignKey(\n        OrderPosition,\n        on_delete=models.SET_NULL,\n        related_name='blocked_secrets',\n        null=True,\n    )\n    secret = models.TextField(db_index=True)\n    blocked = models.BooleanField()\n    updated = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = (('event', 'secret'),)\n\n\n@receiver(post_delete, sender=CachedTicket)\ndef cachedticket_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n\n\n@receiver(post_delete, sender=CachedCombinedTicket)\ndef cachedcombinedticket_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n\n\n@receiver(post_delete, sender=QuestionAnswer)\ndef answer_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Felix Sch\u00e4fer\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport hashlib\nimport itertools\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport tempfile\nimport unicodedata\nimport uuid\nfrom collections import OrderedDict, defaultdict\nfrom functools import partial\nfrom io import BytesIO\n\nimport jsonschema\nimport reportlab.rl_config\nfrom bidi.algorithm import get_display\nfrom django.conf import settings\nfrom django.contrib.staticfiles import finders\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Max, Min\nfrom django.db.models.fields.files import FieldFile\nfrom django.dispatch import receiver\nfrom django.utils.deconstruct import deconstructible\nfrom django.utils.formats import date_format\nfrom django.utils.html import conditional_escape\nfrom django.utils.timezone import now\nfrom django.utils.translation import gettext_lazy as _, pgettext\nfrom i18nfield.strings import LazyI18nString\nfrom pypdf import PdfReader, PdfWriter, Transformation\nfrom pypdf.generic import RectangleObject\nfrom reportlab.graphics import renderPDF\nfrom reportlab.graphics.barcode.qr import QrCodeWidget\nfrom reportlab.graphics.shapes import Drawing\nfrom reportlab.lib.colors import Color\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT\nfrom reportlab.lib.styles import ParagraphStyle\nfrom reportlab.lib.units import mm\nfrom reportlab.pdfbase import pdfmetrics\nfrom reportlab.pdfbase.pdfmetrics import getAscentDescent\nfrom reportlab.pdfbase.ttfonts import TTFont\nfrom reportlab.pdfgen.canvas import Canvas\nfrom reportlab.platypus import Paragraph\n\nfrom pretix.base.i18n import language\nfrom pretix.base.models import Order, OrderPosition, Question\nfrom pretix.base.settings import PERSON_NAME_SCHEMES\nfrom pretix.base.signals import layout_image_variables, layout_text_variables\nfrom pretix.base.templatetags.money import money_filter\nfrom pretix.base.templatetags.phone_format import phone_format\nfrom pretix.helpers.reportlab import ThumbnailingImageReader, reshaper\nfrom pretix.presale.style import get_fonts\n\nlogger = logging.getLogger(__name__)\n\nif not settings.DEBUG:\n    reportlab.rl_config.shapeChecking = 0\n\n\nDEFAULT_VARIABLES = OrderedDict((\n    (\"secret\", {\n        \"label\": _(\"Ticket code (barcode content)\"),\n        \"editor_sample\": \"tdmruoekvkpbv1o2mv8xccvqcikvr58u\",\n        \"evaluate\": lambda orderposition, order, event: (\n            orderposition.secret[:30] + \"\u2026\" if len(orderposition.secret) > 32 else orderposition.secret\n        )\n    }),\n    (\"order\", {\n        \"label\": _(\"Order code\"),\n        \"editor_sample\": \"A1B2C\",\n        \"evaluate\": lambda orderposition, order, event: orderposition.order.code\n    }),\n    (\"positionid\", {\n        \"label\": _(\"Order position number\"),\n        \"editor_sample\": \"1\",\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.positionid)\n    }),\n    (\"order_positionid\", {\n        \"label\": _(\"Order code and position number\"),\n        \"editor_sample\": \"A1B2C-1\",\n        \"evaluate\": lambda orderposition, order, event: f\"{orderposition.order.code}-{orderposition.positionid}\"\n    }),\n    (\"item\", {\n        \"label\": _(\"Product name\"),\n        \"editor_sample\": _(\"Sample product\"),\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.item.name)\n    }),\n    (\"variation\", {\n        \"label\": _(\"Variation name\"),\n        \"editor_sample\": _(\"Sample variation\"),\n        \"evaluate\": lambda op, order, event: str(op.variation) if op.variation else ''\n    }),\n    (\"item_description\", {\n        \"label\": _(\"Product description\"),\n        \"editor_sample\": _(\"Sample product description\"),\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.item.description)\n    }),\n    (\"itemvar\", {\n        \"label\": _(\"Product name and variation\"),\n        \"editor_sample\": _(\"Sample product \u2013 sample variation\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            '{} - {}'.format(orderposition.item.name, orderposition.variation)\n            if orderposition.variation else str(orderposition.item.name)\n        )\n    }),\n    (\"itemvar_description\", {\n        \"label\": _(\"Product variation description\"),\n        \"editor_sample\": _(\"Sample product variation description\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            str(orderposition.variation.description) if orderposition.variation else str(orderposition.item.description)\n        )\n    }),\n    (\"item_category\", {\n        \"label\": _(\"Product category\"),\n        \"editor_sample\": _(\"Ticket category\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            str(orderposition.item.category.name) if orderposition.item.category else \"\"\n        )\n    }),\n    (\"price\", {\n        \"label\": _(\"Price\"),\n        \"editor_sample\": _(\"123.45 EUR\"),\n        \"evaluate\": lambda op, order, event: money_filter(op.price, event.currency)\n    }),\n    (\"price_with_addons\", {\n        \"label\": _(\"Price including add-ons\"),\n        \"editor_sample\": _(\"123.45 EUR\"),\n        \"evaluate\": lambda op, order, event: money_filter(op.price + sum(\n            p.price\n            for p in op.addons.all()\n            if not p.canceled\n        ), event.currency)\n    }),\n    (\"attendee_name\", {\n        \"label\": _(\"Attendee name\"),\n        \"editor_sample\": _(\"John Doe\"),\n        \"evaluate\": lambda op, order, ev: op.attendee_name or (op.addon_to.attendee_name if op.addon_to else '')\n    }),\n    (\"attendee_company\", {\n        \"label\": _(\"Attendee company\"),\n        \"editor_sample\": _(\"Sample company\"),\n        \"evaluate\": lambda op, order, ev: op.company or (op.addon_to.company if op.addon_to else '')\n    }),\n    ('attendee_address', {\n        'label': _('Full attendee address'),\n        'editor_sample': _('John Doe\\nSample company\\nSesame Street 42\\n12345 Any City\\nAtlantis'),\n        'evaluate': lambda op, order, event: op.address_format()\n    }),\n    (\"attendee_street\", {\n        \"label\": _(\"Attendee street\"),\n        \"editor_sample\": 'Sesame Street 42',\n        \"evaluate\": lambda op, order, ev: op.street or (op.addon_to.street if op.addon_to else '')\n    }),\n    (\"attendee_zipcode\", {\n        \"label\": _(\"Attendee ZIP code\"),\n        \"editor_sample\": '12345',\n        \"evaluate\": lambda op, order, ev: op.zipcode or (op.addon_to.zipcode if op.addon_to else '')\n    }),\n    (\"attendee_city\", {\n        \"label\": _(\"Attendee city\"),\n        \"editor_sample\": 'Any City',\n        \"evaluate\": lambda op, order, ev: op.city or (op.addon_to.city if op.addon_to else '')\n    }),\n    (\"attendee_state\", {\n        \"label\": _(\"Attendee state\"),\n        \"editor_sample\": 'Sample State',\n        \"evaluate\": lambda op, order, ev: op.state or (op.addon_to.state if op.addon_to else '')\n    }),\n    (\"attendee_country\", {\n        \"label\": _(\"Attendee country\"),\n        \"editor_sample\": 'Atlantis',\n        \"evaluate\": lambda op, order, ev: str(getattr(op.country, 'name', '')) or (\n            str(getattr(op.addon_to.country, 'name', '')) if op.addon_to else ''\n        )\n    }),\n    (\"attendee_email\", {\n        \"label\": _(\"Attendee email\"),\n        \"editor_sample\": 'foo@bar.com',\n        \"evaluate\": lambda op, order, ev: op.attendee_email or (op.addon_to.attendee_email if op.addon_to else '')\n    }),\n    (\"pseudonymization_id\", {\n        \"label\": _(\"Pseudonymization ID (lead scanning)\"),\n        \"editor_sample\": \"GG89JUJDTA\",\n        \"evaluate\": lambda orderposition, order, event: orderposition.pseudonymization_id,\n    }),\n    (\"event_name\", {\n        \"label\": _(\"Event name\"),\n        \"editor_sample\": _(\"Sample event name\"),\n        \"evaluate\": lambda op, order, ev: str(ev.name)\n    }),\n    (\"event_series_name\", {\n        \"label\": _(\"Event series\"),\n        \"editor_sample\": _(\"Sample event name\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.name)\n    }),\n    (\"event_date\", {\n        \"label\": _(\"Event date\"),\n        \"editor_sample\": _(\"May 31st, 2017\"),\n        \"evaluate\": lambda op, order, ev: ev.get_date_from_display(show_times=False)\n    }),\n    (\"event_date_range\", {\n        \"label\": _(\"Event date range\"),\n        \"editor_sample\": _(\"May 31st \u2013 June 4th, 2017\"),\n        \"evaluate\": lambda op, order, ev: ev.get_date_range_display(force_show_end=True)\n    }),\n    (\"event_begin\", {\n        \"label\": _(\"Event begin date and time\"),\n        \"editor_sample\": _(\"2017-05-31 20:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_from.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_from else \"\"\n    }),\n    (\"event_begin_date\", {\n        \"label\": _(\"Event begin date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_from.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if ev.date_from else \"\"\n    }),\n    (\"event_begin_time\", {\n        \"label\": _(\"Event begin time\"),\n        \"editor_sample\": _(\"20:00\"),\n        \"evaluate\": lambda op, order, ev: ev.get_time_from_display()\n    }),\n    (\"event_begin_weekday\", {\n        \"label\": _(\"Event begin weekday\"),\n        \"editor_sample\": _(\"Friday\"),\n        \"evaluate\": lambda op, order, ev: ev.get_weekday_from_display()\n    }),\n    (\"event_end\", {\n        \"label\": _(\"Event end date and time\"),\n        \"editor_sample\": _(\"2017-05-31 22:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_date\", {\n        \"label\": _(\"Event end date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_time\", {\n        \"label\": _(\"Event end time\"),\n        \"editor_sample\": _(\"22:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_weekday\", {\n        \"label\": _(\"Event end weekday\"),\n        \"editor_sample\": _(\"Friday\"),\n        \"evaluate\": lambda op, order, ev: ev.get_weekday_to_display()\n    }),\n    (\"event_admission\", {\n        \"label\": _(\"Event admission date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_admission.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_admission else \"\"\n    }),\n    (\"event_admission_time\", {\n        \"label\": _(\"Event admission time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_admission.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if ev.date_admission else \"\"\n    }),\n    (\"event_location\", {\n        \"label\": _(\"Event location\"),\n        \"editor_sample\": _(\"Random City\"),\n        \"evaluate\": lambda op, order, ev: str(ev.location)\n    }),\n    (\"telephone\", {\n        \"label\": _(\"Phone number\"),\n        \"editor_sample\": \"+01 1234 567890\",\n        \"evaluate\": lambda op, order, ev: phone_format(order.phone, html=False)\n    }),\n    (\"email\", {\n        \"label\": _(\"Email\"),\n        \"editor_sample\": \"foo@bar.com\",\n        \"evaluate\": lambda op, order, ev: order.email\n    }),\n    (\"invoice_name\", {\n        \"label\": _(\"Invoice address name\"),\n        \"editor_sample\": _(\"John Doe\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.name if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_company\", {\n        \"label\": _(\"Invoice address company\"),\n        \"editor_sample\": _(\"Sample company\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.company if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_street\", {\n        \"label\": _(\"Invoice address street\"),\n        \"editor_sample\": _(\"Sesame Street 42\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.street if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_zipcode\", {\n        \"label\": _(\"Invoice address ZIP code\"),\n        \"editor_sample\": _(\"12345\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.zipcode if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_city\", {\n        \"label\": _(\"Invoice address city\"),\n        \"editor_sample\": _(\"Sample city\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.city if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_state\", {\n        \"label\": _(\"Invoice address state\"),\n        \"editor_sample\": _(\"Sample State\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.state if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_country\", {\n        \"label\": _(\"Invoice address country\"),\n        \"editor_sample\": _(\"Atlantis\"),\n        \"evaluate\": lambda op, order, ev: str(getattr(order.invoice_address.country, 'name', '')) if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"addons\", {\n        \"label\": _(\"List of Add-Ons\"),\n        \"editor_sample\": _(\"Add-on 1\\n2x Add-on 2\"),\n        \"evaluate\": lambda op, order, ev: \"\\n\".join([\n            str(p) for p in generate_compressed_addon_list(op, order, ev)\n        ])\n    }),\n    (\"organizer\", {\n        \"label\": _(\"Organizer name\"),\n        \"editor_sample\": _(\"Event organizer company\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.organizer.name)\n    }),\n    (\"organizer_info_text\", {\n        \"label\": _(\"Organizer info text\"),\n        \"editor_sample\": _(\"Event organizer info text\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.settings.organizer_info_text)\n    }),\n    (\"event_info_text\", {\n        \"label\": _(\"Event info text\"),\n        \"editor_sample\": _(\"Event info text\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.settings.event_info_text)\n    }),\n    (\"now_date\", {\n        \"label\": _(\"Printing date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        )\n    }),\n    (\"now_datetime\", {\n        \"label\": _(\"Printing date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        )\n    }),\n    (\"now_time\", {\n        \"label\": _(\"Printing time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        )\n    }),\n    (\"valid_from_date\", {\n        \"label\": _(\"Validity start date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_from_datetime\", {\n        \"label\": _(\"Validity start date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_from_time\", {\n        \"label\": _(\"Validity start time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_until_date\", {\n        \"label\": _(\"Validity end date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"valid_until_datetime\", {\n        \"label\": _(\"Validity end date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"valid_until_time\", {\n        \"label\": _(\"Validity end time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"medium_identifier\", {\n        \"label\": _(\"Reusable Medium ID\"),\n        \"editor_sample\": \"ABC1234DEF4567\",\n        \"evaluate\": lambda op, order, ev: op.linked_media.all()[0].identifier if op.linked_media.all() else \"\",\n    }),\n    (\"seat\", {\n        \"label\": _(\"Seat: Full name\"),\n        \"editor_sample\": _(\"Ground floor, Row 3, Seat 4\"),\n        \"evaluate\": lambda op, order, ev: str(get_seat(op) if get_seat(op) else\n                                              _('General admission') if ev.seating_plan_id is not None else \"\")\n    }),\n    (\"seat_zone\", {\n        \"label\": _(\"Seat: zone\"),\n        \"editor_sample\": _(\"Ground floor\"),\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).zone_name if get_seat(op) else\n                                              _('General admission') if ev.seating_plan_id is not None else \"\")\n    }),\n    (\"seat_row\", {\n        \"label\": _(\"Seat: row\"),\n        \"editor_sample\": \"3\",\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).row_name if get_seat(op) else \"\")\n    }),\n    (\"seat_number\", {\n        \"label\": _(\"Seat: seat number\"),\n        \"editor_sample\": 4,\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).seat_number if get_seat(op) else \"\")\n    }),\n    (\"first_scan\", {\n        \"label\": _(\"Date and time of first scan\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: get_first_scan(op)\n    }),\n    (\"giftcard_issuance_date\", {\n\n        \"label\": _(\"Gift card: Issuance date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: get_giftcard_issuance(op, ev)\n    }),\n    (\"giftcard_expiry_date\", {\n        \"label\": _(\"Gift card: Expiration date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: get_giftcard_expiry(op, ev)\n    }),\n))\nDEFAULT_IMAGES = OrderedDict([])\n\n\n@receiver(layout_image_variables, dispatch_uid=\"pretix_base_layout_image_variables_questions\")\ndef images_from_questions(sender, *args, **kwargs):\n    def get_answer(op, order, event, question_id, etag):\n        a = None\n        if op.addon_to:\n            if 'answers' in getattr(op.addon_to, '_prefetched_objects_cache', {}):\n                try:\n                    a = [a for a in op.addon_to.answers.all() if a.question_id == question_id][0]\n                except IndexError:\n                    pass\n            else:\n                a = op.addon_to.answers.filter(question_id=question_id).first()\n\n        if 'answers' in getattr(op, '_prefetched_objects_cache', {}):\n            try:\n                a = [a for a in op.answers.all() if a.question_id == question_id][0]\n            except IndexError:\n                pass\n        else:\n            a = op.answers.filter(question_id=question_id).first() or a\n\n        if not a or not a.file or not any(a.file.name.lower().endswith(e) for e in (\".jpg\", \".jpeg\", \".png\", \".gif\", \".bmp\", \".tif\", \".tiff\")):\n            return None\n        else:\n            if etag:\n                return hashlib.sha1(a.file.name.encode()).hexdigest()\n            return a.file\n\n    d = {}\n    for q in sender.questions.all():\n        if q.type != Question.TYPE_FILE:\n            continue\n        d['question_{}'.format(q.identifier)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk, etag=False),\n            'etag': partial(get_answer, question_id=q.pk, etag=True),\n        }\n    return d\n\n\n@receiver(layout_text_variables, dispatch_uid=\"pretix_base_layout_text_variables_questions\")\ndef variables_from_questions(sender, *args, **kwargs):\n    def get_answer(op, order, event, question_id):\n        a = None\n        if op.addon_to:\n            if 'answers' in getattr(op.addon_to, '_prefetched_objects_cache', {}):\n                try:\n                    a = [a for a in op.addon_to.answers.all() if a.question_id == question_id][0]\n                except IndexError:\n                    pass\n            else:\n                a = op.addon_to.answers.filter(question_id=question_id).first()\n\n        if 'answers' in getattr(op, '_prefetched_objects_cache', {}):\n            try:\n                a = [a for a in op.answers.all() if a.question_id == question_id][0]\n            except IndexError:\n                pass\n        else:\n            a = op.answers.filter(question_id=question_id).first() or a\n\n        if not a:\n            return \"\"\n        else:\n            return str(a)\n\n    d = {}\n    for q in sender.questions.all():\n        if q.type == Question.TYPE_FILE:\n            continue\n        d['question_{}'.format(q.identifier)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'editor_sample': _('<Answer: {question}>').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk),\n            'migrate_from': 'question_{}'.format(q.pk)\n        }\n        d['question_{}'.format(q.pk)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'editor_sample': _('<Answer: {question}>').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk),\n            'hidden': True,\n        }\n    return d\n\n\ndef _get_attendee_name_part(key, op, order, ev):\n    name_parts = op.attendee_name_parts or (op.addon_to.attendee_name_parts if op.addon_to else {})\n    if isinstance(key, tuple):\n        parts = [_get_attendee_name_part(c[0], op, order, ev) for c in key if not (c[0] == 'salutation' and name_parts.get(c[0], '') == \"Mx\")]\n        return ' '.join(p for p in parts if p)\n    value = name_parts.get(key, '')\n    if key == 'salutation':\n        return pgettext('person_name_salutation', value)\n    return value\n\n\ndef _get_ia_name_part(key, op, order, ev):\n    value = order.invoice_address.name_parts.get(key, '') if getattr(order, 'invoice_address', None) else ''\n    if key == 'salutation' and value:\n        return pgettext('person_name_salutation', value)\n    return value\n\n\ndef get_images(event):\n    v = copy.copy(DEFAULT_IMAGES)\n\n    for recv, res in layout_image_variables.send(sender=event):\n        v.update(res)\n\n    return v\n\n\ndef get_variables(event):\n    v = copy.copy(DEFAULT_VARIABLES)\n\n    scheme = PERSON_NAME_SCHEMES[event.settings.name_scheme]\n\n    concatenation_for_salutation = scheme.get(\"concatenation_for_salutation\", scheme[\"concatenation\"])\n    v['attendee_name_for_salutation'] = {\n        'label': _(\"Attendee name for salutation\"),\n        'editor_sample': _(\"Mr Doe\"),\n        'evaluate': lambda op, order, ev: concatenation_for_salutation(op.attendee_name_parts or (op.addon_to.attendee_name_parts if op.addon_to else {}))\n    }\n\n    for key, label, weight in scheme['fields']:\n        v['attendee_name_%s' % key] = {\n            'label': _(\"Attendee name: {part}\").format(part=label),\n            'editor_sample': scheme['sample'][key],\n            'evaluate': partial(_get_attendee_name_part, key)\n        }\n    for i in range(2, len(scheme['fields']) + 1):\n        for comb in itertools.combinations(scheme['fields'], i):\n            v['attendee_name_%s' % ('_'.join(c[0] for c in comb))] = {\n                'label': _(\"Attendee name: {part}\").format(part=' + '.join(str(c[1]) for c in comb)),\n                'editor_sample': ' '.join(str(scheme['sample'][c[0]]) for c in comb),\n                'evaluate': partial(_get_attendee_name_part, comb)\n            }\n\n    v['invoice_name']['editor_sample'] = scheme['concatenation'](scheme['sample'])\n    v['attendee_name']['editor_sample'] = scheme['concatenation'](scheme['sample'])\n\n    v['invoice_name_for_salutation'] = {\n        'label': _(\"Invoice address name for salutation\"),\n        'editor_sample': _(\"Mr Doe\"),\n        'evaluate': lambda op, order, ev: concatenation_for_salutation(order.invoice_address.name_parts if getattr(order, 'invoice_address', None) else {})\n    }\n\n    for key, label, weight in scheme['fields']:\n        v['invoice_name_%s' % key] = {\n            'label': _(\"Invoice address name: {part}\").format(part=label),\n            'editor_sample': scheme['sample'][key],\n            \"evaluate\": partial(_get_ia_name_part, key)\n        }\n\n    for recv, res in layout_text_variables.send(sender=event):\n        v.update(res)\n\n    return v\n\n\ndef get_giftcard_expiry(op: OrderPosition, ev):\n    if not op.item.issue_giftcard:\n        return \"\"  # performance optimization\n    m = op.issued_gift_cards.aggregate(m=Min('expires'))['m']\n    if not m:\n        return \"\"\n    return date_format(m.astimezone(ev.timezone), \"SHORT_DATE_FORMAT\")\n\n\ndef get_giftcard_issuance(op: OrderPosition, ev):\n    if not op.item.issue_giftcard:\n        return \"\"  # performance optimization\n    m = op.issued_gift_cards.aggregate(m=Max('issuance'))['m']\n    if not m:\n        return \"\"\n    return date_format(m.astimezone(ev.timezone), \"SHORT_DATE_FORMAT\")\n\n\ndef get_first_scan(op: OrderPosition):\n    scans = list(op.checkins.all())\n\n    if scans:\n        return date_format(\n            list(op.checkins.all())[-1].datetime.astimezone(op.order.event.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        )\n    return \"\"\n\n\ndef get_seat(op: OrderPosition):\n    if op.seat_id:\n        return op.seat\n    if op.addon_to_id:\n        return op.addon_to.seat\n    return None\n\n\ndef generate_compressed_addon_list(op, order, event):\n    itemcount = defaultdict(int)\n    addons = (\n        op.addons.all() if 'addons' in getattr(op, '_prefetched_objects_cache', {})\n        else op.addons.select_related('item', 'variation')\n    )\n    for pos in addons:\n        itemcount[pos.item, pos.variation] += 1\n\n    addonlist = []\n    for (item, variation), count in itemcount.items():\n        if variation:\n            if count > 1:\n                addonlist.append('{}x {} - {}'.format(count, item.name, variation.value))\n            else:\n                addonlist.append('{} - {}'.format(item.name, variation.value))\n        else:\n            if count > 1:\n                addonlist.append('{}x {}'.format(count, item.name))\n            else:\n                addonlist.append(item.name)\n    return addonlist\n\n\nclass Renderer:\n\n    def __init__(self, event, layout, background_file):\n        self.layout = layout\n        self.background_file = background_file\n        self.variables = get_variables(event)\n        self.images = get_images(event)\n        self.event = event\n        if self.background_file:\n            self.bg_bytes = self.background_file.read()\n            self.bg_pdf = PdfReader(BytesIO(self.bg_bytes), strict=False)\n        else:\n            self.bg_bytes = None\n            self.bg_pdf = None\n\n    @classmethod\n    def _register_fonts(cls):\n        if hasattr(cls, '_fonts_registered'):\n            return\n        pdfmetrics.registerFont(TTFont('Open Sans', finders.find('fonts/OpenSans-Regular.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans I', finders.find('fonts/OpenSans-Italic.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans B', finders.find('fonts/OpenSans-Bold.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans B I', finders.find('fonts/OpenSans-BoldItalic.ttf')))\n\n        for family, styles in get_fonts().items():\n            pdfmetrics.registerFont(TTFont(family, finders.find(styles['regular']['truetype'])))\n            if 'italic' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' I', finders.find(styles['italic']['truetype'])))\n            if 'bold' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' B', finders.find(styles['bold']['truetype'])))\n            if 'bolditalic' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' B I', finders.find(styles['bolditalic']['truetype'])))\n\n        cls._fonts_registered = True\n\n    def _draw_poweredby(self, canvas: Canvas, op: OrderPosition, o: dict):\n        content = o.get('content', 'dark')\n        if content not in ('dark', 'white'):\n            content = 'dark'\n        img = finders.find('pretixpresale/pdf/powered_by_pretix_{}.png'.format(content))\n\n        ir = ThumbnailingImageReader(img)\n        try:\n            width, height = ir.resize(None, float(o['size']) * mm, 300)\n        except:\n            logger.exception(\"Can not resize image\")\n            pass\n        canvas.drawImage(ir,\n                         float(o['left']) * mm, float(o['bottom']) * mm,\n                         width=width, height=height,\n                         preserveAspectRatio=True, anchor='n',\n                         mask='auto')\n\n    def _draw_barcodearea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        content = o.get('content', 'secret')\n        if content == 'secret':\n            # do not use get_text_content because it uses a shortened version of secret\n            # and does not deal with our default value here properly\n            content = op.secret\n        else:\n            content = self._get_text_content(op, order, o)\n\n        if len(content) == 0:\n            return\n\n        level = 'H'\n        if len(content) > 32:\n            level = 'M'\n        if len(content) > 128:\n            level = 'L'\n        reqs = float(o['size']) * mm\n        kwargs = {}\n        if o.get('nowhitespace', False):\n            kwargs['barBorder'] = 0\n        qrw = QrCodeWidget(content, barLevel=level, barHeight=reqs, barWidth=reqs, **kwargs)\n        d = Drawing(reqs, reqs)\n        d.add(qrw)\n        qr_x = float(o['left']) * mm\n        qr_y = float(o['bottom']) * mm\n        renderPDF.draw(d, canvas, qr_x, qr_y)\n\n        # Add QR content + PDF issuer as a hidden string (fully transparent & very very small)\n        # This helps automated processing of the PDF file by 3rd parties, e.g. when checking tickets for resale\n        data = {\n            \"issuer\": settings.SITE_URL,\n            o.get('content', 'secret'): content\n        }\n        canvas.saveState()\n        canvas.setFont('Open Sans', .01)\n        canvas.setFillColorRGB(0, 0, 0, 0)\n        canvas.drawString(0 * mm, 0 * mm, json.dumps(data, sort_keys=True))\n        canvas.restoreState()\n\n    def _get_ev(self, op, order):\n        return op.subevent or order.event\n\n    def _get_text_content(self, op: OrderPosition, order: Order, o: dict, inner=False):\n        if o.get('locale', None) and not inner:\n            with language(o['locale'], self.event.settings.region):\n                return self._get_text_content(op, order, o, True)\n\n        ev = self._get_ev(op, order)\n\n        if not o['content']:\n            return '(error)'\n\n        if o['content'] == 'other' or o['content'] == 'other_i18n':\n            if o['content'] == 'other_i18n':\n                text = str(LazyI18nString(o.get('text_i18n', {})))\n            else:\n                text = o.get('text', '')\n\n            def replace(x):\n                if x.group(1).startswith('itemmeta:'):\n                    if op.variation_id:\n                        return op.variation.meta_data.get(x.group(1)[9:]) or ''\n                    return op.item.meta_data.get(x.group(1)[9:]) or ''\n                elif x.group(1).startswith('meta:'):\n                    return ev.meta_data.get(x.group(1)[5:]) or ''\n                elif x.group(1) not in self.variables:\n                    return x.group(0)\n                if x.group(1) == 'secret':\n                    # Do not use shortened version\n                    return op.secret\n\n                try:\n                    return self.variables[x.group(1)]['evaluate'](op, order, ev)\n                except:\n                    logger.exception('Failed to process variable.')\n                    return '(error)'\n\n            # We do not use str.format like in emails so we (a) can evaluate lazily and (b) can re-implement this\n            # 1:1 on other platforms that render PDFs through our API (libpretixprint)\n            return re.sub(r'\\{([a-zA-Z0-9:_]+)\\}', replace, text)\n\n        elif o['content'].startswith('itemmeta:'):\n            if op.variation_id:\n                return op.variation.meta_data.get(o['content'][9:]) or ''\n            return op.item.meta_data.get(o['content'][9:]) or ''\n\n        elif o['content'].startswith('meta:'):\n            return ev.meta_data.get(o['content'][5:]) or ''\n\n        elif o['content'] in self.variables:\n            try:\n                return self.variables[o['content']]['evaluate'](op, order, ev)\n            except:\n                logger.exception('Failed to process variable.')\n                return '(error)'\n\n        return ''\n\n    def _draw_imagearea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        ev = self._get_ev(op, order)\n        if not o['content'] or o['content'] not in self.images:\n            image_file = None\n        else:\n            try:\n                image_file = self.images[o['content']]['evaluate'](op, order, ev)\n            except:\n                logger.exception('Failed to process variable.')\n                image_file = None\n\n        if image_file:\n            try:\n                ir = ThumbnailingImageReader(image_file)\n                ir.resize(float(o['width']) * mm, float(o['height']) * mm, 300)\n                canvas.drawImage(\n                    image=ir,\n                    x=float(o['left']) * mm,\n                    y=float(o['bottom']) * mm,\n                    width=float(o['width']) * mm,\n                    height=float(o['height']) * mm,\n                    preserveAspectRatio=True,\n                    anchor='c',  # centered in frame\n                    mask='auto'\n                )\n                if isinstance(image_file, FieldFile):\n                    # ThumbnailingImageReader \"closes\" the file, so it's no use to use the same file pointer\n                    # in case we need it again. For FieldFile, fortunately, there is an easy way to make the file\n                    # refresh itself when it is used next.\n                    del image_file.file\n            except:\n                logger.exception(\"Can not load or resize image\")\n                canvas.saveState()\n                canvas.setFillColorRGB(.8, .8, .8, alpha=1)\n                canvas.rect(\n                    x=float(o['left']) * mm,\n                    y=float(o['bottom']) * mm,\n                    width=float(o['width']) * mm,\n                    height=float(o['height']) * mm,\n                    stroke=0,\n                    fill=1,\n                )\n                canvas.restoreState()\n        else:\n            canvas.saveState()\n            canvas.setFillColorRGB(.8, .8, .8, alpha=1)\n            canvas.rect(\n                x=float(o['left']) * mm,\n                y=float(o['bottom']) * mm,\n                width=float(o['width']) * mm,\n                height=float(o['height']) * mm,\n                stroke=0,\n                fill=1,\n            )\n            canvas.restoreState()\n\n    def _draw_textarea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        font = o['fontfamily']\n        if o['bold']:\n            font += ' B'\n        if o['italic']:\n            font += ' I'\n\n        try:\n            ad = getAscentDescent(font, float(o['fontsize']))\n        except KeyError:  # font not known, fall back\n            logger.warning(f'Use of unknown font \"{font}\"')\n            font = 'Open Sans'\n            ad = getAscentDescent(font, float(o['fontsize']))\n\n        align_map = {\n            'left': TA_LEFT,\n            'center': TA_CENTER,\n            'right': TA_RIGHT\n        }\n        # lineheight display differs from browser canvas. This calc is just empirical values to get\n        # reportlab render similarly to browser canvas.\n        # for backwards compatability use \u201euncorrected\u201c lineheight of 1.0 instead of 1.15\n        lineheight = float(o['lineheight']) * 1.15 if 'lineheight' in o else 1.0\n        style = ParagraphStyle(\n            name=uuid.uuid4().hex,\n            fontName=font,\n            fontSize=float(o['fontsize']),\n            leading=lineheight * float(o['fontsize']),\n            # for backwards compatability use autoLeading if no lineheight is given\n            autoLeading='off' if 'lineheight' in o else 'max',\n            textColor=Color(o['color'][0] / 255, o['color'][1] / 255, o['color'][2] / 255),\n            alignment=align_map[o['align']]\n        )\n        # add an almost-invisible space &hairsp; after hyphens as word-wrap in ReportLab only works on space chars\n        text = conditional_escape(\n            self._get_text_content(op, order, o) or \"\",\n        ).replace(\"\\n\", \"<br/>\\n\").replace(\"-\", \"-&hairsp;\")\n\n        # reportlab does not support unicode combination characters\n        # It's important we do this before we use ArabicReshaper\n        text = unicodedata.normalize(\"NFC\", text)\n\n        # reportlab does not support RTL, ligature-heavy scripts like Arabic. Therefore, we use ArabicReshaper\n        # to resolve all ligatures and python-bidi to switch RTL texts.\n        try:\n            text = \"<br/>\".join(get_display(reshaper.reshape(l)) for l in text.split(\"<br/>\"))\n        except:\n            logger.exception('Reshaping/Bidi fixes failed on string {}'.format(repr(text)))\n\n        p = Paragraph(text, style=style)\n        w, h = p.wrapOn(canvas, float(o['width']) * mm, 1000 * mm)\n        # p_size = p.wrap(float(o['width']) * mm, 1000 * mm)\n        canvas.saveState()\n        # The ascent/descent offsets here are not really proven to be correct, they're just empirical values to get\n        # reportlab render similarly to browser canvas.\n        if o.get('downward', False):\n            canvas.translate(float(o['left']) * mm, float(o['bottom']) * mm)\n            canvas.rotate(o.get('rotation', 0) * -1)\n            p.drawOn(canvas, 0, -h - ad[1] / 2.5)\n        else:\n            if lineheight != 1.0:\n                # lineheight adds to ascent/descent offsets, just empirical values again to get\n                # reportlab to render similarly to browser canvas\n                ad = (\n                    ad[0],\n                    ad[1] + (lineheight - 1.0) * float(o['fontsize']) * 1.05\n                )\n            canvas.translate(float(o['left']) * mm, float(o['bottom']) * mm + h)\n            canvas.rotate(o.get('rotation', 0) * -1)\n            p.drawOn(canvas, 0, -h - ad[1])\n        canvas.restoreState()\n\n    def draw_page(self, canvas: Canvas, order: Order, op: OrderPosition, show_page=True, only_page=None):\n        page_count = len(self.bg_pdf.pages)\n\n        if not only_page and not show_page:\n            raise ValueError(\"only_page=None and show_page=False cannot be combined\")\n\n        for page in range(page_count):\n            if only_page and only_page != page + 1:\n                continue\n            for o in self.layout:\n                if o.get('page', 1) != page + 1:\n                    continue\n                if o['type'] == \"barcodearea\":\n                    self._draw_barcodearea(canvas, op, order, o)\n                elif o['type'] == \"imagearea\":\n                    self._draw_imagearea(canvas, op, order, o)\n                elif o['type'] == \"textarea\":\n                    self._draw_textarea(canvas, op, order, o)\n                elif o['type'] == \"poweredby\":\n                    self._draw_poweredby(canvas, op, o)\n                if self.bg_pdf:\n                    page_size = (\n                        self.bg_pdf.pages[0].mediabox[2] - self.bg_pdf.pages[0].mediabox[0],\n                        self.bg_pdf.pages[0].mediabox[3] - self.bg_pdf.pages[0].mediabox[1]\n                    )\n                    if self.bg_pdf.pages[0].get('/Rotate') in (90, 270):\n                        # swap dimensions due to pdf being rotated\n                        page_size = page_size[::-1]\n                    canvas.setPageSize(page_size)\n            if show_page:\n                canvas.showPage()\n\n    def render_background(self, buffer, title=_('Ticket')):\n        if settings.PDFTK:\n            buffer.seek(0)\n            with tempfile.TemporaryDirectory() as d:\n                with open(os.path.join(d, 'back.pdf'), 'wb') as f:\n                    f.write(self.bg_bytes)\n                with open(os.path.join(d, 'front.pdf'), 'wb') as f:\n                    f.write(buffer.read())\n                subprocess.run([\n                    settings.PDFTK,\n                    os.path.join(d, 'front.pdf'),\n                    'multibackground',\n                    os.path.join(d, 'back.pdf'),\n                    'output',\n                    os.path.join(d, 'out.pdf'),\n                    'compress'\n                ], check=True)\n                with open(os.path.join(d, 'out.pdf'), 'rb') as f:\n                    return BytesIO(f.read())\n        else:\n            buffer.seek(0)\n            new_pdf = PdfReader(buffer)\n            output = PdfWriter()\n\n            for i, page in enumerate(new_pdf.pages):\n                bg_page = copy.deepcopy(self.bg_pdf.pages[i])\n                bg_rotation = bg_page.get('/Rotate')\n                if bg_rotation:\n                    # /Rotate is clockwise, transformation.rotate is counter-clockwise\n                    t = Transformation().rotate(bg_rotation)\n                    w = float(page.mediabox.getWidth())\n                    h = float(page.mediabox.getHeight())\n                    if bg_rotation in (90, 270):\n                        # offset due to rotation base\n                        if bg_rotation == 90:\n                            t = t.translate(h, 0)\n                        else:\n                            t = t.translate(0, w)\n                        # rotate mediabox as well\n                        page.mediabox = RectangleObject((\n                            page.mediabox.left.as_numeric(),\n                            page.mediabox.bottom.as_numeric(),\n                            page.mediabox.top.as_numeric(),\n                            page.mediabox.right.as_numeric(),\n                        ))\n                        page.trimbox = page.mediabox\n                    elif bg_rotation == 180:\n                        t = t.translate(w, h)\n                    page.add_transformation(t)\n                bg_page.merge_page(page)\n                output.add_page(bg_page)\n\n            output.add_metadata({\n                '/Title': str(title),\n                '/Creator': 'pretix',\n            })\n            outbuffer = BytesIO()\n            output.write(outbuffer)\n            outbuffer.seek(0)\n            return outbuffer\n\n\ndef merge_background(fg_pdf, bg_pdf, out_file, compress):\n    if settings.PDFTK:\n        with tempfile.TemporaryDirectory() as d:\n            fg_filename = os.path.join(d, 'fg.pdf')\n            bg_filename = os.path.join(d, 'bg.pdf')\n            fg_pdf.write(fg_filename)\n            bg_pdf.write(bg_filename)\n            pdftk_cmd = [\n                settings.PDFTK,\n                fg_filename,\n                'multibackground',\n                bg_filename,\n                'output',\n                '-',\n            ]\n            if compress:\n                pdftk_cmd.append('compress')\n            subprocess.run(pdftk_cmd, check=True, stdout=out_file)\n    else:\n        output = PdfWriter()\n        for i, page in enumerate(fg_pdf.pages):\n            bg_page = copy.deepcopy(bg_pdf.pages[i])\n            bg_rotation = bg_page.get('/Rotate')\n            if bg_rotation:\n                # /Rotate is clockwise, transformation.rotate is counter-clockwise\n                t = Transformation().rotate(bg_rotation)\n                w = float(page.mediabox.getWidth())\n                h = float(page.mediabox.getHeight())\n                if bg_rotation in (90, 270):\n                    # offset due to rotation base\n                    if bg_rotation == 90:\n                        t = t.translate(h, 0)\n                    else:\n                        t = t.translate(0, w)\n                    # rotate mediabox as well\n                    page.mediabox = RectangleObject((\n                        page.mediabox.left.as_numeric(),\n                        page.mediabox.bottom.as_numeric(),\n                        page.mediabox.top.as_numeric(),\n                        page.mediabox.right.as_numeric(),\n                    ))\n                    page.trimbox = page.mediabox\n                elif bg_rotation == 180:\n                    t = t.translate(w, h)\n                page.add_transformation(t)\n            bg_page.merge_page(page)\n            output.add_page(bg_page)\n        output.write(out_file)\n\n\n@deconstructible\nclass PdfLayoutValidator:\n    def __call__(self, value):\n        if not isinstance(value, dict):\n            try:\n                val = json.loads(value)\n            except ValueError:\n                raise ValidationError(_('Your layout file is not a valid JSON file.'))\n        else:\n            val = value\n        with open(finders.find('schema/pdf-layout.schema.json'), 'r') as f:\n            schema = json.loads(f.read())\n        try:\n            jsonschema.validate(val, schema)\n        except jsonschema.ValidationError as e:\n            e = str(e).replace('%', '%%')\n            raise ValidationError(_('Your layout file is not a valid layout. Error message: {}').format(e))\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Daniel, Heok Hong Low, Ian Williams, Maico Timmerman,\n# Sanket Dasgupta, Tobias Kunze, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport json\nimport operator\nfrom collections import OrderedDict, UserList\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Any\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import File\nfrom django.core.validators import (\n    MaxValueValidator, MinValueValidator, RegexValidator,\n)\nfrom django.db.models import Model\nfrom django.utils.functional import lazy\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import (\n    gettext, gettext_lazy as _, gettext_noop, pgettext, pgettext_lazy,\n)\nfrom django_countries.fields import Country\nfrom hierarkey.models import GlobalSettingsBase, Hierarkey\nfrom i18nfield.forms import I18nFormField, I18nTextarea, I18nTextInput\nfrom i18nfield.strings import LazyI18nString\nfrom phonenumbers import PhoneNumber, parse\nfrom rest_framework import serializers\n\nfrom pretix.api.serializers.fields import (\n    ListMultipleChoiceField, UploadedFileField,\n)\nfrom pretix.api.serializers.i18n import I18nField, I18nURLField\nfrom pretix.base.forms import I18nURLFormField\nfrom pretix.base.models.tax import VAT_ID_COUNTRIES, TaxRule\nfrom pretix.base.reldate import (\n    RelativeDateField, RelativeDateTimeField, RelativeDateWrapper,\n    SerializerRelativeDateField, SerializerRelativeDateTimeField,\n)\nfrom pretix.control.forms import (\n    ExtFileField, FontSelect, MultipleLanguagesWidget, SingleLanguageWidget,\n)\nfrom pretix.helpers.countries import CachedCountries\n\n\ndef country_choice_kwargs():\n    allcountries = list(CachedCountries())\n    allcountries.insert(0, ('', _('Select country')))\n    return {\n        'choices': allcountries\n    }\n\n\ndef primary_font_kwargs():\n    from pretix.presale.style import get_fonts\n\n    choices = [('Open Sans', 'Open Sans')]\n    choices += sorted([\n        (a, {\"title\": a, \"data\": v}) for a, v in get_fonts().items() if not v.get('pdf_only', False)\n    ], key=lambda a: a[0])\n    return {\n        'choices': choices,\n    }\n\n\ndef invoice_font_kwargs():\n    from pretix.presale.style import get_fonts\n\n    choices = [('Open Sans', 'Open Sans')]\n    choices += sorted([\n        (a, a) for a, v in get_fonts().items()\n    ], key=lambda a: a[0])\n    return {\n        'choices': choices,\n    }\n\n\ndef restricted_plugin_kwargs():\n    from pretix.base.plugins import get_all_plugins\n\n    plugins_available = [\n        (p.module, p.name) for p in get_all_plugins(None)\n        if (\n            not p.name.startswith('.') and\n            getattr(p, 'restricted', False) and\n            not hasattr(p, 'is_available')  # this means you should not really use restricted and is_available\n        )\n    ]\n    return {\n        'widget': forms.CheckboxSelectMultiple,\n        'label': _(\"Allow usage of restricted plugins\"),\n        'choices': plugins_available,\n    }\n\n\nclass LazyI18nStringList(UserList):\n    def __init__(self, init_list=None):\n        super().__init__()\n        if init_list is not None:\n            self.data = [v if isinstance(v, LazyI18nString) else LazyI18nString(v) for v in init_list]\n\n    def serialize(self):\n        return json.dumps([s.data for s in self.data])\n\n    @classmethod\n    def unserialize(cls, s):\n        return cls(json.loads(s))\n\n\nDEFAULTS = {\n    'allowed_restricted_plugins': {\n        'default': [],\n        'type': list,\n        'form_class': forms.MultipleChoiceField,\n        'serializer_class': serializers.MultipleChoiceField,\n        'form_kwargs': lambda: restricted_plugin_kwargs(),\n    },\n    'customer_accounts': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to create accounts\"),\n            help_text=_(\"This will allow customers to sign up for an account on your ticket shop. This is a prerequisite for some \"\n                        \"advanced features like memberships.\")\n        )\n    },\n    'customer_accounts_native': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to log in with email address and password\"),\n            help_text=_(\"If disabled, you will need to connect one or more single-sign-on providers.\"),\n            widget=forms.CheckboxInput(attrs={'data-display-dependency': '#id_settings-customer_accounts'}),\n        )\n    },\n    'customer_accounts_link_by_email': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Match orders based on email address\"),\n            help_text=_(\"This will allow registered customers to access orders made with the same email address, even if the customer \"\n                        \"was not logged in during the purchase.\")\n        )\n    },\n    'reusable_media_active': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Activate re-usable media\"),\n            help_text=_(\"The re-usable media feature allows you to connect tickets and gift cards with physical media \"\n                        \"such as wristbands or chip cards that may be re-used for different tickets or gift cards \"\n                        \"later.\")\n        )\n    },\n    'reusable_media_type_barcode': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_barcode_identifier_length': {\n        'default': 24,\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ]\n        ),\n        'form_kwargs': dict(\n            label=_('Length of barcodes'),\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ],\n            required=True,\n            widget=forms.NumberInput(\n                attrs={\n                    'min': '12',\n                    'max': '64',\n                },\n            ),\n        )\n    },\n    'reusable_media_type_nfc_uid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_nfc_uid_autocreate_giftcard': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically create a new gift card if a previously unknown chip is seen\"),\n        )\n    },\n    'reusable_media_type_nfc_uid_autocreate_giftcard_currency': {\n        'default': 'EUR',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n        ),\n        'form_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n            label=_(\"Gift card currency\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_autocreate_giftcard': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically create a new gift card if a new chip is encoded\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_autocreate_giftcard_currency': {\n        'default': 'EUR',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n        ),\n        'form_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n            label=_(\"Gift card currency\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_random_uid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use UID protection feature of NFC chip\"),\n        )\n    },\n    'max_items_per_order': {\n        'default': '10',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            min_value=1,\n            required=True,\n            label=_(\"Maximum number of items per order\"),\n            help_text=_(\"Add-on products will not be counted.\")\n        ),\n    },\n    'display_net_prices': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show net prices instead of gross prices in the product list (not recommended!)\"),\n            help_text=_(\"Independent of your choice, the cart will show gross prices as this is the price that needs to be \"\n                        \"paid.\"),\n\n        )\n    },\n    'hide_prices_from_attendees': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide prices on attendee ticket page\"),\n            help_text=_(\"If a person buys multiple tickets and you send emails to all of the attendees, with this \"\n                        \"option the ticket price will not be shown on the ticket page of the individual attendees. \"\n                        \"The ticket buyer will of course see the price.\"),\n\n        )\n    },\n    'system_question_order': {\n        'default': {},\n        'type': dict,\n        'serializer_class': serializers.DictField,\n        'serializer_kwargs': lambda: dict(read_only=True, allow_empty=True),\n    },\n    'attendee_names_asked': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for attendee names\"),\n            help_text=_(\"Ask for a name for all personalized tickets.\"),\n        )\n    },\n    'attendee_names_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require attendee names\"),\n            help_text=_(\"Require customers to fill in the names of all attendees.\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_names_asked'}),\n        )\n    },\n    'attendee_emails_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for email addresses per ticket\"),\n            help_text=_(\"Normally, pretix asks for one email address per order and the order confirmation will be sent \"\n                        \"only to that email address. If you enable this option, the system will additionally ask for \"\n                        \"individual email addresses for every personalized ticket. This might be useful if you want to \"\n                        \"obtain individual addresses for every attendee even in case of group orders. However, \"\n                        \"pretix will send the order confirmation by default only to the one primary email address, not to \"\n                        \"the per-attendee addresses. You can however enable this in the email settings.\"),\n        )\n    },\n    'attendee_emails_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require email addresses per ticket\"),\n            help_text=_(\"Require customers to fill in individual email addresses for all personalized tickets. See the \"\n                        \"above option for more details. One email address for the order confirmation will always be \"\n                        \"required regardless of this setting.\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_emails_asked'}),\n        )\n    },\n    'attendee_company_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for company per ticket\"),\n        )\n    },\n    'attendee_company_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require company per ticket\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_company_asked'}),\n        )\n    },\n    'attendee_addresses_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for postal addresses per ticket\"),\n        )\n    },\n    'attendee_addresses_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require postal addresses per ticket\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_addresses_asked'}),\n        )\n    },\n    'order_email_asked_twice': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for the order email address twice\"),\n            help_text=_(\"Require customers to fill in the primary email address twice to avoid errors.\"),\n        )\n    },\n    'order_phone_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a phone number per order\"),\n        )\n    },\n    'order_phone_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require a phone number per order\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-order_phone_asked'}),\n        )\n    },\n    'invoice_address_asked': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for invoice address\"),\n        )\n    },\n    'invoice_address_not_asked_free': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Do not ask for invoice address if an order is free'),\n        )\n    },\n    'invoice_name_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require customer name\"),\n        )\n    },\n    'invoice_attendee_name': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show attendee names on invoices\"),\n        )\n    },\n    'invoice_event_location': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event location on invoices\"),\n            help_text=_(\"The event location will be shown below the list of products if it is the same for all \"\n                        \"lines. It will be shown on every line if there are different locations.\")\n        )\n    },\n    'invoice_eu_currencies': {\n        'default': 'True',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'form_kwargs': dict(\n            label=_(\"Show exchange rates\"),\n            widget=forms.RadioSelect,\n            choices=(\n                ('False', _('Never')),\n                ('True', _('Based on European Central Bank daily rates, whenever the invoice recipient is in an EU '\n                           'country that uses a different currency.')),\n                ('CZK', _('Based on Czech National Bank daily rates, whenever the invoice amount is not in CZK.')),\n            ),\n        ),\n        'serializer_kwargs': dict(\n            choices=(\n                ('False', _('Never')),\n                ('True', _('Based on European Central Bank daily rates, whenever the invoice recipient is in an EU '\n                           'country that uses a different currency.')),\n                ('CZK', _('Based on Czech National Bank daily rates, whenever the invoice amount is not in CZK.')),\n            ),\n        ),\n    },\n    'invoice_address_required': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'type': bool,\n        'form_kwargs': dict(\n            label=_(\"Require invoice address\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_company_required': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'type': bool,\n        'form_kwargs': dict(\n            label=_(\"Require a business addresses\"),\n            help_text=_('This will require users to enter a company name.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_required'}),\n        )\n    },\n    'invoice_address_beneficiary': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for beneficiary\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_custom_field': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Custom recipient field\"),\n            widget=I18nTextInput,\n            help_text=_(\"If you want to add a custom text field, e.g. for a country-specific registration number, to \"\n                        \"your invoice address form, please fill in the label here. This label will both be used for \"\n                        \"asking the user to input their details as well as for displaying the value on the invoice. It will \"\n                        \"be shown on the invoice below the headline. \"\n                        \"The field will not be required.\")\n        )\n    },\n    'invoice_address_vatid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for VAT ID\"),\n            help_text=format_lazy(\n                _(\"Only works if an invoice address is asked for. VAT ID is never required and only requested from \"\n                  \"business customers in the following countries: {countries}\"),\n                countries=lazy(lambda *args: ', '.join(sorted(gettext(Country(cc).name) for cc in VAT_ID_COUNTRIES)), str)()\n            ),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Invoice address explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the invoice address form during checkout.\")\n        )\n    },\n    'invoice_show_payments': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show paid amount on partially paid invoices\"),\n            help_text=_(\"If an invoice has already been paid partially, this option will add the paid and pending \"\n                        \"amount to the invoice.\"),\n        )\n    },\n    'invoice_include_free': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show free products on invoices\"),\n            help_text=_(\"Note that invoices will never be generated for orders that contain only free \"\n                        \"products.\"),\n        )\n    },\n    'invoice_include_expire_date': {\n        'default': 'False',  # default for new events is True\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show expiration date of order\"),\n            help_text=_(\"The expiration date will not be shown if the invoice is generated after the order is paid.\"),\n        )\n    },\n    'invoice_numbers_counter_length': {\n        'default': '5',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(),\n        'form_kwargs': dict(\n            label=_(\"Minimum length of invoice number after prefix\"),\n            help_text=_(\"The part of your invoice number after your prefix will be filled up with leading zeros up to this length, e.g. INV-001 or INV-00001.\"),\n            max_value=12,\n            required=True,\n        )\n    },\n    'invoice_numbers_consecutive': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate invoices with consecutive numbers\"),\n            help_text=_(\"If deactivated, the order code will be used in the invoice number.\"),\n        )\n    },\n    'invoice_numbers_prefix': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Invoice number prefix\"),\n            help_text=_(\"This will be prepended to invoice numbers. If you leave this field empty, your event slug will \"\n                        \"be used followed by a dash. Attention: If multiple events within the same organization use the \"\n                        \"same value in this field, they will share their number range, i.e. every full number will be \"\n                        \"used at most once over all of your events. This setting only affects future invoices. You can \"\n                        \"use %Y (with century) %y (without century) to insert the year of the invoice, or %m and %d for \"\n                        \"the day of month.\"),\n            validators=[\n                RegexValidator(\n                    # We actually allow more characters than we name in the error message since some of these characters\n                    # are in active use at the time of the introduction of this validation, so we can't really forbid\n                    # them, but we don't think they belong in an invoice number and don't want to advertise them.\n                    regex=\"^[a-zA-Z0-9-_%./,&:# ]+$\",\n                    message=lazy(lambda *args: _('Please only use the characters {allowed} in this field.').format(\n                        allowed='A-Z, a-z, 0-9, -./:#'\n                    ), str)()\n                )\n            ],\n        )\n    },\n    'invoice_numbers_prefix_cancellations': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Invoice number prefix for cancellations\"),\n            help_text=_(\"This will be prepended to invoice numbers of cancellations. If you leave this field empty, \"\n                        \"the same numbering scheme will be used that you configured for regular invoices.\"),\n            validators=[\n                RegexValidator(\n                    # We actually allow more characters than we name in the error message since some of these characters\n                    # are in active use at the time of the introduction of this validation, so we can't really forbid\n                    # them, but we don't think they belong in an invoice number and don't want to advertise them.\n                    regex=\"^[a-zA-Z0-9-_%./,&:# ]+$\",\n                    message=lazy(lambda *args: _('Please only use the characters {allowed} in this field.').format(\n                        allowed='A-Z, a-z, 0-9, -./:#'\n                    ), str)()\n                )\n            ],\n        )\n    },\n    'invoice_renderer_highlight_order_code': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Highlight order code to make it stand out visibly\"),\n            help_text=_(\"Only respected by some invoice renderers.\"),\n        )\n    },\n    'invoice_renderer_font': {\n        'default': 'Open Sans',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**invoice_font_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Font'),\n            help_text=_(\"Only respected by some invoice renderers.\"),\n            required=True,\n            **invoice_font_kwargs()\n        ),\n    },\n    'invoice_renderer': {\n        'default': 'classic',  # default for new events is 'modern1'\n        'type': str,\n    },\n    'ticket_secret_generator': {\n        'default': 'random',\n        'type': str,\n    },\n    'ticket_secret_length': {\n        'default': settings.ENTROPY['ticket_secret'],\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ]\n        ),\n        'form_kwargs': dict(\n            label=_('Length of ticket codes'),\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ],\n            required=True,\n            widget=forms.NumberInput(\n                attrs={\n                    'min': '12',\n                    'max': '64',\n                    'data-display-dependency': 'input[name=ticket_secret_generator][value=random]',\n                },\n            ),\n        )\n    },\n    'reservation_time': {\n        'default': '30',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=60 * 24 * 7,\n        ),\n        'form_kwargs': dict(\n            min_value=0,\n            max_value=60 * 24 * 7,\n            label=_(\"Reservation period\"),\n            required=True,\n            help_text=_(\"The number of minutes the items in a user's cart are reserved for this user.\"),\n        )\n    },\n    'redirect_to_checkout_directly': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Directly redirect to check-out after a product has been added to the cart.'),\n        )\n    },\n    'presale_has_ended_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"End of presale text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the ticket shop once the designated sales timeframe for this event \"\n                        \"is over. You can use it to describe other options to get a ticket, such as a box office.\")\n        )\n    },\n    'payment_explanation': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n            }},\n            label=_(\"Guidance text\"),\n            help_text=_(\"This text will be shown above the payment options. You can explain the choices to the user here, \"\n                        \"if you want.\")\n        )\n    },\n    'payment_term_mode': {\n        'default': 'days',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('days', _(\"in days\")),\n                ('minutes', _(\"in minutes\"))\n            ),\n        ),\n        'form_kwargs': dict(\n            label=_(\"Set payment term\"),\n            widget=forms.RadioSelect,\n            required=True,\n            choices=(\n                ('days', _(\"in days\")),\n                ('minutes', _(\"in minutes\"))\n            ),\n            help_text=_(\"If using days, the order will expire at the end of the last day. \"\n                        \"Using minutes is more exact, but should only be used for real-time payment methods.\")\n        )\n    },\n    'payment_term_days': {\n        'default': '14',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Payment term in days'),\n            widget=forms.NumberInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_0',\n                    'data-required-if': '#id_payment_term_mode_0'\n                },\n            ),\n            help_text=_(\"The number of days after placing an order the user has to pay to preserve their reservation. If \"\n                        \"you use slow payment methods like bank transfer, we recommend 14 days. If you only use real-time \"\n                        \"payment methods, we recommend still setting two or three days to allow people to retry failed \"\n                        \"payments.\"),\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1000000)]\n        ),\n        'serializer_kwargs': dict(\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1000000)]\n        )\n    },\n    'payment_term_weekdays': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Only end payment terms on weekdays'),\n            help_text=_(\"If this is activated and the payment term of any order ends on a Saturday or Sunday, it will be \"\n                        \"moved to the next Monday instead. This is required in some countries by civil law. This will \"\n                        \"not effect the last date of payments configured below.\"),\n            widget=forms.CheckboxInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_0',\n                },\n            ),\n        )\n    },\n    'payment_term_minutes': {\n        'default': '30',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Payment term in minutes'),\n            help_text=_(\"The number of minutes after placing an order the user has to pay to preserve their reservation. \"\n                        \"Only use this if you exclusively offer real-time payment methods. Please note that for technical reasons, \"\n                        \"the actual time frame might be a few minutes longer before the order is marked as expired.\"),\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1440)],\n            widget=forms.NumberInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_1',\n                    'data-required-if': '#id_payment_term_mode_1'\n                },\n            ),\n        ),\n        'serializer_kwargs': dict(\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1440)]\n        )\n    },\n    'payment_term_last': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateField,\n        'serializer_class': SerializerRelativeDateField,\n        'form_kwargs': dict(\n            label=_('Last date of payments'),\n            help_text=_(\"The last date any payments are accepted. This has precedence over the terms \"\n                        \"configured above. If you use the event series feature and an order contains tickets for \"\n                        \"multiple dates, the earliest date will be used.\"),\n        )\n    },\n    'payment_term_expire_automatically': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Automatically expire unpaid orders'),\n            help_text=_(\"If checked, all unpaid orders will automatically go from 'pending' to 'expired' \"\n                        \"after the end of their payment deadline. This means that those tickets go back to \"\n                        \"the pool and can be ordered by other people.\"),\n        )\n    },\n    'payment_term_expire_delay_days': {\n        'default': '0',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Expiration delay'),\n            help_text=_(\"The order will only actually expire this many days after the expiration date communicated \"\n                        \"to the customer. If you select \\\"Only end payment terms on weekdays\\\" above, this will also \"\n                        \"be respected. However, this will not delay beyond the \\\"last date of payments\\\" \"\n                        \"configured above, which is always enforced.\"),\n            # Every order in between the official expiry date and the delayed expiry date has a performance penalty\n            # for the cron job, so we limit this feature to 30 days to prevent arbitrary numbers of orders needing\n            # to be checked.\n            min_value=0,\n            max_value=30,\n        ),\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=30,\n        ),\n    },\n    'payment_pending_hidden': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Hide \"payment pending\" state on customer-facing pages'),\n            help_text=_(\"The payment instructions panel will still be shown to the primary customer, but no indication \"\n                        \"of missing payment will be visible on the ticket pages of attendees who did not buy the ticket \"\n                        \"themselves.\")\n        )\n    },\n    'payment_giftcard__enabled': {\n        'default': 'True',\n        'type': bool\n    },\n    'payment_giftcard_public_name': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Gift card')),\n        'type': LazyI18nString\n    },\n    'payment_giftcard_public_description': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'If you have a gift card, please enter the gift card code here. If the gift card does not have '\n            'enough credit to pay for the full order, you will be shown this page again and you can either '\n            'redeem another gift card or select a different payment method for the difference.'\n        )),\n        'type': LazyI18nString\n    },\n    'payment_resellers__restrict_to_sales_channels': {\n        'default': ['resellers'],\n        'type': list\n    },\n    'payment_term_accept_late': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Accept late payments'),\n            help_text=_(\"Accept payments for orders even when they are in 'expired' state as long as enough \"\n                        \"capacity is available. No payments will ever be accepted after the 'Last date of payments' \"\n                        \"configured above.\"),\n        )\n    },\n    'presale_start_show_date': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show start date\"),\n            help_text=_(\"Show the presale start date before presale has started.\"),\n            widget=forms.CheckboxInput,\n        )\n    },\n    'tax_rate_default': {\n        'default': None,\n        'type': TaxRule\n    },\n    'invoice_generate': {\n        'default': 'False',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('False', _('Do not generate invoices')),\n                ('admin', _('Only manually in admin panel')),\n                ('user', _('Automatically on user request')),\n                ('True', _('Automatically for all created orders')),\n                ('paid', _('Automatically on payment or when required by payment method')),\n            ),\n        ),\n        'form_kwargs': dict(\n            label=_(\"Generate invoices\"),\n            widget=forms.RadioSelect,\n            choices=(\n                ('False', _('Do not generate invoices')),\n                ('admin', _('Only manually in admin panel')),\n                ('user', _('Automatically on user request')),\n                ('True', _('Automatically for all created orders')),\n                ('paid', _('Automatically on payment or when required by payment method')),\n            ),\n            help_text=_(\"Invoices will never be automatically generated for free orders.\")\n        )\n    },\n    'invoice_reissue_after_modify': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically cancel and reissue invoice on address changes\"),\n            help_text=_(\"If customers change their invoice address on an existing order, the invoice will \"\n                        \"automatically be canceled and a new invoice will be issued. This setting does not affect \"\n                        \"changes made through the backend.\"),\n        )\n    },\n    'invoice_regenerate_allowed': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow to update existing invoices\"),\n            help_text=_(\"By default, invoices can never again be changed once they are issued. In most countries, we \"\n                        \"recommend to leave this option turned off and always issue a new invoice if a change needs \"\n                        \"to be made.\"),\n        )\n    },\n    'invoice_generate_sales_channels': {\n        'default': json.dumps(['web']),\n        'type': list\n    },\n    'invoice_address_from': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Address line\"),\n            widget=forms.Textarea(attrs={\n                'rows': 2,\n                'placeholder': _(\n                    'Albert Einstein Road 52'\n                )\n            }),\n        )\n    },\n    'invoice_address_from_name': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Company name\"),\n        )\n    },\n    'invoice_address_from_zipcode': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            widget=forms.TextInput(attrs={\n                'placeholder': '12345'\n            }),\n            label=_(\"ZIP code\"),\n        )\n    },\n    'invoice_address_from_city': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            widget=forms.TextInput(attrs={\n                'placeholder': _('Random City')\n            }),\n            label=_(\"City\"),\n        )\n    },\n    'invoice_address_from_country': {\n        'default': '',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**country_choice_kwargs()),\n        'form_kwargs': lambda: dict(label=_('Country'), **country_choice_kwargs()),\n    },\n    'invoice_address_from_tax_id': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Domestic tax ID\"),\n            help_text=_(\"e.g. tax number in Germany, ABN in Australia, \u2026\")\n        )\n    },\n    'invoice_address_from_vat_id': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"EU VAT ID\"),\n        )\n    },\n    'invoice_introductory_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n                'placeholder': _(\n                    'e.g. With this document, we sent you the invoice for your ticket order.'\n                )\n            }},\n            label=_(\"Introductory text\"),\n            help_text=_(\"Will be printed on every invoice above the invoice rows.\")\n        )\n    },\n    'invoice_additional_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n                'placeholder': _(\n                    'e.g. Thank you for your purchase! You can find more information on the event at ...'\n                )\n            }},\n            label=_(\"Additional text\"),\n            help_text=_(\"Will be printed on every invoice below the invoice total.\")\n        )\n    },\n    'invoice_footer_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 5,\n                'placeholder': _(\n                    'e.g. your bank details, legal details like your VAT ID, registration numbers, etc.'\n                )\n            }},\n            label=_(\"Footer\"),\n            help_text=_(\"Will be printed centered and in a smaller font at the end of every invoice page.\")\n        )\n    },\n    'invoice_language': {\n        'default': '__user__',\n        'type': str\n    },\n    'invoice_email_attachment': {\n        'default': 'False',  # default for new events is True\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach invoices to emails\"),\n            help_text=_(\"If invoices are automatically generated for all orders, they will be attached to the order \"\n                        \"confirmation mail. If they are automatically generated on payment, they will be attached to the \"\n                        \"payment confirmation mail. If they are not automatically generated, they will not be attached \"\n                        \"to emails.\"),\n        )\n    },\n    'invoice_email_organizer': {\n        'default': '',\n        'type': str,\n        'form_class': forms.EmailField,\n        'serializer_class': serializers.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Email address to receive a copy of each invoice\"),\n            help_text=_(\"Each newly created invoice will be sent to this email address shortly after creation. You can \"\n                        \"use this for an automated import of invoices to your accounting system. The invoice will be \"\n                        \"the only attachment of the email.\"),\n        )\n    },\n    'show_items_outside_presale_period': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show items outside presale period\"),\n            help_text=_(\"Show item details before presale has started and after presale has ended\"),\n        )\n    },\n    'timezone': {\n        'default': settings.TIME_ZONE,\n        'type': str\n    },\n    'locales': {\n        'default': json.dumps([settings.LANGUAGE_CODE]),\n        'type': list,\n        'serializer_class': ListMultipleChoiceField,\n        'serializer_kwargs': dict(\n            choices=settings.LANGUAGES,\n            required=True,\n        ),\n        'form_class': forms.MultipleChoiceField,\n        'form_kwargs': dict(\n            choices=settings.LANGUAGES,\n            widget=MultipleLanguagesWidget,\n            required=True,\n            label=_(\"Available languages\"),\n        )\n    },\n    'locale': {\n        'default': settings.LANGUAGE_CODE,\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=settings.LANGUAGES,\n            required=True,\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            choices=settings.LANGUAGES,\n            widget=SingleLanguageWidget,\n            required=True,\n            label=_(\"Default language\"),\n        )\n    },\n    'region': {\n        'default': None,\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**country_choice_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Region'),\n            help_text=_('Will be used to determine date and time formatting as well as default country for customer '\n                        'addresses and phone numbers. For formatting, this takes less priority than the language and '\n                        'is therefore mostly relevant for languages used in different regions globally (like English).'),\n            **country_choice_kwargs()\n        ),\n    },\n    'show_dates_on_frontpage': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event times and dates on the ticket shop\"),\n            help_text=_(\"If disabled, no date or time will be shown on the ticket shop's front page. This settings \"\n                        \"does however not affect the display in other locations.\"),\n        )\n    },\n    'show_date_to': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event end date\"),\n            help_text=_(\"If disabled, only event's start date will be displayed to the public.\"),\n        )\n    },\n    'show_times': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show dates with time\"),\n            help_text=_(\"If disabled, the event's start and end date will be displayed without the time of day.\"),\n        )\n    },\n    'hide_sold_out': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all products that are sold out\"),\n        )\n    },\n    'show_quota_left': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show number of tickets left\"),\n            help_text=_(\"Publicly show how many tickets of a certain type are still available.\"),\n        )\n    },\n    'meta_noindex': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Ask search engines not to index the ticket shop'),\n        )\n    },\n    'show_variations_expanded': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show variations of a product expanded by default\"),\n        )\n    },\n    'waiting_list_enabled': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Enable waiting list\"),\n            help_text=_(\"Once a ticket is sold out, people can add themselves to a waiting list. As soon as a ticket \"\n                        \"becomes available again, it will be reserved for the first person on the waiting list and this \"\n                        \"person will receive an email notification with a voucher that can be used to buy a ticket.\"),\n        )\n    },\n    'waiting_list_auto': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatic waiting list assignments\"),\n            help_text=_(\"If ticket capacity becomes free, automatically create a voucher and send it to the first person \"\n                        \"on the waiting list for that product. If this is not active, mails will not be send automatically \"\n                        \"but you can send them manually via the control panel. If you disable the waiting list but keep \"\n                        \"this option enabled, tickets will still be sent out.\"),\n            widget=forms.CheckboxInput(),\n        )\n    },\n    'waiting_list_hours': {\n        'default': '48',\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Waiting list response time\"),\n            min_value=1,\n            required=True,\n            help_text=_(\"If a ticket voucher is sent to a person on the waiting list, it has to be redeemed within this \"\n                        \"number of hours until it expires and can be re-assigned to the next person on the list.\"),\n            widget=forms.NumberInput(),\n        )\n    },\n    'waiting_list_names_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a name\"),\n            help_text=_(\"Ask for a name when signing up to the waiting list.\"),\n        )\n    },\n    'waiting_list_names_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require name\"),\n            help_text=_(\"Require a name when signing up to the waiting list..\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-waiting_list_names_asked'}),\n        )\n    },\n    'waiting_list_phones_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a phone number\"),\n            help_text=_(\"Ask for a phone number when signing up to the waiting list.\"),\n        )\n    },\n    'waiting_list_phones_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require phone number\"),\n            help_text=_(\"Require a phone number when signing up to the waiting list..\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-waiting_list_phones_asked'}),\n        )\n    },\n    'waiting_list_phones_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Phone number explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"If you ask for a phone number, explain why you do so and what you will use the phone number for.\")\n        )\n    },\n    'waiting_list_limit_per_user': {\n        'default': '1',\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Maximum number of entries per email address for the same product\"),\n            min_value=1,\n            required=True,\n            widget=forms.NumberInput(),\n        )\n    },\n    'show_checkin_number_user': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show number of check-ins to customer\"),\n            help_text=_('With this option enabled, your customers will be able to see how many times they entered '\n                        'the event. This is usually not necessary, but might be useful in combination with tickets '\n                        'that are usable a specific number of times, so customers can see how many times they have '\n                        'already been used. Exits or failed scans will not be counted, and the user will not see '\n                        'the different check-in lists.'),\n        )\n    },\n    'ticket_download': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow users to download tickets\"),\n            help_text=_(\"If this is off, nobody can download a ticket.\"),\n        )\n    },\n    'ticket_download_date': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Download date\"),\n            help_text=_(\"Ticket download will be offered after this date. If you use the event series feature and an order \"\n                        \"contains tickets for multiple event dates, download of all tickets will be available if at least \"\n                        \"one of the event dates allows it.\"),\n        )\n    },\n    'ticket_download_addons': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for add-on products and bundled products\"),\n            help_text=_('By default, tickets are only issued for products selected individually, not for add-on products '\n                        'or bundled products. With this option, a separate ticket is issued for every add-on product '\n                        'or bundled product as well.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_nonadm': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for all products\"),\n            help_text=_('If turned off, tickets are only issued for products that are marked as an \"admission ticket\"'\n                        'in the product settings. You can also turn off ticket issuing in every product separately.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_pending': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for pending orders\"),\n            help_text=_('If turned off, ticket downloads are only possible after an order has been marked as paid.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_require_validated_email': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Do not issue ticket before email address is validated\"),\n            help_text=_(\"If turned on, tickets will not be offered for download directly after purchase. They will \"\n                        \"be attached to the payment confirmation email (if the file size is not too large), and the \"\n                        \"customer will be able to download them from the page as soon as they clicked a link in \"\n                        \"the email. Does not affect orders performed through other sales channels.\"),\n        )\n    },\n    'low_availability_percentage': {\n        'default': None,\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=100,\n        ),\n        'form_kwargs': dict(\n            label=_('Low availability threshold'),\n            help_text=_('If the availability of tickets falls below this percentage, the event (or a date, if it is an '\n                        'event series) will be highlighted to have low availability in the event list or calendar. If '\n                        'you keep this option empty, low availability will not be shown publicly.'),\n            min_value=0,\n            max_value=100,\n            required=False\n        )\n    },\n    'event_list_availability': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Show availability in event overviews'),\n            help_text=_('If checked, the list of events will show if events are sold out. This might '\n                        'make for longer page loading times if you have lots of events and the shown status might be out '\n                        'of date for up to two minutes.'),\n            required=False\n        )\n    },\n    'event_list_type': {\n        'default': 'list',  # default for new events is 'calendar'\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('list', _('List')),\n                ('week', _('Week calendar')),\n                ('calendar', _('Month calendar')),\n            )\n        ),\n        'form_kwargs': dict(\n            label=_('Default overview style'),\n            choices=(\n                ('list', _('List')),\n                ('week', _('Week calendar')),\n                ('calendar', _('Month calendar')),\n            ),\n            help_text=_('If your event series has more than 50 dates in the future, only the month or week calendar can be used.')\n        ),\n    },\n    'event_list_available_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all unavailable dates from calendar or list views\"),\n            help_text=_(\"This option currently only affects the calendar of this event series, not the organizer-wide \"\n                        \"calendar.\")\n        )\n    },\n    'event_calendar_future_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all past dates from calendar\"),\n            help_text=_(\"This option currently only affects the calendar of this event series, not the organizer-wide \"\n                        \"calendar.\")\n        )\n    },\n    'allow_modifications_after_checkin': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to modify their information after they checked in.\"),\n        )\n    },\n    'last_order_modification_date': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_('Last date of modifications'),\n            help_text=_(\"The last date users can modify details of their orders, such as attendee names or \"\n                        \"answers to questions. If you use the event series feature and an order contains tickets for \"\n                        \"multiple event dates, the earliest date will be used.\"),\n        )\n    },\n    'change_allow_user_variation': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can change the variation of the products they purchased\"),\n        )\n    },\n    'change_allow_user_addons': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can change their selected add-on products\"),\n        )\n    },\n    'change_allow_user_price': {\n        'default': 'gte',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('gte', _('Only allow changes if the resulting price is higher or equal than the previous price.')),\n                ('gt', _('Only allow changes if the resulting price is higher than the previous price.')),\n                ('eq', _('Only allow changes if the resulting price is equal to the previous price.')),\n                ('any', _('Allow changes regardless of price, even if this results in a refund.')),\n            )\n        ),\n        'form_kwargs': dict(\n            label=_(\"Requirement for changed prices\"),\n            choices=(\n                ('gte', _('Only allow changes if the resulting price is higher or equal than the previous price.')),\n                ('gt', _('Only allow changes if the resulting price is higher than the previous price.')),\n                ('eq', _('Only allow changes if the resulting price is equal to the previous price.')),\n                ('any', _('Allow changes regardless of price, even if this results in a refund.')),\n            ),\n            widget=forms.RadioSelect,\n        ),\n    },\n    'change_allow_user_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow changes after\"),\n        )\n    },\n    'change_allow_user_if_checked_in': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow change even though the ticket has already been checked in\"),\n            help_text=_(\"By default, order changes are disabled after any ticket in the order has been checked in. \"\n                        \"If you check this box, this requirement is lifted. It is still not possible to remove an \"\n                        \"add-on product that has already been checked in individually. Use with care, and preferably \"\n                        \"only in combination with a limitation on price changes above.\"),\n        )\n    },\n    'change_allow_attendee': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow individual attendees to change their ticket\"),\n            help_text=_(\"By default, only the person who ordered the tickets can make any changes. If you check this \"\n                        \"box, individual attendees can also make changes. However, individual attendees can always \"\n                        \"only make changes that do not change the total price of the order. Such changes can always \"\n                        \"only be made by the main customer.\"),\n        )\n    },\n    'cancel_allow_user': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can cancel their unpaid orders\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Charge a fixed cancellation fee\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Charge payment, shipping and service fees\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep_percentage': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Charge a percentual cancellation fee\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow cancellations after\"),\n        )\n    },\n    'cancel_allow_user_paid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can cancel their paid orders\"),\n            help_text=_(\"Paid money will be automatically paid back if the payment method allows it. \"\n                        \"Otherwise, a manual refund will be created for you to process manually.\"),\n        )\n    },\n    'cancel_allow_user_paid_keep': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Keep a fixed cancellation fee\"),\n        )\n    },\n    'cancel_allow_user_paid_keep_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Keep payment, shipping and service fees\"),\n        )\n    },\n    'cancel_allow_user_paid_keep_percentage': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Keep a percentual cancellation fee\"),\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to voluntarily choose a lower refund\"),\n            help_text=_(\"With this option enabled, your customers can choose to get a smaller refund to support you.\")\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees_explanation': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'However, if you want us to help keep the lights on here, please consider using the slider below to '\n            'request a smaller refund. Thank you!'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Voluntary lower refund explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown in between the explanation of how the refunds work and the slider \"\n                        \"which your customers can use to choose the amount they would like to receive. You can use it \"\n                        \"e.g. to explain choosing a lower refund will help your organization.\")\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees_step': {\n        'default': None,\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            max_digits=13, decimal_places=2,\n            label=_(\"Step size for reduction amount\"),\n            help_text=_('By default, customers can choose an arbitrary amount for you to keep. If you set this to e.g. '\n                        '10, they will only be able to choose values in increments of 10.')\n        )\n    },\n    'cancel_allow_user_paid_require_approval': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can only request a cancellation that needs to be approved by the event organizer \"\n                    \"before the order is canceled and a refund is issued.\"),\n        )\n    },\n    'cancel_allow_user_paid_require_approval_fee_unknown': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Do not show the cancellation fee to users when they request cancellation.\"),\n        )\n    },\n    'cancel_allow_user_paid_refund_as_giftcard': {\n        'default': 'off',\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[\n                ('off', _('All refunds are issued to the original payment method')),\n                ('option', _('Customers can choose between a gift card and a refund to their payment method')),\n                ('force', _('All refunds are issued as gift cards')),\n                ('manually', _('Do not handle refunds automatically at all')),\n            ],\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            label=_('Refund method'),\n            choices=[\n                ('off', _('All refunds are issued to the original payment method')),\n                ('option', _('Customers can choose between a gift card and a refund to their payment method')),\n                ('force', _('All refunds are issued as gift cards')),\n                ('manually', _('Do not handle refunds automatically at all')),\n            ],\n            widget=forms.RadioSelect,\n            # When adding a new ordering, remember to also define it in the event model\n        )\n    },\n    'cancel_allow_user_paid_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow cancellations after\"),\n        )\n    },\n    'contact_mail': {\n        'default': None,\n        'type': str,\n        'serializer_class': serializers.EmailField,\n        'form_class': forms.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Contact address\"),\n            help_text=_(\"We'll show this publicly to allow attendees to contact you.\")\n        )\n    },\n    'imprint_url': {\n        'default': None,\n        'type': str,\n        'form_class': forms.URLField,\n        'form_kwargs': dict(\n            label=_(\"Imprint URL\"),\n            help_text=_(\"This should point e.g. to a part of your website that has your contact details and legal \"\n                        \"information.\"),\n        ),\n        'serializer_class': serializers.URLField,\n    },\n    'privacy_url': {\n        'default': None,\n        'type': LazyI18nString,\n        'form_class': I18nURLFormField,\n        'form_kwargs': dict(\n            label=_(\"Privacy Policy URL\"),\n            help_text=_(\"This should point e.g. to a part of your website that explains how you use data gathered in \"\n                        \"your ticket shop.\"),\n            widget=I18nTextInput,\n        ),\n        'serializer_class': I18nURLField,\n    },\n    'confirm_texts': {\n        'default': LazyI18nStringList(),\n        'type': LazyI18nStringList,\n        'serializer_class': serializers.ListField,\n        'serializer_kwargs': lambda: dict(child=I18nField()),\n    },\n    'mail_html_renderer': {\n        'default': 'classic',\n        'type': str\n    },\n    'mail_attach_tickets': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach ticket files\"),\n            help_text=format_lazy(\n                _(\"Tickets will never be attached if they're larger than {size} to avoid email delivery problems.\"),\n                size='4 MB'\n            ),\n        )\n    },\n    'mail_attach_ical': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach calendar files\"),\n            help_text=_(\"If enabled, we will attach an .ics calendar file to order confirmation emails.\"),\n        )\n    },\n    'mail_attach_ical_paid_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach calendar files only after order has been paid\"),\n            help_text=_(\"Use this if you e.g. put a private access link into the calendar file to make sure people only \"\n                        \"receive it after their payment was confirmed.\"),\n        )\n    },\n    'mail_attach_ical_description': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Event description\"),\n            widget=I18nTextarea,\n            help_text=_(\n                \"You can use this to share information with your attendees, such as travel information or the link to a digital event. \"\n                \"If you keep it empty, we will put a link to the event shop, the admission time, and your organizer name in there. \"\n                \"We do not allow using placeholders with sensitive person-specific data as calendar entries are often shared with an \"\n                \"unspecified number of people.\"\n            ),\n        )\n    },\n    'mail_prefix': {\n        'default': None,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Subject prefix\"),\n            help_text=_(\"This will be prepended to the subject of all outgoing emails, formatted as [prefix]. \"\n                        \"Choose, for example, a short form of your event name.\"),\n        )\n    },\n    'mail_bcc': {\n        'default': None,\n        'type': str\n    },\n    'mail_from': {\n        'default': settings.MAIL_FROM_ORGANIZERS,\n        'type': str,\n        'form_class': forms.EmailField,\n        'serializer_class': serializers.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Sender address\"),\n            help_text=_(\"Sender address for outgoing emails\"),\n        )\n    },\n    'mail_from_name': {\n        'default': None,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Sender name\"),\n            help_text=_(\"Sender name used in conjunction with the sender address for outgoing emails. \"\n                        \"Defaults to your event name.\"),\n        )\n    },\n    'mail_sales_channel_placed_paid': {\n        'default': ['web'],\n        'type': list,\n    },\n    'mail_sales_channel_download_reminder': {\n        'default': ['web'],\n        'type': list,\n    },\n    'mail_text_signature': {\n        'type': LazyI18nString,\n        'default': \"\"\n    },\n    'mail_subject_resend_link': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_subject_resend_link_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_resend_link': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou receive this message because you asked us to send you the link\nto your order for {event}.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_resend_all_links': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your orders for {event}\")),\n    },\n    'mail_text_resend_all_links': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nsomebody requested a list of your orders for {event}.\nThe list is as follows:\n\n{orders}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\nyou have been registered for {event} successfully.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_free_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order for {event} was successful. As you only ordered free products,\nno payment is required.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_placed_require_approval': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_placed_require_approval': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your order for {event}. Since you ordered\na product that requires approval by the event organizer, we ask you to\nbe patient and wait for our next email.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_placed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_placed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your order for {event} with a total value\nof {total_with_currency}. Please complete your payment before {expire_date}.\n\n{payment_info}\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_attachment_new_order': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Attachment for new orders'),\n            ext_whitelist=(\".pdf\",),\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT,\n            help_text=format_lazy(\n                _(\n                    'This file will be attached to the first email that we send for every new order. Therefore it will be '\n                    'combined with the \"Placed order\", \"Free order\", or \"Received order\" texts from above. It will be sent '\n                    'to both order contacts and attendees. You can use this e.g. to send your terms of service. Do not use '\n                    'it to send non-public information as this file might be sent before payment is confirmed or the order '\n                    'is approved. To avoid this vital email going to spam, you can only upload PDF files of up to {size} MB.'\n                ),\n                size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT // (1024 * 1024),\n            )\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'application/pdf'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT,\n        )\n    },\n    'mail_send_order_placed_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_placed_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_placed_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\na ticket for {event} has been ordered for you.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_changed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order has been changed: {code}\")),\n    },\n    'mail_text_order_changed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order for {event} has been changed.\n\nYou can view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_paid': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Payment received for your order: {code}\")),\n    },\n    'mail_text_order_paid': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your payment for {event}. Thank you!\n\n{payment_info}\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_paid_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_paid_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Event registration confirmed: {code}\")),\n    },\n    'mail_text_order_paid_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\na ticket for {event} that has been ordered for you is now paid.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_days_order_expire_warning': {\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Number of days\"),\n            min_value=0,\n            help_text=_(\"This email will be sent out this many days before the order expires. If the \"\n                        \"value is 0, the mail will never be sent.\")\n        ),\n        'type': int,\n        'default': '3'\n    },\n    'mail_subject_order_expire_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order is about to expire: {code}\")),\n    },\n    'mail_text_order_expire_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe did not yet receive a full payment for your order for {event}.\nPlease keep in mind that we only guarantee your order if we receive\nyour payment before {expire_date}.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_pending_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order is pending payment: {code}\")),\n    },\n    'mail_text_order_pending_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe did not yet receive a full payment for your order for {event}.\nPlease keep in mind that you are required to pay before {expire_date}.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_incomplete_payment': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Incomplete payment received: {code}\")),\n    },\n    'mail_text_order_incomplete_payment': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe received a payment for your order for {event}.\n\nUnfortunately, the received amount is less than the full amount\nrequired. Your order is therefore still considered unpaid, as it is\nmissing additional payment of **{pending_sum}**.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_payment_failed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Payment failed for your order: {code}\")),\n    },\n    'mail_text_order_payment_failed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour payment attempt for your order for {event} has failed.\n\nYour order is still valid and you can try to pay again using the same or a different payment method. Please complete your payment before {expire_date}.\n\nYou can retry the payment and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_waiting_list': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"You have been selected from the waitinglist for {event}\")),\n    },\n    'mail_text_waiting_list': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou submitted yourself to the waiting list for {event},\nfor the product {product}.\n\nWe now have a ticket ready for you! You can redeem it in our ticket shop\nwithin the next {hours} hours by entering the following voucher code:\n\n{code}\n\nAlternatively, you can just click on the following link:\n\n{url}\n\nPlease note that this link is only valid within the next {hours} hours!\nWe will reassign the ticket to the next person on the list if you do not\nredeem the voucher within that timeframe.\n\nIf you do NOT need a ticket any more, we kindly ask you to click the\nfollowing link to let us know. This way, we can send the ticket as quickly\nas possible to the next person on the waiting list:\n\n{url_remove}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_canceled': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order canceled: {code}\")),\n    },\n    'mail_text_order_canceled': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order {code} for {event} has been canceled.\n\n{comment}\n\nYou can view the details of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_approved': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order approved and awaiting payment: {code}\")),\n    },\n    'mail_text_order_approved': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved your order for {event} and will be happy to welcome you\nat our event.\n\nPlease continue by paying for your order before {expire_date}.\n\nYou can select a payment method and perform the payment here:\n\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_approved_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_approved_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_approved_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved a ticket ordered for you for {event}.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_approved_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order approved and confirmed: {code}\")),\n    },\n    'mail_text_order_approved_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved your order for {event} and will be happy to welcome you\nat our event. As you only ordered free products, no payment is required.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_approved_free_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_approved_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_approved_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved a ticket ordered for you for {event}.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_denied': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order denied: {code}\")),\n    },\n    'mail_text_order_denied': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nunfortunately, we denied your order request for {event}.\n\n{comment}\n\nYou can view the details of your order here:\n\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_text_order_custom_mail': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_days_download_reminder': {\n        'type': int,\n        'default': None\n    },\n    'mail_send_download_reminder_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_download_reminder_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your ticket is ready for download: {code}\")),\n    },\n    'mail_text_download_reminder_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\nyou are registered for {event}.\n\nIf you did not do so already, you can download your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_download_reminder': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your ticket is ready for download: {code}\")),\n    },\n    'mail_text_download_reminder': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou bought a ticket for {event}.\n\nIf you did not do so already, you can download your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_registration': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Activate your account at {organizer}\")),\n    },\n    'mail_text_customer_registration': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nthank you for signing up for an account at {organizer}!\n\nTo activate your account and set a password, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not sign up yourself, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_email_change': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Confirm email address for your account at {organizer}\")),\n    },\n    'mail_text_customer_email_change': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nyou requested to change the email address of your account at {organizer}!\n\nTo confirm the change, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not request this, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_reset': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Set a new password for your account at {organizer}\")),\n    },\n    'mail_text_customer_reset': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nyou requested a new password for your account at {organizer}!\n\nTo set a new password, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not request a new password, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'smtp_use_custom': {\n        'default': 'False',\n        'type': bool\n    },\n    'smtp_host': {\n        'default': '',\n        'type': str\n    },\n    'smtp_port': {\n        'default': 587,\n        'type': int\n    },\n    'smtp_username': {\n        'default': '',\n        'type': str\n    },\n    'smtp_password': {\n        'default': '',\n        'type': str\n    },\n    'smtp_use_tls': {\n        'default': 'True',\n        'type': bool\n    },\n    'smtp_use_ssl': {\n        'default': 'False',\n        'type': bool\n    },\n    'primary_color': {\n        'default': settings.PRETIX_PRIMARY_COLOR,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Primary color\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_success': {\n        'default': '#50a167',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Accent color for success\"),\n            help_text=_(\"We strongly suggest to use a shade of green.\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_danger': {\n        'default': '#c44f4f',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Accent color for errors\"),\n            help_text=_(\"We strongly suggest to use a shade of red.\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_background': {\n        'default': '#f5f5f5',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Page background color\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield no-contrast'})\n        ),\n    },\n    'theme_round_borders': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use round edges\"),\n        )\n    },\n    'widget_use_native_spinners': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use native spinners in the widget instead of custom ones for numeric inputs such as quantity.\"),\n        )\n    },\n    'primary_font': {\n        'default': 'Open Sans',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**primary_font_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Font'),\n            help_text=_('Only respected by modern browsers.'),\n            required=True,\n            widget=FontSelect,\n            **primary_font_kwargs()\n        ),\n    },\n    'presale_css_file': {\n        'default': None,\n        'type': str\n    },\n    'presale_css_checksum': {\n        'default': None,\n        'type': str\n    },\n    'presale_widget_css_file': {\n        'default': None,\n        'type': str\n    },\n    'presale_widget_css_checksum': {\n        'default': None,\n        'type': str\n    },\n    'logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Header image'),\n            ext_whitelist=(\".png\", \".jpg\", \".gif\", \".jpeg\"),\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('If you provide a logo image, we will by default not show your event name and date '\n                        'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                        'can increase the size with the setting below. We recommend not using small details on the picture '\n                        'as it will be resized on smaller screens.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n\n    },\n    'logo_image_large': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image in its full size'),\n            help_text=_('We recommend to upload a picture at least 1170 pixels wide.'),\n        )\n    },\n    'logo_show_title': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Show event title even if a header image is present'),\n            help_text=_('The title will only be shown on the event front page. If no header image is uploaded for the event, but the header image '\n                        'from the organizer profile is used, this option will be ignored and the event title will always be shown.'),\n        )\n    },\n    'organizer_logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Header image'),\n            ext_whitelist=(\".png\", \".jpg\", \".gif\", \".jpeg\"),\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('If you provide a logo image, we will by default not show your organization name '\n                        'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                        'can increase the size with the setting below. We recommend not using small details on the picture '\n                        'as it will be resized on smaller screens.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'organizer_logo_image_large': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image in its full size'),\n            help_text=_('We recommend to upload a picture at least 1170 pixels wide.'),\n        )\n    },\n    'organizer_logo_image_inherit': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image also for events without an individually uploaded logo'),\n        )\n    },\n    'og_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Social media image'),\n            ext_whitelist=(\".png\", \".jpg\", \".gif\", \".jpeg\"),\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('This picture will be used as a preview if you post links to your ticket shop on social media. '\n                        'Facebook advises to use a picture size of 1200 x 630 pixels, however some platforms like '\n                        'WhatsApp and Reddit only show a square preview, so we recommend to make sure it still looks good '\n                        'only the center square is shown. If you do not fill this, we will use the logo given above.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'invoice_logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Logo image'),\n            ext_whitelist=(\".png\", \".jpg\", \".gif\", \".jpeg\"),\n            required=False,\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('We will show your logo with a maximal height and width of 2.5 cm.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'frontpage_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Frontpage text\"),\n            widget=I18nTextarea\n        )\n    },\n    'event_info_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Info text'),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_('Not displayed anywhere by default, but if you want to, you can use this e.g. in ticket templates.')\n        )\n    },\n    'banner_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Banner text (top)\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above every page of your shop. Please only use this for \"\n                        \"very important messages.\")\n        )\n    },\n    'banner_text_bottom': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Banner text (bottom)\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown below every page of your shop. Please only use this for \"\n                        \"very important messages.\")\n        )\n    },\n    'voucher_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Voucher explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown next to the input for a voucher code. You can use it e.g. to explain \"\n                        \"how to obtain a voucher code.\")\n        )\n    },\n    'attendee_data_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Attendee data explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the questions asked for every personalized product. You can use it e.g. to explain \"\n                        \"why you need information from them.\")\n        )\n    },\n    'checkout_success_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Additional success message\"),\n            help_text=_(\"This message will be shown after an order has been created successfully. It will be shown in additional \"\n                        \"to the default text.\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'checkout_phone_helptext': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Help text of the phone number field\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'checkout_email_helptext': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'Make sure to enter a valid email address. We will send you an order '\n            'confirmation including a link that you need to access your order later.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Help text of the email field\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'order_import_settings': {\n        'default': '{}',\n        'type': dict\n    },\n    'organizer_info_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Info text'),\n            widget=I18nTextarea,\n            help_text=_('Not displayed anywhere by default, but if you want to, you can use this e.g. in ticket templates.')\n        )\n    },\n    'event_team_provisioning': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Allow creating a new team during event creation'),\n            help_text=_('Users that do not have access to all events under this organizer, must select one of their teams '\n                        'to have access to the created event. This setting allows users to create an event-specified team'\n                        ' on-the-fly, even when they do not have \\\"Can change teams and permissions\\\" permission.'),\n        )\n    },\n    'license_check_completed': {\n        'default': None,\n        'type': datetime\n    },\n    'license_check_input': {\n        'default': '{}',\n        'type': dict\n    },\n    'update_check_ack': {\n        'default': 'False',\n        'type': bool\n    },\n    'update_check_email': {\n        'default': '',\n        'type': str\n    },\n    'update_check_perform': {\n        'default': 'True',\n        'type': bool\n    },\n    'update_check_result': {\n        'default': None,\n        'type': dict\n    },\n    'update_check_result_warning': {\n        'default': 'False',\n        'type': bool\n    },\n    'update_check_last': {\n        'default': None,\n        'type': datetime\n    },\n    'update_check_id': {\n        'default': None,\n        'type': str\n    },\n    'banner_message': {\n        'default': '',\n        'type': LazyI18nString\n    },\n    'banner_message_detail': {\n        'default': '',\n        'type': LazyI18nString\n    },\n    'opencagedata_apikey': {\n        'default': None,\n        'type': str\n    },\n    'mapquest_apikey': {\n        'default': None,\n        'type': str\n    },\n    'leaflet_tiles': {\n        'default': None,\n        'type': str\n    },\n    'leaflet_tiles_attribution': {\n        'default': None,\n        'type': str\n    },\n    'frontpage_subevent_ordering': {\n        'default': 'date_ascending',\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[\n                ('date_ascending', _('Event start time')),\n                ('date_descending', _('Event start time (descending)')),\n                ('name_ascending', _('Name')),\n                ('name_descending', _('Name (descending)')),\n            ],\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            label=pgettext('subevent', 'Date ordering'),\n            choices=[\n                ('date_ascending', _('Event start time')),\n                ('date_descending', _('Event start time (descending)')),\n                ('name_ascending', _('Name')),\n                ('name_descending', _('Name (descending)')),\n            ],\n            # When adding a new ordering, remember to also define it in the event model\n        )\n    },\n    'organizer_link_back': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Link back to organizer overview on all event pages'),\n        )\n    },\n    'organizer_homepage_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Homepage text'),\n            widget=I18nTextarea,\n            help_text=_('This will be displayed on the organizer homepage.')\n        )\n    },\n    'name_scheme': {\n        'default': 'full',  # default for new events is 'given_family'\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': {},\n    },\n    'giftcard_length': {\n        'default': settings.ENTROPY['giftcard_secret'],\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Length of gift card codes'),\n            help_text=_('The system generates by default {}-character long gift card codes. However, if a different length '\n                        'is required, it can be set here.'.format(settings.ENTROPY['giftcard_secret'])),\n        )\n    },\n    'giftcard_expiry_years': {\n        'default': None,\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Validity of gift card codes in years'),\n            help_text=_('If you set a number here, gift cards will by default expire at the end of the year after this '\n                        'many years. If you keep it empty, gift cards do not have an explicit expiry date.'),\n        )\n    },\n    'cookie_consent': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Enable cookie consent management features\"),\n        ),\n        'type': bool,\n    },\n    'cookie_consent_dialog_text': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'By clicking \"Accept all cookies\", you agree to the storing of cookies and use of similar technologies on '\n            'your device.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Dialog text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '3', 'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_text_secondary': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'We use cookies and similar technologies to gather data that allows us to improve this website and our '\n            'offerings. If you do not agree, we will only use cookies if they are essential to providing the services '\n            'this website offers.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Secondary dialog text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '3', 'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_title': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Privacy settings')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Dialog title'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_button_yes': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Accept all cookies')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('\"Accept\" button description'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_button_no': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Required cookies only')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('\"Reject\" button description'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'seating_choice': {\n        'default': 'True',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can choose their own seats\"),\n            help_text=_(\"If disabled, you will need to manually assign seats in the backend. Note that this can mean \"\n                        \"people will not know their seat after their purchase and it might not be written on their \"\n                        \"ticket.\"),\n        ),\n        'type': bool,\n    },\n    'seating_minimal_distance': {\n        'default': '0',\n        'type': float\n    },\n    'seating_allow_blocked_seats_for_channel': {\n        'default': [],\n        'type': list\n    },\n    'seating_distance_within_row': {\n        'default': 'False',\n        'type': bool\n    },\n    'checkout_show_copy_answers_button': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show button to copy user input from other products\"),\n        ),\n    }\n}\nSETTINGS_AFFECTING_CSS = {\n    'primary_color', 'theme_color_success', 'theme_color_danger', 'primary_font',\n    'theme_color_background', 'theme_round_borders'\n}\nPERSON_NAME_TITLE_GROUPS = OrderedDict([\n    ('english_common', (_('Most common English titles'), (\n        'Mr',\n        'Ms',\n        'Mrs',\n        'Miss',\n        'Mx',\n        'Dr',\n        'Professor',\n        'Sir',\n    ))),\n    ('german_common', (_('Most common German titles'), (\n        'Dr.',\n        'Prof.',\n        'Prof. Dr.',\n    ))),\n    ('dr_prof_he', ('Dr., Prof., H.E.', (\n        'Dr.',\n        'Prof.',\n        'H.E.',\n    )))\n])\n\nPERSON_NAME_SALUTATIONS = [\n    (\"Ms\", pgettext_lazy(\"person_name_salutation\", \"Ms\")),\n    (\"Mr\", pgettext_lazy(\"person_name_salutation\", \"Mr\")),\n    (\"Mx\", pgettext_lazy(\"person_name_salutation\", \"Mx\")),\n]\n\n\ndef concatenation_for_salutation(d):\n    salutation = d.get(\"salutation\")\n    title = d.get(\"title\")\n    given_name = d.get(\"given_name\")\n    family_name = d.get(\"family_name\")\n    # degree (after name) is not used in salutation\n    # see https://www.schreibwerkstatt.co.at/2012/12/25/der-umgang-mit-akademischen-graden/\n\n    if salutation == \"Mx\":\n        salutation = None\n    elif salutation:\n        salutation = pgettext(\"person_name_salutation\", salutation)\n        given_name = None\n\n    return \" \".join(filter(None, (salutation, title, given_name, family_name)))\n\n\ndef get_name_parts_localized(name_parts, key):\n    value = name_parts.get(key, \"\")\n    if key == \"salutation\" and value:\n        return pgettext_lazy(\"person_name_salutation\", value)\n    return value\n\n\nPERSON_NAME_SCHEMES = OrderedDict([\n    ('given_family', {\n        'fields': (\n            # field_name, label, weight for widget width\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(str(p) for p in [d.get('given_name', ''), d.get('family_name', '')] if p),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'given_family',\n        },\n    }),\n    ('title_given_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_family',\n        },\n    }),\n    ('title_given_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_family',\n        },\n    }),\n    ('given_middle_family', {\n        'fields': (\n            ('given_name', _('First name'), 2),\n            ('middle_name', _('Middle name'), 1),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('given_name', ''), d.get('middle_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'middle_name': 'M',\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'given_middle_family',\n        },\n    }),\n    ('title_given_middle_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('First name'), 2),\n            ('middle_name', _('Middle name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name'), d.get('middle_name'), d.get('family_name')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'middle_name': 'M',\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_middle_family',\n        },\n    }),\n    ('family_given', {\n        'fields': (\n            ('family_name', _('Family name'), 1),\n            ('given_name', _('Given name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('family_name', ''), d.get('given_name', '')] if p\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'family_given',\n        },\n    }),\n    ('family_nospace_given', {\n        'fields': (\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ''.join(\n            str(p) for p in [d.get('family_name', ''), d.get('given_name', '')] if p\n        ),\n        'sample': {\n            'given_name': '\u6cfd\u4e1c',\n            'family_name': '\u6bdb',\n            '_scheme': 'family_nospace_given',\n        },\n    }),\n    ('family_comma_given', {\n        'fields': (\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: (\n            str(d.get('family_name', '')) +\n            str((', ' if d.get('family_name') and d.get('given_name') else '')) +\n            str(d.get('given_name', ''))\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'family_comma_given',\n        },\n    }),\n    ('full', {\n        'fields': (\n            ('full_name', _('Name'), 1),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'sample': {\n            'full_name': pgettext_lazy('person_name_sample', 'John Doe'),\n            '_scheme': 'full',\n        },\n    }),\n    ('calling_full', {\n        'fields': (\n            ('calling_name', _('Calling name'), 1),\n            ('full_name', _('Full name'), 2),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'concatenation_all_components': lambda d: str(d.get('full_name', '')) + \" (\\\"\" + d.get('calling_name', '') + \"\\\")\",\n        'sample': {\n            'full_name': pgettext_lazy('person_name_sample', 'John Doe'),\n            'calling_name': pgettext_lazy('person_name_sample', 'John'),\n            '_scheme': 'calling_full',\n        },\n    }),\n    ('full_transcription', {\n        'fields': (\n            ('full_name', _('Full name'), 1),\n            ('latin_transcription', _('Latin transcription'), 2),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'concatenation_all_components': lambda d: str(d.get('full_name', '')) + \" (\" + d.get('latin_transcription', '') + \")\",\n        'sample': {\n            'full_name': '\u5e84\u53f8',\n            'latin_transcription': 'Sh\u014dji',\n            '_scheme': 'full_transcription',\n        },\n    }),\n    ('salutation_given_family', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in (d.get(key, '') for key in [\"given_name\", \"family_name\"]) if p\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: ' '.join(\n            str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"given_name\", \"family_name\"]) if p\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'salutation_given_family',\n        },\n    }),\n    ('salutation_title_given_family', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in (d.get(key, '') for key in [\"title\", \"given_name\", \"family_name\"]) if p\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: ' '.join(\n            str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"title\", \"given_name\", \"family_name\"]) if p\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'salutation_title_given_family',\n        },\n    }),\n    ('salutation_title_given_family_degree', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n            ('degree', pgettext_lazy('person_name', 'Degree (after name)'), 2),\n        ),\n        'concatenation': lambda d: (\n            ' '.join(\n                str(p) for p in (d.get(key, '') for key in [\"title\", \"given_name\", \"family_name\"]) if p\n            ) +\n            str((', ' if d.get('degree') else '')) +\n            str(d.get('degree', ''))\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: (\n            ' '.join(\n                str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"title\", \"given_name\", \"family_name\"]) if p\n            ) +\n            str((', ' if d.get('degree') else '')) +\n            str(d.get('degree', ''))\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            'degree': pgettext_lazy('person_name_sample', 'MA'),\n            '_scheme': 'salutation_title_given_family_degree',\n        },\n    }),\n])\n\nDEFAULTS['name_scheme']['serializer_kwargs']['choices'] = ((k, k) for k in PERSON_NAME_SCHEMES)\n\nCOUNTRIES_WITH_STATE_IN_ADDRESS = {\n    # Source: http://www.bitboost.com/ref/international-address-formats.html\n    # This is not a list of countries that *have* states, this is a list of countries where states\n    # are actually *used* in postal addresses. This is obviously not complete and opinionated.\n    # Country: [(List of subdivision types as defined by pycountry), (short or long form to be used)]\n    'AU': (['State', 'Territory'], 'short'),\n    'BR': (['State'], 'short'),\n    'CA': (['Province', 'Territory'], 'short'),\n    # 'CN': (['Province', 'Autonomous region', 'Munincipality'], 'long'),\n    'MY': (['State'], 'long'),\n    'MX': (['State', 'Federal district'], 'short'),\n    'US': (['State', 'Outlying area', 'District'], 'short'),\n}\n\nsettings_hierarkey = Hierarkey(attribute_name='settings')\n\nfor k, v in DEFAULTS.items():\n    settings_hierarkey.add_default(k, v['default'], v['type'])\n\n\ndef i18n_uns(v):\n    try:\n        return LazyI18nString(json.loads(v))\n    except ValueError:\n        return LazyI18nString(str(v))\n\n\nsettings_hierarkey.add_type(LazyI18nString,\n                            serialize=lambda s: json.dumps(s.data),\n                            unserialize=i18n_uns)\nsettings_hierarkey.add_type(LazyI18nStringList,\n                            serialize=operator.methodcaller(\"serialize\"),\n                            unserialize=LazyI18nStringList.unserialize)\nsettings_hierarkey.add_type(RelativeDateWrapper,\n                            serialize=lambda rdw: rdw.to_string(),\n                            unserialize=lambda s: RelativeDateWrapper.from_string(s))\nsettings_hierarkey.add_type(PhoneNumber, lambda pn: pn.as_international, lambda s: parse(s) if s else None)\n\n\n@settings_hierarkey.set_global(cache_namespace='global')\nclass GlobalSettingsObject(GlobalSettingsBase):\n    slug = '_global'\n\n\nclass SettingsSandbox:\n    \"\"\"\n    Transparently proxied access to event settings, handling your prefixes for you.\n\n    :param typestr: The first part of the pretix, e.g. ``plugin``\n    :param key: The prefix, e.g. the name of your plugin\n    :param obj: The event or organizer that should be queried\n    \"\"\"\n\n    def __init__(self, typestr: str, key: str, obj: Model):\n        self._event = obj\n        self._type = typestr\n        self._key = key\n\n    def get_prefix(self):\n        return '%s_%s_' % (self._type, self._key)\n\n    def _convert_key(self, key: str) -> str:\n        return '%s_%s_%s' % (self._type, self._key, key)\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        self.set(key, value)\n\n    def __setattr__(self, key: str, value: Any) -> None:\n        if key.startswith('_'):\n            return super().__setattr__(key, value)\n        self.set(key, value)\n\n    def __getattr__(self, item: str) -> Any:\n        return self.get(item)\n\n    def __getitem__(self, item: str) -> Any:\n        return self.get(item)\n\n    def __delitem__(self, key: str) -> None:\n        del self._event.settings[self._convert_key(key)]\n\n    def __delattr__(self, key: str) -> None:\n        del self._event.settings[self._convert_key(key)]\n\n    def get(self, key: str, default: Any = None, as_type: type = str, binary_file: bool = False):\n        return self._event.settings.get(\n            self._convert_key(key), default=default, as_type=as_type, binary_file=binary_file\n        )\n\n    def set(self, key: str, value: Any):\n        self._event.settings.set(self._convert_key(key), value)\n\n\ndef validate_event_settings(event, settings_dict):\n    from pretix.base.models import Event\n    from pretix.base.signals import validate_event_settings\n\n    if 'locales' in settings_dict and settings_dict['locale'] not in settings_dict['locales']:\n        raise ValidationError({\n            'locale': _('Your default locale must also be enabled for your event (see box above).')\n        })\n    if settings_dict.get('attendee_names_required') and not settings_dict.get('attendee_names_asked'):\n        raise ValidationError({\n            'attendee_names_required': _('You cannot require specifying attendee names if you do not ask for them.')\n        })\n    if settings_dict.get('attendee_emails_required') and not settings_dict.get('attendee_emails_asked'):\n        raise ValidationError({\n            'attendee_emails_required': _('You have to ask for attendee emails if you want to make them required.')\n        })\n    if settings_dict.get('invoice_address_required') and not settings_dict.get('invoice_address_asked'):\n        raise ValidationError({\n            'invoice_address_required': _('You have to ask for invoice addresses if you want to make them required.')\n        })\n    if settings_dict.get('invoice_address_company_required') and not settings_dict.get('invoice_address_required'):\n        raise ValidationError({\n            'invoice_address_company_required': _('You have to require invoice addresses to require for company names.')\n        })\n\n    payment_term_last = settings_dict.get('payment_term_last')\n    if payment_term_last and event.presale_end:\n        if payment_term_last.date(event) < event.presale_end.date():\n            raise ValidationError({\n                'payment_term_last': _('The last payment date cannot be before the end of presale.')\n            })\n\n    if isinstance(event, Event):\n        validate_event_settings.send(sender=event, settings_dict=settings_dict)\n\n\ndef validate_organizer_settings(organizer, settings_dict):\n    # This is not doing anything for the time being.\n    # But earlier we called validate_event_settings for the organizer, too - and that didn't do anything for\n    # organizer-settings either.\n    if settings_dict.get('reusable_media_type_nfc_mf0aes') and settings_dict.get('reusable_media_type_nfc_uid'):\n        raise ValidationError({\n            'reusable_media_type_nfc_uid': _('This needs to be disabled if other NFC-based types are active.')\n        })\n\n\ndef global_settings_object(holder):\n    if not hasattr(holder, '_global_settings_object'):\n        holder._global_settings_object = GlobalSettingsObject()\n    return holder._global_settings_object\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexander Schwartz\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport datetime\nimport os\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import File\nfrom django.core.files.uploadedfile import UploadedFile\nfrom django.forms.utils import from_current_timezone\nfrom django.urls import reverse\nfrom django.utils.html import escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import now\nfrom django.utils.translation import gettext_lazy as _\nfrom django_scopes.forms import SafeModelMultipleChoiceField\n\nfrom pretix.helpers.hierarkey import clean_filename\n\nfrom ...base.forms import I18nModelForm\nfrom ...helpers.images import (\n    IMAGE_EXTS, validate_uploaded_file_for_valid_image,\n)\n\n# Import for backwards compatibility with okd import paths\nfrom ...base.forms.widgets import (  # noqa\n    DatePickerWidget, SplitDateTimePickerWidget, TimePickerWidget,\n)\n\n\nclass TolerantFormsetModelForm(I18nModelForm):\n    \"\"\"\n    This is equivalent to a normal I18nModelForm, but works around a problem that\n    arises when the form is used inside a FormSet with can_order=True and django-formset-js\n    enabled. In this configuration, even empty \"extra\" forms might have an ORDER value\n    sent and Django marks the form as empty and raises validation errors because the other\n    fields have not been filled.\n    \"\"\"\n\n    def has_changed(self) -> bool:\n        \"\"\"\n        Returns True if data differs from initial. Contrary to the default\n        implementation, the ORDER field is being ignored.\n        \"\"\"\n        for name, field in self.fields.items():\n            if name == 'ORDER' or name == 'id':\n                continue\n            prefixed_name = self.add_prefix(name)\n            data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                initial_value = self.initial.get(name, field.initial)\n                if callable(initial_value):\n                    initial_value = initial_value()\n            else:\n                initial_prefixed_name = self.add_initial_prefix(name)\n                hidden_widget = field.hidden_widget()\n                try:\n                    initial_value = field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except forms.ValidationError:\n                    # Always assume data has changed if validation fails.\n                    self._changed_data.append(name)\n                    continue\n            # We're using a private API of Django here. This is not nice, but no problem as it seems\n            # like this will become a public API in future Django.\n            if field._has_changed(initial_value, data_value):\n                return True\n        return False\n\n\ndef selector(values, prop):\n    # Given an iterable of PropertyValue objects, this will return a\n    # list of their primary keys, ordered by the primary keys of the\n    # properties they belong to EXCEPT the value for the property prop2.\n    # We'll see later why we need this.\n    return [\n        v.id for v in sorted(values, key=lambda v: v.prop.id)\n        if v.prop.id != prop.id\n    ]\n\n\nclass ClearableBasenameFileInput(forms.ClearableFileInput):\n    template_name = 'pretixbase/forms/widgets/thumbnailed_file_input.html'\n\n    class FakeFile(File):\n        def __init__(self, file):\n            self.file = file\n\n        @property\n        def name(self):\n            if hasattr(self.file, 'display_name'):\n                return self.file.display_name\n            return self.file.name\n\n        @property\n        def is_img(self):\n            return any(self.file.name.lower().endswith(e) for e in ('.jpg', '.jpeg', '.png', '.gif'))\n\n        def __str__(self):\n            if hasattr(self.file, 'display_name'):\n                return self.file.display_name\n            return clean_filename(os.path.basename(self.file.name))\n\n        @property\n        def url(self):\n            return self.file.url\n\n    def get_context(self, name, value, attrs):\n        ctx = super().get_context(name, value, attrs)\n        ctx['widget']['value'] = self.FakeFile(value)\n        ctx['widget']['cachedfile'] = None\n        return ctx\n\n\nclass CachedFileInput(forms.ClearableFileInput):\n    template_name = 'pretixbase/forms/widgets/thumbnailed_file_input.html'\n\n    class FakeFile(File):\n        def __init__(self, file):\n            self.file = file\n\n        @property\n        def name(self):\n            return self.file.filename\n\n        @property\n        def is_img(self):\n            return False  # thumbnailing doesn't work since the file isn't available publicly\n\n        def __str__(self):\n            return self.file.filename\n\n        @property\n        def url(self):\n            return reverse('cachedfile.download', kwargs={'id': self.file.id})\n\n    def value_from_datadict(self, data, files, name):\n        from ...base.models import CachedFile\n        v = super().value_from_datadict(data, files, name)\n        if v is None and data.get(name + '-cachedfile'):  # An explicit \"[x] clear\" would be False, not None\n            return CachedFile.objects.filter(id=data[name + '-cachedfile']).first()\n        return v\n\n    def get_context(self, name, value, attrs):\n        from ...base.models import CachedFile\n        if isinstance(value, CachedFile):\n            value = self.FakeFile(value)\n\n        ctx = super().get_context(name, value, attrs)\n        ctx['widget']['value'] = value\n        ctx['widget']['cachedfile'] = value.file if isinstance(value, self.FakeFile) else None\n        ctx['widget']['hidden_name'] = name + '-cachedfile'\n        return ctx\n\n\nclass SizeValidationMixin:\n    def __init__(self, *args, **kwargs):\n        self.max_size = kwargs.pop(\"max_size\", None)\n        super().__init__(*args, **kwargs)\n\n    @staticmethod\n    def _sizeof_fmt(num, suffix='B'):\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 1024.0:\n                return \"%3.1f%s%s\" % (num, unit, suffix)\n            num /= 1024.0\n        return \"%.1f%s%s\" % (num, 'Yi', suffix)\n\n    def clean(self, *args, **kwargs):\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, UploadedFile) and self.max_size and data.size > self.max_size:\n            raise forms.ValidationError(_(\"Please do not upload files larger than {size}!\").format(\n                size=SizeValidationMixin._sizeof_fmt(self.max_size)\n            ))\n        return data\n\n\nclass ExtValidationMixin:\n\n    def __init__(self, *args, **kwargs):\n        ext_whitelist = kwargs.pop(\"ext_whitelist\")\n        self.ext_whitelist = [i.lower() for i in ext_whitelist]\n        super().__init__(*args, **kwargs)\n\n    def clean(self, *args, **kwargs):\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, UploadedFile):\n            filename = data.name\n            ext = os.path.splitext(filename)[1]\n            ext = ext.lower()\n            if ext not in self.ext_whitelist:\n                raise forms.ValidationError(_(\"Filetype not allowed!\"))\n\n            if ext in IMAGE_EXTS:\n                validate_uploaded_file_for_valid_image(data)\n\n        return data\n\n\nclass SizeFileField(SizeValidationMixin, forms.FileField):\n    pass\n\n\nclass ExtFileField(ExtValidationMixin, SizeFileField):\n    widget = ClearableBasenameFileInput\n\n\nclass CachedFileField(ExtFileField):\n    widget = CachedFileInput\n\n    def to_python(self, data):\n        from ...base.models import CachedFile\n\n        if isinstance(data, CachedFile):\n            return data\n\n        return super().to_python(data)\n\n    def bound_data(self, data, initial):\n        from ...base.models import CachedFile\n\n        if isinstance(data, File):\n            if hasattr(data, '_uploaded_to'):\n                return data._uploaded_to\n            cf = CachedFile.objects.create(\n                expires=now() + datetime.timedelta(days=1),\n                date=now(),\n                web_download=True,\n                filename=data.name,\n                type=data.content_type,\n            )\n            cf.file.save(data.name, data.file)\n            cf.save()\n            data._uploaded_to = cf\n            return cf\n        return super().bound_data(data, initial)\n\n    def clean(self, *args, **kwargs):\n        from ...base.models import CachedFile\n\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, File):\n            if hasattr(data, '_uploaded_to'):\n                return data._uploaded_to\n            cf = CachedFile.objects.create(\n                expires=now() + datetime.timedelta(days=1),\n                web_download=True,\n                date=now(),\n                filename=data.name,\n                type=data.content_type,\n            )\n            cf.file.save(data.name, data.file)\n            cf.save()\n            data._uploaded_to = cf\n            return cf\n        return data\n\n\nclass SlugWidget(forms.TextInput):\n    template_name = 'pretixcontrol/slug_widget.html'\n    prefix = ''\n\n    def get_context(self, name, value, attrs):\n        ctx = super().get_context(name, value, attrs)\n        ctx['pre'] = self.prefix\n        return ctx\n\n\nclass MultipleLanguagesWidget(forms.CheckboxSelectMultiple):\n    option_template_name = 'pretixcontrol/multi_languages_widget.html'\n\n    def sort(self):\n        self.choices = sorted(self.choices, key=lambda l: (\n            (\n                0 if l[0] in settings.LANGUAGES_OFFICIAL\n                else (\n                    1 if l[0] not in settings.LANGUAGES_INCUBATING\n                    else 2\n                )\n            ), str(l[1])\n        ))\n\n    def options(self, name, value, attrs=None):\n        self.sort()\n        return super().options(name, value, attrs)\n\n    def optgroups(self, name, value, attrs=None):\n        self.sort()\n        return super().optgroups(name, value, attrs)\n\n    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):\n        opt = super().create_option(name, value, label, selected, index, subindex, attrs)\n        opt['official'] = value in settings.LANGUAGES_OFFICIAL\n        opt['incubating'] = value in settings.LANGUAGES_INCUBATING\n        return opt\n\n\nclass SingleLanguageWidget(forms.Select):\n\n    def modify(self):\n        if hasattr(self, '_modified'):\n            return self.choices\n        self.choices = sorted(self.choices, key=lambda l: (\n            (\n                0 if l[0] in settings.LANGUAGES_OFFICIAL\n                else (\n                    1 if l[0] not in settings.LANGUAGES_INCUBATING\n                    else 2\n                )\n            ), str(l[1])\n        ))\n        new_choices = []\n        for k, v in self.choices:\n            new_choices.append((\n                k,\n                v if k in settings.LANGUAGES_OFFICIAL\n                else (\n                    '{} (inofficial translation)'.format(v) if k not in settings.LANGUAGES_INCUBATING\n                    else '{} (translation in progress)'.format(v)\n                )\n            ))\n        self._modified = True\n        self.choices = new_choices\n\n    def options(self, name, value, attrs=None):\n        self.modify()\n        return super().options(name, value, attrs)\n\n    def optgroups(self, name, value, attrs=None):\n        self.modify()\n        return super().optgroups(name, value, attrs)\n\n\nclass SplitDateTimeField(forms.SplitDateTimeField):\n\n    def compress(self, data_list):\n        # Differs from the default implementation: If only a time is given and no date, we consider the field empty\n        if data_list:\n            if data_list[0] in self.empty_values:\n                return None\n            if data_list[1] in self.empty_values:\n                raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')\n            result = datetime.datetime.combine(*data_list)\n            return from_current_timezone(result)\n        return None\n\n\nclass FontSelect(forms.RadioSelect):\n    option_template_name = 'pretixcontrol/font_option.html'\n\n\nclass ItemMultipleChoiceField(SafeModelMultipleChoiceField):\n    def label_from_instance(self, obj):\n        return str(obj) if obj.active else mark_safe(f'<strike class=\"text-muted\">{escape(obj)}</strike>')\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Bolutife Lawrence, Maico Timmerman\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nfrom decimal import Decimal\nfrom urllib.parse import urlparse\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.forms import inlineformset_factory\nfrom django.forms.utils import ErrorDict\nfrom django.urls import reverse\nfrom django.utils.crypto import get_random_string\nfrom django.utils.html import conditional_escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_scopes.forms import (\n    SafeModelChoiceField, SafeModelMultipleChoiceField,\n)\nfrom i18nfield.forms import (\n    I18nFormField, I18nFormSetMixin, I18nTextarea, I18nTextInput,\n)\nfrom phonenumber_field.formfields import PhoneNumberField\nfrom pytz import common_timezones\n\nfrom pretix.api.models import WebHook\nfrom pretix.api.webhooks import get_all_webhook_events\nfrom pretix.base.customersso.oidc import oidc_validate_and_complete_config\nfrom pretix.base.forms import I18nModelForm, PlaceholderValidator, SettingsForm\nfrom pretix.base.forms.questions import (\n    NamePartsFormField, WrappedPhoneNumberPrefixWidget, get_country_by_locale,\n    get_phone_prefix,\n)\nfrom pretix.base.forms.widgets import SplitDateTimePickerWidget\nfrom pretix.base.models import (\n    Customer, Device, EventMetaProperty, Gate, GiftCard, GiftCardAcceptance,\n    Membership, MembershipType, OrderPosition, Organizer, ReusableMedium, Team,\n)\nfrom pretix.base.models.customers import CustomerSSOClient, CustomerSSOProvider\nfrom pretix.base.models.organizer import OrganizerFooterLink\nfrom pretix.base.settings import (\n    PERSON_NAME_SCHEMES, PERSON_NAME_TITLE_GROUPS, validate_organizer_settings,\n)\nfrom pretix.control.forms import ExtFileField, SplitDateTimeField\nfrom pretix.control.forms.event import (\n    SafeEventMultipleChoiceField, multimail_validate,\n)\nfrom pretix.control.forms.widgets import Select2\nfrom pretix.multidomain.models import KnownDomain\nfrom pretix.multidomain.urlreverse import build_absolute_uri\n\n\nclass OrganizerForm(I18nModelForm):\n    error_messages = {\n        'duplicate_slug': _(\"This slug is already in use. Please choose a different one.\"),\n    }\n\n    class Meta:\n        model = Organizer\n        fields = ['name', 'slug']\n\n    def clean_slug(self):\n        slug = self.cleaned_data['slug']\n        if Organizer.objects.filter(slug__iexact=slug).exists():\n            raise forms.ValidationError(\n                self.error_messages['duplicate_slug'],\n                code='duplicate_slug',\n            )\n        return slug\n\n\nclass OrganizerDeleteForm(forms.Form):\n    error_messages = {\n        'slug_wrong': _(\"The slug you entered was not correct.\"),\n    }\n    slug = forms.CharField(\n        max_length=255,\n        label=_(\"Event slug\"),\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    def clean_slug(self):\n        slug = self.cleaned_data.get('slug')\n        if slug != self.organizer.slug:\n            raise forms.ValidationError(\n                self.error_messages['slug_wrong'],\n                code='slug_wrong',\n            )\n        return slug\n\n\nclass OrganizerUpdateForm(OrganizerForm):\n\n    def __init__(self, *args, **kwargs):\n        self.domain = kwargs.pop('domain', False)\n        self.change_slug = kwargs.pop('change_slug', False)\n        kwargs.setdefault('initial', {})\n        self.instance = kwargs['instance']\n        if self.domain and self.instance:\n            initial_domain = self.instance.domains.filter(event__isnull=True).first()\n            if initial_domain:\n                kwargs['initial'].setdefault('domain', initial_domain.domainname)\n\n        super().__init__(*args, **kwargs)\n        if not self.change_slug:\n            self.fields['slug'].widget.attrs['readonly'] = 'readonly'\n        if self.domain:\n            self.fields['domain'] = forms.CharField(\n                max_length=255,\n                label=_('Custom domain'),\n                required=False,\n                help_text=_('You need to configure the custom domain in the webserver beforehand.')\n            )\n\n    def clean_domain(self):\n        d = self.cleaned_data['domain']\n        if d:\n            if d == urlparse(settings.SITE_URL).hostname:\n                raise ValidationError(\n                    _('You cannot choose the base domain of this installation.')\n                )\n            if KnownDomain.objects.filter(domainname=d).exclude(organizer=self.instance.pk,\n                                                                event__isnull=True).exists():\n                raise ValidationError(\n                    _('This domain is already in use for a different event or organizer.')\n                )\n        return d\n\n    def clean_slug(self):\n        if self.change_slug:\n            return self.cleaned_data['slug']\n        return self.instance.slug\n\n    def save(self, commit=True):\n        instance = super().save(commit)\n\n        if self.domain:\n            current_domain = instance.domains.filter(event__isnull=True).first()\n            if self.cleaned_data['domain']:\n                if current_domain and current_domain.domainname != self.cleaned_data['domain']:\n                    current_domain.delete()\n                    KnownDomain.objects.create(organizer=instance, domainname=self.cleaned_data['domain'])\n                elif not current_domain:\n                    KnownDomain.objects.create(organizer=instance, domainname=self.cleaned_data['domain'])\n            elif current_domain:\n                current_domain.delete()\n            instance.cache.clear()\n            for ev in instance.events.all():\n                ev.cache.clear()\n\n        return instance\n\n\nclass SafeOrderPositionChoiceField(forms.ModelChoiceField):\n    def __init__(self, queryset, **kwargs):\n        queryset = queryset.model.all.none()\n        super().__init__(queryset, **kwargs)\n\n    def label_from_instance(self, op):\n        return f'{op.order.code}-{op.positionid} ({str(op.item) + ((\" - \" + str(op.variation)) if op.variation else \"\")})'\n\n\nclass EventMetaPropertyForm(forms.ModelForm):\n    class Meta:\n        model = EventMetaProperty\n        fields = ['name', 'default', 'required', 'protected', 'allowed_values', 'filter_allowed']\n        widgets = {\n            'default': forms.TextInput()\n        }\n\n\nclass MembershipTypeForm(I18nModelForm):\n    class Meta:\n        model = MembershipType\n        fields = ['name', 'transferable', 'allow_parallel_usage', 'max_usages']\n\n\nclass TeamForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n\n    class Meta:\n        model = Team\n        fields = ['name', 'all_events', 'limit_events', 'can_create_events',\n                  'can_change_teams', 'can_change_organizer_settings',\n                  'can_manage_gift_cards', 'can_manage_customers',\n                  'can_manage_reusable_media',\n                  'can_change_event_settings', 'can_change_items',\n                  'can_view_orders', 'can_change_orders', 'can_checkin_orders',\n                  'can_view_vouchers', 'can_change_vouchers']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n    def clean(self):\n        data = super().clean()\n        if self.instance.pk and not data['can_change_teams']:\n            if not self.instance.organizer.teams.exclude(pk=self.instance.pk).filter(\n                    can_change_teams=True, members__isnull=False\n            ).exists():\n                raise ValidationError(_('The changes could not be saved because there would be no remaining team with '\n                                        'the permission to change teams and permissions.'))\n\n        return data\n\n\nclass GateForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    class Meta:\n        model = Gate\n        fields = ['name', 'identifier']\n\n\nclass DeviceForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n        self.fields['gate'].queryset = organizer.gates.all()\n\n    def clean(self):\n        d = super().clean()\n        if not d['all_events'] and not d.get('limit_events'):\n            raise ValidationError(_('Your device will not have access to anything, please select some events.'))\n\n        return d\n\n    class Meta:\n        model = Device\n        fields = ['name', 'all_events', 'limit_events', 'security_profile', 'gate']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n\nclass DeviceBulkEditForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        self.mixed_values = kwargs.pop('mixed_values')\n        self.queryset = kwargs.pop('queryset')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n        self.fields['gate'].queryset = organizer.gates.all()\n\n    def clean(self):\n        d = super().clean()\n        if self.prefix + '__events' in self.data.getlist('_bulk') and not d['all_events'] and not d['limit_events']:\n            raise ValidationError(_('Your device will not have access to anything, please select some events.'))\n\n        return d\n\n    class Meta:\n        model = Device\n        fields = ['all_events', 'limit_events', 'security_profile', 'gate']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n    def save(self, commit=True):\n        objs = list(self.queryset)\n        fields = set()\n\n        check_map = {\n            'all_events': '__events',\n            'limit_events': '__events',\n        }\n        for k in self.fields:\n            cb_val = self.prefix + check_map.get(k, k)\n            if cb_val not in self.data.getlist('_bulk'):\n                continue\n\n            fields.add(k)\n            for obj in objs:\n                if k == 'limit_events':\n                    getattr(obj, k).set(self.cleaned_data[k])\n                else:\n                    setattr(obj, k, self.cleaned_data[k])\n\n        if fields:\n            Device.objects.bulk_update(objs, [f for f in fields if f != 'limit_events'], 200)\n\n    def full_clean(self):\n        if len(self.data) == 0:\n            # form wasn't submitted\n            self._errors = ErrorDict()\n            return\n        super().full_clean()\n\n\nclass OrganizerSettingsForm(SettingsForm):\n    timezone = forms.ChoiceField(\n        choices=((a, a) for a in common_timezones),\n        label=_(\"Default timezone\"),\n    )\n    name_scheme = forms.ChoiceField(\n        label=_(\"Name format\"),\n        help_text=_(\"This defines how pretix will ask for human names. Changing this after you already received \"\n                    \"orders might lead to unexpected behavior when sorting or changing names.\"),\n        required=True,\n    )\n    name_scheme_titles = forms.ChoiceField(\n        label=_(\"Allowed titles\"),\n        help_text=_(\"If the naming scheme you defined above allows users to input a title, you can use this to \"\n                    \"restrict the set of selectable titles.\"),\n        required=False,\n    )\n    auto_fields = [\n        'allowed_restricted_plugins',\n        'customer_accounts',\n        'customer_accounts_native',\n        'customer_accounts_link_by_email',\n        'invoice_regenerate_allowed',\n        'contact_mail',\n        'imprint_url',\n        'organizer_info_text',\n        'event_list_type',\n        'event_list_availability',\n        'organizer_homepage_text',\n        'organizer_link_back',\n        'organizer_logo_image_large',\n        'organizer_logo_image_inherit',\n        'giftcard_length',\n        'giftcard_expiry_years',\n        'locales',\n        'region',\n        'meta_noindex',\n        'event_team_provisioning',\n        'primary_color',\n        'theme_color_success',\n        'theme_color_danger',\n        'theme_color_background',\n        'theme_round_borders',\n        'primary_font',\n        'privacy_url',\n        'cookie_consent',\n        'cookie_consent_dialog_title',\n        'cookie_consent_dialog_text',\n        'cookie_consent_dialog_text_secondary',\n        'cookie_consent_dialog_button_yes',\n        'cookie_consent_dialog_button_no',\n        'reusable_media_active',\n        'reusable_media_type_barcode',\n        'reusable_media_type_barcode_identifier_length',\n        'reusable_media_type_nfc_uid',\n        'reusable_media_type_nfc_uid_autocreate_giftcard',\n        'reusable_media_type_nfc_uid_autocreate_giftcard_currency',\n        'reusable_media_type_nfc_mf0aes',\n        'reusable_media_type_nfc_mf0aes_autocreate_giftcard',\n        'reusable_media_type_nfc_mf0aes_autocreate_giftcard_currency',\n        'reusable_media_type_nfc_mf0aes_random_uid',\n    ]\n\n    organizer_logo_image = ExtFileField(\n        label=_('Header image'),\n        ext_whitelist=(\".png\", \".jpg\", \".gif\", \".jpeg\"),\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        required=False,\n        help_text=_('If you provide a logo image, we will by default not show your organization name '\n                    'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                    'can increase the size with the setting below. We recommend not using small details on the picture '\n                    'as it will be resized on smaller screens.')\n    )\n    favicon = ExtFileField(\n        label=_('Favicon'),\n        ext_whitelist=(\".ico\", \".png\", \".jpg\", \".gif\", \".jpeg\"),\n        required=False,\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_FAVICON,\n        help_text=_('If you provide a favicon, we will show it instead of the default pretix icon. '\n                    'We recommend a size of at least 200x200px to accommodate most devices.')\n    )\n\n    def __init__(self, *args, **kwargs):\n        is_admin = kwargs.pop('is_admin', False)\n        super().__init__(*args, **kwargs)\n\n        if not is_admin:\n            del self.fields['allowed_restricted_plugins']\n\n        self.fields['name_scheme'].choices = (\n            (k, _('Ask for {fields}, display like {example}').format(\n                fields=' + '.join(str(vv[1]) for vv in v['fields']),\n                example=v['concatenation'](v['sample'])\n            ))\n            for k, v in PERSON_NAME_SCHEMES.items()\n        )\n        self.fields['name_scheme_titles'].choices = [('', _('Free text input'))] + [\n            (k, '{scheme}: {samples}'.format(\n                scheme=v[0],\n                samples=', '.join(v[1])\n            ))\n            for k, v in PERSON_NAME_TITLE_GROUPS.items()\n        ]\n        self.fields['reusable_media_active'].label = mark_safe(\n            conditional_escape(self.fields['reusable_media_active'].label) +\n            ' ' +\n            '<span class=\"label label-info\">{}</span>'.format(_('experimental'))\n        )\n        self.fields['reusable_media_active'].help_text = mark_safe(\n            conditional_escape(self.fields['reusable_media_active'].help_text) +\n            ' ' +\n            '<br/><span class=\"fa fa-flask\"></span> ' +\n            _('This feature is currently in an experimental stage. It only supports very limited use cases and might '\n              'change at any point.')\n        )\n\n    def clean(self):\n        data = super().clean()\n        settings_dict = self.obj.settings.freeze()\n        settings_dict.update(data)\n\n        validate_organizer_settings(self.obj, data)\n        return data\n\n\nclass MailSettingsForm(SettingsForm):\n    auto_fields = [\n        'mail_from_name',\n    ]\n\n    mail_bcc = forms.CharField(\n        label=_(\"Bcc address\"),\n        help_text=_(\"All emails will be sent to this address as a Bcc copy\"),\n        validators=[multimail_validate],\n        required=False,\n        max_length=255\n    )\n    mail_text_signature = I18nFormField(\n        label=_(\"Signature\"),\n        required=False,\n        widget=I18nTextarea,\n        help_text=_(\"This will be attached to every email.\"),\n        validators=[PlaceholderValidator([])],\n        widget_kwargs={'attrs': {\n            'rows': '4',\n            'placeholder': _(\n                'e.g. your contact details'\n            )\n        }}\n    )\n\n    mail_subject_customer_registration = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_registration = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n    mail_subject_customer_email_change = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_email_change = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n    mail_subject_customer_reset = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_reset = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n\n    base_context = {\n        'mail_text_customer_registration': ['customer', 'url'],\n        'mail_subject_customer_registration': ['customer', 'url'],\n        'mail_text_customer_email_change': ['customer', 'url'],\n        'mail_subject_customer_email_change': ['customer', 'url'],\n        'mail_text_customer_reset': ['customer', 'url'],\n        'mail_subject_customer_reset': ['customer', 'url'],\n    }\n\n    def _get_sample_context(self, base_parameters):\n        placeholders = {\n            'organizer': self.organizer.name\n        }\n\n        if 'url' in base_parameters:\n            placeholders['url'] = build_absolute_uri(\n                self.organizer,\n                'presale:organizer.customer.activate'\n            ) + '?token=' + get_random_string(30)\n\n        if 'customer' in base_parameters:\n            placeholders['name'] = pgettext_lazy('person_name_sample', 'John Doe')\n            name_scheme = PERSON_NAME_SCHEMES[self.organizer.settings.name_scheme]\n            for f, l, w in name_scheme['fields']:\n                if f == 'full_name':\n                    continue\n                placeholders['name_%s' % f] = name_scheme['sample'][f]\n            placeholders['name_for_salutation'] = _(\"Mr Doe\")\n        return placeholders\n\n    def _set_field_placeholders(self, fn, base_parameters):\n        phs = [\n            '{%s}' % p\n            for p in sorted(self._get_sample_context(base_parameters).keys())\n        ]\n        ht = _('Available placeholders: {list}').format(\n            list=', '.join(phs)\n        )\n        if self.fields[fn].help_text:\n            self.fields[fn].help_text += ' ' + str(ht)\n        else:\n            self.fields[fn].help_text = ht\n        self.fields[fn].validators.append(\n            PlaceholderValidator(phs)\n        )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.get('obj')\n        super().__init__(*args, **kwargs)\n        for k, v in self.base_context.items():\n            self._set_field_placeholders(k, v)\n\n\nclass WebHookForm(forms.ModelForm):\n    events = forms.MultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple,\n        label=pgettext_lazy('webhooks', 'Event types')\n    )\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all()\n        self.fields['events'].choices = [\n            (\n                a.action_type,\n                mark_safe('{} \u2013 <code>{}</code>'.format(a.verbose_name, a.action_type))\n            ) for a in get_all_webhook_events().values()\n        ]\n        if self.instance and self.instance.pk:\n            self.fields['events'].initial = list(self.instance.listeners.values_list('action_type', flat=True))\n\n    class Meta:\n        model = WebHook\n        fields = ['target_url', 'enabled', 'all_events', 'limit_events', 'comment']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events'\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeModelMultipleChoiceField\n        }\n\n\nclass GiftCardCreateForm(forms.ModelForm):\n    value = forms.DecimalField(\n        label=_('Gift card value'),\n        min_value=Decimal('0.00'),\n        max_value=Decimal('99999999.99'),\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        initial = kwargs.pop('initial', {})\n        initial['expires'] = self.organizer.default_gift_card_expiry\n        kwargs['initial'] = initial\n        super().__init__(*args, **kwargs)\n\n    def clean_secret(self):\n        s = self.cleaned_data['secret']\n        if GiftCard.objects.filter(\n                secret__iexact=s\n        ).filter(\n            Q(issuer=self.organizer) |\n            Q(issuer__in=GiftCardAcceptance.objects.filter(\n                acceptor=self.organizer,\n                active=True,\n            ).values_list('issuer', flat=True))\n        ).exists():\n            raise ValidationError(\n                _('A gift card with the same secret already exists in your or an affiliated organizer account.')\n            )\n        return s\n\n    class Meta:\n        model = GiftCard\n        fields = ['secret', 'currency', 'testmode', 'expires', 'conditions']\n        field_classes = {\n            'expires': SplitDateTimeField\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n            'conditions': forms.Textarea(attrs={\"rows\": 2})\n        }\n\n\nclass GiftCardUpdateForm(forms.ModelForm):\n    class Meta:\n        model = GiftCard\n        fields = ['expires', 'conditions', 'owner_ticket']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'owner_ticket': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n            'conditions': forms.Textarea(attrs={\"rows\": 2})\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        organizer = self.instance.issuer\n\n        self.fields['owner_ticket'].queryset = OrderPosition.all.filter(order__event__organizer=organizer).all()\n        self.fields['owner_ticket'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.ticket_select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Ticket')\n            }\n        )\n        self.fields['owner_ticket'].widget.choices = self.fields['owner_ticket'].choices\n        self.fields['owner_ticket'].required = False\n\n\nclass ReusableMediumUpdateForm(forms.ModelForm):\n    error_messages = {\n        'duplicate': _(\"An medium with this type and identifier is already registered.\"),\n    }\n\n    class Meta:\n        model = ReusableMedium\n        fields = ['active', 'expires', 'customer', 'linked_giftcard', 'linked_orderposition', 'notes']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'customer': SafeModelChoiceField,\n            'linked_giftcard': SafeModelChoiceField,\n            'linked_orderposition': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        organizer = self.instance.organizer\n\n        self.fields['linked_orderposition'].queryset = OrderPosition.all.filter(order__event__organizer=organizer).all()\n        self.fields['linked_orderposition'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.ticket_select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Ticket')\n            }\n        )\n        self.fields['linked_orderposition'].widget.choices = self.fields['linked_orderposition'].choices\n        self.fields['linked_orderposition'].required = False\n\n        self.fields['linked_giftcard'].queryset = organizer.issued_gift_cards.all()\n        self.fields['linked_giftcard'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.giftcards.select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Gift card')\n            }\n        )\n        self.fields['linked_giftcard'].widget.choices = self.fields['linked_giftcard'].choices\n        self.fields['linked_giftcard'].required = False\n\n        if organizer.settings.customer_accounts:\n            self.fields['customer'].queryset = organizer.customers.all()\n            self.fields['customer'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'generic',\n                    'data-select2-url': reverse('control:organizer.customers.select2', kwargs={\n                        'organizer': organizer.slug,\n                    }),\n                    'data-placeholder': _('Customer')\n                }\n            )\n            self.fields['customer'].widget.choices = self.fields['customer'].choices\n            self.fields['customer'].required = False\n        else:\n            del self.fields['customer']\n\n    def clean(self):\n        identifier = self.cleaned_data.get('identifier')\n        type = self.cleaned_data.get('type')\n\n        if identifier is not None and type is not None:\n            try:\n                self.instance.organizer.reusable_media.exclude(pk=self.instance.pk).get(\n                    identifier=identifier,\n                    type=type,\n                )\n            except ReusableMedium.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate'],\n                    code='duplicate',\n                )\n\n        return self.cleaned_data\n\n\nclass ReusableMediumCreateForm(ReusableMediumUpdateForm):\n\n    class Meta:\n        model = ReusableMedium\n        fields = ['active', 'type', 'identifier', 'expires', 'linked_orderposition', 'linked_giftcard', 'customer', 'notes']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'customer': SafeModelChoiceField,\n            'linked_giftcard': SafeModelChoiceField,\n            'linked_orderposition': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n        }\n\n\nclass CustomerUpdateForm(forms.ModelForm):\n    error_messages = {\n        'duplicate_identifier': _(\"An account with this customer ID is already registered.\"),\n        'duplicate': _(\"An account with this email address is already registered.\"),\n    }\n\n    class Meta:\n        model = Customer\n        fields = ['is_active', 'external_identifier', 'name_parts', 'email', 'is_verified', 'phone', 'locale', 'notes']\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.instance.phone and (self.instance.organizer.settings.region or self.instance.locale):\n            country_code = self.instance.organizer.settings.region or get_country_by_locale(self.instance.locale)\n            phone_prefix = get_phone_prefix(country_code)\n            if phone_prefix:\n                self.initial['phone'] = \"+{}.\".format(phone_prefix)\n\n        self.fields['phone'] = PhoneNumberField(\n            label=_('Phone'),\n            required=False,\n            widget=WrappedPhoneNumberPrefixWidget()\n        )\n        self.fields['name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=False,\n            scheme=self.instance.organizer.settings.name_scheme,\n            titles=self.instance.organizer.settings.name_scheme_titles,\n            label=_('Name'),\n        )\n        if self.instance.provider_id:\n            self.fields['email'].disabled = True\n            self.fields['is_verified'].disabled = True\n            self.fields['external_identifier'].disabled = True\n\n    def clean(self):\n        email = self.cleaned_data.get('email')\n        identifier = self.cleaned_data.get('identifier')\n\n        if email is not None:\n            try:\n                self.instance.organizer.customers.exclude(pk=self.instance.pk).get(email=email)\n            except Customer.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate'],\n                    code='duplicate',\n                )\n\n        if identifier is not None:\n            try:\n                self.instance.organizer.customers.exclude(pk=self.instance.pk).get(identifier=identifier)\n            except Customer.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate_identifier'],\n                    code='duplicate_identifier',\n                )\n\n        return self.cleaned_data\n\n\nclass CustomerCreateForm(CustomerUpdateForm):\n\n    class Meta:\n        model = Customer\n        fields = ['is_active', 'identifier', 'external_identifier', 'name_parts', 'email', 'is_verified', 'phone', 'locale', 'notes']\n\n\nclass MembershipUpdateForm(forms.ModelForm):\n\n    class Meta:\n        model = Membership\n        fields = ['testmode', 'membership_type', 'date_start', 'date_end', 'attendee_name_parts', 'canceled']\n        field_classes = {\n            'date_start': SplitDateTimeField,\n            'date_end': SplitDateTimeField,\n        }\n        widgets = {\n            'date_start': SplitDateTimePickerWidget(),\n            'date_end': SplitDateTimePickerWidget(attrs={'data-date-after': '#id_date_Start'}),\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if self.instance and self.instance.pk:\n            del self.fields['testmode']\n\n        self.fields['membership_type'].queryset = self.instance.customer.organizer.membership_types.all()\n        self.fields['attendee_name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=False,\n            scheme=self.instance.customer.organizer.settings.name_scheme,\n            titles=self.instance.customer.organizer.settings.name_scheme_titles,\n            label=_('Attendee name'),\n        )\n\n\nclass OrganizerFooterLinkForm(I18nModelForm):\n    class Meta:\n        model = OrganizerFooterLink\n        fields = ('label', 'url')\n\n\nclass BaseOrganizerFooterLinkFormSet(I18nFormSetMixin, forms.BaseInlineFormSet):\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer', None)\n        if organizer:\n            kwargs['locales'] = organizer.settings.get('locales')\n        super().__init__(*args, **kwargs)\n\n\nOrganizerFooterLinkFormset = inlineformset_factory(\n    Organizer, OrganizerFooterLink,\n    OrganizerFooterLinkForm,\n    formset=BaseOrganizerFooterLinkFormSet,\n    can_order=False, can_delete=True, extra=0\n)\n\n\nclass SSOProviderForm(I18nModelForm):\n\n    config_oidc_base_url = forms.URLField(\n        label=pgettext_lazy('sso_oidc', 'Base URL'),\n        required=False,\n    )\n    config_oidc_client_id = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Client ID'),\n        required=False,\n    )\n    config_oidc_client_secret = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Client secret'),\n        required=False,\n    )\n    config_oidc_scope = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Scope'),\n        help_text=pgettext_lazy('sso_oidc', 'Multiple scopes separated with spaces.'),\n        required=False,\n    )\n    config_oidc_uid_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'User ID field'),\n        help_text=pgettext_lazy('sso_oidc', 'We will assume that the contents of the user ID fields are unique and '\n                                            'can never change for a user.'),\n        required=True,\n        initial='sub',\n    )\n    config_oidc_email_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Email field'),\n        help_text=pgettext_lazy('sso_oidc', 'We will assume that all email addresses received from the SSO provider '\n                                            'are verified to really belong the the user. If this can\\'t be '\n                                            'guaranteed, security issues might arise.'),\n        required=True,\n        initial='email',\n    )\n    config_oidc_phone_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Phone field'),\n        required=False,\n    )\n\n    class Meta:\n        model = CustomerSSOProvider\n        fields = ['is_active', 'name', 'button_label', 'method']\n        widgets = {\n            'method': forms.RadioSelect,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        name_scheme = self.event.settings.name_scheme\n        scheme = PERSON_NAME_SCHEMES.get(name_scheme)\n        for fname, label, size in scheme['fields']:\n            self.fields[f'config_oidc_{fname}_field'] = forms.CharField(\n                label=pgettext_lazy('sso_oidc', f'{label} field').format(label=label),\n                required=False,\n            )\n\n        self.fields['method'].choices = [c for c in self.fields['method'].choices if c[0]]\n\n        for fname, f in self.fields.items():\n            if fname.startswith('config_'):\n                prefix, method, suffix = fname.split('_', 2)\n                f.widget.attrs['data-display-dependency'] = f'input[name=method][value={method}]'\n\n                if self.instance and self.instance.method == method:\n                    f.initial = self.instance.configuration.get(suffix)\n\n    def clean(self):\n        data = self.cleaned_data\n        if not data.get(\"method\"):\n            return data\n\n        config = {}\n        for fname, f in self.fields.items():\n            if fname.startswith(f'config_{data[\"method\"]}_'):\n                prefix, method, suffix = fname.split('_', 2)\n                config[suffix] = data.get(fname)\n\n        if data[\"method\"] == \"oidc\":\n            oidc_validate_and_complete_config(config)\n\n        self.instance.configuration = config\n\n\nclass SSOClientForm(I18nModelForm):\n    regenerate_client_secret = forms.BooleanField(\n        label=_('Invalidate old client secret and generate a new one'),\n        required=False,\n    )\n\n    class Meta:\n        model = CustomerSSOClient\n        fields = ['is_active', 'name', 'client_id', 'client_type', 'authorization_grant_type', 'redirect_uris',\n                  'allowed_scopes']\n        widgets = {\n            'authorization_grant_type': forms.RadioSelect,\n            'client_type': forms.RadioSelect,\n            'allowed_scopes': forms.CheckboxSelectMultiple,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.fields['allowed_scopes'] = forms.MultipleChoiceField(\n            label=self.fields['allowed_scopes'].label,\n            help_text=self.fields['allowed_scopes'].help_text,\n            required=self.fields['allowed_scopes'].required,\n            initial=self.fields['allowed_scopes'].initial,\n            choices=CustomerSSOClient.SCOPE_CHOICES,\n            widget=forms.CheckboxSelectMultiple\n        )\n        if self.instance and self.instance.pk:\n            self.fields['client_id'].disabled = True\n        else:\n            del self.fields['client_id']\n            del self.fields['regenerate_client_secret']\n\n\nclass GiftCardAcceptanceInviteForm(forms.Form):\n    acceptor = forms.CharField(\n        label=_(\"Organizer short name\"),\n        required=True,\n    )\n    reusable_media = forms.BooleanField(\n        label=_(\"Allow access to reusable media\"),\n        help_text=_(\"This is required if you want the other organizer to participate in a shared system with e.g. \"\n                    \"NFC payment chips. You should only use this option for organizers you trust, since (depending \"\n                    \"on the activated medium types) this will grant the other organizer access to cryptographic key \"\n                    \"material required to interact with the media type.\"),\n        required=False,\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    def clean_acceptor(self):\n        val = self.cleaned_data['acceptor']\n        try:\n            acceptor = Organizer.objects.exclude(pk=self.organizer.pk).get(slug=val)\n        except Organizer.DoesNotExist:\n            raise ValidationError(_('The selected organizer does not exist or cannot be invited.'))\n        if self.organizer.gift_card_acceptor_acceptance.filter(acceptor=acceptor).exists():\n            raise ValidationError(_('The selected organizer has already been invited.'))\n        return acceptor\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport logging\nfrom io import BytesIO\n\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\nfrom PIL.Image import MAX_IMAGE_PIXELS, DecompressionBombError\n\nIMAGE_TYPES = {'image/gif', 'image/jpeg', 'image/png'}\nIMAGE_EXTS = {'.gif', '.jpg', '.jpeg', '.png'}\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_uploaded_file_for_valid_image(f):\n    if f is None:\n        return None\n\n    from PIL import Image\n\n    # We need to get a file object for Pillow. We might have a path or we might\n    # have to read the data into memory.\n    if hasattr(f, 'temporary_file_path'):\n        file = f.temporary_file_path()\n    else:\n        if hasattr(f, 'read'):\n            file = BytesIO(f.read())\n        else:\n            file = BytesIO(f['content'])\n\n    try:\n        try:\n            image = Image.open(file)\n            # verify() must be called immediately after the constructor.\n            image.verify()\n        except DecompressionBombError:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n\n        # load() is a potential DoS vector (see Django bug #18520), so we verify the size first\n        if image.width * image.height > MAX_IMAGE_PIXELS:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n    except Exception as exc:\n        logger.exception('Could not parse image')\n        # Pillow doesn't recognize it as an image.\n        if isinstance(exc, ValidationError):\n            raise\n        raise ValidationError(_(\n            \"Upload a valid image. The file you uploaded was either not an image or a corrupted image.\"\n        )) from exc\n    if hasattr(f, 'seek') and callable(f.seek):\n        f.seek(0)\n\n\nclass ImageSizeValidator:\n    def __call__(self, image):\n        if image.width * image.height > MAX_IMAGE_PIXELS:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n        return image\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nfrom datetime import datetime\n\n\ndef monkeypatch_vobject_performance():\n    \"\"\"\n    This works around a performance issue in the unmaintained vobject library which calls\n    a very expensive function for every event in a calendar. Since the slow function is\n    mostly used to compare timezones to UTC, not to arbitrary other timezones, we can\n    add a few early-out optimizations.\n    \"\"\"\n\n    from vobject import icalendar\n\n    old_tzinfo_eq = icalendar.tzinfo_eq\n    test_date = datetime(2000, 1, 1)\n\n    def new_tzinfo_eq(tzinfo1, tzinfo2, *args, **kwargs):\n        if tzinfo1 is None:\n            return tzinfo2 is None\n        if tzinfo2 is None:\n            return tzinfo1 is None\n\n        n1 = tzinfo1.tzname(test_date)\n        n2 = tzinfo2.tzname(test_date)\n        if n1 == \"UTC\" and n2 == \"UTC\":\n            return True\n        if n1 == \"UTC\" or n2 == \"UTC\":\n            return False\n        return old_tzinfo_eq(tzinfo1, tzinfo2, *args, **kwargs)\n\n    icalendar.tzinfo_eq = new_tzinfo_eq\n\n\ndef monkeypatch_all_at_ready():\n    monkeypatch_vobject_performance()\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nfrom arabic_reshaper import ArabicReshaper\nfrom django.utils.functional import SimpleLazyObject\nfrom PIL.Image import Resampling\nfrom reportlab.lib.utils import ImageReader\n\n\nclass ThumbnailingImageReader(ImageReader):\n    def resize(self, width, height, dpi):\n        if width is None:\n            width = height * self._image.size[0] / self._image.size[1]\n        if height is None:\n            height = width * self._image.size[1] / self._image.size[0]\n        self._image.thumbnail(\n            size=(int(width * dpi / 72), int(height * dpi / 72)),\n            resample=Resampling.BICUBIC\n        )\n        self._data = None\n        return width, height\n\n    def _jpeg_fh(self):\n        # Bypass a reportlab-internal optimization that falls back to the original\n        # file handle if the file is a JPEG, and therefore does not respect the\n        # (smaller) size of the modified image.\n        return None\n\n\nreshaper = SimpleLazyObject(lambda: ArabicReshaper(configuration={\n    'delete_harakat': True,\n    'support_ligatures': False,\n}))\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport hashlib\nimport math\nfrom io import BytesIO\n\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import default_storage\nfrom PIL import Image, ImageOps, ImageSequence\nfrom PIL.Image import Resampling\n\nfrom pretix.helpers.models import Thumbnail\n\n\nclass ThumbnailError(Exception):\n    pass\n\n\n\"\"\"\n\n# How \"size\" works:\n\n\n## normal resize\n\nimage|thumb:\"100x100\" resizes the image proportionally to a maximum width and maximum height of 100px.\nI.e. an image of 200x100 will be resized to 100x50.\nAn image of 40x80 will stay 40x80.\n\n\n## cropped resize with ^\n\nimage|thumb:\"100x100^\" resizes the image proportionally to a minimum width and minimum height of 100px and then will be cropped to 100x100.\nI.e. an image of 300x200 will be resized to 150x100 and then cropped from center to 100x100.\nAn image of 40x80 will stay 40x80.\n\n\n## exact-size resize with _\n\nexact-size-operator \"_\" works for width and height independently, so the following is possible:\n\nimage|thumb:\"100_x100\" resizes the image to a maximum height of 100px (if it is lower, it does not upscale) and makes it exactly 100px wide\n(if the resized image would be less than 100px wide it adds a white background to both sides to make it at least 100px wide).\nI.e. an image of 300x200 will be resized to 150x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 100x80.\n\nimage|thumb:\"100x100_\" resizes the image to a maximum width of 100px (if it is lower, it does not upscale) and makes it at least 100px high\n(if the resized image would be less than 100px high it adds a white background to top and bottom to make it at least 100px high).\nI.e. an image of 400x200 will be resized to 100x50 and then padded from center to be 100x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 40x100.\n\nimage|thumb:\"100_x100_\" resizes the image proportionally to either a width or height of 100px \u2013 it takes the smaller side and resizes that to 100px,\nso the longer side will at least be 100px. So the resulting image will at least be 100px wide and at least 100px high. If the original image is bigger\nthan 100x100 then no padding will occur. If the original image is smaller than 100x100, no resize will happen but padding to 100x100 will occur.\nI.e. an image of 400x200 will be resized to 200x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 100x100.\n\n\"\"\"\n\n\ndef get_minsize(size):\n    if \"_\" not in size:\n        return (0, 0)\n    min_width = 0\n    min_height = 0\n    if \"x\" in size:\n        sizes = size.split('x')\n        if sizes[0].endswith(\"_\"):\n            min_width = int(sizes[0][:-1])\n        if sizes[1].endswith(\"_\"):\n            min_height = int(sizes[1][:-1])\n    elif size.endswith(\"_\"):\n        min_width = int(size[:-1])\n        min_height = min_width\n    return (min_width, min_height)\n\n\ndef get_sizes(size, imgsize):\n    crop = False\n    if size.endswith('^'):\n        crop = True\n        size = size[:-1]\n\n    if crop and \"_\" in size:\n        raise ThumbnailError('Size %s has errors: crop and minsize cannot be combined.' % size)\n\n    size = size.replace(\"_\", \"\")\n\n    if 'x' in size:\n        size = [int(p) for p in size.split('x')]\n    else:\n        size = [int(size), int(size)]\n\n    if crop:\n        # currently crop and min-size cannot be combined\n        wfactor = min(1, size[0] / imgsize[0])\n        hfactor = min(1, size[1] / imgsize[1])\n        if wfactor == hfactor:\n            return (int(imgsize[0] * wfactor), int(imgsize[1] * hfactor)), \\\n                   (0, int((imgsize[1] * wfactor - imgsize[1] * hfactor) / 2),\n                    imgsize[0] * hfactor, int((imgsize[1] * wfactor + imgsize[1] * wfactor) / 2))\n        elif wfactor > hfactor:\n            return (int(size[0]), int(imgsize[1] * wfactor)), \\\n                   (0, int((imgsize[1] * wfactor - size[1]) / 2), size[0], int((imgsize[1] * wfactor + size[1]) / 2))\n        else:\n            return (int(imgsize[0] * hfactor), int(size[1])), \\\n                   (int((imgsize[0] * hfactor - size[0]) / 2), 0, int((imgsize[0] * hfactor + size[0]) / 2), size[1])\n    else:\n        wfactor = min(1, size[0] / imgsize[0])\n        hfactor = min(1, size[1] / imgsize[1])\n\n        if wfactor == hfactor:\n            return (int(imgsize[0] * hfactor), int(imgsize[1] * wfactor)), None\n        elif wfactor < hfactor:\n            return (size[0], int(imgsize[1] * wfactor)), None\n        else:\n            return (int(imgsize[0] * hfactor), size[1]), None\n\n\ndef resize_image(image, size):\n    # before we calc thumbnail, we need to check and apply EXIF-orientation\n    image = ImageOps.exif_transpose(image)\n\n    new_size, crop = get_sizes(size, image.size)\n    image = image.resize(new_size, resample=Resampling.LANCZOS)\n    if crop:\n        image = image.crop(crop)\n\n    min_width, min_height = get_minsize(size)\n\n    if min_width > new_size[0] or min_height > new_size[1]:\n        padding = math.ceil(max(min_width - new_size[0], min_height - new_size[1]) / 2)\n        if image.mode not in (\"RGB\", \"RGBA\"):\n            image = image.convert('RGB')\n        image = ImageOps.expand(image, border=padding, fill=\"white\")\n\n        new_width = max(min_width, new_size[0])\n        new_height = max(min_height, new_size[1])\n        new_x = (image.width - new_width) // 2\n        new_y = (image.height - new_height) // 2\n\n        image = image.crop((new_x, new_y, new_x + new_width, new_y + new_height))\n\n    return image\n\n\ndef create_thumbnail(sourcename, size):\n    source = default_storage.open(sourcename)\n    image = Image.open(BytesIO(source.read()))\n    try:\n        image.load()\n    except:\n        raise ThumbnailError('Could not load image')\n\n    frames = [resize_image(frame, size) for frame in ImageSequence.Iterator(image)]\n    image_out = frames[0]\n    save_kwargs = {}\n\n    if source.name.lower().endswith('.jpg') or source.name.lower().endswith('.jpeg'):\n        # Yields better file sizes for photos\n        target_ext = 'jpeg'\n        quality = 95\n    elif source.name.lower().endswith('.gif') or source.name.lower().endswith('.png'):\n        target_ext = source.name.lower()[-3:]\n        quality = None\n        image_out.info = image.info\n        save_kwargs = {\n            'append_images': frames[1:],\n            'loop': image.info.get('loop', 0),\n            'save_all': True,\n        }\n    else:\n        target_ext = 'png'\n        quality = None\n\n    checksum = hashlib.md5(image.tobytes()).hexdigest()\n    name = checksum + '.' + size.replace('^', 'c') + '.' + target_ext\n    buffer = BytesIO()\n    if image_out.mode == \"P\" and source.name.lower().endswith('.png'):\n        image_out = image_out.convert('RGBA')\n    if image_out.mode not in (\"1\", \"L\", \"RGB\", \"RGBA\"):\n        image_out = image_out.convert('RGB')\n    image_out.save(fp=buffer, format=target_ext.upper(), quality=quality, **save_kwargs)\n    imgfile = ContentFile(buffer.getvalue())\n\n    t = Thumbnail.objects.create(source=sourcename, size=size)\n    t.thumb.save(name, imgfile)\n    return t\n\n\ndef get_thumbnail(source, size):\n    # Assumes files are immutable\n    try:\n        return Thumbnail.objects.get(source=source, size=size)\n    except Thumbnail.DoesNotExist:\n        return create_thumbnail(source, size)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexey Kislitsin, Daniel, Flavia Bastos, Sanket\n# Dasgupta, Sohalt, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_scopes.forms import SafeModelMultipleChoiceField\nfrom i18nfield.forms import I18nFormField, I18nTextarea, I18nTextInput\n\nfrom pretix.base.email import get_available_placeholders\nfrom pretix.base.forms import I18nModelForm, PlaceholderValidator\nfrom pretix.base.forms.widgets import (\n    SplitDateTimePickerWidget, TimePickerWidget,\n)\nfrom pretix.base.models import CheckinList, Item, Order, SubEvent\nfrom pretix.control.forms import CachedFileField, SplitDateTimeField\nfrom pretix.control.forms.widgets import Select2, Select2Multiple\nfrom pretix.plugins.sendmail.models import Rule\n\n\nclass FormPlaceholderMixin:\n    def _set_field_placeholders(self, fn, base_parameters):\n        phs = [\n            '{%s}' % p\n            for p in sorted(get_available_placeholders(self.event, base_parameters).keys())\n        ]\n        ht = _('Available placeholders: {list}').format(\n            list=', '.join(phs)\n        )\n        if self.fields[fn].help_text:\n            self.fields[fn].help_text += ' ' + str(ht)\n        else:\n            self.fields[fn].help_text = ht\n        self.fields[fn].validators.append(\n            PlaceholderValidator(phs)\n        )\n\n\nclass BaseMailForm(FormPlaceholderMixin, forms.Form):\n    subject = forms.CharField(label=_(\"Subject\"))\n    message = forms.CharField(label=_(\"Message\"))\n    attachment = CachedFileField(\n        label=_(\"Attachment\"),\n        required=False,\n        ext_whitelist=(\n            \".png\", \".jpg\", \".gif\", \".jpeg\", \".pdf\", \".txt\", \".docx\", \".gif\", \".svg\",\n            \".pptx\", \".ppt\", \".doc\", \".xlsx\", \".xls\", \".jfif\", \".heic\", \".heif\", \".pages\",\n            \".bmp\", \".tif\", \".tiff\"\n        ),\n        help_text=_('Sending an attachment increases the chance of your email not arriving or being sorted into spam folders. We recommend only using PDFs '\n                    'of no more than 2 MB in size.'),\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_ATTACHMENT\n    )\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs.pop('event')\n        context_parameters = kwargs.pop('context_parameters')\n        super().__init__(*args, **kwargs)\n        self.fields['subject'] = I18nFormField(\n            label=_('Subject'),\n            widget=I18nTextInput, required=True,\n            locales=event.settings.get('locales'),\n        )\n        self.fields['message'] = I18nFormField(\n            label=_('Message'),\n            widget=I18nTextarea, required=True,\n            locales=event.settings.get('locales'),\n        )\n        self._set_field_placeholders('subject', context_parameters)\n        self._set_field_placeholders('message', context_parameters)\n\n\nclass WaitinglistMailForm(BaseMailForm):\n    items = forms.ModelMultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple(\n            attrs={'class': 'scrolling-multiple-choice'}\n        ),\n        label=pgettext_lazy('sendmail_form', 'Waiting for'),\n        required=True,\n        queryset=Item.objects.none()\n    )\n    subevent = forms.ModelChoiceField(\n        SubEvent.objects.none(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to a specific event date'),\n        required=False,\n        empty_label=pgettext_lazy('subevent', 'All dates')\n    )\n    subevents_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting at or after'),\n        required=False,\n    )\n    subevents_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting before'),\n        required=False,\n    )\n\n    def clean(self):\n        d = super().clean()\n        if d.get('subevent') and (d.get('subevents_from') or d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'Please either select a specific date or a date range, not both.'))\n        if bool(d.get('subevents_from')) != bool(d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'If you set a date range, please set both a start and an end.'))\n        return d\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs['event']\n        super().__init__(*args, **kwargs)\n\n        self.fields['items'].queryset = event.items.all()\n        if not self.initial.get('items'):\n            self.initial['items'] = event.items.all()\n\n        if event.has_subevents:\n            self.fields['subevent'].queryset = event.subevents.all()\n            self.fields['subevent'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'event',\n                    'data-select2-url': reverse('control:event.subevents.select2', kwargs={\n                        'event': event.slug,\n                        'organizer': event.organizer.slug,\n                    }),\n                    'data-placeholder': pgettext_lazy('subevent', 'Date')\n                }\n            )\n            self.fields['subevent'].widget.choices = self.fields['subevent'].choices\n        else:\n            del self.fields['subevent']\n            del self.fields['subevents_from']\n            del self.fields['subevents_to']\n\n\nclass OrderMailForm(BaseMailForm):\n    recipients = forms.ChoiceField(\n        label=pgettext_lazy('sendmail_form', 'Send to'),\n        widget=forms.RadioSelect,\n        initial='orders',\n        choices=[]\n    )\n    sendto = forms.MultipleChoiceField()  # overridden later\n    items = forms.ModelMultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple(\n            attrs={'class': 'scrolling-multiple-choice'}\n        ),\n        label=pgettext_lazy('sendmail_form', 'Restrict to products'),\n        required=True,\n        queryset=Item.objects.none()\n    )\n    filter_checkins = forms.BooleanField(\n        label=_('Filter check-in status'),\n        required=False\n    )\n    checkin_lists = SafeModelMultipleChoiceField(queryset=CheckinList.objects.none(), required=False)  # overridden later\n    not_checked_in = forms.BooleanField(label=pgettext_lazy('sendmail_form', 'Restrict to recipients without check-in'), required=False)\n    subevent = forms.ModelChoiceField(\n        SubEvent.objects.none(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to a specific event date'),\n        required=False,\n        empty_label=pgettext_lazy('subevent', 'All dates')\n    )\n    subevents_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting at or after'),\n        required=False,\n    )\n    subevents_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting before'),\n        required=False,\n    )\n    created_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to orders created at or after'),\n        required=False,\n    )\n    created_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to orders created before'),\n        required=False,\n    )\n    attach_tickets = forms.BooleanField(\n        label=_(\"Attach tickets\"),\n        help_text=_(\"Will be ignored if tickets exceed a given size limit to ensure email deliverability.\"),\n        required=False\n    )\n    attach_ical = forms.BooleanField(\n        label=_(\"Attach calendar files\"),\n        required=False\n    )\n\n    def clean(self):\n        d = super().clean()\n        if d.get('subevent') and (d.get('subevents_from') or d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'Please either select a specific date or a date range, not both.'))\n        if bool(d.get('subevents_from')) != bool(d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'If you set a date range, please set both a start and an end.'))\n        return d\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs['event']\n        super().__init__(*args, **kwargs)\n\n        recp_choices = [\n            ('orders', _('Everyone who placed an order'))\n        ]\n        if event.settings.attendee_emails_asked:\n            recp_choices += [\n                ('attendees', _('Every attendee (falling back to the order contact when no attendee email address is '\n                                'given)')),\n                ('both', _('Both (all order contact addresses and all attendee email addresses)'))\n            ]\n        self.fields['recipients'].choices = recp_choices\n\n        choices = [(e, l) for e, l in Order.STATUS_CHOICE if e != 'n']\n        choices.insert(0, ('valid_if_pending', _('payment pending but already confirmed')))\n        choices.insert(0, ('na', _('payment pending (except unapproved or already confirmed)')))\n        choices.insert(0, ('pa', _('approval pending')))\n        if not event.settings.get('payment_term_expire_automatically', as_type=bool):\n            choices.append(\n                ('overdue', _('pending with payment overdue'))\n            )\n        self.fields['sendto'] = forms.MultipleChoiceField(\n            label=pgettext_lazy('sendmail_form', 'Restrict to orders with status'),\n            widget=forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice no-search'}\n            ),\n            choices=choices\n        )\n        if not self.initial.get('sendto'):\n            self.initial['sendto'] = ['p', 'valid_if_pending']\n        elif 'n' in self.initial['sendto']:\n            self.initial['sendto'].append('pa')\n            self.initial['sendto'].append('na')\n            self.initial['sendto'].append('valid_if_pending')\n\n        self.fields['items'].queryset = event.items.all()\n        if not self.initial.get('items'):\n            self.initial['items'] = event.items.all()\n\n        self.fields['checkin_lists'].queryset = event.checkin_lists.all()\n        self.fields['checkin_lists'].widget = Select2Multiple(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:event.orders.checkinlists.select2', kwargs={\n                    'event': event.slug,\n                    'organizer': event.organizer.slug,\n                }),\n                'data-placeholder': pgettext_lazy('sendmail_form', 'Restrict to recipients with check-in on list')\n            }\n        )\n        self.fields['checkin_lists'].widget.choices = self.fields['checkin_lists'].choices\n        self.fields['checkin_lists'].label = pgettext_lazy('sendmail_form', 'Restrict to recipients with check-in on list')\n\n        if event.has_subevents:\n            self.fields['subevent'].queryset = event.subevents.all()\n            self.fields['subevent'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'event',\n                    'data-select2-url': reverse('control:event.subevents.select2', kwargs={\n                        'event': event.slug,\n                        'organizer': event.organizer.slug,\n                    }),\n                    'data-placeholder': pgettext_lazy('subevent', 'Date')\n                }\n            )\n            self.fields['subevent'].widget.choices = self.fields['subevent'].choices\n        else:\n            del self.fields['subevent']\n            del self.fields['subevents_from']\n            del self.fields['subevents_to']\n\n\nclass RuleForm(FormPlaceholderMixin, I18nModelForm):\n    class Meta:\n        model = Rule\n\n        fields = ['subject', 'template', 'attach_ical',\n                  'send_date', 'send_offset_days', 'send_offset_time',\n                  'all_products', 'limit_products', 'restrict_to_status',\n                  'send_to', 'enabled']\n\n        field_classes = {\n            'subevent': SafeModelMultipleChoiceField,\n            'limit_products': SafeModelMultipleChoiceField,\n            'send_date': SplitDateTimeField,\n        }\n\n        widgets = {\n            'send_date': SplitDateTimePickerWidget(attrs={\n                'data-display-dependency': '#id_schedule_type_0',\n            }),\n            'send_offset_days': forms.NumberInput(attrs={\n                'data-display-dependency': '#id_schedule_type_1,#id_schedule_type_2,#id_schedule_type_3,'\n                                           '#id_schedule_type_4',\n            }),\n            'send_offset_time': TimePickerWidget(attrs={\n                'data-display-dependency': '#id_schedule_type_1,#id_schedule_type_2,#id_schedule_type_3,'\n                                           '#id_schedule_type_4',\n            }),\n            'limit_products': forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice',\n                       'data-inverse-dependency': '#id_all_products'},\n            ),\n            'send_to': forms.RadioSelect,\n        }\n\n    def __init__(self, *args, **kwargs):\n        instance = kwargs.get('instance')\n\n        if instance:\n            if instance.date_is_absolute:\n                dia = \"abs\"\n            else:\n                dia = \"rel\"\n                dia += \"_a\" if instance.offset_is_after else \"_b\"\n                dia += \"_e\" if instance.offset_to_event_end else \"_s\"\n\n        else:\n            dia = \"abs\"\n\n        kwargs.setdefault('initial', {})\n        kwargs['initial']['schedule_type'] = dia\n\n        super().__init__(*args, **kwargs)\n\n        self.fields['limit_products'].queryset = Item.objects.filter(event=self.event)\n\n        self.fields['schedule_type'] = forms.ChoiceField(\n            label=_('Type of schedule time'),\n            widget=forms.RadioSelect,\n            choices=[\n                ('abs', _('Absolute')),\n                ('rel_b_s', _('Relative, before event start')),\n                ('rel_b_e', _('Relative, before event end')),\n                ('rel_a_s', _('Relative, after event start')),\n                ('rel_a_e', _('Relative, after event end'))\n            ]\n        )\n\n        self._set_field_placeholders('subject', ['event', 'order'])\n        self._set_field_placeholders('template', ['event', 'order'])\n\n        choices = [(e, l) for e, l in Order.STATUS_CHOICE if e != 'n']\n        choices.insert(0, ('n__valid_if_pending', _('payment pending but already confirmed')))\n        choices.insert(0, ('n__not_pending_approval_and_not_valid_if_pending',\n                           _('payment pending (except unapproved or already confirmed)')))\n        choices.insert(0, ('n__pending_approval', _('approval pending')))\n        if not self.event.settings.get('payment_term_expire_automatically', as_type=bool):\n            choices.append(\n                ('p__overdue', _('pending with payment overdue'))\n            )\n        self.fields['restrict_to_status'] = forms.MultipleChoiceField(\n            label=pgettext_lazy('sendmail_from', 'Restrict to orders with status'),\n            widget=forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice no-search'}\n            ),\n            choices=choices\n        )\n        if not self.initial.get('restrict_to_status'):\n            self.initial['restrict_to_status'] = ['p', 'n__valid_if_pending']\n\n    def clean(self):\n        d = super().clean()\n\n        dia = d.get('schedule_type')\n        if dia == 'abs':\n            if not d.get('send_date'):\n                raise ValidationError({'send_date': _('Please specify the send date')})\n            d['date_is_absolute'] = True\n            d['send_offset_days'] = d['send_offset_time'] = None\n        else:\n            if not (d.get('send_offset_days') is not None and d.get('send_offset_time') is not None):\n                raise ValidationError(_('Please specify the offset days and time'))\n            d['offset_is_after'] = '_a' in dia\n            d['offset_to_event_end'] = '_e' in dia\n            d['date_is_absolute'] = False\n            d['send_date'] = None\n\n        if d.get('all_products'):\n            # having products checked while the option is ignored is probably counterintuitive\n            d['limit_products'] = Item.objects.none()\n        else:\n            if not d.get('limit_products'):\n                raise ValidationError({'limit_products': _('Please specify a product')})\n\n        self.instance.offset_is_after = d.get('offset_is_after', False)\n        self.instance.offset_to_event_end = d.get('offset_to_event_end', False)\n        self.instance.date_is_absolute = d.get('date_is_absolute', False)\n\n        return d\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: FlaviaBastos, Jason Estibeiro, Jonas Gro\u00dfe Sundrup,\n# Laura Kl\u00fcnder, Matthew Emerson, Nils Schneider, Tim Freund, Tobias Kunze\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport configparser\nimport logging\nimport os\nimport sys\nfrom json import loads\nfrom urllib.parse import urlparse\n\nimport importlib_metadata as metadata\nfrom django.utils.crypto import get_random_string\nfrom kombu import Queue\n\nfrom . import __version__\nfrom .helpers.config import EnvOrParserConfig\n\n# Pull in all settings that we also need at wheel require time\nfrom ._base_settings import *  # NOQA\n\n\nfrom django.contrib.messages import constants as messages  # NOQA\nfrom django.utils.translation import gettext_lazy as _  # NOQA\n\n_config = configparser.RawConfigParser()\nif 'PRETIX_CONFIG_FILE' in os.environ:\n    _config.read_file(open(os.environ.get('PRETIX_CONFIG_FILE'), encoding='utf-8'))\nelse:\n    _config.read(['/etc/pretix/pretix.cfg', os.path.expanduser('~/.pretix.cfg'), 'pretix.cfg'],\n                 encoding='utf-8')\nconfig = EnvOrParserConfig(_config)\n\nCONFIG_FILE = config\nDATA_DIR = config.get('pretix', 'datadir', fallback=os.environ.get('DATA_DIR', 'data'))\nLOG_DIR = os.path.join(DATA_DIR, 'logs')\nMEDIA_ROOT = os.path.join(DATA_DIR, 'media')\nPROFILE_DIR = os.path.join(DATA_DIR, 'profiles')\nCACHE_DIR = os.path.join(DATA_DIR, 'cache')\n\nif not os.path.exists(DATA_DIR):\n    os.mkdir(DATA_DIR)\nif not os.path.exists(LOG_DIR):\n    os.mkdir(LOG_DIR)\nif not os.path.exists(MEDIA_ROOT):\n    os.mkdir(MEDIA_ROOT)\nif not os.path.exists(CACHE_DIR):\n    os.mkdir(CACHE_DIR)\n\nif config.has_option('django', 'secret'):\n    SECRET_KEY = config.get('django', 'secret')\nelse:\n    SECRET_FILE = os.path.join(DATA_DIR, '.secret')\n    if os.path.exists(SECRET_FILE):\n        with open(SECRET_FILE, 'r') as f:\n            SECRET_KEY = f.read().strip()\n    else:\n        chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'\n        SECRET_KEY = get_random_string(50, chars)\n        with open(SECRET_FILE, 'w') as f:\n            os.chmod(SECRET_FILE, 0o600)\n            try:\n                os.chown(SECRET_FILE, os.getuid(), os.getgid())\n            except AttributeError:\n                pass  # os.chown is not available on Windows\n            f.write(SECRET_KEY)\n\n# Adjustable settings\n\ndebug_fallback = \"runserver\" in sys.argv\nDEBUG = config.getboolean('django', 'debug', fallback=debug_fallback)\nLOG_CSP = config.getboolean('pretix', 'csp_log', fallback=False)\nCSP_ADDITIONAL_HEADER = config.get('pretix', 'csp_additional_header', fallback='')\n\nPDFTK = config.get('tools', 'pdftk', fallback=None)\n\nPRETIX_AUTH_BACKENDS = config.get('pretix', 'auth_backends', fallback='pretix.base.auth.NativeAuthBackend').split(',')\n\ndb_backend = config.get('database', 'backend', fallback='sqlite3')\nif db_backend == 'postgresql_psycopg2':\n    db_backend = 'postgresql'\nelif 'mysql' in db_backend:\n    print(\"pretix does no longer support running on MySQL/MariaDB\")\n    sys.exit(1)\n\ndb_options = {}\n\npostgresql_sslmode = config.get('database', 'sslmode', fallback='disable')\nUSE_DATABASE_TLS = postgresql_sslmode != 'disable'\nUSE_DATABASE_MTLS = USE_DATABASE_TLS and config.has_option('database', 'sslcert')\n\nif USE_DATABASE_TLS or USE_DATABASE_MTLS:\n    tls_config = {}\n    if not USE_DATABASE_MTLS:\n        if 'postgresql' in db_backend:\n            tls_config = {\n                'sslmode': config.get('database', 'sslmode'),\n                'sslrootcert': config.get('database', 'sslrootcert'),\n            }\n    else:\n        if 'postgresql' in db_backend:\n            tls_config = {\n                'sslmode': config.get('database', 'sslmode'),\n                'sslrootcert': config.get('database', 'sslrootcert'),\n                'sslcert': config.get('database', 'sslcert'),\n                'sslkey': config.get('database', 'sslkey'),\n            }\n\n    db_options.update(tls_config)\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.' + db_backend,\n        'NAME': config.get('database', 'name', fallback=os.path.join(DATA_DIR, 'db.sqlite3')),\n        'USER': config.get('database', 'user', fallback=''),\n        'PASSWORD': config.get('database', 'password', fallback=''),\n        'HOST': config.get('database', 'host', fallback=''),\n        'PORT': config.get('database', 'port', fallback=''),\n        'CONN_MAX_AGE': 0 if db_backend == 'sqlite3' else 120,\n        'CONN_HEALTH_CHECKS': db_backend != 'sqlite3',  # Will only be used from Django 4.1 onwards\n        'OPTIONS': db_options,\n        'TEST': {}\n    }\n}\nDATABASE_REPLICA = 'default'\nif config.has_section('replica'):\n    DATABASE_REPLICA = 'replica'\n    DATABASES['replica'] = {\n        'ENGINE': 'django.db.backends.' + db_backend,\n        'NAME': config.get('replica', 'name', fallback=DATABASES['default']['NAME']),\n        'USER': config.get('replica', 'user', fallback=DATABASES['default']['USER']),\n        'PASSWORD': config.get('replica', 'password', fallback=DATABASES['default']['PASSWORD']),\n        'HOST': config.get('replica', 'host', fallback=DATABASES['default']['HOST']),\n        'PORT': config.get('replica', 'port', fallback=DATABASES['default']['PORT']),\n        'CONN_MAX_AGE': 0 if db_backend == 'sqlite3' else 120,\n        'OPTIONS': db_options,\n        'TEST': {}\n    }\n    DATABASE_ROUTERS = ['pretix.helpers.database.ReplicaRouter']\n\nSTATIC_URL = config.get('urls', 'static', fallback='/static/')\n\nMEDIA_URL = config.get('urls', 'media', fallback='/media/')\n\nPRETIX_INSTANCE_NAME = config.get('pretix', 'instance_name', fallback='pretix.de')\nPRETIX_REGISTRATION = config.getboolean('pretix', 'registration', fallback=True)\nPRETIX_PASSWORD_RESET = config.getboolean('pretix', 'password_reset', fallback=True)\nPRETIX_LONG_SESSIONS = config.getboolean('pretix', 'long_sessions', fallback=True)\nPRETIX_ADMIN_AUDIT_COMMENTS = config.getboolean('pretix', 'audit_comments', fallback=False)\nPRETIX_OBLIGATORY_2FA = config.getboolean('pretix', 'obligatory_2fa', fallback=False)\nPRETIX_SESSION_TIMEOUT_RELATIVE = 3600 * 3\nPRETIX_SESSION_TIMEOUT_ABSOLUTE = 3600 * 12\n\nSITE_URL = config.get('pretix', 'url', fallback='http://localhost:8000')\nif SITE_URL.endswith('/'):\n    SITE_URL = SITE_URL[:-1]\n\nCSRF_TRUSTED_ORIGINS = [urlparse(SITE_URL).scheme + '://' + urlparse(SITE_URL).hostname]\n\nTRUST_X_FORWARDED_FOR = config.getboolean('pretix', 'trust_x_forwarded_for', fallback=False)\nUSE_X_FORWARDED_HOST = config.getboolean('pretix', 'trust_x_forwarded_host', fallback=False)\n\n\nREQUEST_ID_HEADER = config.get('pretix', 'request_id_header', fallback=False)\n\nif config.getboolean('pretix', 'trust_x_forwarded_proto', fallback=False):\n    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')\n\nPRETIX_PLUGINS_DEFAULT = config.get('pretix', 'plugins_default',\n                                    fallback='pretix.plugins.sendmail,pretix.plugins.statistics,pretix.plugins.checkinlists,pretix.plugins.autocheckin')\nPRETIX_PLUGINS_EXCLUDE = config.get('pretix', 'plugins_exclude', fallback='').split(',')\nPRETIX_PLUGINS_SHOW_META = config.getboolean('pretix', 'plugins_show_meta', fallback=True)\n\nFETCH_ECB_RATES = config.getboolean('pretix', 'ecb_rates', fallback=True)\n\nDEFAULT_CURRENCY = config.get('pretix', 'currency', fallback='EUR')\n\nALLOWED_HOSTS = ['*']\n\nLANGUAGE_CODE = config.get('locale', 'default', fallback='en')\nTIME_ZONE = config.get('locale', 'timezone', fallback='UTC')\n\nMAIL_FROM = SERVER_EMAIL = DEFAULT_FROM_EMAIL = config.get('mail', 'from', fallback='pretix@localhost')\nMAIL_FROM_NOTIFICATIONS = config.get('mail', 'from_notifications', fallback=MAIL_FROM)\nMAIL_FROM_ORGANIZERS = config.get('mail', 'from_organizers', fallback=MAIL_FROM)\nMAIL_CUSTOM_SENDER_VERIFICATION_REQUIRED = config.getboolean('mail', 'custom_sender_verification_required', fallback=True)\nMAIL_CUSTOM_SENDER_SPF_STRING = config.get('mail', 'custom_sender_spf_string', fallback='')\nMAIL_CUSTOM_SMTP_ALLOW_PRIVATE_NETWORKS = config.getboolean('mail', 'custom_smtp_allow_private_networks', fallback=DEBUG)\nEMAIL_HOST = config.get('mail', 'host', fallback='localhost')\nEMAIL_PORT = config.getint('mail', 'port', fallback=25)\nEMAIL_HOST_USER = config.get('mail', 'user', fallback='')\nEMAIL_HOST_PASSWORD = config.get('mail', 'password', fallback='')\nEMAIL_USE_TLS = config.getboolean('mail', 'tls', fallback=False)\nEMAIL_USE_SSL = config.getboolean('mail', 'ssl', fallback=False)\nEMAIL_SUBJECT_PREFIX = '[pretix] '\nEMAIL_BACKEND = EMAIL_CUSTOM_SMTP_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_TIMEOUT = 60\n\nADMINS = [('Admin', n) for n in config.get('mail', 'admins', fallback='').split(\",\") if n]\n\nMETRICS_ENABLED = config.getboolean('metrics', 'enabled', fallback=False)\nMETRICS_USER = config.get('metrics', 'user', fallback=\"metrics\")\nMETRICS_PASSPHRASE = config.get('metrics', 'passphrase', fallback=\"\")\n\nCACHES = {\n    'default': {\n        'BACKEND': 'pretix.helpers.cache.CustomDummyCache',\n    }\n}\nREAL_CACHE_USED = False\nSESSION_ENGINE = None\n\nHAS_MEMCACHED = config.has_option('memcached', 'location')\nif HAS_MEMCACHED:\n    REAL_CACHE_USED = True\n    CACHES['default'] = {\n        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',\n        'LOCATION': config.get('memcached', 'location'),\n    }\n\nHAS_REDIS = config.has_option('redis', 'location')\nUSE_REDIS_SENTINEL = config.has_option('redis', 'sentinels')\nredis_ssl_cert_reqs = config.get('redis', 'ssl_cert_reqs', fallback='none')\nUSE_REDIS_TLS = redis_ssl_cert_reqs != 'none'\nUSE_REDIS_MTLS = USE_REDIS_TLS and config.has_option('redis', 'ssl_certfile')\nHAS_REDIS_PASSWORD = config.has_option('redis', 'password')\nif HAS_REDIS:\n    OPTIONS = {\n        \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n        \"REDIS_CLIENT_KWARGS\": {\"health_check_interval\": 30}\n    }\n\n    if USE_REDIS_SENTINEL:\n        DJANGO_REDIS_CONNECTION_FACTORY = \"django_redis.pool.SentinelConnectionFactory\"\n        OPTIONS[\"CLIENT_CLASS\"] = \"django_redis.client.SentinelClient\"\n        OPTIONS[\"CONNECTION_POOL_CLASS\"] = \"redis.sentinel.SentinelConnectionPool\"\n        # See https://github.com/jazzband/django-redis/issues/540\n        OPTIONS[\"SENTINEL_KWARGS\"] = {\"socket_timeout\": 1}\n        OPTIONS[\"SENTINELS\"] = [tuple(sentinel) for sentinel in loads(config.get('redis', 'sentinels'))]\n\n    if USE_REDIS_TLS or USE_REDIS_MTLS:\n        tls_config = {}\n        if not USE_REDIS_MTLS:\n            tls_config = {\n                'ssl_cert_reqs': config.get('redis', 'ssl_cert_reqs'),\n                'ssl_ca_certs': config.get('redis', 'ssl_ca_certs'),\n            }\n        else:\n            tls_config = {\n                'ssl_cert_reqs': config.get('redis', 'ssl_cert_reqs'),\n                'ssl_ca_certs': config.get('redis', 'ssl_ca_certs'),\n                'ssl_keyfile': config.get('redis', 'ssl_keyfile'),\n                'ssl_certfile': config.get('redis', 'ssl_certfile'),\n            }\n\n        if USE_REDIS_SENTINEL is False:\n            # The CONNECTION_POOL_KWARGS option is necessary for self-signed certs. For further details, please check\n            # https://github.com/jazzband/django-redis/issues/554#issuecomment-949498321\n            OPTIONS[\"CONNECTION_POOL_KWARGS\"] = tls_config\n            OPTIONS[\"REDIS_CLIENT_KWARGS\"].update(tls_config)\n        else:\n            OPTIONS[\"SENTINEL_KWARGS\"].update(tls_config)\n\n    if HAS_REDIS_PASSWORD:\n        OPTIONS[\"PASSWORD\"] = config.get('redis', 'password')\n\n    CACHES['redis'] = {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": config.get('redis', 'location'),\n        \"OPTIONS\": OPTIONS\n    }\n    CACHES['redis_sessions'] = {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": config.get('redis', 'location'),\n        \"TIMEOUT\": 3600 * 24 * 30,\n        \"OPTIONS\": OPTIONS\n    }\n    if not HAS_MEMCACHED:\n        CACHES['default'] = CACHES['redis']\n        REAL_CACHE_USED = True\n    if config.getboolean('redis', 'sessions', fallback=False):\n        SESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\n        SESSION_CACHE_ALIAS = \"redis_sessions\"\n\nif not SESSION_ENGINE:\n    if REAL_CACHE_USED:\n        SESSION_ENGINE = \"django.contrib.sessions.backends.cached_db\"\n    else:\n        SESSION_ENGINE = \"django.contrib.sessions.backends.db\"\n\nHAS_CELERY = config.has_option('celery', 'broker')\nHAS_CELERY_BROKER_TRANSPORT_OPTS = config.has_option('celery', 'broker_transport_options')\nHAS_CELERY_BACKEND_TRANSPORT_OPTS = config.has_option('celery', 'backend_transport_options')\nif HAS_CELERY:\n    CELERY_BROKER_URL = config.get('celery', 'broker')\n    CELERY_RESULT_BACKEND = config.get('celery', 'backend')\n    if HAS_CELERY_BROKER_TRANSPORT_OPTS:\n        CELERY_BROKER_TRANSPORT_OPTIONS = loads(config.get('celery', 'broker_transport_options'))\n    if HAS_CELERY_BACKEND_TRANSPORT_OPTS:\n        CELERY_RESULT_BACKEND_TRANSPORT_OPTIONS = loads(config.get('celery', 'backend_transport_options'))\nelse:\n    CELERY_TASK_ALWAYS_EAGER = True\n\nSESSION_COOKIE_DOMAIN = config.get('pretix', 'cookie_domain', fallback=None)\n\nCACHE_TICKETS_HOURS = config.getint('cache', 'tickets', fallback=24 * 3)\n\nENTROPY = {\n    'order_code': config.getint('entropy', 'order_code', fallback=5),\n    'customer_identifier': config.getint('entropy', 'customer_identifier', fallback=7),\n    'ticket_secret': config.getint('entropy', 'ticket_secret', fallback=32),\n    'voucher_code': config.getint('entropy', 'voucher_code', fallback=16),\n    'giftcard_secret': config.getint('entropy', 'giftcard_secret', fallback=12),\n}\n\nHAS_GEOIP = False\nif config.has_option('geoip', 'path'):\n    HAS_GEOIP = True\n    GEOIP_PATH = config.get('geoip', 'path')\n    GEOIP_COUNTRY = config.get('geoip', 'filename_country', fallback='GeoLite2-Country.mmdb')\n\n# Internal settings\nSESSION_COOKIE_NAME = 'pretix_session'\nLANGUAGE_COOKIE_NAME = 'pretix_language'\nCSRF_COOKIE_NAME = 'pretix_csrftoken'\nSESSION_COOKIE_HTTPONLY = True\n\nINSTALLED_APPS += [ # noqa\n    'django_filters',\n    'django_markup',\n    'django_otp',\n    'django_otp.plugins.otp_totp',\n    'django_otp.plugins.otp_static',\n    'hijack',\n    'localflavor',\n]\n\nif db_backend == 'postgresql':\n    # ALlow plugins to use django.contrib.postgres\n    INSTALLED_APPS.insert(0, 'django.contrib.postgres')\n\ntry:\n    import django_extensions  # noqa\n    INSTALLED_APPS.append('django_extensions')\nexcept ImportError:\n    pass\n\nPLUGINS = []\nfor entry_point in metadata.entry_points(group='pretix.plugin'):\n    if entry_point.module in PRETIX_PLUGINS_EXCLUDE:\n        continue\n    PLUGINS.append(entry_point.module)\n    INSTALLED_APPS.append(entry_point.module)\n\nHIJACK_PERMISSION_CHECK = \"hijack.permissions.superusers_and_staff\"\nHIJACK_INSERT_BEFORE = None\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': [\n        'pretix.api.auth.permission.EventPermission',\n    ],\n    'DEFAULT_PAGINATION_CLASS': 'pretix.api.pagination.Pagination',\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 50,\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'pretix.api.auth.token.TeamTokenAuthentication',\n        'pretix.api.auth.device.DeviceTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',\n    ),\n    'DEFAULT_RENDERER_CLASSES': (\n        'drf_ujson.renderers.UJSONRenderer',\n    ),\n    'DEFAULT_PARSER_CLASSES': (\n        'drf_ujson.parsers.UJSONParser',\n        'rest_framework.parsers.FormParser',\n        'rest_framework.parsers.MultiPartParser'\n    ),\n    'TEST_REQUEST_RENDERER_CLASSES': [\n        'rest_framework.renderers.MultiPartRenderer',\n        'rest_framework.renderers.JSONRenderer',\n        'pretix.testutils.api.UploadRenderer',\n    ],\n    'EXCEPTION_HANDLER': 'pretix.api.exception.custom_exception_handler',\n    'UNICODE_JSON': False\n}\n\n\nCORE_MODULES = {\n    \"pretix.base\",\n    \"pretix.presale\",\n    \"pretix.control\",\n    \"pretix.plugins.checkinlists\",\n    \"pretix.plugins.reports\",\n}\n\nMIDDLEWARE = [\n    'pretix.helpers.logs.RequestIdMiddleware',\n    'pretix.api.middleware.IdempotencyMiddleware',\n    'pretix.multidomain.middlewares.MultiDomainMiddleware',\n    'pretix.base.middleware.CustomCommonMiddleware',\n    'pretix.multidomain.middlewares.SessionMiddleware',\n    'pretix.multidomain.middlewares.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n    'hijack.middleware.HijackUserMiddleware',\n    'pretix.control.middleware.PermissionMiddleware',\n    'pretix.control.middleware.AuditLogMiddleware',\n    'pretix.base.middleware.LocaleMiddleware',\n    'pretix.base.middleware.SecurityMiddleware',\n    'pretix.presale.middleware.EventMiddleware',\n    'pretix.api.middleware.ApiScopeMiddleware',\n]\n\ntry:\n    import debug_toolbar.settings  # noqa\n    if DEBUG:\n        INSTALLED_APPS.append('debug_toolbar.apps.DebugToolbarConfig')\n        MIDDLEWARE.insert(0, 'debug_toolbar.middleware.DebugToolbarMiddleware')\n        DEBUG_TOOLBAR_PATCH_SETTINGS = False\n        DEBUG_TOOLBAR_CONFIG = {\n            'JQUERY_URL': '',\n            'DISABLE_PANELS': debug_toolbar.settings.PANELS_DEFAULTS,\n        }\n    pass\nexcept ImportError:\n    pass\n\n\nif METRICS_ENABLED:\n    MIDDLEWARE.insert(MIDDLEWARE.index('pretix.base.middleware.CustomCommonMiddleware') + 1,\n                      'pretix.helpers.metrics.middleware.MetricsMiddleware')\n\n\nPROFILING_RATE = config.getfloat('django', 'profile', fallback=0)  # Percentage of requests to profile\nif PROFILING_RATE > 0:\n    if not os.path.exists(PROFILE_DIR):\n        os.mkdir(PROFILE_DIR)\n    MIDDLEWARE.insert(0, 'pretix.helpers.profile.middleware.CProfileMiddleware')\n\n\n# Security settings\nX_FRAME_OPTIONS = 'DENY'\n\n# URL settings\nROOT_URLCONF = 'pretix.multidomain.maindomain_urlconf'\n\nWSGI_APPLICATION = 'pretix.wsgi.application'\n\nif config.has_option('languages', 'path'):\n    LOCALE_PATHS.insert(0, config.get('languages', 'path')) # noqa\n\nLANGUAGES_INCUBATING = LANGUAGES_INCUBATING - set(config.get('languages', 'allow_incubating', fallback='').split(',')) # noqa\nLANGUAGES = []\nLANGUAGES_ENABLED = [lang for lang in config.get(\"languages\", \"enabled\", fallback='').split(',') if lang]\nfor k, v in ALL_LANGUAGES: # noqa\n    if not DEBUG and k in LANGUAGES_INCUBATING:\n        continue\n    if LANGUAGES_ENABLED and k not in LANGUAGES_ENABLED:\n        continue\n    LANGUAGES.append((k, v))\n\n\nAUTH_USER_MODEL = 'pretixbase.User'\nLOGIN_URL = 'control:auth.login'\nLOGIN_URL_CONTROL = 'control:auth.login'\nCSRF_FAILURE_VIEW = 'pretix.base.views.errors.csrf_failure'\n\ntemplate_loaders = (\n    'django.template.loaders.filesystem.Loader',\n    'pretix.helpers.template_loaders.AppLoader',\n)\nif not DEBUG:\n    TEMPLATES[0]['OPTIONS']['loaders'] = ( # noqa\n        ('django.template.loaders.cached.Loader', template_loaders),\n    )\nTEMPLATES[0]['DIRS'].insert(0, os.path.join(DATA_DIR, 'templates')) # noqa\n\nINTERNAL_IPS = ('127.0.0.1', '::1')\n\nMESSAGE_TAGS = {\n    messages.INFO: 'alert-info',\n    messages.ERROR: 'alert-danger',\n    messages.WARNING: 'alert-warning',\n    messages.SUCCESS: 'alert-success',\n}\nMESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'\n\nloglevel = 'DEBUG' if DEBUG else config.get('pretix', 'loglevel', fallback='INFO')\n\nCOMPRESS_ENABLED = COMPRESS_OFFLINE = not debug_fallback\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'default': {\n            'format': (\n                '%(levelname)s %(asctime)s RequestId=%(request_id)s %(name)s %(module)s %(message)s'\n                if REQUEST_ID_HEADER\n                else '%(levelname)s %(asctime)s %(name)s %(module)s %(message)s'\n            )\n        },\n    },\n    'filters': {\n        'require_admin_enabled': {\n            '()': 'pretix.helpers.logs.AdminExistsFilter',\n        },\n        'request_id': {\n            '()': 'pretix.helpers.logs.RequestIdFilter'\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': loglevel,\n            'class': 'logging.StreamHandler',\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'csp_file': {\n            'level': loglevel,\n            'class': 'logging.FileHandler',\n            'filename': os.path.join(LOG_DIR, 'csp.log'),\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'file': {\n            'level': loglevel,\n            'class': 'logging.FileHandler',\n            'filename': os.path.join(LOG_DIR, 'pretix.log'),\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'mail_admins': {\n            'level': 'ERROR',\n            'class': 'django.utils.log.AdminEmailHandler',\n            'filters': ['require_admin_enabled']\n        },\n        'null': {\n            'class': 'logging.NullHandler',\n        },\n    },\n    'loggers': {\n        '': {\n            'handlers': ['file', 'console'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'django.request': {\n            'handlers': ['file', 'console', 'mail_admins'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'pretix.security.csp': {\n            'handlers': ['csp_file'],\n            'level': loglevel,\n            'propagate': False,\n        },\n        'django.security': {\n            'handlers': ['file', 'console', 'mail_admins'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'django.security.DisallowedHost': {\n            'handlers': ['null'],\n            'propagate': False,\n        },\n        'django.db.backends': {\n            'handlers': ['file', 'console'],\n            'level': 'INFO',  # Do not output all the queries\n            'propagate': False,\n        },\n        'asyncio': {\n            'handlers': ['file', 'console'],\n            'level': 'WARNING',\n        },\n    },\n}\n\nSENTRY_ENABLED = False\nif config.has_option('sentry', 'dsn') and not any(c in sys.argv for c in ('shell', 'shell_scoped', 'shell_plus')):\n    import sentry_sdk\n    from sentry_sdk.integrations.celery import CeleryIntegration\n    from sentry_sdk.integrations.logging import (\n        LoggingIntegration, ignore_logger,\n    )\n\n    from .sentry import PretixSentryIntegration, setup_custom_filters\n\n    SENTRY_TOKEN = config.get('sentry', 'traces_sample_token', fallback='')\n\n    def traces_sampler(sampling_context):\n        qs = sampling_context.get('wsgi_environ', {}).get('QUERY_STRING', '')\n        if SENTRY_TOKEN and SENTRY_TOKEN in qs:\n            return 1.0\n        return config.getfloat('sentry', 'traces_sample_rate', fallback=0.0)\n\n    SENTRY_ENABLED = True\n    sentry_sdk.init(\n        dsn=config.get('sentry', 'dsn'),\n        integrations=[\n            PretixSentryIntegration(),\n            CeleryIntegration(),\n            LoggingIntegration(\n                level=logging.INFO,\n                event_level=logging.CRITICAL\n            )\n        ],\n        traces_sampler=traces_sampler,\n        environment=urlparse(SITE_URL).netloc,\n        release=__version__,\n        send_default_pii=False,\n        propagate_traces=False,  # see https://github.com/getsentry/sentry-python/issues/1717\n    )\n    ignore_logger('pretix.base.tasks')\n    ignore_logger('django.security.DisallowedHost')\n    setup_custom_filters()\n\nCELERY_TASK_SERIALIZER = 'json'\nCELERY_RESULT_SERIALIZER = 'json'\nCELERY_TASK_DEFAULT_QUEUE = 'default'\nCELERY_TASK_QUEUES = (\n    Queue('default', routing_key='default.#'),\n    Queue('checkout', routing_key='checkout.#'),\n    Queue('mail', routing_key='mail.#'),\n    Queue('background', routing_key='background.#'),\n    Queue('notifications', routing_key='notifications.#'),\n)\nCELERY_TASK_ROUTES = ([\n    ('pretix.base.services.cart.*', {'queue': 'checkout'}),\n    ('pretix.base.services.export.scheduled_organizer_export', {'queue': 'background'}),\n    ('pretix.base.services.export.scheduled_event_export', {'queue': 'background'}),\n    ('pretix.base.services.orders.*', {'queue': 'checkout'}),\n    ('pretix.base.services.mail.*', {'queue': 'mail'}),\n    ('pretix.base.services.update_check.*', {'queue': 'background'}),\n    ('pretix.base.services.quotas.*', {'queue': 'background'}),\n    ('pretix.base.services.waitinglist.*', {'queue': 'background'}),\n    ('pretix.base.services.notifications.*', {'queue': 'notifications'}),\n    ('pretix.api.webhooks.*', {'queue': 'notifications'}),\n    ('pretix.presale.style.*', {'queue': 'background'}),\n    ('pretix.plugins.banktransfer.*', {'queue': 'background'}),\n],)\n\nBOOTSTRAP3 = {\n    'success_css_class': '',\n    'field_renderers': {\n        'default': 'pretix.base.forms.renderers.FieldRenderer',\n        'inline': 'pretix.base.forms.renderers.InlineFieldRenderer',\n        'control': 'pretix.control.forms.renderers.ControlFieldRenderer',\n        'bulkedit': 'pretix.control.forms.renderers.BulkEditFieldRenderer',\n        'bulkedit_inline': 'pretix.control.forms.renderers.InlineBulkEditFieldRenderer',\n        'checkout': 'pretix.presale.forms.renderers.CheckoutFieldRenderer',\n    },\n}\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\nOAUTH2_PROVIDER_APPLICATION_MODEL = 'pretixapi.OAuthApplication'\nOAUTH2_PROVIDER_GRANT_MODEL = 'pretixapi.OAuthGrant'\nOAUTH2_PROVIDER_ACCESS_TOKEN_MODEL = 'pretixapi.OAuthAccessToken'\nOAUTH2_PROVIDER_ID_TOKEN_MODEL = 'pretixapi.OAuthIDToken'\nOAUTH2_PROVIDER_REFRESH_TOKEN_MODEL = 'pretixapi.OAuthRefreshToken'\nOAUTH2_PROVIDER = {\n    'SCOPES': {\n        'profile': _('User profile only'),\n        'read': _('Read access'),\n        'write': _('Write access'),\n    },\n    'OAUTH2_VALIDATOR_CLASS': 'pretix.api.oauth.Validator',\n    'ALLOWED_REDIRECT_URI_SCHEMES': ['https'] if not DEBUG else ['http', 'https'],\n    'ACCESS_TOKEN_EXPIRE_SECONDS': 3600 * 24,\n    'ROTATE_REFRESH_TOKEN': False,\n    'PKCE_REQUIRED': False,\n    'OIDC_RESPONSE_TYPES_SUPPORTED': [\"code\"],  # We don't support proper OIDC for now\n}\n\nCOUNTRIES_OVERRIDE = {\n    'XK': _('Kosovo'),\n}\n\nDATA_UPLOAD_MAX_NUMBER_FIELDS = 25000\nDATA_UPLOAD_MAX_MEMORY_SIZE = 10 * 1024 * 1024  # 10 MB\n\n# File sizes are in MiB\nFILE_UPLOAD_MAX_SIZE_IMAGE = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_image\", fallback=10)\nFILE_UPLOAD_MAX_SIZE_FAVICON = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_favicon\", fallback=1)\nFILE_UPLOAD_MAX_SIZE_EMAIL_ATTACHMENT = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_email_attachment\", fallback=5)\nFILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_email_auto_attachment\", fallback=1)\nFILE_UPLOAD_MAX_SIZE_OTHER = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_other\", fallback=10)\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'  # sadly. we would prefer BigInt, and should use it for all new models but the migration will be hard\n"], "fixing_code": ["#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport datetime\nimport mimetypes\nimport os\nfrom decimal import Decimal\nfrom zoneinfo import ZoneInfo\n\nimport django_filters\nfrom django.conf import settings\nfrom django.db import transaction\nfrom django.db.models import (\n    Exists, F, OuterRef, Prefetch, Q, Subquery, prefetch_related_objects,\n)\nfrom django.db.models.functions import Coalesce, Concat\nfrom django.http import FileResponse, HttpResponse\nfrom django.shortcuts import get_object_or_404\nfrom django.utils.timezone import make_aware, now\nfrom django.utils.translation import gettext as _\nfrom django_filters.rest_framework import DjangoFilterBackend, FilterSet\nfrom django_scopes import scopes_disabled\nfrom PIL import Image\nfrom rest_framework import serializers, status, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.exceptions import (\n    APIException, NotFound, PermissionDenied, ValidationError,\n)\nfrom rest_framework.mixins import CreateModelMixin\nfrom rest_framework.response import Response\n\nfrom pretix.api.models import OAuthAccessToken\nfrom pretix.api.pagination import TotalOrderingFilter\nfrom pretix.api.serializers.order import (\n    BlockedTicketSecretSerializer, InvoiceSerializer, OrderCreateSerializer,\n    OrderPaymentCreateSerializer, OrderPaymentSerializer,\n    OrderPositionSerializer, OrderRefundCreateSerializer,\n    OrderRefundSerializer, OrderSerializer, PriceCalcSerializer,\n    RevokedTicketSecretSerializer, SimulatedOrderSerializer,\n)\nfrom pretix.api.serializers.orderchange import (\n    BlockNameSerializer, OrderChangeOperationSerializer,\n    OrderFeeChangeSerializer, OrderPositionChangeSerializer,\n    OrderPositionCreateForExistingOrderSerializer,\n    OrderPositionInfoPatchSerializer,\n)\nfrom pretix.api.views import RichOrderingFilter\nfrom pretix.base.i18n import language\nfrom pretix.base.models import (\n    CachedCombinedTicket, CachedTicket, Checkin, Device, EventMetaValue,\n    Invoice, InvoiceAddress, ItemMetaValue, ItemVariation,\n    ItemVariationMetaValue, Order, OrderFee, OrderPayment, OrderPosition,\n    OrderRefund, Quota, ReusableMedium, SubEvent, SubEventMetaValue, TaxRule,\n    TeamAPIToken, generate_secret,\n)\nfrom pretix.base.models.orders import (\n    BlockedTicketSecret, QuestionAnswer, RevokedTicketSecret,\n)\nfrom pretix.base.payment import PaymentException\nfrom pretix.base.pdf import get_images\nfrom pretix.base.secrets import assign_ticket_secret\nfrom pretix.base.services import tickets\nfrom pretix.base.services.invoices import (\n    generate_cancellation, generate_invoice, invoice_pdf, invoice_qualified,\n    regenerate_invoice,\n)\nfrom pretix.base.services.mail import SendMailException\nfrom pretix.base.services.orders import (\n    OrderChangeManager, OrderError, _order_placed_email,\n    _order_placed_email_attendee, approve_order, cancel_order, deny_order,\n    extend_order, mark_order_expired, mark_order_refunded, reactivate_order,\n)\nfrom pretix.base.services.pricing import get_price\nfrom pretix.base.services.tickets import generate\nfrom pretix.base.signals import (\n    order_modified, order_paid, order_placed, register_ticket_outputs,\n)\nfrom pretix.base.templatetags.money import money_filter\nfrom pretix.control.signals import order_search_filter_q\n\nwith scopes_disabled():\n    class OrderFilter(FilterSet):\n        email = django_filters.CharFilter(field_name='email', lookup_expr='iexact')\n        code = django_filters.CharFilter(field_name='code', lookup_expr='iexact')\n        status = django_filters.CharFilter(field_name='status', lookup_expr='iexact')\n        modified_since = django_filters.IsoDateTimeFilter(field_name='last_modified', lookup_expr='gte')\n        created_since = django_filters.IsoDateTimeFilter(field_name='datetime', lookup_expr='gte')\n        subevent_after = django_filters.IsoDateTimeFilter(method='subevent_after_qs')\n        subevent_before = django_filters.IsoDateTimeFilter(method='subevent_before_qs')\n        search = django_filters.CharFilter(method='search_qs')\n        item = django_filters.CharFilter(field_name='all_positions', lookup_expr='item_id', distinct=True)\n        variation = django_filters.CharFilter(field_name='all_positions', lookup_expr='variation_id', distinct=True)\n        subevent = django_filters.CharFilter(field_name='all_positions', lookup_expr='subevent_id', distinct=True)\n\n        class Meta:\n            model = Order\n            fields = ['code', 'status', 'email', 'locale', 'testmode', 'require_approval']\n\n        @scopes_disabled()\n        def subevent_after_qs(self, qs, name, value):\n            qs = qs.filter(\n                pk__in=Subquery(\n                    OrderPosition.all.filter(\n                        subevent_id__in=SubEvent.objects.filter(\n                            Q(date_to__gt=value) | Q(date_from__gt=value, date_to__isnull=True),\n                            event=self.request.event\n                        ).values_list('id'),\n                    ).values_list('order_id')\n                )\n            )\n            return qs\n\n        def subevent_before_qs(self, qs, name, value):\n            qs = qs.filter(\n                pk__in=Subquery(\n                    OrderPosition.all.filter(\n                        subevent_id__in=SubEvent.objects.filter(\n                            Q(date_from__lt=value),\n                            event=self.request.event\n                        ).values_list('id'),\n                    ).values_list('order_id')\n                )\n            )\n            return qs\n\n        def search_qs(self, qs, name, value):\n            u = value\n            if \"-\" in value:\n                code = (Q(event__slug__icontains=u.rsplit(\"-\", 1)[0])\n                        & Q(code__icontains=Order.normalize_code(u.rsplit(\"-\", 1)[1])))\n            else:\n                code = Q(code__icontains=Order.normalize_code(u))\n\n            invoice_nos = {u, u.upper()}\n            if u.isdigit():\n                for i in range(2, 12):\n                    invoice_nos.add(u.zfill(i))\n\n            matching_invoices = Invoice.objects.filter(\n                Q(invoice_no__in=invoice_nos)\n                | Q(full_invoice_no__iexact=u)\n            ).values_list('order_id', flat=True)\n\n            matching_positions = OrderPosition.objects.filter(\n                Q(order=OuterRef('pk')) & Q(\n                    Q(attendee_name_cached__icontains=u) | Q(attendee_email__icontains=u)\n                    | Q(secret__istartswith=u)\n                    # | Q(voucher__code__icontains=u)  # temporarily removed since it caused bad query performance on postgres\n                )\n            ).values('id')\n\n            matching_media = ReusableMedium.objects.filter(identifier=u).values_list('linked_orderposition__order_id', flat=True)\n\n            mainq = (\n                code\n                | Q(email__icontains=u)\n                | Q(invoice_address__name_cached__icontains=u)\n                | Q(invoice_address__company__icontains=u)\n                | Q(pk__in=matching_invoices)\n                | Q(pk__in=matching_media)\n                | Q(comment__icontains=u)\n                | Q(has_pos=True)\n            )\n            for recv, q in order_search_filter_q.send(sender=getattr(self, 'event', None), query=u):\n                mainq = mainq | q\n            return qs.annotate(has_pos=Exists(matching_positions)).filter(\n                mainq\n            )\n\n\nclass OrderViewSet(viewsets.ModelViewSet):\n    serializer_class = OrderSerializer\n    queryset = Order.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('datetime',)\n    ordering_fields = ('datetime', 'code', 'status', 'last_modified')\n    filterset_class = OrderFilter\n    lookup_field = 'code'\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['event'] = self.request.event\n        ctx['pdf_data'] = self.request.query_params.get('pdf_data', 'false') == 'true'\n        ctx['exclude'] = self.request.query_params.getlist('exclude')\n        ctx['include'] = self.request.query_params.getlist('include')\n        return ctx\n\n    def get_queryset(self):\n        qs = self.request.event.orders\n        if 'fees' not in self.request.GET.getlist('exclude'):\n            if self.request.query_params.get('include_canceled_fees', 'false') == 'true':\n                fqs = OrderFee.all\n            else:\n                fqs = OrderFee.objects\n            qs = qs.prefetch_related(Prefetch('fees', queryset=fqs.all()))\n        if 'payments' not in self.request.GET.getlist('exclude'):\n            qs = qs.prefetch_related('payments')\n        if 'refunds' not in self.request.GET.getlist('exclude'):\n            qs = qs.prefetch_related('refunds', 'refunds__payment')\n        if 'invoice_address' not in self.request.GET.getlist('exclude'):\n            qs = qs.select_related('invoice_address')\n\n        qs = qs.prefetch_related(self._positions_prefetch(self.request))\n        return qs\n\n    def _positions_prefetch(self, request):\n        if request.query_params.get('include_canceled_positions', 'false') == 'true':\n            opq = OrderPosition.all\n        else:\n            opq = OrderPosition.objects\n        if request.query_params.get('pdf_data', 'false') == 'true':\n            prefetch_related_objects([request.organizer], 'meta_properties')\n            prefetch_related_objects(\n                [request.event],\n                Prefetch('meta_values', queryset=EventMetaValue.objects.select_related('property'), to_attr='meta_values_cached'),\n                'questions',\n                'item_meta_properties',\n            )\n            return Prefetch(\n                'positions',\n                opq.all().prefetch_related(\n                    Prefetch('checkins', queryset=Checkin.objects.all()),\n                    Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                        Prefetch('meta_values', ItemMetaValue.objects.select_related('property'), to_attr='meta_values_cached')\n                    )),\n                    Prefetch('variation', queryset=ItemVariation.objects.prefetch_related(\n                        Prefetch('meta_values', ItemVariationMetaValue.objects.select_related('property'), to_attr='meta_values_cached')\n                    )),\n                    'answers', 'answers__options', 'answers__question',\n                    'item__category',\n                    'addon_to__answers', 'addon_to__answers__options', 'addon_to__answers__question',\n                    Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                        Prefetch('meta_values', to_attr='meta_values_cached', queryset=SubEventMetaValue.objects.select_related('property'))\n                    )),\n                    Prefetch('addons', opq.select_related('item', 'variation', 'seat')),\n                    'linked_media',\n                ).select_related('seat', 'addon_to', 'addon_to__seat')\n            )\n        else:\n            return Prefetch(\n                'positions',\n                opq.all().prefetch_related(\n                    Prefetch('checkins', queryset=Checkin.objects.all()),\n                    'item', 'variation',\n                    Prefetch('answers', queryset=QuestionAnswer.objects.prefetch_related('options', 'question').order_by('question__position')),\n                    'seat',\n                )\n            )\n\n    def _get_output_provider(self, identifier):\n        responses = register_ticket_outputs.send(self.request.event)\n        for receiver, response in responses:\n            prov = response(self.request.event)\n            if prov.identifier == identifier:\n                return prov\n        raise NotFound('Unknown output provider.')\n\n    @scopes_disabled()  # we are sure enough that get_queryset() is correct, so we save some perforamnce\n    def list(self, request, **kwargs):\n        date = serializers.DateTimeField().to_representation(now())\n        queryset = self.filter_queryset(self.get_queryset())\n\n        page = self.paginate_queryset(queryset)\n        if page is not None:\n            serializer = self.get_serializer(page, many=True)\n            resp = self.get_paginated_response(serializer.data)\n            resp['X-Page-Generated'] = date\n            return resp\n\n        serializer = self.get_serializer(queryset, many=True)\n        return Response(serializer.data, headers={'X-Page-Generated': date})\n\n    @action(detail=True, url_name='download', url_path='download/(?P<output>[^/]+)')\n    def download(self, request, output, **kwargs):\n        provider = self._get_output_provider(output)\n        order = self.get_object()\n\n        if order.status in (Order.STATUS_CANCELED, Order.STATUS_EXPIRED):\n            raise PermissionDenied(\"Downloads are not available for canceled or expired orders.\")\n\n        if order.status == Order.STATUS_PENDING and not (order.valid_if_pending or request.event.settings.ticket_download_pending):\n            raise PermissionDenied(\"Downloads are not available for pending orders.\")\n\n        ct = CachedCombinedTicket.objects.filter(\n            order=order, provider=provider.identifier, file__isnull=False\n        ).last()\n        if not ct or not ct.file:\n            generate.apply_async(args=('order', order.pk, provider.identifier))\n            raise RetryException()\n        else:\n            if ct.type == 'text/uri-list':\n                resp = HttpResponse(ct.file.file.read(), content_type='text/uri-list')\n                return resp\n            else:\n                resp = FileResponse(ct.file.file, content_type=ct.type)\n                resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}{}\"'.format(\n                    self.request.event.slug.upper(), order.code,\n                    provider.identifier, ct.extension\n                )\n                return resp\n\n    @action(detail=True, methods=['POST'])\n    def mark_paid(self, request, **kwargs):\n        order = self.get_object()\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        if order.status in (Order.STATUS_PENDING, Order.STATUS_EXPIRED):\n\n            ps = order.pending_sum\n            try:\n                p = order.payments.get(\n                    state__in=(OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED),\n                    provider='manual',\n                    amount=ps\n                )\n            except OrderPayment.DoesNotExist:\n                for p in order.payments.filter(state__in=(OrderPayment.PAYMENT_STATE_PENDING,\n                                                          OrderPayment.PAYMENT_STATE_CREATED)):\n                    try:\n                        with transaction.atomic():\n                            p.payment_provider.cancel_payment(p)\n                            order.log_action('pretix.event.order.payment.canceled', {\n                                'local_id': p.local_id,\n                                'provider': p.provider,\n                            }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n                    except PaymentException as e:\n                        order.log_action(\n                            'pretix.event.order.payment.canceled.failed',\n                            {\n                                'local_id': p.local_id,\n                                'provider': p.provider,\n                                'error': str(e)\n                            },\n                            user=self.request.user if self.request.user.is_authenticated else None,\n                            auth=self.request.auth\n                        )\n                p = order.payments.create(\n                    state=OrderPayment.PAYMENT_STATE_CREATED,\n                    provider='manual',\n                    amount=ps,\n                    fee=None\n                )\n\n            try:\n                p.confirm(auth=self.request.auth,\n                          user=self.request.user if request.user.is_authenticated else None,\n                          send_mail=send_mail,\n                          count_waitinglist=False)\n            except Quota.QuotaExceededException as e:\n                return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n            except PaymentException as e:\n                return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n            except SendMailException:\n                pass\n\n            return self.retrieve(request, [], **kwargs)\n        return Response(\n            {'detail': 'The order is not pending or expired.'},\n            status=status.HTTP_400_BAD_REQUEST\n        )\n\n    @action(detail=True, methods=['POST'])\n    def mark_canceled(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        comment = request.data.get('comment', None)\n        cancellation_fee = request.data.get('cancellation_fee', None)\n        if cancellation_fee:\n            try:\n                cancellation_fee = float(Decimal(cancellation_fee))\n            except:\n                cancellation_fee = None\n\n        order = self.get_object()\n        if not order.cancel_allowed():\n            return Response(\n                {'detail': 'The order is not allowed to be canceled.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        try:\n            cancel_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                api_token=request.auth if isinstance(request.auth, TeamAPIToken) else None,\n                device=request.auth if isinstance(request.auth, Device) else None,\n                oauth_application=request.auth.application if isinstance(request.auth, OAuthAccessToken) else None,\n                send_mail=send_mail,\n                email_comment=comment,\n                cancellation_fee=cancellation_fee\n            )\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def reactivate(self, request, **kwargs):\n\n        order = self.get_object()\n        if order.status != Order.STATUS_CANCELED:\n            return Response(\n                {'detail': 'The order is not allowed to be reactivated.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        try:\n            reactivate_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n            )\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def approve(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        order = self.get_object()\n        try:\n            approve_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n                send_mail=send_mail,\n            )\n        except Quota.QuotaExceededException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except OrderError as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def deny(self, request, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        comment = request.data.get('comment', '')\n\n        order = self.get_object()\n        try:\n            deny_order(\n                order,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth if isinstance(request.auth, (Device, TeamAPIToken, OAuthAccessToken)) else None,\n                send_mail=send_mail,\n                comment=comment,\n            )\n        except OrderError as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_pending(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PAID:\n            return Response(\n                {'detail': 'The order is not paid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        order.status = Order.STATUS_PENDING\n        order.save(update_fields=['status'])\n        order.log_action(\n            'pretix.event.order.unpaid',\n            user=request.user if request.user.is_authenticated else None,\n            auth=request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_expired(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PENDING:\n            return Response(\n                {'detail': 'The order is not pending.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        mark_order_expired(\n            order,\n            user=request.user if request.user.is_authenticated else None,\n            auth=request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def mark_refunded(self, request, **kwargs):\n        order = self.get_object()\n\n        if order.status != Order.STATUS_PAID:\n            return Response(\n                {'detail': 'The order is not paid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        mark_order_refunded(\n            order,\n            user=request.user if request.user.is_authenticated else None,\n            auth=(request.auth if isinstance(request.auth, (TeamAPIToken, OAuthAccessToken, Device)) else None),\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def create_invoice(self, request, **kwargs):\n        order = self.get_object()\n        has_inv = order.invoices.exists() and not (\n            order.status in (Order.STATUS_PAID, Order.STATUS_PENDING)\n            and order.invoices.filter(is_cancellation=True).count() >= order.invoices.filter(is_cancellation=False).count()\n        )\n        if self.request.event.settings.get('invoice_generate') not in ('admin', 'user', 'paid', 'True') or not invoice_qualified(order):\n            return Response(\n                {'detail': _('You cannot generate an invoice for this order.')},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n        elif has_inv:\n            return Response(\n                {'detail': _('An invoice for this order already exists.')},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        inv = generate_invoice(order)\n        order.log_action(\n            'pretix.event.order.invoice.generated',\n            user=self.request.user,\n            auth=self.request.auth,\n            data={\n                'invoice': inv.pk\n            }\n        )\n        return Response(\n            InvoiceSerializer(inv).data,\n            status=status.HTTP_201_CREATED\n        )\n\n    @action(detail=True, methods=['POST'])\n    def resend_link(self, request, **kwargs):\n        order = self.get_object()\n        if not order.email:\n            return Response({'detail': 'There is no email address associated with this order.'}, status=status.HTTP_400_BAD_REQUEST)\n        try:\n            order.resend_link(user=self.request.user, auth=self.request.auth)\n        except SendMailException:\n            return Response({'detail': _('There was an error sending the mail. Please try again later.')}, status=status.HTTP_503_SERVICE_UNAVAILABLE)\n\n        return Response(\n            status=status.HTTP_204_NO_CONTENT\n        )\n\n    @action(detail=True, methods=['POST'])\n    @transaction.atomic\n    def regenerate_secrets(self, request, **kwargs):\n        order = self.get_object()\n        order.secret = generate_secret()\n        for op in order.all_positions.all():\n            assign_ticket_secret(\n                request.event, op, force_invalidate=True, save=True\n            )\n        order.save(update_fields=['secret'])\n        CachedTicket.objects.filter(order_position__order=order).delete()\n        CachedCombinedTicket.objects.filter(order=order).delete()\n        tickets.invalidate_cache.apply_async(kwargs={'event': self.request.event.pk,\n                                                     'order': order.pk})\n        order.log_action(\n            'pretix.event.order.secret.changed',\n            user=self.request.user,\n            auth=self.request.auth,\n        )\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def extend(self, request, **kwargs):\n        new_date = request.data.get('expires', None)\n        force = request.data.get('force', False)\n        if not new_date:\n            return Response(\n                {'detail': 'New date is missing.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        df = serializers.DateField()\n        try:\n            new_date = df.to_internal_value(new_date)\n        except:\n            return Response(\n                {'detail': 'New date is invalid.'},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n        tz = ZoneInfo(self.request.event.settings.timezone)\n        new_date = make_aware(datetime.datetime.combine(\n            new_date,\n            datetime.time(hour=23, minute=59, second=59)\n        ), tz)\n\n        order = self.get_object()\n\n        try:\n            extend_order(\n                order,\n                new_date=new_date,\n                force=force,\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth,\n            )\n            return self.retrieve(request, [], **kwargs)\n        except OrderError as e:\n            return Response(\n                {'detail': str(e)},\n                status=status.HTTP_400_BAD_REQUEST\n            )\n\n    def create(self, request, *args, **kwargs):\n        if 'send_mail' in request.data and 'send_email' not in request.data:\n            request.data['send_email'] = request.data['send_mail']\n        serializer = OrderCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            try:\n                self.perform_create(serializer)\n            except TaxRule.SaleNotAllowed:\n                raise ValidationError(_('One of the selected products is not available in the selected country.'))\n            send_mail = serializer._send_mail\n            order = serializer.instance\n\n            if not order.pk:\n                # Simulation -- exit here\n                serializer = SimulatedOrderSerializer(order, context=serializer.context)\n                return Response(serializer.data, status=status.HTTP_201_CREATED)\n\n            order.log_action(\n                'pretix.event.order.placed',\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth,\n            )\n\n        with language(order.locale, self.request.event.settings.region):\n            payment = order.payments.last()\n            # OrderCreateSerializer creates at most one payment\n            if payment and payment.state == OrderPayment.PAYMENT_STATE_CONFIRMED:\n                order.log_action(\n                    'pretix.event.order.payment.confirmed', {\n                        'local_id': payment.local_id,\n                        'provider': payment.provider,\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth,\n                )\n            order_placed.send(self.request.event, order=order)\n            if order.status == Order.STATUS_PAID:\n                order_paid.send(self.request.event, order=order)\n                order.log_action(\n                    'pretix.event.order.paid',\n                    {\n                        'provider': payment.provider if payment else None,\n                        'info': {},\n                        'date': now().isoformat(),\n                        'force': False\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth,\n                )\n\n            gen_invoice = invoice_qualified(order) and (\n                (order.event.settings.get('invoice_generate') == 'True') or\n                (order.event.settings.get('invoice_generate') == 'paid' and order.status == Order.STATUS_PAID)\n            ) and not order.invoices.last()\n            invoice = None\n            if gen_invoice:\n                invoice = generate_invoice(order, trigger_pdf=True)\n\n            # Refresh serializer only after running signals\n            prefetch_related_objects([order], self._positions_prefetch(request))\n            serializer = OrderSerializer(order, context=serializer.context)\n\n            if send_mail:\n                free_flow = (\n                    payment and order.total == Decimal('0.00') and order.status == Order.STATUS_PAID and\n                    not order.require_approval and payment.provider in (\"free\", \"boxoffice\")\n                )\n                if order.require_approval:\n                    email_template = request.event.settings.mail_text_order_placed_require_approval\n                    subject_template = request.event.settings.mail_subject_order_placed_require_approval\n                    log_entry = 'pretix.event.order.email.order_placed_require_approval'\n                    email_attendees = False\n                elif free_flow:\n                    email_template = request.event.settings.mail_text_order_free\n                    subject_template = request.event.settings.mail_subject_order_free\n                    log_entry = 'pretix.event.order.email.order_free'\n                    email_attendees = request.event.settings.mail_send_order_free_attendee\n                    email_attendees_template = request.event.settings.mail_text_order_free_attendee\n                    subject_attendees_template = request.event.settings.mail_subject_order_free_attendee\n                else:\n                    email_template = request.event.settings.mail_text_order_placed\n                    subject_template = request.event.settings.mail_subject_order_placed\n                    log_entry = 'pretix.event.order.email.order_placed'\n                    email_attendees = request.event.settings.mail_send_order_placed_attendee\n                    email_attendees_template = request.event.settings.mail_text_order_placed_attendee\n                    subject_attendees_template = request.event.settings.mail_subject_order_placed_attendee\n\n                _order_placed_email(\n                    request.event, order, email_template, subject_template,\n                    log_entry, invoice, [payment] if payment else [], is_free=free_flow\n                )\n                if email_attendees:\n                    for p in order.positions.all():\n                        if p.addon_to_id is None and p.attendee_email and p.attendee_email != order.email:\n                            _order_placed_email_attendee(request.event, order, p, email_attendees_template, subject_attendees_template,\n                                                         log_entry, is_free=free_flow)\n\n                if not free_flow and order.status == Order.STATUS_PAID and payment:\n                    payment._send_paid_mail(invoice, None, '')\n                    if self.request.event.settings.mail_send_order_paid_attendee:\n                        for p in order.positions.all():\n                            if p.addon_to_id is None and p.attendee_email and p.attendee_email != order.email:\n                                payment._send_paid_mail_attendee(p, None)\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.get('partial', False)\n        if not partial:\n            return Response(\n                {\"detail\": \"Method \\\"PUT\\\" not allowed.\"},\n                status=status.HTTP_405_METHOD_NOT_ALLOWED,\n            )\n        return super().update(request, *args, **kwargs)\n\n    def perform_update(self, serializer):\n        with transaction.atomic():\n            if 'comment' in self.request.data and serializer.instance.comment != self.request.data.get('comment'):\n                serializer.instance.log_action(\n                    'pretix.event.order.comment',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_comment': self.request.data.get('comment')\n                    }\n                )\n\n            if 'custom_followup_at' in self.request.data and serializer.instance.custom_followup_at != self.request.data.get('custom_followup_at'):\n                serializer.instance.log_action(\n                    'pretix.event.order.custom_followup_at',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_custom_followup_at': self.request.data.get('custom_followup_at')\n                    }\n                )\n\n            if 'checkin_attention' in self.request.data and serializer.instance.checkin_attention != self.request.data.get('checkin_attention'):\n                serializer.instance.log_action(\n                    'pretix.event.order.checkin_attention',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_value': self.request.data.get('checkin_attention')\n                    }\n                )\n\n            if 'valid_if_pending' in self.request.data and serializer.instance.valid_if_pending != self.request.data.get('valid_if_pending'):\n                serializer.instance.log_action(\n                    'pretix.event.order.valid_if_pending',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'new_value': self.request.data.get('valid_if_pending')\n                    }\n                )\n\n            if 'email' in self.request.data and serializer.instance.email != self.request.data.get('email'):\n                serializer.instance.email_known_to_work = False\n                serializer.instance.log_action(\n                    'pretix.event.order.contact.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_email': serializer.instance.email,\n                        'new_email': self.request.data.get('email'),\n                    }\n                )\n\n            if 'phone' in self.request.data and serializer.instance.phone != self.request.data.get('phone'):\n                serializer.instance.log_action(\n                    'pretix.event.order.phone.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_phone': serializer.instance.phone,\n                        'new_phone': self.request.data.get('phone'),\n                    }\n                )\n\n            if 'locale' in self.request.data and serializer.instance.locale != self.request.data.get('locale'):\n                serializer.instance.log_action(\n                    'pretix.event.order.locale.changed',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'old_locale': serializer.instance.locale,\n                        'new_locale': self.request.data.get('locale'),\n                    }\n                )\n\n            if 'invoice_address' in self.request.data:\n                serializer.instance.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'invoice_data': self.request.data.get('invoice_address'),\n                    }\n                )\n\n            serializer.save()\n            tickets.invalidate_cache.apply_async(kwargs={'event': serializer.instance.event.pk, 'order': serializer.instance.pk})\n\n        if 'invoice_address' in self.request.data:\n            order_modified.send(sender=serializer.instance.event, order=serializer.instance)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    def perform_destroy(self, instance):\n        if not instance.testmode:\n            raise PermissionDenied('Only test mode orders can be deleted.')\n\n        with transaction.atomic():\n            self.get_object().gracefully_delete(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n\n    @action(detail=True, methods=['POST'])\n    def change(self, request, **kwargs):\n        order = self.get_object()\n\n        serializer = OrderChangeOperationSerializer(\n            context={'order': order, **self.get_serializer_context()},\n            data=request.data,\n        )\n        serializer.is_valid(raise_exception=True)\n\n        try:\n            ocm = OrderChangeManager(\n                order=order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=serializer.validated_data.get('send_email', False),\n                reissue_invoice=serializer.validated_data.get('reissue_invoice', True),\n            )\n\n            canceled_positions = set()\n            for r in serializer.validated_data.get('cancel_positions', []):\n                ocm.cancel(r['position'])\n                canceled_positions.add(r['position'])\n\n            for r in serializer.validated_data.get('patch_positions', []):\n                if r['position'] in canceled_positions:\n                    continue\n                pos_serializer = OrderPositionChangeSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                    partial=True,\n                )\n                pos_serializer.update(r['position'], r['body'])\n\n            for r in serializer.validated_data.get('split_positions', []):\n                if r['position'] in canceled_positions:\n                    continue\n                ocm.split(r['position'])\n\n            for r in serializer.validated_data.get('create_positions', []):\n                pos_serializer = OrderPositionCreateForExistingOrderSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                )\n                pos_serializer.create(r)\n\n            canceled_fees = set()\n            for r in serializer.validated_data.get('cancel_fees', []):\n                ocm.cancel_fee(r['fee'])\n                canceled_fees.add(r['fee'])\n\n            for r in serializer.validated_data.get('patch_fees', []):\n                if r['fee'] in canceled_fees:\n                    continue\n                pos_serializer = OrderFeeChangeSerializer(\n                    context={'ocm': ocm, 'commit': False, 'event': request.event, **self.get_serializer_context()},\n                )\n                pos_serializer.update(r['fee'], r['body'])\n\n            if serializer.validated_data.get('recalculate_taxes') == 'keep_net':\n                ocm.recalculate_taxes(keep='net')\n            elif serializer.validated_data.get('recalculate_taxes') == 'keep_gross':\n                ocm.recalculate_taxes(keep='gross')\n\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n\n        order.refresh_from_db()\n        serializer = OrderSerializer(\n            instance=order,\n            context=self.get_serializer_context(),\n        )\n        return Response(serializer.data)\n\n\nwith scopes_disabled():\n    class OrderPositionFilter(FilterSet):\n        order = django_filters.CharFilter(field_name='order', lookup_expr='code__iexact')\n        has_checkin = django_filters.rest_framework.BooleanFilter(method='has_checkin_qs')\n        attendee_name = django_filters.CharFilter(method='attendee_name_qs')\n        search = django_filters.CharFilter(method='search_qs')\n\n        def search_qs(self, queryset, name, value):\n            matching_media = ReusableMedium.objects.filter(identifier=value).values_list('linked_orderposition', flat=True)\n            return queryset.filter(\n                Q(secret__istartswith=value)\n                | Q(attendee_name_cached__icontains=value)\n                | Q(addon_to__attendee_name_cached__icontains=value)\n                | Q(attendee_email__icontains=value)\n                | Q(addon_to__attendee_email__icontains=value)\n                | Q(order__code__istartswith=value)\n                | Q(order__invoice_address__name_cached__icontains=value)\n                | Q(order__invoice_address__company__icontains=value)\n                | Q(order__email__icontains=value)\n                | Q(pk__in=matching_media)\n            )\n\n        def has_checkin_qs(self, queryset, name, value):\n            return queryset.alias(ce=Exists(Checkin.objects.filter(position=OuterRef('pk')))).filter(ce=value)\n\n        def attendee_name_qs(self, queryset, name, value):\n            return queryset.filter(Q(attendee_name_cached__iexact=value) | Q(addon_to__attendee_name_cached__iexact=value))\n\n        class Meta:\n            model = OrderPosition\n            fields = {\n                'item': ['exact', 'in'],\n                'variation': ['exact', 'in'],\n                'secret': ['exact'],\n                'order__status': ['exact', 'in'],\n                'addon_to': ['exact', 'in'],\n                'subevent': ['exact', 'in'],\n                'pseudonymization_id': ['exact'],\n                'voucher__code': ['exact'],\n                'voucher': ['exact'],\n            }\n\n\nclass OrderPositionViewSet(viewsets.ModelViewSet):\n    serializer_class = OrderPositionSerializer\n    queryset = OrderPosition.all.none()\n    filter_backends = (DjangoFilterBackend, RichOrderingFilter)\n    ordering = ('order__datetime', 'positionid')\n    ordering_fields = ('order__code', 'order__datetime', 'positionid', 'attendee_name', 'order__status',)\n    filterset_class = OrderPositionFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    ordering_custom = {\n        'attendee_name': {\n            '_order': F('display_name').asc(nulls_first=True),\n            'display_name': Coalesce('attendee_name_cached', 'addon_to__attendee_name_cached')\n        },\n        '-attendee_name': {\n            '_order': F('display_name').asc(nulls_last=True),\n            'display_name': Coalesce('attendee_name_cached', 'addon_to__attendee_name_cached')\n        },\n    }\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['event'] = self.request.event\n        ctx['pdf_data'] = self.request.query_params.get('pdf_data', 'false') == 'true'\n        return ctx\n\n    def get_queryset(self):\n        if self.request.query_params.get('include_canceled_positions', 'false') == 'true':\n            qs = OrderPosition.all\n        else:\n            qs = OrderPosition.objects\n\n        qs = qs.filter(order__event=self.request.event)\n        if self.request.query_params.get('pdf_data', 'false') == 'true':\n            prefetch_related_objects([self.request.organizer], 'meta_properties')\n            prefetch_related_objects(\n                [self.request.event],\n                Prefetch('meta_values', queryset=EventMetaValue.objects.select_related('property'), to_attr='meta_values_cached'),\n                'questions',\n                'item_meta_properties',\n            )\n            qs = qs.prefetch_related(\n                Prefetch('checkins', queryset=Checkin.objects.all()),\n                Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                    Prefetch('meta_values', ItemMetaValue.objects.select_related('property'),\n                             to_attr='meta_values_cached')\n                )),\n                'variation',\n                'answers', 'answers__options', 'answers__question',\n                'item__category',\n                'addon_to__answers', 'addon_to__answers__options', 'addon_to__answers__question',\n                Prefetch('addons', qs.select_related('item', 'variation')),\n                Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                    Prefetch('meta_values', to_attr='meta_values_cached',\n                             queryset=SubEventMetaValue.objects.select_related('property'))\n                )),\n                'linked_media',\n                Prefetch('order', self.request.event.orders.select_related('invoice_address').prefetch_related(\n                    Prefetch(\n                        'positions',\n                        qs.prefetch_related(\n                            Prefetch('checkins', queryset=Checkin.objects.all()),\n                            Prefetch('item', queryset=self.request.event.items.prefetch_related(\n                                Prefetch('meta_values', ItemMetaValue.objects.select_related('property'),\n                                         to_attr='meta_values_cached')\n                            )),\n                            Prefetch('variation', queryset=self.request.event.items.prefetch_related(\n                                Prefetch('meta_values', ItemVariationMetaValue.objects.select_related('property'),\n                                         to_attr='meta_values_cached')\n                            )),\n                            'answers', 'answers__options', 'answers__question',\n                            'item__category',\n                            Prefetch('subevent', queryset=self.request.event.subevents.prefetch_related(\n                                Prefetch('meta_values', to_attr='meta_values_cached',\n                                         queryset=SubEventMetaValue.objects.select_related('property'))\n                            )),\n                            Prefetch('addons', qs.select_related('item', 'variation', 'seat'))\n                        ).select_related('addon_to', 'seat', 'addon_to__seat')\n                    )\n                ))\n            ).select_related(\n                'addon_to', 'seat', 'addon_to__seat'\n            )\n        else:\n            qs = qs.prefetch_related(\n                Prefetch('checkins', queryset=Checkin.objects.all()),\n                'answers', 'answers__options', 'answers__question',\n            ).select_related(\n                'item', 'order', 'order__event', 'order__event__organizer', 'seat'\n            )\n        return qs\n\n    def _get_output_provider(self, identifier):\n        responses = register_ticket_outputs.send(self.request.event)\n        for receiver, response in responses:\n            prov = response(self.request.event)\n            if prov.identifier == identifier:\n                return prov\n        raise NotFound('Unknown output provider.')\n\n    @action(detail=True, methods=['POST'], url_name='price_calc')\n    def price_calc(self, request, *args, **kwargs):\n        \"\"\"\n        This calculates the price assuming a change of product or subevent. This endpoint\n        is deliberately not documented and considered a private API, only to be used by\n        pretix' web interface.\n\n        Sample input:\n\n        {\n            \"item\": 2,\n            \"variation\": null,\n            \"subevent\": 3,\n            \"tax_rule\": 4,\n        }\n\n        Sample output:\n\n        {\n            \"gross\": \"2.34\",\n            \"gross_formatted\": \"2,34\",\n            \"net\": \"2.34\",\n            \"tax\": \"0.00\",\n            \"rate\": \"0.00\",\n            \"name\": \"VAT\"\n        }\n        \"\"\"\n        serializer = PriceCalcSerializer(data=request.data, event=request.event)\n        serializer.is_valid(raise_exception=True)\n        data = serializer.validated_data\n        pos = self.get_object()\n\n        try:\n            ia = pos.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = InvoiceAddress()\n\n        kwargs = {\n            'item': pos.item,\n            'variation': pos.variation,\n            'voucher': pos.voucher,\n            'subevent': pos.subevent,\n            'addon_to': pos.addon_to,\n            'invoice_address': ia,\n        }\n\n        if data.get('item'):\n            item = data.get('item')\n            kwargs['item'] = item\n\n            if item.has_variations:\n                variation = data.get('variation') or pos.variation\n                if not variation:\n                    raise ValidationError('No variation given')\n                if variation.item != item:\n                    raise ValidationError('Variation does not belong to item')\n                kwargs['variation'] = variation\n            else:\n                variation = None\n                kwargs['variation'] = None\n\n            if pos.voucher and not pos.voucher.applies_to(item, variation):\n                kwargs['voucher'] = None\n\n        if data.get('subevent'):\n            kwargs['subevent'] = data.get('subevent')\n\n        if data.get('tax_rule'):\n            kwargs['tax_rule'] = data.get('tax_rule')\n\n        price = get_price(**kwargs)\n        tr = kwargs.get('tax_rule', kwargs.get('item').tax_rule)\n        with language(data.get('locale') or self.request.event.settings.locale, self.request.event.settings.region):\n            return Response({\n                'gross': price.gross,\n                'gross_formatted': money_filter(price.gross, self.request.event.currency, hide_currency=True),\n                'net': price.net,\n                'rate': price.rate,\n                'name': str(price.name),\n                'tax': price.tax,\n                'tax_rule': tr.pk if tr else None,\n            })\n\n    @action(detail=True, url_name='answer', url_path=r'answer/(?P<question>\\d+)')\n    def answer(self, request, **kwargs):\n        pos = self.get_object()\n        answer = get_object_or_404(\n            QuestionAnswer,\n            orderposition=self.get_object(),\n            question_id=kwargs.get('question')\n        )\n        if not answer.file:\n            raise NotFound()\n\n        ftype, ignored = mimetypes.guess_type(answer.file.name)\n        resp = FileResponse(answer.file, content_type=ftype or 'application/binary')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}\"'.format(\n            self.request.event.slug.upper(),\n            pos.order.code,\n            pos.positionid,\n            os.path.basename(answer.file.name).split('.', 1)[1]\n        )\n        return resp\n\n    @action(detail=True, url_name='pdf_image', url_path=r'pdf_image/(?P<key>[^/]+)')\n    def pdf_image(self, request, key, **kwargs):\n        pos = self.get_object()\n\n        image_vars = get_images(request.event)\n        if key not in image_vars:\n            raise NotFound('Unknown key')\n\n        image_file = image_vars[key]['evaluate'](pos, pos.order, pos.subevent or self.request.event)\n        if image_file is None:\n            raise NotFound('No image available')\n\n        if getattr(image_file, 'name', ''):\n            ftype, ignored = mimetypes.guess_type(image_file.name)\n            extension = os.path.basename(image_file.name).split('.')[-1]\n        else:\n            img = Image.open(image_file, formats=settings.PILLOW_FORMATS_QUESTIONS_IMAGE)\n            ftype = Image.MIME[img.format]\n            extensions = {\n                'GIF': 'gif', 'TIFF': 'tif', 'BMP': 'bmp', 'JPEG': 'jpg', 'PNG': 'png'\n            }\n            extension = extensions.get(img.format, 'bin')\n            if hasattr(image_file, 'seek'):\n                image_file.seek(0)\n\n        resp = FileResponse(image_file, content_type=ftype or 'application/binary')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}.{}\"'.format(\n            self.request.event.slug.upper(),\n            pos.order.code,\n            pos.positionid,\n            key,\n            extension,\n        )\n        return resp\n\n    @action(detail=True, url_name='download', url_path='download/(?P<output>[^/]+)')\n    def download(self, request, output, **kwargs):\n        provider = self._get_output_provider(output)\n        pos = self.get_object()\n\n        if pos.order.status in (Order.STATUS_CANCELED, Order.STATUS_EXPIRED):\n            raise PermissionDenied(\"Downloads are not available for canceled or expired orders.\")\n\n        if pos.order.status == Order.STATUS_PENDING and not (pos.order.valid_if_pending or request.event.settings.ticket_download_pending):\n            raise PermissionDenied(\"Downloads are not available for pending orders.\")\n        if not pos.generate_ticket:\n            raise PermissionDenied(\"Downloads are not enabled for this product.\")\n\n        ct = CachedTicket.objects.filter(\n            order_position=pos, provider=provider.identifier, file__isnull=False\n        ).last()\n        if not ct or not ct.file:\n            generate.apply_async(args=('orderposition', pos.pk, provider.identifier))\n            raise RetryException()\n        else:\n            if ct.type == 'text/uri-list':\n                resp = HttpResponse(ct.file.file.read(), content_type='text/uri-list')\n                return resp\n            else:\n                resp = FileResponse(ct.file.file, content_type=ct.type)\n                resp['Content-Disposition'] = 'attachment; filename=\"{}-{}-{}-{}{}\"'.format(\n                    self.request.event.slug.upper(), pos.order.code, pos.positionid,\n                    provider.identifier, ct.extension\n                )\n                return resp\n\n    @action(detail=True, methods=['POST'])\n    def regenerate_secrets(self, request, **kwargs):\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.regenerate_secret(instance)\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def add_block(self, request, **kwargs):\n        serializer = BlockNameSerializer(\n            data=request.data,\n            context=self.get_serializer_context(),\n        )\n        serializer.is_valid(raise_exception=True)\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.add_block(instance, serializer.validated_data['name'])\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def remove_block(self, request, **kwargs):\n        serializer = BlockNameSerializer(\n            data=request.data,\n            context=self.get_serializer_context(),\n        )\n        serializer.is_valid(raise_exception=True)\n        instance = self.get_object()\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            ocm.remove_block(instance, serializer.validated_data['name'])\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n        return self.retrieve(request, [], **kwargs)\n\n    def perform_destroy(self, instance):\n        try:\n            ocm = OrderChangeManager(\n                instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=self.request.auth,\n                notify=False\n            )\n            ocm.cancel(instance)\n            ocm.commit()\n        except OrderError as e:\n            raise ValidationError(str(e))\n        except Quota.QuotaExceededException as e:\n            raise ValidationError(str(e))\n\n    def create(self, request, *args, **kwargs):\n        with transaction.atomic():\n            serializer = OrderPositionCreateForExistingOrderSerializer(\n                data=request.data,\n                context=self.get_serializer_context(),\n            )\n            serializer.is_valid(raise_exception=True)\n            order = serializer.validated_data['order']\n            ocm = OrderChangeManager(\n                order=order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n            serializer.context['ocm'] = ocm\n            serializer.save()\n\n            # Fields that can be easily patched after the position was added\n            old_data = OrderPositionInfoPatchSerializer(instance=serializer.instance, context=self.get_serializer_context()).data\n            serializer = OrderPositionInfoPatchSerializer(\n                instance=serializer.instance,\n                context=self.get_serializer_context(),\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            new_data = serializer.data\n\n            if old_data != new_data:\n                log_data = self.request.data\n                if 'answers' in log_data:\n                    for a in new_data['answers']:\n                        log_data[f'question_{a[\"question\"]}'] = a[\"answer\"]\n                    log_data.pop('answers', None)\n                serializer.instance.order.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'data': [\n                            dict(\n                                position=serializer.instance.pk,\n                                **log_data\n                            )\n                        ]\n                    }\n                )\n                tickets.invalidate_cache.apply_async(\n                    kwargs={'event': serializer.instance.order.event.pk, 'order': serializer.instance.order.pk})\n                order_modified.send(sender=serializer.instance.order.event, order=serializer.instance.order)\n        return Response(\n            OrderPositionSerializer(serializer.instance, context=self.get_serializer_context()).data,\n            status=status.HTTP_201_CREATED,\n        )\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.get('partial', False)\n        if not partial:\n            return Response(\n                {\"detail\": \"Method \\\"PUT\\\" not allowed.\"},\n                status=status.HTTP_405_METHOD_NOT_ALLOWED,\n            )\n\n        with transaction.atomic():\n            instance = self.get_object()\n            ocm = OrderChangeManager(\n                order=instance.order,\n                user=self.request.user if self.request.user.is_authenticated else None,\n                auth=request.auth,\n                notify=False,\n                reissue_invoice=False,\n            )\n\n            # Field that need to go through OrderChangeManager\n            serializer = OrderPositionChangeSerializer(\n                instance=instance,\n                context={'ocm': ocm, **self.get_serializer_context()},\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n\n            # Fields that can be easily patched\n            old_data = OrderPositionInfoPatchSerializer(instance=instance, context=self.get_serializer_context()).data\n            serializer = OrderPositionInfoPatchSerializer(\n                instance=instance,\n                context=self.get_serializer_context(),\n                partial=True,\n                data=request.data\n            )\n            serializer.is_valid(raise_exception=True)\n            serializer.save()\n            new_data = serializer.data\n\n            if old_data != new_data:\n                log_data = self.request.data\n                if 'answers' in log_data:\n                    for a in new_data['answers']:\n                        log_data[f'question_{a[\"question\"]}'] = a[\"answer\"]\n                    log_data.pop('answers', None)\n                serializer.instance.order.log_action(\n                    'pretix.event.order.modified',\n                    user=self.request.user,\n                    auth=self.request.auth,\n                    data={\n                        'data': [\n                            dict(\n                                position=serializer.instance.pk,\n                                **log_data\n                            )\n                        ]\n                    }\n                )\n                tickets.invalidate_cache.apply_async(kwargs={'event': serializer.instance.order.event.pk, 'order': serializer.instance.order.pk})\n                order_modified.send(sender=serializer.instance.order.event, order=serializer.instance.order)\n\n        return Response(self.get_serializer_class()(instance=serializer.instance, context=self.get_serializer_context()).data)\n\n\nclass PaymentViewSet(CreateModelMixin, viewsets.ReadOnlyModelViewSet):\n    serializer_class = OrderPaymentSerializer\n    queryset = OrderPayment.objects.none()\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    lookup_field = 'local_id'\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['order'] = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        ctx['event'] = self.request.event\n        return ctx\n\n    def get_queryset(self):\n        order = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return order.payments.all()\n\n    def create(self, request, *args, **kwargs):\n        send_mail = request.data.get('send_email', True) if request.data else True\n        serializer = OrderPaymentCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            mark_confirmed = False\n            if serializer.validated_data['state'] == OrderPayment.PAYMENT_STATE_CONFIRMED:\n                serializer.validated_data['state'] = OrderPayment.PAYMENT_STATE_PENDING\n                mark_confirmed = True\n            self.perform_create(serializer)\n            r = serializer.instance\n            if mark_confirmed:\n                try:\n                    r.confirm(\n                        user=self.request.user if self.request.user.is_authenticated else None,\n                        auth=self.request.auth,\n                        count_waitinglist=False,\n                        force=request.data.get('force', False),\n                        send_mail=send_mail,\n                    )\n                except Quota.QuotaExceededException:\n                    pass\n                except SendMailException:\n                    pass\n\n            serializer = OrderPaymentSerializer(r, context=serializer.context)\n\n            r.order.log_action(\n                'pretix.event.order.payment.started', {\n                    'local_id': r.local_id,\n                    'provider': r.provider,\n                },\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth\n            )\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n    @action(detail=True, methods=['POST'])\n    def confirm(self, request, **kwargs):\n        payment = self.get_object()\n        force = request.data.get('force', False)\n        send_mail = request.data.get('send_email', True) if request.data else True\n\n        if payment.state not in (OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED):\n            return Response({'detail': 'Invalid state of payment'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            payment.confirm(user=self.request.user if self.request.user.is_authenticated else None,\n                            auth=self.request.auth,\n                            count_waitinglist=False,\n                            send_mail=send_mail,\n                            force=force)\n        except Quota.QuotaExceededException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except PaymentException as e:\n            return Response({'detail': str(e)}, status=status.HTTP_400_BAD_REQUEST)\n        except SendMailException:\n            pass\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def refund(self, request, **kwargs):\n        payment = self.get_object()\n        amount = serializers.DecimalField(max_digits=13, decimal_places=2).to_internal_value(\n            request.data.get('amount', str(payment.amount))\n        )\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.get('mark_refunded', False)\n        else:\n            mark_refunded = request.data.get('mark_canceled', False)\n\n        if payment.state != OrderPayment.PAYMENT_STATE_CONFIRMED:\n            return Response({'detail': 'Invalid state of payment.'}, status=status.HTTP_400_BAD_REQUEST)\n\n        full_refund_possible = payment.payment_provider.payment_refund_supported(payment)\n        partial_refund_possible = payment.payment_provider.payment_partial_refund_supported(payment)\n        available_amount = payment.amount - payment.refunded_amount\n\n        if amount <= 0:\n            return Response({'amount': ['Invalid refund amount.']}, status=status.HTTP_400_BAD_REQUEST)\n        if amount > available_amount:\n            return Response(\n                {'amount': ['Invalid refund amount, only {} are available to refund.'.format(available_amount)]},\n                status=status.HTTP_400_BAD_REQUEST)\n        if amount != payment.amount and not partial_refund_possible:\n            return Response({'amount': ['Partial refund not available for this payment method.']},\n                            status=status.HTTP_400_BAD_REQUEST)\n        if amount == payment.amount and not full_refund_possible:\n            return Response({'amount': ['Full refund not available for this payment method.']},\n                            status=status.HTTP_400_BAD_REQUEST)\n        r = payment.order.refunds.create(\n            payment=payment,\n            source=OrderRefund.REFUND_SOURCE_ADMIN,\n            state=OrderRefund.REFUND_STATE_CREATED,\n            amount=amount,\n            provider=payment.provider,\n            info='{}',\n        )\n        payment.order.log_action('pretix.event.order.refund.created', {\n            'local_id': r.local_id,\n            'provider': r.provider,\n        }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n\n        try:\n            r.payment_provider.execute_refund(r)\n        except PaymentException as e:\n            r.state = OrderRefund.REFUND_STATE_FAILED\n            r.save()\n            payment.order.log_action('pretix.event.order.refund.failed', {\n                'local_id': r.local_id,\n                'provider': r.provider,\n                'error': str(e)\n            })\n            return Response({'detail': 'External error: {}'.format(str(e))},\n                            status=status.HTTP_400_BAD_REQUEST)\n        else:\n            if payment.order.pending_sum > 0:\n                if mark_refunded:\n                    mark_order_refunded(payment.order,\n                                        user=self.request.user if self.request.user.is_authenticated else None,\n                                        auth=self.request.auth)\n                else:\n                    payment.order.status = Order.STATUS_PENDING\n                    payment.order.set_expires(\n                        now(),\n                        payment.order.event.subevents.filter(\n                            id__in=payment.order.positions.values_list('subevent_id', flat=True))\n                    )\n                    payment.order.save(update_fields=['status', 'expires'])\n            return Response(OrderRefundSerializer(r).data, status=status.HTTP_200_OK)\n\n    @action(detail=True, methods=['POST'])\n    def cancel(self, request, **kwargs):\n        payment = self.get_object()\n\n        if payment.state not in (OrderPayment.PAYMENT_STATE_PENDING, OrderPayment.PAYMENT_STATE_CREATED):\n            return Response({'detail': 'Invalid state of payment'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            with transaction.atomic():\n                payment.payment_provider.cancel_payment(payment)\n                payment.order.log_action('pretix.event.order.payment.canceled', {\n                    'local_id': payment.local_id,\n                    'provider': payment.provider,\n                }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        except PaymentException as e:\n            return Response({'detail': 'External error: {}'.format(str(e))},\n                            status=status.HTTP_400_BAD_REQUEST)\n        return self.retrieve(request, [], **kwargs)\n\n\nclass RefundViewSet(CreateModelMixin, viewsets.ReadOnlyModelViewSet):\n    serializer_class = OrderRefundSerializer\n    queryset = OrderRefund.objects.none()\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n    lookup_field = 'local_id'\n\n    def get_queryset(self):\n        order = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return order.refunds.all()\n\n    @action(detail=True, methods=['POST'])\n    def cancel(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state not in (OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT,\n                                OrderRefund.REFUND_STATE_EXTERNAL):\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        with transaction.atomic():\n            refund.state = OrderRefund.REFUND_STATE_CANCELED\n            refund.save()\n            refund.order.log_action('pretix.event.order.refund.canceled', {\n                'local_id': refund.local_id,\n                'provider': refund.provider,\n            }, user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def process(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state != OrderRefund.REFUND_STATE_EXTERNAL:\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        refund.done(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.get('mark_refunded', False)\n        else:\n            mark_refunded = request.data.get('mark_canceled', False)\n        if mark_refunded:\n            mark_order_refunded(refund.order, user=self.request.user if self.request.user.is_authenticated else None,\n                                auth=self.request.auth)\n        elif not (refund.order.status == Order.STATUS_PAID and refund.order.pending_sum <= 0):\n            refund.order.status = Order.STATUS_PENDING\n            refund.order.set_expires(\n                now(),\n                refund.order.event.subevents.filter(\n                    id__in=refund.order.positions.values_list('subevent_id', flat=True))\n            )\n            refund.order.save(update_fields=['status', 'expires'])\n        return self.retrieve(request, [], **kwargs)\n\n    @action(detail=True, methods=['POST'])\n    def done(self, request, **kwargs):\n        refund = self.get_object()\n\n        if refund.state not in (OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT):\n            return Response({'detail': 'Invalid state of refund'}, status=status.HTTP_400_BAD_REQUEST)\n\n        refund.done(user=self.request.user if self.request.user.is_authenticated else None, auth=self.request.auth)\n        return self.retrieve(request, [], **kwargs)\n\n    def get_serializer_context(self):\n        ctx = super().get_serializer_context()\n        ctx['order'] = get_object_or_404(Order, code=self.kwargs['order'], event=self.request.event)\n        return ctx\n\n    def create(self, request, *args, **kwargs):\n        if 'mark_refunded' in request.data:\n            mark_refunded = request.data.pop('mark_refunded', False)\n        else:\n            mark_refunded = request.data.pop('mark_canceled', False)\n        mark_pending = request.data.pop('mark_pending', False)\n        serializer = OrderRefundCreateSerializer(data=request.data, context=self.get_serializer_context())\n        serializer.is_valid(raise_exception=True)\n        with transaction.atomic():\n            self.perform_create(serializer)\n            r = serializer.instance\n            serializer = OrderRefundSerializer(r, context=serializer.context)\n\n            r.order.log_action(\n                'pretix.event.order.refund.created', {\n                    'local_id': r.local_id,\n                    'provider': r.provider,\n                },\n                user=request.user if request.user.is_authenticated else None,\n                auth=request.auth\n            )\n\n            if r.state in (OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_CANCELED, OrderRefund.REFUND_STATE_FAILED):\n                r.order.log_action(\n                    f'pretix.event.order.refund.{r.state}', {\n                        'local_id': r.local_id,\n                        'provider': r.provider,\n                    },\n                    user=request.user if request.user.is_authenticated else None,\n                    auth=request.auth\n                )\n\n            if mark_refunded:\n                try:\n                    mark_order_refunded(\n                        r.order,\n                        user=request.user if request.user.is_authenticated else None,\n                        auth=(request.auth if request.auth else None),\n                    )\n                except OrderError as e:\n                    raise ValidationError(str(e))\n            elif mark_pending:\n                if r.order.status == Order.STATUS_PAID and r.order.pending_sum > 0:\n                    r.order.status = Order.STATUS_PENDING\n                    r.order.set_expires(\n                        now(),\n                        r.order.event.subevents.filter(\n                            id__in=r.order.positions.values_list('subevent_id', flat=True))\n                    )\n                    r.order.save(update_fields=['status', 'expires'])\n\n        headers = self.get_success_headers(serializer.data)\n        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)\n\n    def perform_create(self, serializer):\n        serializer.save()\n\n\nwith scopes_disabled():\n    class InvoiceFilter(FilterSet):\n        refers = django_filters.CharFilter(method='refers_qs')\n        number = django_filters.CharFilter(method='nr_qs')\n        order = django_filters.CharFilter(field_name='order', lookup_expr='code__iexact')\n\n        def refers_qs(self, queryset, name, value):\n            return queryset.annotate(\n                refers_nr=Concat('refers__prefix', 'refers__invoice_no')\n            ).filter(refers_nr__iexact=value)\n\n        def nr_qs(self, queryset, name, value):\n            return queryset.filter(nr__iexact=value)\n\n        class Meta:\n            model = Invoice\n            fields = ['order', 'number', 'is_cancellation', 'refers', 'locale']\n\n\nclass RetryException(APIException):\n    status_code = 409\n    default_detail = 'The requested resource is not ready, please retry later.'\n    default_code = 'retry_later'\n\n\nclass InvoiceViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = InvoiceSerializer\n    queryset = Invoice.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('nr',)\n    ordering_fields = ('nr', 'date')\n    filterset_class = InvoiceFilter\n    permission = 'can_view_orders'\n    lookup_url_kwarg = 'number'\n    lookup_field = 'nr'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return self.request.event.invoices.prefetch_related('lines').select_related('order', 'refers').annotate(\n            nr=Concat('prefix', 'invoice_no')\n        )\n\n    @action(detail=True, )\n    def download(self, request, **kwargs):\n        invoice = self.get_object()\n\n        if not invoice.file:\n            invoice_pdf(invoice.pk)\n            invoice.refresh_from_db()\n\n        if invoice.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n\n        if not invoice.file:\n            raise RetryException()\n\n        resp = FileResponse(invoice.file.file, content_type='application/pdf')\n        resp['Content-Disposition'] = 'attachment; filename=\"{}.pdf\"'.format(invoice.number)\n        return resp\n\n    @action(detail=True, methods=['POST'])\n    def regenerate(self, request, **kwarts):\n        inv = self.get_object()\n        if inv.canceled:\n            raise ValidationError('The invoice has already been canceled.')\n        if not inv.event.settings.invoice_regenerate_allowed:\n            raise PermissionDenied('Invoices may not be changed after they are created.')\n        elif inv.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n        elif inv.sent_to_organizer:\n            raise PermissionDenied('The invoice file has already been exported.')\n        elif now().astimezone(self.request.event.timezone).date() - inv.date > datetime.timedelta(days=1):\n            raise PermissionDenied('The invoice file is too old to be regenerated.')\n        else:\n            inv = regenerate_invoice(inv)\n            inv.order.log_action(\n                'pretix.event.order.invoice.regenerated',\n                data={\n                    'invoice': inv.pk\n                },\n                user=self.request.user,\n                auth=self.request.auth,\n            )\n            return Response(status=204)\n\n    @action(detail=True, methods=['POST'])\n    def reissue(self, request, **kwarts):\n        inv = self.get_object()\n        if inv.canceled:\n            raise ValidationError('The invoice has already been canceled.')\n        elif inv.shredded:\n            raise PermissionDenied('The invoice file is no longer stored on the server.')\n        else:\n            c = generate_cancellation(inv)\n            if inv.order.status != Order.STATUS_CANCELED:\n                inv = generate_invoice(inv.order)\n            else:\n                inv = c\n            inv.order.log_action(\n                'pretix.event.order.invoice.reissued',\n                data={\n                    'invoice': inv.pk\n                },\n                user=self.request.user,\n                auth=self.request.auth,\n            )\n            return Response(status=204)\n\n\nwith scopes_disabled():\n    class RevokedSecretFilter(FilterSet):\n        created_since = django_filters.IsoDateTimeFilter(field_name='created', lookup_expr='gte')\n\n        class Meta:\n            model = RevokedTicketSecret\n            fields = []\n\n\nclass RevokedSecretViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = RevokedTicketSecretSerializer\n    queryset = RevokedTicketSecret.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('-created',)\n    ordering_fields = ('created', 'secret')\n    filterset_class = RevokedSecretFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return RevokedTicketSecret.objects.filter(event=self.request.event)\n\n\nwith scopes_disabled():\n    class BlockedSecretFilter(FilterSet):\n        updated_since = django_filters.IsoDateTimeFilter(field_name='updated', lookup_expr='gte')\n\n        class Meta:\n            model = BlockedTicketSecret\n            fields = ['blocked']\n\n\nclass BlockedSecretViewSet(viewsets.ReadOnlyModelViewSet):\n    serializer_class = BlockedTicketSecretSerializer\n    queryset = BlockedTicketSecret.objects.none()\n    filter_backends = (DjangoFilterBackend, TotalOrderingFilter)\n    ordering = ('-updated', '-pk')\n    filterset_class = BlockedSecretFilter\n    permission = 'can_view_orders'\n    write_permission = 'can_change_orders'\n\n    def get_queryset(self):\n        return BlockedTicketSecret.objects.filter(event=self.request.event)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Andreas Teuber, Flavia Bastos\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport json\nimport logging\nfrom datetime import timedelta\nfrom decimal import Decimal\nfrom io import BytesIO\nfrom zoneinfo import ZoneInfo\n\nimport dateutil.parser\nimport pycountry\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.gis.geoip2 import GeoIP2\nfrom django.core.exceptions import ValidationError\nfrom django.core.files.uploadedfile import SimpleUploadedFile\nfrom django.core.validators import (\n    MaxValueValidator, MinValueValidator, RegexValidator,\n)\nfrom django.db.models import QuerySet\nfrom django.forms import Select, widgets\nfrom django.forms.widgets import FILE_INPUT_CONTRADICTION\nfrom django.utils.formats import date_format\nfrom django.utils.html import escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import get_current_timezone, now\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_countries import countries\nfrom django_countries.fields import Country, CountryField\nfrom geoip2.errors import AddressNotFoundError\nfrom phonenumber_field.formfields import PhoneNumberField\nfrom phonenumber_field.phonenumber import PhoneNumber\nfrom phonenumber_field.widgets import PhoneNumberPrefixWidget\nfrom phonenumbers import NumberParseException, national_significant_number\nfrom phonenumbers.data import _COUNTRY_CODE_TO_REGION_CODE\nfrom PIL import ImageOps\n\nfrom pretix.base.forms.widgets import (\n    BusinessBooleanRadio, DatePickerWidget, SplitDateTimePickerWidget,\n    TimePickerWidget, UploadedFileWidget,\n)\nfrom pretix.base.i18n import (\n    get_babel_locale, get_language_without_region, language,\n)\nfrom pretix.base.models import InvoiceAddress, Item, Question, QuestionOption\nfrom pretix.base.models.tax import VAT_ID_COUNTRIES, ask_for_vat_id\nfrom pretix.base.services.tax import (\n    VATIDFinalError, VATIDTemporaryError, validate_vat_id,\n)\nfrom pretix.base.settings import (\n    COUNTRIES_WITH_STATE_IN_ADDRESS, PERSON_NAME_SALUTATIONS,\n    PERSON_NAME_SCHEMES, PERSON_NAME_TITLE_GROUPS,\n)\nfrom pretix.base.templatetags.rich_text import rich_text\nfrom pretix.control.forms import (\n    ExtFileField, ExtValidationMixin, SizeValidationMixin, SplitDateTimeField,\n)\nfrom pretix.helpers.countries import (\n    CachedCountries, get_phone_prefixes_sorted_and_localized,\n)\nfrom pretix.helpers.escapejson import escapejson_attr\nfrom pretix.helpers.http import get_client_ip\nfrom pretix.helpers.i18n import get_format_without_seconds\nfrom pretix.presale.signals import question_form_fields\n\nlogger = logging.getLogger(__name__)\n\n\nREQUIRED_NAME_PARTS = ['salutation', 'given_name', 'family_name', 'full_name']\n\n\nclass NamePartsWidget(forms.MultiWidget):\n    widget = forms.TextInput\n    autofill_map = {\n        'given_name': 'given-name',\n        'family_name': 'family-name',\n        'middle_name': 'additional-name',\n        'title': 'honorific-prefix',\n        'full_name': 'name',\n        'calling_name': 'nickname',\n    }\n\n    def __init__(self, scheme: dict, field: forms.Field, attrs=None, titles: list=None):\n        widgets = []\n        self.scheme = scheme\n        self.field = field\n        self.titles = titles\n        for fname, label, size in self.scheme['fields']:\n            a = copy.copy(attrs) or {}\n            a['data-fname'] = fname\n            if fname == 'title' and self.titles:\n                widgets.append(Select(attrs=a, choices=[('', '')] + [(d, d) for d in self.titles[1]]))\n            elif fname == 'salutation':\n                widgets.append(Select(attrs=a, choices=[('', '---')] + PERSON_NAME_SALUTATIONS))\n            else:\n                widgets.append(self.widget(attrs=a))\n        super().__init__(widgets, attrs)\n\n    def decompress(self, value):\n        if value is None:\n            return None\n        data = []\n        for i, field in enumerate(self.scheme['fields']):\n            fname, label, size = field\n            data.append(value.get(fname, \"\"))\n        if '_legacy' in value and not data[-1]:\n            data[-1] = value.get('_legacy', '')\n        elif not any(d for d in data) and '_scheme' in value:\n            scheme = PERSON_NAME_SCHEMES[value['_scheme']]\n            data[-1] = scheme['concatenation'](value).strip()\n\n        return data\n\n    def render(self, name: str, value, attrs=None, renderer=None) -> str:\n        if not isinstance(value, list):\n            value = self.decompress(value)\n        output = []\n        final_attrs = self.build_attrs(attrs or {})\n        if 'required' in final_attrs:\n            del final_attrs['required']\n        id_ = final_attrs.get('id', None)\n        for i, widget in enumerate(self.widgets):\n            try:\n                widget_value = value[i]\n            except (IndexError, TypeError):\n                widget_value = None\n            if id_:\n                these_attrs = dict(\n                    final_attrs,\n                    id='%s_%s' % (id_, i),\n                    title=self.scheme['fields'][i][1],\n                )\n                if not isinstance(widget, widgets.Select):\n                    these_attrs['placeholder'] = self.scheme['fields'][i][1]\n                if self.scheme['fields'][i][0] in REQUIRED_NAME_PARTS:\n                    if self.field.required:\n                        these_attrs['required'] = 'required'\n                    these_attrs.pop('data-no-required-attr', None)\n                these_attrs['autocomplete'] = (self.attrs.get('autocomplete', '') + ' ' + self.autofill_map.get(self.scheme['fields'][i][0], 'off')).strip()\n                these_attrs['data-size'] = self.scheme['fields'][i][2]\n                if len(self.widgets) > 1:\n                    these_attrs['aria-label'] = self.scheme['fields'][i][1]\n            else:\n                these_attrs = final_attrs\n            output.append(widget.render(name + '_%s' % i, widget_value, these_attrs, renderer=renderer))\n        return mark_safe(self.format_output(output))\n\n    def format_output(self, rendered_widgets) -> str:\n        return '<div class=\"nameparts-form-group\">%s</div>' % ''.join(rendered_widgets)\n\n\nclass NamePartsFormField(forms.MultiValueField):\n    widget = NamePartsWidget\n\n    def compress(self, data_list) -> dict:\n        data = {}\n        data['_scheme'] = self.scheme_name\n        for i, value in enumerate(data_list):\n            data[self.scheme['fields'][i][0]] = value or ''\n        return data\n\n    def __init__(self, *args, **kwargs):\n        fields = []\n        defaults = {\n            'widget': self.widget,\n            'max_length': kwargs.pop('max_length', None),\n            'validators': [\n                RegexValidator(\n                    # The following characters should never appear in a name anywhere of\n                    # the world. However, they commonly appear in inputs generated by spam\n                    # bots.\n                    r'^[^$\u20ac/%\u00a7{}<>~]*$',\n                    message=_('Please do not use special characters in names.')\n                )\n            ]\n        }\n        self.scheme_name = kwargs.pop('scheme')\n        self.titles = kwargs.pop('titles')\n        self.scheme = PERSON_NAME_SCHEMES.get(self.scheme_name)\n        if self.titles:\n            self.scheme_titles = PERSON_NAME_TITLE_GROUPS.get(self.titles)\n        else:\n            self.scheme_titles = None\n        self.one_required = kwargs.get('required', True)\n        require_all_fields = kwargs.pop('require_all_fields', False)\n        kwargs['required'] = False\n        kwargs['widget'] = (kwargs.get('widget') or self.widget)(\n            scheme=self.scheme, titles=self.scheme_titles, field=self, **kwargs.pop('widget_kwargs', {})\n        )\n        defaults.update(**kwargs)\n        for fname, label, size in self.scheme['fields']:\n            defaults['label'] = label\n            if fname == 'title' and self.scheme_titles:\n                d = dict(defaults)\n                d.pop('max_length', None)\n                d.pop('validators', None)\n                field = forms.ChoiceField(\n                    **d,\n                    choices=[('', '')] + [(d, d) for d in self.scheme_titles[1]]\n                )\n\n            elif fname == 'salutation':\n                d = dict(defaults)\n                d.pop('max_length', None)\n                d.pop('validators', None)\n                field = forms.ChoiceField(\n                    **d,\n                    choices=[('', '---')] + PERSON_NAME_SALUTATIONS\n                )\n            else:\n                field = forms.CharField(**defaults)\n            field.part_name = fname\n            fields.append(field)\n        super().__init__(\n            fields=fields, require_all_fields=False, *args, **kwargs\n        )\n        self.require_all_fields = require_all_fields\n        self.required = self.one_required\n\n    def clean(self, value) -> dict:\n        value = super().clean(value)\n        if self.one_required and (not value or not any(v for v in value.values())):\n            raise forms.ValidationError(self.error_messages['required'], code='required')\n        if self.one_required:\n            for k, label, size in self.scheme['fields']:\n                if k in REQUIRED_NAME_PARTS and not value.get(k):\n                    raise forms.ValidationError(self.error_messages['required'], code='required')\n        if self.require_all_fields and not all(v for v in value):\n            raise forms.ValidationError(self.error_messages['incomplete'], code='required')\n\n        if sum(len(v) for v in value.values() if v) > 250:\n            raise forms.ValidationError(_('Please enter a shorter name.'), code='max_length')\n\n        return value\n\n\nclass WrappedPhonePrefixSelect(Select):\n    initial = None\n\n    def __init__(self, initial=None):\n        choices = [(\"\", \"---------\")]\n\n        if initial:\n            for prefix, values in _COUNTRY_CODE_TO_REGION_CODE.items():\n                if initial in values:\n                    self.initial = \"+%d\" % prefix\n                    break\n        choices += get_phone_prefixes_sorted_and_localized()\n        super().__init__(choices=choices, attrs={'aria-label': pgettext_lazy('phonenumber', 'International area code')})\n\n    def render(self, name, value, *args, **kwargs):\n        return super().render(name, value or self.initial, *args, **kwargs)\n\n    def get_context(self, name, value, attrs):\n        if value and self.choices[1][0] != value:\n            matching_choices = len([1 for p, c in self.choices if p == value])\n            if matching_choices > 1:\n                # Some countries share a phone prefix, for example +1 is used all over the Americas.\n                # This causes a UX problem: If the default value or the existing data is +12125552368,\n                # the widget will just show the first <option> entry with value=\"+1\" as selected,\n                # which alphabetically is America Samoa, although most numbers statistically are from\n                # the US. As a workaround, we detect this case and add an aditional choice value with\n                # just <option value=\"+1\">+1</option> without an explicit country.\n                self.choices.insert(1, (value, value))\n        context = super().get_context(name, value, attrs)\n        return context\n\n\nclass WrappedPhoneNumberPrefixWidget(PhoneNumberPrefixWidget):\n\n    def __init__(self, attrs=None, initial=None):\n        attrs = {\n            'aria-label': pgettext_lazy('phonenumber', 'Phone number (without international area code)')\n        }\n        widgets = (WrappedPhonePrefixSelect(initial), forms.TextInput(attrs=attrs))\n        super(PhoneNumberPrefixWidget, self).__init__(widgets, attrs)\n\n    def render(self, name, value, attrs=None, renderer=None):\n        output = super().render(name, value, attrs, renderer)\n        return mark_safe(self.format_output(output))\n\n    def format_output(self, rendered_widgets) -> str:\n        return '<div class=\"nameparts-form-group\">%s</div>' % ''.join(rendered_widgets)\n\n    def decompress(self, value):\n        \"\"\"\n        If an incomplete phone number (e.g. without country prefix) is currently entered,\n        the default implementation just discards the value and shows nothing at all.\n        Let's rather show something invalid, so the user is prompted to fix it, instead of\n        silently deleting data.\n        \"\"\"\n        if value:\n            if isinstance(value, str):\n                try:\n                    value = PhoneNumber.from_string(value)\n                except:\n                    pass\n            if isinstance(value, PhoneNumber):\n                if value.country_code and value.national_number:\n                    return [\n                        \"+%d\" % value.country_code,\n                        national_significant_number(value),\n                    ]\n                return [\n                    None,\n                    str(value)\n                ]\n            elif \".\" in value:\n                return value.split(\".\")\n            else:\n                return [None, value]\n        return [None, \"\"]\n\n    def value_from_datadict(self, data, files, name):\n        # In contrast to defualt implementation, do not silently fail if a number without\n        # country prefix is entered\n        values = super(PhoneNumberPrefixWidget, self).value_from_datadict(data, files, name)\n        if values[1]:\n            return \"%s.%s\" % tuple(values)\n        return \"\"\n\n\ndef guess_country_from_request(request, event):\n    if settings.HAS_GEOIP:\n        g = GeoIP2()\n        try:\n            res = g.country(get_client_ip(request))\n            if res['country_code'] and len(res['country_code']) == 2:\n                return Country(res['country_code'])\n        except AddressNotFoundError:\n            pass\n    return guess_country(event)\n\n\ndef guess_country(event):\n    # Try to guess the initial country from either the country of the merchant\n    # or the locale. This will hopefully save at least some users some scrolling :)\n    country = event.settings.region or event.settings.invoice_address_from_country\n    if not country:\n        country = get_country_by_locale(get_language_without_region())\n    return country\n\n\ndef get_country_by_locale(locale):\n    country = None\n    valid_countries = countries.countries\n    if '-' in locale:\n        parts = locale.split('-')\n        # TODO: does this actually work?\n        if parts[1].upper() in valid_countries:\n            country = Country(parts[1].upper())\n        elif parts[0].upper() in valid_countries:\n            country = Country(parts[0].upper())\n    else:\n        if locale.upper() in valid_countries:\n            country = Country(locale.upper())\n    return country\n\n\ndef guess_phone_prefix(event):\n    with language(get_babel_locale()):\n        country = str(guess_country(event))\n        return get_phone_prefix(country)\n\n\ndef guess_phone_prefix_from_request(request, event):\n    with language(get_babel_locale()):\n        country = str(guess_country_from_request(request, event))\n        return get_phone_prefix(country)\n\n\ndef get_phone_prefix(country):\n    for prefix, values in _COUNTRY_CODE_TO_REGION_CODE.items():\n        if country in values:\n            return prefix\n    return None\n\n\nclass QuestionCheckboxSelectMultiple(forms.CheckboxSelectMultiple):\n    option_template_name = 'pretixbase/forms/widgets/checkbox_option_with_links.html'\n\n\nclass MinDateValidator(MinValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'], 'SHORT_DATE_FORMAT')\n            raise e\n\n\nclass MinDateTimeValidator(MinValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'].astimezone(get_current_timezone()), 'SHORT_DATETIME_FORMAT')\n            raise e\n\n\nclass MaxDateValidator(MaxValueValidator):\n\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'], 'SHORT_DATE_FORMAT')\n            raise e\n\n\nclass MaxDateTimeValidator(MaxValueValidator):\n    def __call__(self, value):\n        try:\n            return super().__call__(value)\n        except ValidationError as e:\n            e.params['limit_value'] = date_format(e.params['limit_value'].astimezone(get_current_timezone()), 'SHORT_DATETIME_FORMAT')\n            raise e\n\n\nclass PortraitImageWidget(UploadedFileWidget):\n    template_name = 'pretixbase/forms/widgets/portrait_image.html'\n\n    def value_from_datadict(self, data, files, name):\n        d = super().value_from_datadict(data, files, name)\n        if d is not None and d is not False and d is not FILE_INPUT_CONTRADICTION:\n            d._cropdata = json.loads(data.get(name + '_cropdata', '{}') or '{}')\n        return d\n\n\nclass PortraitImageField(SizeValidationMixin, ExtValidationMixin, forms.FileField):\n    widget = PortraitImageWidget\n    default_error_messages = {\n        'aspect_ratio_landscape': _(\n            \"You uploaded an image in landscape orientation. Please upload an image in portrait orientation.\"\n        ),\n        'aspect_ratio_not_3_by_4': _(\n            \"Please upload an image where the width is 3/4 of the height.\"\n        ),\n        'max_dimension': _(\n            \"The file you uploaded has a very large number of pixels, please upload an image no larger than 10000 x 10000 pixels.\"\n        ),\n        'invalid_image': _(\n            \"Upload a valid image. The file you uploaded was either not an \"\n            \"image or a corrupted image.\"\n        ),\n    }\n\n    def to_python(self, data):\n        \"\"\"\n        Based on Django's ImageField\n        \"\"\"\n        f = super().to_python(data)\n        if f is None:\n            return None\n\n        from PIL import Image\n\n        # We need to get a file object for Pillow. We might have a path or we might\n        # have to read the data into memory.\n        if hasattr(data, 'temporary_file_path'):\n            file = data.temporary_file_path()\n        else:\n            if hasattr(data, 'read'):\n                file = BytesIO(data.read())\n            else:\n                file = BytesIO(data['content'])\n\n        try:\n            image = Image.open(file, formats=settings.PILLOW_FORMATS_QUESTIONS_IMAGE)\n            # verify() must be called immediately after the constructor.\n            image.verify()\n\n            # We want to do more than just verify(), so we need to re-open the file\n            if hasattr(file, 'seek'):\n                file.seek(0)\n            image = Image.open(file, formats=settings.PILLOW_FORMATS_QUESTIONS_IMAGE)\n\n            # load() is a potential DoS vector (see Django bug #18520), so we verify the size first\n            if image.width > 10_000 or image.height > 10_000:\n                raise ValidationError(\n                    self.error_messages['max_dimension'],\n                    code='max_dimension',\n                )\n\n            image.load()\n\n            # Annotating so subclasses can reuse it for their own validation\n            f.image = image\n            # Pillow doesn't detect the MIME type of all formats. In those\n            # cases, content_type will be None.\n            f.content_type = Image.MIME.get(image.format)\n\n            # before we calc aspect ratio, we need to check and apply EXIF-orientation\n            image = ImageOps.exif_transpose(image)\n\n            if f._cropdata:\n                image = image.crop((\n                    f._cropdata.get('x', 0),\n                    f._cropdata.get('y', 0),\n                    f._cropdata.get('x', 0) + f._cropdata.get('width', image.width),\n                    f._cropdata.get('y', 0) + f._cropdata.get('height', image.height),\n                ))\n                with BytesIO() as output:\n                    # This might use a lot of memory, but temporary files are not a good option since\n                    # we don't control the cleanup\n                    image.save(output, format=f.image.format)\n                    f = SimpleUploadedFile(f.name, output.getvalue(), f.content_type)\n                    f.image = image\n\n            if image.width > image.height:\n                raise ValidationError(\n                    self.error_messages['aspect_ratio_landscape'],\n                    code='aspect_ratio_landscape',\n                )\n\n            if not 3 / 4 * .95 < image.width / image.height < 3 / 4 * 1.05:  # give it some tolerance\n                raise ValidationError(\n                    self.error_messages['aspect_ratio_not_3_by_4'],\n                    code='aspect_ratio_not_3_by_4',\n                )\n        except Exception as exc:\n            logger.exception('Could not parse image')\n            # Pillow doesn't recognize it as an image.\n            if isinstance(exc, ValidationError):\n                raise\n            raise ValidationError(\n                self.error_messages['invalid_image'],\n                code='invalid_image',\n            ) from exc\n        if hasattr(f, 'seek') and callable(f.seek):\n            f.seek(0)\n        return f\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault('ext_whitelist', settings.FILE_UPLOAD_EXTENSIONS_QUESTION_IMAGE)\n        kwargs.setdefault('max_size', settings.FILE_UPLOAD_MAX_SIZE_IMAGE)\n        super().__init__(*args, **kwargs)\n\n\nclass BaseQuestionsForm(forms.Form):\n    \"\"\"\n    This form class is responsible for asking order-related questions. This includes\n    the attendee name for admission tickets, if the corresponding setting is enabled,\n    as well as additional questions defined by the organizer.\n    \"\"\"\n    address_validation = False\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Takes two additional keyword arguments:\n\n        :param cartpos: The cart position the form should be for\n        :param event: The event this belongs to\n        \"\"\"\n        request = kwargs.pop('request', None)\n        cartpos = self.cartpos = kwargs.pop('cartpos', None)\n        orderpos = self.orderpos = kwargs.pop('orderpos', None)\n        pos = cartpos or orderpos\n        item = pos.item\n        questions = pos.item.questions_to_ask\n        event = kwargs.pop('event')\n        self.all_optional = kwargs.pop('all_optional', False)\n\n        super().__init__(*args, **kwargs)\n\n        if cartpos and item.validity_mode == Item.VALIDITY_MODE_DYNAMIC and item.validity_dynamic_start_choice:\n            if item.validity_dynamic_start_choice_day_limit:\n                max_date = now().astimezone(event.timezone) + timedelta(days=item.validity_dynamic_start_choice_day_limit)\n            else:\n                max_date = None\n            if item.validity_dynamic_duration_months or item.validity_dynamic_duration_days:\n                attrs = {}\n                if max_date:\n                    attrs['data-max'] = max_date.date().isoformat()\n                self.fields['requested_valid_from'] = forms.DateField(\n                    label=_('Start date'),\n                    help_text=_('If you keep this empty, the ticket will be valid starting at the time of purchase.'),\n                    required=False,\n                    widget=DatePickerWidget(attrs),\n                    validators=[MaxDateValidator(max_date.date())] if max_date else []\n                )\n            else:\n                self.fields['requested_valid_from'] = forms.SplitDateTimeField(\n                    label=_('Start date'),\n                    help_text=_('If you keep this empty, the ticket will be valid starting at the time of purchase.'),\n                    required=False,\n                    widget=SplitDateTimePickerWidget(\n                        time_format=get_format_without_seconds('TIME_INPUT_FORMATS'),\n                        max_date=max_date\n                    ),\n                    validators=[MaxDateTimeValidator(max_date)] if max_date else []\n                )\n\n        add_fields = {}\n\n        if item.ask_attendee_data and event.settings.attendee_names_asked:\n            add_fields['attendee_name_parts'] = NamePartsFormField(\n                max_length=255,\n                required=event.settings.attendee_names_required and not self.all_optional,\n                scheme=event.settings.name_scheme,\n                titles=event.settings.name_scheme_titles,\n                label=_('Attendee name'),\n                initial=(cartpos.attendee_name_parts if cartpos else orderpos.attendee_name_parts),\n            )\n        if item.ask_attendee_data and event.settings.attendee_emails_asked:\n            add_fields['attendee_email'] = forms.EmailField(\n                required=event.settings.attendee_emails_required and not self.all_optional,\n                label=_('Attendee email'),\n                initial=(cartpos.attendee_email if cartpos else orderpos.attendee_email),\n                widget=forms.EmailInput(\n                    attrs={\n                        'autocomplete': 'email'\n                    }\n                )\n            )\n        if item.ask_attendee_data and event.settings.attendee_company_asked:\n            add_fields['company'] = forms.CharField(\n                required=event.settings.attendee_company_required and not self.all_optional,\n                label=_('Company'),\n                max_length=255,\n                initial=(cartpos.company if cartpos else orderpos.company),\n            )\n\n        if item.ask_attendee_data and event.settings.attendee_addresses_asked:\n            add_fields['street'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('Address'),\n                widget=forms.Textarea(attrs={\n                    'rows': 2,\n                    'placeholder': _('Street and Number'),\n                    'autocomplete': 'street-address'\n                }),\n                initial=(cartpos.street if cartpos else orderpos.street),\n            )\n            add_fields['zipcode'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                max_length=30,\n                label=_('ZIP code'),\n                initial=(cartpos.zipcode if cartpos else orderpos.zipcode),\n                widget=forms.TextInput(attrs={\n                    'autocomplete': 'postal-code',\n                }),\n            )\n            add_fields['city'] = forms.CharField(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('City'),\n                max_length=255,\n                initial=(cartpos.city if cartpos else orderpos.city),\n                widget=forms.TextInput(attrs={\n                    'autocomplete': 'address-level2',\n                }),\n            )\n            country = (cartpos.country if cartpos else orderpos.country) or guess_country_from_request(request, event)\n            add_fields['country'] = CountryField(\n                countries=CachedCountries\n            ).formfield(\n                required=event.settings.attendee_addresses_required and not self.all_optional,\n                label=_('Country'),\n                initial=country,\n                widget=forms.Select(attrs={\n                    'autocomplete': 'country',\n                }),\n            )\n            c = [('', pgettext_lazy('address', 'Select state'))]\n            fprefix = str(self.prefix) + '-' if self.prefix is not None and self.prefix != '-' else ''\n            cc = None\n            state = None\n            if fprefix + 'country' in self.data:\n                cc = str(self.data[fprefix + 'country'])\n            elif country:\n                cc = str(country)\n            if cc and cc in COUNTRIES_WITH_STATE_IN_ADDRESS:\n                types, form = COUNTRIES_WITH_STATE_IN_ADDRESS[cc]\n                statelist = [s for s in pycountry.subdivisions.get(country_code=cc) if s.type in types]\n                c += sorted([(s.code[3:], s.name) for s in statelist], key=lambda s: s[1])\n                state = (cartpos.state if cartpos else orderpos.state)\n            elif fprefix + 'state' in self.data:\n                self.data = self.data.copy()\n                del self.data[fprefix + 'state']\n\n            add_fields['state'] = forms.ChoiceField(\n                label=pgettext_lazy('address', 'State'),\n                required=False,\n                choices=c,\n                initial=state,\n                widget=forms.Select(attrs={\n                    'autocomplete': 'address-level1',\n                }),\n            )\n            add_fields['state'].widget.is_required = True\n\n        field_positions = list(\n            [\n                (n, event.settings.system_question_order.get(n if n != 'state' else 'country', 0))\n                for n in add_fields.keys()\n            ]\n        )\n\n        for q in questions:\n            # Do we already have an answer? Provide it as the initial value\n            answers = [a for a in pos.answerlist if a.question_id == q.id]\n            if answers:\n                initial = answers[0]\n            else:\n                initial = None\n            tz = ZoneInfo(event.settings.timezone)\n            help_text = rich_text(q.help_text)\n            label = escape(q.question)  # django-bootstrap3 calls mark_safe\n            required = q.required and not self.all_optional\n            if q.type == Question.TYPE_BOOLEAN:\n                if required:\n                    # For some reason, django-bootstrap3 does not set the required attribute\n                    # itself.\n                    widget = forms.CheckboxInput(attrs={'required': 'required'})\n                else:\n                    widget = forms.CheckboxInput()\n\n                if initial:\n                    initialbool = (initial.answer == \"True\")\n                else:\n                    initialbool = False\n\n                field = forms.BooleanField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=initialbool, widget=widget,\n                )\n            elif q.type == Question.TYPE_NUMBER:\n                field = forms.DecimalField(\n                    label=label, required=required,\n                    min_value=q.valid_number_min or Decimal('0.00'),\n                    max_value=q.valid_number_max,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_STRING:\n                field = forms.CharField(\n                    label=label, required=required,\n                    max_length=q.valid_string_length_max,\n                    help_text=help_text,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_TEXT:\n                field = forms.CharField(\n                    label=label, required=required,\n                    max_length=q.valid_string_length_max,\n                    help_text=help_text,\n                    widget=forms.Textarea,\n                    initial=initial.answer if initial else None,\n                )\n            elif q.type == Question.TYPE_COUNTRYCODE:\n                field = CountryField(\n                    countries=CachedCountries,\n                    blank=True, null=True, blank_label=' ',\n                ).formfield(\n                    label=label, required=required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    empty_label=' ',\n                    initial=initial.answer if initial else (guess_country_from_request(request, event) if required else None),\n                )\n            elif q.type == Question.TYPE_CHOICE:\n                field = forms.ModelChoiceField(\n                    queryset=q.options,\n                    label=label, required=required,\n                    help_text=help_text,\n                    widget=forms.Select,\n                    to_field_name='identifier',\n                    empty_label='',\n                    initial=initial.options.first() if initial else None,\n                )\n            elif q.type == Question.TYPE_CHOICE_MULTIPLE:\n                field = forms.ModelMultipleChoiceField(\n                    queryset=q.options,\n                    label=label, required=required,\n                    help_text=help_text,\n                    to_field_name='identifier',\n                    widget=QuestionCheckboxSelectMultiple,\n                    initial=initial.options.all() if initial else None,\n                )\n            elif q.type == Question.TYPE_FILE:\n                if q.valid_file_portrait:\n                    field = PortraitImageField(\n                        label=label, required=required,\n                        help_text=help_text,\n                        initial=initial.file if initial else None,\n                        widget=PortraitImageWidget(position=pos, event=event, answer=initial, attrs={'data-portrait-photo': 'true'}),\n                    )\n                else:\n                    field = ExtFileField(\n                        label=label, required=required,\n                        help_text=help_text,\n                        initial=initial.file if initial else None,\n                        widget=UploadedFileWidget(position=pos, event=event, answer=initial),\n                        ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_OTHER,\n                        max_size=settings.FILE_UPLOAD_MAX_SIZE_OTHER,\n                    )\n            elif q.type == Question.TYPE_DATE:\n                attrs = {}\n                if q.valid_date_min:\n                    attrs['data-min'] = q.valid_date_min.isoformat()\n                if q.valid_date_max:\n                    attrs['data-max'] = q.valid_date_max.isoformat()\n                field = forms.DateField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).date() if initial and initial.answer else None,\n                    widget=DatePickerWidget(attrs),\n                )\n                if q.valid_date_min:\n                    field.validators.append(MinDateValidator(q.valid_date_min))\n                if q.valid_date_max:\n                    field.validators.append(MaxDateValidator(q.valid_date_max))\n            elif q.type == Question.TYPE_TIME:\n                field = forms.TimeField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).time() if initial and initial.answer else None,\n                    widget=TimePickerWidget(time_format=get_format_without_seconds('TIME_INPUT_FORMATS')),\n                )\n            elif q.type == Question.TYPE_DATETIME:\n                field = SplitDateTimeField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    initial=dateutil.parser.parse(initial.answer).astimezone(tz) if initial and initial.answer else None,\n                    widget=SplitDateTimePickerWidget(\n                        time_format=get_format_without_seconds('TIME_INPUT_FORMATS'),\n                        min_date=q.valid_datetime_min,\n                        max_date=q.valid_datetime_max\n                    ),\n                )\n                if q.valid_datetime_min:\n                    field.validators.append(MinDateTimeValidator(q.valid_datetime_min))\n                if q.valid_datetime_max:\n                    field.validators.append(MaxDateTimeValidator(q.valid_datetime_max))\n            elif q.type == Question.TYPE_PHONENUMBER:\n                if initial:\n                    try:\n                        initial = PhoneNumber().from_string(initial.answer)\n                    except NumberParseException:\n                        initial = None\n\n                if not initial:\n                    phone_prefix = guess_phone_prefix_from_request(request, event)\n                    if phone_prefix:\n                        initial = \"+{}.\".format(phone_prefix)\n\n                field = PhoneNumberField(\n                    label=label, required=required,\n                    help_text=help_text,\n                    # We now exploit an implementation detail in PhoneNumberPrefixWidget to allow us to pass just\n                    # a country code but no number as an initial value. It's a bit hacky, but should be stable for\n                    # the future.\n                    initial=initial,\n                    widget=WrappedPhoneNumberPrefixWidget()\n                )\n            field.question = q\n            if answers:\n                # Cache the answer object for later use\n                field.answer = answers[0]\n\n            if q.dependency_question_id:\n                field.widget.attrs['data-question-dependency'] = q.dependency_question_id\n                field.widget.attrs['data-question-dependency-values'] = escapejson_attr(json.dumps(q.dependency_values))\n                if q.type != 'M':\n                    field.widget.attrs['required'] = q.required and not self.all_optional\n                    field._required = q.required and not self.all_optional\n                field.required = False\n\n            add_fields['question_%s' % q.id] = field\n            field_positions.append(('question_%s' % q.id, q.position))\n\n        field_positions.sort(key=lambda e: e[1])\n        for fname, p in field_positions:\n            self.fields[fname] = add_fields[fname]\n\n        responses = question_form_fields.send(sender=event, position=pos)\n        data = pos.meta_info_data\n        for r, response in sorted(responses, key=lambda r: str(r[0])):\n            for key, value in response.items():\n                # We need to be this explicit, since OrderedDict.update does not retain ordering\n                self.fields[key] = value\n                value.initial = data.get('question_form_data', {}).get(key)\n\n        for k, v in self.fields.items():\n            if v.widget.attrs.get('autocomplete') or k == 'attendee_name_parts':\n                v.widget.attrs['autocomplete'] = 'section-{} '.format(self.prefix) + v.widget.attrs.get('autocomplete', '')\n\n    def clean(self):\n        from pretix.base.addressvalidation import \\\n            validate_address  # local import to prevent impact on startup time\n\n        d = super().clean()\n\n        if self.address_validation:\n            self.cleaned_data = d = validate_address(d, True)\n\n        if d.get('city') and d.get('country') and str(d['country']) in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            if not d.get('state'):\n                self.add_error('state', _('This field is required.'))\n\n        question_cache = {f.question.pk: f.question for f in self.fields.values() if getattr(f, 'question', None)}\n\n        def question_is_visible(parentid, qvals):\n            if parentid not in question_cache:\n                return False\n            parentq = question_cache[parentid]\n            if parentq.dependency_question_id and not question_is_visible(parentq.dependency_question_id, parentq.dependency_values):\n                return False\n            if 'question_%d' % parentid not in d:\n                return False\n            dval = d.get('question_%d' % parentid)\n            return (\n                ('True' in qvals and dval)\n                or ('False' in qvals and not dval)\n                or (isinstance(dval, QuestionOption) and dval.identifier in qvals)\n                or (isinstance(dval, (list, QuerySet)) and any(qval in [o.identifier for o in dval] for qval in qvals))\n            )\n\n        def question_is_required(q):\n            return (\n                q.required and\n                (not q.dependency_question_id or question_is_visible(q.dependency_question_id, q.dependency_values))\n            )\n\n        if not self.all_optional:\n            for q in question_cache.values():\n                answer = d.get('question_%d' % q.pk)\n                field = self['question_%d' % q.pk]\n                if question_is_required(q) and not answer and answer != 0 and not field.errors:\n                    raise ValidationError({'question_%d' % q.pk: [_('This field is required.')]})\n\n        # Strip invisible question from cleaned_data so they don't end up in the database\n        for q in question_cache.values():\n            answer = d.get('question_%d' % q.pk)\n            if q.dependency_question_id and not question_is_visible(q.dependency_question_id, q.dependency_values) and answer is not None:\n                d['question_%d' % q.pk] = None\n\n        return d\n\n\nclass BaseInvoiceAddressForm(forms.ModelForm):\n    vat_warning = False\n    address_validation = False\n\n    class Meta:\n        model = InvoiceAddress\n        fields = ('is_business', 'company', 'name_parts', 'street', 'zipcode', 'city', 'country', 'state',\n                  'vat_id', 'internal_reference', 'beneficiary', 'custom_field')\n        widgets = {\n            'is_business': BusinessBooleanRadio,\n            'street': forms.Textarea(attrs={\n                'rows': 2,\n                'placeholder': _('Street and Number'),\n                'autocomplete': 'street-address'\n            }),\n            'beneficiary': forms.Textarea(attrs={'rows': 3}),\n            'country': forms.Select(attrs={\n                'autocomplete': 'country',\n            }),\n            'zipcode': forms.TextInput(attrs={\n                'autocomplete': 'postal-code',\n            }),\n            'city': forms.TextInput(attrs={\n                'autocomplete': 'address-level2',\n            }),\n            'company': forms.TextInput(attrs={\n                'data-display-dependency': '#id_is_business_1',\n                'autocomplete': 'organization',\n            }),\n            'vat_id': forms.TextInput(attrs={'data-display-dependency': '#id_is_business_1', 'data-countries-with-vat-id': ','.join(VAT_ID_COUNTRIES)}),\n            'internal_reference': forms.TextInput,\n        }\n        labels = {\n            'is_business': ''\n        }\n\n    def __init__(self, *args, **kwargs):\n        self.event = event = kwargs.pop('event')\n        self.request = kwargs.pop('request', None)\n        self.validate_vat_id = kwargs.pop('validate_vat_id')\n        self.all_optional = kwargs.pop('all_optional', False)\n\n        kwargs.setdefault('initial', {})\n        if not kwargs.get('instance') or not kwargs['instance'].country:\n            kwargs['initial']['country'] = guess_country_from_request(self.request, self.event)\n\n        super().__init__(*args, **kwargs)\n        if not event.settings.invoice_address_vatid:\n            del self.fields['vat_id']\n        elif self.validate_vat_id:\n            self.fields['vat_id'].help_text = '<br/>'.join([\n                str(_('Optional, but depending on the country you reside in we might need to charge you '\n                      'additional taxes if you do not enter it.')),\n                str(_('If you are registered in Switzerland, you can enter your UID instead.')),\n            ])\n        else:\n            self.fields['vat_id'].help_text = '<br/>'.join([\n                str(_('Optional, but it might be required for you to claim tax benefits on your invoice '\n                      'depending on your and the seller\u2019s country of residence.')),\n                str(_('If you are registered in Switzerland, you can enter your UID instead.')),\n            ])\n\n        self.fields['country'].choices = CachedCountries()\n\n        c = [('', pgettext_lazy('address', 'Select state'))]\n        fprefix = self.prefix + '-' if self.prefix else ''\n        cc = None\n        if fprefix + 'country' in self.data:\n            cc = str(self.data[fprefix + 'country'])\n        elif 'country' in self.initial:\n            cc = str(self.initial['country'])\n        elif self.instance and self.instance.country:\n            cc = str(self.instance.country)\n        if cc and cc in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            types, form = COUNTRIES_WITH_STATE_IN_ADDRESS[cc]\n            statelist = [s for s in pycountry.subdivisions.get(country_code=cc) if s.type in types]\n            c += sorted([(s.code[3:], s.name) for s in statelist], key=lambda s: s[1])\n        elif fprefix + 'state' in self.data:\n            self.data = self.data.copy()\n            del self.data[fprefix + 'state']\n\n        self.fields['state'] = forms.ChoiceField(\n            label=pgettext_lazy('address', 'State'),\n            required=False,\n            choices=c,\n            widget=forms.Select(attrs={\n                'autocomplete': 'address-level1',\n            }),\n        )\n        self.fields['state'].widget.is_required = True\n\n        # Without JavaScript the VAT ID field is not hidden, so we empty the field if a country outside the EU is selected.\n        if cc and not ask_for_vat_id(cc) and fprefix + 'vat_id' in self.data:\n            self.data = self.data.copy()\n            del self.data[fprefix + 'vat_id']\n\n        if not event.settings.invoice_address_required or self.all_optional:\n            for k, f in self.fields.items():\n                f.required = False\n                f.widget.is_required = False\n                if 'required' in f.widget.attrs:\n                    del f.widget.attrs['required']\n        elif event.settings.invoice_address_company_required and not self.all_optional:\n            self.initial['is_business'] = True\n\n            self.fields['is_business'].widget = BusinessBooleanRadio(require_business=True)\n            self.fields['company'].required = True\n            self.fields['company'].widget.is_required = True\n            self.fields['company'].widget.attrs['required'] = 'required'\n            del self.fields['company'].widget.attrs['data-display-dependency']\n\n        self.fields['name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=event.settings.invoice_name_required and not self.all_optional,\n            scheme=event.settings.name_scheme,\n            titles=event.settings.name_scheme_titles,\n            label=_('Name'),\n            initial=self.instance.name_parts,\n        )\n        if event.settings.invoice_address_required and not event.settings.invoice_address_company_required and not self.all_optional:\n            if not event.settings.invoice_name_required:\n                self.fields['name_parts'].widget.attrs['data-required-if'] = '#id_is_business_0'\n            self.fields['name_parts'].widget.attrs['data-no-required-attr'] = '1'\n            self.fields['company'].widget.attrs['data-required-if'] = '#id_is_business_1'\n\n        if not event.settings.invoice_address_beneficiary:\n            del self.fields['beneficiary']\n\n        if event.settings.invoice_address_custom_field:\n            self.fields['custom_field'].label = event.settings.invoice_address_custom_field\n        else:\n            del self.fields['custom_field']\n\n        for k, v in self.fields.items():\n            if v.widget.attrs.get('autocomplete') or k == 'name_parts':\n                v.widget.attrs['autocomplete'] = 'section-invoice billing ' + v.widget.attrs.get('autocomplete', '')\n\n    def clean(self):\n        from pretix.base.addressvalidation import \\\n            validate_address  # local import to prevent impact on startup time\n\n        data = self.cleaned_data\n        if not data.get('is_business'):\n            data['company'] = ''\n            data['vat_id'] = ''\n        if data.get('is_business') and not ask_for_vat_id(data.get('country')):\n            data['vat_id'] = ''\n        if self.event.settings.invoice_address_required:\n            if data.get('is_business') and not data.get('company'):\n                raise ValidationError(_('You need to provide a company name.'))\n            if not data.get('is_business') and not data.get('name_parts'):\n                raise ValidationError(_('You need to provide your name.'))\n\n        if 'vat_id' in self.changed_data or not data.get('vat_id'):\n            self.instance.vat_id_validated = False\n\n        if self.address_validation:\n            self.cleaned_data = data = validate_address(data, self.all_optional)\n\n        self.instance.name_parts = data.get('name_parts')\n\n        if all(\n                not v for k, v in data.items() if k not in ('is_business', 'country', 'name_parts')\n        ) and len(data.get('name_parts', {})) == 1:\n            # Do not save the country if it is the only field set -- we don't know the user even checked it!\n            self.cleaned_data['country'] = ''\n\n        if self.validate_vat_id and self.instance.vat_id_validated and 'vat_id' not in self.changed_data:\n            pass\n        elif self.validate_vat_id and data.get('is_business') and ask_for_vat_id(data.get('country')) and data.get('vat_id'):\n            try:\n                normalized_id = validate_vat_id(data.get('vat_id'), str(data.get('country')))\n                self.instance.vat_id_validated = True\n                self.instance.vat_id = normalized_id\n            except VATIDFinalError as e:\n                if self.all_optional:\n                    self.instance.vat_id_validated = False\n                    messages.warning(self.request, e.message)\n                else:\n                    raise ValidationError(e.message)\n            except VATIDTemporaryError as e:\n                self.instance.vat_id_validated = False\n                if self.request and self.vat_warning:\n                    messages.warning(self.request, e.message)\n        else:\n            self.instance.vat_id_validated = False\n\n\nclass BaseInvoiceNameForm(BaseInvoiceAddressForm):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        for f in list(self.fields.keys()):\n            if f != 'name_parts':\n                del self.fields[f]\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexander Schwartz, Ayan Ginet, Daniel, Enrique Saez,\n# Flavia Bastos, Jakob Schnell, Sanket Dasgupta, Sohalt, Tobias Kunze, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport hashlib\nimport json\nimport logging\nimport string\nfrom collections import Counter\nfrom datetime import datetime, time, timedelta\nfrom decimal import Decimal\nfrom typing import Any, Dict, List, Union\nfrom zoneinfo import ZoneInfo\n\nimport dateutil\nimport pycountry\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.db import models, transaction\nfrom django.db.models import (\n    Case, Exists, F, Max, OuterRef, Q, Subquery, Sum, Value, When,\n)\nfrom django.db.models.functions import Coalesce, Greatest\nfrom django.db.models.signals import post_delete\nfrom django.dispatch import receiver\nfrom django.urls import reverse\nfrom django.utils.crypto import get_random_string\nfrom django.utils.encoding import escape_uri_path\nfrom django.utils.formats import date_format\nfrom django.utils.functional import cached_property\nfrom django.utils.timezone import get_current_timezone, make_aware, now\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_countries.fields import Country\nfrom django_scopes import ScopedManager, scopes_disabled\nfrom i18nfield.strings import LazyI18nString\nfrom phonenumber_field.modelfields import PhoneNumberField\nfrom phonenumber_field.phonenumber import PhoneNumber\nfrom phonenumbers import NumberParseException\n\nfrom pretix.base.banlist import banned\nfrom pretix.base.decimal import round_decimal\nfrom pretix.base.email import get_email_context\nfrom pretix.base.i18n import language\nfrom pretix.base.models import Customer, User\nfrom pretix.base.reldate import RelativeDateWrapper\nfrom pretix.base.services.locking import LOCK_TIMEOUT, NoLockManager\nfrom pretix.base.settings import PERSON_NAME_SCHEMES\nfrom pretix.base.signals import order_gracefully_delete\n\nfrom ...helpers import OF_SELF\nfrom ...helpers.countries import CachedCountries, FastCountryField\nfrom ...helpers.format import format_map\nfrom ...helpers.names import build_name\nfrom ._transactions import (\n    _fail, _transactions_mark_order_clean, _transactions_mark_order_dirty,\n)\nfrom .base import LockModel, LoggedModel\nfrom .event import Event, SubEvent\nfrom .items import Item, ItemVariation, Question, QuestionOption, Quota\n\nlogger = logging.getLogger(__name__)\n\n\ndef generate_secret():\n    return get_random_string(length=16, allowed_chars=string.ascii_lowercase + string.digits)\n\n\ndef generate_position_secret():\n    raise TypeError(\"Function no longer exists, use secret generators\")\n\n\nclass Order(LockModel, LoggedModel):\n    \"\"\"\n    An order is created when a user clicks 'buy' on his cart. It holds\n    several OrderPositions and is connected to a user. It has an\n    expiration date: If items run out of capacity, orders which are over\n    their expiration date might be canceled.\n\n    An order -- like all objects -- has an ID, which is globally unique,\n    but also a code, which is shorter and easier to memorize, but only\n    unique within a single conference.\n\n    :param code: In addition to the ID, which is globally unique, every\n                 order has an order code, which is shorter and easier to\n                 memorize, but is only unique within a single conference.\n    :type code: str\n    :param status: The status of this order. One of:\n\n        * ``STATUS_PENDING``\n        * ``STATUS_PAID``\n        * ``STATUS_EXPIRED``\n        * ``STATUS_CANCELED``\n\n    :param valid_if_pending: Treat this order like a paid order for most purposes (such as check-in), even if it is\n                             still unpaid.\n    :type valid_if_pending: bool\n    :param event: The event this order belongs to\n    :type event: Event\n    :param customer: The customer this order belongs to\n    :type customer: Customer\n    :param email: The email of the person who ordered this\n    :type email: str\n    :param phone: The phone number of the person who ordered this\n    :type phone: str\n    :param testmode: Whether this is a test mode order\n    :type testmode: bool\n    :param locale: The locale of this order\n    :type locale: str\n    :param secret: A secret string that is required to modify the order\n    :type secret: str\n    :param datetime: The datetime of the order placement\n    :type datetime: datetime\n    :param expires: The date until this order has to be paid to guarantee the fulfillment\n    :type expires: datetime\n    :param total: The total amount of the order, including the payment fee\n    :type total: decimal.Decimal\n    :param comment: An internal comment that will only be visible to staff, and never displayed to the user\n    :type comment: str\n    :param download_reminder_sent: A field to indicate whether a download reminder has been sent.\n    :type download_reminder_sent: boolean\n    :param require_approval: If set to ``True``, this order is pending approval by an organizer\n    :type require_approval: bool\n    :param meta_info: Additional meta information on the order, JSON-encoded.\n    :type meta_info: str\n    :param sales_channel: Identifier of the sales channel this order was created through.\n    :type sales_channel: str\n    \"\"\"\n\n    STATUS_PENDING = \"n\"\n    STATUS_PAID = \"p\"\n    STATUS_EXPIRED = \"e\"\n    STATUS_CANCELED = \"c\"\n    STATUS_REFUNDED = \"c\"  # deprecated\n    STATUS_CHOICE = (\n        (STATUS_PENDING, _(\"pending\")),\n        (STATUS_PAID, _(\"paid\")),\n        (STATUS_EXPIRED, _(\"expired\")),\n        (STATUS_CANCELED, _(\"canceled\")),\n    )\n\n    code = models.CharField(\n        max_length=16,\n        verbose_name=_(\"Order code\"),\n        db_index=True\n    )\n    status = models.CharField(\n        max_length=3,\n        choices=STATUS_CHOICE,\n        verbose_name=_(\"Status\"),\n        db_index=True\n    )\n    valid_if_pending = models.BooleanField(\n        default=False,\n    )\n    testmode = models.BooleanField(default=False)\n    event = models.ForeignKey(\n        Event,\n        verbose_name=_(\"Event\"),\n        related_name=\"orders\",\n        on_delete=models.CASCADE\n    )\n    customer = models.ForeignKey(\n        Customer,\n        verbose_name=_(\"Customer\"),\n        related_name=\"orders\",\n        null=True, blank=True,\n        on_delete=models.SET_NULL\n    )\n    email = models.EmailField(\n        null=True, blank=True,\n        verbose_name=_('E-mail')\n    )\n    phone = PhoneNumberField(\n        null=True, blank=True,\n        verbose_name=_('Phone number'),\n    )\n    locale = models.CharField(\n        null=True, blank=True, max_length=32,\n        verbose_name=_('Locale')\n    )\n    secret = models.CharField(max_length=32, default=generate_secret)\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"), db_index=False\n    )\n    cancellation_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    expires = models.DateTimeField(\n        verbose_name=_(\"Expiration date\")\n    )\n    total = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Total amount\")\n    )\n    comment = models.TextField(\n        blank=True, verbose_name=_(\"Comment\"),\n        help_text=_(\"The text entered in this field will not be visible to the user and is available for your \"\n                    \"convenience.\")\n    )\n    custom_followup_at = models.DateField(\n        verbose_name=_(\"Follow-up date\"),\n        help_text=_('We\\'ll show you this order to be due for a follow-up on this day.'),\n        null=True, blank=True\n    )\n    checkin_attention = models.BooleanField(\n        verbose_name=_('Requires special attention'),\n        default=False,\n        help_text=_('If you set this, the check-in app will show a visible warning that tickets of this order require '\n                    'special attention. This will not show any details or custom message, so you need to brief your '\n                    'check-in staff how to handle these cases.')\n    )\n    expiry_reminder_sent = models.BooleanField(\n        default=False\n    )\n\n    download_reminder_sent = models.BooleanField(\n        default=False\n    )\n    meta_info = models.TextField(\n        verbose_name=_(\"Meta information\"),\n        null=True, blank=True\n    )\n    last_modified = models.DateTimeField(\n        auto_now=True, db_index=False\n    )\n    require_approval = models.BooleanField(\n        default=False\n    )\n    sales_channel = models.CharField(max_length=190, default=\"web\")\n    email_known_to_work = models.BooleanField(\n        default=False,\n        verbose_name=_('E-mail address verified')\n    )\n\n    objects = ScopedManager(organizer='event__organizer')\n\n    class Meta:\n        verbose_name = _(\"Order\")\n        verbose_name_plural = _(\"Orders\")\n        ordering = (\"-datetime\", \"-pk\")\n        index_together = [\n            [\"datetime\", \"id\"],\n            [\"last_modified\", \"id\"],\n        ]\n\n    def __str__(self):\n        return self.full_code\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if 'require_approval' not in self.get_deferred_fields() and 'status' not in self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def _transaction_key_reset(self):\n        self.__initial_status_paid_or_pending = self.status in (Order.STATUS_PENDING, Order.STATUS_PAID) and not self.require_approval\n\n    def gracefully_delete(self, user=None, auth=None):\n        from . import GiftCard, GiftCardTransaction, Membership, Voucher\n\n        if not self.testmode:\n            raise TypeError(\"Only test mode orders can be deleted.\")\n        self.event.log_action(\n            'pretix.event.order.deleted', user=user, auth=auth,\n            data={\n                'code': self.code,\n            }\n        )\n\n        order_gracefully_delete.send(self.event, order=self)\n\n        if self.status != Order.STATUS_CANCELED:\n            for position in self.positions.all():\n                if position.voucher:\n                    Voucher.objects.filter(pk=position.voucher.pk).update(redeemed=Greatest(0, F('redeemed') - 1))\n\n        GiftCardTransaction.objects.filter(payment__in=self.payments.all()).update(payment=None)\n        GiftCardTransaction.objects.filter(refund__in=self.refunds.all()).update(refund=None)\n        GiftCardTransaction.objects.filter(order=self).update(order=None)\n        GiftCard.objects.filter(issued_in__in=self.positions.all()).update(issued_in=None)\n        Membership.objects.filter(granted_in__order=self, testmode=True).update(granted_in=None)\n        OrderPosition.all.filter(order=self, addon_to__isnull=False).delete()\n        OrderPosition.all.filter(order=self).delete()\n        OrderFee.all.filter(order=self).delete()\n        Transaction.objects.filter(order=self).delete()\n        self.refunds.all().delete()\n        self.payments.all().delete()\n        self.event.cache.delete('complain_testmode_orders')\n        self.delete()\n\n    def email_confirm_hash(self):\n        return hashlib.sha256(settings.SECRET_KEY.encode() + self.secret.encode()).hexdigest()[:9]\n\n    @property\n    def fees(self):\n        \"\"\"\n        Related manager for all non-canceled fees. Use ``all_fees`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_fees(manager='objects')\n\n    @property\n    def custom_followup_due(self):\n        return self.custom_followup_at and self.custom_followup_at <= now().astimezone(get_current_timezone()).date()\n\n    @cached_property\n    @scopes_disabled()\n    def count_positions(self):\n        if hasattr(self, 'pcnt'):\n            return self.pcnt or 0\n        return self.positions.count()\n\n    @property\n    def positions(self):\n        \"\"\"\n        Related manager for all non-canceled positions. Use ``all_positions`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_positions(manager='objects')\n\n    @cached_property\n    def meta_info_data(self):\n        if not self.meta_info:\n            return {}\n        try:\n            return json.loads(self.meta_info)\n        except TypeError:\n            return None\n\n    @property\n    @scopes_disabled()\n    def payment_refund_sum(self):\n        payment_sum = self.payments.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        return payment_sum - refund_sum\n\n    @property\n    @scopes_disabled()\n    def pending_sum(self):\n        total = self.total\n        if self.status == Order.STATUS_CANCELED:\n            total = Decimal('0.00')\n        payment_sum = self.payments.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        return total - payment_sum + refund_sum\n\n    @classmethod\n    def annotate_overpayments(cls, qs, results=True, refunds=True, sums=False):\n        payment_sum = OrderPayment.objects.filter(\n            state__in=(OrderPayment.PAYMENT_STATE_CONFIRMED, OrderPayment.PAYMENT_STATE_REFUNDED),\n            order=OuterRef('pk')\n        ).order_by().values('order').annotate(s=Sum('amount')).values('s')\n        refund_sum = OrderRefund.objects.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED),\n            order=OuterRef('pk')\n        ).order_by().values('order').annotate(s=Sum('amount')).values('s')\n        external_refund = OrderRefund.objects.filter(\n            state=OrderRefund.REFUND_STATE_EXTERNAL,\n            order=OuterRef('pk')\n        )\n        pending_refund = OrderRefund.objects.filter(\n            state__in=(OrderRefund.REFUND_STATE_CREATED, OrderRefund.REFUND_STATE_TRANSIT),\n            order=OuterRef('pk')\n        )\n        payment_sum_sq = Subquery(payment_sum, output_field=models.DecimalField(decimal_places=2, max_digits=13))\n        refund_sum_sq = Subquery(refund_sum, output_field=models.DecimalField(decimal_places=2, max_digits=13))\n        if sums:\n            qs = qs.annotate(\n                payment_sum=payment_sum_sq,\n                refund_sum=refund_sum_sq,\n            )\n            qs = qs.annotate(\n                computed_payment_refund_sum=Coalesce(payment_sum_sq, Decimal('0.00')) - Coalesce(refund_sum_sq, Decimal('0.00')),\n            )\n\n        qs = qs.annotate(\n            pending_sum_t=F('total') - Coalesce(payment_sum_sq, Decimal('0.00')) + Coalesce(refund_sum_sq, Decimal('0.00')),\n            pending_sum_rc=-1 * Coalesce(payment_sum_sq, Decimal('0.00')) + Coalesce(refund_sum_sq, Decimal('0.00')),\n        )\n        if refunds:\n            qs = qs.annotate(\n                has_external_refund=Exists(external_refund),\n                has_pending_refund=Exists(pending_refund),\n            )\n        if results:\n            qs = qs.annotate(\n                is_overpaid=Case(\n                    When(~Q(status=Order.STATUS_CANCELED) & Q(pending_sum_t__lt=-1e-8),\n                         then=Value(1)),\n                    When(Q(status=Order.STATUS_CANCELED) & Q(pending_sum_rc__lt=-1e-8),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                ),\n                is_pending_with_full_payment=Case(\n                    When(Q(status__in=(Order.STATUS_EXPIRED, Order.STATUS_PENDING)) & Q(pending_sum_t__lte=1e-8)\n                         & Q(require_approval=False),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                ),\n                is_underpaid=Case(\n                    When(Q(status=Order.STATUS_PAID) & Q(pending_sum_t__gt=1e-8),\n                         then=Value(1)),\n                    When(Q(status=Order.STATUS_CANCELED) & Q(pending_sum_rc__gt=1e-8),\n                         then=Value(1)),\n                    default=Value(0),\n                    output_field=models.IntegerField()\n                )\n            )\n        return qs\n\n    @property\n    def full_code(self):\n        \"\"\"\n        An order code which is unique among all events of a single organizer,\n        built by concatenating the event slug and the order code.\n        \"\"\"\n        return '{event}-{code}'.format(event=self.event.slug.upper(), code=self.code)\n\n    def save(self, **kwargs):\n        if 'update_fields' in kwargs:\n            kwargs['update_fields'] = {'last_modified'}.union(kwargs['update_fields'])\n        if not self.code:\n            self.assign_code()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'code'}.union(kwargs['update_fields'])\n        if not self.datetime:\n            self.datetime = now()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'datetime'}.union(kwargs['update_fields'])\n        if not self.expires:\n            self.set_expires()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'expires'}.union(kwargs['update_fields'])\n\n        is_new = not self.pk\n        update_fields = kwargs.get('update_fields', [])\n        if 'require_approval' not in self.get_deferred_fields() and 'status' not in self.get_deferred_fields():\n            status_paid_or_pending = self.status in (Order.STATUS_PENDING, Order.STATUS_PAID) and not self.require_approval\n            if status_paid_or_pending != self.__initial_status_paid_or_pending:\n                _transactions_mark_order_dirty(self.pk, using=kwargs.get('using', None))\n        elif (\n            not kwargs.get('force_save_with_deferred_fields', None) and\n            (not update_fields or ('require_approval' not in update_fields and 'status' not in update_fields))\n        ):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        r = super().save(**kwargs)\n\n        if is_new:\n            _transactions_mark_order_dirty(self.pk, using=kwargs.get('using', None))\n\n        return r\n\n    def touch(self):\n        self.save(update_fields=['last_modified'])\n\n    def set_expires(self, now_dt=None, subevents=None):\n        now_dt = now_dt or now()\n        tz = ZoneInfo(self.event.settings.timezone)\n        mode = self.event.settings.get('payment_term_mode')\n        if mode == 'days':\n            exp_by_date = now_dt.astimezone(tz) + timedelta(days=self.event.settings.get('payment_term_days', as_type=int))\n            exp_by_date = exp_by_date.astimezone(tz).replace(hour=23, minute=59, second=59, microsecond=0)\n            if self.event.settings.get('payment_term_weekdays'):\n                if exp_by_date.weekday() == 5:\n                    exp_by_date += timedelta(days=2)\n                elif exp_by_date.weekday() == 6:\n                    exp_by_date += timedelta(days=1)\n        elif mode == 'minutes':\n            exp_by_date = now_dt.astimezone(tz) + timedelta(minutes=self.event.settings.get('payment_term_minutes', as_type=int))\n        else:\n            raise ValueError(\"'payment_term_mode' has an invalid value '{}'.\".format(mode))\n\n        self.expires = exp_by_date\n\n        term_last = self.event.settings.get('payment_term_last', as_type=RelativeDateWrapper)\n        if term_last:\n            if self.event.has_subevents and subevents:\n                terms = [\n                    term_last.datetime(se).date()\n                    for se in subevents\n                ]\n                if not terms:\n                    return\n                term_last = min(terms)\n            else:\n                term_last = term_last.datetime(self.event).date()\n            term_last = make_aware(datetime.combine(\n                term_last,\n                time(hour=23, minute=59, second=59)\n            ), tz)\n            if term_last < self.expires:\n                self.expires = term_last\n\n    @cached_property\n    def tax_total(self):\n        return (self.positions.aggregate(s=Sum('tax_value'))['s'] or 0) + (self.fees.aggregate(s=Sum('tax_value'))['s'] or 0)\n\n    @property\n    def net_total(self):\n        return self.total - self.tax_total\n\n    def cancel_allowed(self):\n        return (\n            self.status in (Order.STATUS_PENDING, Order.STATUS_PAID, Order.STATUS_EXPIRED) and self.count_positions\n        )\n\n    @cached_property\n    def user_change_deadline(self):\n        until = self.event.settings.get('change_allow_user_until', as_type=RelativeDateWrapper)\n        if until:\n            if self.event.has_subevents:\n                terms = [\n                    until.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                return min(terms) if terms else None\n            else:\n                return until.datetime(self.event)\n\n    @cached_property\n    def user_cancel_deadline(self):\n        if self.status == Order.STATUS_PAID and self.total != Decimal('0.00'):\n            until = self.event.settings.get('cancel_allow_user_paid_until', as_type=RelativeDateWrapper)\n        else:\n            until = self.event.settings.get('cancel_allow_user_until', as_type=RelativeDateWrapper)\n        if until:\n            if self.event.has_subevents:\n                terms = [\n                    until.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                return min(terms) if terms else None\n            else:\n                return until.datetime(self.event)\n\n    @cached_property\n    def user_cancel_fee(self):\n        fee = Decimal('0.00')\n        if self.status == Order.STATUS_PAID:\n            if self.event.settings.cancel_allow_user_paid_keep_fees:\n                fee += self.fees.filter(\n                    fee_type__in=(OrderFee.FEE_TYPE_PAYMENT, OrderFee.FEE_TYPE_SHIPPING, OrderFee.FEE_TYPE_SERVICE,\n                                  OrderFee.FEE_TYPE_CANCELLATION)\n                ).aggregate(\n                    s=Sum('value')\n                )['s'] or 0\n            if self.event.settings.cancel_allow_user_paid_keep_percentage:\n                fee += self.event.settings.cancel_allow_user_paid_keep_percentage / Decimal('100.0') * (self.total - fee)\n            if self.event.settings.cancel_allow_user_paid_keep:\n                fee += self.event.settings.cancel_allow_user_paid_keep\n        else:\n            if self.event.settings.cancel_allow_user_unpaid_keep_fees:\n                fee += self.fees.filter(\n                    fee_type__in=(OrderFee.FEE_TYPE_PAYMENT, OrderFee.FEE_TYPE_SHIPPING, OrderFee.FEE_TYPE_SERVICE,\n                                  OrderFee.FEE_TYPE_CANCELLATION)\n                ).aggregate(\n                    s=Sum('value')\n                )['s'] or 0\n            if self.event.settings.cancel_allow_user_unpaid_keep_percentage:\n                fee += self.event.settings.cancel_allow_user_unpaid_keep_percentage / Decimal('100.0') * (self.total - fee)\n            if self.event.settings.cancel_allow_user_unpaid_keep:\n                fee += self.event.settings.cancel_allow_user_unpaid_keep\n        return round_decimal(min(fee, self.total), self.event.currency)\n\n    @property\n    @scopes_disabled()\n    def user_change_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be canceled by the user.\n        \"\"\"\n        from .checkin import Checkin\n        from .items import ItemAddOn\n\n        if self.status not in (Order.STATUS_PENDING, Order.STATUS_PAID) or not self.count_positions:\n            return False\n\n        if self.cancellation_requests.exists():\n            return False\n\n        if self.require_approval:\n            return False\n\n        positions = list(\n            self.positions.all().annotate(\n                has_variations=Exists(ItemVariation.objects.filter(item_id=OuterRef('item_id'))),\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        if self.event.settings.change_allow_user_if_checked_in:\n            cancelable = all([op.item.allow_cancel for op in positions])\n        else:\n            cancelable = all([op.item.allow_cancel and not op.has_checkin for op in positions])\n        if not cancelable or not positions:\n            return False\n        for op in positions:\n            if op.issued_gift_cards.all():\n                return False\n        if self.user_change_deadline and now() > self.user_change_deadline:\n            return False\n\n        return (\n            (self.event.settings.change_allow_user_variation and any([op.has_variations for op in positions])) or\n            (self.event.settings.change_allow_user_addons and ItemAddOn.objects.filter(base_item_id__in=[op.item_id for op in positions]).exists())\n        )\n\n    @property\n    @scopes_disabled()\n    def user_cancel_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be canceled by the user.\n        \"\"\"\n        from .checkin import Checkin\n\n        if self.cancellation_requests.exists() or not self.cancel_allowed():\n            return False\n        positions = list(\n            self.positions.all().annotate(\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        cancelable = all([op.item.allow_cancel and not op.has_checkin and not op.blocked for op in positions])\n        if not cancelable or not positions:\n            return False\n        for op in positions:\n            for gc in op.issued_gift_cards.all():\n                if gc.value != op.price:\n                    return False\n            if op.granted_memberships.with_usages().filter(usages__gt=0):\n                return False\n        if self.user_cancel_deadline and now() > self.user_cancel_deadline:\n            return False\n\n        if self.status == Order.STATUS_PAID:\n            if self.total == Decimal('0.00'):\n                return self.event.settings.cancel_allow_user\n            return self.event.settings.cancel_allow_user_paid\n        elif self.payment_refund_sum > Decimal('0.00'):\n            return False\n        elif self.status == Order.STATUS_PENDING:\n            return self.event.settings.cancel_allow_user\n        return False\n\n    def propose_auto_refunds(self, amount: Decimal, payments: list=None):\n        # Algorithm to choose which payments are to be refunded to create the least hassle\n        payments = payments or self.payments.filter(state=OrderPayment.PAYMENT_STATE_CONFIRMED)\n        for p in payments:\n            if p.payment_provider:\n                p.full_refund_possible = p.payment_provider.payment_refund_supported(p)\n                p.partial_refund_possible = p.payment_provider.payment_partial_refund_supported(p)\n                p.propose_refund = Decimal('0.00')\n                p.available_amount = p.amount - p.refunded_amount\n            else:\n                p.full_refund_possible = False\n                p.partial_refund_possible = False\n                p.propose_refund = Decimal('0.00')\n                p.available_amount = Decimal('0.00')\n\n        unused_payments = set(p for p in payments if p.full_refund_possible or p.partial_refund_possible)\n        to_refund = amount\n        proposals = {}\n\n        while to_refund and unused_payments:\n            bigger = sorted([\n                p for p in unused_payments\n                if p.available_amount > to_refund\n                and p.partial_refund_possible\n            ], key=lambda p: p.available_amount)\n            same = [\n                p for p in unused_payments\n                if p.available_amount == to_refund\n                and (p.full_refund_possible or p.partial_refund_possible)\n            ]\n            smaller = sorted([\n                p for p in unused_payments\n                if p.available_amount < to_refund\n                and (p.full_refund_possible or p.partial_refund_possible)\n            ], key=lambda p: p.available_amount, reverse=True)\n            if same:\n                payment = same[0]\n                proposals[payment] = payment.available_amount\n                to_refund -= payment.available_amount\n                unused_payments.remove(payment)\n            elif bigger:\n                payment = bigger[0]\n                proposals[payment] = to_refund\n                to_refund -= to_refund\n                unused_payments.remove(payment)\n            elif smaller:\n                payment = smaller[0]\n                proposals[payment] = payment.available_amount\n                to_refund -= payment.available_amount\n                unused_payments.remove(payment)\n            else:\n                break\n        return proposals\n\n    @staticmethod\n    def normalize_code(code, is_fallback=False):\n        d = {\n            '2': 'Z',\n            '4': 'A',\n            '5': 'S',\n            '6': 'G',\n        }\n        if is_fallback:\n            d['8'] = 'B'\n            # 8 has been removed from the character set only in 2021, which means there are a lot of order codes\n            # with an 8 in it around. We only want to replace this when this is used in a fallback.\n        tr = str.maketrans(d)\n        return code.upper().translate(tr)\n\n    def assign_code(self):\n        # This omits some character pairs completely because they are hard to read even on screens (1/I and O/0)\n        # and includes only one of two characters for some pairs because they are sometimes hard to distinguish in\n        # handwriting (2/Z, 4/A, 5/S, 6/G, 8/B). This allows for better detection e.g. in incoming wire transfers that\n        # might include OCR'd handwritten text\n        charset = list('ABCDEFGHJKLMNPQRSTUVWXYZ379')\n        iteration = 0\n        length = settings.ENTROPY['order_code']\n        while True:\n            code = get_random_string(length=length, allowed_chars=charset)\n            iteration += 1\n\n            if banned(code):\n                continue\n\n            if self.testmode:\n                # Subtle way to recognize test orders while debugging: They all contain a 0 at the second place,\n                # even though zeros are not used outside test mode.\n                code = code[0] + \"0\" + code[2:]\n\n            if not Order.objects.filter(event__organizer=self.event.organizer, code=code).exists():\n                self.code = code\n                return\n\n            if iteration > 20:\n                # Safeguard: If we don't find an unused and non-banlisted code within 20 iterations, we increase\n                # the length.\n                length += 1\n                iteration = 0\n\n    @property\n    def modify_deadline(self):\n        modify_deadline = self.event.settings.get('last_order_modification_date', as_type=RelativeDateWrapper)\n        if self.event.has_subevents and modify_deadline:\n            dates = [\n                modify_deadline.datetime(se)\n                for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n            ]\n            return min(dates) if dates else None\n        elif modify_deadline:\n            return modify_deadline.datetime(self.event)\n        return None\n\n    @property\n    def can_modify_answers(self) -> bool:\n        \"\"\"\n        ``True`` if the user can change the question answers / attendee names that are\n        related to the order. This checks order status and modification deadlines. It also\n        returns ``False`` if there are no questions that can be answered.\n        \"\"\"\n        from .checkin import Checkin\n\n        if self.status not in (Order.STATUS_PENDING, Order.STATUS_PAID, Order.STATUS_EXPIRED):\n            return False\n\n        modify_deadline = self.modify_deadline\n        if modify_deadline is not None and now() > modify_deadline:\n            return False\n\n        positions = list(\n            self.positions.all().annotate(\n                has_checkin=Exists(Checkin.objects.filter(position_id=OuterRef('pk')))\n            ).select_related('item').prefetch_related('item__questions')\n        )\n        if not self.event.settings.allow_modifications_after_checkin:\n            for cp in positions:\n                if cp.has_checkin:\n                    return False\n\n        if self.event.settings.get('invoice_address_asked', as_type=bool):\n            return True\n        ask_names = self.event.settings.get('attendee_names_asked', as_type=bool)\n        for cp in positions:\n            if (cp.item.ask_attendee_data and ask_names) or cp.item.questions.all():\n                return True\n\n        return False  # nothing there to modify\n\n    @property\n    def is_expired_by_time(self):\n        return (\n            self.status == Order.STATUS_PENDING and not self.require_approval and self.expires < now()\n            and not self.event.settings.get('payment_term_expire_automatically')\n        )\n\n    @property\n    def ticket_download_date(self):\n        \"\"\"\n        Returns the first date the tickets for this order can be downloaded or ``None`` if there is no\n        restriction.\n        \"\"\"\n        dl_date = self.event.settings.get('ticket_download_date', as_type=RelativeDateWrapper)\n        if dl_date:\n            if self.event.has_subevents:\n                dates = [\n                    dl_date.datetime(se)\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                dl_date = min(dates) if dates else None\n            else:\n                dl_date = dl_date.datetime(self.event)\n        return dl_date\n\n    @property\n    def ticket_download_available(self):\n        return self.event.settings.ticket_download and (\n            self.event.settings.ticket_download_date is None\n            or self.ticket_download_date is None\n            or now() > self.ticket_download_date\n        ) and (\n            self.status == Order.STATUS_PAID\n            or (\n                (self.valid_if_pending or self.event.settings.ticket_download_pending) and\n                self.status == Order.STATUS_PENDING and\n                not self.require_approval\n            )\n        )\n\n    @property\n    def payment_term_last(self):\n        tz = ZoneInfo(self.event.settings.timezone)\n        term_last = self.event.settings.get('payment_term_last', as_type=RelativeDateWrapper)\n        if term_last:\n            if self.event.has_subevents:\n                terms = [\n                    term_last.datetime(se).date()\n                    for se in self.event.subevents.filter(id__in=self.positions.values_list('subevent', flat=True))\n                ]\n                if terms:\n                    term_last = min(terms)\n                else:\n                    return None\n            else:\n                term_last = term_last.datetime(self.event).date()\n            term_last = make_aware(datetime.combine(\n                term_last,\n                time(hour=23, minute=59, second=59)\n            ), tz)\n        return term_last\n\n    @property\n    def payment_term_expire_date(self):\n        delay = self.event.settings.get('payment_term_expire_delay_days', as_type=int)\n        if not delay:  # performance saver + backwards compatibility\n            return self.expires\n\n        term_last = self.payment_term_last\n        if term_last and self.expires > term_last:  # backwards compatibility\n            return self.expires\n\n        expires = self.expires.date() + timedelta(days=delay)\n        if self.event.settings.get('payment_term_weekdays'):\n            if expires.weekday() == 5:\n                expires += timedelta(days=2)\n            elif expires.weekday() == 6:\n                expires += timedelta(days=1)\n\n        tz = ZoneInfo(self.event.settings.timezone)\n        expires = make_aware(datetime.combine(\n            expires,\n            time(hour=23, minute=59, second=59)\n        ), tz)\n        if term_last:\n            return min(expires, term_last)\n        else:\n            return expires\n\n    def _can_be_paid(self, count_waitinglist=True, ignore_date=False, force=False) -> Union[bool, str]:\n        error_messages = {\n            'late_lastdate': _(\"The payment can not be accepted as the last date of payments configured in the \"\n                               \"payment settings is over.\"),\n            'late': _(\"The payment can not be accepted as the order is expired and you configured that no late \"\n                      \"payments should be accepted in the payment settings.\"),\n            'require_approval': _('This order is not yet approved by the event organizer.')\n        }\n        if not force:\n            if self.require_approval:\n                return error_messages['require_approval']\n            term_last = self.payment_term_last\n            if term_last and not ignore_date:\n                if now() > term_last:\n                    return error_messages['late_lastdate']\n\n        if self.status == self.STATUS_PENDING:\n            return True\n        if not self.event.settings.get('payment_term_accept_late') and not ignore_date and not force:\n            return error_messages['late']\n\n        return self._is_still_available(count_waitinglist=count_waitinglist, force=force)\n\n    def _is_still_available(self, now_dt: datetime=None, count_waitinglist=True, force=False,\n                            check_voucher_usage=False, check_memberships=False) -> Union[bool, str]:\n        from pretix.base.services.memberships import (\n            validate_memberships_in_order,\n        )\n\n        error_messages = {\n            'unavailable': _('The ordered product \"{item}\" is no longer available.'),\n            'seat_unavailable': _('The seat \"{seat}\" is no longer available.'),\n            'voucher_budget': _('The voucher \"{voucher}\" no longer has sufficient budget.'),\n            'voucher_usages': _('The voucher \"{voucher}\" has been used in the meantime.'),\n        }\n        now_dt = now_dt or now()\n        positions = list(self.positions.all().select_related('item', 'variation', 'seat', 'voucher'))\n        quota_cache = {}\n        v_budget = {}\n        v_usage = Counter()\n        try:\n            if check_memberships:\n                try:\n                    validate_memberships_in_order(self.customer, positions, self.event, lock=False, testmode=self.testmode)\n                except ValidationError as e:\n                    raise Quota.QuotaExceededException(e.message)\n\n            for i, op in enumerate(positions):\n                if op.seat:\n                    if not op.seat.is_available(ignore_orderpos=op):\n                        raise Quota.QuotaExceededException(error_messages['seat_unavailable'].format(seat=op.seat))\n                if force:\n                    continue\n\n                if op.voucher and op.voucher.budget is not None and op.voucher_budget_use:\n                    if op.voucher not in v_budget:\n                        v_budget[op.voucher] = op.voucher.budget - op.voucher.budget_used()\n                    disc = op.voucher_budget_use\n                    if disc > v_budget[op.voucher]:\n                        raise Quota.QuotaExceededException(error_messages['voucher_budget'].format(\n                            voucher=op.voucher.code\n                        ))\n                    v_budget[op.voucher] -= disc\n\n                if op.voucher and check_voucher_usage:\n                    v_usage[op.voucher.pk] += 1\n                    if v_usage[op.voucher.pk] + op.voucher.redeemed > op.voucher.max_usages:\n                        raise Quota.QuotaExceededException(error_messages['voucher_usages'].format(\n                            voucher=op.voucher.code\n                        ))\n\n                quotas = list(op.quotas)\n                if len(quotas) == 0:\n                    raise Quota.QuotaExceededException(error_messages['unavailable'].format(\n                        item=str(op.item) + (' - ' + str(op.variation) if op.variation else '')\n                    ))\n\n                for quota in quotas:\n                    if quota.id not in quota_cache:\n                        quota_cache[quota.id] = quota\n                        quota.cached_availability = quota.availability(now_dt, count_waitinglist=count_waitinglist)[1]\n                    else:\n                        # Use cached version\n                        quota = quota_cache[quota.id]\n                    if quota.cached_availability is not None:\n                        quota.cached_availability -= 1\n                        if quota.cached_availability < 0:\n                            # This quota is sold out/currently unavailable, so do not sell this at all\n                            raise Quota.QuotaExceededException(error_messages['unavailable'].format(\n                                item=str(op.item) + (' - ' + str(op.variation) if op.variation else '')\n                            ))\n        except Quota.QuotaExceededException as e:\n            return str(e)\n        return True\n\n    def send_mail(self, subject: Union[str, LazyI18nString], template: Union[str, LazyI18nString],\n                  context: Dict[str, Any]=None, log_entry_type: str='pretix.event.order.email.sent',\n                  user: User=None, headers: dict=None, sender: str=None, invoices: list=None,\n                  auth=None, attach_tickets=False, position: 'OrderPosition'=None, auto_email=True,\n                  attach_ical=False, attach_other_files: list=None, attach_cached_files: list=None):\n        \"\"\"\n        Sends an email to the user that placed this order. Basically, this method does two things:\n\n        * Call ``pretix.base.services.mail.mail`` with useful values for the ``event``, ``locale``, ``recipient`` and\n          ``order`` parameters.\n\n        * Create a ``LogEntry`` with the email contents.\n\n        :param subject: Subject of the email\n        :param template: LazyI18nString or template filename, see ``pretix.base.services.mail.mail`` for more details\n        :param context: Dictionary to use for rendering the template\n        :param log_entry_type: Key to be used for the log entry\n        :param user: Administrative user who triggered this mail to be sent\n        :param headers: Dictionary with additional mail headers\n        :param sender: Custom email sender.\n        :param attach_tickets: Attach tickets of this order, if they are existing and ready to download\n        :param attach_ical: Attach relevant ICS files\n        :param position: An order position this refers to. If given, no invoices will be attached, the tickets will\n                         only be attached for this position and child positions, the link will only point to the\n                         position and the attendee email will be used if available.\n        \"\"\"\n        from pretix.base.services.mail import (\n            SendMailException, mail, render_mail,\n        )\n\n        if not self.email and not (position and position.attendee_email):\n            return\n\n        for k, v in self.event.meta_data.items():\n            context['meta_' + k] = v\n\n        with language(self.locale, self.event.settings.region):\n            recipient = self.email\n            if position and position.attendee_email:\n                recipient = position.attendee_email\n\n            try:\n                email_content = render_mail(template, context)\n                subject = format_map(subject, context)\n                mail(\n                    recipient, subject, template, context,\n                    self.event, self.locale, self, headers=headers, sender=sender,\n                    invoices=invoices, attach_tickets=attach_tickets,\n                    position=position, auto_email=auto_email, attach_ical=attach_ical,\n                    attach_other_files=attach_other_files, attach_cached_files=attach_cached_files,\n                )\n            except SendMailException:\n                raise\n            else:\n                self.log_action(\n                    log_entry_type,\n                    user=user,\n                    auth=auth,\n                    data={\n                        'subject': subject,\n                        'message': email_content,\n                        'position': position.positionid if position else None,\n                        'recipient': recipient,\n                        'invoices': [i.pk for i in invoices] if invoices else [],\n                        'attach_tickets': attach_tickets,\n                        'attach_ical': attach_ical,\n                    }\n                )\n\n    def resend_link(self, user=None, auth=None):\n        with language(self.locale, self.event.settings.region):\n            email_template = self.event.settings.mail_text_resend_link\n            email_context = get_email_context(event=self.event, order=self)\n            email_subject = self.event.settings.mail_subject_resend_link\n            self.send_mail(\n                email_subject, email_template, email_context,\n                'pretix.event.order.email.resend', user=user, auth=auth,\n                attach_tickets=True,\n            )\n\n    @property\n    def positions_with_tickets(self):\n        for op in self.positions.select_related('item'):\n            if not op.generate_ticket:\n                continue\n            yield op\n\n    def create_transactions(self, is_new=False, positions=None, fees=None, dt_now=None, migrated=False,\n                            _backfill_before_cancellation=False, save=True):\n        dt_now = dt_now or now()\n\n        # Count the transactions we already have\n        current_transaction_count = Counter()\n        if not is_new:\n            for t in Transaction.objects.filter(order=self):  # do not use related manager, we want to avoid cached data\n                current_transaction_count[Transaction.key(t)] += t.count\n\n        # Count the transactions we'd actually need\n        target_transaction_count = Counter()\n        if (_backfill_before_cancellation or self.status in (Order.STATUS_PENDING, Order.STATUS_PAID)) and not self.require_approval:\n            positions = self.positions.all() if positions is None else positions\n            for p in positions:\n                if p.canceled and not _backfill_before_cancellation:\n                    continue\n                target_transaction_count[Transaction.key(p)] += 1\n                p._transaction_key_reset()\n\n            fees = self.fees.all() if fees is None else fees\n            for f in fees:\n                if f.canceled and not _backfill_before_cancellation:\n                    continue\n                target_transaction_count[Transaction.key(f)] += 1\n                f._transaction_key_reset()\n\n        keys = set(target_transaction_count.keys()) | set(current_transaction_count.keys())\n        create = []\n        for k in keys:\n            positionid, itemid, variationid, subeventid, price, taxrate, taxruleid, taxvalue, feetype, internaltype = k\n            d = target_transaction_count[k] - current_transaction_count[k]\n            if d:\n                create.append(Transaction(\n                    order=self,\n                    datetime=dt_now,\n                    migrated=migrated,\n                    positionid=positionid,\n                    count=d,\n                    item_id=itemid,\n                    variation_id=variationid,\n                    subevent_id=subeventid,\n                    price=price,\n                    tax_rate=taxrate,\n                    tax_rule_id=taxruleid,\n                    tax_value=taxvalue,\n                    fee_type=feetype,\n                    internal_type=internaltype,\n                ))\n        create.sort(key=lambda t: (0 if t.count < 0 else 1, t.positionid or 0))\n        if save:\n            Transaction.objects.bulk_create(create)\n        self._transaction_key_reset()\n        _transactions_mark_order_clean(self.pk)\n        return create\n\n\ndef answerfile_name(instance, filename: str) -> str:\n    secret = get_random_string(length=32, allowed_chars=string.ascii_letters + string.digits)\n    event = (instance.cartposition if instance.cartposition else instance.orderposition.order).event\n    return 'cachedfiles/answers/{org}/{ev}/{secret}.{filename}'.format(\n        org=event.organizer.slug,\n        ev=event.slug,\n        secret=secret,\n        filename=escape_uri_path(filename),\n    )\n\n\nclass QuestionAnswer(models.Model):\n    \"\"\"\n    The answer to a Question, connected to an OrderPosition or CartPosition.\n\n    :param orderposition: The order position this is related to, or null if this is\n                          related to a cart position.\n    :type orderposition: OrderPosition\n    :param cartposition: The cart position this is related to, or null if this is related\n                         to an order position.\n    :type cartposition: CartPosition\n    :param question: The question this is an answer for\n    :type question: Question\n    :param answer: The actual answer data\n    :type answer: str\n    \"\"\"\n    orderposition = models.ForeignKey(\n        'OrderPosition', null=True, blank=True,\n        related_name='answers', on_delete=models.CASCADE\n    )\n    cartposition = models.ForeignKey(\n        'CartPosition', null=True, blank=True,\n        related_name='answers', on_delete=models.CASCADE\n    )\n    question = models.ForeignKey(\n        Question, related_name='answers', on_delete=models.CASCADE\n    )\n    options = models.ManyToManyField(\n        QuestionOption, related_name='answers', blank=True\n    )\n    answer = models.TextField()\n    file = models.FileField(\n        null=True, blank=True, upload_to=answerfile_name,\n        max_length=255\n    )\n\n    objects = ScopedManager(organizer='question__event__organizer')\n\n    class Meta:\n        unique_together = [['orderposition', 'question'], ['cartposition', 'question']]\n\n    @property\n    def backend_file_url(self):\n        if self.file:\n            if self.orderposition:\n                return reverse('control:event.order.download.answer', kwargs={\n                    'code': self.orderposition.order.code,\n                    'event': self.orderposition.order.event.slug,\n                    'organizer': self.orderposition.order.event.organizer.slug,\n                    'answer': self.pk,\n                })\n        return \"\"\n\n    @property\n    def frontend_file_url(self):\n        from pretix.multidomain.urlreverse import eventreverse\n\n        if self.file:\n            if self.orderposition:\n                url = eventreverse(self.orderposition.order.event, 'presale:event.order.download.answer', kwargs={\n                    'order': self.orderposition.order.code,\n                    'secret': self.orderposition.order.secret,\n                    'answer': self.pk,\n                })\n            else:\n                url = eventreverse(self.cartposition.event, 'presale:event.cart.download.answer', kwargs={\n                    'answer': self.pk,\n                })\n\n            return url\n        return \"\"\n\n    @property\n    def is_image(self):\n        return any(self.file.name.lower().endswith(e) for e in settings.FILE_UPLOAD_EXTENSIONS_QUESTION_IMAGE)\n\n    @property\n    def file_name(self):\n        return self.file.name.split('.', 1)[-1]\n\n    def __str__(self):\n        if self.question.type == Question.TYPE_BOOLEAN and self.answer == \"True\":\n            return str(_(\"Yes\"))\n        elif self.question.type == Question.TYPE_BOOLEAN and self.answer == \"False\":\n            return str(_(\"No\"))\n        elif self.question.type == Question.TYPE_FILE:\n            return str(_(\"<file>\"))\n        elif self.question.type == Question.TYPE_DATETIME and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                if self.orderposition:\n                    tz = ZoneInfo(self.orderposition.order.event.settings.timezone)\n                    d = d.astimezone(tz)\n                return date_format(d, \"SHORT_DATETIME_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_DATE and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                return date_format(d, \"SHORT_DATE_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_TIME and self.answer:\n            try:\n                d = dateutil.parser.parse(self.answer)\n                return date_format(d, \"TIME_FORMAT\")\n            except ValueError:\n                return self.answer\n        elif self.question.type == Question.TYPE_COUNTRYCODE and self.answer:\n            return Country(self.answer).name or self.answer\n        elif self.question.type == Question.TYPE_PHONENUMBER and self.answer:\n            try:\n                return PhoneNumber.from_string(self.answer).as_international\n            except NumberParseException:\n                return self.answer\n        else:\n            return self.answer\n\n    def save(self, *args, **kwargs):\n        if self.orderposition and self.cartposition:\n            raise ValueError('QuestionAnswer cannot be linked to an order and a cart position at the same time.')\n        if self.orderposition:\n            self.orderposition.order.touch()\n        super().save(*args, **kwargs)\n\n    def delete(self, **kwargs):\n        if self.orderposition:\n            self.orderposition.order.touch()\n        super().delete(**kwargs)\n\n\nclass AbstractPosition(models.Model):\n    \"\"\"\n    A position can either be one line of an order or an item placed in a cart.\n\n    :param subevent: The date in the event series, if event series are enabled\n    :type subevent: SubEvent\n    :param item: The selected item\n    :type item: Item\n    :param variation: The selected ItemVariation or null, if the item has no variations\n    :type variation: ItemVariation\n    :param datetime: The datetime this item was put into the cart\n    :type datetime: datetime\n    :param expires: The date until this item is guaranteed to be reserved\n    :type expires: datetime\n    :param price: The price of this item\n    :type price: decimal.Decimal\n    :param attendee_name_parts: The parts of the attendee's name, if entered.\n    :type attendee_name_parts: str\n    :param attendee_name_cached: The concatenated version of the attendee's name, if entered.\n    :type attendee_name_cached: str\n    :param attendee_email: The attendee's email, if entered.\n    :type attendee_email: str\n    :param voucher: A voucher that has been applied to this sale\n    :type voucher: Voucher\n    :param meta_info: Additional meta information on the position, JSON-encoded.\n    :type meta_info: str\n    :param seat: Seat, if reserved seating is used.\n    :type seat: Seat\n    \"\"\"\n    subevent = models.ForeignKey(\n        SubEvent,\n        null=True, blank=True,\n        on_delete=models.PROTECT,\n        verbose_name=pgettext_lazy(\"subevent\", \"Date\"),\n    )\n    item = models.ForeignKey(\n        Item,\n        verbose_name=_(\"Item\"),\n        on_delete=models.PROTECT\n    )\n    variation = models.ForeignKey(\n        ItemVariation,\n        null=True, blank=True,\n        verbose_name=_(\"Variation\"),\n        on_delete=models.PROTECT\n    )\n    price = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Price\")\n    )\n    attendee_name_cached = models.CharField(\n        max_length=255,\n        verbose_name=_(\"Attendee name\"),\n        blank=True, null=True,\n        help_text=_(\"Empty, if this product is not an admission ticket\")\n    )\n    attendee_name_parts = models.JSONField(\n        blank=True, default=dict\n    )\n    attendee_email = models.EmailField(\n        verbose_name=_(\"Attendee email\"),\n        blank=True, null=True,\n        help_text=_(\"Empty, if this product is not an admission ticket\")\n    )\n    voucher = models.ForeignKey(\n        'Voucher', null=True, blank=True, on_delete=models.PROTECT\n    )\n    used_membership = models.ForeignKey(\n        'Membership', null=True, blank=True, on_delete=models.PROTECT\n    )\n    addon_to = models.ForeignKey(\n        'self', null=True, blank=True, on_delete=models.PROTECT, related_name='addons'\n    )\n    meta_info = models.TextField(\n        verbose_name=_(\"Meta information\"),\n        null=True, blank=True\n    )\n    seat = models.ForeignKey(\n        'Seat', null=True, blank=True, on_delete=models.PROTECT\n    )\n    is_bundled = models.BooleanField(default=False)\n\n    discount = models.ForeignKey(\n        'Discount', null=True, blank=True, on_delete=models.RESTRICT\n    )\n\n    company = models.CharField(max_length=255, blank=True, verbose_name=_('Company name'), null=True)\n    street = models.TextField(verbose_name=_('Address'), blank=True, null=True)\n    zipcode = models.CharField(max_length=30, verbose_name=_('ZIP code'), blank=True, null=True)\n    city = models.CharField(max_length=255, verbose_name=_('City'), blank=True, null=True)\n    country = FastCountryField(verbose_name=_('Country'), blank=True, blank_label=_('Select country'), null=True)\n    state = models.CharField(max_length=255, verbose_name=pgettext_lazy('address', 'State'), blank=True, null=True)\n\n    class Meta:\n        abstract = True\n\n    @property\n    def meta_info_data(self):\n        if self.meta_info:\n            return json.loads(self.meta_info)\n        else:\n            return {}\n\n    @property\n    def item_and_variation(self):\n        return self.item, self.variation\n\n    @meta_info_data.setter\n    def meta_info_data(self, d):\n        self.meta_info = json.dumps(d)\n\n    def cache_answers(self, all=True):\n        \"\"\"\n        Creates two properties on the object.\n        (1) answ: a dictionary of question.id \u2192 answer string\n        (2) questions: a list of Question objects, extended by an 'answer' property\n        \"\"\"\n        self.answ = {}\n        for a in getattr(self, 'answerlist', self.answers.all()):  # use prefetch_related cache from get_cart\n            self.answ[a.question_id] = a\n\n        # We need to clone our question objects, otherwise we will override the cached\n        # answers of other items in the same cart if the question objects have been\n        # selected via prefetch_related\n        if not all:\n            if hasattr(self.item, 'questions_to_ask'):\n                questions = list(copy.copy(q) for q in self.item.questions_to_ask)\n            else:\n                questions = list(copy.copy(q) for q in self.item.questions.filter(ask_during_checkin=False,\n                                                                                  hidden=False))\n        else:\n            questions = list(copy.copy(q) for q in self.item.questions.all())\n\n        question_cache = {\n            q.pk: q for q in questions\n        }\n\n        def question_is_visible(parentid, qvals):\n            if parentid not in question_cache:\n                return False\n            parentq = question_cache[parentid]\n            if parentq.dependency_question_id and not question_is_visible(parentq.dependency_question_id, parentq.dependency_values):\n                return False\n            if parentid not in self.answ:\n                return False\n            return (\n                ('True' in qvals and self.answ[parentid].answer == 'True')\n                or ('False' in qvals and self.answ[parentid].answer == 'False')\n                or (any(qval in [o.identifier for o in self.answ[parentid].options.all()] for qval in qvals))\n            )\n\n        self.questions = []\n        for q in questions:\n            if q.id in self.answ:\n                q.answer = self.answ[q.id]\n                q.answer.question = q  # cache object\n            else:\n                q.answer = \"\"\n            if not q.dependency_question_id or question_is_visible(q.dependency_question_id, q.dependency_values):\n                self.questions.append(q)\n\n    @property\n    def net_price(self):\n        return self.price - self.tax_value\n\n    @property\n    def quotas(self):\n        return (self.item.quotas.filter(subevent=self.subevent)\n                if self.variation is None\n                else self.variation.quotas.filter(subevent=self.subevent))\n\n    def save(self, *args, **kwargs):\n        update_fields = kwargs.get('update_fields', set())\n        if 'attendee_name_parts' in update_fields:\n            kwargs['update_fields'] = {'attendee_name_cached'}.union(kwargs['update_fields'])\n\n        name = self.attendee_name\n        if name != self.attendee_name_cached:\n            self.attendee_name_cached = name\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'attendee_name_cached'}.union(kwargs['update_fields'])\n\n        if self.attendee_name_parts is None:\n            self.attendee_name_parts = {}\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'attendee_name_parts'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n    @property\n    def attendee_name(self):\n        return build_name(self.attendee_name_parts, fallback_scheme=lambda: self.event.settings.name_scheme)\n\n    @property\n    def attendee_name_all_components(self):\n        return build_name(self.attendee_name_parts, \"concatenation_all_components\", fallback_scheme=lambda: self.event.settings.name_scheme)\n\n    @property\n    def state_name(self):\n        sd = pycountry.subdivisions.get(code='{}-{}'.format(self.country, self.state))\n        if sd:\n            return sd.name\n        return self.state\n\n    @property\n    def state_for_address(self):\n        from pretix.base.settings import COUNTRIES_WITH_STATE_IN_ADDRESS\n        if not self.state or str(self.country) not in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            return \"\"\n        if COUNTRIES_WITH_STATE_IN_ADDRESS[str(self.country)][1] == 'long':\n            return self.state_name\n        return self.state\n\n    def address_format(self):\n        lines = [\n            self.attendee_name,\n            self.company,\n            self.street,\n            (self.zipcode or '') + ' ' + (self.city or '') + ' ' + (self.state_for_address or ''),\n            self.country.name\n        ]\n        lines = [r.strip() for r in lines if r]\n        return '\\n'.join(lines).strip()\n\n    def requires_approval(self, invoice_address=None):\n        if self.item.require_approval:\n            return True\n        if self.variation and self.variation.require_approval:\n            return True\n        if self.item.tax_rule and self.item.tax_rule._require_approval(invoice_address):\n            return True\n        return False\n\n\nclass OrderPayment(models.Model):\n    \"\"\"\n    Represents a payment or payment attempt for an order.\n\n\n    :param id: A globally unique ID for this payment\n    :type id:\n    :param local_id: An ID of this payment, counting from one for every order independently.\n    :type local_id: int\n    :param state: The state of the payment, one of ``created``, ``pending``, ``confirmed``, ``failed``,\n      ``canceled``, or ``refunded``.\n    :type state: str\n    :param amount: The payment amount\n    :type amount: Decimal\n    :param order: The order that is paid\n    :type order: Order\n    :param created: The creation time of this record\n    :type created: datetime\n    :param payment_date: The completion time of this payment\n    :type payment_date: datetime\n    :param provider: The payment provider in use\n    :type provider: str\n    :param info: Provider-specific meta information (in JSON format)\n    :type info: str\n    :param fee: The ``OrderFee`` object used to track the fee for this order.\n    :type fee: pretix.base.models.OrderFee\n    :param process_initiated: Only for internal use inside pretix.presale to check which payments have started\n                              the execution process.\n    :type process_initiated: bool\n    \"\"\"\n    PAYMENT_STATE_CREATED = 'created'\n    PAYMENT_STATE_PENDING = 'pending'\n    PAYMENT_STATE_CONFIRMED = 'confirmed'\n    PAYMENT_STATE_FAILED = 'failed'\n    PAYMENT_STATE_CANCELED = 'canceled'\n    PAYMENT_STATE_REFUNDED = 'refunded'\n\n    PAYMENT_STATES = (\n        (PAYMENT_STATE_CREATED, pgettext_lazy('payment_state', 'created')),\n        (PAYMENT_STATE_PENDING, pgettext_lazy('payment_state', 'pending')),\n        (PAYMENT_STATE_CONFIRMED, pgettext_lazy('payment_state', 'confirmed')),\n        (PAYMENT_STATE_CANCELED, pgettext_lazy('payment_state', 'canceled')),\n        (PAYMENT_STATE_FAILED, pgettext_lazy('payment_state', 'failed')),\n        (PAYMENT_STATE_REFUNDED, pgettext_lazy('payment_state', 'refunded')),\n    )\n    local_id = models.PositiveIntegerField()\n    state = models.CharField(\n        max_length=190, choices=PAYMENT_STATES\n    )\n    amount = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Amount\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='payments',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True\n    )\n    payment_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    provider = models.CharField(\n        null=True, blank=True,\n        max_length=255,\n        verbose_name=_(\"Payment provider\")\n    )\n    info = models.TextField(\n        verbose_name=_(\"Payment information\"),\n        null=True, blank=True\n    )\n    fee = models.ForeignKey(\n        'OrderFee',\n        null=True, blank=True, related_name='payments', on_delete=models.SET_NULL\n    )\n    migrated = models.BooleanField(default=False)\n    process_initiated = models.BooleanField(\n        null=True  # null = created before this field was introduced\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n\n    class Meta:\n        ordering = ('local_id',)\n\n    def __str__(self):\n        return self.full_id\n\n    @property\n    def info_data(self):\n        \"\"\"\n        This property allows convenient access to the data stored in the ``info``\n        attribute by automatically encoding and decoding the content as JSON.\n        \"\"\"\n        return json.loads(self.info) if self.info else {}\n\n    @info_data.setter\n    def info_data(self, d):\n        self.info = json.dumps(d, sort_keys=True)\n\n    @cached_property\n    def payment_provider(self):\n        \"\"\"\n        Cached access to an instance of the payment provider in use.\n        \"\"\"\n        return self.order.event.get_payment_providers(cached=True).get(self.provider)\n\n    @transaction.atomic()\n    def _mark_paid_inner(self, force, count_waitinglist, user, auth, ignore_date=False, overpaid=False):\n        from pretix.base.signals import order_paid\n        can_be_paid = self.order._can_be_paid(count_waitinglist=count_waitinglist, ignore_date=ignore_date, force=force)\n        if can_be_paid is not True:\n            self.order.log_action('pretix.event.order.quotaexceeded', {\n                'message': can_be_paid\n            }, user=user, auth=auth)\n            raise Quota.QuotaExceededException(can_be_paid)\n        status_change = self.order.status != Order.STATUS_PENDING\n        self.order.status = Order.STATUS_PAID\n        self.order.save(update_fields=['status'])\n\n        self.order.log_action('pretix.event.order.paid', {\n            'provider': self.provider,\n            'info': self.info,\n            'date': self.payment_date,\n            'force': force\n        }, user=user, auth=auth)\n\n        if overpaid:\n            self.order.log_action('pretix.event.order.overpaid', {}, user=user, auth=auth)\n        order_paid.send(self.order.event, order=self.order)\n        if status_change:\n            self.order.create_transactions()\n\n    def fail(self, info=None, user=None, auth=None, log_data=None, send_mail=True):\n        \"\"\"\n        Marks the order as failed and sets info to ``info``, but only if the order is in ``created`` or ``pending``\n        state. This is equivalent to setting ``state`` to ``OrderPayment.PAYMENT_STATE_FAILED`` and logging a failure,\n        but it adds strong database logging since we do not want to report a failure for an order that has just\n        been marked as paid.\n        :param send_mail: Whether an email should be sent to the user about this event (default: ``True``).\n        \"\"\"\n        with transaction.atomic():\n            locked_instance = OrderPayment.objects.select_for_update(of=OF_SELF).get(pk=self.pk)\n            if locked_instance.state not in (OrderPayment.PAYMENT_STATE_CREATED, OrderPayment.PAYMENT_STATE_PENDING):\n                # Race condition detected, this payment is already confirmed\n                logger.info('Failed payment {} but ignored due to likely race condition.'.format(\n                    self.full_id,\n                ))\n                return False\n\n            if isinstance(info, str):\n                locked_instance.info = info\n            elif info:\n                locked_instance.info_data = info\n            locked_instance.state = OrderPayment.PAYMENT_STATE_FAILED\n            locked_instance.save(update_fields=['state', 'info'])\n\n        self.refresh_from_db()\n        self.order.log_action('pretix.event.order.payment.failed', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n            'info': info,\n            'data': log_data,\n        }, user=user, auth=auth)\n\n        if send_mail:\n            with language(self.order.locale, self.order.event.settings.region):\n                email_subject = self.order.event.settings.mail_subject_order_payment_failed\n                email_template = self.order.event.settings.mail_text_order_payment_failed\n                email_context = get_email_context(event=self.order.event, order=self.order)\n                self.order.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.payment_failed', user=user, auth=auth,\n                )\n\n        return True\n\n    def confirm(self, count_waitinglist=True, send_mail=True, force=False, user=None, auth=None, mail_text='',\n                ignore_date=False, lock=True, payment_date=None, generate_invoice=True):\n        \"\"\"\n        Marks the payment as complete. If possible, this also marks the order as paid if no further\n        payment is required\n\n        :param count_waitinglist: Whether, when calculating quota, people on the waiting list should be taken into\n                                  consideration (default: ``True``).\n        :type count_waitinglist: boolean\n        :param force: Whether this payment should be marked as paid even if no remaining\n                      quota is available (default: ``False``).\n        :param ignore_date: Whether this order should be marked as paid even when the last date of payments is over.\n        :type force: boolean\n        :param send_mail: Whether an email should be sent to the user about this event (default: ``True``).\n        :type send_mail: boolean\n        :param user: The user who performed the change\n        :param auth: The API auth token that performed the change\n        :param mail_text: Additional text to be included in the email\n        :type mail_text: str\n        :raises Quota.QuotaExceededException: if the quota is exceeded and ``force`` is ``False``\n        \"\"\"\n        with transaction.atomic():\n            locked_instance = OrderPayment.objects.select_for_update(of=OF_SELF).get(pk=self.pk)\n            if locked_instance.state == self.PAYMENT_STATE_CONFIRMED:\n                # Race condition detected, this payment is already confirmed\n                logger.info('Confirmed payment {} but ignored due to likely race condition.'.format(\n                    self.full_id,\n                ))\n                return\n\n            locked_instance.state = self.PAYMENT_STATE_CONFIRMED\n            locked_instance.payment_date = payment_date or now()\n            locked_instance.info = self.info  # required for backwards compatibility\n            locked_instance.save(update_fields=['state', 'payment_date', 'info'])\n\n            # Do a cheap manual \"refresh from db\" on non-complex fields\n            for field in self._meta.concrete_fields:\n                if not field.is_relation:\n                    setattr(self, field.attname, getattr(locked_instance, field.attname))\n\n        self.refresh_from_db()\n\n        self.order.log_action('pretix.event.order.payment.confirmed', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n        }, user=user, auth=auth)\n\n        if self.order.status in (Order.STATUS_PAID, Order.STATUS_CANCELED):\n            logger.info('Confirmed payment {} but order is in status {}.'.format(self.full_id, self.order.status))\n            return\n\n        payment_sum = self.order.payments.filter(\n            state__in=(self.PAYMENT_STATE_CONFIRMED, self.PAYMENT_STATE_REFUNDED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        refund_sum = self.order.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n        if payment_sum - refund_sum < self.order.total:\n            logger.info('Confirmed payment {} but payment sum is {} and refund sum is {}.'.format(\n                self.full_id, payment_sum, refund_sum\n            ))\n            return\n\n        self._mark_order_paid(count_waitinglist, send_mail, force, user, auth, mail_text, ignore_date, lock, payment_sum - refund_sum,\n                              generate_invoice)\n\n    def _mark_order_paid(self, count_waitinglist=True, send_mail=True, force=False, user=None, auth=None, mail_text='',\n                         ignore_date=False, lock=True, payment_refund_sum=0, allow_generate_invoice=True):\n        from pretix.base.services.invoices import (\n            generate_invoice, invoice_qualified,\n        )\n\n        if (self.order.status == Order.STATUS_PENDING and self.order.expires > now() + timedelta(seconds=LOCK_TIMEOUT * 2)) or not lock:\n            # Performance optimization. In this case, there's really no reason to lock everything and an atomic\n            # database transaction is more than enough.\n            lockfn = NoLockManager\n        else:\n            lockfn = self.order.event.lock\n\n        with lockfn():\n            self._mark_paid_inner(force, count_waitinglist, user, auth, overpaid=payment_refund_sum > self.order.total,\n                                  ignore_date=ignore_date)\n\n        invoice = None\n        if invoice_qualified(self.order) and allow_generate_invoice:\n            invoices = self.order.invoices.filter(is_cancellation=False).count()\n            cancellations = self.order.invoices.filter(is_cancellation=True).count()\n            gen_invoice = (\n                (invoices == 0 and self.order.event.settings.get('invoice_generate') in ('True', 'paid')) or\n                0 < invoices <= cancellations\n            )\n            if gen_invoice:\n                invoice = generate_invoice(\n                    self.order,\n                    trigger_pdf=not send_mail or not self.order.event.settings.invoice_email_attachment\n                )\n\n        if send_mail and self.order.sales_channel in self.order.event.settings.mail_sales_channel_placed_paid:\n            self._send_paid_mail(invoice, user, mail_text)\n            if self.order.event.settings.mail_send_order_paid_attendee:\n                for p in self.order.positions.all():\n                    if p.addon_to_id is None and p.attendee_email and p.attendee_email != self.order.email:\n                        self._send_paid_mail_attendee(p, user)\n\n    def _send_paid_mail_attendee(self, position, user):\n        from pretix.base.services.mail import SendMailException\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.order.event.settings.mail_text_order_paid_attendee\n            email_subject = self.order.event.settings.mail_subject_order_paid_attendee\n            email_context = get_email_context(event=self.order.event, order=self.order, position=position)\n            try:\n                position.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.order_paid', user,\n                    invoices=[],\n                    attach_tickets=True,\n                    attach_ical=self.order.event.settings.mail_attach_ical\n                )\n            except SendMailException:\n                logger.exception('Order paid email could not be sent')\n\n    def _send_paid_mail(self, invoice, user, mail_text):\n        from pretix.base.services.mail import SendMailException\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.order.event.settings.mail_text_order_paid\n            email_subject = self.order.event.settings.mail_subject_order_paid\n            email_context = get_email_context(event=self.order.event, order=self.order, payment_info=mail_text)\n            try:\n                self.order.send_mail(\n                    email_subject, email_template, email_context,\n                    'pretix.event.order.email.order_paid', user,\n                    invoices=[invoice] if invoice and self.order.event.settings.invoice_email_attachment else [],\n                    attach_tickets=True,\n                    attach_ical=self.order.event.settings.mail_attach_ical\n                )\n            except SendMailException:\n                logger.exception('Order paid email could not be sent')\n\n    @property\n    def refunded_amount(self):\n        \"\"\"\n        The sum of all refund amounts in ``done``, ``transit``, or ``created`` states associated\n        with this payment.\n        \"\"\"\n        return self.refunds.filter(\n            state__in=(OrderRefund.REFUND_STATE_DONE, OrderRefund.REFUND_STATE_TRANSIT,\n                       OrderRefund.REFUND_STATE_CREATED)\n        ).aggregate(s=Sum('amount'))['s'] or Decimal('0.00')\n\n    @property\n    def full_id(self):\n        \"\"\"\n        The full human-readable ID of this payment, constructed by the order code and the ``local_id``\n        field with ``-P-`` in between.\n        :return:\n        \"\"\"\n        return '{}-P-{}'.format(self.order.code, self.local_id)\n\n    def save(self, *args, **kwargs):\n        if not self.local_id:\n            self.local_id = (self.order.payments.aggregate(m=Max('local_id'))['m'] or 0) + 1\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'local_id'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n    def create_external_refund(self, amount=None, execution_date=None, info='{}'):\n        \"\"\"\n        This should be called to create an OrderRefund object when a refund has triggered\n        by an external source, e.g. when a credit card payment has been refunded by the\n        credit card provider.\n\n        :param amount: Amount to refund. If not given, the full payment amount will be used.\n        :type amount: Decimal\n        :param execution_date: Date of the refund. Defaults to the current time.\n        :type execution_date: datetime\n        :param info: Additional information, defaults to ``\"{}\"``.\n        :type info: str\n        :return: OrderRefund\n        \"\"\"\n        r = self.order.refunds.create(\n            state=OrderRefund.REFUND_STATE_EXTERNAL,\n            source=OrderRefund.REFUND_SOURCE_EXTERNAL,\n            amount=amount if amount is not None else self.amount,\n            order=self.order,\n            payment=self,\n            execution_date=execution_date or now(),\n            provider=self.provider,\n            info=info\n        )\n        self.order.log_action('pretix.event.order.refund.created.externally', {\n            'local_id': r.local_id,\n            'provider': r.provider,\n        })\n\n        if self.order.pending_sum + r.amount == Decimal('0.00'):\n            r.done()\n\n        return r\n\n\nclass OrderRefund(models.Model):\n    \"\"\"\n    Represents a refund or refund attempt for an order.\n\n    :param id: A globally unique ID for this refund\n    :type id:\n    :param local_id: An ID of this refund, counting from one for every order independently.\n    :type local_id: int\n    :param state: The state of the refund, one of ``created``, ``transit``, ``external``, ``canceled``,\n      ``failed``, or ``done``.\n    :type state: str\n    :param source: How this refund was started, one of ``buyer``, ``admin``, or ``external``.\n    :param amount: The refund amount\n    :type amount: Decimal\n    :param order: The order that is refunded\n    :type order: Order\n    :param created: The creation time of this record\n    :type created: datetime\n    :param execution_date: The completion time of this refund\n    :type execution_date: datetime\n    :param provider: The payment provider in use\n    :type provider: str\n    :param info: Provider-specific meta information in JSON format\n    :type info: dict\n    \"\"\"\n    # REFUND_STATE_REQUESTED = 'requested'\n    # REFUND_STATE_APPROVED = 'approved'\n    REFUND_STATE_EXTERNAL = 'external'\n    REFUND_STATE_TRANSIT = 'transit'\n    REFUND_STATE_DONE = 'done'\n    # REFUND_STATE_REJECTED = 'rejected'\n    REFUND_STATE_CANCELED = 'canceled'\n    REFUND_STATE_CREATED = 'created'\n    REFUND_STATE_FAILED = 'failed'\n\n    REFUND_STATES = (\n        # (REFUND_STATE_REQUESTED, pgettext_lazy('refund_state', 'requested')),\n        # (REFUND_STATE_APPROVED, pgettext_lazy('refund_state', 'approved')),\n        (REFUND_STATE_EXTERNAL, pgettext_lazy('refund_state', 'started externally')),\n        (REFUND_STATE_CREATED, pgettext_lazy('refund_state', 'created')),\n        (REFUND_STATE_TRANSIT, pgettext_lazy('refund_state', 'in transit')),\n        (REFUND_STATE_DONE, pgettext_lazy('refund_state', 'done')),\n        (REFUND_STATE_FAILED, pgettext_lazy('refund_state', 'failed')),\n        # (REFUND_STATE_REJECTED, pgettext_lazy('refund_state', 'rejected')),\n        (REFUND_STATE_CANCELED, pgettext_lazy('refund_state', 'canceled')),\n    )\n\n    REFUND_SOURCE_BUYER = 'buyer'\n    REFUND_SOURCE_ADMIN = 'admin'\n    REFUND_SOURCE_EXTERNAL = 'external'\n\n    REFUND_SOURCES = (\n        (REFUND_SOURCE_ADMIN, pgettext_lazy('refund_source', 'Organizer')),\n        (REFUND_SOURCE_BUYER, pgettext_lazy('refund_source', 'Customer')),\n        (REFUND_SOURCE_EXTERNAL, pgettext_lazy('refund_source', 'External')),\n    )\n\n    local_id = models.PositiveIntegerField()\n    state = models.CharField(\n        max_length=190, choices=REFUND_STATES\n    )\n    source = models.CharField(\n        max_length=190, choices=REFUND_SOURCES\n    )\n    amount = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Amount\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='refunds',\n        on_delete=models.PROTECT\n    )\n    payment = models.ForeignKey(\n        OrderPayment,\n        null=True, blank=True,\n        related_name='refunds',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True\n    )\n    execution_date = models.DateTimeField(\n        null=True, blank=True\n    )\n    provider = models.CharField(\n        null=True, blank=True,\n        max_length=255,\n        verbose_name=_(\"Payment provider\")\n    )\n    comment = models.TextField(\n        verbose_name=_(\"Refund reason\"),\n        help_text=_('May be shown to the end user or used e.g. as part of a payment reference.'),\n        null=True, blank=True\n    )\n    info = models.TextField(\n        verbose_name=_(\"Payment information\"),\n        null=True, blank=True\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n\n    class Meta:\n        ordering = ('local_id',)\n\n    def __str__(self):\n        return self.full_id\n\n    @property\n    def info_data(self):\n        \"\"\"\n        This property allows convenient access to the data stored in the ``info``\n        attribute by automatically encoding and decoding the content as JSON.\n        \"\"\"\n        return json.loads(self.info) if self.info else {}\n\n    @info_data.setter\n    def info_data(self, d):\n        self.info = json.dumps(d, sort_keys=True)\n\n    @cached_property\n    def payment_provider(self):\n        \"\"\"\n        Cached access to an instance of the payment provider in use.\n        \"\"\"\n        return self.order.event.get_payment_providers().get(self.provider)\n\n    @transaction.atomic\n    def done(self, user=None, auth=None):\n        \"\"\"\n        Marks the refund as complete. This does not modify the state of the order.\n\n        :param user: The user who performed the change\n        :param auth: The API auth token that performed the change\n        \"\"\"\n        self.state = self.REFUND_STATE_DONE\n        self.execution_date = self.execution_date or now()\n        self.save()\n\n        self.order.log_action('pretix.event.order.refund.done', {\n            'local_id': self.local_id,\n            'provider': self.provider,\n        }, user=user, auth=auth)\n\n        if self.payment and self.payment.refunded_amount >= self.payment.amount:\n            self.payment.state = OrderPayment.PAYMENT_STATE_REFUNDED\n            self.payment.save(update_fields=['state'])\n\n    @property\n    def full_id(self):\n        \"\"\"\n        The full human-readable ID of this refund, constructed by the order code and the ``local_id``\n        field with ``-R-`` in between.\n        :return:\n        \"\"\"\n        return '{}-R-{}'.format(self.order.code, self.local_id)\n\n    def save(self, *args, **kwargs):\n        if not self.local_id:\n            self.local_id = (self.order.refunds.aggregate(m=Max('local_id'))['m'] or 0) + 1\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'local_id'}.union(kwargs['update_fields'])\n        super().save(*args, **kwargs)\n\n\nclass ActivePositionManager(ScopedManager(organizer='order__event__organizer').__class__):\n    def get_queryset(self):\n        return super().get_queryset().filter(canceled=False)\n\n\nclass OrderFee(models.Model):\n    \"\"\"\n    An OrderFee object represents a fee that is added to the order total independently of\n    the actual positions. This might for example be a payment or a shipping fee.\n\n    The default ``OrderFee.objects`` manager only contains fees that are not ``canceled``. If\n    you ant all objects, you need to use ``OrderFee.all`` instead.\n\n    :param value: Gross price of this fee\n    :type value: Decimal\n    :param order: Order this fee is charged with\n    :type order: Order\n    :param fee_type: The type of the fee, currently ``payment``, ``shipping``, ``service``, ``giftcard``, or ``other``.\n    :type fee_type: str\n    :param description: A human-readable description of the fee\n    :type description: str\n    :param internal_type: An internal string to group fees by, e.g. the identifier string of a payment provider\n    :type internal_type: str\n    :param tax_rate: The tax rate applied to this fee\n    :type tax_rate: Decimal\n    :param tax_rule: The tax rule applied to this fee\n    :type tax_rule: TaxRule\n    :param tax_value: The tax amount included in the price\n    :type tax_value: Decimal\n    :param canceled: True, if this position is canceled and should no longer be regarded\n    :type canceled: bool\n    \"\"\"\n    FEE_TYPE_PAYMENT = \"payment\"\n    FEE_TYPE_SHIPPING = \"shipping\"\n    FEE_TYPE_SERVICE = \"service\"\n    FEE_TYPE_CANCELLATION = \"cancellation\"\n    FEE_TYPE_INSURANCE = \"insurance\"\n    FEE_TYPE_OTHER = \"other\"\n    FEE_TYPE_GIFTCARD = \"giftcard\"\n    FEE_TYPES = (\n        (FEE_TYPE_PAYMENT, _(\"Payment fee\")),\n        (FEE_TYPE_SHIPPING, _(\"Shipping fee\")),\n        (FEE_TYPE_SERVICE, _(\"Service fee\")),\n        (FEE_TYPE_CANCELLATION, _(\"Cancellation fee\")),\n        (FEE_TYPE_INSURANCE, _(\"Insurance fee\")),\n        (FEE_TYPE_OTHER, _(\"Other fees\")),\n        (FEE_TYPE_GIFTCARD, _(\"Gift card\")),\n    )\n\n    value = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Value\")\n    )\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='all_fees',\n        on_delete=models.PROTECT\n    )\n    fee_type = models.CharField(\n        max_length=100, choices=FEE_TYPES\n    )\n    description = models.CharField(max_length=190, blank=True)\n    internal_type = models.CharField(max_length=255, blank=True)\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n    canceled = models.BooleanField(default=False)\n\n    all = ScopedManager(organizer='order__event__organizer')\n    objects = ActivePositionManager()\n\n    @property\n    def net_value(self):\n        return self.value - self.tax_value\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def refresh_from_db(self, using=None, fields=None):\n        \"\"\"\n        Reload field values from the database. Similar to django's implementation\n        with adjustment for our method that forces us to create ``Transaction`` instances.\n        \"\"\"\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n        return super().refresh_from_db(using, fields)\n\n    def _transaction_key_reset(self):\n        self.__initial_transaction_key = Transaction.key(self)\n        self.__initial_canceled = self.canceled\n\n    def __str__(self):\n        if self.description:\n            return '{} - {}'.format(self.get_fee_type_display(), self.description)\n        else:\n            return self.get_fee_type_display()\n\n    def __repr__(self):\n        return '<OrderFee: type %s, value %d>' % (\n            self.fee_type, self.value\n        )\n\n    def _calculate_tax(self, tax_rule=None):\n        if tax_rule:\n            self.tax_rule = tax_rule\n\n        try:\n            ia = self.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = None\n\n        if not self.tax_rule and self.fee_type == \"payment\" and self.order.event.settings.tax_rate_default:\n            self.tax_rule = self.order.event.settings.tax_rate_default\n\n        if self.tax_rule:\n            tax = self.tax_rule.tax(self.value, base_price_is='gross', invoice_address=ia, force_fixed_gross_price=True)\n            self.tax_rate = tax.rate\n            self.tax_value = tax.tax\n        else:\n            self.tax_value = Decimal('0.00')\n            self.tax_rate = Decimal('0.00')\n\n    def save(self, *args, **kwargs):\n        if self.tax_rule and not self.tax_rule.rate and not self.tax_rule.pk:\n            self.tax_rule = None\n\n        if self.tax_rate is None:\n            self._calculate_tax()\n        self.order.touch()\n\n        if not self.get_deferred_fields():\n            if Transaction.key(self) != self.__initial_transaction_key or self.canceled != self.__initial_canceled or not self.pk:\n                _transactions_mark_order_dirty(self.order_id, using=kwargs.get('using', None))\n        elif not kwargs.get('force_save_with_deferred_fields', None):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        return super().save(*args, **kwargs)\n\n    def delete(self, **kwargs):\n        self.order.touch()\n        super().delete(**kwargs)\n\n\nclass OrderPosition(AbstractPosition):\n    \"\"\"\n    An OrderPosition is one line of an order, representing one ordered item\n    of a specified type (or variation). This has all properties of\n    AbstractPosition.\n\n    The default ``OrderPosition.objects`` manager only contains fees that are not ``canceled``. If\n    you want all objects, you need to use ``OrderPosition.all`` instead.\n\n    :param order: The order this position is a part of\n    :type order: Order\n    :param positionid: A local ID of this position, counted for each order individually\n    :type positionid: int\n    :param tax_rate: The tax rate applied to this position\n    :type tax_rate: Decimal\n    :param tax_rule: The tax rule applied to this position\n    :type tax_rule: TaxRule\n    :param tax_value: The tax amount included in the price\n    :type tax_value: Decimal\n    :param secret: The secret used for ticket QR codes\n    :type secret: str\n    :param canceled: True, if this position is canceled and should no longer be regarded\n    :type canceled: bool\n    :param pseudonymization_id: The QR code content for lead scanning\n    :type pseudonymization_id: str\n    :param blocked: A list of reasons why this order position is blocked. Blocked positions can't be used for check-in and\n                    other purposes. Each entry should be a short string that can be translated into a human-readable\n                    description by a plugin. If the position is not blocked, the value must be ``None``, not an empty\n                    list.\n    :type blocked: list\n    :param ignore_from_quota_while_blocked: Ignore this order position from quota, as long as ``blocked`` is set. Only\n                                            to be used carefully by specific plugins.\n    :type ignore_from_quota_while_blocked: boolean\n    :param valid_from: The ticket will not be considered valid before this date. If the value is ``None``, no check on\n                       ticket level is made.\n    :type valid_from: datetime\n    :param valid_until: The ticket will not be considered valid after this date. If the value is ``None``, no check on\n                       ticket level is made.\n    :type valid_until: datetime\n    \"\"\"\n    positionid = models.PositiveIntegerField(default=1)\n\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='all_positions',\n        on_delete=models.PROTECT\n    )\n\n    voucher_budget_use = models.DecimalField(\n        max_digits=13, decimal_places=2, null=True, blank=True,\n    )\n\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n\n    secret = models.CharField(max_length=255, null=False, blank=False, db_index=True)\n    web_secret = models.CharField(max_length=32, default=generate_secret, db_index=True)\n    pseudonymization_id = models.CharField(\n        max_length=16,\n        unique=True,\n        db_index=True\n    )\n\n    canceled = models.BooleanField(default=False)\n\n    blocked = models.JSONField(null=True, blank=True)\n    ignore_from_quota_while_blocked = models.BooleanField(default=False)\n    valid_from = models.DateTimeField(\n        verbose_name=_(\"Valid from\"),\n        null=True,\n        blank=True,\n    )\n    valid_until = models.DateTimeField(\n        verbose_name=_(\"Valid until\"),\n        null=True,\n        blank=True,\n    )\n\n    all = ScopedManager(organizer='order__event__organizer')\n    objects = ActivePositionManager()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n\n    def refresh_from_db(self, using=None, fields=None):\n        \"\"\"\n        Reload field values from the database. Similar to django's implementation\n        with adjustment for our method that forces us to create ``Transaction`` instances.\n        \"\"\"\n        if not self.get_deferred_fields():\n            self._transaction_key_reset()\n        return super().refresh_from_db(using, fields)\n\n    def _transaction_key_reset(self):\n        self.__initial_transaction_key = Transaction.key(self)\n        self.__initial_canceled = self.canceled\n\n    class Meta:\n        verbose_name = _(\"Order position\")\n        verbose_name_plural = _(\"Order positions\")\n        ordering = (\"positionid\", \"id\")\n\n    @cached_property\n    def sort_key(self):\n        return self.addon_to.positionid if self.addon_to else self.positionid, self.addon_to_id or 0, self.positionid\n\n    @cached_property\n    def require_checkin_attention(self):\n        if self.order.checkin_attention or self.item.checkin_attention or (self.variation_id and self.variation.checkin_attention):\n            return True\n        return False\n\n    @property\n    def checkins(self):\n        \"\"\"\n        Related manager for all successful checkins. Use ``all_checkins`` instead if you want\n        canceled positions as well.\n        \"\"\"\n        return self.all_checkins(manager='objects')\n\n    @property\n    def generate_ticket(self):\n        if self.item.generate_tickets is not None:\n            return self.item.generate_tickets\n        if self.blocked:\n            return False\n        return (\n            (self.order.event.settings.ticket_download_addons or not self.addon_to_id) and\n            (self.event.settings.ticket_download_nonadm or self.item.admission)\n        )\n\n    @property\n    def blocked_reasons(self):\n        from ..signals import orderposition_blocked_display\n\n        if not self.blocked:\n            return []\n\n        reasons = {}\n        for b in self.blocked:\n            for recv, response in orderposition_blocked_display.send(self.event, orderposition=self, block_name=b):\n                if response:\n                    reasons[b] = response\n                    break\n            else:\n                reasons[b] = b\n        return reasons\n\n    @classmethod\n    def transform_cart_positions(cls, cp: List, order) -> list:\n        from . import Voucher\n\n        ops = []\n        cp_mapping = {}\n        # The sorting key ensures that all addons come directly after the position they refer to\n        for i, cartpos in enumerate(sorted(cp, key=lambda c: c.sort_key)):\n            op = OrderPosition(order=order)\n            for f in AbstractPosition._meta.fields:\n                if f.name == 'addon_to':\n                    setattr(op, f.name, cp_mapping.get(cartpos.addon_to_id))\n                else:\n                    setattr(op, f.name, getattr(cartpos, f.name))\n            op._calculate_tax()\n            if cartpos.voucher:\n                op.voucher_budget_use = cartpos.listed_price - cartpos.price_after_voucher\n\n            if cartpos.item.validity_mode:\n                valid_from, valid_until = cartpos.item.compute_validity(\n                    requested_start=(\n                        max(cartpos.requested_valid_from, now())\n                        if cartpos.requested_valid_from and cartpos.item.validity_dynamic_start_choice\n                        else now()\n                    ),\n                    enforce_start_limit=True,\n                    override_tz=order.event.timezone,\n                )\n                op.valid_from = valid_from\n                op.valid_until = valid_until\n\n            op.positionid = i + 1\n            op.save()\n            ops.append(op)\n            cp_mapping[cartpos.pk] = op\n            for answ in cartpos.answers.all():\n                answ.orderposition = op\n                answ.cartposition = None\n                answ.save()\n            if cartpos.voucher:\n                Voucher.objects.filter(pk=cartpos.voucher.pk).update(redeemed=F('redeemed') + 1)\n                cartpos.voucher.log_action('pretix.voucher.redeemed', {\n                    'order_code': order.code\n                })\n\n        # Delete afterwards. Deleting in between might cause deletion of things related to add-ons\n        # due to the deletion cascade.\n        for cartpos in cp:\n            if cartpos.pk:\n                cartpos.addons.all().delete()\n                cartpos.delete()\n        return ops\n\n    def __str__(self):\n        if self.variation:\n            return '#{} \u2013 {} \u2013 {}'.format(\n                self.positionid, str(self.item), str(self.variation)\n            )\n        return '#{} \u2013 {}'.format(self.positionid, str(self.item))\n\n    def __repr__(self):\n        return '<OrderPosition: item %d, variation %d for order %s>' % (\n            self.item.id, self.variation.id if self.variation else 0, self.order_id\n        )\n\n    def _calculate_tax(self, tax_rule=None):\n        self.tax_rule = tax_rule or self.item.tax_rule\n        try:\n            ia = self.order.invoice_address\n        except InvoiceAddress.DoesNotExist:\n            ia = None\n        if self.tax_rule:\n            tax = self.tax_rule.tax(self.price, invoice_address=ia, base_price_is='gross', force_fixed_gross_price=True)\n            self.tax_rate = tax.rate\n            self.tax_value = tax.tax\n            if tax.gross != self.price:\n                raise ValueError('Invalid tax calculation')\n        else:\n            self.tax_value = Decimal('0.00')\n            self.tax_rate = Decimal('0.00')\n\n    def save(self, *args, **kwargs):\n        from pretix.base.secrets import assign_ticket_secret\n\n        if self.tax_rate is None:\n            self._calculate_tax()\n\n        self.order.touch()\n        if not self.pk:\n            while not self.secret or OrderPosition.all.filter(\n                secret=self.secret, order__event__organizer_id=self.order.event.organizer_id\n            ).exists():\n                assign_ticket_secret(\n                    event=self.order.event, position=self, force_invalidate=True, save=False\n                )\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'secret'}.union(kwargs['update_fields'])\n\n        if not self.blocked and self.blocked is not None:\n            self.blocked = None\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'blocked'}.union(kwargs['update_fields'])\n        elif self.blocked and (not isinstance(self.blocked, list) or any(not isinstance(b, str) for b in self.blocked)):\n            raise TypeError(\"blocked needs to be a list of strings\")\n\n        if not self.pseudonymization_id:\n            self.assign_pseudonymization_id()\n            if 'update_fields' in kwargs:\n                kwargs['update_fields'] = {'pseudonymization_id'}.union(kwargs['update_fields'])\n\n        if not self.get_deferred_fields():\n            if Transaction.key(self) != self.__initial_transaction_key or self.canceled != self.__initial_canceled or not self.pk:\n                _transactions_mark_order_dirty(self.order_id, using=kwargs.get('using', None))\n        elif not kwargs.get('force_save_with_deferred_fields', None):\n            _fail(\"It is unsafe to call save() on an OrderFee with deferred fields since we can't check if you missed \"\n                  \"creating a transaction. Call save(force_save_with_deferred_fields=True) if you really want to do \"\n                  \"this.\")\n\n        return super().save(*args, **kwargs)\n\n    @scopes_disabled()\n    def assign_pseudonymization_id(self):\n        # This omits some character pairs completely because they are hard to read even on screens (1/I and O/0)\n        # and includes only one of two characters for some pairs because they are sometimes hard to distinguish in\n        # handwriting (2/Z, 4/A, 5/S, 6/G). This allows for better detection e.g. in incoming wire transfers that\n        # might include OCR'd handwritten text\n        charset = list('ABCDEFGHJKLMNPQRSTUVWXYZ3789')\n        while True:\n            code = get_random_string(length=10, allowed_chars=charset)\n            with scopes_disabled():\n                if not OrderPosition.all.filter(pseudonymization_id=code).exists():\n                    self.pseudonymization_id = code\n                    return\n\n    @property\n    def event(self):\n        return self.order.event\n\n    def send_mail(self, subject: str, template: Union[str, LazyI18nString],\n                  context: Dict[str, Any]=None, log_entry_type: str='pretix.event.order.email.sent',\n                  user: User=None, headers: dict=None, sender: str=None, invoices: list=None,\n                  auth=None, attach_tickets=False, attach_ical=False, attach_other_files: list=None):\n        \"\"\"\n        Sends an email to the attendee. Basically, this method does two things:\n\n        * Call ``pretix.base.services.mail.mail`` with useful values for the ``event``, ``locale``, ``recipient`` and\n          ``order`` parameters.\n\n        * Create a ``LogEntry`` with the email contents.\n\n        :param subject: Subject of the email\n        :param template: LazyI18nString or template filename, see ``pretix.base.services.mail.mail`` for more details\n        :param context: Dictionary to use for rendering the template\n        :param log_entry_type: Key to be used for the log entry\n        :param user: Administrative user who triggered this mail to be sent\n        :param headers: Dictionary with additional mail headers\n        :param sender: Custom email sender.\n        :param attach_tickets: Attach tickets of this order, if they are existing and ready to download\n        :param attach_ical: Attach relevant ICS files\n        \"\"\"\n        from pretix.base.services.mail import (\n            SendMailException, mail, render_mail,\n        )\n\n        if not self.attendee_email:\n            return\n\n        for k, v in self.event.meta_data.items():\n            context['meta_' + k] = v\n\n        with language(self.order.locale, self.order.event.settings.region):\n            recipient = self.attendee_email\n            try:\n                email_content = render_mail(template, context)\n                subject = format_map(subject, context)\n                mail(\n                    recipient, subject, template, context,\n                    self.event, self.order.locale, order=self.order, headers=headers, sender=sender,\n                    position=self,\n                    invoices=invoices,\n                    attach_tickets=attach_tickets,\n                    attach_ical=attach_ical,\n                    attach_other_files=attach_other_files,\n                )\n            except SendMailException:\n                raise\n            else:\n                self.order.log_action(\n                    log_entry_type,\n                    user=user,\n                    auth=auth,\n                    data={\n                        'subject': subject,\n                        'message': email_content,\n                        'recipient': recipient,\n                        'invoices': [i.pk for i in invoices] if invoices else [],\n                        'attach_tickets': attach_tickets,\n                        'attach_ical': attach_ical,\n                    }\n                )\n\n    def resend_link(self, user=None, auth=None):\n\n        with language(self.order.locale, self.order.event.settings.region):\n            email_template = self.event.settings.mail_text_resend_link\n            email_context = get_email_context(event=self.order.event, order=self.order, position=self)\n            email_subject = self.event.settings.mail_subject_resend_link\n            self.send_mail(\n                email_subject, email_template, email_context,\n                'pretix.event.order.email.resend', user=user, auth=auth,\n                attach_tickets=True\n            )\n\n    @property\n    @scopes_disabled()\n    def attendee_change_allowed(self) -> bool:\n        \"\"\"\n        Returns whether or not this order can be changed by the attendee.\n        \"\"\"\n        from .items import ItemAddOn\n\n        if not self.event.settings.change_allow_attendee or not self.order.user_change_allowed:\n            return False\n\n        positions = list(\n            self.order.positions.filter(Q(pk=self.pk) | Q(addon_to_id=self.pk)).annotate(\n                has_variations=Exists(ItemVariation.objects.filter(item_id=OuterRef('item_id'))),\n            ).select_related('item').prefetch_related('issued_gift_cards')\n        )\n        return (\n            (self.order.event.settings.change_allow_user_variation and any([op.has_variations for op in positions])) or\n            (self.order.event.settings.change_allow_user_addons and ItemAddOn.objects.filter(base_item_id__in=[op.item_id for op in positions]).exists())\n        )\n\n\nclass Transaction(models.Model):\n    \"\"\"\n    Transactions are a data structure that is redundant on the first sight but makes it possible to create good\n    financial reporting.\n\n    To understand this, think of \"orders\" as something like a contractual relationship between the organizer and the\n    customer which requires to customer to pay some money and the organizer to provide a ticket.\n\n    The ``Order``, ``OrderPosition``, and ``OrderFee`` models combined give a representation of the current contractual\n    status of this relationship, i.e. how much and what is owed. The ``OrderPayment`` and ``OrderRefund`` models indicate\n    the \"other side\" of the relationship, i.e. how much of the financial obligation has been met so far.\n\n    However, while ``OrderPayment`` and ``OrderRefund`` objects are \"final\" and no longer change once they reached their\n    final state, ``Order``, ``OrderPosition`` and ``OrderFee`` are highly mutable and can change at any time, e.g. if\n    the customer moves their booking to a different day or a discount is applied retroactively.\n\n    Therefore those models can be used to answer the question \"how many tickets of type X have been sold for my event\n    as of today?\" but they cannot accurately answer the question \"how many tickets of type X have been sold for my event\n    as of last month?\" because they lack this kind of historical information.\n\n    Transactions help here because they are \"immutable copies\" or \"modification records\" of call positions and fees\n    at the time of their creation and change. They only record data that is usually relevant for financial reporting,\n    such as amounts, prices, products and dates involved. They do not record data like attendee names etc.\n\n    Even before the introduction of the Transaction Model pretix *did* store historical data for auditability in the\n    LogEntry model. However, it's almost impossible to do efficient reporting on that data.\n\n    Transactions should never be generated manually but only through the ``order.create_transactions()``\n    method which should be called **within the same database transaction**.\n\n    The big downside of this approach is that you need to remember to update transaction records every time you change\n    or create orders in new code paths. The mechanism introduced in ``pretix.base.models._transactions`` as well as\n    the ``save()`` methods of ``Order``, ``OrderPosition`` and ``OrderFee`` intends to help you notice if you missed\n    it. The only thing this *doesn't* catch is usage of ``OrderPosition.objects.bulk_create`` (and likewise for\n    ``bulk_update`` and ``OrderFee``).\n\n    :param id: ID of the transaction\n    :param order: Order the transaction belongs to\n    :param datetime: Date and time of the transaction\n    :param migrated: Whether this object was reconstructed because the order was created before transactions where introduced\n    :param positionid: Affected Position ID, in case this transaction represents a change in an order position\n    :param count: An amount, multiplicator for price etc. For order positions this can *currently* only be -1 or +1, for\n                  fees it can also be more in special cases\n    :param item: ``Item``, in case this transaction represents a change in an order position\n    :param variation: ``ItemVariation``, in case this transaction represents a change in an order position\n    :param subevent: ``subevent``, in case this transaction represents a change in an order position\n    :param price: Price of the changed position\n    :param tax_rate: Tax rate of the changed position\n    :param tax_rule: Used tax rule\n    :param tax_value: Tax value in event currency\n    :param fee_type: Fee type code in case this transaction represents a change in an order fee\n    :param internal_type: Internal fee type in case this transaction represents a change in an order fee\n    \"\"\"\n    id = models.BigAutoField(primary_key=True)\n    order = models.ForeignKey(\n        Order,\n        verbose_name=_(\"Order\"),\n        related_name='transactions',\n        on_delete=models.PROTECT\n    )\n    created = models.DateTimeField(\n        auto_now_add=True,\n        db_index=True,\n    )\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"),\n    )\n    migrated = models.BooleanField(\n        default=False\n    )\n    positionid = models.PositiveIntegerField(default=1, null=True, blank=True)\n    count = models.IntegerField(\n        default=1\n    )\n    item = models.ForeignKey(\n        Item,\n        null=True, blank=True,\n        verbose_name=_(\"Item\"),\n        on_delete=models.PROTECT\n    )\n    variation = models.ForeignKey(\n        ItemVariation,\n        null=True, blank=True,\n        verbose_name=_(\"Variation\"),\n        on_delete=models.PROTECT\n    )\n    subevent = models.ForeignKey(\n        SubEvent,\n        null=True, blank=True,\n        on_delete=models.PROTECT,\n        verbose_name=pgettext_lazy(\"subevent\", \"Date\"),\n    )\n    price = models.DecimalField(\n        decimal_places=2, max_digits=13,\n        verbose_name=_(\"Price\")\n    )\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2,\n        verbose_name=_('Tax rate')\n    )\n    tax_rule = models.ForeignKey(\n        'TaxRule',\n        on_delete=models.PROTECT,\n        null=True, blank=True\n    )\n    tax_value = models.DecimalField(\n        max_digits=13, decimal_places=2,\n        verbose_name=_('Tax value')\n    )\n    fee_type = models.CharField(\n        max_length=100, choices=OrderFee.FEE_TYPES, null=True, blank=True\n    )\n    internal_type = models.CharField(max_length=255, null=True, blank=True)\n\n    class Meta:\n        ordering = 'datetime', 'pk'\n        index_together = [\n            ['datetime', 'id']\n        ]\n\n    def save(self, *args, **kwargs):\n        if not self.fee_type and not self.item:\n            raise ValidationError('Should set either item or fee type')\n        return super().save(*args, **kwargs)\n\n    @staticmethod\n    def key(obj):\n        if isinstance(obj, Transaction):\n            return (obj.positionid, obj.item_id, obj.variation_id, obj.subevent_id, obj.price, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, obj.fee_type, obj.internal_type)\n        elif isinstance(obj, OrderPosition):\n            return (obj.positionid, obj.item_id, obj.variation_id, obj.subevent_id, obj.price, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, None, None)\n        elif isinstance(obj, OrderFee):\n            return (None, None, None, None, obj.value, obj.tax_rate,\n                    obj.tax_rule_id, obj.tax_value, obj.fee_type, obj.internal_type)\n        raise ValueError('invalid state')  # noqa\n\n    @property\n    def full_price(self):\n        return self.price * self.count\n\n    @property\n    def full_tax_value(self):\n        return self.tax_value * self.count\n\n\nclass CartPosition(AbstractPosition):\n    \"\"\"\n    A cart position is similar to an order line, except that it is not\n    yet part of a binding order but just placed by some user in his or\n    her cart. It therefore normally has a much shorter expiration time\n    than an ordered position, but still blocks an item in the quota pool\n    as we do not want to throw out users while they're clicking through\n    the checkout process. This has all properties of AbstractPosition.\n\n    :param event: The event this belongs to\n    :type event: Event\n    :param cart_id: The user session that contains this cart position\n    :type cart_id: str\n    \"\"\"\n    event = models.ForeignKey(\n        Event,\n        verbose_name=_(\"Event\"),\n        on_delete=models.CASCADE\n    )\n    cart_id = models.CharField(\n        max_length=255, null=True, blank=True, db_index=True,\n        verbose_name=_(\"Cart ID (e.g. session key)\")\n    )\n    datetime = models.DateTimeField(\n        verbose_name=_(\"Date\"),\n        auto_now_add=True\n    )\n    expires = models.DateTimeField(\n        verbose_name=_(\"Expiration date\"),\n        db_index=True\n    )\n\n    tax_rate = models.DecimalField(\n        max_digits=7, decimal_places=2, default=Decimal('0.00'),\n        verbose_name=_('Tax rate')\n    )\n    listed_price = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    price_after_voucher = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    custom_price_input = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    custom_price_input_is_net = models.BooleanField(\n        default=False,\n    )\n    line_price_gross = models.DecimalField(\n        decimal_places=2, max_digits=13, null=True,\n    )\n    requested_valid_from = models.DateTimeField(\n        null=True,\n    )\n\n    objects = ScopedManager(organizer='event__organizer')\n\n    class Meta:\n        verbose_name = _(\"Cart position\")\n        verbose_name_plural = _(\"Cart positions\")\n\n    def __repr__(self):\n        return '<CartPosition: item %d, variation %d for cart %s>' % (\n            self.item.id, self.variation.id if self.variation else 0, self.cart_id\n        )\n\n    @property\n    def tax_value(self):\n        net = round_decimal(self.price - (self.price * (1 - 100 / (100 + self.tax_rate))),\n                            self.event.currency)\n        return self.price - net\n\n    @cached_property\n    def sort_key(self):\n        subevent_key = (self.subevent.date_from, str(self.subevent.name), self.subevent_id) if self.subevent_id else (0, \"\", 0)\n        category_key = (self.item.category.position, self.item.category.id) if self.item.category_id is not None else (0, 0)\n        item_key = self.item.position, self.item_id\n        variation_key = (self.variation.position, self.variation.id) if self.variation_id is not None else (0, 0)\n        line_key = (self.price, (self.voucher_id or 0), (self.seat.sorting_rank if self.seat_id else 0), self.pk)\n        sort_key = subevent_key + category_key + item_key + variation_key + line_key\n\n        if self.addon_to_id:\n            return self.addon_to.sort_key + (1 if self.is_bundled else 2,) + sort_key\n        else:\n            return sort_key\n\n    def update_listed_price_and_voucher(self, voucher_only=False, max_discount=None):\n        from pretix.base.services.pricing import (\n            get_listed_price, is_included_for_free,\n        )\n\n        if voucher_only:\n            listed_price = self.listed_price\n        else:\n            if self.addon_to_id and is_included_for_free(self.item, self.addon_to):\n                listed_price = Decimal('0.00')\n            else:\n                listed_price = get_listed_price(self.item, self.variation, self.subevent)\n\n        if self.voucher:\n            price_after_voucher = self.voucher.calculate_price(listed_price, max_discount)\n        else:\n            price_after_voucher = listed_price\n\n        if self.is_bundled:\n            bundle = self.addon_to.item.bundles.filter(bundled_item=self.item, bundled_variation=self.variation).first()\n            if bundle:\n                if self.addon_to.voucher_id and self.addon_to.voucher.all_bundles_included:\n                    listed_price = Decimal('0.00')\n                    price_after_voucher = Decimal('0.00')\n                else:\n                    listed_price = bundle.designated_price\n                    price_after_voucher = bundle.designated_price\n\n        if listed_price != self.listed_price or price_after_voucher != self.price_after_voucher:\n            self.listed_price = listed_price\n            self.price_after_voucher = price_after_voucher\n            self.save(update_fields=['listed_price', 'price_after_voucher'])\n\n    def migrate_free_price_if_necessary(self):\n        # Migrate from pre-discounts position\n        if self.item.free_price and self.custom_price_input is None:\n            custom_price = self.price\n            if custom_price > 99_999_999_999:\n                raise ValueError('price_too_high')\n            self.custom_price_input = custom_price\n            self.custom_price_input_is_net = not False\n            self.save(update_fields=['custom_price_input', 'custom_price_input_is_net'])\n\n    def update_line_price(self, invoice_address, bundled_positions):\n        from pretix.base.services.pricing import get_line_price\n\n        line_price = get_line_price(\n            price_after_voucher=self.price_after_voucher,\n            custom_price_input=self.custom_price_input,\n            custom_price_input_is_net=self.custom_price_input_is_net,\n            tax_rule=self.item.tax_rule,\n            invoice_address=invoice_address,\n            bundled_sum=sum([b.price_after_voucher for b in bundled_positions]),\n            is_bundled=self.is_bundled,\n        )\n        if line_price.gross != self.line_price_gross or line_price.rate != self.tax_rate:\n            self.line_price_gross = line_price.gross\n            self.tax_rate = line_price.rate\n            self.save(update_fields=['line_price_gross', 'tax_rate'])\n\n    @property\n    def addons_without_bundled(self):\n        addons = [op for op in self.addons.all() if not op.is_bundled]\n        return sorted(addons, key=lambda cp: cp.sort_key)\n\n    @cached_property\n    def predicted_validity(self):\n        return self.item.compute_validity(\n            requested_start=(\n                max(self.requested_valid_from, now())\n                if self.requested_valid_from and self.item.validity_dynamic_start_choice\n                else now()\n            ),\n            override_tz=self.event.timezone,\n        )\n\n    @property\n    def valid_from(self):\n        return self.predicted_validity[0]\n\n    @property\n    def valid_until(self):\n        return self.predicted_validity[1]\n\n\nclass InvoiceAddress(models.Model):\n    last_modified = models.DateTimeField(auto_now=True)\n    order = models.OneToOneField(Order, null=True, blank=True, related_name='invoice_address', on_delete=models.CASCADE)\n    customer = models.ForeignKey(\n        Customer,\n        related_name='invoice_addresses',\n        null=True, blank=True,\n        on_delete=models.CASCADE\n    )\n    is_business = models.BooleanField(default=False, verbose_name=_('Business customer'))\n    company = models.CharField(max_length=255, blank=True, verbose_name=_('Company name'))\n    name_cached = models.CharField(max_length=255, verbose_name=_('Full name'), blank=True)\n    name_parts = models.JSONField(default=dict)\n    street = models.TextField(verbose_name=_('Address'), blank=False)\n    zipcode = models.CharField(max_length=30, verbose_name=_('ZIP code'), blank=False)\n    city = models.CharField(max_length=255, verbose_name=_('City'), blank=False)\n    country_old = models.CharField(max_length=255, verbose_name=_('Country'), blank=False)\n    country = FastCountryField(verbose_name=_('Country'), blank=False, blank_label=_('Select country'),\n                               countries=CachedCountries)\n    state = models.CharField(max_length=255, verbose_name=pgettext_lazy('address', 'State'), blank=True)\n    vat_id = models.CharField(max_length=255, blank=True, verbose_name=_('VAT ID'))\n    vat_id_validated = models.BooleanField(default=False)\n    custom_field = models.CharField(max_length=255, null=True, blank=True)\n    internal_reference = models.TextField(\n        verbose_name=_('Internal reference'),\n        help_text=_('This reference will be printed on your invoice for your convenience.'),\n        blank=True,\n    )\n    beneficiary = models.TextField(\n        verbose_name=_('Beneficiary'),\n        blank=True\n    )\n\n    objects = ScopedManager(organizer='order__event__organizer')\n    profiles = ScopedManager(organizer='customer__organizer')\n\n    def save(self, **kwargs):\n        if self.order:\n            self.order.touch()\n\n        if self.name_parts:\n            name = self.name\n            if self.name_cached != name:\n                self.name_cached = self.name\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'name_cached'}.union(kwargs['update_fields'])\n        else:\n            if self.name_cached != \"\" or self.name_parts != {}:\n                self.name_cached = \"\"\n                self.name_parts = {}\n                if 'update_fields' in kwargs:\n                    kwargs['update_fields'] = {'name_cached', 'name_parts'}.union(kwargs['update_fields'])\n        super().save(**kwargs)\n\n    def describe(self):\n        parts = [\n            self.company,\n            self.name,\n            self.street,\n            (self.zipcode or '') + ' ' + (self.city or '') + ' ' + (self.state_for_address or ''),\n            self.country.name,\n            self.vat_id,\n            self.custom_field,\n            self.internal_reference,\n            (_('Beneficiary') + ': ' + self.beneficiary) if self.beneficiary else '',\n        ]\n        return '\\n'.join([str(p).strip() for p in parts if p and str(p).strip()])\n\n    @property\n    def is_empty(self):\n        return (\n            not self.name_cached and not self.company and not self.street and not self.zipcode and not self.city\n            and not self.internal_reference and not self.beneficiary\n        )\n\n    @property\n    def state_name(self):\n        sd = pycountry.subdivisions.get(code='{}-{}'.format(self.country, self.state))\n        if sd:\n            return sd.name\n        return self.state\n\n    @property\n    def state_for_address(self):\n        from pretix.base.settings import COUNTRIES_WITH_STATE_IN_ADDRESS\n        if not self.state or str(self.country) not in COUNTRIES_WITH_STATE_IN_ADDRESS:\n            return \"\"\n        if COUNTRIES_WITH_STATE_IN_ADDRESS[str(self.country)][1] == 'long':\n            return self.state_name\n        return self.state\n\n    @property\n    def name(self):\n        return build_name(self.name_parts, fallback_scheme=lambda: self.order.event.settings.name_scheme) or \"\"\n\n    @property\n    def name_all_components(self):\n        return build_name(self.name_parts, \"concatenation_all_components\", fallback_scheme=lambda: self.order.event.settings.name_scheme) or \"\"\n\n    def for_js(self):\n        d = {}\n\n        if self.name_parts:\n            if '_scheme' in self.name_parts:\n                scheme = PERSON_NAME_SCHEMES[self.name_parts['_scheme']]\n                for i, (k, l, w) in enumerate(scheme['fields']):\n                    d[f'name_parts_{i}'] = self.name_parts.get(k) or ''\n\n        d.update({\n            'company': self.company,\n            'is_business': self.is_business,\n            'street': self.street,\n            'zipcode': self.zipcode,\n            'city': self.city,\n            'country': str(self.country) if self.country else None,\n            'state': str(self.state) if self.state else None,\n            'vat_id': self.vat_id,\n            'custom_field': self.custom_field,\n            'internal_reference': self.internal_reference,\n            'beneficiary': self.beneficiary,\n        })\n        return d\n\n\ndef cachedticket_name(instance, filename: str) -> str:\n    secret = get_random_string(length=16, allowed_chars=string.ascii_letters + string.digits)\n    return 'tickets/{org}/{ev}/{code}-{no}-{prov}-{secret}.dat'.format(\n        org=instance.order_position.order.event.organizer.slug,\n        ev=instance.order_position.order.event.slug,\n        prov=instance.provider,\n        no=instance.order_position.positionid,\n        code=instance.order_position.order.code,\n        secret=secret,\n    )\n\n\ndef cachedcombinedticket_name(instance, filename: str) -> str:\n    secret = get_random_string(length=16, allowed_chars=string.ascii_letters + string.digits)\n    return 'tickets/{org}/{ev}/{code}-{prov}-{secret}.dat'.format(\n        org=instance.order.event.organizer.slug,\n        ev=instance.order.event.slug,\n        prov=instance.provider,\n        code=instance.order.code,\n        secret=secret\n    )\n\n\nclass CachedTicket(models.Model):\n    order_position = models.ForeignKey(OrderPosition, on_delete=models.CASCADE)\n    provider = models.CharField(max_length=255)\n    type = models.CharField(max_length=255)\n    extension = models.CharField(max_length=255)\n    file = models.FileField(null=True, blank=True, upload_to=cachedticket_name, max_length=255)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass CachedCombinedTicket(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE)\n    provider = models.CharField(max_length=255)\n    type = models.CharField(max_length=255)\n    extension = models.CharField(max_length=255)\n    file = models.FileField(null=True, blank=True, upload_to=cachedcombinedticket_name, max_length=255)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass CancellationRequest(models.Model):\n    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='cancellation_requests')\n    created = models.DateTimeField(auto_now_add=True)\n    cancellation_fee = models.DecimalField(max_digits=13, decimal_places=2)\n    refund_as_giftcard = models.BooleanField(default=False)\n\n\nclass RevokedTicketSecret(models.Model):\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='revoked_secrets')\n    position = models.ForeignKey(\n        OrderPosition,\n        on_delete=models.SET_NULL,\n        related_name='revoked_secrets',\n        null=True,\n    )\n    secret = models.TextField(db_index=True)\n    created = models.DateTimeField(auto_now_add=True)\n\n\nclass BlockedTicketSecret(models.Model):\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='blocked_secrets')\n    position = models.ForeignKey(\n        OrderPosition,\n        on_delete=models.SET_NULL,\n        related_name='blocked_secrets',\n        null=True,\n    )\n    secret = models.TextField(db_index=True)\n    blocked = models.BooleanField()\n    updated = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        unique_together = (('event', 'secret'),)\n\n\n@receiver(post_delete, sender=CachedTicket)\ndef cachedticket_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n\n\n@receiver(post_delete, sender=CachedCombinedTicket)\ndef cachedcombinedticket_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n\n\n@receiver(post_delete, sender=QuestionAnswer)\ndef answer_delete(sender, instance, **kwargs):\n    if instance.file:\n        # Pass false so FileField doesn't save the model.\n        instance.file.delete(False)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Felix Sch\u00e4fer\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport copy\nimport hashlib\nimport itertools\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport tempfile\nimport unicodedata\nimport uuid\nfrom collections import OrderedDict, defaultdict\nfrom functools import partial\nfrom io import BytesIO\n\nimport jsonschema\nimport reportlab.rl_config\nfrom bidi.algorithm import get_display\nfrom django.conf import settings\nfrom django.contrib.staticfiles import finders\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Max, Min\nfrom django.db.models.fields.files import FieldFile\nfrom django.dispatch import receiver\nfrom django.utils.deconstruct import deconstructible\nfrom django.utils.formats import date_format\nfrom django.utils.html import conditional_escape\nfrom django.utils.timezone import now\nfrom django.utils.translation import gettext_lazy as _, pgettext\nfrom i18nfield.strings import LazyI18nString\nfrom pypdf import PdfReader, PdfWriter, Transformation\nfrom pypdf.generic import RectangleObject\nfrom reportlab.graphics import renderPDF\nfrom reportlab.graphics.barcode.qr import QrCodeWidget\nfrom reportlab.graphics.shapes import Drawing\nfrom reportlab.lib.colors import Color\nfrom reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT\nfrom reportlab.lib.styles import ParagraphStyle\nfrom reportlab.lib.units import mm\nfrom reportlab.pdfbase import pdfmetrics\nfrom reportlab.pdfbase.pdfmetrics import getAscentDescent\nfrom reportlab.pdfbase.ttfonts import TTFont\nfrom reportlab.pdfgen.canvas import Canvas\nfrom reportlab.platypus import Paragraph\n\nfrom pretix.base.i18n import language\nfrom pretix.base.models import Order, OrderPosition, Question\nfrom pretix.base.settings import PERSON_NAME_SCHEMES\nfrom pretix.base.signals import layout_image_variables, layout_text_variables\nfrom pretix.base.templatetags.money import money_filter\nfrom pretix.base.templatetags.phone_format import phone_format\nfrom pretix.helpers.reportlab import ThumbnailingImageReader, reshaper\nfrom pretix.presale.style import get_fonts\n\nlogger = logging.getLogger(__name__)\n\nif not settings.DEBUG:\n    reportlab.rl_config.shapeChecking = 0\n\n\nDEFAULT_VARIABLES = OrderedDict((\n    (\"secret\", {\n        \"label\": _(\"Ticket code (barcode content)\"),\n        \"editor_sample\": \"tdmruoekvkpbv1o2mv8xccvqcikvr58u\",\n        \"evaluate\": lambda orderposition, order, event: (\n            orderposition.secret[:30] + \"\u2026\" if len(orderposition.secret) > 32 else orderposition.secret\n        )\n    }),\n    (\"order\", {\n        \"label\": _(\"Order code\"),\n        \"editor_sample\": \"A1B2C\",\n        \"evaluate\": lambda orderposition, order, event: orderposition.order.code\n    }),\n    (\"positionid\", {\n        \"label\": _(\"Order position number\"),\n        \"editor_sample\": \"1\",\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.positionid)\n    }),\n    (\"order_positionid\", {\n        \"label\": _(\"Order code and position number\"),\n        \"editor_sample\": \"A1B2C-1\",\n        \"evaluate\": lambda orderposition, order, event: f\"{orderposition.order.code}-{orderposition.positionid}\"\n    }),\n    (\"item\", {\n        \"label\": _(\"Product name\"),\n        \"editor_sample\": _(\"Sample product\"),\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.item.name)\n    }),\n    (\"variation\", {\n        \"label\": _(\"Variation name\"),\n        \"editor_sample\": _(\"Sample variation\"),\n        \"evaluate\": lambda op, order, event: str(op.variation) if op.variation else ''\n    }),\n    (\"item_description\", {\n        \"label\": _(\"Product description\"),\n        \"editor_sample\": _(\"Sample product description\"),\n        \"evaluate\": lambda orderposition, order, event: str(orderposition.item.description)\n    }),\n    (\"itemvar\", {\n        \"label\": _(\"Product name and variation\"),\n        \"editor_sample\": _(\"Sample product \u2013 sample variation\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            '{} - {}'.format(orderposition.item.name, orderposition.variation)\n            if orderposition.variation else str(orderposition.item.name)\n        )\n    }),\n    (\"itemvar_description\", {\n        \"label\": _(\"Product variation description\"),\n        \"editor_sample\": _(\"Sample product variation description\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            str(orderposition.variation.description) if orderposition.variation else str(orderposition.item.description)\n        )\n    }),\n    (\"item_category\", {\n        \"label\": _(\"Product category\"),\n        \"editor_sample\": _(\"Ticket category\"),\n        \"evaluate\": lambda orderposition, order, event: (\n            str(orderposition.item.category.name) if orderposition.item.category else \"\"\n        )\n    }),\n    (\"price\", {\n        \"label\": _(\"Price\"),\n        \"editor_sample\": _(\"123.45 EUR\"),\n        \"evaluate\": lambda op, order, event: money_filter(op.price, event.currency)\n    }),\n    (\"price_with_addons\", {\n        \"label\": _(\"Price including add-ons\"),\n        \"editor_sample\": _(\"123.45 EUR\"),\n        \"evaluate\": lambda op, order, event: money_filter(op.price + sum(\n            p.price\n            for p in op.addons.all()\n            if not p.canceled\n        ), event.currency)\n    }),\n    (\"attendee_name\", {\n        \"label\": _(\"Attendee name\"),\n        \"editor_sample\": _(\"John Doe\"),\n        \"evaluate\": lambda op, order, ev: op.attendee_name or (op.addon_to.attendee_name if op.addon_to else '')\n    }),\n    (\"attendee_company\", {\n        \"label\": _(\"Attendee company\"),\n        \"editor_sample\": _(\"Sample company\"),\n        \"evaluate\": lambda op, order, ev: op.company or (op.addon_to.company if op.addon_to else '')\n    }),\n    ('attendee_address', {\n        'label': _('Full attendee address'),\n        'editor_sample': _('John Doe\\nSample company\\nSesame Street 42\\n12345 Any City\\nAtlantis'),\n        'evaluate': lambda op, order, event: op.address_format()\n    }),\n    (\"attendee_street\", {\n        \"label\": _(\"Attendee street\"),\n        \"editor_sample\": 'Sesame Street 42',\n        \"evaluate\": lambda op, order, ev: op.street or (op.addon_to.street if op.addon_to else '')\n    }),\n    (\"attendee_zipcode\", {\n        \"label\": _(\"Attendee ZIP code\"),\n        \"editor_sample\": '12345',\n        \"evaluate\": lambda op, order, ev: op.zipcode or (op.addon_to.zipcode if op.addon_to else '')\n    }),\n    (\"attendee_city\", {\n        \"label\": _(\"Attendee city\"),\n        \"editor_sample\": 'Any City',\n        \"evaluate\": lambda op, order, ev: op.city or (op.addon_to.city if op.addon_to else '')\n    }),\n    (\"attendee_state\", {\n        \"label\": _(\"Attendee state\"),\n        \"editor_sample\": 'Sample State',\n        \"evaluate\": lambda op, order, ev: op.state or (op.addon_to.state if op.addon_to else '')\n    }),\n    (\"attendee_country\", {\n        \"label\": _(\"Attendee country\"),\n        \"editor_sample\": 'Atlantis',\n        \"evaluate\": lambda op, order, ev: str(getattr(op.country, 'name', '')) or (\n            str(getattr(op.addon_to.country, 'name', '')) if op.addon_to else ''\n        )\n    }),\n    (\"attendee_email\", {\n        \"label\": _(\"Attendee email\"),\n        \"editor_sample\": 'foo@bar.com',\n        \"evaluate\": lambda op, order, ev: op.attendee_email or (op.addon_to.attendee_email if op.addon_to else '')\n    }),\n    (\"pseudonymization_id\", {\n        \"label\": _(\"Pseudonymization ID (lead scanning)\"),\n        \"editor_sample\": \"GG89JUJDTA\",\n        \"evaluate\": lambda orderposition, order, event: orderposition.pseudonymization_id,\n    }),\n    (\"event_name\", {\n        \"label\": _(\"Event name\"),\n        \"editor_sample\": _(\"Sample event name\"),\n        \"evaluate\": lambda op, order, ev: str(ev.name)\n    }),\n    (\"event_series_name\", {\n        \"label\": _(\"Event series\"),\n        \"editor_sample\": _(\"Sample event name\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.name)\n    }),\n    (\"event_date\", {\n        \"label\": _(\"Event date\"),\n        \"editor_sample\": _(\"May 31st, 2017\"),\n        \"evaluate\": lambda op, order, ev: ev.get_date_from_display(show_times=False)\n    }),\n    (\"event_date_range\", {\n        \"label\": _(\"Event date range\"),\n        \"editor_sample\": _(\"May 31st \u2013 June 4th, 2017\"),\n        \"evaluate\": lambda op, order, ev: ev.get_date_range_display(force_show_end=True)\n    }),\n    (\"event_begin\", {\n        \"label\": _(\"Event begin date and time\"),\n        \"editor_sample\": _(\"2017-05-31 20:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_from.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_from else \"\"\n    }),\n    (\"event_begin_date\", {\n        \"label\": _(\"Event begin date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_from.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if ev.date_from else \"\"\n    }),\n    (\"event_begin_time\", {\n        \"label\": _(\"Event begin time\"),\n        \"editor_sample\": _(\"20:00\"),\n        \"evaluate\": lambda op, order, ev: ev.get_time_from_display()\n    }),\n    (\"event_begin_weekday\", {\n        \"label\": _(\"Event begin weekday\"),\n        \"editor_sample\": _(\"Friday\"),\n        \"evaluate\": lambda op, order, ev: ev.get_weekday_from_display()\n    }),\n    (\"event_end\", {\n        \"label\": _(\"Event end date and time\"),\n        \"editor_sample\": _(\"2017-05-31 22:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_date\", {\n        \"label\": _(\"Event end date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_time\", {\n        \"label\": _(\"Event end time\"),\n        \"editor_sample\": _(\"22:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_to.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if ev.date_to else \"\"\n    }),\n    (\"event_end_weekday\", {\n        \"label\": _(\"Event end weekday\"),\n        \"editor_sample\": _(\"Friday\"),\n        \"evaluate\": lambda op, order, ev: ev.get_weekday_to_display()\n    }),\n    (\"event_admission\", {\n        \"label\": _(\"Event admission date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_admission.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if ev.date_admission else \"\"\n    }),\n    (\"event_admission_time\", {\n        \"label\": _(\"Event admission time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            ev.date_admission.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if ev.date_admission else \"\"\n    }),\n    (\"event_location\", {\n        \"label\": _(\"Event location\"),\n        \"editor_sample\": _(\"Random City\"),\n        \"evaluate\": lambda op, order, ev: str(ev.location)\n    }),\n    (\"telephone\", {\n        \"label\": _(\"Phone number\"),\n        \"editor_sample\": \"+01 1234 567890\",\n        \"evaluate\": lambda op, order, ev: phone_format(order.phone, html=False)\n    }),\n    (\"email\", {\n        \"label\": _(\"Email\"),\n        \"editor_sample\": \"foo@bar.com\",\n        \"evaluate\": lambda op, order, ev: order.email\n    }),\n    (\"invoice_name\", {\n        \"label\": _(\"Invoice address name\"),\n        \"editor_sample\": _(\"John Doe\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.name if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_company\", {\n        \"label\": _(\"Invoice address company\"),\n        \"editor_sample\": _(\"Sample company\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.company if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_street\", {\n        \"label\": _(\"Invoice address street\"),\n        \"editor_sample\": _(\"Sesame Street 42\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.street if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_zipcode\", {\n        \"label\": _(\"Invoice address ZIP code\"),\n        \"editor_sample\": _(\"12345\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.zipcode if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_city\", {\n        \"label\": _(\"Invoice address city\"),\n        \"editor_sample\": _(\"Sample city\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.city if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_state\", {\n        \"label\": _(\"Invoice address state\"),\n        \"editor_sample\": _(\"Sample State\"),\n        \"evaluate\": lambda op, order, ev: order.invoice_address.state if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"invoice_country\", {\n        \"label\": _(\"Invoice address country\"),\n        \"editor_sample\": _(\"Atlantis\"),\n        \"evaluate\": lambda op, order, ev: str(getattr(order.invoice_address.country, 'name', '')) if getattr(order, 'invoice_address', None) else ''\n    }),\n    (\"addons\", {\n        \"label\": _(\"List of Add-Ons\"),\n        \"editor_sample\": _(\"Add-on 1\\n2x Add-on 2\"),\n        \"evaluate\": lambda op, order, ev: \"\\n\".join([\n            str(p) for p in generate_compressed_addon_list(op, order, ev)\n        ])\n    }),\n    (\"organizer\", {\n        \"label\": _(\"Organizer name\"),\n        \"editor_sample\": _(\"Event organizer company\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.organizer.name)\n    }),\n    (\"organizer_info_text\", {\n        \"label\": _(\"Organizer info text\"),\n        \"editor_sample\": _(\"Event organizer info text\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.settings.organizer_info_text)\n    }),\n    (\"event_info_text\", {\n        \"label\": _(\"Event info text\"),\n        \"editor_sample\": _(\"Event info text\"),\n        \"evaluate\": lambda op, order, ev: str(order.event.settings.event_info_text)\n    }),\n    (\"now_date\", {\n        \"label\": _(\"Printing date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        )\n    }),\n    (\"now_datetime\", {\n        \"label\": _(\"Printing date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        )\n    }),\n    (\"now_time\", {\n        \"label\": _(\"Printing time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            now().astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        )\n    }),\n    (\"valid_from_date\", {\n        \"label\": _(\"Validity start date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_from_datetime\", {\n        \"label\": _(\"Validity start date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_from_time\", {\n        \"label\": _(\"Validity start time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_from.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if op.valid_from else \"\"\n    }),\n    (\"valid_until_date\", {\n        \"label\": _(\"Validity end date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"SHORT_DATE_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"valid_until_datetime\", {\n        \"label\": _(\"Validity end date and time\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"valid_until_time\", {\n        \"label\": _(\"Validity end time\"),\n        \"editor_sample\": _(\"19:00\"),\n        \"evaluate\": lambda op, order, ev: date_format(\n            op.valid_until.astimezone(ev.timezone),\n            \"TIME_FORMAT\"\n        ) if op.valid_until else \"\"\n    }),\n    (\"medium_identifier\", {\n        \"label\": _(\"Reusable Medium ID\"),\n        \"editor_sample\": \"ABC1234DEF4567\",\n        \"evaluate\": lambda op, order, ev: op.linked_media.all()[0].identifier if op.linked_media.all() else \"\",\n    }),\n    (\"seat\", {\n        \"label\": _(\"Seat: Full name\"),\n        \"editor_sample\": _(\"Ground floor, Row 3, Seat 4\"),\n        \"evaluate\": lambda op, order, ev: str(get_seat(op) if get_seat(op) else\n                                              _('General admission') if ev.seating_plan_id is not None else \"\")\n    }),\n    (\"seat_zone\", {\n        \"label\": _(\"Seat: zone\"),\n        \"editor_sample\": _(\"Ground floor\"),\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).zone_name if get_seat(op) else\n                                              _('General admission') if ev.seating_plan_id is not None else \"\")\n    }),\n    (\"seat_row\", {\n        \"label\": _(\"Seat: row\"),\n        \"editor_sample\": \"3\",\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).row_name if get_seat(op) else \"\")\n    }),\n    (\"seat_number\", {\n        \"label\": _(\"Seat: seat number\"),\n        \"editor_sample\": 4,\n        \"evaluate\": lambda op, order, ev: str(get_seat(op).seat_number if get_seat(op) else \"\")\n    }),\n    (\"first_scan\", {\n        \"label\": _(\"Date and time of first scan\"),\n        \"editor_sample\": _(\"2017-05-31 19:00\"),\n        \"evaluate\": lambda op, order, ev: get_first_scan(op)\n    }),\n    (\"giftcard_issuance_date\", {\n\n        \"label\": _(\"Gift card: Issuance date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: get_giftcard_issuance(op, ev)\n    }),\n    (\"giftcard_expiry_date\", {\n        \"label\": _(\"Gift card: Expiration date\"),\n        \"editor_sample\": _(\"2017-05-31\"),\n        \"evaluate\": lambda op, order, ev: get_giftcard_expiry(op, ev)\n    }),\n))\nDEFAULT_IMAGES = OrderedDict([])\n\n\n@receiver(layout_image_variables, dispatch_uid=\"pretix_base_layout_image_variables_questions\")\ndef images_from_questions(sender, *args, **kwargs):\n    def get_answer(op, order, event, question_id, etag):\n        a = None\n        if op.addon_to:\n            if 'answers' in getattr(op.addon_to, '_prefetched_objects_cache', {}):\n                try:\n                    a = [a for a in op.addon_to.answers.all() if a.question_id == question_id][0]\n                except IndexError:\n                    pass\n            else:\n                a = op.addon_to.answers.filter(question_id=question_id).first()\n\n        if 'answers' in getattr(op, '_prefetched_objects_cache', {}):\n            try:\n                a = [a for a in op.answers.all() if a.question_id == question_id][0]\n            except IndexError:\n                pass\n        else:\n            a = op.answers.filter(question_id=question_id).first() or a\n\n        if not a or not a.file or not any(a.file.name.lower().endswith(e) for e in settings.FILE_UPLOAD_EXTENSIONS_QUESTION_IMAGE):\n            return None\n        else:\n            if etag:\n                return hashlib.sha1(a.file.name.encode()).hexdigest()\n            return a.file\n\n    d = {}\n    for q in sender.questions.all():\n        if q.type != Question.TYPE_FILE:\n            continue\n        d['question_{}'.format(q.identifier)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk, etag=False),\n            'etag': partial(get_answer, question_id=q.pk, etag=True),\n        }\n    return d\n\n\n@receiver(layout_text_variables, dispatch_uid=\"pretix_base_layout_text_variables_questions\")\ndef variables_from_questions(sender, *args, **kwargs):\n    def get_answer(op, order, event, question_id):\n        a = None\n        if op.addon_to:\n            if 'answers' in getattr(op.addon_to, '_prefetched_objects_cache', {}):\n                try:\n                    a = [a for a in op.addon_to.answers.all() if a.question_id == question_id][0]\n                except IndexError:\n                    pass\n            else:\n                a = op.addon_to.answers.filter(question_id=question_id).first()\n\n        if 'answers' in getattr(op, '_prefetched_objects_cache', {}):\n            try:\n                a = [a for a in op.answers.all() if a.question_id == question_id][0]\n            except IndexError:\n                pass\n        else:\n            a = op.answers.filter(question_id=question_id).first() or a\n\n        if not a:\n            return \"\"\n        else:\n            return str(a)\n\n    d = {}\n    for q in sender.questions.all():\n        if q.type == Question.TYPE_FILE:\n            continue\n        d['question_{}'.format(q.identifier)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'editor_sample': _('<Answer: {question}>').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk),\n            'migrate_from': 'question_{}'.format(q.pk)\n        }\n        d['question_{}'.format(q.pk)] = {\n            'label': _('Question: {question}').format(question=q.question),\n            'editor_sample': _('<Answer: {question}>').format(question=q.question),\n            'evaluate': partial(get_answer, question_id=q.pk),\n            'hidden': True,\n        }\n    return d\n\n\ndef _get_attendee_name_part(key, op, order, ev):\n    name_parts = op.attendee_name_parts or (op.addon_to.attendee_name_parts if op.addon_to else {})\n    if isinstance(key, tuple):\n        parts = [_get_attendee_name_part(c[0], op, order, ev) for c in key if not (c[0] == 'salutation' and name_parts.get(c[0], '') == \"Mx\")]\n        return ' '.join(p for p in parts if p)\n    value = name_parts.get(key, '')\n    if key == 'salutation':\n        return pgettext('person_name_salutation', value)\n    return value\n\n\ndef _get_ia_name_part(key, op, order, ev):\n    value = order.invoice_address.name_parts.get(key, '') if getattr(order, 'invoice_address', None) else ''\n    if key == 'salutation' and value:\n        return pgettext('person_name_salutation', value)\n    return value\n\n\ndef get_images(event):\n    v = copy.copy(DEFAULT_IMAGES)\n\n    for recv, res in layout_image_variables.send(sender=event):\n        v.update(res)\n\n    return v\n\n\ndef get_variables(event):\n    v = copy.copy(DEFAULT_VARIABLES)\n\n    scheme = PERSON_NAME_SCHEMES[event.settings.name_scheme]\n\n    concatenation_for_salutation = scheme.get(\"concatenation_for_salutation\", scheme[\"concatenation\"])\n    v['attendee_name_for_salutation'] = {\n        'label': _(\"Attendee name for salutation\"),\n        'editor_sample': _(\"Mr Doe\"),\n        'evaluate': lambda op, order, ev: concatenation_for_salutation(op.attendee_name_parts or (op.addon_to.attendee_name_parts if op.addon_to else {}))\n    }\n\n    for key, label, weight in scheme['fields']:\n        v['attendee_name_%s' % key] = {\n            'label': _(\"Attendee name: {part}\").format(part=label),\n            'editor_sample': scheme['sample'][key],\n            'evaluate': partial(_get_attendee_name_part, key)\n        }\n    for i in range(2, len(scheme['fields']) + 1):\n        for comb in itertools.combinations(scheme['fields'], i):\n            v['attendee_name_%s' % ('_'.join(c[0] for c in comb))] = {\n                'label': _(\"Attendee name: {part}\").format(part=' + '.join(str(c[1]) for c in comb)),\n                'editor_sample': ' '.join(str(scheme['sample'][c[0]]) for c in comb),\n                'evaluate': partial(_get_attendee_name_part, comb)\n            }\n\n    v['invoice_name']['editor_sample'] = scheme['concatenation'](scheme['sample'])\n    v['attendee_name']['editor_sample'] = scheme['concatenation'](scheme['sample'])\n\n    v['invoice_name_for_salutation'] = {\n        'label': _(\"Invoice address name for salutation\"),\n        'editor_sample': _(\"Mr Doe\"),\n        'evaluate': lambda op, order, ev: concatenation_for_salutation(order.invoice_address.name_parts if getattr(order, 'invoice_address', None) else {})\n    }\n\n    for key, label, weight in scheme['fields']:\n        v['invoice_name_%s' % key] = {\n            'label': _(\"Invoice address name: {part}\").format(part=label),\n            'editor_sample': scheme['sample'][key],\n            \"evaluate\": partial(_get_ia_name_part, key)\n        }\n\n    for recv, res in layout_text_variables.send(sender=event):\n        v.update(res)\n\n    return v\n\n\ndef get_giftcard_expiry(op: OrderPosition, ev):\n    if not op.item.issue_giftcard:\n        return \"\"  # performance optimization\n    m = op.issued_gift_cards.aggregate(m=Min('expires'))['m']\n    if not m:\n        return \"\"\n    return date_format(m.astimezone(ev.timezone), \"SHORT_DATE_FORMAT\")\n\n\ndef get_giftcard_issuance(op: OrderPosition, ev):\n    if not op.item.issue_giftcard:\n        return \"\"  # performance optimization\n    m = op.issued_gift_cards.aggregate(m=Max('issuance'))['m']\n    if not m:\n        return \"\"\n    return date_format(m.astimezone(ev.timezone), \"SHORT_DATE_FORMAT\")\n\n\ndef get_first_scan(op: OrderPosition):\n    scans = list(op.checkins.all())\n\n    if scans:\n        return date_format(\n            list(op.checkins.all())[-1].datetime.astimezone(op.order.event.timezone),\n            \"SHORT_DATETIME_FORMAT\"\n        )\n    return \"\"\n\n\ndef get_seat(op: OrderPosition):\n    if op.seat_id:\n        return op.seat\n    if op.addon_to_id:\n        return op.addon_to.seat\n    return None\n\n\ndef generate_compressed_addon_list(op, order, event):\n    itemcount = defaultdict(int)\n    addons = (\n        op.addons.all() if 'addons' in getattr(op, '_prefetched_objects_cache', {})\n        else op.addons.select_related('item', 'variation')\n    )\n    for pos in addons:\n        itemcount[pos.item, pos.variation] += 1\n\n    addonlist = []\n    for (item, variation), count in itemcount.items():\n        if variation:\n            if count > 1:\n                addonlist.append('{}x {} - {}'.format(count, item.name, variation.value))\n            else:\n                addonlist.append('{} - {}'.format(item.name, variation.value))\n        else:\n            if count > 1:\n                addonlist.append('{}x {}'.format(count, item.name))\n            else:\n                addonlist.append(item.name)\n    return addonlist\n\n\nclass Renderer:\n\n    def __init__(self, event, layout, background_file):\n        self.layout = layout\n        self.background_file = background_file\n        self.variables = get_variables(event)\n        self.images = get_images(event)\n        self.event = event\n        if self.background_file:\n            self.bg_bytes = self.background_file.read()\n            self.bg_pdf = PdfReader(BytesIO(self.bg_bytes), strict=False)\n        else:\n            self.bg_bytes = None\n            self.bg_pdf = None\n\n    @classmethod\n    def _register_fonts(cls):\n        if hasattr(cls, '_fonts_registered'):\n            return\n        pdfmetrics.registerFont(TTFont('Open Sans', finders.find('fonts/OpenSans-Regular.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans I', finders.find('fonts/OpenSans-Italic.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans B', finders.find('fonts/OpenSans-Bold.ttf')))\n        pdfmetrics.registerFont(TTFont('Open Sans B I', finders.find('fonts/OpenSans-BoldItalic.ttf')))\n\n        for family, styles in get_fonts().items():\n            pdfmetrics.registerFont(TTFont(family, finders.find(styles['regular']['truetype'])))\n            if 'italic' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' I', finders.find(styles['italic']['truetype'])))\n            if 'bold' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' B', finders.find(styles['bold']['truetype'])))\n            if 'bolditalic' in styles:\n                pdfmetrics.registerFont(TTFont(family + ' B I', finders.find(styles['bolditalic']['truetype'])))\n\n        cls._fonts_registered = True\n\n    def _draw_poweredby(self, canvas: Canvas, op: OrderPosition, o: dict):\n        content = o.get('content', 'dark')\n        if content not in ('dark', 'white'):\n            content = 'dark'\n        img = finders.find('pretixpresale/pdf/powered_by_pretix_{}.png'.format(content))\n\n        ir = ThumbnailingImageReader(img)\n        try:\n            width, height = ir.resize(None, float(o['size']) * mm, 300)\n        except:\n            logger.exception(\"Can not resize image\")\n            pass\n        canvas.drawImage(ir,\n                         float(o['left']) * mm, float(o['bottom']) * mm,\n                         width=width, height=height,\n                         preserveAspectRatio=True, anchor='n',\n                         mask='auto')\n\n    def _draw_barcodearea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        content = o.get('content', 'secret')\n        if content == 'secret':\n            # do not use get_text_content because it uses a shortened version of secret\n            # and does not deal with our default value here properly\n            content = op.secret\n        else:\n            content = self._get_text_content(op, order, o)\n\n        if len(content) == 0:\n            return\n\n        level = 'H'\n        if len(content) > 32:\n            level = 'M'\n        if len(content) > 128:\n            level = 'L'\n        reqs = float(o['size']) * mm\n        kwargs = {}\n        if o.get('nowhitespace', False):\n            kwargs['barBorder'] = 0\n        qrw = QrCodeWidget(content, barLevel=level, barHeight=reqs, barWidth=reqs, **kwargs)\n        d = Drawing(reqs, reqs)\n        d.add(qrw)\n        qr_x = float(o['left']) * mm\n        qr_y = float(o['bottom']) * mm\n        renderPDF.draw(d, canvas, qr_x, qr_y)\n\n        # Add QR content + PDF issuer as a hidden string (fully transparent & very very small)\n        # This helps automated processing of the PDF file by 3rd parties, e.g. when checking tickets for resale\n        data = {\n            \"issuer\": settings.SITE_URL,\n            o.get('content', 'secret'): content\n        }\n        canvas.saveState()\n        canvas.setFont('Open Sans', .01)\n        canvas.setFillColorRGB(0, 0, 0, 0)\n        canvas.drawString(0 * mm, 0 * mm, json.dumps(data, sort_keys=True))\n        canvas.restoreState()\n\n    def _get_ev(self, op, order):\n        return op.subevent or order.event\n\n    def _get_text_content(self, op: OrderPosition, order: Order, o: dict, inner=False):\n        if o.get('locale', None) and not inner:\n            with language(o['locale'], self.event.settings.region):\n                return self._get_text_content(op, order, o, True)\n\n        ev = self._get_ev(op, order)\n\n        if not o['content']:\n            return '(error)'\n\n        if o['content'] == 'other' or o['content'] == 'other_i18n':\n            if o['content'] == 'other_i18n':\n                text = str(LazyI18nString(o.get('text_i18n', {})))\n            else:\n                text = o.get('text', '')\n\n            def replace(x):\n                if x.group(1).startswith('itemmeta:'):\n                    if op.variation_id:\n                        return op.variation.meta_data.get(x.group(1)[9:]) or ''\n                    return op.item.meta_data.get(x.group(1)[9:]) or ''\n                elif x.group(1).startswith('meta:'):\n                    return ev.meta_data.get(x.group(1)[5:]) or ''\n                elif x.group(1) not in self.variables:\n                    return x.group(0)\n                if x.group(1) == 'secret':\n                    # Do not use shortened version\n                    return op.secret\n\n                try:\n                    return self.variables[x.group(1)]['evaluate'](op, order, ev)\n                except:\n                    logger.exception('Failed to process variable.')\n                    return '(error)'\n\n            # We do not use str.format like in emails so we (a) can evaluate lazily and (b) can re-implement this\n            # 1:1 on other platforms that render PDFs through our API (libpretixprint)\n            return re.sub(r'\\{([a-zA-Z0-9:_]+)\\}', replace, text)\n\n        elif o['content'].startswith('itemmeta:'):\n            if op.variation_id:\n                return op.variation.meta_data.get(o['content'][9:]) or ''\n            return op.item.meta_data.get(o['content'][9:]) or ''\n\n        elif o['content'].startswith('meta:'):\n            return ev.meta_data.get(o['content'][5:]) or ''\n\n        elif o['content'] in self.variables:\n            try:\n                return self.variables[o['content']]['evaluate'](op, order, ev)\n            except:\n                logger.exception('Failed to process variable.')\n                return '(error)'\n\n        return ''\n\n    def _draw_imagearea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        ev = self._get_ev(op, order)\n        if not o['content'] or o['content'] not in self.images:\n            image_file = None\n        else:\n            try:\n                image_file = self.images[o['content']]['evaluate'](op, order, ev)\n            except:\n                logger.exception('Failed to process variable.')\n                image_file = None\n\n        if image_file:\n            try:\n                ir = ThumbnailingImageReader(image_file)\n                ir.resize(float(o['width']) * mm, float(o['height']) * mm, 300)\n                canvas.drawImage(\n                    image=ir,\n                    x=float(o['left']) * mm,\n                    y=float(o['bottom']) * mm,\n                    width=float(o['width']) * mm,\n                    height=float(o['height']) * mm,\n                    preserveAspectRatio=True,\n                    anchor='c',  # centered in frame\n                    mask='auto'\n                )\n                if isinstance(image_file, FieldFile):\n                    # ThumbnailingImageReader \"closes\" the file, so it's no use to use the same file pointer\n                    # in case we need it again. For FieldFile, fortunately, there is an easy way to make the file\n                    # refresh itself when it is used next.\n                    del image_file.file\n            except:\n                logger.exception(\"Can not load or resize image\")\n                canvas.saveState()\n                canvas.setFillColorRGB(.8, .8, .8, alpha=1)\n                canvas.rect(\n                    x=float(o['left']) * mm,\n                    y=float(o['bottom']) * mm,\n                    width=float(o['width']) * mm,\n                    height=float(o['height']) * mm,\n                    stroke=0,\n                    fill=1,\n                )\n                canvas.restoreState()\n        else:\n            canvas.saveState()\n            canvas.setFillColorRGB(.8, .8, .8, alpha=1)\n            canvas.rect(\n                x=float(o['left']) * mm,\n                y=float(o['bottom']) * mm,\n                width=float(o['width']) * mm,\n                height=float(o['height']) * mm,\n                stroke=0,\n                fill=1,\n            )\n            canvas.restoreState()\n\n    def _draw_textarea(self, canvas: Canvas, op: OrderPosition, order: Order, o: dict):\n        font = o['fontfamily']\n        if o['bold']:\n            font += ' B'\n        if o['italic']:\n            font += ' I'\n\n        try:\n            ad = getAscentDescent(font, float(o['fontsize']))\n        except KeyError:  # font not known, fall back\n            logger.warning(f'Use of unknown font \"{font}\"')\n            font = 'Open Sans'\n            ad = getAscentDescent(font, float(o['fontsize']))\n\n        align_map = {\n            'left': TA_LEFT,\n            'center': TA_CENTER,\n            'right': TA_RIGHT\n        }\n        # lineheight display differs from browser canvas. This calc is just empirical values to get\n        # reportlab render similarly to browser canvas.\n        # for backwards compatability use \u201euncorrected\u201c lineheight of 1.0 instead of 1.15\n        lineheight = float(o['lineheight']) * 1.15 if 'lineheight' in o else 1.0\n        style = ParagraphStyle(\n            name=uuid.uuid4().hex,\n            fontName=font,\n            fontSize=float(o['fontsize']),\n            leading=lineheight * float(o['fontsize']),\n            # for backwards compatability use autoLeading if no lineheight is given\n            autoLeading='off' if 'lineheight' in o else 'max',\n            textColor=Color(o['color'][0] / 255, o['color'][1] / 255, o['color'][2] / 255),\n            alignment=align_map[o['align']]\n        )\n        # add an almost-invisible space &hairsp; after hyphens as word-wrap in ReportLab only works on space chars\n        text = conditional_escape(\n            self._get_text_content(op, order, o) or \"\",\n        ).replace(\"\\n\", \"<br/>\\n\").replace(\"-\", \"-&hairsp;\")\n\n        # reportlab does not support unicode combination characters\n        # It's important we do this before we use ArabicReshaper\n        text = unicodedata.normalize(\"NFC\", text)\n\n        # reportlab does not support RTL, ligature-heavy scripts like Arabic. Therefore, we use ArabicReshaper\n        # to resolve all ligatures and python-bidi to switch RTL texts.\n        try:\n            text = \"<br/>\".join(get_display(reshaper.reshape(l)) for l in text.split(\"<br/>\"))\n        except:\n            logger.exception('Reshaping/Bidi fixes failed on string {}'.format(repr(text)))\n\n        p = Paragraph(text, style=style)\n        w, h = p.wrapOn(canvas, float(o['width']) * mm, 1000 * mm)\n        # p_size = p.wrap(float(o['width']) * mm, 1000 * mm)\n        canvas.saveState()\n        # The ascent/descent offsets here are not really proven to be correct, they're just empirical values to get\n        # reportlab render similarly to browser canvas.\n        if o.get('downward', False):\n            canvas.translate(float(o['left']) * mm, float(o['bottom']) * mm)\n            canvas.rotate(o.get('rotation', 0) * -1)\n            p.drawOn(canvas, 0, -h - ad[1] / 2.5)\n        else:\n            if lineheight != 1.0:\n                # lineheight adds to ascent/descent offsets, just empirical values again to get\n                # reportlab to render similarly to browser canvas\n                ad = (\n                    ad[0],\n                    ad[1] + (lineheight - 1.0) * float(o['fontsize']) * 1.05\n                )\n            canvas.translate(float(o['left']) * mm, float(o['bottom']) * mm + h)\n            canvas.rotate(o.get('rotation', 0) * -1)\n            p.drawOn(canvas, 0, -h - ad[1])\n        canvas.restoreState()\n\n    def draw_page(self, canvas: Canvas, order: Order, op: OrderPosition, show_page=True, only_page=None):\n        page_count = len(self.bg_pdf.pages)\n\n        if not only_page and not show_page:\n            raise ValueError(\"only_page=None and show_page=False cannot be combined\")\n\n        for page in range(page_count):\n            if only_page and only_page != page + 1:\n                continue\n            for o in self.layout:\n                if o.get('page', 1) != page + 1:\n                    continue\n                if o['type'] == \"barcodearea\":\n                    self._draw_barcodearea(canvas, op, order, o)\n                elif o['type'] == \"imagearea\":\n                    self._draw_imagearea(canvas, op, order, o)\n                elif o['type'] == \"textarea\":\n                    self._draw_textarea(canvas, op, order, o)\n                elif o['type'] == \"poweredby\":\n                    self._draw_poweredby(canvas, op, o)\n                if self.bg_pdf:\n                    page_size = (\n                        self.bg_pdf.pages[0].mediabox[2] - self.bg_pdf.pages[0].mediabox[0],\n                        self.bg_pdf.pages[0].mediabox[3] - self.bg_pdf.pages[0].mediabox[1]\n                    )\n                    if self.bg_pdf.pages[0].get('/Rotate') in (90, 270):\n                        # swap dimensions due to pdf being rotated\n                        page_size = page_size[::-1]\n                    canvas.setPageSize(page_size)\n            if show_page:\n                canvas.showPage()\n\n    def render_background(self, buffer, title=_('Ticket')):\n        if settings.PDFTK:\n            buffer.seek(0)\n            with tempfile.TemporaryDirectory() as d:\n                with open(os.path.join(d, 'back.pdf'), 'wb') as f:\n                    f.write(self.bg_bytes)\n                with open(os.path.join(d, 'front.pdf'), 'wb') as f:\n                    f.write(buffer.read())\n                subprocess.run([\n                    settings.PDFTK,\n                    os.path.join(d, 'front.pdf'),\n                    'multibackground',\n                    os.path.join(d, 'back.pdf'),\n                    'output',\n                    os.path.join(d, 'out.pdf'),\n                    'compress'\n                ], check=True)\n                with open(os.path.join(d, 'out.pdf'), 'rb') as f:\n                    return BytesIO(f.read())\n        else:\n            buffer.seek(0)\n            new_pdf = PdfReader(buffer)\n            output = PdfWriter()\n\n            for i, page in enumerate(new_pdf.pages):\n                bg_page = copy.deepcopy(self.bg_pdf.pages[i])\n                bg_rotation = bg_page.get('/Rotate')\n                if bg_rotation:\n                    # /Rotate is clockwise, transformation.rotate is counter-clockwise\n                    t = Transformation().rotate(bg_rotation)\n                    w = float(page.mediabox.getWidth())\n                    h = float(page.mediabox.getHeight())\n                    if bg_rotation in (90, 270):\n                        # offset due to rotation base\n                        if bg_rotation == 90:\n                            t = t.translate(h, 0)\n                        else:\n                            t = t.translate(0, w)\n                        # rotate mediabox as well\n                        page.mediabox = RectangleObject((\n                            page.mediabox.left.as_numeric(),\n                            page.mediabox.bottom.as_numeric(),\n                            page.mediabox.top.as_numeric(),\n                            page.mediabox.right.as_numeric(),\n                        ))\n                        page.trimbox = page.mediabox\n                    elif bg_rotation == 180:\n                        t = t.translate(w, h)\n                    page.add_transformation(t)\n                bg_page.merge_page(page)\n                output.add_page(bg_page)\n\n            output.add_metadata({\n                '/Title': str(title),\n                '/Creator': 'pretix',\n            })\n            outbuffer = BytesIO()\n            output.write(outbuffer)\n            outbuffer.seek(0)\n            return outbuffer\n\n\ndef merge_background(fg_pdf, bg_pdf, out_file, compress):\n    if settings.PDFTK:\n        with tempfile.TemporaryDirectory() as d:\n            fg_filename = os.path.join(d, 'fg.pdf')\n            bg_filename = os.path.join(d, 'bg.pdf')\n            fg_pdf.write(fg_filename)\n            bg_pdf.write(bg_filename)\n            pdftk_cmd = [\n                settings.PDFTK,\n                fg_filename,\n                'multibackground',\n                bg_filename,\n                'output',\n                '-',\n            ]\n            if compress:\n                pdftk_cmd.append('compress')\n            subprocess.run(pdftk_cmd, check=True, stdout=out_file)\n    else:\n        output = PdfWriter()\n        for i, page in enumerate(fg_pdf.pages):\n            bg_page = copy.deepcopy(bg_pdf.pages[i])\n            bg_rotation = bg_page.get('/Rotate')\n            if bg_rotation:\n                # /Rotate is clockwise, transformation.rotate is counter-clockwise\n                t = Transformation().rotate(bg_rotation)\n                w = float(page.mediabox.getWidth())\n                h = float(page.mediabox.getHeight())\n                if bg_rotation in (90, 270):\n                    # offset due to rotation base\n                    if bg_rotation == 90:\n                        t = t.translate(h, 0)\n                    else:\n                        t = t.translate(0, w)\n                    # rotate mediabox as well\n                    page.mediabox = RectangleObject((\n                        page.mediabox.left.as_numeric(),\n                        page.mediabox.bottom.as_numeric(),\n                        page.mediabox.top.as_numeric(),\n                        page.mediabox.right.as_numeric(),\n                    ))\n                    page.trimbox = page.mediabox\n                elif bg_rotation == 180:\n                    t = t.translate(w, h)\n                page.add_transformation(t)\n            bg_page.merge_page(page)\n            output.add_page(bg_page)\n        output.write(out_file)\n\n\n@deconstructible\nclass PdfLayoutValidator:\n    def __call__(self, value):\n        if not isinstance(value, dict):\n            try:\n                val = json.loads(value)\n            except ValueError:\n                raise ValidationError(_('Your layout file is not a valid JSON file.'))\n        else:\n            val = value\n        with open(finders.find('schema/pdf-layout.schema.json'), 'r') as f:\n            schema = json.loads(f.read())\n        try:\n            jsonschema.validate(val, schema)\n        except jsonschema.ValidationError as e:\n            e = str(e).replace('%', '%%')\n            raise ValidationError(_('Your layout file is not a valid layout. Error message: {}').format(e))\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Daniel, Heok Hong Low, Ian Williams, Maico Timmerman,\n# Sanket Dasgupta, Tobias Kunze, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport json\nimport operator\nfrom collections import OrderedDict, UserList\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom typing import Any\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import File\nfrom django.core.validators import (\n    MaxValueValidator, MinValueValidator, RegexValidator,\n)\nfrom django.db.models import Model\nfrom django.utils.functional import lazy\nfrom django.utils.text import format_lazy\nfrom django.utils.translation import (\n    gettext, gettext_lazy as _, gettext_noop, pgettext, pgettext_lazy,\n)\nfrom django_countries.fields import Country\nfrom hierarkey.models import GlobalSettingsBase, Hierarkey\nfrom i18nfield.forms import I18nFormField, I18nTextarea, I18nTextInput\nfrom i18nfield.strings import LazyI18nString\nfrom phonenumbers import PhoneNumber, parse\nfrom rest_framework import serializers\n\nfrom pretix.api.serializers.fields import (\n    ListMultipleChoiceField, UploadedFileField,\n)\nfrom pretix.api.serializers.i18n import I18nField, I18nURLField\nfrom pretix.base.forms import I18nURLFormField\nfrom pretix.base.models.tax import VAT_ID_COUNTRIES, TaxRule\nfrom pretix.base.reldate import (\n    RelativeDateField, RelativeDateTimeField, RelativeDateWrapper,\n    SerializerRelativeDateField, SerializerRelativeDateTimeField,\n)\nfrom pretix.control.forms import (\n    ExtFileField, FontSelect, MultipleLanguagesWidget, SingleLanguageWidget,\n)\nfrom pretix.helpers.countries import CachedCountries\n\n\ndef country_choice_kwargs():\n    allcountries = list(CachedCountries())\n    allcountries.insert(0, ('', _('Select country')))\n    return {\n        'choices': allcountries\n    }\n\n\ndef primary_font_kwargs():\n    from pretix.presale.style import get_fonts\n\n    choices = [('Open Sans', 'Open Sans')]\n    choices += sorted([\n        (a, {\"title\": a, \"data\": v}) for a, v in get_fonts().items() if not v.get('pdf_only', False)\n    ], key=lambda a: a[0])\n    return {\n        'choices': choices,\n    }\n\n\ndef invoice_font_kwargs():\n    from pretix.presale.style import get_fonts\n\n    choices = [('Open Sans', 'Open Sans')]\n    choices += sorted([\n        (a, a) for a, v in get_fonts().items()\n    ], key=lambda a: a[0])\n    return {\n        'choices': choices,\n    }\n\n\ndef restricted_plugin_kwargs():\n    from pretix.base.plugins import get_all_plugins\n\n    plugins_available = [\n        (p.module, p.name) for p in get_all_plugins(None)\n        if (\n            not p.name.startswith('.') and\n            getattr(p, 'restricted', False) and\n            not hasattr(p, 'is_available')  # this means you should not really use restricted and is_available\n        )\n    ]\n    return {\n        'widget': forms.CheckboxSelectMultiple,\n        'label': _(\"Allow usage of restricted plugins\"),\n        'choices': plugins_available,\n    }\n\n\nclass LazyI18nStringList(UserList):\n    def __init__(self, init_list=None):\n        super().__init__()\n        if init_list is not None:\n            self.data = [v if isinstance(v, LazyI18nString) else LazyI18nString(v) for v in init_list]\n\n    def serialize(self):\n        return json.dumps([s.data for s in self.data])\n\n    @classmethod\n    def unserialize(cls, s):\n        return cls(json.loads(s))\n\n\nDEFAULTS = {\n    'allowed_restricted_plugins': {\n        'default': [],\n        'type': list,\n        'form_class': forms.MultipleChoiceField,\n        'serializer_class': serializers.MultipleChoiceField,\n        'form_kwargs': lambda: restricted_plugin_kwargs(),\n    },\n    'customer_accounts': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to create accounts\"),\n            help_text=_(\"This will allow customers to sign up for an account on your ticket shop. This is a prerequisite for some \"\n                        \"advanced features like memberships.\")\n        )\n    },\n    'customer_accounts_native': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to log in with email address and password\"),\n            help_text=_(\"If disabled, you will need to connect one or more single-sign-on providers.\"),\n            widget=forms.CheckboxInput(attrs={'data-display-dependency': '#id_settings-customer_accounts'}),\n        )\n    },\n    'customer_accounts_link_by_email': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Match orders based on email address\"),\n            help_text=_(\"This will allow registered customers to access orders made with the same email address, even if the customer \"\n                        \"was not logged in during the purchase.\")\n        )\n    },\n    'reusable_media_active': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Activate re-usable media\"),\n            help_text=_(\"The re-usable media feature allows you to connect tickets and gift cards with physical media \"\n                        \"such as wristbands or chip cards that may be re-used for different tickets or gift cards \"\n                        \"later.\")\n        )\n    },\n    'reusable_media_type_barcode': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_barcode_identifier_length': {\n        'default': 24,\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ]\n        ),\n        'form_kwargs': dict(\n            label=_('Length of barcodes'),\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ],\n            required=True,\n            widget=forms.NumberInput(\n                attrs={\n                    'min': '12',\n                    'max': '64',\n                },\n            ),\n        )\n    },\n    'reusable_media_type_nfc_uid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_nfc_uid_autocreate_giftcard': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically create a new gift card if a previously unknown chip is seen\"),\n        )\n    },\n    'reusable_media_type_nfc_uid_autocreate_giftcard_currency': {\n        'default': 'EUR',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n        ),\n        'form_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n            label=_(\"Gift card currency\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Active\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_autocreate_giftcard': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically create a new gift card if a new chip is encoded\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_autocreate_giftcard_currency': {\n        'default': 'EUR',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n        ),\n        'form_kwargs': dict(\n            choices=[(c.alpha_3, c.alpha_3 + \" - \" + c.name) for c in settings.CURRENCIES],\n            label=_(\"Gift card currency\"),\n        )\n    },\n    'reusable_media_type_nfc_mf0aes_random_uid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use UID protection feature of NFC chip\"),\n        )\n    },\n    'max_items_per_order': {\n        'default': '10',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            min_value=1,\n            required=True,\n            label=_(\"Maximum number of items per order\"),\n            help_text=_(\"Add-on products will not be counted.\")\n        ),\n    },\n    'display_net_prices': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show net prices instead of gross prices in the product list (not recommended!)\"),\n            help_text=_(\"Independent of your choice, the cart will show gross prices as this is the price that needs to be \"\n                        \"paid.\"),\n\n        )\n    },\n    'hide_prices_from_attendees': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide prices on attendee ticket page\"),\n            help_text=_(\"If a person buys multiple tickets and you send emails to all of the attendees, with this \"\n                        \"option the ticket price will not be shown on the ticket page of the individual attendees. \"\n                        \"The ticket buyer will of course see the price.\"),\n\n        )\n    },\n    'system_question_order': {\n        'default': {},\n        'type': dict,\n        'serializer_class': serializers.DictField,\n        'serializer_kwargs': lambda: dict(read_only=True, allow_empty=True),\n    },\n    'attendee_names_asked': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for attendee names\"),\n            help_text=_(\"Ask for a name for all personalized tickets.\"),\n        )\n    },\n    'attendee_names_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require attendee names\"),\n            help_text=_(\"Require customers to fill in the names of all attendees.\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_names_asked'}),\n        )\n    },\n    'attendee_emails_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for email addresses per ticket\"),\n            help_text=_(\"Normally, pretix asks for one email address per order and the order confirmation will be sent \"\n                        \"only to that email address. If you enable this option, the system will additionally ask for \"\n                        \"individual email addresses for every personalized ticket. This might be useful if you want to \"\n                        \"obtain individual addresses for every attendee even in case of group orders. However, \"\n                        \"pretix will send the order confirmation by default only to the one primary email address, not to \"\n                        \"the per-attendee addresses. You can however enable this in the email settings.\"),\n        )\n    },\n    'attendee_emails_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require email addresses per ticket\"),\n            help_text=_(\"Require customers to fill in individual email addresses for all personalized tickets. See the \"\n                        \"above option for more details. One email address for the order confirmation will always be \"\n                        \"required regardless of this setting.\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_emails_asked'}),\n        )\n    },\n    'attendee_company_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for company per ticket\"),\n        )\n    },\n    'attendee_company_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require company per ticket\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_company_asked'}),\n        )\n    },\n    'attendee_addresses_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for postal addresses per ticket\"),\n        )\n    },\n    'attendee_addresses_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require postal addresses per ticket\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-attendee_addresses_asked'}),\n        )\n    },\n    'order_email_asked_twice': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for the order email address twice\"),\n            help_text=_(\"Require customers to fill in the primary email address twice to avoid errors.\"),\n        )\n    },\n    'order_phone_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a phone number per order\"),\n        )\n    },\n    'order_phone_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require a phone number per order\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-order_phone_asked'}),\n        )\n    },\n    'invoice_address_asked': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for invoice address\"),\n        )\n    },\n    'invoice_address_not_asked_free': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Do not ask for invoice address if an order is free'),\n        )\n    },\n    'invoice_name_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require customer name\"),\n        )\n    },\n    'invoice_attendee_name': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show attendee names on invoices\"),\n        )\n    },\n    'invoice_event_location': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event location on invoices\"),\n            help_text=_(\"The event location will be shown below the list of products if it is the same for all \"\n                        \"lines. It will be shown on every line if there are different locations.\")\n        )\n    },\n    'invoice_eu_currencies': {\n        'default': 'True',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'form_kwargs': dict(\n            label=_(\"Show exchange rates\"),\n            widget=forms.RadioSelect,\n            choices=(\n                ('False', _('Never')),\n                ('True', _('Based on European Central Bank daily rates, whenever the invoice recipient is in an EU '\n                           'country that uses a different currency.')),\n                ('CZK', _('Based on Czech National Bank daily rates, whenever the invoice amount is not in CZK.')),\n            ),\n        ),\n        'serializer_kwargs': dict(\n            choices=(\n                ('False', _('Never')),\n                ('True', _('Based on European Central Bank daily rates, whenever the invoice recipient is in an EU '\n                           'country that uses a different currency.')),\n                ('CZK', _('Based on Czech National Bank daily rates, whenever the invoice amount is not in CZK.')),\n            ),\n        ),\n    },\n    'invoice_address_required': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'type': bool,\n        'form_kwargs': dict(\n            label=_(\"Require invoice address\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_company_required': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'type': bool,\n        'form_kwargs': dict(\n            label=_(\"Require a business addresses\"),\n            help_text=_('This will require users to enter a company name.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_required'}),\n        )\n    },\n    'invoice_address_beneficiary': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for beneficiary\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_custom_field': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Custom recipient field\"),\n            widget=I18nTextInput,\n            help_text=_(\"If you want to add a custom text field, e.g. for a country-specific registration number, to \"\n                        \"your invoice address form, please fill in the label here. This label will both be used for \"\n                        \"asking the user to input their details as well as for displaying the value on the invoice. It will \"\n                        \"be shown on the invoice below the headline. \"\n                        \"The field will not be required.\")\n        )\n    },\n    'invoice_address_vatid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for VAT ID\"),\n            help_text=format_lazy(\n                _(\"Only works if an invoice address is asked for. VAT ID is never required and only requested from \"\n                  \"business customers in the following countries: {countries}\"),\n                countries=lazy(lambda *args: ', '.join(sorted(gettext(Country(cc).name) for cc in VAT_ID_COUNTRIES)), str)()\n            ),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_invoice_address_asked'}),\n        )\n    },\n    'invoice_address_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Invoice address explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the invoice address form during checkout.\")\n        )\n    },\n    'invoice_show_payments': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show paid amount on partially paid invoices\"),\n            help_text=_(\"If an invoice has already been paid partially, this option will add the paid and pending \"\n                        \"amount to the invoice.\"),\n        )\n    },\n    'invoice_include_free': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show free products on invoices\"),\n            help_text=_(\"Note that invoices will never be generated for orders that contain only free \"\n                        \"products.\"),\n        )\n    },\n    'invoice_include_expire_date': {\n        'default': 'False',  # default for new events is True\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show expiration date of order\"),\n            help_text=_(\"The expiration date will not be shown if the invoice is generated after the order is paid.\"),\n        )\n    },\n    'invoice_numbers_counter_length': {\n        'default': '5',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(),\n        'form_kwargs': dict(\n            label=_(\"Minimum length of invoice number after prefix\"),\n            help_text=_(\"The part of your invoice number after your prefix will be filled up with leading zeros up to this length, e.g. INV-001 or INV-00001.\"),\n            max_value=12,\n            required=True,\n        )\n    },\n    'invoice_numbers_consecutive': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate invoices with consecutive numbers\"),\n            help_text=_(\"If deactivated, the order code will be used in the invoice number.\"),\n        )\n    },\n    'invoice_numbers_prefix': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Invoice number prefix\"),\n            help_text=_(\"This will be prepended to invoice numbers. If you leave this field empty, your event slug will \"\n                        \"be used followed by a dash. Attention: If multiple events within the same organization use the \"\n                        \"same value in this field, they will share their number range, i.e. every full number will be \"\n                        \"used at most once over all of your events. This setting only affects future invoices. You can \"\n                        \"use %Y (with century) %y (without century) to insert the year of the invoice, or %m and %d for \"\n                        \"the day of month.\"),\n            validators=[\n                RegexValidator(\n                    # We actually allow more characters than we name in the error message since some of these characters\n                    # are in active use at the time of the introduction of this validation, so we can't really forbid\n                    # them, but we don't think they belong in an invoice number and don't want to advertise them.\n                    regex=\"^[a-zA-Z0-9-_%./,&:# ]+$\",\n                    message=lazy(lambda *args: _('Please only use the characters {allowed} in this field.').format(\n                        allowed='A-Z, a-z, 0-9, -./:#'\n                    ), str)()\n                )\n            ],\n        )\n    },\n    'invoice_numbers_prefix_cancellations': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Invoice number prefix for cancellations\"),\n            help_text=_(\"This will be prepended to invoice numbers of cancellations. If you leave this field empty, \"\n                        \"the same numbering scheme will be used that you configured for regular invoices.\"),\n            validators=[\n                RegexValidator(\n                    # We actually allow more characters than we name in the error message since some of these characters\n                    # are in active use at the time of the introduction of this validation, so we can't really forbid\n                    # them, but we don't think they belong in an invoice number and don't want to advertise them.\n                    regex=\"^[a-zA-Z0-9-_%./,&:# ]+$\",\n                    message=lazy(lambda *args: _('Please only use the characters {allowed} in this field.').format(\n                        allowed='A-Z, a-z, 0-9, -./:#'\n                    ), str)()\n                )\n            ],\n        )\n    },\n    'invoice_renderer_highlight_order_code': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Highlight order code to make it stand out visibly\"),\n            help_text=_(\"Only respected by some invoice renderers.\"),\n        )\n    },\n    'invoice_renderer_font': {\n        'default': 'Open Sans',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**invoice_font_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Font'),\n            help_text=_(\"Only respected by some invoice renderers.\"),\n            required=True,\n            **invoice_font_kwargs()\n        ),\n    },\n    'invoice_renderer': {\n        'default': 'classic',  # default for new events is 'modern1'\n        'type': str,\n    },\n    'ticket_secret_generator': {\n        'default': 'random',\n        'type': str,\n    },\n    'ticket_secret_length': {\n        'default': settings.ENTROPY['ticket_secret'],\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ]\n        ),\n        'form_kwargs': dict(\n            label=_('Length of ticket codes'),\n            validators=[\n                MinValueValidator(12),\n                MaxValueValidator(64),\n            ],\n            required=True,\n            widget=forms.NumberInput(\n                attrs={\n                    'min': '12',\n                    'max': '64',\n                    'data-display-dependency': 'input[name=ticket_secret_generator][value=random]',\n                },\n            ),\n        )\n    },\n    'reservation_time': {\n        'default': '30',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=60 * 24 * 7,\n        ),\n        'form_kwargs': dict(\n            min_value=0,\n            max_value=60 * 24 * 7,\n            label=_(\"Reservation period\"),\n            required=True,\n            help_text=_(\"The number of minutes the items in a user's cart are reserved for this user.\"),\n        )\n    },\n    'redirect_to_checkout_directly': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Directly redirect to check-out after a product has been added to the cart.'),\n        )\n    },\n    'presale_has_ended_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"End of presale text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the ticket shop once the designated sales timeframe for this event \"\n                        \"is over. You can use it to describe other options to get a ticket, such as a box office.\")\n        )\n    },\n    'payment_explanation': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n            }},\n            label=_(\"Guidance text\"),\n            help_text=_(\"This text will be shown above the payment options. You can explain the choices to the user here, \"\n                        \"if you want.\")\n        )\n    },\n    'payment_term_mode': {\n        'default': 'days',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('days', _(\"in days\")),\n                ('minutes', _(\"in minutes\"))\n            ),\n        ),\n        'form_kwargs': dict(\n            label=_(\"Set payment term\"),\n            widget=forms.RadioSelect,\n            required=True,\n            choices=(\n                ('days', _(\"in days\")),\n                ('minutes', _(\"in minutes\"))\n            ),\n            help_text=_(\"If using days, the order will expire at the end of the last day. \"\n                        \"Using minutes is more exact, but should only be used for real-time payment methods.\")\n        )\n    },\n    'payment_term_days': {\n        'default': '14',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Payment term in days'),\n            widget=forms.NumberInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_0',\n                    'data-required-if': '#id_payment_term_mode_0'\n                },\n            ),\n            help_text=_(\"The number of days after placing an order the user has to pay to preserve their reservation. If \"\n                        \"you use slow payment methods like bank transfer, we recommend 14 days. If you only use real-time \"\n                        \"payment methods, we recommend still setting two or three days to allow people to retry failed \"\n                        \"payments.\"),\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1000000)]\n        ),\n        'serializer_kwargs': dict(\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1000000)]\n        )\n    },\n    'payment_term_weekdays': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Only end payment terms on weekdays'),\n            help_text=_(\"If this is activated and the payment term of any order ends on a Saturday or Sunday, it will be \"\n                        \"moved to the next Monday instead. This is required in some countries by civil law. This will \"\n                        \"not effect the last date of payments configured below.\"),\n            widget=forms.CheckboxInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_0',\n                },\n            ),\n        )\n    },\n    'payment_term_minutes': {\n        'default': '30',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Payment term in minutes'),\n            help_text=_(\"The number of minutes after placing an order the user has to pay to preserve their reservation. \"\n                        \"Only use this if you exclusively offer real-time payment methods. Please note that for technical reasons, \"\n                        \"the actual time frame might be a few minutes longer before the order is marked as expired.\"),\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1440)],\n            widget=forms.NumberInput(\n                attrs={\n                    'data-display-dependency': '#id_payment_term_mode_1',\n                    'data-required-if': '#id_payment_term_mode_1'\n                },\n            ),\n        ),\n        'serializer_kwargs': dict(\n            validators=[MinValueValidator(0),\n                        MaxValueValidator(1440)]\n        )\n    },\n    'payment_term_last': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateField,\n        'serializer_class': SerializerRelativeDateField,\n        'form_kwargs': dict(\n            label=_('Last date of payments'),\n            help_text=_(\"The last date any payments are accepted. This has precedence over the terms \"\n                        \"configured above. If you use the event series feature and an order contains tickets for \"\n                        \"multiple dates, the earliest date will be used.\"),\n        )\n    },\n    'payment_term_expire_automatically': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Automatically expire unpaid orders'),\n            help_text=_(\"If checked, all unpaid orders will automatically go from 'pending' to 'expired' \"\n                        \"after the end of their payment deadline. This means that those tickets go back to \"\n                        \"the pool and can be ordered by other people.\"),\n        )\n    },\n    'payment_term_expire_delay_days': {\n        'default': '0',\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Expiration delay'),\n            help_text=_(\"The order will only actually expire this many days after the expiration date communicated \"\n                        \"to the customer. If you select \\\"Only end payment terms on weekdays\\\" above, this will also \"\n                        \"be respected. However, this will not delay beyond the \\\"last date of payments\\\" \"\n                        \"configured above, which is always enforced.\"),\n            # Every order in between the official expiry date and the delayed expiry date has a performance penalty\n            # for the cron job, so we limit this feature to 30 days to prevent arbitrary numbers of orders needing\n            # to be checked.\n            min_value=0,\n            max_value=30,\n        ),\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=30,\n        ),\n    },\n    'payment_pending_hidden': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Hide \"payment pending\" state on customer-facing pages'),\n            help_text=_(\"The payment instructions panel will still be shown to the primary customer, but no indication \"\n                        \"of missing payment will be visible on the ticket pages of attendees who did not buy the ticket \"\n                        \"themselves.\")\n        )\n    },\n    'payment_giftcard__enabled': {\n        'default': 'True',\n        'type': bool\n    },\n    'payment_giftcard_public_name': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Gift card')),\n        'type': LazyI18nString\n    },\n    'payment_giftcard_public_description': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'If you have a gift card, please enter the gift card code here. If the gift card does not have '\n            'enough credit to pay for the full order, you will be shown this page again and you can either '\n            'redeem another gift card or select a different payment method for the difference.'\n        )),\n        'type': LazyI18nString\n    },\n    'payment_resellers__restrict_to_sales_channels': {\n        'default': ['resellers'],\n        'type': list\n    },\n    'payment_term_accept_late': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Accept late payments'),\n            help_text=_(\"Accept payments for orders even when they are in 'expired' state as long as enough \"\n                        \"capacity is available. No payments will ever be accepted after the 'Last date of payments' \"\n                        \"configured above.\"),\n        )\n    },\n    'presale_start_show_date': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show start date\"),\n            help_text=_(\"Show the presale start date before presale has started.\"),\n            widget=forms.CheckboxInput,\n        )\n    },\n    'tax_rate_default': {\n        'default': None,\n        'type': TaxRule\n    },\n    'invoice_generate': {\n        'default': 'False',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('False', _('Do not generate invoices')),\n                ('admin', _('Only manually in admin panel')),\n                ('user', _('Automatically on user request')),\n                ('True', _('Automatically for all created orders')),\n                ('paid', _('Automatically on payment or when required by payment method')),\n            ),\n        ),\n        'form_kwargs': dict(\n            label=_(\"Generate invoices\"),\n            widget=forms.RadioSelect,\n            choices=(\n                ('False', _('Do not generate invoices')),\n                ('admin', _('Only manually in admin panel')),\n                ('user', _('Automatically on user request')),\n                ('True', _('Automatically for all created orders')),\n                ('paid', _('Automatically on payment or when required by payment method')),\n            ),\n            help_text=_(\"Invoices will never be automatically generated for free orders.\")\n        )\n    },\n    'invoice_reissue_after_modify': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatically cancel and reissue invoice on address changes\"),\n            help_text=_(\"If customers change their invoice address on an existing order, the invoice will \"\n                        \"automatically be canceled and a new invoice will be issued. This setting does not affect \"\n                        \"changes made through the backend.\"),\n        )\n    },\n    'invoice_regenerate_allowed': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow to update existing invoices\"),\n            help_text=_(\"By default, invoices can never again be changed once they are issued. In most countries, we \"\n                        \"recommend to leave this option turned off and always issue a new invoice if a change needs \"\n                        \"to be made.\"),\n        )\n    },\n    'invoice_generate_sales_channels': {\n        'default': json.dumps(['web']),\n        'type': list\n    },\n    'invoice_address_from': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Address line\"),\n            widget=forms.Textarea(attrs={\n                'rows': 2,\n                'placeholder': _(\n                    'Albert Einstein Road 52'\n                )\n            }),\n        )\n    },\n    'invoice_address_from_name': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Company name\"),\n        )\n    },\n    'invoice_address_from_zipcode': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            widget=forms.TextInput(attrs={\n                'placeholder': '12345'\n            }),\n            label=_(\"ZIP code\"),\n        )\n    },\n    'invoice_address_from_city': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            widget=forms.TextInput(attrs={\n                'placeholder': _('Random City')\n            }),\n            label=_(\"City\"),\n        )\n    },\n    'invoice_address_from_country': {\n        'default': '',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**country_choice_kwargs()),\n        'form_kwargs': lambda: dict(label=_('Country'), **country_choice_kwargs()),\n    },\n    'invoice_address_from_tax_id': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Domestic tax ID\"),\n            help_text=_(\"e.g. tax number in Germany, ABN in Australia, \u2026\")\n        )\n    },\n    'invoice_address_from_vat_id': {\n        'default': '',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"EU VAT ID\"),\n        )\n    },\n    'invoice_introductory_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n                'placeholder': _(\n                    'e.g. With this document, we sent you the invoice for your ticket order.'\n                )\n            }},\n            label=_(\"Introductory text\"),\n            help_text=_(\"Will be printed on every invoice above the invoice rows.\")\n        )\n    },\n    'invoice_additional_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 3,\n                'placeholder': _(\n                    'e.g. Thank you for your purchase! You can find more information on the event at ...'\n                )\n            }},\n            label=_(\"Additional text\"),\n            help_text=_(\"Will be printed on every invoice below the invoice total.\")\n        )\n    },\n    'invoice_footer_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {\n                'rows': 5,\n                'placeholder': _(\n                    'e.g. your bank details, legal details like your VAT ID, registration numbers, etc.'\n                )\n            }},\n            label=_(\"Footer\"),\n            help_text=_(\"Will be printed centered and in a smaller font at the end of every invoice page.\")\n        )\n    },\n    'invoice_language': {\n        'default': '__user__',\n        'type': str\n    },\n    'invoice_email_attachment': {\n        'default': 'False',  # default for new events is True\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach invoices to emails\"),\n            help_text=_(\"If invoices are automatically generated for all orders, they will be attached to the order \"\n                        \"confirmation mail. If they are automatically generated on payment, they will be attached to the \"\n                        \"payment confirmation mail. If they are not automatically generated, they will not be attached \"\n                        \"to emails.\"),\n        )\n    },\n    'invoice_email_organizer': {\n        'default': '',\n        'type': str,\n        'form_class': forms.EmailField,\n        'serializer_class': serializers.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Email address to receive a copy of each invoice\"),\n            help_text=_(\"Each newly created invoice will be sent to this email address shortly after creation. You can \"\n                        \"use this for an automated import of invoices to your accounting system. The invoice will be \"\n                        \"the only attachment of the email.\"),\n        )\n    },\n    'show_items_outside_presale_period': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show items outside presale period\"),\n            help_text=_(\"Show item details before presale has started and after presale has ended\"),\n        )\n    },\n    'timezone': {\n        'default': settings.TIME_ZONE,\n        'type': str\n    },\n    'locales': {\n        'default': json.dumps([settings.LANGUAGE_CODE]),\n        'type': list,\n        'serializer_class': ListMultipleChoiceField,\n        'serializer_kwargs': dict(\n            choices=settings.LANGUAGES,\n            required=True,\n        ),\n        'form_class': forms.MultipleChoiceField,\n        'form_kwargs': dict(\n            choices=settings.LANGUAGES,\n            widget=MultipleLanguagesWidget,\n            required=True,\n            label=_(\"Available languages\"),\n        )\n    },\n    'locale': {\n        'default': settings.LANGUAGE_CODE,\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=settings.LANGUAGES,\n            required=True,\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            choices=settings.LANGUAGES,\n            widget=SingleLanguageWidget,\n            required=True,\n            label=_(\"Default language\"),\n        )\n    },\n    'region': {\n        'default': None,\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**country_choice_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Region'),\n            help_text=_('Will be used to determine date and time formatting as well as default country for customer '\n                        'addresses and phone numbers. For formatting, this takes less priority than the language and '\n                        'is therefore mostly relevant for languages used in different regions globally (like English).'),\n            **country_choice_kwargs()\n        ),\n    },\n    'show_dates_on_frontpage': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event times and dates on the ticket shop\"),\n            help_text=_(\"If disabled, no date or time will be shown on the ticket shop's front page. This settings \"\n                        \"does however not affect the display in other locations.\"),\n        )\n    },\n    'show_date_to': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show event end date\"),\n            help_text=_(\"If disabled, only event's start date will be displayed to the public.\"),\n        )\n    },\n    'show_times': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show dates with time\"),\n            help_text=_(\"If disabled, the event's start and end date will be displayed without the time of day.\"),\n        )\n    },\n    'hide_sold_out': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all products that are sold out\"),\n        )\n    },\n    'show_quota_left': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show number of tickets left\"),\n            help_text=_(\"Publicly show how many tickets of a certain type are still available.\"),\n        )\n    },\n    'meta_noindex': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Ask search engines not to index the ticket shop'),\n        )\n    },\n    'show_variations_expanded': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show variations of a product expanded by default\"),\n        )\n    },\n    'waiting_list_enabled': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Enable waiting list\"),\n            help_text=_(\"Once a ticket is sold out, people can add themselves to a waiting list. As soon as a ticket \"\n                        \"becomes available again, it will be reserved for the first person on the waiting list and this \"\n                        \"person will receive an email notification with a voucher that can be used to buy a ticket.\"),\n        )\n    },\n    'waiting_list_auto': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Automatic waiting list assignments\"),\n            help_text=_(\"If ticket capacity becomes free, automatically create a voucher and send it to the first person \"\n                        \"on the waiting list for that product. If this is not active, mails will not be send automatically \"\n                        \"but you can send them manually via the control panel. If you disable the waiting list but keep \"\n                        \"this option enabled, tickets will still be sent out.\"),\n            widget=forms.CheckboxInput(),\n        )\n    },\n    'waiting_list_hours': {\n        'default': '48',\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Waiting list response time\"),\n            min_value=1,\n            required=True,\n            help_text=_(\"If a ticket voucher is sent to a person on the waiting list, it has to be redeemed within this \"\n                        \"number of hours until it expires and can be re-assigned to the next person on the list.\"),\n            widget=forms.NumberInput(),\n        )\n    },\n    'waiting_list_names_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a name\"),\n            help_text=_(\"Ask for a name when signing up to the waiting list.\"),\n        )\n    },\n    'waiting_list_names_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require name\"),\n            help_text=_(\"Require a name when signing up to the waiting list..\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-waiting_list_names_asked'}),\n        )\n    },\n    'waiting_list_phones_asked': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Ask for a phone number\"),\n            help_text=_(\"Ask for a phone number when signing up to the waiting list.\"),\n        )\n    },\n    'waiting_list_phones_required': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Require phone number\"),\n            help_text=_(\"Require a phone number when signing up to the waiting list..\"),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_settings-waiting_list_phones_asked'}),\n        )\n    },\n    'waiting_list_phones_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'serializer_class': I18nField,\n        'form_kwargs': dict(\n            label=_(\"Phone number explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"If you ask for a phone number, explain why you do so and what you will use the phone number for.\")\n        )\n    },\n    'waiting_list_limit_per_user': {\n        'default': '1',\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=1,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Maximum number of entries per email address for the same product\"),\n            min_value=1,\n            required=True,\n            widget=forms.NumberInput(),\n        )\n    },\n    'show_checkin_number_user': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show number of check-ins to customer\"),\n            help_text=_('With this option enabled, your customers will be able to see how many times they entered '\n                        'the event. This is usually not necessary, but might be useful in combination with tickets '\n                        'that are usable a specific number of times, so customers can see how many times they have '\n                        'already been used. Exits or failed scans will not be counted, and the user will not see '\n                        'the different check-in lists.'),\n        )\n    },\n    'ticket_download': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow users to download tickets\"),\n            help_text=_(\"If this is off, nobody can download a ticket.\"),\n        )\n    },\n    'ticket_download_date': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Download date\"),\n            help_text=_(\"Ticket download will be offered after this date. If you use the event series feature and an order \"\n                        \"contains tickets for multiple event dates, download of all tickets will be available if at least \"\n                        \"one of the event dates allows it.\"),\n        )\n    },\n    'ticket_download_addons': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for add-on products and bundled products\"),\n            help_text=_('By default, tickets are only issued for products selected individually, not for add-on products '\n                        'or bundled products. With this option, a separate ticket is issued for every add-on product '\n                        'or bundled product as well.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_nonadm': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for all products\"),\n            help_text=_('If turned off, tickets are only issued for products that are marked as an \"admission ticket\"'\n                        'in the product settings. You can also turn off ticket issuing in every product separately.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_pending': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Generate tickets for pending orders\"),\n            help_text=_('If turned off, ticket downloads are only possible after an order has been marked as paid.'),\n            widget=forms.CheckboxInput(attrs={'data-checkbox-dependency': '#id_ticket_download',\n                                              'data-checkbox-dependency-visual': 'on'}),\n        )\n    },\n    'ticket_download_require_validated_email': {\n        'default': 'False',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Do not issue ticket before email address is validated\"),\n            help_text=_(\"If turned on, tickets will not be offered for download directly after purchase. They will \"\n                        \"be attached to the payment confirmation email (if the file size is not too large), and the \"\n                        \"customer will be able to download them from the page as soon as they clicked a link in \"\n                        \"the email. Does not affect orders performed through other sales channels.\"),\n        )\n    },\n    'low_availability_percentage': {\n        'default': None,\n        'type': int,\n        'serializer_class': serializers.IntegerField,\n        'form_class': forms.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n            max_value=100,\n        ),\n        'form_kwargs': dict(\n            label=_('Low availability threshold'),\n            help_text=_('If the availability of tickets falls below this percentage, the event (or a date, if it is an '\n                        'event series) will be highlighted to have low availability in the event list or calendar. If '\n                        'you keep this option empty, low availability will not be shown publicly.'),\n            min_value=0,\n            max_value=100,\n            required=False\n        )\n    },\n    'event_list_availability': {\n        'default': 'True',\n        'type': bool,\n        'serializer_class': serializers.BooleanField,\n        'form_class': forms.BooleanField,\n        'form_kwargs': dict(\n            label=_('Show availability in event overviews'),\n            help_text=_('If checked, the list of events will show if events are sold out. This might '\n                        'make for longer page loading times if you have lots of events and the shown status might be out '\n                        'of date for up to two minutes.'),\n            required=False\n        )\n    },\n    'event_list_type': {\n        'default': 'list',  # default for new events is 'calendar'\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('list', _('List')),\n                ('week', _('Week calendar')),\n                ('calendar', _('Month calendar')),\n            )\n        ),\n        'form_kwargs': dict(\n            label=_('Default overview style'),\n            choices=(\n                ('list', _('List')),\n                ('week', _('Week calendar')),\n                ('calendar', _('Month calendar')),\n            ),\n            help_text=_('If your event series has more than 50 dates in the future, only the month or week calendar can be used.')\n        ),\n    },\n    'event_list_available_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all unavailable dates from calendar or list views\"),\n            help_text=_(\"This option currently only affects the calendar of this event series, not the organizer-wide \"\n                        \"calendar.\")\n        )\n    },\n    'event_calendar_future_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Hide all past dates from calendar\"),\n            help_text=_(\"This option currently only affects the calendar of this event series, not the organizer-wide \"\n                        \"calendar.\")\n        )\n    },\n    'allow_modifications_after_checkin': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to modify their information after they checked in.\"),\n        )\n    },\n    'last_order_modification_date': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_('Last date of modifications'),\n            help_text=_(\"The last date users can modify details of their orders, such as attendee names or \"\n                        \"answers to questions. If you use the event series feature and an order contains tickets for \"\n                        \"multiple event dates, the earliest date will be used.\"),\n        )\n    },\n    'change_allow_user_variation': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can change the variation of the products they purchased\"),\n        )\n    },\n    'change_allow_user_addons': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can change their selected add-on products\"),\n        )\n    },\n    'change_allow_user_price': {\n        'default': 'gte',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=(\n                ('gte', _('Only allow changes if the resulting price is higher or equal than the previous price.')),\n                ('gt', _('Only allow changes if the resulting price is higher than the previous price.')),\n                ('eq', _('Only allow changes if the resulting price is equal to the previous price.')),\n                ('any', _('Allow changes regardless of price, even if this results in a refund.')),\n            )\n        ),\n        'form_kwargs': dict(\n            label=_(\"Requirement for changed prices\"),\n            choices=(\n                ('gte', _('Only allow changes if the resulting price is higher or equal than the previous price.')),\n                ('gt', _('Only allow changes if the resulting price is higher than the previous price.')),\n                ('eq', _('Only allow changes if the resulting price is equal to the previous price.')),\n                ('any', _('Allow changes regardless of price, even if this results in a refund.')),\n            ),\n            widget=forms.RadioSelect,\n        ),\n    },\n    'change_allow_user_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow changes after\"),\n        )\n    },\n    'change_allow_user_if_checked_in': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow change even though the ticket has already been checked in\"),\n            help_text=_(\"By default, order changes are disabled after any ticket in the order has been checked in. \"\n                        \"If you check this box, this requirement is lifted. It is still not possible to remove an \"\n                        \"add-on product that has already been checked in individually. Use with care, and preferably \"\n                        \"only in combination with a limitation on price changes above.\"),\n        )\n    },\n    'change_allow_attendee': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow individual attendees to change their ticket\"),\n            help_text=_(\"By default, only the person who ordered the tickets can make any changes. If you check this \"\n                        \"box, individual attendees can also make changes. However, individual attendees can always \"\n                        \"only make changes that do not change the total price of the order. Such changes can always \"\n                        \"only be made by the main customer.\"),\n        )\n    },\n    'cancel_allow_user': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can cancel their unpaid orders\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Charge a fixed cancellation fee\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Charge payment, shipping and service fees\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_unpaid_keep_percentage': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Charge a percentual cancellation fee\"),\n            help_text=_(\"Only affects orders pending payments, a cancellation fee for free orders is never charged. \"\n                        \"Note that it will be your responsibility to claim the cancellation fee from the user.\"),\n        )\n    },\n    'cancel_allow_user_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow cancellations after\"),\n        )\n    },\n    'cancel_allow_user_paid': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can cancel their paid orders\"),\n            help_text=_(\"Paid money will be automatically paid back if the payment method allows it. \"\n                        \"Otherwise, a manual refund will be created for you to process manually.\"),\n        )\n    },\n    'cancel_allow_user_paid_keep': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Keep a fixed cancellation fee\"),\n        )\n    },\n    'cancel_allow_user_paid_keep_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Keep payment, shipping and service fees\"),\n        )\n    },\n    'cancel_allow_user_paid_keep_percentage': {\n        'default': '0.00',\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            label=_(\"Keep a percentual cancellation fee\"),\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Allow customers to voluntarily choose a lower refund\"),\n            help_text=_(\"With this option enabled, your customers can choose to get a smaller refund to support you.\")\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees_explanation': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'However, if you want us to help keep the lights on here, please consider using the slider below to '\n            'request a smaller refund. Thank you!'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Voluntary lower refund explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown in between the explanation of how the refunds work and the slider \"\n                        \"which your customers can use to choose the amount they would like to receive. You can use it \"\n                        \"e.g. to explain choosing a lower refund will help your organization.\")\n        )\n    },\n    'cancel_allow_user_paid_adjust_fees_step': {\n        'default': None,\n        'type': Decimal,\n        'form_class': forms.DecimalField,\n        'serializer_class': serializers.DecimalField,\n        'serializer_kwargs': dict(\n            max_digits=13, decimal_places=2\n        ),\n        'form_kwargs': dict(\n            max_digits=13, decimal_places=2,\n            label=_(\"Step size for reduction amount\"),\n            help_text=_('By default, customers can choose an arbitrary amount for you to keep. If you set this to e.g. '\n                        '10, they will only be able to choose values in increments of 10.')\n        )\n    },\n    'cancel_allow_user_paid_require_approval': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can only request a cancellation that needs to be approved by the event organizer \"\n                    \"before the order is canceled and a refund is issued.\"),\n        )\n    },\n    'cancel_allow_user_paid_require_approval_fee_unknown': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Do not show the cancellation fee to users when they request cancellation.\"),\n        )\n    },\n    'cancel_allow_user_paid_refund_as_giftcard': {\n        'default': 'off',\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[\n                ('off', _('All refunds are issued to the original payment method')),\n                ('option', _('Customers can choose between a gift card and a refund to their payment method')),\n                ('force', _('All refunds are issued as gift cards')),\n                ('manually', _('Do not handle refunds automatically at all')),\n            ],\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            label=_('Refund method'),\n            choices=[\n                ('off', _('All refunds are issued to the original payment method')),\n                ('option', _('Customers can choose between a gift card and a refund to their payment method')),\n                ('force', _('All refunds are issued as gift cards')),\n                ('manually', _('Do not handle refunds automatically at all')),\n            ],\n            widget=forms.RadioSelect,\n            # When adding a new ordering, remember to also define it in the event model\n        )\n    },\n    'cancel_allow_user_paid_until': {\n        'default': None,\n        'type': RelativeDateWrapper,\n        'form_class': RelativeDateTimeField,\n        'serializer_class': SerializerRelativeDateTimeField,\n        'form_kwargs': dict(\n            label=_(\"Do not allow cancellations after\"),\n        )\n    },\n    'contact_mail': {\n        'default': None,\n        'type': str,\n        'serializer_class': serializers.EmailField,\n        'form_class': forms.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Contact address\"),\n            help_text=_(\"We'll show this publicly to allow attendees to contact you.\")\n        )\n    },\n    'imprint_url': {\n        'default': None,\n        'type': str,\n        'form_class': forms.URLField,\n        'form_kwargs': dict(\n            label=_(\"Imprint URL\"),\n            help_text=_(\"This should point e.g. to a part of your website that has your contact details and legal \"\n                        \"information.\"),\n        ),\n        'serializer_class': serializers.URLField,\n    },\n    'privacy_url': {\n        'default': None,\n        'type': LazyI18nString,\n        'form_class': I18nURLFormField,\n        'form_kwargs': dict(\n            label=_(\"Privacy Policy URL\"),\n            help_text=_(\"This should point e.g. to a part of your website that explains how you use data gathered in \"\n                        \"your ticket shop.\"),\n            widget=I18nTextInput,\n        ),\n        'serializer_class': I18nURLField,\n    },\n    'confirm_texts': {\n        'default': LazyI18nStringList(),\n        'type': LazyI18nStringList,\n        'serializer_class': serializers.ListField,\n        'serializer_kwargs': lambda: dict(child=I18nField()),\n    },\n    'mail_html_renderer': {\n        'default': 'classic',\n        'type': str\n    },\n    'mail_attach_tickets': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach ticket files\"),\n            help_text=format_lazy(\n                _(\"Tickets will never be attached if they're larger than {size} to avoid email delivery problems.\"),\n                size='4 MB'\n            ),\n        )\n    },\n    'mail_attach_ical': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach calendar files\"),\n            help_text=_(\"If enabled, we will attach an .ics calendar file to order confirmation emails.\"),\n        )\n    },\n    'mail_attach_ical_paid_only': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Attach calendar files only after order has been paid\"),\n            help_text=_(\"Use this if you e.g. put a private access link into the calendar file to make sure people only \"\n                        \"receive it after their payment was confirmed.\"),\n        )\n    },\n    'mail_attach_ical_description': {\n        'default': '',\n        'type': LazyI18nString,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Event description\"),\n            widget=I18nTextarea,\n            help_text=_(\n                \"You can use this to share information with your attendees, such as travel information or the link to a digital event. \"\n                \"If you keep it empty, we will put a link to the event shop, the admission time, and your organizer name in there. \"\n                \"We do not allow using placeholders with sensitive person-specific data as calendar entries are often shared with an \"\n                \"unspecified number of people.\"\n            ),\n        )\n    },\n    'mail_prefix': {\n        'default': None,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Subject prefix\"),\n            help_text=_(\"This will be prepended to the subject of all outgoing emails, formatted as [prefix]. \"\n                        \"Choose, for example, a short form of your event name.\"),\n        )\n    },\n    'mail_bcc': {\n        'default': None,\n        'type': str\n    },\n    'mail_from': {\n        'default': settings.MAIL_FROM_ORGANIZERS,\n        'type': str,\n        'form_class': forms.EmailField,\n        'serializer_class': serializers.EmailField,\n        'form_kwargs': dict(\n            label=_(\"Sender address\"),\n            help_text=_(\"Sender address for outgoing emails\"),\n        )\n    },\n    'mail_from_name': {\n        'default': None,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'form_kwargs': dict(\n            label=_(\"Sender name\"),\n            help_text=_(\"Sender name used in conjunction with the sender address for outgoing emails. \"\n                        \"Defaults to your event name.\"),\n        )\n    },\n    'mail_sales_channel_placed_paid': {\n        'default': ['web'],\n        'type': list,\n    },\n    'mail_sales_channel_download_reminder': {\n        'default': ['web'],\n        'type': list,\n    },\n    'mail_text_signature': {\n        'type': LazyI18nString,\n        'default': \"\"\n    },\n    'mail_subject_resend_link': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_subject_resend_link_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_resend_link': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou receive this message because you asked us to send you the link\nto your order for {event}.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_resend_all_links': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your orders for {event}\")),\n    },\n    'mail_text_resend_all_links': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nsomebody requested a list of your orders for {event}.\nThe list is as follows:\n\n{orders}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\nyou have been registered for {event} successfully.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_free_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order for {event} was successful. As you only ordered free products,\nno payment is required.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_placed_require_approval': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_placed_require_approval': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your order for {event}. Since you ordered\na product that requires approval by the event organizer, we ask you to\nbe patient and wait for our next email.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_placed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order: {code}\")),\n    },\n    'mail_text_order_placed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your order for {event} with a total value\nof {total_with_currency}. Please complete your payment before {expire_date}.\n\n{payment_info}\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_attachment_new_order': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Attachment for new orders'),\n            ext_whitelist=(\".pdf\",),\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT,\n            help_text=format_lazy(\n                _(\n                    'This file will be attached to the first email that we send for every new order. Therefore it will be '\n                    'combined with the \"Placed order\", \"Free order\", or \"Received order\" texts from above. It will be sent '\n                    'to both order contacts and attendees. You can use this e.g. to send your terms of service. Do not use '\n                    'it to send non-public information as this file might be sent before payment is confirmed or the order '\n                    'is approved. To avoid this vital email going to spam, you can only upload PDF files of up to {size} MB.'\n                ),\n                size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT // (1024 * 1024),\n            )\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'application/pdf'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT,\n        )\n    },\n    'mail_send_order_placed_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_placed_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_placed_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\na ticket for {event} has been ordered for you.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_changed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order has been changed: {code}\")),\n    },\n    'mail_text_order_changed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order for {event} has been changed.\n\nYou can view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_paid': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Payment received for your order: {code}\")),\n    },\n    'mail_text_order_paid': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe successfully received your payment for {event}. Thank you!\n\n{payment_info}\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_paid_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_paid_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Event registration confirmed: {code}\")),\n    },\n    'mail_text_order_paid_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\na ticket for {event} that has been ordered for you is now paid.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_days_order_expire_warning': {\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'serializer_kwargs': dict(\n            min_value=0,\n        ),\n        'form_kwargs': dict(\n            label=_(\"Number of days\"),\n            min_value=0,\n            help_text=_(\"This email will be sent out this many days before the order expires. If the \"\n                        \"value is 0, the mail will never be sent.\")\n        ),\n        'type': int,\n        'default': '3'\n    },\n    'mail_subject_order_expire_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order is about to expire: {code}\")),\n    },\n    'mail_text_order_expire_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe did not yet receive a full payment for your order for {event}.\nPlease keep in mind that we only guarantee your order if we receive\nyour payment before {expire_date}.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_pending_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your order is pending payment: {code}\")),\n    },\n    'mail_text_order_pending_warning': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe did not yet receive a full payment for your order for {event}.\nPlease keep in mind that you are required to pay before {expire_date}.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_incomplete_payment': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Incomplete payment received: {code}\")),\n    },\n    'mail_text_order_incomplete_payment': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe received a payment for your order for {event}.\n\nUnfortunately, the received amount is less than the full amount\nrequired. Your order is therefore still considered unpaid, as it is\nmissing additional payment of **{pending_sum}**.\n\nYou can view the payment information and the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_payment_failed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Payment failed for your order: {code}\")),\n    },\n    'mail_text_order_payment_failed': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour payment attempt for your order for {event} has failed.\n\nYour order is still valid and you can try to pay again using the same or a different payment method. Please complete your payment before {expire_date}.\n\nYou can retry the payment and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_waiting_list': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"You have been selected from the waitinglist for {event}\")),\n    },\n    'mail_text_waiting_list': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou submitted yourself to the waiting list for {event},\nfor the product {product}.\n\nWe now have a ticket ready for you! You can redeem it in our ticket shop\nwithin the next {hours} hours by entering the following voucher code:\n\n{code}\n\nAlternatively, you can just click on the following link:\n\n{url}\n\nPlease note that this link is only valid within the next {hours} hours!\nWe will reassign the ticket to the next person on the list if you do not\nredeem the voucher within that timeframe.\n\nIf you do NOT need a ticket any more, we kindly ask you to click the\nfollowing link to let us know. This way, we can send the ticket as quickly\nas possible to the next person on the waiting list:\n\n{url_remove}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_canceled': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order canceled: {code}\")),\n    },\n    'mail_text_order_canceled': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyour order {code} for {event} has been canceled.\n\n{comment}\n\nYou can view the details of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_approved': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order approved and awaiting payment: {code}\")),\n    },\n    'mail_text_order_approved': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved your order for {event} and will be happy to welcome you\nat our event.\n\nPlease continue by paying for your order before {expire_date}.\n\nYou can select a payment method and perform the payment here:\n\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_approved_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_approved_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_approved_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved a ticket ordered for you for {event}.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_approved_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order approved and confirmed: {code}\")),\n    },\n    'mail_text_order_approved_free': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved your order for {event} and will be happy to welcome you\nat our event. As you only ordered free products, no payment is required.\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_send_order_approved_free_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_order_approved_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your event registration: {code}\")),\n    },\n    'mail_text_order_approved_free_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nwe approved a ticket ordered for you for {event}.\n\nYou can view the details and status of your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_order_denied': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Order denied: {code}\")),\n    },\n    'mail_text_order_denied': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nunfortunately, we denied your order request for {event}.\n\n{comment}\n\nYou can view the details of your order here:\n\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_text_order_custom_mail': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nYou can change your order details and view the status of your order at\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_days_download_reminder': {\n        'type': int,\n        'default': None\n    },\n    'mail_send_download_reminder_attendee': {\n        'type': bool,\n        'default': 'False'\n    },\n    'mail_subject_download_reminder_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your ticket is ready for download: {code}\")),\n    },\n    'mail_text_download_reminder_attendee': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {attendee_name},\n\nyou are registered for {event}.\n\nIf you did not do so already, you can download your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_download_reminder': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Your ticket is ready for download: {code}\")),\n    },\n    'mail_text_download_reminder': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello,\n\nyou bought a ticket for {event}.\n\nIf you did not do so already, you can download your ticket here:\n{url}\n\nBest regards,  \nYour {event} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_registration': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Activate your account at {organizer}\")),\n    },\n    'mail_text_customer_registration': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nthank you for signing up for an account at {organizer}!\n\nTo activate your account and set a password, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not sign up yourself, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_email_change': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Confirm email address for your account at {organizer}\")),\n    },\n    'mail_text_customer_email_change': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nyou requested to change the email address of your account at {organizer}!\n\nTo confirm the change, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not request this, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'mail_subject_customer_reset': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"Set a new password for your account at {organizer}\")),\n    },\n    'mail_text_customer_reset': {\n        'type': LazyI18nString,\n        'default': LazyI18nString.from_gettext(gettext_noop(\"\"\"Hello {name},\n\nyou requested a new password for your account at {organizer}!\n\nTo set a new password, please click here:\n\n{url}\n\nThis link is valid for one day.\n\nIf you did not request a new password, please ignore this email.\n\nBest regards,  \n\nYour {organizer} team\"\"\"))  # noqa: W291\n    },\n    'smtp_use_custom': {\n        'default': 'False',\n        'type': bool\n    },\n    'smtp_host': {\n        'default': '',\n        'type': str\n    },\n    'smtp_port': {\n        'default': 587,\n        'type': int\n    },\n    'smtp_username': {\n        'default': '',\n        'type': str\n    },\n    'smtp_password': {\n        'default': '',\n        'type': str\n    },\n    'smtp_use_tls': {\n        'default': 'True',\n        'type': bool\n    },\n    'smtp_use_ssl': {\n        'default': 'False',\n        'type': bool\n    },\n    'primary_color': {\n        'default': settings.PRETIX_PRIMARY_COLOR,\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Primary color\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_success': {\n        'default': '#50a167',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Accent color for success\"),\n            help_text=_(\"We strongly suggest to use a shade of green.\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_danger': {\n        'default': '#c44f4f',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Accent color for errors\"),\n            help_text=_(\"We strongly suggest to use a shade of red.\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield'})\n        ),\n    },\n    'theme_color_background': {\n        'default': '#f5f5f5',\n        'type': str,\n        'form_class': forms.CharField,\n        'serializer_class': serializers.CharField,\n        'serializer_kwargs': dict(\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n        ),\n        'form_kwargs': dict(\n            label=_(\"Page background color\"),\n            validators=[\n                RegexValidator(regex='^#[0-9a-fA-F]{6}$',\n                               message=_('Please enter the hexadecimal code of a color, e.g. #990000.')),\n            ],\n            required=True,\n            widget=forms.TextInput(attrs={'class': 'colorpickerfield no-contrast'})\n        ),\n    },\n    'theme_round_borders': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use round edges\"),\n        )\n    },\n    'widget_use_native_spinners': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Use native spinners in the widget instead of custom ones for numeric inputs such as quantity.\"),\n        )\n    },\n    'primary_font': {\n        'default': 'Open Sans',\n        'type': str,\n        'form_class': forms.ChoiceField,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': lambda: dict(**primary_font_kwargs()),\n        'form_kwargs': lambda: dict(\n            label=_('Font'),\n            help_text=_('Only respected by modern browsers.'),\n            required=True,\n            widget=FontSelect,\n            **primary_font_kwargs()\n        ),\n    },\n    'presale_css_file': {\n        'default': None,\n        'type': str\n    },\n    'presale_css_checksum': {\n        'default': None,\n        'type': str\n    },\n    'presale_widget_css_file': {\n        'default': None,\n        'type': str\n    },\n    'presale_widget_css_checksum': {\n        'default': None,\n        'type': str\n    },\n    'logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Header image'),\n            ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_IMAGE,\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('If you provide a logo image, we will by default not show your event name and date '\n                        'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                        'can increase the size with the setting below. We recommend not using small details on the picture '\n                        'as it will be resized on smaller screens.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n\n    },\n    'logo_image_large': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image in its full size'),\n            help_text=_('We recommend to upload a picture at least 1170 pixels wide.'),\n        )\n    },\n    'logo_show_title': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Show event title even if a header image is present'),\n            help_text=_('The title will only be shown on the event front page. If no header image is uploaded for the event, but the header image '\n                        'from the organizer profile is used, this option will be ignored and the event title will always be shown.'),\n        )\n    },\n    'organizer_logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Header image'),\n            ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_IMAGE,\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('If you provide a logo image, we will by default not show your organization name '\n                        'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                        'can increase the size with the setting below. We recommend not using small details on the picture '\n                        'as it will be resized on smaller screens.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'organizer_logo_image_large': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image in its full size'),\n            help_text=_('We recommend to upload a picture at least 1170 pixels wide.'),\n        )\n    },\n    'organizer_logo_image_inherit': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Use header image also for events without an individually uploaded logo'),\n        )\n    },\n    'og_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Social media image'),\n            ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_IMAGE,\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('This picture will be used as a preview if you post links to your ticket shop on social media. '\n                        'Facebook advises to use a picture size of 1200 x 630 pixels, however some platforms like '\n                        'WhatsApp and Reddit only show a square preview, so we recommend to make sure it still looks good '\n                        'only the center square is shown. If you do not fill this, we will use the logo given above.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'invoice_logo_image': {\n        'default': None,\n        'type': File,\n        'form_class': ExtFileField,\n        'form_kwargs': dict(\n            label=_('Logo image'),\n            ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_IMAGE,\n            required=False,\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n            help_text=_('We will show your logo with a maximal height and width of 2.5 cm.')\n        ),\n        'serializer_class': UploadedFileField,\n        'serializer_kwargs': dict(\n            allowed_types=[\n                'image/png', 'image/jpeg', 'image/gif'\n            ],\n            max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        )\n    },\n    'frontpage_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Frontpage text\"),\n            widget=I18nTextarea\n        )\n    },\n    'event_info_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Info text'),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_('Not displayed anywhere by default, but if you want to, you can use this e.g. in ticket templates.')\n        )\n    },\n    'banner_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Banner text (top)\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above every page of your shop. Please only use this for \"\n                        \"very important messages.\")\n        )\n    },\n    'banner_text_bottom': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Banner text (bottom)\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown below every page of your shop. Please only use this for \"\n                        \"very important messages.\")\n        )\n    },\n    'voucher_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Voucher explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown next to the input for a voucher code. You can use it e.g. to explain \"\n                        \"how to obtain a voucher code.\")\n        )\n    },\n    'attendee_data_explanation_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Attendee data explanation\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '2'}},\n            help_text=_(\"This text will be shown above the questions asked for every personalized product. You can use it e.g. to explain \"\n                        \"why you need information from them.\")\n        )\n    },\n    'checkout_success_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Additional success message\"),\n            help_text=_(\"This message will be shown after an order has been created successfully. It will be shown in additional \"\n                        \"to the default text.\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'checkout_phone_helptext': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Help text of the phone number field\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'checkout_email_helptext': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'Make sure to enter a valid email address. We will send you an order '\n            'confirmation including a link that you need to access your order later.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Help text of the email field\"),\n            widget_kwargs={'attrs': {'rows': '2'}},\n            widget=I18nTextarea\n        )\n    },\n    'order_import_settings': {\n        'default': '{}',\n        'type': dict\n    },\n    'organizer_info_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Info text'),\n            widget=I18nTextarea,\n            help_text=_('Not displayed anywhere by default, but if you want to, you can use this e.g. in ticket templates.')\n        )\n    },\n    'event_team_provisioning': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Allow creating a new team during event creation'),\n            help_text=_('Users that do not have access to all events under this organizer, must select one of their teams '\n                        'to have access to the created event. This setting allows users to create an event-specified team'\n                        ' on-the-fly, even when they do not have \\\"Can change teams and permissions\\\" permission.'),\n        )\n    },\n    'license_check_completed': {\n        'default': None,\n        'type': datetime\n    },\n    'license_check_input': {\n        'default': '{}',\n        'type': dict\n    },\n    'update_check_ack': {\n        'default': 'False',\n        'type': bool\n    },\n    'update_check_email': {\n        'default': '',\n        'type': str\n    },\n    'update_check_perform': {\n        'default': 'True',\n        'type': bool\n    },\n    'update_check_result': {\n        'default': None,\n        'type': dict\n    },\n    'update_check_result_warning': {\n        'default': 'False',\n        'type': bool\n    },\n    'update_check_last': {\n        'default': None,\n        'type': datetime\n    },\n    'update_check_id': {\n        'default': None,\n        'type': str\n    },\n    'banner_message': {\n        'default': '',\n        'type': LazyI18nString\n    },\n    'banner_message_detail': {\n        'default': '',\n        'type': LazyI18nString\n    },\n    'opencagedata_apikey': {\n        'default': None,\n        'type': str\n    },\n    'mapquest_apikey': {\n        'default': None,\n        'type': str\n    },\n    'leaflet_tiles': {\n        'default': None,\n        'type': str\n    },\n    'leaflet_tiles_attribution': {\n        'default': None,\n        'type': str\n    },\n    'frontpage_subevent_ordering': {\n        'default': 'date_ascending',\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': dict(\n            choices=[\n                ('date_ascending', _('Event start time')),\n                ('date_descending', _('Event start time (descending)')),\n                ('name_ascending', _('Name')),\n                ('name_descending', _('Name (descending)')),\n            ],\n        ),\n        'form_class': forms.ChoiceField,\n        'form_kwargs': dict(\n            label=pgettext('subevent', 'Date ordering'),\n            choices=[\n                ('date_ascending', _('Event start time')),\n                ('date_descending', _('Event start time (descending)')),\n                ('name_ascending', _('Name')),\n                ('name_descending', _('Name (descending)')),\n            ],\n            # When adding a new ordering, remember to also define it in the event model\n        )\n    },\n    'organizer_link_back': {\n        'default': 'False',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_('Link back to organizer overview on all event pages'),\n        )\n    },\n    'organizer_homepage_text': {\n        'default': '',\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Homepage text'),\n            widget=I18nTextarea,\n            help_text=_('This will be displayed on the organizer homepage.')\n        )\n    },\n    'name_scheme': {\n        'default': 'full',  # default for new events is 'given_family'\n        'type': str,\n        'serializer_class': serializers.ChoiceField,\n        'serializer_kwargs': {},\n    },\n    'giftcard_length': {\n        'default': settings.ENTROPY['giftcard_secret'],\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Length of gift card codes'),\n            help_text=_('The system generates by default {}-character long gift card codes. However, if a different length '\n                        'is required, it can be set here.'.format(settings.ENTROPY['giftcard_secret'])),\n        )\n    },\n    'giftcard_expiry_years': {\n        'default': None,\n        'type': int,\n        'form_class': forms.IntegerField,\n        'serializer_class': serializers.IntegerField,\n        'form_kwargs': dict(\n            label=_('Validity of gift card codes in years'),\n            help_text=_('If you set a number here, gift cards will by default expire at the end of the year after this '\n                        'many years. If you keep it empty, gift cards do not have an explicit expiry date.'),\n        )\n    },\n    'cookie_consent': {\n        'default': 'False',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Enable cookie consent management features\"),\n        ),\n        'type': bool,\n    },\n    'cookie_consent_dialog_text': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'By clicking \"Accept all cookies\", you agree to the storing of cookies and use of similar technologies on '\n            'your device.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Dialog text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '3', 'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_text_secondary': {\n        'default': LazyI18nString.from_gettext(gettext_noop(\n            'We use cookies and similar technologies to gather data that allows us to improve this website and our '\n            'offerings. If you do not agree, we will only use cookies if they are essential to providing the services '\n            'this website offers.'\n        )),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_(\"Secondary dialog text\"),\n            widget=I18nTextarea,\n            widget_kwargs={'attrs': {'rows': '3', 'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_title': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Privacy settings')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('Dialog title'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_button_yes': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Accept all cookies')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('\"Accept\" button description'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'cookie_consent_dialog_button_no': {\n        'default': LazyI18nString.from_gettext(gettext_noop('Required cookies only')),\n        'type': LazyI18nString,\n        'serializer_class': I18nField,\n        'form_class': I18nFormField,\n        'form_kwargs': dict(\n            label=_('\"Reject\" button description'),\n            widget=I18nTextInput,\n            widget_kwargs={'attrs': {'data-display-dependency': '#id_settings-cookie_consent'}},\n        )\n    },\n    'seating_choice': {\n        'default': 'True',\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Customers can choose their own seats\"),\n            help_text=_(\"If disabled, you will need to manually assign seats in the backend. Note that this can mean \"\n                        \"people will not know their seat after their purchase and it might not be written on their \"\n                        \"ticket.\"),\n        ),\n        'type': bool,\n    },\n    'seating_minimal_distance': {\n        'default': '0',\n        'type': float\n    },\n    'seating_allow_blocked_seats_for_channel': {\n        'default': [],\n        'type': list\n    },\n    'seating_distance_within_row': {\n        'default': 'False',\n        'type': bool\n    },\n    'checkout_show_copy_answers_button': {\n        'default': 'True',\n        'type': bool,\n        'form_class': forms.BooleanField,\n        'serializer_class': serializers.BooleanField,\n        'form_kwargs': dict(\n            label=_(\"Show button to copy user input from other products\"),\n        ),\n    }\n}\nSETTINGS_AFFECTING_CSS = {\n    'primary_color', 'theme_color_success', 'theme_color_danger', 'primary_font',\n    'theme_color_background', 'theme_round_borders'\n}\nPERSON_NAME_TITLE_GROUPS = OrderedDict([\n    ('english_common', (_('Most common English titles'), (\n        'Mr',\n        'Ms',\n        'Mrs',\n        'Miss',\n        'Mx',\n        'Dr',\n        'Professor',\n        'Sir',\n    ))),\n    ('german_common', (_('Most common German titles'), (\n        'Dr.',\n        'Prof.',\n        'Prof. Dr.',\n    ))),\n    ('dr_prof_he', ('Dr., Prof., H.E.', (\n        'Dr.',\n        'Prof.',\n        'H.E.',\n    )))\n])\n\nPERSON_NAME_SALUTATIONS = [\n    (\"Ms\", pgettext_lazy(\"person_name_salutation\", \"Ms\")),\n    (\"Mr\", pgettext_lazy(\"person_name_salutation\", \"Mr\")),\n    (\"Mx\", pgettext_lazy(\"person_name_salutation\", \"Mx\")),\n]\n\n\ndef concatenation_for_salutation(d):\n    salutation = d.get(\"salutation\")\n    title = d.get(\"title\")\n    given_name = d.get(\"given_name\")\n    family_name = d.get(\"family_name\")\n    # degree (after name) is not used in salutation\n    # see https://www.schreibwerkstatt.co.at/2012/12/25/der-umgang-mit-akademischen-graden/\n\n    if salutation == \"Mx\":\n        salutation = None\n    elif salutation:\n        salutation = pgettext(\"person_name_salutation\", salutation)\n        given_name = None\n\n    return \" \".join(filter(None, (salutation, title, given_name, family_name)))\n\n\ndef get_name_parts_localized(name_parts, key):\n    value = name_parts.get(key, \"\")\n    if key == \"salutation\" and value:\n        return pgettext_lazy(\"person_name_salutation\", value)\n    return value\n\n\nPERSON_NAME_SCHEMES = OrderedDict([\n    ('given_family', {\n        'fields': (\n            # field_name, label, weight for widget width\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(str(p) for p in [d.get('given_name', ''), d.get('family_name', '')] if p),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'given_family',\n        },\n    }),\n    ('title_given_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_family',\n        },\n    }),\n    ('title_given_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_family',\n        },\n    }),\n    ('given_middle_family', {\n        'fields': (\n            ('given_name', _('First name'), 2),\n            ('middle_name', _('Middle name'), 1),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('given_name', ''), d.get('middle_name', ''), d.get('family_name', '')] if p\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'middle_name': 'M',\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'given_middle_family',\n        },\n    }),\n    ('title_given_middle_family', {\n        'fields': (\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('First name'), 2),\n            ('middle_name', _('Middle name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('title', ''), d.get('given_name'), d.get('middle_name'), d.get('family_name')] if p\n        ),\n        'sample': {\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'middle_name': 'M',\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'title_given_middle_family',\n        },\n    }),\n    ('family_given', {\n        'fields': (\n            ('family_name', _('Family name'), 1),\n            ('given_name', _('Given name'), 1),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in [d.get('family_name', ''), d.get('given_name', '')] if p\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'family_given',\n        },\n    }),\n    ('family_nospace_given', {\n        'fields': (\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: ''.join(\n            str(p) for p in [d.get('family_name', ''), d.get('given_name', '')] if p\n        ),\n        'sample': {\n            'given_name': '\u6cfd\u4e1c',\n            'family_name': '\u6bdb',\n            '_scheme': 'family_nospace_given',\n        },\n    }),\n    ('family_comma_given', {\n        'fields': (\n            ('given_name', _('Given name'), 1),\n            ('family_name', _('Family name'), 1),\n        ),\n        'concatenation': lambda d: (\n            str(d.get('family_name', '')) +\n            str((', ' if d.get('family_name') and d.get('given_name') else '')) +\n            str(d.get('given_name', ''))\n        ),\n        'sample': {\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'family_comma_given',\n        },\n    }),\n    ('full', {\n        'fields': (\n            ('full_name', _('Name'), 1),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'sample': {\n            'full_name': pgettext_lazy('person_name_sample', 'John Doe'),\n            '_scheme': 'full',\n        },\n    }),\n    ('calling_full', {\n        'fields': (\n            ('calling_name', _('Calling name'), 1),\n            ('full_name', _('Full name'), 2),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'concatenation_all_components': lambda d: str(d.get('full_name', '')) + \" (\\\"\" + d.get('calling_name', '') + \"\\\")\",\n        'sample': {\n            'full_name': pgettext_lazy('person_name_sample', 'John Doe'),\n            'calling_name': pgettext_lazy('person_name_sample', 'John'),\n            '_scheme': 'calling_full',\n        },\n    }),\n    ('full_transcription', {\n        'fields': (\n            ('full_name', _('Full name'), 1),\n            ('latin_transcription', _('Latin transcription'), 2),\n        ),\n        'concatenation': lambda d: str(d.get('full_name', '')),\n        'concatenation_all_components': lambda d: str(d.get('full_name', '')) + \" (\" + d.get('latin_transcription', '') + \")\",\n        'sample': {\n            'full_name': '\u5e84\u53f8',\n            'latin_transcription': 'Sh\u014dji',\n            '_scheme': 'full_transcription',\n        },\n    }),\n    ('salutation_given_family', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in (d.get(key, '') for key in [\"given_name\", \"family_name\"]) if p\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: ' '.join(\n            str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"given_name\", \"family_name\"]) if p\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'salutation_given_family',\n        },\n    }),\n    ('salutation_title_given_family', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n        ),\n        'concatenation': lambda d: ' '.join(\n            str(p) for p in (d.get(key, '') for key in [\"title\", \"given_name\", \"family_name\"]) if p\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: ' '.join(\n            str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"title\", \"given_name\", \"family_name\"]) if p\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            '_scheme': 'salutation_title_given_family',\n        },\n    }),\n    ('salutation_title_given_family_degree', {\n        'fields': (\n            ('salutation', pgettext_lazy('person_name', 'Salutation'), 1),\n            ('title', pgettext_lazy('person_name', 'Title'), 1),\n            ('given_name', _('Given name'), 2),\n            ('family_name', _('Family name'), 2),\n            ('degree', pgettext_lazy('person_name', 'Degree (after name)'), 2),\n        ),\n        'concatenation': lambda d: (\n            ' '.join(\n                str(p) for p in (d.get(key, '') for key in [\"title\", \"given_name\", \"family_name\"]) if p\n            ) +\n            str((', ' if d.get('degree') else '')) +\n            str(d.get('degree', ''))\n        ),\n        'concatenation_for_salutation': concatenation_for_salutation,\n        'concatenation_all_components': lambda d: (\n            ' '.join(\n                str(p) for p in (get_name_parts_localized(d, key) for key in [\"salutation\", \"title\", \"given_name\", \"family_name\"]) if p\n            ) +\n            str((', ' if d.get('degree') else '')) +\n            str(d.get('degree', ''))\n        ),\n        'sample': {\n            'salutation': pgettext_lazy('person_name_sample', 'Mr'),\n            'title': pgettext_lazy('person_name_sample', 'Dr'),\n            'given_name': pgettext_lazy('person_name_sample', 'John'),\n            'family_name': pgettext_lazy('person_name_sample', 'Doe'),\n            'degree': pgettext_lazy('person_name_sample', 'MA'),\n            '_scheme': 'salutation_title_given_family_degree',\n        },\n    }),\n])\n\nDEFAULTS['name_scheme']['serializer_kwargs']['choices'] = ((k, k) for k in PERSON_NAME_SCHEMES)\n\nCOUNTRIES_WITH_STATE_IN_ADDRESS = {\n    # Source: http://www.bitboost.com/ref/international-address-formats.html\n    # This is not a list of countries that *have* states, this is a list of countries where states\n    # are actually *used* in postal addresses. This is obviously not complete and opinionated.\n    # Country: [(List of subdivision types as defined by pycountry), (short or long form to be used)]\n    'AU': (['State', 'Territory'], 'short'),\n    'BR': (['State'], 'short'),\n    'CA': (['Province', 'Territory'], 'short'),\n    # 'CN': (['Province', 'Autonomous region', 'Munincipality'], 'long'),\n    'MY': (['State'], 'long'),\n    'MX': (['State', 'Federal district'], 'short'),\n    'US': (['State', 'Outlying area', 'District'], 'short'),\n}\n\nsettings_hierarkey = Hierarkey(attribute_name='settings')\n\nfor k, v in DEFAULTS.items():\n    settings_hierarkey.add_default(k, v['default'], v['type'])\n\n\ndef i18n_uns(v):\n    try:\n        return LazyI18nString(json.loads(v))\n    except ValueError:\n        return LazyI18nString(str(v))\n\n\nsettings_hierarkey.add_type(LazyI18nString,\n                            serialize=lambda s: json.dumps(s.data),\n                            unserialize=i18n_uns)\nsettings_hierarkey.add_type(LazyI18nStringList,\n                            serialize=operator.methodcaller(\"serialize\"),\n                            unserialize=LazyI18nStringList.unserialize)\nsettings_hierarkey.add_type(RelativeDateWrapper,\n                            serialize=lambda rdw: rdw.to_string(),\n                            unserialize=lambda s: RelativeDateWrapper.from_string(s))\nsettings_hierarkey.add_type(PhoneNumber, lambda pn: pn.as_international, lambda s: parse(s) if s else None)\n\n\n@settings_hierarkey.set_global(cache_namespace='global')\nclass GlobalSettingsObject(GlobalSettingsBase):\n    slug = '_global'\n\n\nclass SettingsSandbox:\n    \"\"\"\n    Transparently proxied access to event settings, handling your prefixes for you.\n\n    :param typestr: The first part of the pretix, e.g. ``plugin``\n    :param key: The prefix, e.g. the name of your plugin\n    :param obj: The event or organizer that should be queried\n    \"\"\"\n\n    def __init__(self, typestr: str, key: str, obj: Model):\n        self._event = obj\n        self._type = typestr\n        self._key = key\n\n    def get_prefix(self):\n        return '%s_%s_' % (self._type, self._key)\n\n    def _convert_key(self, key: str) -> str:\n        return '%s_%s_%s' % (self._type, self._key, key)\n\n    def __setitem__(self, key: str, value: Any) -> None:\n        self.set(key, value)\n\n    def __setattr__(self, key: str, value: Any) -> None:\n        if key.startswith('_'):\n            return super().__setattr__(key, value)\n        self.set(key, value)\n\n    def __getattr__(self, item: str) -> Any:\n        return self.get(item)\n\n    def __getitem__(self, item: str) -> Any:\n        return self.get(item)\n\n    def __delitem__(self, key: str) -> None:\n        del self._event.settings[self._convert_key(key)]\n\n    def __delattr__(self, key: str) -> None:\n        del self._event.settings[self._convert_key(key)]\n\n    def get(self, key: str, default: Any = None, as_type: type = str, binary_file: bool = False):\n        return self._event.settings.get(\n            self._convert_key(key), default=default, as_type=as_type, binary_file=binary_file\n        )\n\n    def set(self, key: str, value: Any):\n        self._event.settings.set(self._convert_key(key), value)\n\n\ndef validate_event_settings(event, settings_dict):\n    from pretix.base.models import Event\n    from pretix.base.signals import validate_event_settings\n\n    if 'locales' in settings_dict and settings_dict['locale'] not in settings_dict['locales']:\n        raise ValidationError({\n            'locale': _('Your default locale must also be enabled for your event (see box above).')\n        })\n    if settings_dict.get('attendee_names_required') and not settings_dict.get('attendee_names_asked'):\n        raise ValidationError({\n            'attendee_names_required': _('You cannot require specifying attendee names if you do not ask for them.')\n        })\n    if settings_dict.get('attendee_emails_required') and not settings_dict.get('attendee_emails_asked'):\n        raise ValidationError({\n            'attendee_emails_required': _('You have to ask for attendee emails if you want to make them required.')\n        })\n    if settings_dict.get('invoice_address_required') and not settings_dict.get('invoice_address_asked'):\n        raise ValidationError({\n            'invoice_address_required': _('You have to ask for invoice addresses if you want to make them required.')\n        })\n    if settings_dict.get('invoice_address_company_required') and not settings_dict.get('invoice_address_required'):\n        raise ValidationError({\n            'invoice_address_company_required': _('You have to require invoice addresses to require for company names.')\n        })\n\n    payment_term_last = settings_dict.get('payment_term_last')\n    if payment_term_last and event.presale_end:\n        if payment_term_last.date(event) < event.presale_end.date():\n            raise ValidationError({\n                'payment_term_last': _('The last payment date cannot be before the end of presale.')\n            })\n\n    if isinstance(event, Event):\n        validate_event_settings.send(sender=event, settings_dict=settings_dict)\n\n\ndef validate_organizer_settings(organizer, settings_dict):\n    # This is not doing anything for the time being.\n    # But earlier we called validate_event_settings for the organizer, too - and that didn't do anything for\n    # organizer-settings either.\n    if settings_dict.get('reusable_media_type_nfc_mf0aes') and settings_dict.get('reusable_media_type_nfc_uid'):\n        raise ValidationError({\n            'reusable_media_type_nfc_uid': _('This needs to be disabled if other NFC-based types are active.')\n        })\n\n\ndef global_settings_object(holder):\n    if not hasattr(holder, '_global_settings_object'):\n        holder._global_settings_object = GlobalSettingsObject()\n    return holder._global_settings_object\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexander Schwartz\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport datetime\nimport os\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.core.files import File\nfrom django.core.files.uploadedfile import UploadedFile\nfrom django.forms.utils import from_current_timezone\nfrom django.urls import reverse\nfrom django.utils.html import escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.timezone import now\nfrom django.utils.translation import gettext_lazy as _\nfrom django_scopes.forms import SafeModelMultipleChoiceField\n\nfrom pretix.helpers.hierarkey import clean_filename\n\nfrom ...base.forms import I18nModelForm\nfrom ...helpers.images import (\n    IMAGE_EXTS, validate_uploaded_file_for_valid_image,\n)\n\n# Import for backwards compatibility with okd import paths\nfrom ...base.forms.widgets import (  # noqa\n    DatePickerWidget, SplitDateTimePickerWidget, TimePickerWidget,\n)\n\n\nclass TolerantFormsetModelForm(I18nModelForm):\n    \"\"\"\n    This is equivalent to a normal I18nModelForm, but works around a problem that\n    arises when the form is used inside a FormSet with can_order=True and django-formset-js\n    enabled. In this configuration, even empty \"extra\" forms might have an ORDER value\n    sent and Django marks the form as empty and raises validation errors because the other\n    fields have not been filled.\n    \"\"\"\n\n    def has_changed(self) -> bool:\n        \"\"\"\n        Returns True if data differs from initial. Contrary to the default\n        implementation, the ORDER field is being ignored.\n        \"\"\"\n        for name, field in self.fields.items():\n            if name == 'ORDER' or name == 'id':\n                continue\n            prefixed_name = self.add_prefix(name)\n            data_value = field.widget.value_from_datadict(self.data, self.files, prefixed_name)\n            if not field.show_hidden_initial:\n                initial_value = self.initial.get(name, field.initial)\n                if callable(initial_value):\n                    initial_value = initial_value()\n            else:\n                initial_prefixed_name = self.add_initial_prefix(name)\n                hidden_widget = field.hidden_widget()\n                try:\n                    initial_value = field.to_python(hidden_widget.value_from_datadict(\n                        self.data, self.files, initial_prefixed_name))\n                except forms.ValidationError:\n                    # Always assume data has changed if validation fails.\n                    self._changed_data.append(name)\n                    continue\n            # We're using a private API of Django here. This is not nice, but no problem as it seems\n            # like this will become a public API in future Django.\n            if field._has_changed(initial_value, data_value):\n                return True\n        return False\n\n\ndef selector(values, prop):\n    # Given an iterable of PropertyValue objects, this will return a\n    # list of their primary keys, ordered by the primary keys of the\n    # properties they belong to EXCEPT the value for the property prop2.\n    # We'll see later why we need this.\n    return [\n        v.id for v in sorted(values, key=lambda v: v.prop.id)\n        if v.prop.id != prop.id\n    ]\n\n\nclass ClearableBasenameFileInput(forms.ClearableFileInput):\n    template_name = 'pretixbase/forms/widgets/thumbnailed_file_input.html'\n\n    class FakeFile(File):\n        def __init__(self, file):\n            self.file = file\n\n        @property\n        def name(self):\n            if hasattr(self.file, 'display_name'):\n                return self.file.display_name\n            return self.file.name\n\n        @property\n        def is_img(self):\n            return any(self.file.name.lower().endswith(e) for e in settings.FILE_UPLOAD_EXTENSIONS_IMAGE)\n\n        def __str__(self):\n            if hasattr(self.file, 'display_name'):\n                return self.file.display_name\n            return clean_filename(os.path.basename(self.file.name))\n\n        @property\n        def url(self):\n            return self.file.url\n\n    def get_context(self, name, value, attrs):\n        ctx = super().get_context(name, value, attrs)\n        ctx['widget']['value'] = self.FakeFile(value)\n        ctx['widget']['cachedfile'] = None\n        return ctx\n\n\nclass CachedFileInput(forms.ClearableFileInput):\n    template_name = 'pretixbase/forms/widgets/thumbnailed_file_input.html'\n\n    class FakeFile(File):\n        def __init__(self, file):\n            self.file = file\n\n        @property\n        def name(self):\n            return self.file.filename\n\n        @property\n        def is_img(self):\n            return False  # thumbnailing doesn't work since the file isn't available publicly\n\n        def __str__(self):\n            return self.file.filename\n\n        @property\n        def url(self):\n            return reverse('cachedfile.download', kwargs={'id': self.file.id})\n\n    def value_from_datadict(self, data, files, name):\n        from ...base.models import CachedFile\n        v = super().value_from_datadict(data, files, name)\n        if v is None and data.get(name + '-cachedfile'):  # An explicit \"[x] clear\" would be False, not None\n            return CachedFile.objects.filter(id=data[name + '-cachedfile']).first()\n        return v\n\n    def get_context(self, name, value, attrs):\n        from ...base.models import CachedFile\n        if isinstance(value, CachedFile):\n            value = self.FakeFile(value)\n\n        ctx = super().get_context(name, value, attrs)\n        ctx['widget']['value'] = value\n        ctx['widget']['cachedfile'] = value.file if isinstance(value, self.FakeFile) else None\n        ctx['widget']['hidden_name'] = name + '-cachedfile'\n        return ctx\n\n\nclass SizeValidationMixin:\n    def __init__(self, *args, **kwargs):\n        self.max_size = kwargs.pop(\"max_size\", None)\n        super().__init__(*args, **kwargs)\n\n    @staticmethod\n    def _sizeof_fmt(num, suffix='B'):\n        for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:\n            if abs(num) < 1024.0:\n                return \"%3.1f%s%s\" % (num, unit, suffix)\n            num /= 1024.0\n        return \"%.1f%s%s\" % (num, 'Yi', suffix)\n\n    def clean(self, *args, **kwargs):\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, UploadedFile) and self.max_size and data.size > self.max_size:\n            raise forms.ValidationError(_(\"Please do not upload files larger than {size}!\").format(\n                size=SizeValidationMixin._sizeof_fmt(self.max_size)\n            ))\n        return data\n\n\nclass ExtValidationMixin:\n\n    def __init__(self, *args, **kwargs):\n        ext_whitelist = kwargs.pop(\"ext_whitelist\")\n        self.ext_whitelist = [i.lower() for i in ext_whitelist]\n        super().__init__(*args, **kwargs)\n\n    def clean(self, *args, **kwargs):\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, UploadedFile):\n            filename = data.name\n            ext = os.path.splitext(filename)[1]\n            ext = ext.lower()\n            if ext not in self.ext_whitelist:\n                raise forms.ValidationError(_(\"Filetype not allowed!\"))\n\n            if ext in IMAGE_EXTS:\n                validate_uploaded_file_for_valid_image(data)\n\n        return data\n\n\nclass SizeFileField(SizeValidationMixin, forms.FileField):\n    pass\n\n\nclass ExtFileField(ExtValidationMixin, SizeFileField):\n    widget = ClearableBasenameFileInput\n\n\nclass CachedFileField(ExtFileField):\n    widget = CachedFileInput\n\n    def to_python(self, data):\n        from ...base.models import CachedFile\n\n        if isinstance(data, CachedFile):\n            return data\n\n        return super().to_python(data)\n\n    def bound_data(self, data, initial):\n        from ...base.models import CachedFile\n\n        if isinstance(data, File):\n            if hasattr(data, '_uploaded_to'):\n                return data._uploaded_to\n            cf = CachedFile.objects.create(\n                expires=now() + datetime.timedelta(days=1),\n                date=now(),\n                web_download=True,\n                filename=data.name,\n                type=data.content_type,\n            )\n            cf.file.save(data.name, data.file)\n            cf.save()\n            data._uploaded_to = cf\n            return cf\n        return super().bound_data(data, initial)\n\n    def clean(self, *args, **kwargs):\n        from ...base.models import CachedFile\n\n        data = super().clean(*args, **kwargs)\n        if isinstance(data, File):\n            if hasattr(data, '_uploaded_to'):\n                return data._uploaded_to\n            cf = CachedFile.objects.create(\n                expires=now() + datetime.timedelta(days=1),\n                web_download=True,\n                date=now(),\n                filename=data.name,\n                type=data.content_type,\n            )\n            cf.file.save(data.name, data.file)\n            cf.save()\n            data._uploaded_to = cf\n            return cf\n        return data\n\n\nclass SlugWidget(forms.TextInput):\n    template_name = 'pretixcontrol/slug_widget.html'\n    prefix = ''\n\n    def get_context(self, name, value, attrs):\n        ctx = super().get_context(name, value, attrs)\n        ctx['pre'] = self.prefix\n        return ctx\n\n\nclass MultipleLanguagesWidget(forms.CheckboxSelectMultiple):\n    option_template_name = 'pretixcontrol/multi_languages_widget.html'\n\n    def sort(self):\n        self.choices = sorted(self.choices, key=lambda l: (\n            (\n                0 if l[0] in settings.LANGUAGES_OFFICIAL\n                else (\n                    1 if l[0] not in settings.LANGUAGES_INCUBATING\n                    else 2\n                )\n            ), str(l[1])\n        ))\n\n    def options(self, name, value, attrs=None):\n        self.sort()\n        return super().options(name, value, attrs)\n\n    def optgroups(self, name, value, attrs=None):\n        self.sort()\n        return super().optgroups(name, value, attrs)\n\n    def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):\n        opt = super().create_option(name, value, label, selected, index, subindex, attrs)\n        opt['official'] = value in settings.LANGUAGES_OFFICIAL\n        opt['incubating'] = value in settings.LANGUAGES_INCUBATING\n        return opt\n\n\nclass SingleLanguageWidget(forms.Select):\n\n    def modify(self):\n        if hasattr(self, '_modified'):\n            return self.choices\n        self.choices = sorted(self.choices, key=lambda l: (\n            (\n                0 if l[0] in settings.LANGUAGES_OFFICIAL\n                else (\n                    1 if l[0] not in settings.LANGUAGES_INCUBATING\n                    else 2\n                )\n            ), str(l[1])\n        ))\n        new_choices = []\n        for k, v in self.choices:\n            new_choices.append((\n                k,\n                v if k in settings.LANGUAGES_OFFICIAL\n                else (\n                    '{} (inofficial translation)'.format(v) if k not in settings.LANGUAGES_INCUBATING\n                    else '{} (translation in progress)'.format(v)\n                )\n            ))\n        self._modified = True\n        self.choices = new_choices\n\n    def options(self, name, value, attrs=None):\n        self.modify()\n        return super().options(name, value, attrs)\n\n    def optgroups(self, name, value, attrs=None):\n        self.modify()\n        return super().optgroups(name, value, attrs)\n\n\nclass SplitDateTimeField(forms.SplitDateTimeField):\n\n    def compress(self, data_list):\n        # Differs from the default implementation: If only a time is given and no date, we consider the field empty\n        if data_list:\n            if data_list[0] in self.empty_values:\n                return None\n            if data_list[1] in self.empty_values:\n                raise ValidationError(self.error_messages['invalid_date'], code='invalid_date')\n            result = datetime.datetime.combine(*data_list)\n            return from_current_timezone(result)\n        return None\n\n\nclass FontSelect(forms.RadioSelect):\n    option_template_name = 'pretixcontrol/font_option.html'\n\n\nclass ItemMultipleChoiceField(SafeModelMultipleChoiceField):\n    def label_from_instance(self, obj):\n        return str(obj) if obj.active else mark_safe(f'<strike class=\"text-muted\">{escape(obj)}</strike>')\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Bolutife Lawrence, Maico Timmerman\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nfrom decimal import Decimal\nfrom urllib.parse import urlparse\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.forms import inlineformset_factory\nfrom django.forms.utils import ErrorDict\nfrom django.urls import reverse\nfrom django.utils.crypto import get_random_string\nfrom django.utils.html import conditional_escape\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_scopes.forms import (\n    SafeModelChoiceField, SafeModelMultipleChoiceField,\n)\nfrom i18nfield.forms import (\n    I18nFormField, I18nFormSetMixin, I18nTextarea, I18nTextInput,\n)\nfrom phonenumber_field.formfields import PhoneNumberField\nfrom pytz import common_timezones\n\nfrom pretix.api.models import WebHook\nfrom pretix.api.webhooks import get_all_webhook_events\nfrom pretix.base.customersso.oidc import oidc_validate_and_complete_config\nfrom pretix.base.forms import I18nModelForm, PlaceholderValidator, SettingsForm\nfrom pretix.base.forms.questions import (\n    NamePartsFormField, WrappedPhoneNumberPrefixWidget, get_country_by_locale,\n    get_phone_prefix,\n)\nfrom pretix.base.forms.widgets import SplitDateTimePickerWidget\nfrom pretix.base.models import (\n    Customer, Device, EventMetaProperty, Gate, GiftCard, GiftCardAcceptance,\n    Membership, MembershipType, OrderPosition, Organizer, ReusableMedium, Team,\n)\nfrom pretix.base.models.customers import CustomerSSOClient, CustomerSSOProvider\nfrom pretix.base.models.organizer import OrganizerFooterLink\nfrom pretix.base.settings import (\n    PERSON_NAME_SCHEMES, PERSON_NAME_TITLE_GROUPS, validate_organizer_settings,\n)\nfrom pretix.control.forms import ExtFileField, SplitDateTimeField\nfrom pretix.control.forms.event import (\n    SafeEventMultipleChoiceField, multimail_validate,\n)\nfrom pretix.control.forms.widgets import Select2\nfrom pretix.multidomain.models import KnownDomain\nfrom pretix.multidomain.urlreverse import build_absolute_uri\n\n\nclass OrganizerForm(I18nModelForm):\n    error_messages = {\n        'duplicate_slug': _(\"This slug is already in use. Please choose a different one.\"),\n    }\n\n    class Meta:\n        model = Organizer\n        fields = ['name', 'slug']\n\n    def clean_slug(self):\n        slug = self.cleaned_data['slug']\n        if Organizer.objects.filter(slug__iexact=slug).exists():\n            raise forms.ValidationError(\n                self.error_messages['duplicate_slug'],\n                code='duplicate_slug',\n            )\n        return slug\n\n\nclass OrganizerDeleteForm(forms.Form):\n    error_messages = {\n        'slug_wrong': _(\"The slug you entered was not correct.\"),\n    }\n    slug = forms.CharField(\n        max_length=255,\n        label=_(\"Event slug\"),\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    def clean_slug(self):\n        slug = self.cleaned_data.get('slug')\n        if slug != self.organizer.slug:\n            raise forms.ValidationError(\n                self.error_messages['slug_wrong'],\n                code='slug_wrong',\n            )\n        return slug\n\n\nclass OrganizerUpdateForm(OrganizerForm):\n\n    def __init__(self, *args, **kwargs):\n        self.domain = kwargs.pop('domain', False)\n        self.change_slug = kwargs.pop('change_slug', False)\n        kwargs.setdefault('initial', {})\n        self.instance = kwargs['instance']\n        if self.domain and self.instance:\n            initial_domain = self.instance.domains.filter(event__isnull=True).first()\n            if initial_domain:\n                kwargs['initial'].setdefault('domain', initial_domain.domainname)\n\n        super().__init__(*args, **kwargs)\n        if not self.change_slug:\n            self.fields['slug'].widget.attrs['readonly'] = 'readonly'\n        if self.domain:\n            self.fields['domain'] = forms.CharField(\n                max_length=255,\n                label=_('Custom domain'),\n                required=False,\n                help_text=_('You need to configure the custom domain in the webserver beforehand.')\n            )\n\n    def clean_domain(self):\n        d = self.cleaned_data['domain']\n        if d:\n            if d == urlparse(settings.SITE_URL).hostname:\n                raise ValidationError(\n                    _('You cannot choose the base domain of this installation.')\n                )\n            if KnownDomain.objects.filter(domainname=d).exclude(organizer=self.instance.pk,\n                                                                event__isnull=True).exists():\n                raise ValidationError(\n                    _('This domain is already in use for a different event or organizer.')\n                )\n        return d\n\n    def clean_slug(self):\n        if self.change_slug:\n            return self.cleaned_data['slug']\n        return self.instance.slug\n\n    def save(self, commit=True):\n        instance = super().save(commit)\n\n        if self.domain:\n            current_domain = instance.domains.filter(event__isnull=True).first()\n            if self.cleaned_data['domain']:\n                if current_domain and current_domain.domainname != self.cleaned_data['domain']:\n                    current_domain.delete()\n                    KnownDomain.objects.create(organizer=instance, domainname=self.cleaned_data['domain'])\n                elif not current_domain:\n                    KnownDomain.objects.create(organizer=instance, domainname=self.cleaned_data['domain'])\n            elif current_domain:\n                current_domain.delete()\n            instance.cache.clear()\n            for ev in instance.events.all():\n                ev.cache.clear()\n\n        return instance\n\n\nclass SafeOrderPositionChoiceField(forms.ModelChoiceField):\n    def __init__(self, queryset, **kwargs):\n        queryset = queryset.model.all.none()\n        super().__init__(queryset, **kwargs)\n\n    def label_from_instance(self, op):\n        return f'{op.order.code}-{op.positionid} ({str(op.item) + ((\" - \" + str(op.variation)) if op.variation else \"\")})'\n\n\nclass EventMetaPropertyForm(forms.ModelForm):\n    class Meta:\n        model = EventMetaProperty\n        fields = ['name', 'default', 'required', 'protected', 'allowed_values', 'filter_allowed']\n        widgets = {\n            'default': forms.TextInput()\n        }\n\n\nclass MembershipTypeForm(I18nModelForm):\n    class Meta:\n        model = MembershipType\n        fields = ['name', 'transferable', 'allow_parallel_usage', 'max_usages']\n\n\nclass TeamForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n\n    class Meta:\n        model = Team\n        fields = ['name', 'all_events', 'limit_events', 'can_create_events',\n                  'can_change_teams', 'can_change_organizer_settings',\n                  'can_manage_gift_cards', 'can_manage_customers',\n                  'can_manage_reusable_media',\n                  'can_change_event_settings', 'can_change_items',\n                  'can_view_orders', 'can_change_orders', 'can_checkin_orders',\n                  'can_view_vouchers', 'can_change_vouchers']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n    def clean(self):\n        data = super().clean()\n        if self.instance.pk and not data['can_change_teams']:\n            if not self.instance.organizer.teams.exclude(pk=self.instance.pk).filter(\n                    can_change_teams=True, members__isnull=False\n            ).exists():\n                raise ValidationError(_('The changes could not be saved because there would be no remaining team with '\n                                        'the permission to change teams and permissions.'))\n\n        return data\n\n\nclass GateForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    class Meta:\n        model = Gate\n        fields = ['name', 'identifier']\n\n\nclass DeviceForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n        self.fields['gate'].queryset = organizer.gates.all()\n\n    def clean(self):\n        d = super().clean()\n        if not d['all_events'] and not d.get('limit_events'):\n            raise ValidationError(_('Your device will not have access to anything, please select some events.'))\n\n        return d\n\n    class Meta:\n        model = Device\n        fields = ['name', 'all_events', 'limit_events', 'security_profile', 'gate']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n\nclass DeviceBulkEditForm(forms.ModelForm):\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        self.mixed_values = kwargs.pop('mixed_values')\n        self.queryset = kwargs.pop('queryset')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all().order_by(\n            '-has_subevents', '-date_from'\n        )\n        self.fields['gate'].queryset = organizer.gates.all()\n\n    def clean(self):\n        d = super().clean()\n        if self.prefix + '__events' in self.data.getlist('_bulk') and not d['all_events'] and not d['limit_events']:\n            raise ValidationError(_('Your device will not have access to anything, please select some events.'))\n\n        return d\n\n    class Meta:\n        model = Device\n        fields = ['all_events', 'limit_events', 'security_profile', 'gate']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events',\n                'class': 'scrolling-multiple-choice scrolling-multiple-choice-large',\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeEventMultipleChoiceField\n        }\n\n    def save(self, commit=True):\n        objs = list(self.queryset)\n        fields = set()\n\n        check_map = {\n            'all_events': '__events',\n            'limit_events': '__events',\n        }\n        for k in self.fields:\n            cb_val = self.prefix + check_map.get(k, k)\n            if cb_val not in self.data.getlist('_bulk'):\n                continue\n\n            fields.add(k)\n            for obj in objs:\n                if k == 'limit_events':\n                    getattr(obj, k).set(self.cleaned_data[k])\n                else:\n                    setattr(obj, k, self.cleaned_data[k])\n\n        if fields:\n            Device.objects.bulk_update(objs, [f for f in fields if f != 'limit_events'], 200)\n\n    def full_clean(self):\n        if len(self.data) == 0:\n            # form wasn't submitted\n            self._errors = ErrorDict()\n            return\n        super().full_clean()\n\n\nclass OrganizerSettingsForm(SettingsForm):\n    timezone = forms.ChoiceField(\n        choices=((a, a) for a in common_timezones),\n        label=_(\"Default timezone\"),\n    )\n    name_scheme = forms.ChoiceField(\n        label=_(\"Name format\"),\n        help_text=_(\"This defines how pretix will ask for human names. Changing this after you already received \"\n                    \"orders might lead to unexpected behavior when sorting or changing names.\"),\n        required=True,\n    )\n    name_scheme_titles = forms.ChoiceField(\n        label=_(\"Allowed titles\"),\n        help_text=_(\"If the naming scheme you defined above allows users to input a title, you can use this to \"\n                    \"restrict the set of selectable titles.\"),\n        required=False,\n    )\n    auto_fields = [\n        'allowed_restricted_plugins',\n        'customer_accounts',\n        'customer_accounts_native',\n        'customer_accounts_link_by_email',\n        'invoice_regenerate_allowed',\n        'contact_mail',\n        'imprint_url',\n        'organizer_info_text',\n        'event_list_type',\n        'event_list_availability',\n        'organizer_homepage_text',\n        'organizer_link_back',\n        'organizer_logo_image_large',\n        'organizer_logo_image_inherit',\n        'giftcard_length',\n        'giftcard_expiry_years',\n        'locales',\n        'region',\n        'meta_noindex',\n        'event_team_provisioning',\n        'primary_color',\n        'theme_color_success',\n        'theme_color_danger',\n        'theme_color_background',\n        'theme_round_borders',\n        'primary_font',\n        'privacy_url',\n        'cookie_consent',\n        'cookie_consent_dialog_title',\n        'cookie_consent_dialog_text',\n        'cookie_consent_dialog_text_secondary',\n        'cookie_consent_dialog_button_yes',\n        'cookie_consent_dialog_button_no',\n        'reusable_media_active',\n        'reusable_media_type_barcode',\n        'reusable_media_type_barcode_identifier_length',\n        'reusable_media_type_nfc_uid',\n        'reusable_media_type_nfc_uid_autocreate_giftcard',\n        'reusable_media_type_nfc_uid_autocreate_giftcard_currency',\n        'reusable_media_type_nfc_mf0aes',\n        'reusable_media_type_nfc_mf0aes_autocreate_giftcard',\n        'reusable_media_type_nfc_mf0aes_autocreate_giftcard_currency',\n        'reusable_media_type_nfc_mf0aes_random_uid',\n    ]\n\n    organizer_logo_image = ExtFileField(\n        label=_('Header image'),\n        ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_IMAGE,\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_IMAGE,\n        required=False,\n        help_text=_('If you provide a logo image, we will by default not show your organization name '\n                    'in the page header. By default, we show your logo with a size of up to 1140x120 pixels. You '\n                    'can increase the size with the setting below. We recommend not using small details on the picture '\n                    'as it will be resized on smaller screens.')\n    )\n    favicon = ExtFileField(\n        label=_('Favicon'),\n        ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_FAVICON,\n        required=False,\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_FAVICON,\n        help_text=_('If you provide a favicon, we will show it instead of the default pretix icon. '\n                    'We recommend a size of at least 200x200px to accommodate most devices.')\n    )\n\n    def __init__(self, *args, **kwargs):\n        is_admin = kwargs.pop('is_admin', False)\n        super().__init__(*args, **kwargs)\n\n        if not is_admin:\n            del self.fields['allowed_restricted_plugins']\n\n        self.fields['name_scheme'].choices = (\n            (k, _('Ask for {fields}, display like {example}').format(\n                fields=' + '.join(str(vv[1]) for vv in v['fields']),\n                example=v['concatenation'](v['sample'])\n            ))\n            for k, v in PERSON_NAME_SCHEMES.items()\n        )\n        self.fields['name_scheme_titles'].choices = [('', _('Free text input'))] + [\n            (k, '{scheme}: {samples}'.format(\n                scheme=v[0],\n                samples=', '.join(v[1])\n            ))\n            for k, v in PERSON_NAME_TITLE_GROUPS.items()\n        ]\n        self.fields['reusable_media_active'].label = mark_safe(\n            conditional_escape(self.fields['reusable_media_active'].label) +\n            ' ' +\n            '<span class=\"label label-info\">{}</span>'.format(_('experimental'))\n        )\n        self.fields['reusable_media_active'].help_text = mark_safe(\n            conditional_escape(self.fields['reusable_media_active'].help_text) +\n            ' ' +\n            '<br/><span class=\"fa fa-flask\"></span> ' +\n            _('This feature is currently in an experimental stage. It only supports very limited use cases and might '\n              'change at any point.')\n        )\n\n    def clean(self):\n        data = super().clean()\n        settings_dict = self.obj.settings.freeze()\n        settings_dict.update(data)\n\n        validate_organizer_settings(self.obj, data)\n        return data\n\n\nclass MailSettingsForm(SettingsForm):\n    auto_fields = [\n        'mail_from_name',\n    ]\n\n    mail_bcc = forms.CharField(\n        label=_(\"Bcc address\"),\n        help_text=_(\"All emails will be sent to this address as a Bcc copy\"),\n        validators=[multimail_validate],\n        required=False,\n        max_length=255\n    )\n    mail_text_signature = I18nFormField(\n        label=_(\"Signature\"),\n        required=False,\n        widget=I18nTextarea,\n        help_text=_(\"This will be attached to every email.\"),\n        validators=[PlaceholderValidator([])],\n        widget_kwargs={'attrs': {\n            'rows': '4',\n            'placeholder': _(\n                'e.g. your contact details'\n            )\n        }}\n    )\n\n    mail_subject_customer_registration = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_registration = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n    mail_subject_customer_email_change = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_email_change = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n    mail_subject_customer_reset = I18nFormField(\n        label=_(\"Subject\"),\n        required=False,\n        widget=I18nTextInput,\n    )\n    mail_text_customer_reset = I18nFormField(\n        label=_(\"Text\"),\n        required=False,\n        widget=I18nTextarea,\n    )\n\n    base_context = {\n        'mail_text_customer_registration': ['customer', 'url'],\n        'mail_subject_customer_registration': ['customer', 'url'],\n        'mail_text_customer_email_change': ['customer', 'url'],\n        'mail_subject_customer_email_change': ['customer', 'url'],\n        'mail_text_customer_reset': ['customer', 'url'],\n        'mail_subject_customer_reset': ['customer', 'url'],\n    }\n\n    def _get_sample_context(self, base_parameters):\n        placeholders = {\n            'organizer': self.organizer.name\n        }\n\n        if 'url' in base_parameters:\n            placeholders['url'] = build_absolute_uri(\n                self.organizer,\n                'presale:organizer.customer.activate'\n            ) + '?token=' + get_random_string(30)\n\n        if 'customer' in base_parameters:\n            placeholders['name'] = pgettext_lazy('person_name_sample', 'John Doe')\n            name_scheme = PERSON_NAME_SCHEMES[self.organizer.settings.name_scheme]\n            for f, l, w in name_scheme['fields']:\n                if f == 'full_name':\n                    continue\n                placeholders['name_%s' % f] = name_scheme['sample'][f]\n            placeholders['name_for_salutation'] = _(\"Mr Doe\")\n        return placeholders\n\n    def _set_field_placeholders(self, fn, base_parameters):\n        phs = [\n            '{%s}' % p\n            for p in sorted(self._get_sample_context(base_parameters).keys())\n        ]\n        ht = _('Available placeholders: {list}').format(\n            list=', '.join(phs)\n        )\n        if self.fields[fn].help_text:\n            self.fields[fn].help_text += ' ' + str(ht)\n        else:\n            self.fields[fn].help_text = ht\n        self.fields[fn].validators.append(\n            PlaceholderValidator(phs)\n        )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.get('obj')\n        super().__init__(*args, **kwargs)\n        for k, v in self.base_context.items():\n            self._set_field_placeholders(k, v)\n\n\nclass WebHookForm(forms.ModelForm):\n    events = forms.MultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple,\n        label=pgettext_lazy('webhooks', 'Event types')\n    )\n\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n        self.fields['limit_events'].queryset = organizer.events.all()\n        self.fields['events'].choices = [\n            (\n                a.action_type,\n                mark_safe('{} \u2013 <code>{}</code>'.format(a.verbose_name, a.action_type))\n            ) for a in get_all_webhook_events().values()\n        ]\n        if self.instance and self.instance.pk:\n            self.fields['events'].initial = list(self.instance.listeners.values_list('action_type', flat=True))\n\n    class Meta:\n        model = WebHook\n        fields = ['target_url', 'enabled', 'all_events', 'limit_events', 'comment']\n        widgets = {\n            'limit_events': forms.CheckboxSelectMultiple(attrs={\n                'data-inverse-dependency': '#id_all_events'\n            }),\n        }\n        field_classes = {\n            'limit_events': SafeModelMultipleChoiceField\n        }\n\n\nclass GiftCardCreateForm(forms.ModelForm):\n    value = forms.DecimalField(\n        label=_('Gift card value'),\n        min_value=Decimal('0.00'),\n        max_value=Decimal('99999999.99'),\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        initial = kwargs.pop('initial', {})\n        initial['expires'] = self.organizer.default_gift_card_expiry\n        kwargs['initial'] = initial\n        super().__init__(*args, **kwargs)\n\n    def clean_secret(self):\n        s = self.cleaned_data['secret']\n        if GiftCard.objects.filter(\n                secret__iexact=s\n        ).filter(\n            Q(issuer=self.organizer) |\n            Q(issuer__in=GiftCardAcceptance.objects.filter(\n                acceptor=self.organizer,\n                active=True,\n            ).values_list('issuer', flat=True))\n        ).exists():\n            raise ValidationError(\n                _('A gift card with the same secret already exists in your or an affiliated organizer account.')\n            )\n        return s\n\n    class Meta:\n        model = GiftCard\n        fields = ['secret', 'currency', 'testmode', 'expires', 'conditions']\n        field_classes = {\n            'expires': SplitDateTimeField\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n            'conditions': forms.Textarea(attrs={\"rows\": 2})\n        }\n\n\nclass GiftCardUpdateForm(forms.ModelForm):\n    class Meta:\n        model = GiftCard\n        fields = ['expires', 'conditions', 'owner_ticket']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'owner_ticket': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n            'conditions': forms.Textarea(attrs={\"rows\": 2})\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        organizer = self.instance.issuer\n\n        self.fields['owner_ticket'].queryset = OrderPosition.all.filter(order__event__organizer=organizer).all()\n        self.fields['owner_ticket'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.ticket_select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Ticket')\n            }\n        )\n        self.fields['owner_ticket'].widget.choices = self.fields['owner_ticket'].choices\n        self.fields['owner_ticket'].required = False\n\n\nclass ReusableMediumUpdateForm(forms.ModelForm):\n    error_messages = {\n        'duplicate': _(\"An medium with this type and identifier is already registered.\"),\n    }\n\n    class Meta:\n        model = ReusableMedium\n        fields = ['active', 'expires', 'customer', 'linked_giftcard', 'linked_orderposition', 'notes']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'customer': SafeModelChoiceField,\n            'linked_giftcard': SafeModelChoiceField,\n            'linked_orderposition': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        organizer = self.instance.organizer\n\n        self.fields['linked_orderposition'].queryset = OrderPosition.all.filter(order__event__organizer=organizer).all()\n        self.fields['linked_orderposition'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.ticket_select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Ticket')\n            }\n        )\n        self.fields['linked_orderposition'].widget.choices = self.fields['linked_orderposition'].choices\n        self.fields['linked_orderposition'].required = False\n\n        self.fields['linked_giftcard'].queryset = organizer.issued_gift_cards.all()\n        self.fields['linked_giftcard'].widget = Select2(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:organizer.giftcards.select2', kwargs={\n                    'organizer': organizer.slug,\n                }),\n                'data-placeholder': _('Gift card')\n            }\n        )\n        self.fields['linked_giftcard'].widget.choices = self.fields['linked_giftcard'].choices\n        self.fields['linked_giftcard'].required = False\n\n        if organizer.settings.customer_accounts:\n            self.fields['customer'].queryset = organizer.customers.all()\n            self.fields['customer'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'generic',\n                    'data-select2-url': reverse('control:organizer.customers.select2', kwargs={\n                        'organizer': organizer.slug,\n                    }),\n                    'data-placeholder': _('Customer')\n                }\n            )\n            self.fields['customer'].widget.choices = self.fields['customer'].choices\n            self.fields['customer'].required = False\n        else:\n            del self.fields['customer']\n\n    def clean(self):\n        identifier = self.cleaned_data.get('identifier')\n        type = self.cleaned_data.get('type')\n\n        if identifier is not None and type is not None:\n            try:\n                self.instance.organizer.reusable_media.exclude(pk=self.instance.pk).get(\n                    identifier=identifier,\n                    type=type,\n                )\n            except ReusableMedium.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate'],\n                    code='duplicate',\n                )\n\n        return self.cleaned_data\n\n\nclass ReusableMediumCreateForm(ReusableMediumUpdateForm):\n\n    class Meta:\n        model = ReusableMedium\n        fields = ['active', 'type', 'identifier', 'expires', 'linked_orderposition', 'linked_giftcard', 'customer', 'notes']\n        field_classes = {\n            'expires': SplitDateTimeField,\n            'customer': SafeModelChoiceField,\n            'linked_giftcard': SafeModelChoiceField,\n            'linked_orderposition': SafeOrderPositionChoiceField,\n        }\n        widgets = {\n            'expires': SplitDateTimePickerWidget,\n        }\n\n\nclass CustomerUpdateForm(forms.ModelForm):\n    error_messages = {\n        'duplicate_identifier': _(\"An account with this customer ID is already registered.\"),\n        'duplicate': _(\"An account with this email address is already registered.\"),\n    }\n\n    class Meta:\n        model = Customer\n        fields = ['is_active', 'external_identifier', 'name_parts', 'email', 'is_verified', 'phone', 'locale', 'notes']\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        if not self.instance.phone and (self.instance.organizer.settings.region or self.instance.locale):\n            country_code = self.instance.organizer.settings.region or get_country_by_locale(self.instance.locale)\n            phone_prefix = get_phone_prefix(country_code)\n            if phone_prefix:\n                self.initial['phone'] = \"+{}.\".format(phone_prefix)\n\n        self.fields['phone'] = PhoneNumberField(\n            label=_('Phone'),\n            required=False,\n            widget=WrappedPhoneNumberPrefixWidget()\n        )\n        self.fields['name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=False,\n            scheme=self.instance.organizer.settings.name_scheme,\n            titles=self.instance.organizer.settings.name_scheme_titles,\n            label=_('Name'),\n        )\n        if self.instance.provider_id:\n            self.fields['email'].disabled = True\n            self.fields['is_verified'].disabled = True\n            self.fields['external_identifier'].disabled = True\n\n    def clean(self):\n        email = self.cleaned_data.get('email')\n        identifier = self.cleaned_data.get('identifier')\n\n        if email is not None:\n            try:\n                self.instance.organizer.customers.exclude(pk=self.instance.pk).get(email=email)\n            except Customer.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate'],\n                    code='duplicate',\n                )\n\n        if identifier is not None:\n            try:\n                self.instance.organizer.customers.exclude(pk=self.instance.pk).get(identifier=identifier)\n            except Customer.DoesNotExist:\n                pass\n            else:\n                raise forms.ValidationError(\n                    self.error_messages['duplicate_identifier'],\n                    code='duplicate_identifier',\n                )\n\n        return self.cleaned_data\n\n\nclass CustomerCreateForm(CustomerUpdateForm):\n\n    class Meta:\n        model = Customer\n        fields = ['is_active', 'identifier', 'external_identifier', 'name_parts', 'email', 'is_verified', 'phone', 'locale', 'notes']\n\n\nclass MembershipUpdateForm(forms.ModelForm):\n\n    class Meta:\n        model = Membership\n        fields = ['testmode', 'membership_type', 'date_start', 'date_end', 'attendee_name_parts', 'canceled']\n        field_classes = {\n            'date_start': SplitDateTimeField,\n            'date_end': SplitDateTimeField,\n        }\n        widgets = {\n            'date_start': SplitDateTimePickerWidget(),\n            'date_end': SplitDateTimePickerWidget(attrs={'data-date-after': '#id_date_Start'}),\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if self.instance and self.instance.pk:\n            del self.fields['testmode']\n\n        self.fields['membership_type'].queryset = self.instance.customer.organizer.membership_types.all()\n        self.fields['attendee_name_parts'] = NamePartsFormField(\n            max_length=255,\n            required=False,\n            scheme=self.instance.customer.organizer.settings.name_scheme,\n            titles=self.instance.customer.organizer.settings.name_scheme_titles,\n            label=_('Attendee name'),\n        )\n\n\nclass OrganizerFooterLinkForm(I18nModelForm):\n    class Meta:\n        model = OrganizerFooterLink\n        fields = ('label', 'url')\n\n\nclass BaseOrganizerFooterLinkFormSet(I18nFormSetMixin, forms.BaseInlineFormSet):\n    def __init__(self, *args, **kwargs):\n        organizer = kwargs.pop('organizer', None)\n        if organizer:\n            kwargs['locales'] = organizer.settings.get('locales')\n        super().__init__(*args, **kwargs)\n\n\nOrganizerFooterLinkFormset = inlineformset_factory(\n    Organizer, OrganizerFooterLink,\n    OrganizerFooterLinkForm,\n    formset=BaseOrganizerFooterLinkFormSet,\n    can_order=False, can_delete=True, extra=0\n)\n\n\nclass SSOProviderForm(I18nModelForm):\n\n    config_oidc_base_url = forms.URLField(\n        label=pgettext_lazy('sso_oidc', 'Base URL'),\n        required=False,\n    )\n    config_oidc_client_id = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Client ID'),\n        required=False,\n    )\n    config_oidc_client_secret = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Client secret'),\n        required=False,\n    )\n    config_oidc_scope = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Scope'),\n        help_text=pgettext_lazy('sso_oidc', 'Multiple scopes separated with spaces.'),\n        required=False,\n    )\n    config_oidc_uid_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'User ID field'),\n        help_text=pgettext_lazy('sso_oidc', 'We will assume that the contents of the user ID fields are unique and '\n                                            'can never change for a user.'),\n        required=True,\n        initial='sub',\n    )\n    config_oidc_email_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Email field'),\n        help_text=pgettext_lazy('sso_oidc', 'We will assume that all email addresses received from the SSO provider '\n                                            'are verified to really belong the the user. If this can\\'t be '\n                                            'guaranteed, security issues might arise.'),\n        required=True,\n        initial='email',\n    )\n    config_oidc_phone_field = forms.CharField(\n        label=pgettext_lazy('sso_oidc', 'Phone field'),\n        required=False,\n    )\n\n    class Meta:\n        model = CustomerSSOProvider\n        fields = ['is_active', 'name', 'button_label', 'method']\n        widgets = {\n            'method': forms.RadioSelect,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        name_scheme = self.event.settings.name_scheme\n        scheme = PERSON_NAME_SCHEMES.get(name_scheme)\n        for fname, label, size in scheme['fields']:\n            self.fields[f'config_oidc_{fname}_field'] = forms.CharField(\n                label=pgettext_lazy('sso_oidc', f'{label} field').format(label=label),\n                required=False,\n            )\n\n        self.fields['method'].choices = [c for c in self.fields['method'].choices if c[0]]\n\n        for fname, f in self.fields.items():\n            if fname.startswith('config_'):\n                prefix, method, suffix = fname.split('_', 2)\n                f.widget.attrs['data-display-dependency'] = f'input[name=method][value={method}]'\n\n                if self.instance and self.instance.method == method:\n                    f.initial = self.instance.configuration.get(suffix)\n\n    def clean(self):\n        data = self.cleaned_data\n        if not data.get(\"method\"):\n            return data\n\n        config = {}\n        for fname, f in self.fields.items():\n            if fname.startswith(f'config_{data[\"method\"]}_'):\n                prefix, method, suffix = fname.split('_', 2)\n                config[suffix] = data.get(fname)\n\n        if data[\"method\"] == \"oidc\":\n            oidc_validate_and_complete_config(config)\n\n        self.instance.configuration = config\n\n\nclass SSOClientForm(I18nModelForm):\n    regenerate_client_secret = forms.BooleanField(\n        label=_('Invalidate old client secret and generate a new one'),\n        required=False,\n    )\n\n    class Meta:\n        model = CustomerSSOClient\n        fields = ['is_active', 'name', 'client_id', 'client_type', 'authorization_grant_type', 'redirect_uris',\n                  'allowed_scopes']\n        widgets = {\n            'authorization_grant_type': forms.RadioSelect,\n            'client_type': forms.RadioSelect,\n            'allowed_scopes': forms.CheckboxSelectMultiple,\n        }\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.fields['allowed_scopes'] = forms.MultipleChoiceField(\n            label=self.fields['allowed_scopes'].label,\n            help_text=self.fields['allowed_scopes'].help_text,\n            required=self.fields['allowed_scopes'].required,\n            initial=self.fields['allowed_scopes'].initial,\n            choices=CustomerSSOClient.SCOPE_CHOICES,\n            widget=forms.CheckboxSelectMultiple\n        )\n        if self.instance and self.instance.pk:\n            self.fields['client_id'].disabled = True\n        else:\n            del self.fields['client_id']\n            del self.fields['regenerate_client_secret']\n\n\nclass GiftCardAcceptanceInviteForm(forms.Form):\n    acceptor = forms.CharField(\n        label=_(\"Organizer short name\"),\n        required=True,\n    )\n    reusable_media = forms.BooleanField(\n        label=_(\"Allow access to reusable media\"),\n        help_text=_(\"This is required if you want the other organizer to participate in a shared system with e.g. \"\n                    \"NFC payment chips. You should only use this option for organizers you trust, since (depending \"\n                    \"on the activated medium types) this will grant the other organizer access to cryptographic key \"\n                    \"material required to interact with the media type.\"),\n        required=False,\n    )\n\n    def __init__(self, *args, **kwargs):\n        self.organizer = kwargs.pop('organizer')\n        super().__init__(*args, **kwargs)\n\n    def clean_acceptor(self):\n        val = self.cleaned_data['acceptor']\n        try:\n            acceptor = Organizer.objects.exclude(pk=self.organizer.pk).get(slug=val)\n        except Organizer.DoesNotExist:\n            raise ValidationError(_('The selected organizer does not exist or cannot be invited.'))\n        if self.organizer.gift_card_acceptor_acceptance.filter(acceptor=acceptor).exists():\n            raise ValidationError(_('The selected organizer has already been invited.'))\n        return acceptor\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport logging\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.utils.translation import gettext_lazy as _\nfrom PIL.Image import MAX_IMAGE_PIXELS, DecompressionBombError\n\nIMAGE_TYPES = {'image/gif', 'image/jpeg', 'image/png'}\nIMAGE_EXTS = {'.gif', '.jpg', '.jpeg', '.png'}\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_uploaded_file_for_valid_image(f):\n    if f is None:\n        return None\n\n    from PIL import Image\n\n    # We need to get a file object for Pillow. We might have a path or we might\n    # have to read the data into memory.\n    if hasattr(f, 'temporary_file_path'):\n        file = f.temporary_file_path()\n    else:\n        if hasattr(f, 'read'):\n            file = BytesIO(f.read())\n        else:\n            file = BytesIO(f['content'])\n\n    try:\n        try:\n            image = Image.open(file, formats=settings.PILLOW_FORMATS_QUESTIONS_IMAGE)\n            # verify() must be called immediately after the constructor.\n            image.verify()\n        except DecompressionBombError:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n\n        # load() is a potential DoS vector (see Django bug #18520), so we verify the size first\n        if image.width * image.height > MAX_IMAGE_PIXELS:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n    except Exception as exc:\n        logger.exception('Could not parse image')\n        # Pillow doesn't recognize it as an image.\n        if isinstance(exc, ValidationError):\n            raise\n        raise ValidationError(_(\n            \"Upload a valid image. The file you uploaded was either not an image or a corrupted image.\"\n        )) from exc\n    if hasattr(f, 'seek') and callable(f.seek):\n        f.seek(0)\n\n\nclass ImageSizeValidator:\n    def __call__(self, image):\n        if image.width * image.height > MAX_IMAGE_PIXELS:\n            raise ValidationError(_(\n                \"The file you uploaded has a very large number of pixels, please upload a picture with smaller dimensions.\"\n            ))\n        return image\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nfrom datetime import datetime\n\nfrom PIL import Image\n\n\ndef monkeypatch_vobject_performance():\n    \"\"\"\n    This works around a performance issue in the unmaintained vobject library which calls\n    a very expensive function for every event in a calendar. Since the slow function is\n    mostly used to compare timezones to UTC, not to arbitrary other timezones, we can\n    add a few early-out optimizations.\n    \"\"\"\n\n    from vobject import icalendar\n\n    old_tzinfo_eq = icalendar.tzinfo_eq\n    test_date = datetime(2000, 1, 1)\n\n    def new_tzinfo_eq(tzinfo1, tzinfo2, *args, **kwargs):\n        if tzinfo1 is None:\n            return tzinfo2 is None\n        if tzinfo2 is None:\n            return tzinfo1 is None\n\n        n1 = tzinfo1.tzname(test_date)\n        n2 = tzinfo2.tzname(test_date)\n        if n1 == \"UTC\" and n2 == \"UTC\":\n            return True\n        if n1 == \"UTC\" or n2 == \"UTC\":\n            return False\n        return old_tzinfo_eq(tzinfo1, tzinfo2, *args, **kwargs)\n\n    icalendar.tzinfo_eq = new_tzinfo_eq\n\n\ndef monkeypatch_pillow_safer():\n    \"\"\"\n    Pillow supports many file formats, among them EPS. For EPS, Pillow loads GhostScript whenever GhostScript\n    is installed (cannot officially be disabled). However, GhostScript is known for regular security vulnerabilities.\n    We have no use of reading EPS files and usually prevent this by using `Image.open(\u2026, formats=[\u2026])` to disable EPS\n    support explicitly. However, we are worried about our dependencies like reportlab using `Image.open` without the\n    `formats=` parameter. Therefore, as a defense in depth approach, we monkeypatch EPS support away by modifying the\n    internal image format registry of Pillow.\n    \"\"\"\n    if \"EPS\" in Image.ID:\n        Image.ID.remove(\"EPS\")\n\n\ndef monkeypatch_all_at_ready():\n    monkeypatch_vobject_performance()\n    monkeypatch_pillow_safer()\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nfrom arabic_reshaper import ArabicReshaper\nfrom django.conf import settings\nfrom django.utils.functional import SimpleLazyObject\nfrom PIL import Image\nfrom reportlab.lib.utils import ImageReader\n\n\nclass ThumbnailingImageReader(ImageReader):\n    def resize(self, width, height, dpi):\n        if width is None:\n            width = height * self._image.size[0] / self._image.size[1]\n        if height is None:\n            height = width * self._image.size[1] / self._image.size[0]\n        self._image.thumbnail(\n            size=(int(width * dpi / 72), int(height * dpi / 72)),\n            resample=Image.Resampling.BICUBIC\n        )\n        self._data = None\n        return width, height\n\n    def _jpeg_fh(self):\n        # Bypass a reportlab-internal optimization that falls back to the original\n        # file handle if the file is a JPEG, and therefore does not respect the\n        # (smaller) size of the modified image.\n        return None\n\n    def _read_image(self, fp):\n        return Image.open(fp, formats=settings.PILLOW_FORMATS_IMAGE)\n\n\nreshaper = SimpleLazyObject(lambda: ArabicReshaper(configuration={\n    'delete_harakat': True,\n    'support_ligatures': False,\n}))\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\nimport hashlib\nimport math\nfrom io import BytesIO\n\nfrom django.conf import settings\nfrom django.core.files.base import ContentFile\nfrom django.core.files.storage import default_storage\nfrom PIL import Image, ImageOps, ImageSequence\nfrom PIL.Image import Resampling\n\nfrom pretix.helpers.models import Thumbnail\n\n\nclass ThumbnailError(Exception):\n    pass\n\n\n\"\"\"\n\n# How \"size\" works:\n\n\n## normal resize\n\nimage|thumb:\"100x100\" resizes the image proportionally to a maximum width and maximum height of 100px.\nI.e. an image of 200x100 will be resized to 100x50.\nAn image of 40x80 will stay 40x80.\n\n\n## cropped resize with ^\n\nimage|thumb:\"100x100^\" resizes the image proportionally to a minimum width and minimum height of 100px and then will be cropped to 100x100.\nI.e. an image of 300x200 will be resized to 150x100 and then cropped from center to 100x100.\nAn image of 40x80 will stay 40x80.\n\n\n## exact-size resize with _\n\nexact-size-operator \"_\" works for width and height independently, so the following is possible:\n\nimage|thumb:\"100_x100\" resizes the image to a maximum height of 100px (if it is lower, it does not upscale) and makes it exactly 100px wide\n(if the resized image would be less than 100px wide it adds a white background to both sides to make it at least 100px wide).\nI.e. an image of 300x200 will be resized to 150x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 100x80.\n\nimage|thumb:\"100x100_\" resizes the image to a maximum width of 100px (if it is lower, it does not upscale) and makes it at least 100px high\n(if the resized image would be less than 100px high it adds a white background to top and bottom to make it at least 100px high).\nI.e. an image of 400x200 will be resized to 100x50 and then padded from center to be 100x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 40x100.\n\nimage|thumb:\"100_x100_\" resizes the image proportionally to either a width or height of 100px \u2013 it takes the smaller side and resizes that to 100px,\nso the longer side will at least be 100px. So the resulting image will at least be 100px wide and at least 100px high. If the original image is bigger\nthan 100x100 then no padding will occur. If the original image is smaller than 100x100, no resize will happen but padding to 100x100 will occur.\nI.e. an image of 400x200 will be resized to 200x100.\nAn image of 40x80 will stay 40x80 but padded with a white background to be 100x100.\n\n\"\"\"\n\n\ndef get_minsize(size):\n    if \"_\" not in size:\n        return (0, 0)\n    min_width = 0\n    min_height = 0\n    if \"x\" in size:\n        sizes = size.split('x')\n        if sizes[0].endswith(\"_\"):\n            min_width = int(sizes[0][:-1])\n        if sizes[1].endswith(\"_\"):\n            min_height = int(sizes[1][:-1])\n    elif size.endswith(\"_\"):\n        min_width = int(size[:-1])\n        min_height = min_width\n    return (min_width, min_height)\n\n\ndef get_sizes(size, imgsize):\n    crop = False\n    if size.endswith('^'):\n        crop = True\n        size = size[:-1]\n\n    if crop and \"_\" in size:\n        raise ThumbnailError('Size %s has errors: crop and minsize cannot be combined.' % size)\n\n    size = size.replace(\"_\", \"\")\n\n    if 'x' in size:\n        size = [int(p) for p in size.split('x')]\n    else:\n        size = [int(size), int(size)]\n\n    if crop:\n        # currently crop and min-size cannot be combined\n        wfactor = min(1, size[0] / imgsize[0])\n        hfactor = min(1, size[1] / imgsize[1])\n        if wfactor == hfactor:\n            return (int(imgsize[0] * wfactor), int(imgsize[1] * hfactor)), \\\n                   (0, int((imgsize[1] * wfactor - imgsize[1] * hfactor) / 2),\n                    imgsize[0] * hfactor, int((imgsize[1] * wfactor + imgsize[1] * wfactor) / 2))\n        elif wfactor > hfactor:\n            return (int(size[0]), int(imgsize[1] * wfactor)), \\\n                   (0, int((imgsize[1] * wfactor - size[1]) / 2), size[0], int((imgsize[1] * wfactor + size[1]) / 2))\n        else:\n            return (int(imgsize[0] * hfactor), int(size[1])), \\\n                   (int((imgsize[0] * hfactor - size[0]) / 2), 0, int((imgsize[0] * hfactor + size[0]) / 2), size[1])\n    else:\n        wfactor = min(1, size[0] / imgsize[0])\n        hfactor = min(1, size[1] / imgsize[1])\n\n        if wfactor == hfactor:\n            return (int(imgsize[0] * hfactor), int(imgsize[1] * wfactor)), None\n        elif wfactor < hfactor:\n            return (size[0], int(imgsize[1] * wfactor)), None\n        else:\n            return (int(imgsize[0] * hfactor), size[1]), None\n\n\ndef resize_image(image, size):\n    # before we calc thumbnail, we need to check and apply EXIF-orientation\n    image = ImageOps.exif_transpose(image)\n\n    new_size, crop = get_sizes(size, image.size)\n    image = image.resize(new_size, resample=Resampling.LANCZOS)\n    if crop:\n        image = image.crop(crop)\n\n    min_width, min_height = get_minsize(size)\n\n    if min_width > new_size[0] or min_height > new_size[1]:\n        padding = math.ceil(max(min_width - new_size[0], min_height - new_size[1]) / 2)\n        if image.mode not in (\"RGB\", \"RGBA\"):\n            image = image.convert('RGB')\n        image = ImageOps.expand(image, border=padding, fill=\"white\")\n\n        new_width = max(min_width, new_size[0])\n        new_height = max(min_height, new_size[1])\n        new_x = (image.width - new_width) // 2\n        new_y = (image.height - new_height) // 2\n\n        image = image.crop((new_x, new_y, new_x + new_width, new_y + new_height))\n\n    return image\n\n\ndef create_thumbnail(sourcename, size):\n    source = default_storage.open(sourcename)\n    image = Image.open(BytesIO(source.read()), formats=settings.PILLOW_FORMATS_QUESTIONS_IMAGE)\n    try:\n        image.load()\n    except:\n        raise ThumbnailError('Could not load image')\n\n    frames = [resize_image(frame, size) for frame in ImageSequence.Iterator(image)]\n    image_out = frames[0]\n    save_kwargs = {}\n\n    if source.name.lower().endswith('.jpg') or source.name.lower().endswith('.jpeg'):\n        # Yields better file sizes for photos\n        target_ext = 'jpeg'\n        quality = 95\n    elif source.name.lower().endswith('.gif') or source.name.lower().endswith('.png'):\n        target_ext = source.name.lower()[-3:]\n        quality = None\n        image_out.info = image.info\n        save_kwargs = {\n            'append_images': frames[1:],\n            'loop': image.info.get('loop', 0),\n            'save_all': True,\n        }\n    else:\n        target_ext = 'png'\n        quality = None\n\n    checksum = hashlib.md5(image.tobytes()).hexdigest()\n    name = checksum + '.' + size.replace('^', 'c') + '.' + target_ext\n    buffer = BytesIO()\n    if image_out.mode == \"P\" and source.name.lower().endswith('.png'):\n        image_out = image_out.convert('RGBA')\n    if image_out.mode not in (\"1\", \"L\", \"RGB\", \"RGBA\"):\n        image_out = image_out.convert('RGB')\n    image_out.save(fp=buffer, format=target_ext.upper(), quality=quality, **save_kwargs)\n    imgfile = ContentFile(buffer.getvalue())\n\n    t = Thumbnail.objects.create(source=sourcename, size=size)\n    t.thumb.save(name, imgfile)\n    return t\n\n\ndef get_thumbnail(source, size):\n    # Assumes files are immutable\n    try:\n        return Thumbnail.objects.get(source=source, size=size)\n    except Thumbnail.DoesNotExist:\n        return create_thumbnail(source, size)\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: Alexey Kislitsin, Daniel, Flavia Bastos, Sanket\n# Dasgupta, Sohalt, pajowu\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nfrom django import forms\nfrom django.conf import settings\nfrom django.core.exceptions import ValidationError\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _, pgettext_lazy\nfrom django_scopes.forms import SafeModelMultipleChoiceField\nfrom i18nfield.forms import I18nFormField, I18nTextarea, I18nTextInput\n\nfrom pretix.base.email import get_available_placeholders\nfrom pretix.base.forms import I18nModelForm, PlaceholderValidator\nfrom pretix.base.forms.widgets import (\n    SplitDateTimePickerWidget, TimePickerWidget,\n)\nfrom pretix.base.models import CheckinList, Item, Order, SubEvent\nfrom pretix.control.forms import CachedFileField, SplitDateTimeField\nfrom pretix.control.forms.widgets import Select2, Select2Multiple\nfrom pretix.plugins.sendmail.models import Rule\n\n\nclass FormPlaceholderMixin:\n    def _set_field_placeholders(self, fn, base_parameters):\n        phs = [\n            '{%s}' % p\n            for p in sorted(get_available_placeholders(self.event, base_parameters).keys())\n        ]\n        ht = _('Available placeholders: {list}').format(\n            list=', '.join(phs)\n        )\n        if self.fields[fn].help_text:\n            self.fields[fn].help_text += ' ' + str(ht)\n        else:\n            self.fields[fn].help_text = ht\n        self.fields[fn].validators.append(\n            PlaceholderValidator(phs)\n        )\n\n\nclass BaseMailForm(FormPlaceholderMixin, forms.Form):\n    subject = forms.CharField(label=_(\"Subject\"))\n    message = forms.CharField(label=_(\"Message\"))\n    attachment = CachedFileField(\n        label=_(\"Attachment\"),\n        required=False,\n        ext_whitelist=settings.FILE_UPLOAD_EXTENSIONS_EMAIL_ATTACHMENT,\n        help_text=_('Sending an attachment increases the chance of your email not arriving or being sorted into spam folders. We recommend only using PDFs '\n                    'of no more than 2 MB in size.'),\n        max_size=settings.FILE_UPLOAD_MAX_SIZE_EMAIL_ATTACHMENT\n    )\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs.pop('event')\n        context_parameters = kwargs.pop('context_parameters')\n        super().__init__(*args, **kwargs)\n        self.fields['subject'] = I18nFormField(\n            label=_('Subject'),\n            widget=I18nTextInput, required=True,\n            locales=event.settings.get('locales'),\n        )\n        self.fields['message'] = I18nFormField(\n            label=_('Message'),\n            widget=I18nTextarea, required=True,\n            locales=event.settings.get('locales'),\n        )\n        self._set_field_placeholders('subject', context_parameters)\n        self._set_field_placeholders('message', context_parameters)\n\n\nclass WaitinglistMailForm(BaseMailForm):\n    items = forms.ModelMultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple(\n            attrs={'class': 'scrolling-multiple-choice'}\n        ),\n        label=pgettext_lazy('sendmail_form', 'Waiting for'),\n        required=True,\n        queryset=Item.objects.none()\n    )\n    subevent = forms.ModelChoiceField(\n        SubEvent.objects.none(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to a specific event date'),\n        required=False,\n        empty_label=pgettext_lazy('subevent', 'All dates')\n    )\n    subevents_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting at or after'),\n        required=False,\n    )\n    subevents_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting before'),\n        required=False,\n    )\n\n    def clean(self):\n        d = super().clean()\n        if d.get('subevent') and (d.get('subevents_from') or d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'Please either select a specific date or a date range, not both.'))\n        if bool(d.get('subevents_from')) != bool(d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'If you set a date range, please set both a start and an end.'))\n        return d\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs['event']\n        super().__init__(*args, **kwargs)\n\n        self.fields['items'].queryset = event.items.all()\n        if not self.initial.get('items'):\n            self.initial['items'] = event.items.all()\n\n        if event.has_subevents:\n            self.fields['subevent'].queryset = event.subevents.all()\n            self.fields['subevent'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'event',\n                    'data-select2-url': reverse('control:event.subevents.select2', kwargs={\n                        'event': event.slug,\n                        'organizer': event.organizer.slug,\n                    }),\n                    'data-placeholder': pgettext_lazy('subevent', 'Date')\n                }\n            )\n            self.fields['subevent'].widget.choices = self.fields['subevent'].choices\n        else:\n            del self.fields['subevent']\n            del self.fields['subevents_from']\n            del self.fields['subevents_to']\n\n\nclass OrderMailForm(BaseMailForm):\n    recipients = forms.ChoiceField(\n        label=pgettext_lazy('sendmail_form', 'Send to'),\n        widget=forms.RadioSelect,\n        initial='orders',\n        choices=[]\n    )\n    sendto = forms.MultipleChoiceField()  # overridden later\n    items = forms.ModelMultipleChoiceField(\n        widget=forms.CheckboxSelectMultiple(\n            attrs={'class': 'scrolling-multiple-choice'}\n        ),\n        label=pgettext_lazy('sendmail_form', 'Restrict to products'),\n        required=True,\n        queryset=Item.objects.none()\n    )\n    filter_checkins = forms.BooleanField(\n        label=_('Filter check-in status'),\n        required=False\n    )\n    checkin_lists = SafeModelMultipleChoiceField(queryset=CheckinList.objects.none(), required=False)  # overridden later\n    not_checked_in = forms.BooleanField(label=pgettext_lazy('sendmail_form', 'Restrict to recipients without check-in'), required=False)\n    subevent = forms.ModelChoiceField(\n        SubEvent.objects.none(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to a specific event date'),\n        required=False,\n        empty_label=pgettext_lazy('subevent', 'All dates')\n    )\n    subevents_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting at or after'),\n        required=False,\n    )\n    subevents_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to event dates starting before'),\n        required=False,\n    )\n    created_from = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to orders created at or after'),\n        required=False,\n    )\n    created_to = forms.SplitDateTimeField(\n        widget=SplitDateTimePickerWidget(),\n        label=pgettext_lazy('sendmail_form', 'Restrict to orders created before'),\n        required=False,\n    )\n    attach_tickets = forms.BooleanField(\n        label=_(\"Attach tickets\"),\n        help_text=_(\"Will be ignored if tickets exceed a given size limit to ensure email deliverability.\"),\n        required=False\n    )\n    attach_ical = forms.BooleanField(\n        label=_(\"Attach calendar files\"),\n        required=False\n    )\n\n    def clean(self):\n        d = super().clean()\n        if d.get('subevent') and (d.get('subevents_from') or d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'Please either select a specific date or a date range, not both.'))\n        if bool(d.get('subevents_from')) != bool(d.get('subevents_to')):\n            raise ValidationError(pgettext_lazy('subevent', 'If you set a date range, please set both a start and an end.'))\n        return d\n\n    def __init__(self, *args, **kwargs):\n        event = self.event = kwargs['event']\n        super().__init__(*args, **kwargs)\n\n        recp_choices = [\n            ('orders', _('Everyone who placed an order'))\n        ]\n        if event.settings.attendee_emails_asked:\n            recp_choices += [\n                ('attendees', _('Every attendee (falling back to the order contact when no attendee email address is '\n                                'given)')),\n                ('both', _('Both (all order contact addresses and all attendee email addresses)'))\n            ]\n        self.fields['recipients'].choices = recp_choices\n\n        choices = [(e, l) for e, l in Order.STATUS_CHOICE if e != 'n']\n        choices.insert(0, ('valid_if_pending', _('payment pending but already confirmed')))\n        choices.insert(0, ('na', _('payment pending (except unapproved or already confirmed)')))\n        choices.insert(0, ('pa', _('approval pending')))\n        if not event.settings.get('payment_term_expire_automatically', as_type=bool):\n            choices.append(\n                ('overdue', _('pending with payment overdue'))\n            )\n        self.fields['sendto'] = forms.MultipleChoiceField(\n            label=pgettext_lazy('sendmail_form', 'Restrict to orders with status'),\n            widget=forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice no-search'}\n            ),\n            choices=choices\n        )\n        if not self.initial.get('sendto'):\n            self.initial['sendto'] = ['p', 'valid_if_pending']\n        elif 'n' in self.initial['sendto']:\n            self.initial['sendto'].append('pa')\n            self.initial['sendto'].append('na')\n            self.initial['sendto'].append('valid_if_pending')\n\n        self.fields['items'].queryset = event.items.all()\n        if not self.initial.get('items'):\n            self.initial['items'] = event.items.all()\n\n        self.fields['checkin_lists'].queryset = event.checkin_lists.all()\n        self.fields['checkin_lists'].widget = Select2Multiple(\n            attrs={\n                'data-model-select2': 'generic',\n                'data-select2-url': reverse('control:event.orders.checkinlists.select2', kwargs={\n                    'event': event.slug,\n                    'organizer': event.organizer.slug,\n                }),\n                'data-placeholder': pgettext_lazy('sendmail_form', 'Restrict to recipients with check-in on list')\n            }\n        )\n        self.fields['checkin_lists'].widget.choices = self.fields['checkin_lists'].choices\n        self.fields['checkin_lists'].label = pgettext_lazy('sendmail_form', 'Restrict to recipients with check-in on list')\n\n        if event.has_subevents:\n            self.fields['subevent'].queryset = event.subevents.all()\n            self.fields['subevent'].widget = Select2(\n                attrs={\n                    'data-model-select2': 'event',\n                    'data-select2-url': reverse('control:event.subevents.select2', kwargs={\n                        'event': event.slug,\n                        'organizer': event.organizer.slug,\n                    }),\n                    'data-placeholder': pgettext_lazy('subevent', 'Date')\n                }\n            )\n            self.fields['subevent'].widget.choices = self.fields['subevent'].choices\n        else:\n            del self.fields['subevent']\n            del self.fields['subevents_from']\n            del self.fields['subevents_to']\n\n\nclass RuleForm(FormPlaceholderMixin, I18nModelForm):\n    class Meta:\n        model = Rule\n\n        fields = ['subject', 'template', 'attach_ical',\n                  'send_date', 'send_offset_days', 'send_offset_time',\n                  'all_products', 'limit_products', 'restrict_to_status',\n                  'send_to', 'enabled']\n\n        field_classes = {\n            'subevent': SafeModelMultipleChoiceField,\n            'limit_products': SafeModelMultipleChoiceField,\n            'send_date': SplitDateTimeField,\n        }\n\n        widgets = {\n            'send_date': SplitDateTimePickerWidget(attrs={\n                'data-display-dependency': '#id_schedule_type_0',\n            }),\n            'send_offset_days': forms.NumberInput(attrs={\n                'data-display-dependency': '#id_schedule_type_1,#id_schedule_type_2,#id_schedule_type_3,'\n                                           '#id_schedule_type_4',\n            }),\n            'send_offset_time': TimePickerWidget(attrs={\n                'data-display-dependency': '#id_schedule_type_1,#id_schedule_type_2,#id_schedule_type_3,'\n                                           '#id_schedule_type_4',\n            }),\n            'limit_products': forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice',\n                       'data-inverse-dependency': '#id_all_products'},\n            ),\n            'send_to': forms.RadioSelect,\n        }\n\n    def __init__(self, *args, **kwargs):\n        instance = kwargs.get('instance')\n\n        if instance:\n            if instance.date_is_absolute:\n                dia = \"abs\"\n            else:\n                dia = \"rel\"\n                dia += \"_a\" if instance.offset_is_after else \"_b\"\n                dia += \"_e\" if instance.offset_to_event_end else \"_s\"\n\n        else:\n            dia = \"abs\"\n\n        kwargs.setdefault('initial', {})\n        kwargs['initial']['schedule_type'] = dia\n\n        super().__init__(*args, **kwargs)\n\n        self.fields['limit_products'].queryset = Item.objects.filter(event=self.event)\n\n        self.fields['schedule_type'] = forms.ChoiceField(\n            label=_('Type of schedule time'),\n            widget=forms.RadioSelect,\n            choices=[\n                ('abs', _('Absolute')),\n                ('rel_b_s', _('Relative, before event start')),\n                ('rel_b_e', _('Relative, before event end')),\n                ('rel_a_s', _('Relative, after event start')),\n                ('rel_a_e', _('Relative, after event end'))\n            ]\n        )\n\n        self._set_field_placeholders('subject', ['event', 'order'])\n        self._set_field_placeholders('template', ['event', 'order'])\n\n        choices = [(e, l) for e, l in Order.STATUS_CHOICE if e != 'n']\n        choices.insert(0, ('n__valid_if_pending', _('payment pending but already confirmed')))\n        choices.insert(0, ('n__not_pending_approval_and_not_valid_if_pending',\n                           _('payment pending (except unapproved or already confirmed)')))\n        choices.insert(0, ('n__pending_approval', _('approval pending')))\n        if not self.event.settings.get('payment_term_expire_automatically', as_type=bool):\n            choices.append(\n                ('p__overdue', _('pending with payment overdue'))\n            )\n        self.fields['restrict_to_status'] = forms.MultipleChoiceField(\n            label=pgettext_lazy('sendmail_from', 'Restrict to orders with status'),\n            widget=forms.CheckboxSelectMultiple(\n                attrs={'class': 'scrolling-multiple-choice no-search'}\n            ),\n            choices=choices\n        )\n        if not self.initial.get('restrict_to_status'):\n            self.initial['restrict_to_status'] = ['p', 'n__valid_if_pending']\n\n    def clean(self):\n        d = super().clean()\n\n        dia = d.get('schedule_type')\n        if dia == 'abs':\n            if not d.get('send_date'):\n                raise ValidationError({'send_date': _('Please specify the send date')})\n            d['date_is_absolute'] = True\n            d['send_offset_days'] = d['send_offset_time'] = None\n        else:\n            if not (d.get('send_offset_days') is not None and d.get('send_offset_time') is not None):\n                raise ValidationError(_('Please specify the offset days and time'))\n            d['offset_is_after'] = '_a' in dia\n            d['offset_to_event_end'] = '_e' in dia\n            d['date_is_absolute'] = False\n            d['send_date'] = None\n\n        if d.get('all_products'):\n            # having products checked while the option is ignored is probably counterintuitive\n            d['limit_products'] = Item.objects.none()\n        else:\n            if not d.get('limit_products'):\n                raise ValidationError({'limit_products': _('Please specify a product')})\n\n        self.instance.offset_is_after = d.get('offset_is_after', False)\n        self.instance.offset_to_event_end = d.get('offset_to_event_end', False)\n        self.instance.date_is_absolute = d.get('date_is_absolute', False)\n\n        return d\n", "#\n# This file is part of pretix (Community Edition).\n#\n# Copyright (C) 2014-2020 Raphael Michel and contributors\n# Copyright (C) 2020-2021 rami.io GmbH and contributors\n#\n# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General\n# Public License as published by the Free Software Foundation in version 3 of the License.\n#\n# ADDITIONAL TERMS APPLY: Pursuant to Section 7 of the GNU Affero General Public License, additional terms are\n# applicable granting you additional permissions and placing additional restrictions on your usage of this software.\n# Please refer to the pretix LICENSE file to obtain the full terms applicable to this work. If you did not receive\n# this file, see <https://pretix.eu/about/en/license>.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more\n# details.\n#\n# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see\n# <https://www.gnu.org/licenses/>.\n#\n\n# This file is based on an earlier version of pretix which was released under the Apache License 2.0. The full text of\n# the Apache License 2.0 can be obtained at <http://www.apache.org/licenses/LICENSE-2.0>.\n#\n# This file may have since been changed and any changes are released under the terms of AGPLv3 as described above. A\n# full history of changes and contributors is available at <https://github.com/pretix/pretix>.\n#\n# This file contains Apache-licensed contributions copyrighted by: FlaviaBastos, Jason Estibeiro, Jonas Gro\u00dfe Sundrup,\n# Laura Kl\u00fcnder, Matthew Emerson, Nils Schneider, Tim Freund, Tobias Kunze\n#\n# Unless required by applicable law or agreed to in writing, software distributed under the Apache License 2.0 is\n# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations under the License.\n\nimport configparser\nimport logging\nimport os\nimport sys\nfrom json import loads\nfrom urllib.parse import urlparse\n\nimport importlib_metadata as metadata\nfrom django.utils.crypto import get_random_string\nfrom kombu import Queue\n\nfrom . import __version__\nfrom .helpers.config import EnvOrParserConfig\n\n# Pull in all settings that we also need at wheel require time\nfrom ._base_settings import *  # NOQA\n\n\nfrom django.contrib.messages import constants as messages  # NOQA\nfrom django.utils.translation import gettext_lazy as _  # NOQA\n\n_config = configparser.RawConfigParser()\nif 'PRETIX_CONFIG_FILE' in os.environ:\n    _config.read_file(open(os.environ.get('PRETIX_CONFIG_FILE'), encoding='utf-8'))\nelse:\n    _config.read(['/etc/pretix/pretix.cfg', os.path.expanduser('~/.pretix.cfg'), 'pretix.cfg'],\n                 encoding='utf-8')\nconfig = EnvOrParserConfig(_config)\n\nCONFIG_FILE = config\nDATA_DIR = config.get('pretix', 'datadir', fallback=os.environ.get('DATA_DIR', 'data'))\nLOG_DIR = os.path.join(DATA_DIR, 'logs')\nMEDIA_ROOT = os.path.join(DATA_DIR, 'media')\nPROFILE_DIR = os.path.join(DATA_DIR, 'profiles')\nCACHE_DIR = os.path.join(DATA_DIR, 'cache')\n\nif not os.path.exists(DATA_DIR):\n    os.mkdir(DATA_DIR)\nif not os.path.exists(LOG_DIR):\n    os.mkdir(LOG_DIR)\nif not os.path.exists(MEDIA_ROOT):\n    os.mkdir(MEDIA_ROOT)\nif not os.path.exists(CACHE_DIR):\n    os.mkdir(CACHE_DIR)\n\nif config.has_option('django', 'secret'):\n    SECRET_KEY = config.get('django', 'secret')\nelse:\n    SECRET_FILE = os.path.join(DATA_DIR, '.secret')\n    if os.path.exists(SECRET_FILE):\n        with open(SECRET_FILE, 'r') as f:\n            SECRET_KEY = f.read().strip()\n    else:\n        chars = 'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'\n        SECRET_KEY = get_random_string(50, chars)\n        with open(SECRET_FILE, 'w') as f:\n            os.chmod(SECRET_FILE, 0o600)\n            try:\n                os.chown(SECRET_FILE, os.getuid(), os.getgid())\n            except AttributeError:\n                pass  # os.chown is not available on Windows\n            f.write(SECRET_KEY)\n\n# Adjustable settings\n\ndebug_fallback = \"runserver\" in sys.argv\nDEBUG = config.getboolean('django', 'debug', fallback=debug_fallback)\nLOG_CSP = config.getboolean('pretix', 'csp_log', fallback=False)\nCSP_ADDITIONAL_HEADER = config.get('pretix', 'csp_additional_header', fallback='')\n\nPDFTK = config.get('tools', 'pdftk', fallback=None)\n\nPRETIX_AUTH_BACKENDS = config.get('pretix', 'auth_backends', fallback='pretix.base.auth.NativeAuthBackend').split(',')\n\ndb_backend = config.get('database', 'backend', fallback='sqlite3')\nif db_backend == 'postgresql_psycopg2':\n    db_backend = 'postgresql'\nelif 'mysql' in db_backend:\n    print(\"pretix does no longer support running on MySQL/MariaDB\")\n    sys.exit(1)\n\ndb_options = {}\n\npostgresql_sslmode = config.get('database', 'sslmode', fallback='disable')\nUSE_DATABASE_TLS = postgresql_sslmode != 'disable'\nUSE_DATABASE_MTLS = USE_DATABASE_TLS and config.has_option('database', 'sslcert')\n\nif USE_DATABASE_TLS or USE_DATABASE_MTLS:\n    tls_config = {}\n    if not USE_DATABASE_MTLS:\n        if 'postgresql' in db_backend:\n            tls_config = {\n                'sslmode': config.get('database', 'sslmode'),\n                'sslrootcert': config.get('database', 'sslrootcert'),\n            }\n    else:\n        if 'postgresql' in db_backend:\n            tls_config = {\n                'sslmode': config.get('database', 'sslmode'),\n                'sslrootcert': config.get('database', 'sslrootcert'),\n                'sslcert': config.get('database', 'sslcert'),\n                'sslkey': config.get('database', 'sslkey'),\n            }\n\n    db_options.update(tls_config)\n\nDATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.' + db_backend,\n        'NAME': config.get('database', 'name', fallback=os.path.join(DATA_DIR, 'db.sqlite3')),\n        'USER': config.get('database', 'user', fallback=''),\n        'PASSWORD': config.get('database', 'password', fallback=''),\n        'HOST': config.get('database', 'host', fallback=''),\n        'PORT': config.get('database', 'port', fallback=''),\n        'CONN_MAX_AGE': 0 if db_backend == 'sqlite3' else 120,\n        'CONN_HEALTH_CHECKS': db_backend != 'sqlite3',  # Will only be used from Django 4.1 onwards\n        'OPTIONS': db_options,\n        'TEST': {}\n    }\n}\nDATABASE_REPLICA = 'default'\nif config.has_section('replica'):\n    DATABASE_REPLICA = 'replica'\n    DATABASES['replica'] = {\n        'ENGINE': 'django.db.backends.' + db_backend,\n        'NAME': config.get('replica', 'name', fallback=DATABASES['default']['NAME']),\n        'USER': config.get('replica', 'user', fallback=DATABASES['default']['USER']),\n        'PASSWORD': config.get('replica', 'password', fallback=DATABASES['default']['PASSWORD']),\n        'HOST': config.get('replica', 'host', fallback=DATABASES['default']['HOST']),\n        'PORT': config.get('replica', 'port', fallback=DATABASES['default']['PORT']),\n        'CONN_MAX_AGE': 0 if db_backend == 'sqlite3' else 120,\n        'OPTIONS': db_options,\n        'TEST': {}\n    }\n    DATABASE_ROUTERS = ['pretix.helpers.database.ReplicaRouter']\n\nSTATIC_URL = config.get('urls', 'static', fallback='/static/')\n\nMEDIA_URL = config.get('urls', 'media', fallback='/media/')\n\nPRETIX_INSTANCE_NAME = config.get('pretix', 'instance_name', fallback='pretix.de')\nPRETIX_REGISTRATION = config.getboolean('pretix', 'registration', fallback=True)\nPRETIX_PASSWORD_RESET = config.getboolean('pretix', 'password_reset', fallback=True)\nPRETIX_LONG_SESSIONS = config.getboolean('pretix', 'long_sessions', fallback=True)\nPRETIX_ADMIN_AUDIT_COMMENTS = config.getboolean('pretix', 'audit_comments', fallback=False)\nPRETIX_OBLIGATORY_2FA = config.getboolean('pretix', 'obligatory_2fa', fallback=False)\nPRETIX_SESSION_TIMEOUT_RELATIVE = 3600 * 3\nPRETIX_SESSION_TIMEOUT_ABSOLUTE = 3600 * 12\n\nSITE_URL = config.get('pretix', 'url', fallback='http://localhost:8000')\nif SITE_URL.endswith('/'):\n    SITE_URL = SITE_URL[:-1]\n\nCSRF_TRUSTED_ORIGINS = [urlparse(SITE_URL).scheme + '://' + urlparse(SITE_URL).hostname]\n\nTRUST_X_FORWARDED_FOR = config.getboolean('pretix', 'trust_x_forwarded_for', fallback=False)\nUSE_X_FORWARDED_HOST = config.getboolean('pretix', 'trust_x_forwarded_host', fallback=False)\n\n\nREQUEST_ID_HEADER = config.get('pretix', 'request_id_header', fallback=False)\n\nif config.getboolean('pretix', 'trust_x_forwarded_proto', fallback=False):\n    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')\n\nPRETIX_PLUGINS_DEFAULT = config.get('pretix', 'plugins_default',\n                                    fallback='pretix.plugins.sendmail,pretix.plugins.statistics,pretix.plugins.checkinlists,pretix.plugins.autocheckin')\nPRETIX_PLUGINS_EXCLUDE = config.get('pretix', 'plugins_exclude', fallback='').split(',')\nPRETIX_PLUGINS_SHOW_META = config.getboolean('pretix', 'plugins_show_meta', fallback=True)\n\nFETCH_ECB_RATES = config.getboolean('pretix', 'ecb_rates', fallback=True)\n\nDEFAULT_CURRENCY = config.get('pretix', 'currency', fallback='EUR')\n\nALLOWED_HOSTS = ['*']\n\nLANGUAGE_CODE = config.get('locale', 'default', fallback='en')\nTIME_ZONE = config.get('locale', 'timezone', fallback='UTC')\n\nMAIL_FROM = SERVER_EMAIL = DEFAULT_FROM_EMAIL = config.get('mail', 'from', fallback='pretix@localhost')\nMAIL_FROM_NOTIFICATIONS = config.get('mail', 'from_notifications', fallback=MAIL_FROM)\nMAIL_FROM_ORGANIZERS = config.get('mail', 'from_organizers', fallback=MAIL_FROM)\nMAIL_CUSTOM_SENDER_VERIFICATION_REQUIRED = config.getboolean('mail', 'custom_sender_verification_required', fallback=True)\nMAIL_CUSTOM_SENDER_SPF_STRING = config.get('mail', 'custom_sender_spf_string', fallback='')\nMAIL_CUSTOM_SMTP_ALLOW_PRIVATE_NETWORKS = config.getboolean('mail', 'custom_smtp_allow_private_networks', fallback=DEBUG)\nEMAIL_HOST = config.get('mail', 'host', fallback='localhost')\nEMAIL_PORT = config.getint('mail', 'port', fallback=25)\nEMAIL_HOST_USER = config.get('mail', 'user', fallback='')\nEMAIL_HOST_PASSWORD = config.get('mail', 'password', fallback='')\nEMAIL_USE_TLS = config.getboolean('mail', 'tls', fallback=False)\nEMAIL_USE_SSL = config.getboolean('mail', 'ssl', fallback=False)\nEMAIL_SUBJECT_PREFIX = '[pretix] '\nEMAIL_BACKEND = EMAIL_CUSTOM_SMTP_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_TIMEOUT = 60\n\nADMINS = [('Admin', n) for n in config.get('mail', 'admins', fallback='').split(\",\") if n]\n\nMETRICS_ENABLED = config.getboolean('metrics', 'enabled', fallback=False)\nMETRICS_USER = config.get('metrics', 'user', fallback=\"metrics\")\nMETRICS_PASSPHRASE = config.get('metrics', 'passphrase', fallback=\"\")\n\nCACHES = {\n    'default': {\n        'BACKEND': 'pretix.helpers.cache.CustomDummyCache',\n    }\n}\nREAL_CACHE_USED = False\nSESSION_ENGINE = None\n\nHAS_MEMCACHED = config.has_option('memcached', 'location')\nif HAS_MEMCACHED:\n    REAL_CACHE_USED = True\n    CACHES['default'] = {\n        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',\n        'LOCATION': config.get('memcached', 'location'),\n    }\n\nHAS_REDIS = config.has_option('redis', 'location')\nUSE_REDIS_SENTINEL = config.has_option('redis', 'sentinels')\nredis_ssl_cert_reqs = config.get('redis', 'ssl_cert_reqs', fallback='none')\nUSE_REDIS_TLS = redis_ssl_cert_reqs != 'none'\nUSE_REDIS_MTLS = USE_REDIS_TLS and config.has_option('redis', 'ssl_certfile')\nHAS_REDIS_PASSWORD = config.has_option('redis', 'password')\nif HAS_REDIS:\n    OPTIONS = {\n        \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\",\n        \"REDIS_CLIENT_KWARGS\": {\"health_check_interval\": 30}\n    }\n\n    if USE_REDIS_SENTINEL:\n        DJANGO_REDIS_CONNECTION_FACTORY = \"django_redis.pool.SentinelConnectionFactory\"\n        OPTIONS[\"CLIENT_CLASS\"] = \"django_redis.client.SentinelClient\"\n        OPTIONS[\"CONNECTION_POOL_CLASS\"] = \"redis.sentinel.SentinelConnectionPool\"\n        # See https://github.com/jazzband/django-redis/issues/540\n        OPTIONS[\"SENTINEL_KWARGS\"] = {\"socket_timeout\": 1}\n        OPTIONS[\"SENTINELS\"] = [tuple(sentinel) for sentinel in loads(config.get('redis', 'sentinels'))]\n\n    if USE_REDIS_TLS or USE_REDIS_MTLS:\n        tls_config = {}\n        if not USE_REDIS_MTLS:\n            tls_config = {\n                'ssl_cert_reqs': config.get('redis', 'ssl_cert_reqs'),\n                'ssl_ca_certs': config.get('redis', 'ssl_ca_certs'),\n            }\n        else:\n            tls_config = {\n                'ssl_cert_reqs': config.get('redis', 'ssl_cert_reqs'),\n                'ssl_ca_certs': config.get('redis', 'ssl_ca_certs'),\n                'ssl_keyfile': config.get('redis', 'ssl_keyfile'),\n                'ssl_certfile': config.get('redis', 'ssl_certfile'),\n            }\n\n        if USE_REDIS_SENTINEL is False:\n            # The CONNECTION_POOL_KWARGS option is necessary for self-signed certs. For further details, please check\n            # https://github.com/jazzband/django-redis/issues/554#issuecomment-949498321\n            OPTIONS[\"CONNECTION_POOL_KWARGS\"] = tls_config\n            OPTIONS[\"REDIS_CLIENT_KWARGS\"].update(tls_config)\n        else:\n            OPTIONS[\"SENTINEL_KWARGS\"].update(tls_config)\n\n    if HAS_REDIS_PASSWORD:\n        OPTIONS[\"PASSWORD\"] = config.get('redis', 'password')\n\n    CACHES['redis'] = {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": config.get('redis', 'location'),\n        \"OPTIONS\": OPTIONS\n    }\n    CACHES['redis_sessions'] = {\n        \"BACKEND\": \"django_redis.cache.RedisCache\",\n        \"LOCATION\": config.get('redis', 'location'),\n        \"TIMEOUT\": 3600 * 24 * 30,\n        \"OPTIONS\": OPTIONS\n    }\n    if not HAS_MEMCACHED:\n        CACHES['default'] = CACHES['redis']\n        REAL_CACHE_USED = True\n    if config.getboolean('redis', 'sessions', fallback=False):\n        SESSION_ENGINE = \"django.contrib.sessions.backends.cache\"\n        SESSION_CACHE_ALIAS = \"redis_sessions\"\n\nif not SESSION_ENGINE:\n    if REAL_CACHE_USED:\n        SESSION_ENGINE = \"django.contrib.sessions.backends.cached_db\"\n    else:\n        SESSION_ENGINE = \"django.contrib.sessions.backends.db\"\n\nHAS_CELERY = config.has_option('celery', 'broker')\nHAS_CELERY_BROKER_TRANSPORT_OPTS = config.has_option('celery', 'broker_transport_options')\nHAS_CELERY_BACKEND_TRANSPORT_OPTS = config.has_option('celery', 'backend_transport_options')\nif HAS_CELERY:\n    CELERY_BROKER_URL = config.get('celery', 'broker')\n    CELERY_RESULT_BACKEND = config.get('celery', 'backend')\n    if HAS_CELERY_BROKER_TRANSPORT_OPTS:\n        CELERY_BROKER_TRANSPORT_OPTIONS = loads(config.get('celery', 'broker_transport_options'))\n    if HAS_CELERY_BACKEND_TRANSPORT_OPTS:\n        CELERY_RESULT_BACKEND_TRANSPORT_OPTIONS = loads(config.get('celery', 'backend_transport_options'))\nelse:\n    CELERY_TASK_ALWAYS_EAGER = True\n\nSESSION_COOKIE_DOMAIN = config.get('pretix', 'cookie_domain', fallback=None)\n\nCACHE_TICKETS_HOURS = config.getint('cache', 'tickets', fallback=24 * 3)\n\nENTROPY = {\n    'order_code': config.getint('entropy', 'order_code', fallback=5),\n    'customer_identifier': config.getint('entropy', 'customer_identifier', fallback=7),\n    'ticket_secret': config.getint('entropy', 'ticket_secret', fallback=32),\n    'voucher_code': config.getint('entropy', 'voucher_code', fallback=16),\n    'giftcard_secret': config.getint('entropy', 'giftcard_secret', fallback=12),\n}\n\nHAS_GEOIP = False\nif config.has_option('geoip', 'path'):\n    HAS_GEOIP = True\n    GEOIP_PATH = config.get('geoip', 'path')\n    GEOIP_COUNTRY = config.get('geoip', 'filename_country', fallback='GeoLite2-Country.mmdb')\n\n# Internal settings\nSESSION_COOKIE_NAME = 'pretix_session'\nLANGUAGE_COOKIE_NAME = 'pretix_language'\nCSRF_COOKIE_NAME = 'pretix_csrftoken'\nSESSION_COOKIE_HTTPONLY = True\n\nINSTALLED_APPS += [ # noqa\n    'django_filters',\n    'django_markup',\n    'django_otp',\n    'django_otp.plugins.otp_totp',\n    'django_otp.plugins.otp_static',\n    'hijack',\n    'localflavor',\n]\n\nif db_backend == 'postgresql':\n    # ALlow plugins to use django.contrib.postgres\n    INSTALLED_APPS.insert(0, 'django.contrib.postgres')\n\ntry:\n    import django_extensions  # noqa\n    INSTALLED_APPS.append('django_extensions')\nexcept ImportError:\n    pass\n\nPLUGINS = []\nfor entry_point in metadata.entry_points(group='pretix.plugin'):\n    if entry_point.module in PRETIX_PLUGINS_EXCLUDE:\n        continue\n    PLUGINS.append(entry_point.module)\n    INSTALLED_APPS.append(entry_point.module)\n\nHIJACK_PERMISSION_CHECK = \"hijack.permissions.superusers_and_staff\"\nHIJACK_INSERT_BEFORE = None\n\n\nREST_FRAMEWORK = {\n    'DEFAULT_PERMISSION_CLASSES': [\n        'pretix.api.auth.permission.EventPermission',\n    ],\n    'DEFAULT_PAGINATION_CLASS': 'pretix.api.pagination.Pagination',\n    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.NamespaceVersioning',\n    'PAGE_SIZE': 50,\n    'DEFAULT_AUTHENTICATION_CLASSES': (\n        'pretix.api.auth.token.TeamTokenAuthentication',\n        'pretix.api.auth.device.DeviceTokenAuthentication',\n        'rest_framework.authentication.SessionAuthentication',\n        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',\n    ),\n    'DEFAULT_RENDERER_CLASSES': (\n        'drf_ujson.renderers.UJSONRenderer',\n    ),\n    'DEFAULT_PARSER_CLASSES': (\n        'drf_ujson.parsers.UJSONParser',\n        'rest_framework.parsers.FormParser',\n        'rest_framework.parsers.MultiPartParser'\n    ),\n    'TEST_REQUEST_RENDERER_CLASSES': [\n        'rest_framework.renderers.MultiPartRenderer',\n        'rest_framework.renderers.JSONRenderer',\n        'pretix.testutils.api.UploadRenderer',\n    ],\n    'EXCEPTION_HANDLER': 'pretix.api.exception.custom_exception_handler',\n    'UNICODE_JSON': False\n}\n\n\nCORE_MODULES = {\n    \"pretix.base\",\n    \"pretix.presale\",\n    \"pretix.control\",\n    \"pretix.plugins.checkinlists\",\n    \"pretix.plugins.reports\",\n}\n\nMIDDLEWARE = [\n    'pretix.helpers.logs.RequestIdMiddleware',\n    'pretix.api.middleware.IdempotencyMiddleware',\n    'pretix.multidomain.middlewares.MultiDomainMiddleware',\n    'pretix.base.middleware.CustomCommonMiddleware',\n    'pretix.multidomain.middlewares.SessionMiddleware',\n    'pretix.multidomain.middlewares.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n    'hijack.middleware.HijackUserMiddleware',\n    'pretix.control.middleware.PermissionMiddleware',\n    'pretix.control.middleware.AuditLogMiddleware',\n    'pretix.base.middleware.LocaleMiddleware',\n    'pretix.base.middleware.SecurityMiddleware',\n    'pretix.presale.middleware.EventMiddleware',\n    'pretix.api.middleware.ApiScopeMiddleware',\n]\n\ntry:\n    import debug_toolbar.settings  # noqa\n    if DEBUG:\n        INSTALLED_APPS.append('debug_toolbar.apps.DebugToolbarConfig')\n        MIDDLEWARE.insert(0, 'debug_toolbar.middleware.DebugToolbarMiddleware')\n        DEBUG_TOOLBAR_PATCH_SETTINGS = False\n        DEBUG_TOOLBAR_CONFIG = {\n            'JQUERY_URL': '',\n            'DISABLE_PANELS': debug_toolbar.settings.PANELS_DEFAULTS,\n        }\n    pass\nexcept ImportError:\n    pass\n\n\nif METRICS_ENABLED:\n    MIDDLEWARE.insert(MIDDLEWARE.index('pretix.base.middleware.CustomCommonMiddleware') + 1,\n                      'pretix.helpers.metrics.middleware.MetricsMiddleware')\n\n\nPROFILING_RATE = config.getfloat('django', 'profile', fallback=0)  # Percentage of requests to profile\nif PROFILING_RATE > 0:\n    if not os.path.exists(PROFILE_DIR):\n        os.mkdir(PROFILE_DIR)\n    MIDDLEWARE.insert(0, 'pretix.helpers.profile.middleware.CProfileMiddleware')\n\n\n# Security settings\nX_FRAME_OPTIONS = 'DENY'\n\n# URL settings\nROOT_URLCONF = 'pretix.multidomain.maindomain_urlconf'\n\nWSGI_APPLICATION = 'pretix.wsgi.application'\n\nif config.has_option('languages', 'path'):\n    LOCALE_PATHS.insert(0, config.get('languages', 'path')) # noqa\n\nLANGUAGES_INCUBATING = LANGUAGES_INCUBATING - set(config.get('languages', 'allow_incubating', fallback='').split(',')) # noqa\nLANGUAGES = []\nLANGUAGES_ENABLED = [lang for lang in config.get(\"languages\", \"enabled\", fallback='').split(',') if lang]\nfor k, v in ALL_LANGUAGES: # noqa\n    if not DEBUG and k in LANGUAGES_INCUBATING:\n        continue\n    if LANGUAGES_ENABLED and k not in LANGUAGES_ENABLED:\n        continue\n    LANGUAGES.append((k, v))\n\n\nAUTH_USER_MODEL = 'pretixbase.User'\nLOGIN_URL = 'control:auth.login'\nLOGIN_URL_CONTROL = 'control:auth.login'\nCSRF_FAILURE_VIEW = 'pretix.base.views.errors.csrf_failure'\n\ntemplate_loaders = (\n    'django.template.loaders.filesystem.Loader',\n    'pretix.helpers.template_loaders.AppLoader',\n)\nif not DEBUG:\n    TEMPLATES[0]['OPTIONS']['loaders'] = ( # noqa\n        ('django.template.loaders.cached.Loader', template_loaders),\n    )\nTEMPLATES[0]['DIRS'].insert(0, os.path.join(DATA_DIR, 'templates')) # noqa\n\nINTERNAL_IPS = ('127.0.0.1', '::1')\n\nMESSAGE_TAGS = {\n    messages.INFO: 'alert-info',\n    messages.ERROR: 'alert-danger',\n    messages.WARNING: 'alert-warning',\n    messages.SUCCESS: 'alert-success',\n}\nMESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'\n\nloglevel = 'DEBUG' if DEBUG else config.get('pretix', 'loglevel', fallback='INFO')\n\nCOMPRESS_ENABLED = COMPRESS_OFFLINE = not debug_fallback\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'formatters': {\n        'default': {\n            'format': (\n                '%(levelname)s %(asctime)s RequestId=%(request_id)s %(name)s %(module)s %(message)s'\n                if REQUEST_ID_HEADER\n                else '%(levelname)s %(asctime)s %(name)s %(module)s %(message)s'\n            )\n        },\n    },\n    'filters': {\n        'require_admin_enabled': {\n            '()': 'pretix.helpers.logs.AdminExistsFilter',\n        },\n        'request_id': {\n            '()': 'pretix.helpers.logs.RequestIdFilter'\n        },\n    },\n    'handlers': {\n        'console': {\n            'level': loglevel,\n            'class': 'logging.StreamHandler',\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'csp_file': {\n            'level': loglevel,\n            'class': 'logging.FileHandler',\n            'filename': os.path.join(LOG_DIR, 'csp.log'),\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'file': {\n            'level': loglevel,\n            'class': 'logging.FileHandler',\n            'filename': os.path.join(LOG_DIR, 'pretix.log'),\n            'formatter': 'default',\n            'filters': ['request_id'],\n        },\n        'mail_admins': {\n            'level': 'ERROR',\n            'class': 'django.utils.log.AdminEmailHandler',\n            'filters': ['require_admin_enabled']\n        },\n        'null': {\n            'class': 'logging.NullHandler',\n        },\n    },\n    'loggers': {\n        '': {\n            'handlers': ['file', 'console'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'django.request': {\n            'handlers': ['file', 'console', 'mail_admins'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'pretix.security.csp': {\n            'handlers': ['csp_file'],\n            'level': loglevel,\n            'propagate': False,\n        },\n        'django.security': {\n            'handlers': ['file', 'console', 'mail_admins'],\n            'level': loglevel,\n            'propagate': True,\n        },\n        'django.security.DisallowedHost': {\n            'handlers': ['null'],\n            'propagate': False,\n        },\n        'django.db.backends': {\n            'handlers': ['file', 'console'],\n            'level': 'INFO',  # Do not output all the queries\n            'propagate': False,\n        },\n        'asyncio': {\n            'handlers': ['file', 'console'],\n            'level': 'WARNING',\n        },\n    },\n}\n\nSENTRY_ENABLED = False\nif config.has_option('sentry', 'dsn') and not any(c in sys.argv for c in ('shell', 'shell_scoped', 'shell_plus')):\n    import sentry_sdk\n    from sentry_sdk.integrations.celery import CeleryIntegration\n    from sentry_sdk.integrations.logging import (\n        LoggingIntegration, ignore_logger,\n    )\n\n    from .sentry import PretixSentryIntegration, setup_custom_filters\n\n    SENTRY_TOKEN = config.get('sentry', 'traces_sample_token', fallback='')\n\n    def traces_sampler(sampling_context):\n        qs = sampling_context.get('wsgi_environ', {}).get('QUERY_STRING', '')\n        if SENTRY_TOKEN and SENTRY_TOKEN in qs:\n            return 1.0\n        return config.getfloat('sentry', 'traces_sample_rate', fallback=0.0)\n\n    SENTRY_ENABLED = True\n    sentry_sdk.init(\n        dsn=config.get('sentry', 'dsn'),\n        integrations=[\n            PretixSentryIntegration(),\n            CeleryIntegration(),\n            LoggingIntegration(\n                level=logging.INFO,\n                event_level=logging.CRITICAL\n            )\n        ],\n        traces_sampler=traces_sampler,\n        environment=urlparse(SITE_URL).netloc,\n        release=__version__,\n        send_default_pii=False,\n        propagate_traces=False,  # see https://github.com/getsentry/sentry-python/issues/1717\n    )\n    ignore_logger('pretix.base.tasks')\n    ignore_logger('django.security.DisallowedHost')\n    setup_custom_filters()\n\nCELERY_TASK_SERIALIZER = 'json'\nCELERY_RESULT_SERIALIZER = 'json'\nCELERY_TASK_DEFAULT_QUEUE = 'default'\nCELERY_TASK_QUEUES = (\n    Queue('default', routing_key='default.#'),\n    Queue('checkout', routing_key='checkout.#'),\n    Queue('mail', routing_key='mail.#'),\n    Queue('background', routing_key='background.#'),\n    Queue('notifications', routing_key='notifications.#'),\n)\nCELERY_TASK_ROUTES = ([\n    ('pretix.base.services.cart.*', {'queue': 'checkout'}),\n    ('pretix.base.services.export.scheduled_organizer_export', {'queue': 'background'}),\n    ('pretix.base.services.export.scheduled_event_export', {'queue': 'background'}),\n    ('pretix.base.services.orders.*', {'queue': 'checkout'}),\n    ('pretix.base.services.mail.*', {'queue': 'mail'}),\n    ('pretix.base.services.update_check.*', {'queue': 'background'}),\n    ('pretix.base.services.quotas.*', {'queue': 'background'}),\n    ('pretix.base.services.waitinglist.*', {'queue': 'background'}),\n    ('pretix.base.services.notifications.*', {'queue': 'notifications'}),\n    ('pretix.api.webhooks.*', {'queue': 'notifications'}),\n    ('pretix.presale.style.*', {'queue': 'background'}),\n    ('pretix.plugins.banktransfer.*', {'queue': 'background'}),\n],)\n\nBOOTSTRAP3 = {\n    'success_css_class': '',\n    'field_renderers': {\n        'default': 'pretix.base.forms.renderers.FieldRenderer',\n        'inline': 'pretix.base.forms.renderers.InlineFieldRenderer',\n        'control': 'pretix.control.forms.renderers.ControlFieldRenderer',\n        'bulkedit': 'pretix.control.forms.renderers.BulkEditFieldRenderer',\n        'bulkedit_inline': 'pretix.control.forms.renderers.InlineBulkEditFieldRenderer',\n        'checkout': 'pretix.presale.forms.renderers.CheckoutFieldRenderer',\n    },\n}\n\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\nOAUTH2_PROVIDER_APPLICATION_MODEL = 'pretixapi.OAuthApplication'\nOAUTH2_PROVIDER_GRANT_MODEL = 'pretixapi.OAuthGrant'\nOAUTH2_PROVIDER_ACCESS_TOKEN_MODEL = 'pretixapi.OAuthAccessToken'\nOAUTH2_PROVIDER_ID_TOKEN_MODEL = 'pretixapi.OAuthIDToken'\nOAUTH2_PROVIDER_REFRESH_TOKEN_MODEL = 'pretixapi.OAuthRefreshToken'\nOAUTH2_PROVIDER = {\n    'SCOPES': {\n        'profile': _('User profile only'),\n        'read': _('Read access'),\n        'write': _('Write access'),\n    },\n    'OAUTH2_VALIDATOR_CLASS': 'pretix.api.oauth.Validator',\n    'ALLOWED_REDIRECT_URI_SCHEMES': ['https'] if not DEBUG else ['http', 'https'],\n    'ACCESS_TOKEN_EXPIRE_SECONDS': 3600 * 24,\n    'ROTATE_REFRESH_TOKEN': False,\n    'PKCE_REQUIRED': False,\n    'OIDC_RESPONSE_TYPES_SUPPORTED': [\"code\"],  # We don't support proper OIDC for now\n}\n\nCOUNTRIES_OVERRIDE = {\n    'XK': _('Kosovo'),\n}\n\nDATA_UPLOAD_MAX_NUMBER_FIELDS = 25000\nDATA_UPLOAD_MAX_MEMORY_SIZE = 10 * 1024 * 1024  # 10 MB\n\n# File sizes are in MiB\nFILE_UPLOAD_MAX_SIZE_IMAGE = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_image\", fallback=10)\nFILE_UPLOAD_MAX_SIZE_FAVICON = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_favicon\", fallback=1)\nFILE_UPLOAD_MAX_SIZE_EMAIL_ATTACHMENT = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_email_attachment\", fallback=5)\nFILE_UPLOAD_MAX_SIZE_EMAIL_AUTO_ATTACHMENT = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_email_auto_attachment\", fallback=1)\nFILE_UPLOAD_MAX_SIZE_OTHER = 1024 * 1024 * config.getint(\"pretix_file_upload\", \"max_size_other\", fallback=10)\n\n# Allowed file extensions for various places plus matching Pillow formats.\n# Never allow EPS, it is full of dangerous bugs.\nFILE_UPLOAD_EXTENSIONS_IMAGE = (\".png\", \".jpg\", \".gif\", \".jpeg\")\nPILLOW_FORMATS_IMAGE = ('PNG', 'GIF', 'JPEG')\n\nFILE_UPLOAD_EXTENSIONS_FAVICON = (\".ico\", \".png\", \"jpg\", \".gif\", \".jpeg\")\n\nFILE_UPLOAD_EXTENSIONS_QUESTION_IMAGE = (\".png\", \"jpg\", \".gif\", \".jpeg\", \".bmp\", \".tif\", \".tiff\", \".jfif\")\nPILLOW_FORMATS_QUESTIONS_IMAGE = ('PNG', 'GIF', 'JPEG', 'BMP', 'TIFF')\n\nFILE_UPLOAD_EXTENSIONS_EMAIL_ATTACHMENT = (\n    \".png\", \".jpg\", \".gif\", \".jpeg\", \".pdf\", \".txt\", \".docx\", \".gif\", \".svg\",\n    \".pptx\", \".ppt\", \".doc\", \".xlsx\", \".xls\", \".jfif\", \".heic\", \".heif\", \".pages\",\n    \".bmp\", \".tif\", \".tiff\"\n)\nFILE_UPLOAD_EXTENSIONS_OTHER = FILE_UPLOAD_EXTENSIONS_EMAIL_ATTACHMENT\n\n\nDEFAULT_AUTO_FIELD = 'django.db.models.AutoField'  # sadly. we would prefer BigInt, and should use it for all new models but the migration will be hard\n"], "filenames": ["src/pretix/api/views/order.py", "src/pretix/base/forms/questions.py", "src/pretix/base/models/orders.py", "src/pretix/base/pdf.py", "src/pretix/base/settings.py", "src/pretix/control/forms/__init__.py", "src/pretix/control/forms/organizer.py", "src/pretix/helpers/images.py", "src/pretix/helpers/monkeypatching.py", "src/pretix/helpers/reportlab.py", "src/pretix/helpers/thumb.py", "src/pretix/plugins/sendmail/forms.py", "src/pretix/settings.py"], "buggy_code_start_loc": [28, 503, 1249, 524, 2796, 130, 423, 24, 22, 22, 25, 79, 735], "buggy_code_end_loc": [1195, 834, 1250, 525, 2901, 131, 434, 55, 56, 46, 169, 84, 735], "fixing_code_start_loc": [29, 503, 1249, 524, 2796, 130, 423, 25, 23, 23, 26, 79, 736], "fixing_code_end_loc": [1196, 830, 1250, 525, 2901, 131, 434, 56, 73, 51, 170, 80, 754], "type": "NVD-CWE-noinfo", "message": "pretix before 2023.7.2 allows Pillow to parse EPS files.", "other": {"cve": {"id": "CVE-2023-44464", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-29T05:15:46.757", "lastModified": "2023-10-12T02:47:15.840", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "pretix before 2023.7.2 allows Pillow to parse EPS files."}, {"lang": "es", "value": "pretix antes de 2023.7.2 permite a Pillow analizar archivos EPS."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rami:pretix:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.20.4", "matchCriteriaId": "D3ACC75C-F588-4750-AD6B-0B417191D6BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rami:pretix:*:*:*:*:*:*:*:*", "versionStartIncluding": "2023.6.0", "versionEndExcluding": "2023.6.3", "matchCriteriaId": "449BC544-C630-4258-9B82-025C32230953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:rami:pretix:*:*:*:*:*:*:*:*", "versionStartIncluding": "2023.7.0", "versionEndExcluding": "2023.7.2", "matchCriteriaId": "35C3E175-B498-444E-8919-6F643B036BF5"}]}]}], "references": [{"url": "https://github.com/pretix/pretix/commit/8583bfb7d97263e9e923ad5d7f123ca1cadc8f2e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/pretix/pretix/compare/v2023.7.1...v2023.7.2", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/pretix/pretix/tags", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://pretix.eu/about/de/blog/20230912-release-2023-7-2/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://pretix.eu/about/en/ticketing", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/pretix/pretix/commit/8583bfb7d97263e9e923ad5d7f123ca1cadc8f2e"}}