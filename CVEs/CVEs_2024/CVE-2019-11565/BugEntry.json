{"buggy_code": ["<?php\n\nnamespace mnelson4\\RestApiDetector;\nuse WP_Error;\n\n/**\n * Class RestApiDetector\n *\n * Finds the REST API base URL for the site requested. Works with both self-hosted sites and WordPress.com sites.\n *\n *\n * @package     Event Espresso\n * @author         Mike Nelson\n * @since         $VID:$\n *\n */\nclass RestApiDetector\n{\n    protected $site;\n    protected $name;\n    protected $description;\n    protected $rest_api_url;\n    protected $local;\n    protected $initialized = false;\n\n    /**\n     * RestApiDetector constructor.\n     * @param $site\n     * @throws RestApiDetectorError\n     */\n    public function __construct($site)\n    {\n        // If the REST API Proxy Plugin isn't active, always use the current site.\n        if(! PMB_REST_PROXY_EXISTS){\n            $site = '';\n        }\n        $this->setSite($site);\n        $this->getSiteInfo();\n    }\n\n    /**\n     * Gets the site name and URL (works if they provide the \"site\" query param too,\n     * being the URL, including schema, of a self-hosted or WordPress.com site)\n     * @since $VID:$\n     * @throws RestApiDetectorError\n     */\n    public function getSiteInfo()\n    {\n        // check for a site request param\n        if(empty($this->getSite())){\n            $this->setName(get_bloginfo('name'));\n            $this->setDescription(get_bloginfo('description'));\n            $this->setRestApiUrl(get_rest_url());\n            $this->setSite(get_bloginfo('url'));\n            $this->setLocal(true);\n            return;\n        }\n        // If they forgot to add http(s), add it for them.\n        if(strpos($this->getSite(), 'http://') === false && strpos($this->getSite(), 'https://') === false) {\n            $this->setSite( 'http://' . $this->getSite());\n        }\n        // if there is one, check if it exists in wordpress.com, eg \"retirementreflections.com\"\n        $site = trailingslashit(sanitize_text_field($this->getSite()));\n\n\n        // Let's see if it's self-hosted...\n        $data = $this->getSelfHostedSiteInfo($site);\n//        if($data === false){\n//            // Alright, there was no link to the REST API index. But maybe it's a WordPress.com site...\n//            $data = $this->guessSelfHostedSiteInfo($site);\n//        }\n        if($data === false){\n            // Alright, there was no link to the REST API index. But maybe it's a WordPress.com site...\n            $data = $this->getWordPressComSiteInfo($site);\n        }\n\n        return $data;\n    }\n\n    /**\n     * Tries to get the site's name, description, and URL, assuming it's self-hosted.\n     * Returns a true on success, false if the site works but wasn't a self-hosted WordPress site, or\n     * throws an exception if the site is self-hosted WordPress but had an error.\n     * @since $VID:$\n     * @param $site\n     * @return bool false if the site exists but it's not a self-hosted WordPress site.\n     * @throws RestApiDetectorError\n     */\n    protected function getSelfHostedSiteInfo($site){\n        $response = $this->sendHttpGetRequest($site);\n        if (is_wp_error($response)) {\n            throw new RestApiDetectorError($response);\n        }\n        $response_body = wp_remote_retrieve_body($response);\n        $matches = array();\n        if( ! preg_match(\n            //looking for somethign like \"<link rel='https://api.w.org/' href='http://wpcowichan.org/wp-json/' />\"\n                '<link rel=\\'https\\:\\/\\/api\\.w\\.org\\/\\' href=\\'(.*)\\' \\/>',\n                $response_body,\n                $matches\n            )\n            ||  count($matches) !== 2) {\n            // The site exists, but it's not self-hosted.\n            return false;\n        }\n        // grab from site index\n        $success = $this->fetchWpJsonRootInfo($matches[1]);\n        if($success){\n            $this->setRestApiUrl($matches[1] . 'wp/v2/');\n        }\n        return $success;\n    }\n\n    protected function fetchWpJsonRootInfo($wp_api_url) {\n        $response = $this->sendHttpGetRequest($wp_api_url);\n        if (is_wp_error($response)) {\n            // The WP JSON index existed, but didn't work. Let's tell the user.\n            throw new RestApiDetectorError($response);\n        }\n        $response_body = wp_remote_retrieve_body($response);\n        $response_data = json_decode($response_body,true);\n        if (! is_array($response_data)) {\n            throw new RestApiDetectorError(\n                new WP_Error('no_json', __('The WordPress site has an error in its REST API data.', 'print-my-blog'))\n            );\n        }\n        if (isset($response_data['code'], $response_data['message'])) {\n            throw new RestApiDetectorError(\n                new WP_Error($response_data['code'], $response_data['message'])\n            );\n        }\n        if(isset($response_data['name'], $response_data['description'])){\n            $this->setName($response_data['name']);\n            $this->setDescription($response_data['description']);\n            $this->setLocal(false);\n            return true;\n        }\n        // so we didn't get an error or a proper response, but it's JSON? That's really weird.\n        throw new RestApiDetectorError(\n            new WP_Error('unknown_response', __('The WordPress site responded with an unexpected response.', 'print-my-blog'))\n        );\n    }\n\n    /**\n     * We didn't see any indication the website has the WP API enabled. Just take a guess that\n     * /wp-json is the REST API base url. Maybe we'll get lucky.\n     * @since $VID:$\n     * @param $site\n     * @return bool\n     * @throws RestApiDetectorError\n     */\n    protected function guessSelfHostedSiteInfo($site){\n        // add /wp-json as a guess\n        return $this->fetchWpJsonRootInfo($site . 'wp-json');\n        // and if it responds with valid JSON, it's ok\n    }\n\n    /**\n     * Tries to get the site name, description and URL from a site on WordPress.com.\n     * Returns true success, or throws a RestApiDetectorError. If the site doesn't appear to be on WordPress.com\n     * also has an error.\n     * @since $VID:$\n     * @param $site\n     * @return bool\n     * @throws RestApiDetectorError\n     */\n    protected function getWordPressComSiteInfo($site){\n        $domain = str_replace(array('http://','https://'),'',$site);\n\n        $success =  $this->fetchWpJsonRootInfo(\n            'https://public-api.wordpress.com/rest/v1.1/sites/' . $domain\n        );\n        if($success){\n            $this->setRestApiUrl('https://public-api.wordpress.com/wp/v2/sites/' . $domain);\n        }\n        return $success;\n    }\n\n    /**\n     * @since $VID:$\n     * @param $url\n     * @return array|WP_Error\n     */\n    protected function sendHttpGetRequest($url)\n    {\n        return wp_remote_get(\n            $url,\n            [\n                'timeout' => 30,\n                'sslverify' => false,\n                'user-agent' => 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0'\n            ]\n        );\n    }\n\n    /**\n     * @return string\n     */\n    public function getSite()\n    {\n        return $this->site;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param mixed $name\n     */\n    protected function setName($name)\n    {\n        $this->name = $name;\n    }\n\n    /**\n     * @param mixed $site\n     */\n    protected function setSite($site)\n    {\n        $this->site = $site;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getDescription()\n    {\n        return $this->description;\n    }\n\n    /**\n     * @param mixed $description\n     */\n    protected function setDescription($description)\n    {\n        $this->description = $description;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getRestApiUrl()\n    {\n        return $this->rest_api_url;\n    }\n\n    /**\n     * @param mixed $rest_api_url\n     */\n    protected function setRestApiUrl($rest_api_url)\n    {\n        $this->rest_api_url = $rest_api_url;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function isLocal()\n    {\n        return $this->local;\n    }\n\n    /**\n     * @param mixed $local\n     */\n    protected function setLocal($local)\n    {\n        $this->local = $local;\n    }\n\n    /**\n     * @return bool\n     */\n    protected function isInitialized()\n    {\n        return $this->initialized;\n    }\n\n    /**\n     * @param bool $initialized\n     */\n    protected function setInitialized(bool $initialized)\n    {\n        $this->initialized = $initialized;\n    }\n}\n// End of file RestApiDetector.php\n// Location: mnelson4/RestApiDetector.php\n"], "fixing_code": ["<?php\n\nnamespace mnelson4\\RestApiDetector;\nuse WP_Error;\n\n/**\n * Class RestApiDetector\n *\n * Finds the REST API base URL for the site requested. Works with both self-hosted sites and WordPress.com sites.\n *\n *\n * @package     Event Espresso\n * @author         Mike Nelson\n * @since         $VID:$\n *\n */\nclass RestApiDetector\n{\n    protected $site;\n    protected $name;\n    protected $description;\n    protected $rest_api_url;\n    protected $local;\n    protected $initialized = false;\n\n    /**\n     * RestApiDetector constructor.\n     * @param $site\n     * @throws RestApiDetectorError\n     */\n    public function __construct($site)\n    {\n        $this->setSite($this->sanitizeSite($site));\n        $this->getSiteInfo();\n    }\n\n    /**\n     * Gets the site name and URL (works if they provide the \"site\" query param too,\n     * being the URL, including schema, of a self-hosted or WordPress.com site)\n     * @since $VID:$\n     * @throws RestApiDetectorError\n     */\n    public function getSiteInfo()\n    {\n        // check for a site request param\n        if(empty($this->getSite())){\n            $this->setName(get_bloginfo('name'));\n            $this->setDescription(get_bloginfo('description'));\n            $this->setRestApiUrl(get_rest_url());\n            $this->setSite(get_bloginfo('url'));\n            $this->setLocal(true);\n            return;\n        }\n        $site = $this->getSite();\n        // Let's see if it's self-hosted...\n        $data = $this->getSelfHostedSiteInfo($site);\n//        if($data === false){\n//            // Alright, there was no link to the REST API index. But maybe it's a WordPress.com site...\n//            $data = $this->guessSelfHostedSiteInfo($site);\n//        }\n        if($data === false){\n            // Alright, there was no link to the REST API index. But maybe it's a WordPress.com site...\n            $data = $this->getWordPressComSiteInfo($site);\n        }\n\n        return $data;\n    }\n\n    /**\n     * Avoid SSRF by sanitizing the site received.\n     * @since $VID:$\n     * @param $site\n     * @return mixed|string\n     */\n    protected function sanitizeSite($site)\n    {\n        // If the REST API Proxy Plugin isn't active, always use the current site.\n        if(! PMB_REST_PROXY_EXISTS){\n            return '';\n        }\n        // If they forgot to add http(s), add it for them.\n        if(strpos($site, 'http://') === false && strpos($site, 'https://') === false) {\n            $site = 'http://' . $site;\n        }\n        // if there is one, check if it exists in wordpress.com, eg \"retirementreflections.com\"\n\n        $file_info = pathinfo($site);\n        if( isset($file_info['extension'])){\n            $site = str_replace($file_info['filename'] . \".\" . $file_info['extension'], \"\", $site);\n        }\n        $site = trailingslashit(sanitize_text_field($site));\n        return $site;\n    }\n\n    /**\n     * Tries to get the site's name, description, and URL, assuming it's self-hosted.\n     * Returns a true on success, false if the site works but wasn't a self-hosted WordPress site, or\n     * throws an exception if the site is self-hosted WordPress but had an error.\n     * @since $VID:$\n     * @param $site\n     * @return bool false if the site exists but it's not a self-hosted WordPress site.\n     * @throws RestApiDetectorError\n     */\n    protected function getSelfHostedSiteInfo($site){\n        $response = $this->sendHttpGetRequest($site);\n        if (is_wp_error($response)) {\n            throw new RestApiDetectorError($response);\n        }\n        $response_body = wp_remote_retrieve_body($response);\n        $matches = array();\n        if( ! preg_match(\n            //looking for somethign like \"<link rel='https://api.w.org/' href='http://wpcowichan.org/wp-json/' />\"\n                '<link rel=\\'https\\:\\/\\/api\\.w\\.org\\/\\' href=\\'(.*)\\' \\/>',\n                $response_body,\n                $matches\n            )\n            ||  count($matches) !== 2) {\n            // The site exists, but it's not self-hosted.\n            return false;\n        }\n        // grab from site index\n        $success = $this->fetchWpJsonRootInfo($matches[1]);\n        if($success){\n            $this->setRestApiUrl($matches[1] . 'wp/v2/');\n        }\n        return $success;\n    }\n\n    protected function fetchWpJsonRootInfo($wp_api_url) {\n        $response = $this->sendHttpGetRequest($wp_api_url);\n        if (is_wp_error($response)) {\n            // The WP JSON index existed, but didn't work. Let's tell the user.\n            throw new RestApiDetectorError($response);\n        }\n        $response_body = wp_remote_retrieve_body($response);\n        $response_data = json_decode($response_body,true);\n        if (! is_array($response_data)) {\n            throw new RestApiDetectorError(\n                new WP_Error('no_json', __('The WordPress site has an error in its REST API data.', 'print-my-blog'))\n            );\n        }\n        if (isset($response_data['code'], $response_data['message'])) {\n            throw new RestApiDetectorError(\n                new WP_Error($response_data['code'], $response_data['message'])\n            );\n        }\n        if(isset($response_data['name'], $response_data['description'])){\n            $this->setName($response_data['name']);\n            $this->setDescription($response_data['description']);\n            $this->setLocal(false);\n            return true;\n        }\n        // so we didn't get an error or a proper response, but it's JSON? That's really weird.\n        throw new RestApiDetectorError(\n            new WP_Error('unknown_response', __('The WordPress site responded with an unexpected response.', 'print-my-blog'))\n        );\n    }\n\n    /**\n     * We didn't see any indication the website has the WP API enabled. Just take a guess that\n     * /wp-json is the REST API base url. Maybe we'll get lucky.\n     * @since $VID:$\n     * @param $site\n     * @return bool\n     * @throws RestApiDetectorError\n     */\n    protected function guessSelfHostedSiteInfo($site){\n        // add /wp-json as a guess\n        return $this->fetchWpJsonRootInfo($site . 'wp-json');\n        // and if it responds with valid JSON, it's ok\n    }\n\n    /**\n     * Tries to get the site name, description and URL from a site on WordPress.com.\n     * Returns true success, or throws a RestApiDetectorError. If the site doesn't appear to be on WordPress.com\n     * also has an error.\n     * @since $VID:$\n     * @param $site\n     * @return bool\n     * @throws RestApiDetectorError\n     */\n    protected function getWordPressComSiteInfo($site){\n        $domain = str_replace(array('http://','https://'),'',$site);\n\n        $success =  $this->fetchWpJsonRootInfo(\n            'https://public-api.wordpress.com/rest/v1.1/sites/' . $domain\n        );\n        if($success){\n            $this->setRestApiUrl('https://public-api.wordpress.com/wp/v2/sites/' . $domain);\n        }\n        return $success;\n    }\n\n    /**\n     * @since $VID:$\n     * @param $url\n     * @return array|WP_Error\n     */\n    protected function sendHttpGetRequest($url)\n    {\n        return wp_remote_get(\n            $url,\n            [\n                'timeout' => 30,\n                'sslverify' => false,\n                'user-agent' => 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0'\n            ]\n        );\n    }\n\n    /**\n     * @return string\n     */\n    public function getSite()\n    {\n        return $this->site;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getName()\n    {\n        return $this->name;\n    }\n\n    /**\n     * @param mixed $name\n     */\n    protected function setName($name)\n    {\n        $this->name = $name;\n    }\n\n    /**\n     * @param mixed $site\n     */\n    protected function setSite($site)\n    {\n        $this->site = $site;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getDescription()\n    {\n        return $this->description;\n    }\n\n    /**\n     * @param mixed $description\n     */\n    protected function setDescription($description)\n    {\n        $this->description = $description;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getRestApiUrl()\n    {\n        return $this->rest_api_url;\n    }\n\n    /**\n     * @param mixed $rest_api_url\n     */\n    protected function setRestApiUrl($rest_api_url)\n    {\n        $this->rest_api_url = $rest_api_url;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function isLocal()\n    {\n        return $this->local;\n    }\n\n    /**\n     * @param mixed $local\n     */\n    protected function setLocal($local)\n    {\n        $this->local = $local;\n    }\n\n    /**\n     * @return bool\n     */\n    protected function isInitialized()\n    {\n        return $this->initialized;\n    }\n\n    /**\n     * @param bool $initialized\n     */\n    protected function setInitialized(bool $initialized)\n    {\n        $this->initialized = $initialized;\n    }\n}\n// End of file RestApiDetector.php\n// Location: mnelson4/RestApiDetector.php\n"], "filenames": ["includes/vendor/mnelson4/RestApiDetector/RestApiDetector.php"], "buggy_code_start_loc": [33], "buggy_code_end_loc": [77], "fixing_code_start_loc": [33], "fixing_code_end_loc": [93], "type": "CWE-918", "message": "Server Side Request Forgery (SSRF) exists in the Print My Blog plugin before 1.6.7 for WordPress via the site parameter.", "other": {"cve": {"id": "CVE-2019-11565", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-27T14:29:00.227", "lastModified": "2019-05-01T15:47:54.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server Side Request Forgery (SSRF) exists in the Print My Blog plugin before 1.6.7 for WordPress via the site parameter."}, {"lang": "es", "value": "El plugin Print My Blog, versiones anteriores a 1.6.7, para WordPress, puede sufrir un ataque Server Side Request Forgery (SSRF)  a trav\u00e9s del par\u00e1metro site."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:print_my_blog_project:print_my_blog:*:*:*:*:*:wordpress:*:*", "versionEndExcluding": "1.6.7", "matchCriteriaId": "D084FBF6-62E6-4987-B88D-AC98C45B8202"}]}]}], "references": [{"url": "http://dumpco.re/bugs/wp-plugin-print-my-blog-ssrf", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mnelson4/printmyblog/commit/8584a2839a541eb29fca64252e388c827af3ec21", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://plugins.trac.wordpress.org/changeset?old_path=%2Fprint-my-blog%2Ftrunk&old=2075667&new_path=%2Fprint-my-blog%2Ftrunk&new=2075667", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://wordpress.org/plugins/print-my-blog/#developers", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9263", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mnelson4/printmyblog/commit/8584a2839a541eb29fca64252e388c827af3ec21"}}