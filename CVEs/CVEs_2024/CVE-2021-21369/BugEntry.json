{"buggy_code": ["/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.authentication;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\n\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport io.vertx.core.Handler;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.User;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class AuthenticationUtils {\n  private static final Logger LOG = LogManager.getLogger();\n\n  @VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> authenticationService,\n      final Optional<User> optionalUser,\n      final JsonRpcMethod jsonRpcMethod) {\n\n    AtomicBoolean foundMatchingPermission = new AtomicBoolean();\n\n    if (authenticationService.isPresent()) {\n      if (optionalUser.isPresent()) {\n        User user = optionalUser.get();\n        for (String perm : jsonRpcMethod.getPermissions()) {\n          user.isAuthorized(\n              perm,\n              (authed) -> {\n                if (authed.result()) {\n                  LOG.trace(\n                      \"user {} authorized : {} via permission {}\",\n                      user,\n                      jsonRpcMethod.getName(),\n                      perm);\n                  foundMatchingPermission.set(true);\n                }\n              });\n        }\n      }\n    } else {\n      // no auth provider configured thus anything is permitted\n      foundMatchingPermission.set(true);\n    }\n\n    if (!foundMatchingPermission.get()) {\n      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());\n    }\n    return foundMatchingPermission.get();\n  }\n\n  public static void getUser(\n      final Optional<AuthenticationService> authenticationService,\n      final String token,\n      final Handler<Optional<User>> handler) {\n    try {\n      if (authenticationService.isEmpty()) {\n        handler.handle(Optional.empty());\n      } else {\n        authenticationService\n            .get()\n            .getJwtAuthProvider()\n            .authenticate(\n                new JsonObject().put(\"jwt\", token),\n                (r) -> {\n                  if (r.succeeded()) {\n                    final Optional<User> user = Optional.ofNullable(r.result());\n                    validateExpiryExists(user);\n                    handler.handle(user);\n                  } else {\n                    LOG.debug(\"Invalid JWT token\", r.cause());\n                    handler.handle(Optional.empty());\n                  }\n                });\n      }\n    } catch (Exception e) {\n      handler.handle(Optional.empty());\n    }\n  }\n\n  private static void validateExpiryExists(final Optional<User> user) {\n    if (!user.map(User::principal).map(p -> p.containsKey(\"exp\")).orElse(false)) {\n      throw new IllegalStateException(\"Invalid JWT doesn't have expiry\");\n    }\n  }\n\n  public static String getJwtTokenFromAuthorizationHeaderValue(final String value) {\n    if (value != null) {\n      final String bearerSchemaName = \"Bearer \";\n      if (value.startsWith(bearerSchemaName)) {\n        return value.substring(bearerSchemaName.length());\n      }\n    }\n    return null;\n  }\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic interface JsonRpcMethod {\n\n  /**\n   * Standardised JSON-RPC method name.\n   *\n   * @return identification of the JSON-RPC method.\n   */\n  String getName();\n\n  /**\n   * Applies the method to given request.\n   *\n   * @param request input data for the JSON-RPC method.\n   * @return output from applying the JSON-RPC method to the input.\n   */\n  JsonRpcResponse response(JsonRpcRequestContext request);\n\n  /**\n   * The list of Permissions that correspond to this JSON-RPC method. e.g. [net/*, net/listening]\n   *\n   * @return list of permissions that match this method.\n   */\n  default List<String> getPermissions() {\n    List<String> permissions = new ArrayList<>();\n    permissions.add(\"*:*\");\n    permissions.add(this.getName().replace('_', ':'));\n    permissions.add(this.getName().substring(0, this.getName().indexOf('_')) + \":*\");\n    return permissions;\n  };\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.concurrent.TimeUnit.MINUTES;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.util.Lists.list;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\n\nimport org.hyperledger.besu.config.StubGenesisConfigOptions;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.authentication.AuthenticationUtils;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.health.HealthService;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthAccounts;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthBlockNumber;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.NetVersion;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3ClientVersion;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3Sha3;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.methods.JsonRpcMethodsFactory;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketConfiguration;\nimport org.hyperledger.besu.ethereum.api.query.BlockchainQueries;\nimport org.hyperledger.besu.ethereum.blockcreation.EthHashMiningCoordinator;\nimport org.hyperledger.besu.ethereum.core.PrivacyParameters;\nimport org.hyperledger.besu.ethereum.core.Synchronizer;\nimport org.hyperledger.besu.ethereum.eth.EthProtocol;\nimport org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;\nimport org.hyperledger.besu.ethereum.mainnet.MainnetProtocolSchedule;\nimport org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;\nimport org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;\nimport org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\nimport org.hyperledger.besu.metrics.prometheus.MetricsConfiguration;\nimport org.hyperledger.besu.nat.NatService;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.file.Paths;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport com.google.common.base.Splitter;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.json.Json;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.jwt.JWTAuth;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.assertj.core.api.Assertions;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.StrictStubs.class)\npublic class JsonRpcHttpServiceLoginTest {\n  @ClassRule public static final TemporaryFolder folder = new TemporaryFolder();\n\n  private static final Vertx vertx = Vertx.vertx();\n\n  protected static Map<String, JsonRpcMethod> rpcMethods;\n  protected static JsonRpcHttpService service;\n  protected static OkHttpClient client;\n  protected static String baseUrl;\n  protected static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\n  protected static final String CLIENT_VERSION = \"TestClientVersion/0.1.0\";\n  protected static final BigInteger CHAIN_ID = BigInteger.valueOf(123);\n  protected static P2PNetwork peerDiscoveryMock;\n  protected static BlockchainQueries blockchainQueries;\n  protected static Synchronizer synchronizer;\n  protected static final Collection<RpcApi> JSON_RPC_APIS =\n      Arrays.asList(RpcApis.ETH, RpcApis.NET, RpcApis.WEB3, RpcApis.ADMIN);\n  protected static JWTAuth jwtAuth;\n  protected static String authPermissionsConfigFilePath = \"JsonRpcHttpService/auth.toml\";\n  protected final JsonRpcTestHelper testHelper = new JsonRpcTestHelper();\n  protected static final NatService natService = new NatService(Optional.empty());\n\n  @BeforeClass\n  public static void initServerAndClient() throws Exception {\n    peerDiscoveryMock = mock(P2PNetwork.class);\n    blockchainQueries = mock(BlockchainQueries.class);\n    synchronizer = mock(Synchronizer.class);\n\n    final Set<Capability> supportedCapabilities = new HashSet<>();\n    supportedCapabilities.add(EthProtocol.ETH62);\n    supportedCapabilities.add(EthProtocol.ETH63);\n\n    final StubGenesisConfigOptions genesisConfigOptions =\n        new StubGenesisConfigOptions().constantinopleBlock(0).chainId(CHAIN_ID);\n\n    rpcMethods =\n        spy(\n            new JsonRpcMethodsFactory()\n                .methods(\n                    CLIENT_VERSION,\n                    CHAIN_ID,\n                    genesisConfigOptions,\n                    peerDiscoveryMock,\n                    blockchainQueries,\n                    synchronizer,\n                    MainnetProtocolSchedule.fromConfig(genesisConfigOptions),\n                    mock(FilterManager.class),\n                    mock(TransactionPool.class),\n                    mock(EthHashMiningCoordinator.class),\n                    new NoOpMetricsSystem(),\n                    supportedCapabilities,\n                    Optional.empty(),\n                    Optional.empty(),\n                    JSON_RPC_APIS,\n                    mock(PrivacyParameters.class),\n                    mock(JsonRpcConfiguration.class),\n                    mock(WebSocketConfiguration.class),\n                    mock(MetricsConfiguration.class),\n                    natService,\n                    new HashMap<>()));\n    service = createJsonRpcHttpService();\n    jwtAuth = service.authenticationService.get().getJwtAuthProvider();\n    service.start().join();\n\n    // Build an OkHttp client.\n    client = new OkHttpClient();\n    baseUrl = service.url();\n  }\n\n  private static JsonRpcHttpService createJsonRpcHttpService() throws Exception {\n    final String authTomlPath =\n        Paths.get(ClassLoader.getSystemResource(authPermissionsConfigFilePath).toURI())\n            .toAbsolutePath()\n            .toString();\n\n    final JsonRpcConfiguration config = createJsonRpcConfig();\n    config.setAuthenticationEnabled(true);\n    config.setAuthenticationCredentialsFile(authTomlPath);\n\n    return new JsonRpcHttpService(\n        vertx,\n        folder.newFolder().toPath(),\n        config,\n        new NoOpMetricsSystem(),\n        natService,\n        rpcMethods,\n        HealthService.ALWAYS_HEALTHY,\n        HealthService.ALWAYS_HEALTHY);\n  }\n\n  private static JsonRpcConfiguration createJsonRpcConfig() {\n    final JsonRpcConfiguration config = JsonRpcConfiguration.createDefault();\n    config.setPort(0);\n    config.setHostsAllowlist(Collections.singletonList(\"*\"));\n    return config;\n  }\n\n  /** Tears down the HTTP server. */\n  @AfterClass\n  public static void shutdownServer() {\n    service.stop().join();\n  }\n\n  @Test\n  public void loginWithBadCredentials() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"badpass\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void loginWithGoodCredentials() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            user.isAuthorized(\n                \"noauths\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isFalse();\n                });\n          });\n    }\n  }\n\n  @Test\n  public void loginWithGoodCredentialsAndPermissions() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            user.isAuthorized(\n                \"noauths\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isFalse();\n                });\n            user.isAuthorized(\n                \"fakePermission\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isTrue();\n                });\n          });\n    }\n  }\n\n  @Test\n  public void loginDoesntPopulateJWTPayloadWithPassword()\n      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonObject jwtPayload = decodeJwtPayload(token);\n      final String jwtPayloadString = jwtPayload.encode();\n      assertThat(jwtPayloadString.contains(\"password\")).isFalse();\n      assertThat(jwtPayloadString.contains(\"pegasys\")).isFalse();\n    }\n  }\n\n  @Test\n  public void loginPopulatesJWTPayloadWithRequiredValues()\n      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonObject jwtPayload = decodeJwtPayload(token);\n      assertThat(jwtPayload.getString(\"username\")).isEqualTo(\"user\");\n      assertThat(jwtPayload.getJsonArray(\"permissions\"))\n          .isEqualTo(\n              new JsonArray(list(\"fakePermission\", \"eth:blockNumber\", \"eth:subscribe\", \"web3:*\")));\n      assertThat(jwtPayload.getString(\"privacyPublicKey\"))\n          .isEqualTo(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");\n      assertThat(jwtPayload.containsKey(\"iat\")).isTrue();\n      assertThat(jwtPayload.containsKey(\"exp\")).isTrue();\n      final long tokenExpiry = jwtPayload.getLong(\"exp\") - jwtPayload.getLong(\"iat\");\n      assertThat(tokenExpiry).isEqualTo(MINUTES.toSeconds(5));\n    }\n  }\n\n  private String login(final String username, final String password) throws IOException {\n    final RequestBody loginBody =\n        RequestBody.create(\n            JSON, \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\");\n    final Request loginRequest =\n        new Request.Builder().post(loginBody).url(baseUrl + \"/login\").build();\n    final String token;\n    try (final Response loginResp = client.newCall(loginRequest).execute()) {\n      assertThat(loginResp.code()).isEqualTo(200);\n      assertThat(loginResp.message()).isEqualTo(\"OK\");\n      assertThat(loginResp.body().contentType()).isNotNull();\n      assertThat(loginResp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(loginResp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = loginResp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n    }\n    return token;\n  }\n\n  @Test\n  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndPermissions() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonRpcMethod ethAccounts = new EthAccounts();\n      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));\n      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);\n      final JsonRpcMethod web3Sha3 = new Web3Sha3();\n      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            // single eth/blockNumber method permitted\n            Assertions.assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethBlockNumber))\n                .isTrue();\n            // eth/accounts not permitted\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethAccounts))\n                .isFalse();\n            // allowed by web3/*\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3ClientVersion))\n                .isTrue();\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3Sha3))\n                .isTrue();\n            // no net permissions\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), netVersion))\n                .isFalse();\n          });\n    }\n  }\n\n  @Test\n  public void checkPermissionsWithEmptyUser() {\n    final JsonRpcMethod ethAccounts = new EthAccounts();\n\n    assertThat(\n            AuthenticationUtils.isPermitted(\n                service.authenticationService, Optional.empty(), ethAccounts))\n        .isFalse();\n  }\n\n  @Test\n  public void web3ClientVersionUnsuccessfulBeforeLogin() throws Exception {\n    final String id = \"123\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body)).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void web3ClientVersionUnsuccessfulWithBadBearer() throws Exception {\n    final String id = \"123\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body, \"badtoken\")).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void web3ClientVersionSuccessfulAfterLogin() throws Exception {\n    final String token = login(\"user\", \"pegasys\");\n\n    final String id = \"123\";\n    final RequestBody web3ClientVersionBody =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response web3ClientVersionResp =\n        client.newCall(buildPostRequest(web3ClientVersionBody, token)).execute()) {\n      assertThat(web3ClientVersionResp.code()).isEqualTo(200);\n      // Check general format of result\n      final JsonObject json = new JsonObject(web3ClientVersionResp.body().string());\n      testHelper.assertValidJsonRpcResult(json, id);\n      // Check result\n      final String result = json.getString(\"result\");\n      assertThat(result).isEqualTo(\"TestClientVersion/0.1.0\");\n    }\n  }\n\n  @Test\n  public void ethSyncingUnauthorisedWithoutPermission() throws Exception {\n    final String token = login(\"user\", \"pegasys\");\n\n    final String id = \"007\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\" + Json.encode(id) + \",\\\"method\\\":\\\"eth_syncing\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body, token)).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  private Request buildPostRequest(final RequestBody body) {\n    return buildPostRequest(body, Optional.empty());\n  }\n\n  private Request buildPostRequest(final RequestBody body, final String token) {\n    return buildPostRequest(body, Optional.of(token));\n  }\n\n  private Request buildPostRequest(final RequestBody body, final Optional<String> token) {\n    final Request.Builder request = new Request.Builder().post(body).url(baseUrl);\n    token.ifPresent(t -> request.addHeader(\"Authorization\", \"Bearer \" + t));\n    return request.build();\n  }\n\n  private JsonObject decodeJwtPayload(final String token) {\n    final List<String> tokenParts = Splitter.on('.').splitToList(token);\n    final String payload = tokenParts.get(1);\n    return new JsonObject(new String(Base64.getUrlDecoder().decode(payload), UTF_8));\n  }\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\nimport org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;\n\nimport java.util.List;\n\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class NetListeningTest {\n\n  private NetListening method;\n\n  @Mock private P2PNetwork p2PNetwork;\n\n  @Before\n  public void before() {\n    this.method = new NetListening(p2PNetwork);\n  }\n\n  @Test\n  public void shouldReturnTrueWhenNetworkIsListening() {\n    when(p2PNetwork.isListening()).thenReturn(true);\n\n    final JsonRpcRequestContext request = netListeningRequest();\n    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, true);\n\n    Assertions.assertThat(method.response(request))\n        .isEqualToComparingFieldByField(expectedResponse);\n  }\n\n  @Test\n  public void shouldReturnFalseWhenNetworkIsNotListening() {\n    when(p2PNetwork.isListening()).thenReturn(false);\n\n    final JsonRpcRequestContext request = netListeningRequest();\n    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, false);\n\n    Assertions.assertThat(method.response(request))\n        .isEqualToComparingFieldByField(expectedResponse);\n  }\n\n  @Test\n  public void getPermissions() {\n    List<String> permissions = method.getPermissions();\n    assertThat(permissions).containsExactlyInAnyOrder(\"net:*\", \"net:listening\", \"*:*\");\n  }\n\n  private JsonRpcRequestContext netListeningRequest() {\n    return new JsonRpcRequestContext(new JsonRpcRequest(\"2.0\", \"net_listening\", new Object[] {}));\n  }\n}\n", "[Users.user]\npassword = \"$2a$10$l3GA7K8g6rJ/Yv.YFSygCuI9byngpEzxgWS9qEg5emYDZomQW7fGC\"\npermissions = [\"fakePermission\",\"eth:blockNumber\",\"eth:subscribe\",\"web3:*\"]\nprivacyPublicKey = \"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\"\n"], "fixing_code": ["/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.authentication;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\n\nimport java.util.Optional;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport io.vertx.core.Handler;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.User;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class AuthenticationUtils {\n  private static final Logger LOG = LogManager.getLogger();\n\n  @VisibleForTesting\n  public static boolean isPermitted(\n      final Optional<AuthenticationService> authenticationService,\n      final Optional<User> optionalUser,\n      final JsonRpcMethod jsonRpcMethod) {\n\n    AtomicBoolean foundMatchingPermission = new AtomicBoolean();\n\n    if (authenticationService.isEmpty()) {\n      // no auth provider configured thus anything is permitted\n      return true;\n    }\n\n    if (optionalUser.isPresent()) {\n      User user = optionalUser.get();\n      for (String perm : jsonRpcMethod.getPermissions()) {\n        user.isAuthorized(\n            perm,\n            (authed) -> {\n              if (authed.result()) {\n                LOG.trace(\n                    \"user {} authorized : {} via permission {}\",\n                    user,\n                    jsonRpcMethod.getName(),\n                    perm);\n                foundMatchingPermission.set(true);\n              }\n            });\n        // exit if a matching permission was found, no need to keep checking\n        if (foundMatchingPermission.get()) {\n          return foundMatchingPermission.get();\n        }\n      }\n    }\n\n    if (!foundMatchingPermission.get()) {\n      LOG.trace(\"user NOT authorized : {}\", jsonRpcMethod.getName());\n    }\n    return foundMatchingPermission.get();\n  }\n\n  public static void getUser(\n      final Optional<AuthenticationService> authenticationService,\n      final String token,\n      final Handler<Optional<User>> handler) {\n    try {\n      if (authenticationService.isEmpty()) {\n        handler.handle(Optional.empty());\n      } else {\n        authenticationService\n            .get()\n            .getJwtAuthProvider()\n            .authenticate(\n                new JsonObject().put(\"jwt\", token),\n                (r) -> {\n                  if (r.succeeded()) {\n                    final Optional<User> user = Optional.ofNullable(r.result());\n                    validateExpiryExists(user);\n                    handler.handle(user);\n                  } else {\n                    LOG.debug(\"Invalid JWT token\", r.cause());\n                    handler.handle(Optional.empty());\n                  }\n                });\n      }\n    } catch (Exception e) {\n      handler.handle(Optional.empty());\n    }\n  }\n\n  private static void validateExpiryExists(final Optional<User> user) {\n    if (!user.map(User::principal).map(p -> p.containsKey(\"exp\")).orElse(false)) {\n      throw new IllegalStateException(\"Invalid JWT doesn't have expiry\");\n    }\n  }\n\n  public static String getJwtTokenFromAuthorizationHeaderValue(final String value) {\n    if (value != null) {\n      final String bearerSchemaName = \"Bearer \";\n      if (value.startsWith(bearerSchemaName)) {\n        return value.substring(bearerSchemaName.length());\n      }\n    }\n    return null;\n  }\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic interface JsonRpcMethod {\n\n  /**\n   * Standardized JSON-RPC method name.\n   *\n   * @return identification of the JSON-RPC method.\n   */\n  String getName();\n\n  /**\n   * Applies the method to given request.\n   *\n   * @param request input data for the JSON-RPC method.\n   * @return output from applying the JSON-RPC method to the input.\n   */\n  JsonRpcResponse response(JsonRpcRequestContext request);\n\n  /**\n   * The list of Permissions that correspond to this JSON-RPC method.\n   *\n   * <p>e.g. [*:*, net:*, net:listening]\n   *\n   * @return list of permissions that match this method.\n   */\n  default List<String> getPermissions() {\n    List<String> permissions = new ArrayList<>();\n    permissions.add(\"*:*\");\n    permissions.add(this.getName().substring(0, this.getName().indexOf('_')) + \":*\");\n    permissions.add(this.getName().replace('_', ':'));\n    return permissions;\n  };\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.concurrent.TimeUnit.MINUTES;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.util.Lists.list;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\n\nimport org.hyperledger.besu.config.StubGenesisConfigOptions;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.authentication.AuthenticationUtils;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.health.HealthService;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthAccounts;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.EthBlockNumber;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.NetVersion;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3ClientVersion;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.Web3Sha3;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.methods.JsonRpcMethodsFactory;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.websocket.WebSocketConfiguration;\nimport org.hyperledger.besu.ethereum.api.query.BlockchainQueries;\nimport org.hyperledger.besu.ethereum.blockcreation.EthHashMiningCoordinator;\nimport org.hyperledger.besu.ethereum.core.PrivacyParameters;\nimport org.hyperledger.besu.ethereum.core.Synchronizer;\nimport org.hyperledger.besu.ethereum.eth.EthProtocol;\nimport org.hyperledger.besu.ethereum.eth.transactions.TransactionPool;\nimport org.hyperledger.besu.ethereum.mainnet.MainnetProtocolSchedule;\nimport org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;\nimport org.hyperledger.besu.ethereum.p2p.rlpx.wire.Capability;\nimport org.hyperledger.besu.metrics.noop.NoOpMetricsSystem;\nimport org.hyperledger.besu.metrics.prometheus.MetricsConfiguration;\nimport org.hyperledger.besu.nat.NatService;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.file.Paths;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.CertificateException;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport com.google.common.base.Splitter;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.json.Json;\nimport io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\nimport io.vertx.ext.auth.User;\nimport io.vertx.ext.auth.jwt.JWTAuth;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\nimport org.assertj.core.api.Assertions;\nimport org.junit.AfterClass;\nimport org.junit.BeforeClass;\nimport org.junit.ClassRule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.junit.runner.RunWith;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.StrictStubs.class)\npublic class JsonRpcHttpServiceLoginTest {\n  @ClassRule public static final TemporaryFolder folder = new TemporaryFolder();\n\n  private static final Vertx vertx = Vertx.vertx();\n\n  protected static Map<String, JsonRpcMethod> rpcMethods;\n  protected static JsonRpcHttpService service;\n  protected static OkHttpClient client;\n  protected static String baseUrl;\n  protected static final MediaType JSON = MediaType.parse(\"application/json; charset=utf-8\");\n  protected static final String CLIENT_VERSION = \"TestClientVersion/0.1.0\";\n  protected static final BigInteger CHAIN_ID = BigInteger.valueOf(123);\n  protected static P2PNetwork peerDiscoveryMock;\n  protected static BlockchainQueries blockchainQueries;\n  protected static Synchronizer synchronizer;\n  protected static final Collection<RpcApi> JSON_RPC_APIS =\n      Arrays.asList(RpcApis.ETH, RpcApis.NET, RpcApis.WEB3, RpcApis.ADMIN);\n  protected static JWTAuth jwtAuth;\n  protected static String authPermissionsConfigFilePath = \"JsonRpcHttpService/auth.toml\";\n  protected final JsonRpcTestHelper testHelper = new JsonRpcTestHelper();\n  protected static final NatService natService = new NatService(Optional.empty());\n\n  @BeforeClass\n  public static void initServerAndClient() throws Exception {\n    peerDiscoveryMock = mock(P2PNetwork.class);\n    blockchainQueries = mock(BlockchainQueries.class);\n    synchronizer = mock(Synchronizer.class);\n\n    final Set<Capability> supportedCapabilities = new HashSet<>();\n    supportedCapabilities.add(EthProtocol.ETH62);\n    supportedCapabilities.add(EthProtocol.ETH63);\n\n    final StubGenesisConfigOptions genesisConfigOptions =\n        new StubGenesisConfigOptions().constantinopleBlock(0).chainId(CHAIN_ID);\n\n    rpcMethods =\n        spy(\n            new JsonRpcMethodsFactory()\n                .methods(\n                    CLIENT_VERSION,\n                    CHAIN_ID,\n                    genesisConfigOptions,\n                    peerDiscoveryMock,\n                    blockchainQueries,\n                    synchronizer,\n                    MainnetProtocolSchedule.fromConfig(genesisConfigOptions),\n                    mock(FilterManager.class),\n                    mock(TransactionPool.class),\n                    mock(EthHashMiningCoordinator.class),\n                    new NoOpMetricsSystem(),\n                    supportedCapabilities,\n                    Optional.empty(),\n                    Optional.empty(),\n                    JSON_RPC_APIS,\n                    mock(PrivacyParameters.class),\n                    mock(JsonRpcConfiguration.class),\n                    mock(WebSocketConfiguration.class),\n                    mock(MetricsConfiguration.class),\n                    natService,\n                    new HashMap<>()));\n    service = createJsonRpcHttpService();\n    jwtAuth = service.authenticationService.get().getJwtAuthProvider();\n    service.start().join();\n\n    // Build an OkHttp client.\n    client = new OkHttpClient();\n    baseUrl = service.url();\n  }\n\n  private static JsonRpcHttpService createJsonRpcHttpService() throws Exception {\n    final String authTomlPath =\n        Paths.get(ClassLoader.getSystemResource(authPermissionsConfigFilePath).toURI())\n            .toAbsolutePath()\n            .toString();\n\n    final JsonRpcConfiguration config = createJsonRpcConfig();\n    config.setAuthenticationEnabled(true);\n    config.setAuthenticationCredentialsFile(authTomlPath);\n\n    return new JsonRpcHttpService(\n        vertx,\n        folder.newFolder().toPath(),\n        config,\n        new NoOpMetricsSystem(),\n        natService,\n        rpcMethods,\n        HealthService.ALWAYS_HEALTHY,\n        HealthService.ALWAYS_HEALTHY);\n  }\n\n  private static JsonRpcConfiguration createJsonRpcConfig() {\n    final JsonRpcConfiguration config = JsonRpcConfiguration.createDefault();\n    config.setPort(0);\n    config.setHostsAllowlist(Collections.singletonList(\"*\"));\n    return config;\n  }\n\n  /** Tears down the HTTP server. */\n  @AfterClass\n  public static void shutdownServer() {\n    service.stop().join();\n  }\n\n  @Test\n  public void loginWithBadCredentials() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"badpass\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void loginWithGoodCredentials() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            user.isAuthorized(\n                \"noauths\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isFalse();\n                });\n          });\n    }\n  }\n\n  @Test\n  public void loginWithGoodCredentialsAndPermissions() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            user.isAuthorized(\n                \"noauths\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isFalse();\n                });\n            user.isAuthorized(\n                \"fakePermission\",\n                (authed) -> {\n                  assertThat(authed.succeeded()).isTrue();\n                  assertThat(authed.result()).isTrue();\n                });\n          });\n    }\n  }\n\n  @Test\n  public void loginDoesntPopulateJWTPayloadWithPassword()\n      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonObject jwtPayload = decodeJwtPayload(token);\n      final String jwtPayloadString = jwtPayload.encode();\n      assertThat(jwtPayloadString.contains(\"password\")).isFalse();\n      assertThat(jwtPayloadString.contains(\"pegasys\")).isFalse();\n    }\n  }\n\n  @Test\n  public void loginPopulatesJWTPayloadWithRequiredValues()\n      throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonObject jwtPayload = decodeJwtPayload(token);\n      assertThat(jwtPayload.getString(\"username\")).isEqualTo(\"user\");\n      assertThat(jwtPayload.getJsonArray(\"permissions\"))\n          .isEqualTo(\n              new JsonArray(list(\"fakePermission\", \"eth:blockNumber\", \"eth:subscribe\", \"web3:*\")));\n      assertThat(jwtPayload.getString(\"privacyPublicKey\"))\n          .isEqualTo(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");\n      assertThat(jwtPayload.containsKey(\"iat\")).isTrue();\n      assertThat(jwtPayload.containsKey(\"exp\")).isTrue();\n      final long tokenExpiry = jwtPayload.getLong(\"exp\") - jwtPayload.getLong(\"iat\");\n      assertThat(tokenExpiry).isEqualTo(MINUTES.toSeconds(5));\n    }\n  }\n\n  private String login(final String username, final String password) throws IOException {\n    final RequestBody loginBody =\n        RequestBody.create(\n            JSON, \"{\\\"username\\\":\\\"\" + username + \"\\\",\\\"password\\\":\\\"\" + password + \"\\\"}\");\n    final Request loginRequest =\n        new Request.Builder().post(loginBody).url(baseUrl + \"/login\").build();\n    final String token;\n    try (final Response loginResp = client.newCall(loginRequest).execute()) {\n      assertThat(loginResp.code()).isEqualTo(200);\n      assertThat(loginResp.message()).isEqualTo(\"OK\");\n      assertThat(loginResp.body().contentType()).isNotNull();\n      assertThat(loginResp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(loginResp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = loginResp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n    }\n    return token;\n  }\n\n  @Test\n  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndPermissions() throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"user\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonRpcMethod ethAccounts = new EthAccounts();\n      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));\n      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);\n      final JsonRpcMethod web3Sha3 = new Web3Sha3();\n      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");\n\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            // single eth/blockNumber method permitted\n            Assertions.assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethBlockNumber))\n                .isTrue();\n            // eth/accounts NOT permitted\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethAccounts))\n                .isFalse();\n            // allowed by web3/*\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3ClientVersion))\n                .isTrue();\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3Sha3))\n                .isTrue();\n            // NO net permissions\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), netVersion))\n                .isFalse();\n          });\n    }\n  }\n\n  @Test\n  public void checkJsonRpcMethodsAvailableWithGoodCredentialsAndAllPermissions()\n      throws IOException {\n    final RequestBody body =\n        RequestBody.create(JSON, \"{\\\"username\\\":\\\"adminuser\\\",\\\"password\\\":\\\"pegasys\\\"}\");\n    final Request request = new Request.Builder().post(body).url(baseUrl + \"/login\").build();\n    try (final Response resp = client.newCall(request).execute()) {\n      assertThat(resp.code()).isEqualTo(200);\n      assertThat(resp.message()).isEqualTo(\"OK\");\n      assertThat(resp.body().contentType()).isNotNull();\n      assertThat(resp.body().contentType().type()).isEqualTo(\"application\");\n      assertThat(resp.body().contentType().subtype()).isEqualTo(\"json\");\n      final String bodyString = resp.body().string();\n      assertThat(bodyString).isNotNull();\n      assertThat(bodyString).isNotBlank();\n\n      final JsonObject respBody = new JsonObject(bodyString);\n      final String token = respBody.getString(\"token\");\n      assertThat(token).isNotNull();\n\n      final JsonRpcMethod ethAccounts = new EthAccounts();\n      final JsonRpcMethod netVersion = new NetVersion(Optional.of(BigInteger.valueOf(123)));\n      final JsonRpcMethod ethBlockNumber = new EthBlockNumber(blockchainQueries);\n      final JsonRpcMethod web3Sha3 = new Web3Sha3();\n      final JsonRpcMethod web3ClientVersion = new Web3ClientVersion(\"777\");\n\n      // adminuser has *:* permissions so everything should be allowed\n      jwtAuth.authenticate(\n          new JsonObject().put(\"jwt\", token),\n          (r) -> {\n            assertThat(r.succeeded()).isTrue();\n            final User user = r.result();\n            // single eth/blockNumber method permitted\n            Assertions.assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethBlockNumber))\n                .isTrue();\n            // eth/accounts IS permitted\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), ethAccounts))\n                .isTrue();\n            // allowed by *:*\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3ClientVersion))\n                .isTrue();\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), web3Sha3))\n                .isTrue();\n            // YES net permissions\n            assertThat(\n                    AuthenticationUtils.isPermitted(\n                        service.authenticationService, Optional.of(user), netVersion))\n                .isTrue();\n          });\n    }\n  }\n\n  @Test\n  public void checkPermissionsWithEmptyUser() {\n    final JsonRpcMethod ethAccounts = new EthAccounts();\n\n    assertThat(\n            AuthenticationUtils.isPermitted(\n                service.authenticationService, Optional.empty(), ethAccounts))\n        .isFalse();\n  }\n\n  @Test\n  public void web3ClientVersionUnsuccessfulBeforeLogin() throws Exception {\n    final String id = \"123\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body)).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void web3ClientVersionUnsuccessfulWithBadBearer() throws Exception {\n    final String id = \"123\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body, \"badtoken\")).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  @Test\n  public void web3ClientVersionSuccessfulAfterLogin() throws Exception {\n    final String token = login(\"user\", \"pegasys\");\n\n    final String id = \"123\";\n    final RequestBody web3ClientVersionBody =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\"\n                + Json.encode(id)\n                + \",\\\"method\\\":\\\"web3_clientVersion\\\"}\");\n\n    try (final Response web3ClientVersionResp =\n        client.newCall(buildPostRequest(web3ClientVersionBody, token)).execute()) {\n      assertThat(web3ClientVersionResp.code()).isEqualTo(200);\n      // Check general format of result\n      final JsonObject json = new JsonObject(web3ClientVersionResp.body().string());\n      testHelper.assertValidJsonRpcResult(json, id);\n      // Check result\n      final String result = json.getString(\"result\");\n      assertThat(result).isEqualTo(\"TestClientVersion/0.1.0\");\n    }\n  }\n\n  @Test\n  public void ethSyncingUnauthorisedWithoutPermission() throws Exception {\n    final String token = login(\"user\", \"pegasys\");\n\n    final String id = \"007\";\n    final RequestBody body =\n        RequestBody.create(\n            JSON,\n            \"{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":\" + Json.encode(id) + \",\\\"method\\\":\\\"eth_syncing\\\"}\");\n\n    try (final Response resp = client.newCall(buildPostRequest(body, token)).execute()) {\n      assertThat(resp.code()).isEqualTo(401);\n      assertThat(resp.message()).isEqualTo(\"Unauthorized\");\n    }\n  }\n\n  private Request buildPostRequest(final RequestBody body) {\n    return buildPostRequest(body, Optional.empty());\n  }\n\n  private Request buildPostRequest(final RequestBody body, final String token) {\n    return buildPostRequest(body, Optional.of(token));\n  }\n\n  private Request buildPostRequest(final RequestBody body, final Optional<String> token) {\n    final Request.Builder request = new Request.Builder().post(body).url(baseUrl);\n    token.ifPresent(t -> request.addHeader(\"Authorization\", \"Bearer \" + t));\n    return request.build();\n  }\n\n  private JsonObject decodeJwtPayload(final String token) {\n    final List<String> tokenParts = Splitter.on('.').splitToList(token);\n    final String payload = tokenParts.get(1);\n    return new JsonObject(new String(Base64.getUrlDecoder().decode(payload), UTF_8));\n  }\n}\n", "/*\n * Copyright ConsenSys AG.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\npackage org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.when;\n\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\nimport org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\nimport org.hyperledger.besu.ethereum.p2p.network.P2PNetwork;\n\nimport java.util.List;\n\nimport org.assertj.core.api.Assertions;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class NetListeningTest {\n\n  private NetListening method;\n\n  @Mock private P2PNetwork p2PNetwork;\n\n  @Before\n  public void before() {\n    this.method = new NetListening(p2PNetwork);\n  }\n\n  @Test\n  public void shouldReturnTrueWhenNetworkIsListening() {\n    when(p2PNetwork.isListening()).thenReturn(true);\n\n    final JsonRpcRequestContext request = netListeningRequest();\n    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, true);\n\n    Assertions.assertThat(method.response(request))\n        .isEqualToComparingFieldByField(expectedResponse);\n  }\n\n  @Test\n  public void shouldReturnFalseWhenNetworkIsNotListening() {\n    when(p2PNetwork.isListening()).thenReturn(false);\n\n    final JsonRpcRequestContext request = netListeningRequest();\n    final JsonRpcResponse expectedResponse = new JsonRpcSuccessResponse(null, false);\n\n    Assertions.assertThat(method.response(request))\n        .isEqualToComparingFieldByField(expectedResponse);\n  }\n\n  @Test\n  public void getPermissions() {\n    List<String> permissions = method.getPermissions();\n    assertThat(permissions).containsExactly(\"*:*\", \"net:*\", \"net:listening\");\n  }\n\n  private JsonRpcRequestContext netListeningRequest() {\n    return new JsonRpcRequestContext(new JsonRpcRequest(\"2.0\", \"net_listening\", new Object[] {}));\n  }\n}\n", "[Users.user]\npassword = \"$2a$10$l3GA7K8g6rJ/Yv.YFSygCuI9byngpEzxgWS9qEg5emYDZomQW7fGC\"\npermissions = [\"fakePermission\",\"eth:blockNumber\",\"eth:subscribe\",\"web3:*\"]\nprivacyPublicKey = \"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\"\n[Users.adminuser]\npassword = \"$2a$10$l3GA7K8g6rJ/Yv.YFSygCuI9byngpEzxgWS9qEg5emYDZomQW7fGC\"\npermissions = [\"*:*\"]\nprivacyPublicKey = \"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\"\n"], "filenames": ["ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/authentication/AuthenticationUtils.java", "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/methods/JsonRpcMethod.java", "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/JsonRpcHttpServiceLoginTest.java", "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/methods/NetListeningTest.java", "ethereum/api/src/test/resources/JsonRpcHttpService/auth.toml"], "buggy_code_start_loc": [40, 26, 396, 72, 4], "buggy_code_end_loc": [61, 50, 414, 73, 4], "fixing_code_start_loc": [40, 26, 396, 72, 5], "fixing_code_end_loc": [64, 51, 475, 73, 9], "type": "CWE-400", "message": "Hyperledger Besu is an open-source, MainNet compatible, Ethereum client written in Java. In Besu before version 1.5.1 there is a denial-of-service vulnerability involving the HTTP JSON-RPC API service. If username and password authentication is enabled for the HTTP JSON-RPC API service, then prior to making any requests to an API endpoint the requestor must use the login endpoint to obtain a JSON web token (JWT) using their credentials. A single user can readily overload the login endpoint with invalid requests (incorrect password). As the supplied password is checked for validity on the main vertx event loop and takes a relatively long time this can cause the processing of other valid requests to fail. A valid username is required for this vulnerability to be exposed. This has been fixed in version 1.5.1.", "other": {"cve": {"id": "CVE-2021-21369", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-09T18:15:18.047", "lastModified": "2021-03-16T17:25:35.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Hyperledger Besu is an open-source, MainNet compatible, Ethereum client written in Java. In Besu before version 1.5.1 there is a denial-of-service vulnerability involving the HTTP JSON-RPC API service. If username and password authentication is enabled for the HTTP JSON-RPC API service, then prior to making any requests to an API endpoint the requestor must use the login endpoint to obtain a JSON web token (JWT) using their credentials. A single user can readily overload the login endpoint with invalid requests (incorrect password). As the supplied password is checked for validity on the main vertx event loop and takes a relatively long time this can cause the processing of other valid requests to fail. A valid username is required for this vulnerability to be exposed. This has been fixed in version 1.5.1."}, {"lang": "es", "value": "Hyperledger Besu es un cliente Ethereum de c\u00f3digo abierto, compatible con MainNet, escrito en Java.&#xa0;En Besu versiones anteriores a 1.5.1 se presenta una vulnerabilidad de denegaci\u00f3n de servicio que involucra al servicio HTTP JSON-RPC API .&#xa0;Si la autenticaci\u00f3n de nombre de usuario y contrase\u00f1a est\u00e1 habilitada para el servicio de HTTP JSON-RPC API , antes de realizar cualquier petici\u00f3n a un endpoint de la API, el solicitante debe usar el endpoint de inicio de sesi\u00f3n para obtener un token web JSON (JWT) con sus credenciales.&#xa0;Un solo usuario puede sobrecargar f\u00e1cilmente el endpoint de inicio de sesi\u00f3n con peticiones no v\u00e1lidas (contrase\u00f1a incorrecta).&#xa0;Como se comprueba la validez de la contrase\u00f1a proporcionada en el bucle de eventos principal de vertx y lleva un tiempo relativamente largo, esto puede causar que el procesamiento de otras peticiones v\u00e1lidas presenten un fallo.&#xa0;Es requerido un nombre de usuario v\u00e1lido para que se exponga esta vulnerabilidad.&#xa0;Esto ha sido corregido en la versi\u00f3n 1.5.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:besu:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.1", "matchCriteriaId": "236DADDD-59BD-4AD7-9B91-16F5A30FFA0D"}]}]}], "references": [{"url": "https://github.com/hyperledger/besu/blob/master/CHANGELOG.md#151", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/besu/commit/06e35a58c07a30c0fbdc0aae45a3e8b06b53c022", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/besu/pull/1144", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hyperledger/besu/security/advisories/GHSA-qgfj-mjpc-7w3q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hyperledger/besu/commit/06e35a58c07a30c0fbdc0aae45a3e8b06b53c022"}}