{"buggy_code": ["LDAP Git Backup\n===============\n\nBack up your LDAP data in a Git repository\n\n## Quick Start\n\n### Installation\n\n    wget https://github.com/downloads/elmar/ldap-git-backup/ldap-git-backup.tar.gz\n    tar xzf ldap-git-backup.tar.gz\n    cd ldap-git-backup-1.0\n    ./configure\n    make\n    make check\n    sudo make install\n\n### Deployment\n\nIf you are using OpenLDAP the script\n\n    ldap-git-backup\n\nwill dump your current LDAP database into <code>/var/backups/ldap</code> and check it into Git.  Do this regularly (e.g. via cron) and you will have a versioned history of backups.\n\n## Motivation\n\nHow do you back up your LDAP data?  Typically, you run a cron job once per day to dump all LDAP entries into a LDIF file then compress this file and keep a few generations.  With OpenLDAP the command to use is <code>slapcat</code>.  Since LDAP usually contains a lot of similar entries the compression is quite good and you can keep a few backups with space requirements comparable to the LDAP database itself.  When disaster strikes you take the most recent backup that you know not to contain the problem and restore the data from there.\n\nThis is all quite resonable, but we can do better.  LDAP is used for data that are read more often than written.  As a result the differences between two consecutive backups are relatively small.  If we store only the deltas we can save quite some space.  Git will do all the management of the delta and keep a record of the history.  To make this approach practical we split up the LDIF into individual entries and track the entries as separate files.\n\n## Mode of Operation\n\nThe script <code>ldap-git-backup</code> is a convenient way to automate this process.  Each time it is run it will call the LDIF command given by the option <code>--ldif-cmd</code> or <code>/usr/sbin/slapcat</code> if none is given.  The output of the LDIF command is split up into individual files, one per entry.  The file names are a combination of the creation time of the entry and a hash of the DN.  With this naming the individual LDIF entries will keep their names between backups and still avoid name clashes.  The unlikely case of a name clash will be automatically handled by adding a simple count to the file.\n\nThe backup location will be <code>/var/backups/ldap</code> or an alternative directory given by the <code>--backup-dir</code> option.  This directory will also contain the Git repository.  The directory and the Git repository will be created if needed when the first backup is made.\n\n## Backup Strategies\n\nThe simplest backup strategy would just call <code>ldap-git-backup</code> once per day via cron.  Pick a quiet time for the LDAP directory and add a command like the following to your crontab (e.g., <code>crontab -e</code> or in <code>/etc/cron.d/ldap-git-backup</code>):\n\n    0 5 * * * /usr/sbin/ldap-git-backup --commit-msg 'backup by daily cron'\n\nAlternatively or in addition you can also trigger a backup whenever some relevant event like adding an LDAP entry or changing a password occurs.  The details depend on your setup.  Ultimately, you want to call <code>ldap-git-backup</code> with some helpful <code>--commit-msg</code>.\n\n## Migrating Previous Backups to Git\n\nUnless you are starting a new LDAP directory chances are you already have some backups.  With OpenLDAP you would typically use the above mentioned <code>slapcat</code> command and compress the result.  You can use <code>ldif-git-backup</code> to add these older backups to the Git repository.\n\nHere is some example code that may serve as a start:\n\n    #!/bin/bash\n    LDIF_DIR=$1\n    BKUP_DIR=$2\n\n    function usage () {\n        echo \"usage: $0 <LDIF_DIR> <BACKUP_DIR>\"\n        exit 1\n    }\n\n    [[ -d $LDIF_DIR ]] || usage\n    [[ -d $BKUP_DIR ]] || usage\n\n    for filepath in `ls -1tr $LDIF_DIR/TODO/*.gz` ; do\n        filename=`basename $filepath`\n        echo $filename\n        ldap-git-backup \\\n            --ldif-cmd \"zcat $filepath\" \\\n            --backup-dir $BKUP_DIR \\\n            --commit-msg $filename \\\n            --commit-date $filepath\n        mv $path DONE/$filename\n    done\n\nTo use this script you put all compressed old LDIF file in a subdirectory <code>TODO</code> of some directory where you keep the backups.  You must also create another directory <code>DONE</code> where the processed backups will be moved into.  Furthermore, the script assumes that the backup files still have their original modification time of when the backup was performed.  This is used to sort the files and to set the commit date.\n\nIf your setup is different you have to adjust the script or write your own.  Alternatively, you can decide to start with a clean slate and keep the old backups unchanged for as long as your backup policy requires.\n\n## Restores\n\nIf you need to restore some data you will find the individual LDIF files checked out in the working tree of the backup directory (<code>/var/backups/ldap</code> by default).  You can use these files directly if you just need the latest version of one or a few LDAP entries.  You can use the standard commands meant to deal with LDIF files.  You may also consider writing some Perl/Python/Ruby scripts depending on the restore you want to make.\n\nIf you want to restore the entire LDAP database it might by enough to concatenate all LDIF files and add them to an new, empty LDAP directory.  The file names contain the create timestamp as their first part.  Any entry that depends on another entry needs to have a timestamp that is later than that of the entry it depends on.  If the data has accumulated naturally, this is usually the case.  However, if an entry now depends on another entry that was only created later you may need to reorder the LDIF files or you add them in several passes and keep a list of entries that didn't add themselves properly in an earlier pass.\n\nIf you want to do more complicated restores it is advisable that you clone the Git repository first.  You need to clone only the commits that are relevant for the restore.  A typical session might look like this (cloning the last 10 backups and checking out 7 commits earlier):\n\n    mkdir /tmp/ldap-restore\n    cd /tmp/ldap-restore\n    git clone --depth 10 /var/backups/ldap\n    git checkout -b restore master~7\n    ...\n\n## Bug Hunting with the Git Repository\n\nYou may be looking for the cause of a problem where you suspect some changes in an LDAP entry to be the reason.  You can use the Git repository to see all the changes done to the LDAP directory (in intervals given by your backup policy).  You may do something like:\n\n    cd /var/backups/ldap\n    git log --stat\n    git show <commit-ID>\n\nYou may also see the complete diff history with <code>git log -p</code>.  Individual entries retain their name as long as the create timestamp and DN do not change.  Therefore, you can investigate the history of an individual entry with <code>git log -p filename</code>.\n\n## Safe LDIF\n\nWith OpenLDAP the command <code>slapcat</code> is meant to produce a snapshot LDIF of an active OpenLDAP server.  This works most of the time but occasionally we experienced truncated output without any indication of a problem.  <code>slapcat</code> would exit with a zero exit code and the resulting LDIF dump is valid but too short.  This may be a [bug in OpenLDAP](http://bugs.debian.org/673038).  At the time of this writing it is not clear what triggers the bug.\n\nTo make the backups a bit more robust we can trade speed with reliability and call the <code>--ldif-cmd</code> (i.e., <code>slapcat</code>) multiple times to verify the backup.  <code>safe-ldif</code> does just this and writes the last dump as soon as two consecutive outputs result in the same number of LDIF stanzas.  This accomodates LDAP directories where attributes may be updated relatively frequently but the number of entries changes only rarely.\n\nSince reliable backups are important <code>safe-ldif</code> is the default.\n\n## Thanks\n\nOver time various people contributed with discussions, ideas, code, and bug reports.\n\n- Axel Beckert <abe@debian.org> (co-maintainer)\n- Florian Ernst <florian\\_ernst@gmx.net>\n- Bart Martens <bartm@debian.org>\n", "AC_PREREQ([2.67])dnl require version in Debian squeeze (or higher)\nAC_INIT(\n    [LDAP Git Backup],\n    [1.0.3],\n    [elmar@heebs.ch],\n    [ldap-git-backup],\n    [https://github.com/elmar/ldap-git-backup]\n)\nAC_CONFIG_AUX_DIR([build-aux])\n\nAM_INIT_AUTOMAKE([foreign -Wall -Werror])\n\nAC_DEFUN([AX_CONFIG_FILE_EXEC],\n         [AC_CONFIG_FILES($1, [chmod +x ]$1)]\n)\n\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([t/test-helper.pm])\nAX_CONFIG_FILE_EXEC([t/001_help-option.t])\nAX_CONFIG_FILE_EXEC([t/010_read_ldif.t])\nAX_CONFIG_FILE_EXEC([t/020_entry-name.t])\nAX_CONFIG_FILE_EXEC([t/030_git-from-scratch.t])\nAX_CONFIG_FILE_EXEC([t/040_delete-entry.t])\nAX_CONFIG_FILE_EXEC([t/050_modify-entry.t])\nAX_CONFIG_FILE_EXEC([t/060_custom_commit.t])\nAX_CONFIG_FILE_EXEC([t/070_mock-slapcat.t])\nAX_CONFIG_FILE_EXEC([t/071_safe-ldif.t])\nAX_CONFIG_FILE_EXEC([t/mock-slapcat])\nAX_CONFIG_FILE_EXEC([safe-ldif])\n\nAC_OUTPUT\n", "ldap-git-backup (1.0.3-2) unstable; urgency=low\n\n  * clean up of Depends and Build-Depends\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Thu, 03 Jan 2013 15:07:33 +0100\n\nldap-git-backup (1.0.3-1) unstable; urgency=low\n\n  * fixed autoconf directory variables\n  * better watch file. Thanks to Bart Martens.\n  * mention co-maintainer in debian/control\n  * mention people/thanks in README\n  * use .mdown file ending for README\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Sun, 16 Dec 2012 15:11:46 +0100\n\nldap-git-backup (1.0.2-1) unstable; urgency=low\n\n  * remove option to use Modern::Perl (Closes: #689290)\n  * fixed watch file to include final slash\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Mon, 01 Oct 2012 15:03:12 +0200\n\nldap-git-backup (1.0.1-1) unstable; urgency=low\n\n  * allow extra files to go into Git repo and be untouched by backups\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Tue, 18 Sep 2012 18:20:21 +0200\n\nldap-git-backup (1.0-3) unstable; urgency=low\n\n  * dependency on git (build + package)\n  * document installation from source\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Thu, 05 Jul 2012 11:00:52 +0200\n\nldap-git-backup (1.0-2) unstable; urgency=low\n\n  * fix typo backup vs. backups in default settings\n  * add reference to upstream ChangeLog\n  * make check, make distcheck, and tests in debuild should\n    all work properly\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Wed, 04 Jul 2012 12:16:33 +0200\n\nldap-git-backup (1.0-1) unstable; urgency=low\n\n  * Initial release (Closes: #678980)\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Mon, 25 Jun 2012 14:08:13 +0200\n", "#!/usr/bin/env perl\n# vim: set filetype=perl :\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars);\nuse Carp;\nuse autodie;\nuse File::stat;\n\nmain() unless caller(0);\n\nsub main {\n    use Pod::Usage;\n    use Getopt::Long qw( :config auto_help pass_through );\n    use File::Path qw( make_path );\n    use Git;\n\n    my $ldif_cmd    = '@sbindir@/safe-ldif';\n    my $backup_dir  = '/var/backups/ldap';\n    my $commit_msg  = 'ldap-git-backup';\n    my $commit_date = time();\n    my $help;\n    GetOptions(\n        'ldif-cmd=s'    => \\$ldif_cmd,\n        'backup-dir=s'  => \\$backup_dir,\n        'commit-msg=s'  => \\$commit_msg,\n        'commit-date=s' => \\$commit_date,\n        'help'          => \\$help,\n    );\n    pod2usage('-verbose' => 2, '-exit_status' => 0) if $help;\n    pod2usage() if @ARGV;\n\n    if ( -e $commit_date ) {\n        $commit_date = stat($commit_date)->mtime();\n    }\n\n    my $ldif_aref = LDAP::Utils::read_ldif($ldif_cmd);\n    make_path($backup_dir);\n    chdir($backup_dir);\n    Git::command('init');\n    my $repo = Git->repository(Directory => $backup_dir);\n\n    my @filelist = $repo->command('ls-files', '*.ldif');\n    my %files_before = ();\n    for my $f (@filelist) { $files_before{$f} = 1 }\n\n    @filelist = ();\n    for my $ldif (@$ldif_aref) {\n        my $filename = LDAP::Utils::filename($ldif);\n        open(my $fh, '>', \"$backup_dir/$filename\");\n        print {$fh} $ldif;\n        close($fh);\n        push(@filelist, $filename);\n        delete($files_before{$filename});\n    }\n    $repo->command('add', @filelist) if @filelist;\n    $repo->command('rm', (keys %files_before)) if %files_before;\n\n    $repo->command('commit', \"--message=$commit_msg\", \"--date=$commit_date\");\n    $repo->command('gc', '--quiet');\n}\n\npackage LDAP::Utils;\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars);\nuse Carp;\nuse autodie;\nuse MIME::Base64;\n\nsub read_ldif {\n    my ($ldif_cmd) = @_;\n\n    my $entry_count = -1;\n    my $ldif_aref = [];\n    until ($entry_count == @$ldif_aref) {\n        $entry_count = @$ldif_aref;\n        $ldif_aref = read_ldif_raw($ldif_cmd);\n    }\n\n    return $ldif_aref;\n}\n\nsub read_ldif_raw {\n    my ($ldif_cmd) = @_;\n\n    my $ldif_aref = [];\n    my $ldif_fh;\n    local $INPUT_RECORD_SEPARATOR = \"\\n\\n\";\n\n    open( $ldif_fh, '-|', $ldif_cmd) or die \"Can't exec '$ldif_cmd': $!\";\n    while (my $record = <$ldif_fh>) {\n        push(@$ldif_aref, $record);\n    }\n    close($ldif_fh) or die \"$ldif_cmd exited with $?: $!\";\n\n    return $ldif_aref;\n}\n\nour %filename_list = ();\nsub filename {\n    my ($ldif) = @_;\n\n    use Digest::MD5 qw( md5_hex );\n    my $filename = timestamp($ldif) . '-' . substr(md5_hex(dn($ldif)), 0, 7);\n    if (defined($filename_list{$filename})) {\n        $filename_list{$filename} += 1;\n        $filename .= '-' . $filename_list{$filename};\n    }\n    else {\n        $filename_list{$filename} = 0;\n    }\n\n    return $filename . '.ldif';\n}\n\nsub dn {\n    my ($ldif) = @_;\n    $ldif =~ s{\\n }{}gs; # combine multiline attributes\n\n    for my $line (split(\"\\n\", $ldif)) {\n        next unless $line =~ m{\\A dn:}xmsi;\n        my $dn = get_value_from_attribute($line);\n        return canonicalize_dn($dn);\n    }\n\n    return '';\n}\n\nsub canonicalize_dn {\n    my ($dn) = @_;\n\n    my @rdns = split(',', $dn);\n    @rdns = map { canonicalize_rdn($_) } @rdns;\n    return join(',', @rdns);\n}\n\nsub canonicalize_rdn {\n    my ($rdn) = @_;\n\n    my ($key, $value) = split('=', $rdn, 2);\n    $key   =~ s{\\A\\s+}{}xms;\n    $key   =~ s{\\s+\\Z}{}xms;\n    $value =~ s{\\A\\s+}{}xms;\n    $value =~ s{\\s+\\Z}{}xms;\n    return lc($key) . '=' . lc($value);\n}\n\nsub timestamp {\n    my ($ldif) = @_;\n    $ldif =~ s{\\n }{}gs; # combine multiline attributes\n\n    for my $line (split(\"\\n\", $ldif)) {\n        next unless $line =~ m{\\A createtimestamp:}xmsi;\n        return get_value_from_attribute($line);\n    }\n    return '00000000000000Z';\n}\n\nsub get_value_from_attribute {\n    my ($attribute) = @_;\n\n    my $value;\n    if ( $attribute =~ m{\\A [^:]+ ::}xms ) {\n        $value = ( split(':: ', $attribute, 2) )[1];\n        $value = decode_base64($value);\n    }\n    else {\n        $value = ( split(': ', $attribute, 2) )[1];\n        }\n    return $value;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nldap-git-backup - check in LDIF from an LDAP server into a GIT repository\n\n=head1 SYNOPSIS\n\nldap-git-backup [options]\n\nldap-git-backup --help\n\n=head1 DESCRIPTION\n\nldap-git-backup takes an LDIF dump of an LDAP server and updates a GIT repository\nthat serves as a versioned backup.\n\nldap-git-backup splits the LDIF data into separate entries.  It constructs\nunique but stable file names using a combination of the creation time stamp for\nordering and the DN as the unique key for an entry.\n\n=head1 OPTIONS\n\n=over 4\n\n=item B<--ldif-cmd E<lt>dump_ldif_commandE<gt>>\n\nSpecify a command to create a complete LDIF dump of the LDAP directory suitable\nfor a backup.  It should contain all entries necessary to restore the LDAP\ndatabase.  By default C<@sbindir@/safe-ldif> is taken which calls\nC</usr/sbin/slapcat> from OpenLDAP.\n\n=item B<--backup-dir E<lt>backup_directoryE<gt>>\n\nSpecify the directory where the GIT repository for the versioned backup is held.\nDefault: F</var/backups/ldap>\n\n=item B<--commit-msg E<lt>commit_stringE<gt>>\n\nSpecify a custom commit message.  Default: ldap-git-backup\n\n=item B<--commit-date E<lt>date_stringE<gt>>\n\n=item B<--commit-date E<lt>fileE<gt>>\n\nSpecify a custom commit date.  If a file is given its modification time is used.\n\n=item B<--help>\n\nPrints this page.\n\n=back\n\n=head1 AUTHOR\n\nElmar S. Heeb <elmar@heebs.ch>\n\n=cut\n", "#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars );\nuse autodie;\n\nuse Test::More;\n\nrequire \"@abs_top_builddir@/t/test-helper.pm\";\nTest::Helper->import();\n\nuse Git;\nuse File::Temp qw( tempdir );\n\n# start with a non-existing directory and create two\n# consecutive LDIF backups on the new GIT repo\n\nmy $tmpdir = tempdir( CLEANUP => 1 );\nmy $backup_dir = \"$tmpdir/backup-$PID\";\n\nok( (not -e $backup_dir), 'backup directory should not exist at first' );\n\n# ----- first backup -----\nok(\n    system(\n        'perl',\n        \"@abs_top_builddir@/ldap-git-backup\",\n        \"--ldif-cmd=cat @abs_top_srcdir@/t/testdata/data_A1.ldif\",\n        \"--backup-dir=$backup_dir\",\n    ) == 0,\n    'first backup should run'\n);\nok( (-d $backup_dir), 'backup directory should have been created' );\nok( (-d \"$backup_dir/.git\"), 'backup directory should be a GIT repository now');\n\ncheck_directory_list($backup_dir, qw(\n    .\n    ..\n    .git\n    20120604153004Z-3816ac9.ldif\n    20120604153004Z-9941228.ldif\n));\n\nmy $repo = Git->repository( Directory => $backup_dir );\nmy @revs = $repo->command('rev-list', '--all');\nis( @revs, 1, 'should have one GIT revision' );\n\n# ----- second backup -----\nok(\n    system(\n        'perl',\n        \"@abs_top_builddir@/ldap-git-backup\",\n        \"--ldif-cmd=cat @abs_top_srcdir@/t/testdata/data_A2.ldif\",\n        \"--backup-dir=$backup_dir\",\n    ) == 0,\n    'second backup should run'\n);\ncheck_directory_list($backup_dir, qw(\n    .\n    ..\n    .git\n    20120604153004Z-3816ac9.ldif\n    20120604153004Z-9941228.ldif\n    20120604161324Z-7ebb002.ldif\n    20120604161334Z-e2a09bd.ldif\n));\n@revs = $repo->command('rev-list', '--all');\nis( @revs, 2, 'should have two GIT revisions' );\n\n# clean up test data\ndone_testing();\n"], "fixing_code": ["LDAP Git Backup\n===============\n\nBack up your LDAP data in a Git repository\n\n## Quick Start\n\n### Installation\n\n    wget https://github.com/downloads/elmar/ldap-git-backup/ldap-git-backup.tar.gz\n    tar xzf ldap-git-backup.tar.gz\n    cd ldap-git-backup-1.0\n    ./configure\n    make\n    make check\n    sudo make install\n\n### Deployment\n\nIf you are using OpenLDAP the script\n\n    ldap-git-backup\n\nwill dump your current LDAP database into <code>/var/backups/ldap</code> and check it into Git.  Do this regularly (e.g. via cron) and you will have a versioned history of backups.\n\n## Motivation\n\nHow do you back up your LDAP data?  Typically, you run a cron job once per day to dump all LDAP entries into a LDIF file then compress this file and keep a few generations.  With OpenLDAP the command to use is <code>slapcat</code>.  Since LDAP usually contains a lot of similar entries the compression is quite good and you can keep a few backups with space requirements comparable to the LDAP database itself.  When disaster strikes you take the most recent backup that you know not to contain the problem and restore the data from there.\n\nThis is all quite resonable, but we can do better.  LDAP is used for data that are read more often than written.  As a result the differences between two consecutive backups are relatively small.  If we store only the deltas we can save quite some space.  Git will do all the management of the delta and keep a record of the history.  To make this approach practical we split up the LDIF into individual entries and track the entries as separate files.\n\n## Mode of Operation\n\nThe script <code>ldap-git-backup</code> is a convenient way to automate this process.  Each time it is run it will call the LDIF command given by the option <code>--ldif-cmd</code> or <code>/usr/sbin/slapcat</code> if none is given.  The output of the LDIF command is split up into individual files, one per entry.  The file names are a combination of the creation time of the entry and a hash of the DN.  With this naming the individual LDIF entries will keep their names between backups and still avoid name clashes.  The unlikely case of a name clash will be automatically handled by adding a simple count to the file.\n\nThe backup location will be <code>/var/backups/ldap</code> or an alternative directory given by the <code>--backup-dir</code> option.  This directory will also contain the Git repository.  The directory and the Git repository will be created if needed when the first backup is made.\n\n## Backup Strategies\n\nThe simplest backup strategy would just call <code>ldap-git-backup</code> once per day via cron.  Pick a quiet time for the LDAP directory and add a command like the following to your crontab (e.g., <code>crontab -e</code> or in <code>/etc/cron.d/ldap-git-backup</code>):\n\n    0 5 * * * /usr/sbin/ldap-git-backup --commit-msg 'backup by daily cron'\n\nAlternatively or in addition you can also trigger a backup whenever some relevant event like adding an LDAP entry or changing a password occurs.  The details depend on your setup.  Ultimately, you want to call <code>ldap-git-backup</code> with some helpful <code>--commit-msg</code>.\n\n## Migrating Previous Backups to Git\n\nUnless you are starting a new LDAP directory chances are you already have some backups.  With OpenLDAP you would typically use the above mentioned <code>slapcat</code> command and compress the result.  You can use <code>ldif-git-backup</code> to add these older backups to the Git repository.\n\nHere is some example code that may serve as a start:\n\n    #!/bin/bash\n    LDIF_DIR=$1\n    BKUP_DIR=$2\n\n    function usage () {\n        echo \"usage: $0 <LDIF_DIR> <BACKUP_DIR>\"\n        exit 1\n    }\n\n    [[ -d $LDIF_DIR ]] || usage\n    [[ -d $BKUP_DIR ]] || usage\n\n    for filepath in `ls -1tr $LDIF_DIR/TODO/*.gz` ; do\n        filename=`basename $filepath`\n        echo $filename\n        ldap-git-backup \\\n            --ldif-cmd \"zcat $filepath\" \\\n            --backup-dir $BKUP_DIR \\\n            --commit-msg $filename \\\n            --commit-date $filepath\n        mv $path DONE/$filename\n    done\n\nTo use this script you put all compressed old LDIF file in a subdirectory <code>TODO</code> of some directory where you keep the backups.  You must also create another directory <code>DONE</code> where the processed backups will be moved into.  Furthermore, the script assumes that the backup files still have their original modification time of when the backup was performed.  This is used to sort the files and to set the commit date.\n\nIf your setup is different you have to adjust the script or write your own.  Alternatively, you can decide to start with a clean slate and keep the old backups unchanged for as long as your backup policy requires.\n\n## Restores\n\nIf you need to restore some data you will find the individual LDIF files checked out in the working tree of the backup directory (<code>/var/backups/ldap</code> by default).  You can use these files directly if you just need the latest version of one or a few LDAP entries.  You can use the standard commands meant to deal with LDIF files.  You may also consider writing some Perl/Python/Ruby scripts depending on the restore you want to make.\n\nIf you want to restore the entire LDAP database it might by enough to concatenate all LDIF files and add them to an new, empty LDAP directory.  The file names contain the create timestamp as their first part.  Any entry that depends on another entry needs to have a timestamp that is later than that of the entry it depends on.  If the data has accumulated naturally, this is usually the case.  However, if an entry now depends on another entry that was only created later you may need to reorder the LDIF files or you add them in several passes and keep a list of entries that didn't add themselves properly in an earlier pass.\n\nIf you want to do more complicated restores it is advisable that you clone the Git repository first.  You need to clone only the commits that are relevant for the restore.  A typical session might look like this (cloning the last 10 backups and checking out 7 commits earlier):\n\n    mkdir /tmp/ldap-restore\n    cd /tmp/ldap-restore\n    git clone --depth 10 /var/backups/ldap\n    git checkout -b restore master~7\n    ...\n\n## Bug Hunting with the Git Repository\n\nYou may be looking for the cause of a problem where you suspect some changes in an LDAP entry to be the reason.  You can use the Git repository to see all the changes done to the LDAP directory (in intervals given by your backup policy).  You may do something like:\n\n    cd /var/backups/ldap\n    git log --stat\n    git show <commit-ID>\n\nYou may also see the complete diff history with <code>git log -p</code>.  Individual entries retain their name as long as the create timestamp and DN do not change.  Therefore, you can investigate the history of an individual entry with <code>git log -p filename</code>.\n\n## Safe LDIF\n\nWith OpenLDAP the command <code>slapcat</code> is meant to produce a snapshot LDIF of an active OpenLDAP server.  This works most of the time but occasionally we experienced truncated output without any indication of a problem.  <code>slapcat</code> would exit with a zero exit code and the resulting LDIF dump is valid but too short.  This may be a [bug in OpenLDAP](http://bugs.debian.org/673038).  At the time of this writing it is not clear what triggers the bug.\n\nTo make the backups a bit more robust we can trade speed with reliability and call the <code>--ldif-cmd</code> (i.e., <code>slapcat</code>) multiple times to verify the backup.  <code>safe-ldif</code> does just this and writes the last dump as soon as two consecutive outputs result in the same number of LDIF stanzas.  This accomodates LDAP directories where attributes may be updated relatively frequently but the number of entries changes only rarely.\n\nSince reliable backups are important <code>safe-ldif</code> is the default.\n\n## Thanks\n\nOver time various people contributed with discussions, ideas, code, and bug reports.\n\n- Axel Beckert <abe@debian.org> (co-maintainer)\n- Florian Ernst <florian\\_ernst@gmx.net>\n- Bart Martens <bartm@debian.org>\n- Hans Spaans <hans.spaans@nexit.nl>\n", "AC_PREREQ([2.67])dnl require version in Debian squeeze (or higher)\nAC_INIT(\n    [LDAP Git Backup],\n    [1.0.4],\n    [elmar@heebs.ch],\n    [ldap-git-backup],\n    [https://github.com/elmar/ldap-git-backup]\n)\nAC_CONFIG_AUX_DIR([build-aux])\n\nAM_INIT_AUTOMAKE([foreign -Wall -Werror])\n\nAC_DEFUN([AX_CONFIG_FILE_EXEC],\n         [AC_CONFIG_FILES($1, [chmod +x ]$1)]\n)\n\nAC_CONFIG_FILES([Makefile])\nAC_CONFIG_FILES([t/test-helper.pm])\nAX_CONFIG_FILE_EXEC([t/001_help-option.t])\nAX_CONFIG_FILE_EXEC([t/010_read_ldif.t])\nAX_CONFIG_FILE_EXEC([t/020_entry-name.t])\nAX_CONFIG_FILE_EXEC([t/030_git-from-scratch.t])\nAX_CONFIG_FILE_EXEC([t/040_delete-entry.t])\nAX_CONFIG_FILE_EXEC([t/050_modify-entry.t])\nAX_CONFIG_FILE_EXEC([t/060_custom_commit.t])\nAX_CONFIG_FILE_EXEC([t/070_mock-slapcat.t])\nAX_CONFIG_FILE_EXEC([t/071_safe-ldif.t])\nAX_CONFIG_FILE_EXEC([t/mock-slapcat])\nAX_CONFIG_FILE_EXEC([safe-ldif])\n\nAC_OUTPUT\n", "ldap-git-backup (1.0.4-1) unstable; urgency=low\n\n  * create backup directory with default mode of 0700\n    fixes CVE-2013-1425 (local information disclosure)\n    Thanks to Hans Spaans <hans.spaans@nexit.nl>\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Mon, 28 Jan 2013 19:05:13 +0000\n\nldap-git-backup (1.0.3-2) unstable; urgency=low\n\n  * clean up of Depends and Build-Depends\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Thu, 03 Jan 2013 15:07:33 +0100\n\nldap-git-backup (1.0.3-1) unstable; urgency=low\n\n  * fixed autoconf directory variables\n  * better watch file. Thanks to Bart Martens.\n  * mention co-maintainer in debian/control\n  * mention people/thanks in README\n  * use .mdown file ending for README\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Sun, 16 Dec 2012 15:11:46 +0100\n\nldap-git-backup (1.0.2-1) unstable; urgency=low\n\n  * remove option to use Modern::Perl (Closes: #689290)\n  * fixed watch file to include final slash\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Mon, 01 Oct 2012 15:03:12 +0200\n\nldap-git-backup (1.0.1-1) unstable; urgency=low\n\n  * allow extra files to go into Git repo and be untouched by backups\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Tue, 18 Sep 2012 18:20:21 +0200\n\nldap-git-backup (1.0-3) unstable; urgency=low\n\n  * dependency on git (build + package)\n  * document installation from source\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Thu, 05 Jul 2012 11:00:52 +0200\n\nldap-git-backup (1.0-2) unstable; urgency=low\n\n  * fix typo backup vs. backups in default settings\n  * add reference to upstream ChangeLog\n  * make check, make distcheck, and tests in debuild should\n    all work properly\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Wed, 04 Jul 2012 12:16:33 +0200\n\nldap-git-backup (1.0-1) unstable; urgency=low\n\n  * Initial release (Closes: #678980)\n\n -- Elmar S. Heeb <elmar@heebs.ch>  Mon, 25 Jun 2012 14:08:13 +0200\n", "#!/usr/bin/env perl\n# vim: set filetype=perl :\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars);\nuse Carp;\nuse autodie;\nuse File::stat;\n\nmain() unless caller(0);\n\nsub main {\n    use Pod::Usage;\n    use Getopt::Long qw( :config auto_help pass_through );\n    use File::Path qw( make_path );\n    use Git;\n\n    my $ldif_cmd    = '@sbindir@/safe-ldif';\n    my $backup_dir  = '/var/backups/ldap';\n    my $commit_msg  = 'ldap-git-backup';\n    my $commit_date = time();\n    my $help;\n    GetOptions(\n        'ldif-cmd=s'    => \\$ldif_cmd,\n        'backup-dir=s'  => \\$backup_dir,\n        'commit-msg=s'  => \\$commit_msg,\n        'commit-date=s' => \\$commit_date,\n        'help'          => \\$help,\n    );\n    pod2usage('-verbose' => 2, '-exit_status' => 0) if $help;\n    pod2usage() if @ARGV;\n\n    if ( -e $commit_date ) {\n        $commit_date = stat($commit_date)->mtime();\n    }\n\n    my $ldif_aref = LDAP::Utils::read_ldif($ldif_cmd);\n    make_path($backup_dir, {mode => 0700});\n    chdir($backup_dir);\n    Git::command('init');\n    my $repo = Git->repository(Directory => $backup_dir);\n\n    my @filelist = $repo->command('ls-files', '*.ldif');\n    my %files_before = ();\n    for my $f (@filelist) { $files_before{$f} = 1 }\n\n    @filelist = ();\n    for my $ldif (@$ldif_aref) {\n        my $filename = LDAP::Utils::filename($ldif);\n        open(my $fh, '>', \"$backup_dir/$filename\");\n        print {$fh} $ldif;\n        close($fh);\n        push(@filelist, $filename);\n        delete($files_before{$filename});\n    }\n    $repo->command('add', @filelist) if @filelist;\n    $repo->command('rm', (keys %files_before)) if %files_before;\n\n    $repo->command('commit', \"--message=$commit_msg\", \"--date=$commit_date\");\n    $repo->command('gc', '--quiet');\n}\n\npackage LDAP::Utils;\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars);\nuse Carp;\nuse autodie;\nuse MIME::Base64;\n\nsub read_ldif {\n    my ($ldif_cmd) = @_;\n\n    my $entry_count = -1;\n    my $ldif_aref = [];\n    until ($entry_count == @$ldif_aref) {\n        $entry_count = @$ldif_aref;\n        $ldif_aref = read_ldif_raw($ldif_cmd);\n    }\n\n    return $ldif_aref;\n}\n\nsub read_ldif_raw {\n    my ($ldif_cmd) = @_;\n\n    my $ldif_aref = [];\n    my $ldif_fh;\n    local $INPUT_RECORD_SEPARATOR = \"\\n\\n\";\n\n    open( $ldif_fh, '-|', $ldif_cmd) or die \"Can't exec '$ldif_cmd': $!\";\n    while (my $record = <$ldif_fh>) {\n        push(@$ldif_aref, $record);\n    }\n    close($ldif_fh) or die \"$ldif_cmd exited with $?: $!\";\n\n    return $ldif_aref;\n}\n\nour %filename_list = ();\nsub filename {\n    my ($ldif) = @_;\n\n    use Digest::MD5 qw( md5_hex );\n    my $filename = timestamp($ldif) . '-' . substr(md5_hex(dn($ldif)), 0, 7);\n    if (defined($filename_list{$filename})) {\n        $filename_list{$filename} += 1;\n        $filename .= '-' . $filename_list{$filename};\n    }\n    else {\n        $filename_list{$filename} = 0;\n    }\n\n    return $filename . '.ldif';\n}\n\nsub dn {\n    my ($ldif) = @_;\n    $ldif =~ s{\\n }{}gs; # combine multiline attributes\n\n    for my $line (split(\"\\n\", $ldif)) {\n        next unless $line =~ m{\\A dn:}xmsi;\n        my $dn = get_value_from_attribute($line);\n        return canonicalize_dn($dn);\n    }\n\n    return '';\n}\n\nsub canonicalize_dn {\n    my ($dn) = @_;\n\n    my @rdns = split(',', $dn);\n    @rdns = map { canonicalize_rdn($_) } @rdns;\n    return join(',', @rdns);\n}\n\nsub canonicalize_rdn {\n    my ($rdn) = @_;\n\n    my ($key, $value) = split('=', $rdn, 2);\n    $key   =~ s{\\A\\s+}{}xms;\n    $key   =~ s{\\s+\\Z}{}xms;\n    $value =~ s{\\A\\s+}{}xms;\n    $value =~ s{\\s+\\Z}{}xms;\n    return lc($key) . '=' . lc($value);\n}\n\nsub timestamp {\n    my ($ldif) = @_;\n    $ldif =~ s{\\n }{}gs; # combine multiline attributes\n\n    for my $line (split(\"\\n\", $ldif)) {\n        next unless $line =~ m{\\A createtimestamp:}xmsi;\n        return get_value_from_attribute($line);\n    }\n    return '00000000000000Z';\n}\n\nsub get_value_from_attribute {\n    my ($attribute) = @_;\n\n    my $value;\n    if ( $attribute =~ m{\\A [^:]+ ::}xms ) {\n        $value = ( split(':: ', $attribute, 2) )[1];\n        $value = decode_base64($value);\n    }\n    else {\n        $value = ( split(': ', $attribute, 2) )[1];\n        }\n    return $value;\n}\n\n1;\n\n__END__\n\n=head1 NAME\n\nldap-git-backup - check in LDIF from an LDAP server into a GIT repository\n\n=head1 SYNOPSIS\n\nldap-git-backup [options]\n\nldap-git-backup --help\n\n=head1 DESCRIPTION\n\nldap-git-backup takes an LDIF dump of an LDAP server and updates a GIT repository\nthat serves as a versioned backup.\n\nldap-git-backup splits the LDIF data into separate entries.  It constructs\nunique but stable file names using a combination of the creation time stamp for\nordering and the DN as the unique key for an entry.\n\n=head1 OPTIONS\n\n=over 4\n\n=item B<--ldif-cmd E<lt>dump_ldif_commandE<gt>>\n\nSpecify a command to create a complete LDIF dump of the LDAP directory suitable\nfor a backup.  It should contain all entries necessary to restore the LDAP\ndatabase.  By default C<@sbindir@/safe-ldif> is taken which calls\nC</usr/sbin/slapcat> from OpenLDAP.\n\n=item B<--backup-dir E<lt>backup_directoryE<gt>>\n\nSpecify the directory where the GIT repository for the versioned backup is held.\nDefault: F</var/backups/ldap>\n\n=item B<--commit-msg E<lt>commit_stringE<gt>>\n\nSpecify a custom commit message.  Default: ldap-git-backup\n\n=item B<--commit-date E<lt>date_stringE<gt>>\n\n=item B<--commit-date E<lt>fileE<gt>>\n\nSpecify a custom commit date.  If a file is given its modification time is used.\n\n=item B<--help>\n\nPrints this page.\n\n=back\n\n=head1 AUTHOR\n\nElmar S. Heeb <elmar@heebs.ch>\n\n=cut\n", "#!/usr/bin/env perl\nuse strict;\nuse warnings;\nuse 5.010;\nuse English qw( -no_match_vars );\nuse autodie;\n\nuse Test::More;\n\nrequire \"@abs_top_builddir@/t/test-helper.pm\";\nTest::Helper->import();\n\nuse Git;\nuse File::Temp qw( tempdir );\n\n# start with a non-existing directory and create two\n# consecutive LDIF backups on the new GIT repo\n\nmy $tmpdir = tempdir( CLEANUP => 1 );\nmy $backup_dir = \"$tmpdir/backup-$PID\";\n\nok( (not -e $backup_dir), 'backup directory should not exist at first' );\n\n# ----- first backup -----\nok(\n    system(\n        'perl',\n        \"@abs_top_builddir@/ldap-git-backup\",\n        \"--ldif-cmd=cat @abs_top_srcdir@/t/testdata/data_A1.ldif\",\n        \"--backup-dir=$backup_dir\",\n    ) == 0,\n    'first backup should run'\n);\nok( (-d $backup_dir), 'backup directory should have been created' );\nmy $mode = ((stat($backup_dir))[2]) & 0777; # mask only permission part of mode\n$mode = sprintf(\"%#o\", $mode); # string in octal to help readability of assertion\nis( $mode, '0700', 'new backup directory should be created with mode 0700 (rwx------)' );\nok( (-d \"$backup_dir/.git\"), 'backup directory should be a GIT repository now');\n\ncheck_directory_list($backup_dir, qw(\n    .\n    ..\n    .git\n    20120604153004Z-3816ac9.ldif\n    20120604153004Z-9941228.ldif\n));\n\nmy $repo = Git->repository( Directory => $backup_dir );\nmy @revs = $repo->command('rev-list', '--all');\nis( @revs, 1, 'should have one GIT revision' );\n\n# ----- second backup -----\nok(\n    system(\n        'perl',\n        \"@abs_top_builddir@/ldap-git-backup\",\n        \"--ldif-cmd=cat @abs_top_srcdir@/t/testdata/data_A2.ldif\",\n        \"--backup-dir=$backup_dir\",\n    ) == 0,\n    'second backup should run'\n);\ncheck_directory_list($backup_dir, qw(\n    .\n    ..\n    .git\n    20120604153004Z-3816ac9.ldif\n    20120604153004Z-9941228.ldif\n    20120604161324Z-7ebb002.ldif\n    20120604161334Z-e2a09bd.ldif\n));\n@revs = $repo->command('rev-list', '--all');\nis( @revs, 2, 'should have two GIT revisions' );\n\n# clean up test data\ndone_testing();\n"], "filenames": ["README.mdown", "configure.ac", "debian/changelog", "ldap-git-backup.in", "t/030_git-from-scratch.t.in"], "buggy_code_start_loc": [117, 4, 0, 39, 34], "buggy_code_end_loc": [117, 5, 0, 40, 34], "fixing_code_start_loc": [118, 4, 1, 39, 35], "fixing_code_end_loc": [119, 5, 9, 40, 38], "type": "CWE-276", "message": "ldap-git-backup before 1.0.4 exposes password hashes due to incorrect directory permissions.", "other": {"cve": {"id": "CVE-2013-1425", "sourceIdentifier": "security@debian.org", "published": "2019-11-07T21:15:10.473", "lastModified": "2020-08-18T15:05:57.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ldap-git-backup before 1.0.4 exposes password hashes due to incorrect directory permissions."}, {"lang": "es", "value": "ldap-git-backup versiones anteriores a 1.0.4, expone hashes de contrase\u00f1a debido a permisos de directorio incorrectos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ldap_git_backup_project:ldap_git_backup:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.4", "matchCriteriaId": "9EAC2B41-3042-4401-B7E7-44445BDEB22F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/elmar/ldap-git-backup/commit/a90f3217fce87962db82d212f73af70693087124", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2013-1425", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.mail-archive.com/debian-bugs-dist@lists.debian.org/msg1096253.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/elmar/ldap-git-backup/commit/a90f3217fce87962db82d212f73af70693087124"}}