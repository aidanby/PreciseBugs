{"buggy_code": ["/// Keeps track if the string was percent encoded or not.\n/// Prevents double encoding/double decoding\nenum URLQueryFragment: ExpressibleByStringLiteral, Equatable {\n    init(stringLiteral: String) {\n        self = .urlDecoded(stringLiteral)\n    }\n    \n    case urlEncoded(String)\n    case urlDecoded(String)\n    \n    /// Returns the URL Encoded version\n    func asUrlEncoded() throws -> String {\n        switch self {\n        case .urlEncoded(let encoded):\n            return encoded\n        case .urlDecoded(let decoded):\n            return try decoded.urlEncoded()\n        }\n    }\n    \n    /// Returns the URL Decoded version\n    func asUrlDecoded() throws -> String {\n        switch self {\n        case .urlEncoded(let encoded):\n            guard let decoded = encoded.removingPercentEncoding else {\n                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: \"Unable to remove percent encoding for \\(encoded)\"))\n            }\n            return decoded\n        case .urlDecoded(let decoded):\n            return decoded\n        }\n    }\n    \n    /// Do comparison and hashing using the decoded version as there are multiple ways something can be encoded.\n    /// Certain characters that are not typically encoded could have been encoded making string comparisons between two encodings not work\n    static func == (lhs: URLQueryFragment, rhs: URLQueryFragment) -> Bool {\n        do {\n            return try lhs.asUrlDecoded() == rhs.asUrlDecoded()\n        } catch {\n            return false\n        }\n    }\n    \n    func hash(into: inout Hasher) {\n        do {\n            try self.asUrlDecoded().hash(into: &into)\n        } catch {\n            Logger(label: \"codes.vapor.url\").report(error: error)\n        }\n    }\n}\n\n/// Represents application/x-www-form-urlencoded encoded data.\ninternal struct URLEncodedFormData: ExpressibleByArrayLiteral, ExpressibleByStringLiteral, ExpressibleByDictionaryLiteral, Equatable {\n    var values: [URLQueryFragment]\n    var children: [String: URLEncodedFormData]\n    \n    var hasOnlyValues: Bool {\n        return children.count == 0\n    }\n    \n    var allChildKeysAreSequentialIntegers: Bool {\n        for i in 0...children.count-1 {\n            if !children.keys.contains(String(i)) {\n                return false\n            }\n        }\n        return true\n    }\n\n    init(values: [URLQueryFragment] = [], children: [String: URLEncodedFormData] = [:]) {\n        self.values = values\n        self.children = children\n    }\n    \n    init(stringLiteral: String) {\n        self.values = [.urlDecoded(stringLiteral)]\n        self.children = [:]\n    }\n    \n    init(arrayLiteral: String...) {\n        self.values = arrayLiteral.map({ (s: String) -> URLQueryFragment in\n            return .urlDecoded(s)\n        })\n        self.children = [:]\n    }\n    \n    init(dictionaryLiteral: (String, URLEncodedFormData)...) {\n        self.values = []\n        self.children = Dictionary(uniqueKeysWithValues: dictionaryLiteral)\n    }\n        \n    mutating func set(value: URLQueryFragment, forPath path: [String]) {\n        guard let firstElement = path.first else {\n            self.values.append(value)\n            return\n        }\n        var child: URLEncodedFormData\n        if let existingChild = self.children[firstElement] {\n            child = existingChild\n        } else {\n            child = []\n        }\n        child.set(value: value, forPath: Array(path[1...]))\n        self.children[firstElement] = child\n    }\n}\n", "/// Errors thrown while encoding/decoding `application/x-www-form-urlencoded` data.\nenum URLEncodedFormError: Error {\n    case malformedKey(key: Substring)\n}\n\nextension URLEncodedFormError: AbortError {\n    var status: HTTPResponseStatus {\n        .badRequest\n    }\n\n    var reason: String {\n        switch self {\n        case .malformedKey(let path):\n            return \"Malformed form-urlencoded key encountered: \\(path)\"\n        }\n    }\n}\n", "/// Parses a URL Query `single=value&arr=1&arr=2&obj[key]=objValue` into\ninternal struct URLEncodedFormParser {\n    init() { }\n    \n    func parse(_ query: String) throws -> URLEncodedFormData {\n        let plusDecodedQuery = query.replacingOccurrences(of: \"+\", with: \"%20\")\n        var result: URLEncodedFormData = []\n        for pair in plusDecodedQuery.split(separator: \"&\") {\n            let kv = pair.split(\n                separator: \"=\",\n                maxSplits: 1, // max 1, `foo=a=b` should be `\"foo\": \"a=b\"`\n                omittingEmptySubsequences: false\n            )\n            switch kv.count {\n            case 1:\n                let value = String(kv[0])\n                result.set(value: .urlEncoded(value), forPath: [])\n            case 2:\n                let key = kv[0]\n                let value = String(kv[1])\n                result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)))\n            default:\n                //Empty `&&`\n                continue\n            }\n        }\n        return result\n    }\n\n    func parseKey(key: Substring) throws -> [String] {\n        guard let percentDecodedKey = key.removingPercentEncoding else {\n            throw URLEncodedFormError.malformedKey(key: key)\n        }\n        return try percentDecodedKey.split(separator: \"[\").enumerated().map { (i, part) in \n            switch i {\n            case 0:\n                return String(part)\n            default:\n                guard part.last == \"]\" else {\n                    throw URLEncodedFormError.malformedKey(key: key)\n                }\n                return String(part.dropLast())\n            }\n        }\n    }\n}\n", "@testable import Vapor\nimport XCTest\nimport NIO\n\nfinal class URLEncodedFormTests: XCTestCase {\n    // MARK: Codable\n    \n    func testDecode() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        \n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n    \n    func testDecodeCommaSeparatedArray() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets=Zizek,Foo%2C&dict[a]=1&dict[b]=2&foos=baz&nums=3.14\n        \"\"\"\n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo,\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n    \n    func testDecodeWithoutArrayBrackets() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets=Zizek&pets=Foo&dict[a]=1&dict[b]=2&foos=baz&nums=3.14\n        \"\"\"\n        \n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n\n    func testDecodeArraysToSingleValueFails() throws {\n        let data = \"\"\"\n        name[]=Tanner&age[]=23&pets[]=Zizek&pets[]=Foo&dict[a][]=1&dict[b][]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        XCTAssertThrowsError(try URLEncodedFormDecoder().decode(User.self, from: data))\n    }\n    \n    func testDecodeStringWithCommas() throws {\n        let data = \"\"\"\n        name=Vapor, Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Vapor, Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n\n    func testDecodeWithoutFlagsAsBoolFailsWhenBoolIsRequired() throws {\n        let decoder = URLEncodedFormDecoder(configuration: .init(boolFlags: false))\n        let dataWithoutBool = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        try XCTAssertThrowsError(decoder.decode(User.self, from: dataWithoutBool))\n\n        let dataWithBool = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14&isCool=false\n        \"\"\"\n        let user = try decoder.decode(User.self, from: dataWithBool)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n        XCTAssertEqual(user.isCool, false)\n    }\n\n    func testDecodeIndexedArray() throws {\n        struct Test: Decodable {\n            let array: [String]\n        }\n\n        let data = \"\"\"\n        array[0]=a&array[1]=&array[2]=b&array[3]=\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"\")\n        XCTAssertEqual(test.array[2], \"b\")\n        XCTAssertEqual(test.array[3], \"\")\n    }\n    \n    func testDecodeUnindexedArray() throws {\n        struct Test: Decodable {\n            let array: [String]\n        }\n\n        let data = \"\"\"\n        array[]=a&array[]=&array[]=b&array[]=\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"\")\n        XCTAssertEqual(test.array[2], \"b\")\n        XCTAssertEqual(test.array[3], \"\")\n    }\n\n    func testDecodeIndexedArray_dictionary() throws {\n        struct Test: Decodable {\n            let array: [Int: String]\n        }\n\n        let data = \"\"\"\n        array[0]=a&array[1]=b\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"b\")\n    }\n\n    func testEncode() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder().encode(user)\n        XCTAssert(result.contains(\"pets[]=Zizek\"))\n        XCTAssert(result.contains(\"pets[]=Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos[]=baz\"))\n        XCTAssert(result.contains(\"nums[]=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n\n    func testDateCoding() throws {\n        let toEncode = DateCoding(date: Date(timeIntervalSince1970: 0))\n\n        let decodedDefaultFromUnixTimestamp = try URLEncodedFormDecoder().decode(DateCoding.self, from: \"date=0\")\n        XCTAssertEqual(decodedDefaultFromUnixTimestamp, toEncode)\n\n        let resultForDefault = try URLEncodedFormEncoder().encode(toEncode)\n        XCTAssertEqual(\"date=0.0\", resultForDefault)\n        \n        let decodedDefault = try URLEncodedFormDecoder().decode(DateCoding.self, from: resultForDefault)\n        XCTAssertEqual(decodedDefault, toEncode)\n\n        let resultForTimeIntervalSince1970 = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .secondsSince1970)\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=0.0\", resultForTimeIntervalSince1970)\n        \n        let decodedTimeIntervalSince1970 = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .secondsSince1970)\n        ).decode(DateCoding.self, from: resultForTimeIntervalSince1970)\n        XCTAssertEqual(decodedTimeIntervalSince1970, toEncode)\n        \n        let resultForInternetDateTime = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .iso8601)\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=1970-01-01T00:00:00Z\", resultForInternetDateTime)\n\n        let decodedInternetDateTime = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(DateCoding.self, from: resultForInternetDateTime)\n        XCTAssertEqual(decodedInternetDateTime, toEncode)\n\n        XCTAssertThrowsError(try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(DateCoding.self, from: \"date=bad-date\"))\n                \n        class DateFormatterFactory {\n            private var threadSpecificValue = ThreadSpecificVariable<DateFormatter>()\n            var currentValue: DateFormatter {\n                get {\n                    guard let dateFormatter = threadSpecificValue.currentValue else {\n                        let threadSpecificDateFormatter = self.newDateFormatter\n                        threadSpecificValue.currentValue = threadSpecificDateFormatter\n                        return threadSpecificDateFormatter\n                    }\n                    return dateFormatter\n                }\n            }\n            \n            private var newDateFormatter: DateFormatter {\n                let dateFormatter = DateFormatter()\n                dateFormatter.locale = Locale(identifier: \"en_US_POSIX\")\n                dateFormatter.dateFormat = \"'Date:' yyyy-MM-dd 'Time:' HH:mm:ss 'Timezone:' ZZZZZ\"\n                dateFormatter.timeZone = TimeZone(secondsFromGMT: 0)\n                return dateFormatter\n            }\n        }\n        let factory = DateFormatterFactory()\n        let resultCustom = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .custom({ (date, encoder) in\n                var container = encoder.singleValueContainer()\n                try container.encode(factory.currentValue.string(from: date))\n            }))\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=Date:%201970-01-01%20Time:%2000:00:00%20Timezone:%20Z\", resultCustom)\n        \n        let decodedCustom = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .custom({ (decoder) -> Date in\n                let container = try decoder.singleValueContainer()\n                let string = try container.decode(String.self)\n                guard let date = factory.currentValue.date(from: string) else {\n                    throw DecodingError.dataCorruptedError(in: container, debugDescription: \"Unable to decode date from string '\\(string)'\")\n                }\n                return date\n            }))\n        ).decode(DateCoding.self, from: resultCustom)\n        XCTAssertEqual(decodedCustom, toEncode)\n    }\n\n    func testOptionalDateEncodingAndDecoding_GH2518() throws {\n        let optionalDate: Date? = Date(timeIntervalSince1970: 0)\n        let dateString = \"1970-01-01T00:00:00Z\"\n\n        let resultForDecodedOptionalDate = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(Date?.self, from: dateString)\n        XCTAssertEqual(optionalDate, resultForDecodedOptionalDate)\n\n        let resultForEncodedOptionalDate = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .iso8601)\n        ).encode(optionalDate)\n        XCTAssertEqual(dateString, resultForEncodedOptionalDate)\n    }\n\n    func testEncodedArrayValues() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .values)\n        ).encode(user)\n        XCTAssert(result.contains(\"pets=Zizek\"))\n        XCTAssert(result.contains(\"pets=Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos=baz\"))\n        XCTAssert(result.contains(\"nums=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n\n    func testEncodeArraySeparator() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .separator(\",\"))\n        ).encode(user)\n        XCTAssert(result.contains(\"pets=Zizek,Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos=baz\"))\n        XCTAssert(result.contains(\"nums=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n    \n    func testMultiObjectArrayEncode() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder().encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets][]=Zizek\"))\n        XCTAssert(result.contains(\"users[0][pets][]=Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos][]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums][]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets][]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos][]=baz\"))\n        XCTAssert(result.contains(\"users[1][foos][]=bar\"))\n        XCTAssert(result.contains(\"users[1][nums][]=3.14\"))\n        XCTAssert(result.contains(\"users[1][nums][]=144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n\n    func testMultiObjectValuesArrayEncoding() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .values)\n        ).encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets]=Zizek\"))\n        XCTAssert(result.contains(\"users[0][pets]=Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos]=baz\"))\n        XCTAssert(result.contains(\"users[1][foos]=bar\"))\n        XCTAssert(result.contains(\"users[1][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[1][nums]=144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n    \n    func testInheritanceCoding() throws {\n        let toEncode = ChildClass()\n        toEncode.baseField = \"Base Value\"\n        toEncode.childField = \"Child Field\"\n        let result = try URLEncodedFormEncoder().encode(toEncode)\n        let decoded = try URLEncodedFormDecoder().decode(ChildClass.self, from: result)\n        XCTAssertEqual(decoded, toEncode)\n    }\n\n    func testArraysOfArraysOfObjects() throws {\n        let toEncode = [[User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)]]\n        let result = try URLEncodedFormEncoder().encode(toEncode)\n        let kvs = result.split(separator: \"&\")\n        XCTAssert(kvs.contains(\"0[0][name]=Tanner\"))\n        let decoded = try URLEncodedFormDecoder().decode([[User]].self, from: result)\n        XCTAssertEqual(decoded, toEncode)\n    }\n    \n    func testMultiObjectArrayEncodeWithArraySeparator() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .separator(\",\"))\n        ).encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets]=Zizek,Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos]=baz,bar\"))\n        XCTAssert(result.contains(\"users[1][nums]=3.14,144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n\n    func testCodable() throws {\n        let a = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [], nums: [], isCool: true)\n        let body = try URLEncodedFormEncoder().encode(a)\n        print(body)\n        let b = try! URLEncodedFormDecoder().decode(User.self, from: body)\n        XCTAssertEqual(a, b)\n    }\n    \n    func testDecodeIntArray() throws {\n        let data = \"\"\"\n        array[]=1&array[]=2&array[]=3\n        \"\"\"\n        \n        let content = try URLEncodedFormDecoder().decode([String: [Int]].self, from: data)\n        XCTAssertEqual(content[\"array\"], [1, 2, 3])\n    }\n    \n    func testRawEnum() throws {\n        enum PetType: String, Codable {\n            case cat, dog\n        }\n        struct Pet: Codable {\n            var name: String\n            var type: PetType\n        }\n        let ziz = try URLEncodedFormDecoder().decode(Pet.self, from: \"name=Ziz&type=cat\")\n        XCTAssertEqual(ziz.name, \"Ziz\")\n        XCTAssertEqual(ziz.type, .cat)\n        let string = try URLEncodedFormEncoder().encode(ziz)\n        XCTAssertEqual(string.contains(\"name=Ziz\"), true)\n        XCTAssertEqual(string.contains(\"type=cat\"), true)\n    }\n\n    func testFlagDecodingAsBool() throws {\n        struct Foo: Codable {\n            var flag: Bool\n        }\n        let foo = try URLEncodedFormDecoder().decode(Foo.self, from: \"flag\")\n        XCTAssertEqual(foo.flag, true)\n    }\n\n    /// https://github.com/vapor/url-encoded-form/issues/3\n    func testGH3() throws {\n        struct Foo: Codable {\n            var flag: Bool\n        }\n        let foo = try URLEncodedFormDecoder().decode(Foo.self, from: \"flag=1\")\n        XCTAssertEqual(foo.flag, true)\n    }\n    \n    // MARK: Parser\n    \n    func testBasic() throws {\n        let data = \"hello=world&foo=bar\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"hello\": \"world\", \"foo\": \"bar\"])\n    }\n    \n    func testBasicWithAmpersand() throws {\n        let data = \"hello=world&foo=bar%26bar\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"hello\": \"world\", \"foo\": \"bar&bar\"])\n    }\n    \n    func testDictionary() throws {\n        let data = \"greeting[en]=hello&greeting[es]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greeting\": [\"es\": \"hola\", \"en\": \"hello\"]])\n    }\n    \n    func testArray() throws {\n        let data = \"greetings[]=hello&greetings[]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"\": [\"hello\", \"hola\"]]])\n    }\n  \n    func testArrayWithoutBrackets() throws {\n        let data = \"greetings=hello&greetings=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"hello\", \"hola\"]])\n    }\n  \n    func testSubArray() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub][]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\":[\"sub\":[\"\":[\"hello\", \"hola\"]]]])\n    }\n\n    func testSubArray2() throws {\n        let data = \"greetings[sub]=hello&greetings[sub][]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hello\"], children: [\n                \"\": \"hola\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n    \n    func testSubArray3() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hola\"], children: [\n                \"\": \"hello\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n\n    func testSubArray4() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub]=hola&greetings[sub]=bonjour\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hola\", \"bonjour\"], children: [\n            \"\": \"hello\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n\n    func testBracketsInTheMiddle() throws {\n        let data = \"greetings[sub][][a]=hello&greetings[sub][][a]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"sub\": [\"\": [\"a\": [\"hello\", \"hola\"]]]]])\n    }\n\n    func testSubArrayWithoutBrackets() throws {\n        let data = \"greetings[sub]=hello&greetings[sub]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\":[\"sub\":[\"hello\", \"hola\"]]])\n    }\n\n    func testFlags() throws {\n        let data = \"hello=&foo\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected = URLEncodedFormData(values: [\"foo\"], children:[\n            \"hello\": URLEncodedFormData(\"\")\n        ])\n        XCTAssertEqual(form, expected)\n    }\n    \n    func testPercentDecoding() throws {\n        let data = \"aaa%5B%5D=%2Bbbb%20+ccc&d[]=1&d[]=2\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"aaa\": [\"\": \"+bbb  ccc\"], \"d\": [\"\": [\"1\",\"2\"]]])\n    }\n    \n    func testNestedParsing() throws {\n        // a[][b]=c&a[][b]=c\n        // [a:[[b:c],[b:c]]\n        let data = \"a[b][c][d][hello]=world\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"a\": [\"b\": [\"c\": [\"d\": [\"hello\": \"world\"]]]]])\n    }\n    \n    // MARK: Serializer\n    \n    func testPercentEncoding() throws {\n        let form: URLEncodedFormData = [\"aaa]\": \"+bbb  ccc\"]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"aaa%5D=%2Bbbb%20%20ccc\")\n    }\n\n    func testPercentEncodingWithAmpersand() throws {\n        let form: URLEncodedFormData = [\"aaa\": \"b%26&b\"]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"aaa=b%2526%26b\")\n    }\n\n    func testNested() throws {\n        let form: URLEncodedFormData = [\"a\": [\"b\": [\"c\": [\"d\": [\"hello\": \"world\"]]]]]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"a[b][c][d][hello]=world\")\n    }\n    \n    func testPercentEncodingSpecial() throws {\n        let data = try URLEncodedFormSerializer().serialize([\n            \"test\": \"&;!$'(),/:=?@~\"\n        ])\n        XCTAssertEqual(data, \"test=%26%3B!$'(),/:%3D%3F@~\")\n    }\n}\n\nprivate struct User: Codable, Equatable {\n    var name: String\n    var age: Int\n    var pets: [String]\n    var dict: [String: Int]\n    var foos: [Foo]\n    var nums: [Decimal]\n    var isCool: Bool\n}\n\nclass BaseClass: Codable, Equatable {\n    var baseField: String?\n    static func == (lhs: BaseClass, rhs: BaseClass) -> Bool {\n        return lhs.baseField == rhs.baseField\n    }\n}\n\nclass ChildClass: BaseClass {\n    var childField: String?\n    static func == (lhs: ChildClass, rhs: ChildClass) -> Bool {\n        return lhs.baseField == rhs.baseField && lhs.childField == rhs.childField\n    }\n}\n\nprivate struct Users: Codable, Equatable {\n    var users: [User]\n}\n\nprivate enum Foo: String, Codable {\n    case foo, bar, baz\n}\n\nstruct DateCoding: Codable, Equatable {\n    let date: Date\n}\n"], "fixing_code": ["/// Keeps track if the string was percent encoded or not.\n/// Prevents double encoding/double decoding\nenum URLQueryFragment: ExpressibleByStringLiteral, Equatable {\n    init(stringLiteral: String) {\n        self = .urlDecoded(stringLiteral)\n    }\n    \n    case urlEncoded(String)\n    case urlDecoded(String)\n    \n    /// Returns the URL Encoded version\n    func asUrlEncoded() throws -> String {\n        switch self {\n        case .urlEncoded(let encoded):\n            return encoded\n        case .urlDecoded(let decoded):\n            return try decoded.urlEncoded()\n        }\n    }\n    \n    /// Returns the URL Decoded version\n    func asUrlDecoded() throws -> String {\n        switch self {\n        case .urlEncoded(let encoded):\n            guard let decoded = encoded.removingPercentEncoding else {\n                throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: \"Unable to remove percent encoding for \\(encoded)\"))\n            }\n            return decoded\n        case .urlDecoded(let decoded):\n            return decoded\n        }\n    }\n    \n    /// Do comparison and hashing using the decoded version as there are multiple ways something can be encoded.\n    /// Certain characters that are not typically encoded could have been encoded making string comparisons between two encodings not work\n    static func == (lhs: URLQueryFragment, rhs: URLQueryFragment) -> Bool {\n        do {\n            return try lhs.asUrlDecoded() == rhs.asUrlDecoded()\n        } catch {\n            return false\n        }\n    }\n    \n    func hash(into: inout Hasher) {\n        do {\n            try self.asUrlDecoded().hash(into: &into)\n        } catch {\n            Logger(label: \"codes.vapor.url\").report(error: error)\n        }\n    }\n}\n\n/// Represents application/x-www-form-urlencoded encoded data.\ninternal struct URLEncodedFormData: ExpressibleByArrayLiteral, ExpressibleByStringLiteral, ExpressibleByDictionaryLiteral, Equatable {\n    var values: [URLQueryFragment]\n    var children: [String: URLEncodedFormData]\n    let maxRecursionDepth = 100\n    \n    var hasOnlyValues: Bool {\n        return children.count == 0\n    }\n    \n    var allChildKeysAreSequentialIntegers: Bool {\n        for i in 0...children.count-1 {\n            if !children.keys.contains(String(i)) {\n                return false\n            }\n        }\n        return true\n    }\n\n    init(values: [URLQueryFragment] = [], children: [String: URLEncodedFormData] = [:]) {\n        self.values = values\n        self.children = children\n    }\n    \n    init(stringLiteral: String) {\n        self.values = [.urlDecoded(stringLiteral)]\n        self.children = [:]\n    }\n    \n    init(arrayLiteral: String...) {\n        self.values = arrayLiteral.map({ (s: String) -> URLQueryFragment in\n            return .urlDecoded(s)\n        })\n        self.children = [:]\n    }\n    \n    init(dictionaryLiteral: (String, URLEncodedFormData)...) {\n        self.values = []\n        self.children = Dictionary(uniqueKeysWithValues: dictionaryLiteral)\n    }\n        \n    mutating func set(value: URLQueryFragment, forPath path: [String], recursionDepth: Int) throws {\n        guard recursionDepth <= maxRecursionDepth else {\n            throw URLEncodedFormError.reachedNestingLimit\n        }\n        guard let firstElement = path.first else {\n            self.values.append(value)\n            return\n        }\n        var child: URLEncodedFormData\n        if let existingChild = self.children[firstElement] {\n            child = existingChild\n        } else {\n            child = []\n        }\n        try child.set(value: value, forPath: Array(path[1...]), recursionDepth: recursionDepth + 1)\n        self.children[firstElement] = child\n    }\n}\n", "/// Errors thrown while encoding/decoding `application/x-www-form-urlencoded` data.\nenum URLEncodedFormError: Error {\n    case malformedKey(key: Substring)\n    case reachedNestingLimit\n}\n\nextension URLEncodedFormError: AbortError {\n    var status: HTTPResponseStatus {\n        .badRequest\n    }\n\n    var reason: String {\n        switch self {\n        case .malformedKey(let path):\n            return \"Malformed form-urlencoded key encountered: \\(path)\"\n        case .reachedNestingLimit:\n            return \"The data supplied is too nested\"\n        }\n    }\n}\n", "/// Parses a URL Query `single=value&arr=1&arr=2&obj[key]=objValue` into\ninternal struct URLEncodedFormParser {\n    init() { }\n    \n    func parse(_ query: String) throws -> URLEncodedFormData {\n        let plusDecodedQuery = query.replacingOccurrences(of: \"+\", with: \"%20\")\n        var result: URLEncodedFormData = []\n        for pair in plusDecodedQuery.split(separator: \"&\") {\n            let kv = pair.split(\n                separator: \"=\",\n                maxSplits: 1, // max 1, `foo=a=b` should be `\"foo\": \"a=b\"`\n                omittingEmptySubsequences: false\n            )\n            switch kv.count {\n            case 1:\n                let value = String(kv[0])\n                try result.set(value: .urlEncoded(value), forPath: [], recursionDepth: 0)\n            case 2:\n                let key = kv[0]\n                let value = String(kv[1])\n                try result.set(value: .urlEncoded(value), forPath: try parseKey(key: Substring(key)), recursionDepth: 0)\n            default:\n                //Empty `&&`\n                continue\n            }\n        }\n        return result\n    }\n\n    func parseKey(key: Substring) throws -> [String] {\n        guard let percentDecodedKey = key.removingPercentEncoding else {\n            throw URLEncodedFormError.malformedKey(key: key)\n        }\n        return try percentDecodedKey.split(separator: \"[\").enumerated().map { (i, part) in \n            switch i {\n            case 0:\n                return String(part)\n            default:\n                guard part.last == \"]\" else {\n                    throw URLEncodedFormError.malformedKey(key: key)\n                }\n                return String(part.dropLast())\n            }\n        }\n    }\n}\n", "@testable import Vapor\nimport XCTest\nimport NIO\n\nfinal class URLEncodedFormTests: XCTestCase {\n    // MARK: Codable\n    \n    func testDecode() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        \n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n    \n    func testDecodeCommaSeparatedArray() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets=Zizek,Foo%2C&dict[a]=1&dict[b]=2&foos=baz&nums=3.14\n        \"\"\"\n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo,\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n    \n    func testDecodeWithoutArrayBrackets() throws {\n        let data = \"\"\"\n        name=Tanner&age=23&pets=Zizek&pets=Foo&dict[a]=1&dict[b]=2&foos=baz&nums=3.14\n        \"\"\"\n        \n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n\n    func testDecodeArraysToSingleValueFails() throws {\n        let data = \"\"\"\n        name[]=Tanner&age[]=23&pets[]=Zizek&pets[]=Foo&dict[a][]=1&dict[b][]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        XCTAssertThrowsError(try URLEncodedFormDecoder().decode(User.self, from: data))\n    }\n    \n    func testDecodeStringWithCommas() throws {\n        let data = \"\"\"\n        name=Vapor, Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        let user = try URLEncodedFormDecoder().decode(User.self, from: data)\n        XCTAssertEqual(user.name, \"Vapor, Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n    }\n\n    func testDecodeWithoutFlagsAsBoolFailsWhenBoolIsRequired() throws {\n        let decoder = URLEncodedFormDecoder(configuration: .init(boolFlags: false))\n        let dataWithoutBool = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14\n        \"\"\"\n        try XCTAssertThrowsError(decoder.decode(User.self, from: dataWithoutBool))\n\n        let dataWithBool = \"\"\"\n        name=Tanner&age=23&pets[]=Zizek&pets[]=Foo&dict[a]=1&dict[b]=2&foos[]=baz&nums[]=3.14&isCool=false\n        \"\"\"\n        let user = try decoder.decode(User.self, from: dataWithBool)\n        XCTAssertEqual(user.name, \"Tanner\")\n        XCTAssertEqual(user.age, 23)\n        XCTAssertEqual(user.pets.count, 2)\n        XCTAssertEqual(user.pets.first, \"Zizek\")\n        XCTAssertEqual(user.pets.last, \"Foo\")\n        XCTAssertEqual(user.dict[\"a\"], 1)\n        XCTAssertEqual(user.dict[\"b\"], 2)\n        XCTAssertEqual(user.foos[0], .baz)\n        XCTAssertEqual(user.nums[0], 3.14)\n        XCTAssertEqual(user.isCool, false)\n    }\n\n    func testDecodeIndexedArray() throws {\n        struct Test: Decodable {\n            let array: [String]\n        }\n\n        let data = \"\"\"\n        array[0]=a&array[1]=&array[2]=b&array[3]=\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"\")\n        XCTAssertEqual(test.array[2], \"b\")\n        XCTAssertEqual(test.array[3], \"\")\n    }\n    \n    func testDecodeUnindexedArray() throws {\n        struct Test: Decodable {\n            let array: [String]\n        }\n\n        let data = \"\"\"\n        array[]=a&array[]=&array[]=b&array[]=\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"\")\n        XCTAssertEqual(test.array[2], \"b\")\n        XCTAssertEqual(test.array[3], \"\")\n    }\n\n    func testDecodeIndexedArray_dictionary() throws {\n        struct Test: Decodable {\n            let array: [Int: String]\n        }\n\n        let data = \"\"\"\n        array[0]=a&array[1]=b\n        \"\"\"\n        let test = try URLEncodedFormDecoder().decode(Test.self, from: data)\n        XCTAssertEqual(test.array[0], \"a\")\n        XCTAssertEqual(test.array[1], \"b\")\n    }\n\n    func testEncode() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder().encode(user)\n        XCTAssert(result.contains(\"pets[]=Zizek\"))\n        XCTAssert(result.contains(\"pets[]=Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos[]=baz\"))\n        XCTAssert(result.contains(\"nums[]=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n\n    func testDateCoding() throws {\n        let toEncode = DateCoding(date: Date(timeIntervalSince1970: 0))\n\n        let decodedDefaultFromUnixTimestamp = try URLEncodedFormDecoder().decode(DateCoding.self, from: \"date=0\")\n        XCTAssertEqual(decodedDefaultFromUnixTimestamp, toEncode)\n\n        let resultForDefault = try URLEncodedFormEncoder().encode(toEncode)\n        XCTAssertEqual(\"date=0.0\", resultForDefault)\n        \n        let decodedDefault = try URLEncodedFormDecoder().decode(DateCoding.self, from: resultForDefault)\n        XCTAssertEqual(decodedDefault, toEncode)\n\n        let resultForTimeIntervalSince1970 = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .secondsSince1970)\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=0.0\", resultForTimeIntervalSince1970)\n        \n        let decodedTimeIntervalSince1970 = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .secondsSince1970)\n        ).decode(DateCoding.self, from: resultForTimeIntervalSince1970)\n        XCTAssertEqual(decodedTimeIntervalSince1970, toEncode)\n        \n        let resultForInternetDateTime = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .iso8601)\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=1970-01-01T00:00:00Z\", resultForInternetDateTime)\n\n        let decodedInternetDateTime = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(DateCoding.self, from: resultForInternetDateTime)\n        XCTAssertEqual(decodedInternetDateTime, toEncode)\n\n        XCTAssertThrowsError(try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(DateCoding.self, from: \"date=bad-date\"))\n                \n        class DateFormatterFactory {\n            private var threadSpecificValue = ThreadSpecificVariable<DateFormatter>()\n            var currentValue: DateFormatter {\n                get {\n                    guard let dateFormatter = threadSpecificValue.currentValue else {\n                        let threadSpecificDateFormatter = self.newDateFormatter\n                        threadSpecificValue.currentValue = threadSpecificDateFormatter\n                        return threadSpecificDateFormatter\n                    }\n                    return dateFormatter\n                }\n            }\n            \n            private var newDateFormatter: DateFormatter {\n                let dateFormatter = DateFormatter()\n                dateFormatter.locale = Locale(identifier: \"en_US_POSIX\")\n                dateFormatter.dateFormat = \"'Date:' yyyy-MM-dd 'Time:' HH:mm:ss 'Timezone:' ZZZZZ\"\n                dateFormatter.timeZone = TimeZone(secondsFromGMT: 0)\n                return dateFormatter\n            }\n        }\n        let factory = DateFormatterFactory()\n        let resultCustom = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .custom({ (date, encoder) in\n                var container = encoder.singleValueContainer()\n                try container.encode(factory.currentValue.string(from: date))\n            }))\n        ).encode(toEncode)\n        XCTAssertEqual(\"date=Date:%201970-01-01%20Time:%2000:00:00%20Timezone:%20Z\", resultCustom)\n        \n        let decodedCustom = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .custom({ (decoder) -> Date in\n                let container = try decoder.singleValueContainer()\n                let string = try container.decode(String.self)\n                guard let date = factory.currentValue.date(from: string) else {\n                    throw DecodingError.dataCorruptedError(in: container, debugDescription: \"Unable to decode date from string '\\(string)'\")\n                }\n                return date\n            }))\n        ).decode(DateCoding.self, from: resultCustom)\n        XCTAssertEqual(decodedCustom, toEncode)\n    }\n\n    func testOptionalDateEncodingAndDecoding_GH2518() throws {\n        let optionalDate: Date? = Date(timeIntervalSince1970: 0)\n        let dateString = \"1970-01-01T00:00:00Z\"\n\n        let resultForDecodedOptionalDate = try URLEncodedFormDecoder(\n            configuration: .init(dateDecodingStrategy: .iso8601)\n        ).decode(Date?.self, from: dateString)\n        XCTAssertEqual(optionalDate, resultForDecodedOptionalDate)\n\n        let resultForEncodedOptionalDate = try URLEncodedFormEncoder(\n            configuration: .init(dateEncodingStrategy: .iso8601)\n        ).encode(optionalDate)\n        XCTAssertEqual(dateString, resultForEncodedOptionalDate)\n    }\n\n    func testEncodedArrayValues() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .values)\n        ).encode(user)\n        XCTAssert(result.contains(\"pets=Zizek\"))\n        XCTAssert(result.contains(\"pets=Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos=baz\"))\n        XCTAssert(result.contains(\"nums=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n\n    func testEncodeArraySeparator() throws {\n        let user = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .separator(\",\"))\n        ).encode(user)\n        XCTAssert(result.contains(\"pets=Zizek,Foo\"))\n        XCTAssert(result.contains(\"age=23\"))\n        XCTAssert(result.contains(\"name=Tanner\"))\n        XCTAssert(result.contains(\"dict[a]=1\"))\n        XCTAssert(result.contains(\"dict[b]=2\"))\n        XCTAssert(result.contains(\"foos=baz\"))\n        XCTAssert(result.contains(\"nums=3.14\"))\n        XCTAssert(result.contains(\"isCool=true\"))\n    }\n    \n    func testMultiObjectArrayEncode() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder().encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets][]=Zizek\"))\n        XCTAssert(result.contains(\"users[0][pets][]=Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos][]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums][]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets][]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos][]=baz\"))\n        XCTAssert(result.contains(\"users[1][foos][]=bar\"))\n        XCTAssert(result.contains(\"users[1][nums][]=3.14\"))\n        XCTAssert(result.contains(\"users[1][nums][]=144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n\n    func testMultiObjectValuesArrayEncoding() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .values)\n        ).encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets]=Zizek\"))\n        XCTAssert(result.contains(\"users[0][pets]=Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos]=baz\"))\n        XCTAssert(result.contains(\"users[1][foos]=bar\"))\n        XCTAssert(result.contains(\"users[1][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[1][nums]=144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n    \n    func testInheritanceCoding() throws {\n        let toEncode = ChildClass()\n        toEncode.baseField = \"Base Value\"\n        toEncode.childField = \"Child Field\"\n        let result = try URLEncodedFormEncoder().encode(toEncode)\n        let decoded = try URLEncodedFormDecoder().decode(ChildClass.self, from: result)\n        XCTAssertEqual(decoded, toEncode)\n    }\n\n    func testArraysOfArraysOfObjects() throws {\n        let toEncode = [[User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)]]\n        let result = try URLEncodedFormEncoder().encode(toEncode)\n        let kvs = result.split(separator: \"&\")\n        XCTAssert(kvs.contains(\"0[0][name]=Tanner\"))\n        let decoded = try URLEncodedFormDecoder().decode([[User]].self, from: result)\n        XCTAssertEqual(decoded, toEncode)\n    }\n    \n    func testMultiObjectArrayEncodeWithArraySeparator() throws {\n        let tanner = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [.baz], nums: [3.14], isCool: true)\n        let ravneet = User(name: \"Ravneet\", age: 33, pets: [\"Piku\"], dict: [\"a\": -3, \"b\": 99], foos: [.baz, .bar], nums: [3.14, 144], isCool: true)\n        let usersToEncode = Users(users: [tanner, ravneet])\n        let result = try URLEncodedFormEncoder(\n            configuration: .init(arrayEncoding: .separator(\",\"))\n        ).encode(usersToEncode)\n        XCTAssert(result.contains(\"users[0][pets]=Zizek,Foo\"))\n        XCTAssert(result.contains(\"users[0][age]=23\"))\n        XCTAssert(result.contains(\"users[0][name]=Tanner\"))\n        XCTAssert(result.contains(\"users[0][dict][a]=1\"))\n        XCTAssert(result.contains(\"users[0][dict][b]=2\"))\n        XCTAssert(result.contains(\"users[0][foos]=baz\"))\n        XCTAssert(result.contains(\"users[0][nums]=3.14\"))\n        XCTAssert(result.contains(\"users[0][isCool]=true\"))\n        \n        XCTAssert(result.contains(\"users[1][pets]=Piku\"))\n        XCTAssert(result.contains(\"users[1][age]=33\"))\n        XCTAssert(result.contains(\"users[1][name]=Ravneet\"))\n        XCTAssert(result.contains(\"users[1][dict][a]=-3\"))\n        XCTAssert(result.contains(\"users[1][dict][b]=99\"))\n        XCTAssert(result.contains(\"users[1][foos]=baz,bar\"))\n        XCTAssert(result.contains(\"users[1][nums]=3.14,144\"))\n        XCTAssert(result.contains(\"users[1][isCool]=true\"))\n        \n        let decodedUsers = try URLEncodedFormDecoder().decode(Users.self, from: result)\n        XCTAssertEqual(decodedUsers, usersToEncode)\n    }\n\n    func testCodable() throws {\n        let a = User(name: \"Tanner\", age: 23, pets: [\"Zizek\", \"Foo\"], dict: [\"a\": 1, \"b\": 2], foos: [], nums: [], isCool: true)\n        let body = try URLEncodedFormEncoder().encode(a)\n        print(body)\n        let b = try! URLEncodedFormDecoder().decode(User.self, from: body)\n        XCTAssertEqual(a, b)\n    }\n    \n    func testDecodeIntArray() throws {\n        let data = \"\"\"\n        array[]=1&array[]=2&array[]=3\n        \"\"\"\n        \n        let content = try URLEncodedFormDecoder().decode([String: [Int]].self, from: data)\n        XCTAssertEqual(content[\"array\"], [1, 2, 3])\n    }\n    \n    func testRawEnum() throws {\n        enum PetType: String, Codable {\n            case cat, dog\n        }\n        struct Pet: Codable {\n            var name: String\n            var type: PetType\n        }\n        let ziz = try URLEncodedFormDecoder().decode(Pet.self, from: \"name=Ziz&type=cat\")\n        XCTAssertEqual(ziz.name, \"Ziz\")\n        XCTAssertEqual(ziz.type, .cat)\n        let string = try URLEncodedFormEncoder().encode(ziz)\n        XCTAssertEqual(string.contains(\"name=Ziz\"), true)\n        XCTAssertEqual(string.contains(\"type=cat\"), true)\n    }\n\n    func testFlagDecodingAsBool() throws {\n        struct Foo: Codable {\n            var flag: Bool\n        }\n        let foo = try URLEncodedFormDecoder().decode(Foo.self, from: \"flag\")\n        XCTAssertEqual(foo.flag, true)\n    }\n\n    /// https://github.com/vapor/url-encoded-form/issues/3\n    func testGH3() throws {\n        struct Foo: Codable {\n            var flag: Bool\n        }\n        let foo = try URLEncodedFormDecoder().decode(Foo.self, from: \"flag=1\")\n        XCTAssertEqual(foo.flag, true)\n    }\n    \n    // MARK: Parser\n    \n    func testBasic() throws {\n        let data = \"hello=world&foo=bar\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"hello\": \"world\", \"foo\": \"bar\"])\n    }\n    \n    func testBasicWithAmpersand() throws {\n        let data = \"hello=world&foo=bar%26bar\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"hello\": \"world\", \"foo\": \"bar&bar\"])\n    }\n    \n    func testDictionary() throws {\n        let data = \"greeting[en]=hello&greeting[es]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greeting\": [\"es\": \"hola\", \"en\": \"hello\"]])\n    }\n    \n    func testArray() throws {\n        let data = \"greetings[]=hello&greetings[]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"\": [\"hello\", \"hola\"]]])\n    }\n  \n    func testArrayWithoutBrackets() throws {\n        let data = \"greetings=hello&greetings=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"hello\", \"hola\"]])\n    }\n  \n    func testSubArray() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub][]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\":[\"sub\":[\"\":[\"hello\", \"hola\"]]]])\n    }\n\n    func testSubArray2() throws {\n        let data = \"greetings[sub]=hello&greetings[sub][]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hello\"], children: [\n                \"\": \"hola\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n    \n    func testSubArray3() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hola\"], children: [\n                \"\": \"hello\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n\n    func testSubArray4() throws {\n        let data = \"greetings[sub][]=hello&greetings[sub]=hola&greetings[sub]=bonjour\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected: URLEncodedFormData = [\"greetings\": [\"sub\":\n            URLEncodedFormData(values: [\"hola\", \"bonjour\"], children: [\n            \"\": \"hello\"\n            ])\n        ]]\n        XCTAssertEqual(form, expected)\n    }\n\n    func testBracketsInTheMiddle() throws {\n        let data = \"greetings[sub][][a]=hello&greetings[sub][][a]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\": [\"sub\": [\"\": [\"a\": [\"hello\", \"hola\"]]]]])\n    }\n\n    func testSubArrayWithoutBrackets() throws {\n        let data = \"greetings[sub]=hello&greetings[sub]=hola\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"greetings\":[\"sub\":[\"hello\", \"hola\"]]])\n    }\n\n    func testFlags() throws {\n        let data = \"hello=&foo\"\n        let form = try URLEncodedFormParser().parse(data)\n        let expected = URLEncodedFormData(values: [\"foo\"], children:[\n            \"hello\": URLEncodedFormData(\"\")\n        ])\n        XCTAssertEqual(form, expected)\n    }\n    \n    func testPercentDecoding() throws {\n        let data = \"aaa%5B%5D=%2Bbbb%20+ccc&d[]=1&d[]=2\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"aaa\": [\"\": \"+bbb  ccc\"], \"d\": [\"\": [\"1\",\"2\"]]])\n    }\n    \n    func testNestedParsing() throws {\n        // a[][b]=c&a[][b]=c\n        // [a:[[b:c],[b:c]]\n        let data = \"a[b][c][d][hello]=world\"\n        let form = try URLEncodedFormParser().parse(data)\n        XCTAssertEqual(form, [\"a\": [\"b\": [\"c\": [\"d\": [\"hello\": \"world\"]]]]])\n    }\n    \n    // MARK: Serializer\n    \n    func testPercentEncoding() throws {\n        let form: URLEncodedFormData = [\"aaa]\": \"+bbb  ccc\"]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"aaa%5D=%2Bbbb%20%20ccc\")\n    }\n\n    func testPercentEncodingWithAmpersand() throws {\n        let form: URLEncodedFormData = [\"aaa\": \"b%26&b\"]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"aaa=b%2526%26b\")\n    }\n\n    func testNested() throws {\n        let form: URLEncodedFormData = [\"a\": [\"b\": [\"c\": [\"d\": [\"hello\": \"world\"]]]]]\n        let data = try URLEncodedFormSerializer().serialize(form)\n        XCTAssertEqual(data, \"a[b][c][d][hello]=world\")\n    }\n    \n    func testPercentEncodingSpecial() throws {\n        let data = try URLEncodedFormSerializer().serialize([\n            \"test\": \"&;!$'(),/:=?@~\"\n        ])\n        XCTAssertEqual(data, \"test=%26%3B!$'(),/:%3D%3F@~\")\n    }\n    \n    func testHeavilyNestedArray() throws {\n        var body = \"x\"\n        body += String(repeating: \"[]\", count: 80000)\n        body += \"=y\"\n        struct Foo: Content {}\n        XCTAssertThrowsError(try URLEncodedFormDecoder().decode(Foo.self, from: body))\n        XCTAssert(true, \"We should not have crashed\")\n    }\n}\n\nprivate struct User: Codable, Equatable {\n    var name: String\n    var age: Int\n    var pets: [String]\n    var dict: [String: Int]\n    var foos: [Foo]\n    var nums: [Decimal]\n    var isCool: Bool\n}\n\nclass BaseClass: Codable, Equatable {\n    var baseField: String?\n    static func == (lhs: BaseClass, rhs: BaseClass) -> Bool {\n        return lhs.baseField == rhs.baseField\n    }\n}\n\nclass ChildClass: BaseClass {\n    var childField: String?\n    static func == (lhs: ChildClass, rhs: ChildClass) -> Bool {\n        return lhs.baseField == rhs.baseField && lhs.childField == rhs.childField\n    }\n}\n\nprivate struct Users: Codable, Equatable {\n    var users: [User]\n}\n\nprivate enum Foo: String, Codable {\n    case foo, bar, baz\n}\n\nstruct DateCoding: Codable, Equatable {\n    let date: Date\n}\n"], "filenames": ["Sources/Vapor/URLEncodedForm/URLEncodedFormData.swift", "Sources/Vapor/URLEncodedForm/URLEncodedFormError.swift", "Sources/Vapor/URLEncodedForm/URLEncodedFormParser.swift", "Tests/VaporTests/URLEncodedFormTests.swift"], "buggy_code_start_loc": [56, 3, 17, 576], "buggy_code_end_loc": [105, 14, 22, 576], "fixing_code_start_loc": [57, 4, 17, 577], "fixing_code_end_loc": [109, 18, 22, 586], "type": "CWE-120", "message": "Vapor is a server-side Swift HTTP web framework. When using automatic content decoding an attacker can craft a request body that can make the server crash with the following request: `curl -d \"array[_0][0][array][_0][0][array]$(for f in $(seq 1100); do echo -n '[_0][0][array]'; done)[string][_0]=hello%20world\" http://localhost:8080/foo`. The issue is unbounded, attacker controlled stack growth which will at some point lead to a stack overflow and a process crash. This issue has been fixed in version 4.61.1.", "other": {"cve": {"id": "CVE-2022-31019", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T13:15:08.393", "lastModified": "2022-06-15T16:20:19.410", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vapor is a server-side Swift HTTP web framework. When using automatic content decoding an attacker can craft a request body that can make the server crash with the following request: `curl -d \"array[_0][0][array][_0][0][array]$(for f in $(seq 1100); do echo -n '[_0][0][array]'; done)[string][_0]=hello%20world\" http://localhost:8080/foo`. The issue is unbounded, attacker controlled stack growth which will at some point lead to a stack overflow and a process crash. This issue has been fixed in version 4.61.1."}, {"lang": "es", "value": "Vapor es un framework web Swift HTTP del lado del servidor. Cuando es usada la decodificaci\u00f3n autom\u00e1tica de contenido, un atacante puede dise\u00f1ar un cuerpo de petici\u00f3n que puede hacer que el servidor se bloquee con la siguiente petici\u00f3n: \"curl -d \"array[_0][0][array][_0][array]$(for f in $(seq 1100); do echo -n \"[_0][array]\"; done)[string][_0]=hello%20world\" http://localhost:8080/foo\". El problema es el crecimiento ilimitado de la pila, controlado por el atacante, que en alg\u00fan momento conllevar\u00e1 un desbordamiento de la pila y un bloqueo del proceso. Este problema ha sido corregido en versi\u00f3n 4.61.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vapor:vapor:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.61.1", "matchCriteriaId": "C16F0CBC-8114-4D2C-A7CB-CA31A94FFD0E"}]}]}], "references": [{"url": "https://github.com/vapor/vapor/commit/6c63226a4ab82ce53730eb1afb9ca63866fcf033", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/vapor/vapor/security/advisories/GHSA-qvxg-wjxc-r4gg", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vapor/vapor/commit/6c63226a4ab82ce53730eb1afb9ca63866fcf033"}}