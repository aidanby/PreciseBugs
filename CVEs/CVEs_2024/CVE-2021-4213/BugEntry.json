{"buggy_code": ["package org.mozilla.jss.ssl.javax;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.WritableByteChannel;\nimport java.security.PublicKey;\n\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.X509ExtendedTrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.mozilla.jss.nss.BadCertHandler;\nimport org.mozilla.jss.nss.Buffer;\nimport org.mozilla.jss.nss.BufferProxy;\nimport org.mozilla.jss.nss.Cert;\nimport org.mozilla.jss.nss.CertAuthHandler;\nimport org.mozilla.jss.nss.PR;\nimport org.mozilla.jss.nss.PRErrors;\nimport org.mozilla.jss.nss.PRFDProxy;\nimport org.mozilla.jss.nss.SSL;\nimport org.mozilla.jss.nss.SSLErrors;\nimport org.mozilla.jss.nss.SSLFDProxy;\nimport org.mozilla.jss.nss.SSLPreliminaryChannelInfo;\nimport org.mozilla.jss.nss.SecurityStatusResult;\nimport org.mozilla.jss.pkcs11.PK11Cert;\nimport org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\nimport org.mozilla.jss.ssl.SSLAlertDescription;\nimport org.mozilla.jss.ssl.SSLAlertEvent;\nimport org.mozilla.jss.ssl.SSLAlertLevel;\nimport org.mozilla.jss.ssl.SSLCipher;\nimport org.mozilla.jss.ssl.SSLHandshakeCompletedEvent;\nimport org.mozilla.jss.ssl.SSLVersion;\nimport org.mozilla.jss.ssl.SSLVersionRange;\n\n/**\n * The reference JSSEngine implementation.\n *\n * This JSSEngine implementation is a reference for future JSSEngine\n * implementations, providing a pure-Java overview of what should happen at\n * each step of the init, wrap, and unwrap calls.\n *\n * This implementation allows for extended debug logging, but also debug\n * packet logging. The latter writes out packets sent via wrap(...) and\n * received from unwrap(...) to a port on localhost. This allows one to easily\n * attach Wireshark or tcpdump and inspect the TLS packets, even if errors\n * occur during the test suite (where packets aren't sent over the wire by\n * default). This maintains the client/server relationship, and are logged\n * as being from the appropriate side of the TLS connection.\n */\npublic class JSSEngineReferenceImpl extends JSSEngine {\n    /**\n     * Faked peer information that we pass to the underlying BufferPRFD\n     * implementation.\n     *\n     * This is used by NSS for session resumption. However, because we\n     * don't have the exact peer information at the JSSEngine level, at\n     * best we can guess.\n     */\n    private String peer_info;\n\n    /**\n     * Whether or not the underlying ssl_fd is closed or not.\n     *\n     * Because the socket isn't open yet, we set it to true, to indicate\n     * that no data can be sent or received.\n     */\n    private boolean closed_fd = true;\n\n    /**\n     * Data to be read by the NSS SSL implementation; data from the peer.\n     */\n    private BufferProxy read_buf;\n\n    /**\n     * Data written by the NSS SSL implementation; data sent to the peer.\n     */\n    private BufferProxy write_buf;\n\n    /**\n     * Number of times heuristic has not matched the current state.\n     *\n     * Because this JSSEngine uses a heuristic for determining when the\n     * handshake is completed (or, when we need to switch from WRAP to\n     * UNWRAP), and the heuristic is sometimes wrong, we track how many\n     * times it is in an unknown state. When we hit some internal\n     * threshold, we swap states.\n     */\n    private int unknown_state_count;\n\n    /**\n     * Whether or not to step the handshake.\n     */\n    private boolean step_handshake;\n\n    /**\n     * Whether or not a FINISHED handshake status has been returned to our\n     * caller.\n     *\n     * Because this JSSEngine implementation re-enters the\n     * updateHandshakeState() method potentially multiple times during a\n     * single call to wrap() or unwrap(), we need to know whether or not\n     * the top-level call has returned a FINISHED result. If it hasn't,\n     * we want to keep the state on FINISHED until it has been returned,\n     * otherwise we'll skip straight to NOT_HANDSHAKING, confusing our\n     * peer.\n     */\n    private boolean returned_finished;\n\n    /**\n     * Value of the SSLException we've encountered.\n     */\n    private SSLException ssl_exception;\n\n    /**\n     * Whether or not we've seen an ssl exception.\n     *\n     * Note that, when the exception ultimately gets thrown to the caller,\n     * ssl_exception will be NULLed; this tracks whether or not the connection\n     * has failed previously for some reason.\n     */\n    private boolean seen_exception;\n\n    // In this reference implementation, we allow logging of (encrypted) data\n    // to a Socket for ease of testing. By default, this socket is disabled.\n    private int debug_port;\n    private ServerSocket ss_socket;\n    private Socket s_socket;\n    private Socket c_socket;\n    private InputStream s_istream;\n    private OutputStream s_ostream;\n    private InputStream c_istream;\n    private OutputStream c_ostream;\n\n    /**\n     * Internal name for this JSSEngine instance; most commonly used during\n     * testing.\n     */\n    private String name;\n\n    /**\n     * Automatically generated prefix for debug information.\n     */\n    private String prefix = \"\";\n\n    /**\n     * Runnable task; this performs certificate validation against user-provided\n     * TrustManager instances, passing the result back to NSS.\n     */\n    private CertValidationTask task;\n\n    public JSSEngineReferenceImpl() {\n        super();\n\n        // We were given no hints about our peer so we have no information\n        // to signal to NSS for session resumption.\n        peer_info = null;\n\n        debug(\"JSSEngine: constructor()\");\n    }\n\n    public JSSEngineReferenceImpl(String peerHost, int peerPort) {\n        super(peerHost, peerPort);\n\n        // Signal host and port for session resumption. Only do it when we've\n        // been given valid information.\n        if (peerHost != null && peerPort != 0) {\n            peer_info = peerHost + \":\" + peerPort;\n        }\n\n        // Massive hack for compatibility. In particular, Java usually\n        // specifies the peer information here. NSS uses SSL_SetURL not only\n        // for hostname verification, but also for SNI (!!) on the client.\n        // This means that there's no way to indicate (to those servers like\n        // google.com which require SNI) hostname for the client WITHOUT\n        // also validating the hostname at certificate verification time.\n        // Because the certificate hostname explicitly isn't provided (per\n        // JCA specification) for validation, this might break other clients\n        // which don't provide this information. However, the alternative is\n        // that we never add SNI indication, ever.\n        //\n        // Specifically, this breaks a dead-simple Apache HTTP Components\n        // client:\n        //\n        //     CloseableHttpClient client = HttpClients.createDefault();\n        //     HttpGet request = new HttpGet(\"https://google.com/\");\n        //     HttpResponse response = client.execute(request);\n        //     System.out.println(response);\n        //\n        // Without this, we have no way for the above to work.\n        setHostname(peerHost);\n\n        debug(\"JSSEngine: constructor(\" + peerHost + \", \" + peerPort + \")\");\n    }\n\n    public JSSEngineReferenceImpl(String peerHost, int peerPort,\n                     org.mozilla.jss.crypto.X509Certificate localCert,\n                     org.mozilla.jss.crypto.PrivateKey localKey) {\n        super(peerHost, peerPort, localCert, localKey);\n\n        // Signal host and port for session resumption. Only do it when we've\n        // been given valid information.\n        if (peerHost != null && peerPort != 0) {\n            peer_info = peerHost + \":\" + peerPort;\n        }\n\n        // See above.\n        setHostname(peerHost);\n\n        prefix = prefix + \"[\" + peer_info + \"] \";\n\n        debug(\"JSSEngine: constructor(\" + peerHost + \", \" + peerPort + \", \" + localCert + \", \" + localKey + \")\");\n    }\n\n    private void debug(String msg) {\n        logger.debug(prefix + msg);\n    }\n\n    private void info(String msg) {\n        logger.info(prefix + msg);\n    }\n\n    private void warn(String msg) {\n        logger.warn(prefix + msg);\n    }\n\n    /**\n     * Set the name of this JSSEngine instance, to be printed in logging calls.\n     *\n     * This helps when debugging output from multiple JSSEngine instances at\n     * the same time, such as within the JSS test suite.\n     */\n    public void setName(String name) {\n        this.name = name;\n        prefix = \"[\" + this.name + \"] \" + prefix;\n    }\n\n    private void init() throws SSLException {\n        debug(\"JSSEngine: init()\");\n\n        // Initialize our JSSEngine when we begin to handshake; otherwise,\n        // calls to Set<Option>(...) won't be processed if we initialize it\n        // too early; some of these need to be applied at initialization time\n        // in order to take affect.\n\n        // Ensure we don't leak ssl_fd if we're called multiple times.\n        if (ssl_fd != null && !closed_fd) {\n            is_inbound_closed = true;\n            is_outbound_closed = true;\n            cleanup();\n        }\n\n        ssl_fd = null;\n\n        // Create buffers for interacting with NSS.\n        createBuffers();\n        createBufferFD();\n\n        // Initialize the appropriate end of this connection.\n        if (as_server) {\n            initServer();\n        } else {\n            initClient();\n        }\n\n        // Apply the requested cipher suites and protocols.\n        applyProtocols();\n        applyCiphers();\n        applyConfig();\n\n        // Apply hostname information (via setURL). Note that this is an\n        // extension to SSLEngine for use with NSS; we don't always get this\n        // information and so need to work around it sometimes. See\n        // initClient() for the workaround.\n        applyHosts();\n\n        // Apply TrustManager(s) information for validating the peer's\n        // certificate.\n        applyTrustManagers();\n\n        // Finally, set up any debug logging necessary.\n        createLoggingSocket();\n    }\n\n    private void createBuffers() {\n        debug(\"JSSEngine: createBuffers()\");\n\n        // If the buffers exist, destroy them and then recreate them.\n\n        if (read_buf != null) {\n            Buffer.Free(read_buf);\n        }\n        read_buf = Buffer.Create(BUFFER_SIZE);\n\n        if (write_buf != null) {\n            Buffer.Free(write_buf);\n        }\n        write_buf = Buffer.Create(BUFFER_SIZE);\n    }\n\n    private void createBufferFD() throws SSLException {\n        debug(\"JSSEngine: createBufferFD()\");\n\n        // Create the basis for the ssl_fd from the pair of buffers we created\n        // above.\n\n        PRFDProxy fd;\n        if (peer_info != null && peer_info.length() != 0) {\n            // When we have peer information, indicate it via BufferPRFD so\n            // that NSS can use it for session resumption.\n            fd = PR.NewBufferPRFD(read_buf, write_buf, peer_info.getBytes());\n        } else {\n            fd = PR.NewBufferPRFD(read_buf, write_buf, null);\n        }\n\n        if (fd == null) {\n            throw new SSLException(\"Error creating buffer-backed PRFileDesc.\");\n        }\n\n        SSLFDProxy model = null;\n        if (as_server) {\n            // As a performance improvement, we can copy the server template\n            // (containing the desired key and certificate) rather than\n            // re-creating it from scratch. This saves a significant amount of\n            // time during construction. The implementation lives in JSSEngine,\n            // to be shared by all other JSSEngine implementations.\n            model = getServerTemplate(cert, key);\n        }\n\n        // Initialize ssl_fd from the model Buffer-backed PRFileDesc.\n        ssl_fd = SSL.ImportFD(model, fd);\n        if (ssl_fd == null) {\n            PR.Close(fd);\n            throw new SSLException(\"Error creating SSL socket on top of buffer-backed PRFileDesc.\");\n        }\n\n        fd = null;\n        closed_fd = false;\n\n        // Turn on SSL Alert Logging for the ssl_fd object.\n        int ret = SSL.EnableAlertLogging(ssl_fd);\n        if (ret == SSL.SECFailure) {\n            throw new SSLException(\"Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n        }\n\n        // Turn on notifications of handshake completion. This is the best\n        // source of this information, compared to SSL_SecurityStatus().on;\n        // the latter can indicate \"on\" before the final FINISHED method has\n        // been sent.\n        ret = SSL.EnableHandshakeCallback(ssl_fd);\n        if (ret == SSL.SECFailure) {\n            throw new SSLException(\"Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n        }\n\n        // Pass this ssl_fd to the session object so that we can use\n        // SSL methods to invalidate the session.\n    }\n\n    private void initClient() throws SSLException {\n        debug(\"JSSEngine: initClient()\");\n\n        if (cert != null && key != null) {\n            // NSS uses a callback to check for the client certificate; we\n            // assume we have knowledge of it ahead of time and set it\n            // directly on our SSLFDProxy instance.\n            //\n            // In the future, we could use a KeyManager for inquiring at\n            // selection time which certificate to use.\n            debug(\"JSSEngine.initClient(): Enabling client auth: \" + cert);\n            ssl_fd.SetClientCert(cert);\n            if (SSL.AttachClientCertCallback(ssl_fd) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to attach client certificate auth callback.\");\n            }\n        }\n\n        if (hostname == null) {\n            // When we're a client with no hostname, assume we're running\n            // under standard JDK JCA semantics with no hostname available.\n            // Bypass NSS's hostname check by adding a BadCertHandler, which\n            // check ONLY for the bad hostname error and allows it. This is\n            // safe since this is the LAST check in every (NSS, PKIX, and\n            // JSS) certificate validation step. And, under JCA semantics, we\n            // can assume the caller checks the hostname for us.\n            ssl_fd.badCertHandler = new BypassBadHostname(ssl_fd, 0);\n            if (SSL.ConfigSyncBadCertCallback(ssl_fd) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to attach bad cert callback.\");\n            }\n        }\n    }\n\n    private void initServer() throws SSLException {\n        debug(\"JSSEngine: initServer()\");\n\n        // The only time cert and key are strictly required are when we're\n        // creating a server SSLEngine.\n        if (cert == null || key == null) {\n            throw new IllegalArgumentException(\"JSSEngine: must be initialized with server certificate and key!\");\n        }\n\n        debug(\"JSSEngine.initServer(): \" + cert);\n        debug(\"JSSEngine.initServer(): \" + key);\n\n        session.setLocalCertificates(new PK11Cert[]{ cert } );\n\n        // Create a small server session cache.\n        //\n        // TODO: Make this configurable.\n        initializeSessionCache(1, 100, null);\n\n        configureClientAuth();\n    }\n\n    private void configureClientAuth() throws SSLException {\n        debug(\"SSLFileDesc: \" + ssl_fd);\n\n        // Only specify these on the server side as they affect what we\n        // want from the remote peer in NSS. In the server case, this is\n        // client auth, but if we were to set these on the client, it would\n        // affect server auth.\n        if (SSL.OptionSet(ssl_fd, SSL.REQUEST_CERTIFICATE, want_client_auth || need_client_auth ? 1 : 0) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to configure SSL_REQUEST_CERTIFICATE option: \" + errorText(PR.GetError()));\n        }\n\n        if (SSL.OptionSet(ssl_fd, SSL.REQUIRE_CERTIFICATE, need_client_auth ? SSL.REQUIRE_ALWAYS : 0) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to configure SSL_REQUIRE_CERTIFICATE option: \" + errorText(PR.GetError()));\n        }\n    }\n\n    @Override\n    protected void reconfigureClientAuth() {\n        if (ssl_fd == null || !as_server) {\n            return;\n        }\n\n        // This method is called by JSSEngine's setNeedClientAuth and\n        // setWantClientAuth to inform us of a change in value here. When\n        // we've already configured ssl_fd and we're a server, we need to\n        // inform NSS of this change; this usually indicates Post-Handshake\n        // Authentication is required.\n\n        try {\n            configureClientAuth();\n        } catch (SSLException se) {\n            // We cannot throw SSLException from this helper because it\n            // is called from setNeedClientAuth and setWantClientAuth,\n            // both of which don't disclose SSLException.\n            throw new RuntimeException(se.getMessage(), se);\n        }\n    }\n\n    private void applyCiphers() throws SSLException {\n        debug(\"JSSEngine: applyCiphers()\");\n        // Enabled the ciphersuites specified by setEnabledCipherSuites(...).\n        // When this isn't called, enabled_ciphers will be null, so we'll just\n        // use whatever is enabled by default.\n        if (enabled_ciphers == null) {\n            return;\n        }\n\n        // We need to disable the suite if it isn't present in the list of\n        // suites above. Be lazy about it for the time being and disable all\n        // cipher suites first.\n        for (SSLCipher suite : SSLCipher.values()) {\n            if (SSL.CipherPrefSet(ssl_fd, suite.getID(), false) == SSL.SECFailure) {\n                // warn(\"Unable to set cipher suite preference for \" + suite.name() + \": \" + errorText(PR.GetError()));\n            }\n        }\n\n        // Only enable these particular suites. When a cipher suite can't be\n        // enabled it is most likely due to local policy. Log it. Also log\n        // which ciphers were successfully enabled for debugging purposes.\n        for (SSLCipher suite : enabled_ciphers) {\n            if (suite == null) {\n                continue;\n            }\n\n            if (SSL.CipherPrefSet(ssl_fd, suite.getID(), true) == SSL.SECFailure) {\n                warn(\"Unable to enable cipher suite \" + suite + \": \" + errorText(PR.GetError()));\n            } else {\n                debug(\"Enabled cipher suite \" + suite + \": \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void applyProtocols() throws SSLException {\n        debug(\"JSSEngine: applyProtocols() min_protocol=\" + min_protocol + \" max_protocol=\" + max_protocol);\n        // Enable the protocols only when both a maximum and minimum protocol\n        // version are specified.\n        if (min_protocol == null || max_protocol == null) {\n            debug(\"JSSEngine: applyProtocols() - missing min_protocol or max_protocol; using defaults\");\n            return;\n        }\n\n        // We should bound this range by crypto-policies in the future to\n        // match the current behavior. However, Tomcat already bounds\n        // what we set in the server.xml config by what the JSSEngine\n        // indicates it supports. Because we only indicate we support\n        // what is allowed under crypto-policies, it effective does\n        // this bounding for us.\n        SSLVersionRange vrange = new SSLVersionRange(min_protocol, max_protocol);\n        if (SSL.VersionRangeSet(ssl_fd, vrange) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to set version range: \" + errorText(PR.GetError()));\n        }\n    }\n\n    private void applyConfig() throws SSLException {\n        debug(\"JSSEngine: applyConfig()\");\n        for (Integer key : config.keySet()) {\n            Integer value = config.get(key);\n\n            debug(\"Setting configuration option: \" + key + \"=\" + value);\n            if (SSL.OptionSet(ssl_fd, key, value) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to set configuration value: \" + key + \"=\" + value);\n            }\n        }\n    }\n\n    private void applyHosts() throws SSLException {\n        debug(\"JSSEngine: applyHosts()\");\n\n        // This is most useful for the client end of the connection; this\n        // specifies what to match the server's certificate against.\n        if (hostname != null) {\n            if (SSL.SetURL(ssl_fd, hostname) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure server hostname: \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void applyTrustManagers() throws SSLException {\n        debug(\"JSSEngine: applyTrustManagers()\");\n\n        // If none have been specified, exit early.\n        if (trust_managers == null || trust_managers.length == 0) {\n            // Use the default NSS certificate authentication handler. We\n            // don't need to do anything to use it.\n            debug(\"JSSEngine: no TrustManagers to apply.\");\n            return;\n        }\n\n        // Determine which configuration to use for checking certificates. Our\n        // options are a Native trust manager (most performant) or using a set\n        // of X509TrustManagers.\n        if (trust_managers.length == 1 && trust_managers[0] instanceof JSSNativeTrustManager) {\n            // This is a dummy TrustManager. It signifies that we should call\n            // SSL.ConfigJSSDefaultCertAuthCallback(...) on this SSL\n            // PRFileDesc pointer, letting us utilize the same certificate\n            // validation logic that SSLSocket had.\n            debug(\"JSSEngine: applyTrustManagers() - adding Native TrustManager\");\n            if (SSL.ConfigJSSDefaultCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure JSSNativeTrustManager on this JSSengine: \" + errorText(PR.GetError()));\n            }\n            return;\n        }\n\n        if (as_server) {\n            // We need to manually invoke the async cert auth handler. However,\n            // SSLFDProxy makes this easy for us: our CertAuthHandler derives\n            // from Runnable, so we can reuse it here as well. We can create\n            // it ahead of time though. In this case, checkNeedCertValidation()\n            // is never called.\n            ssl_fd.certAuthHandler = new CertValidationTask(ssl_fd);\n\n            if (SSL.ConfigSyncTrustManagerCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure TrustManager validation on this JSSengine: \" + errorText(PR.GetError()));\n            }\n        } else {\n            // Otherwise, we need a hook from NSS into the SSLFDProxy.\n            //\n            // This hook executes all TrustManagers and if any exception\n            // occurs, we'll turn it into the proper response within NSS.\n            if (SSL.ConfigAsyncTrustManagerCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure TrustManager validation on this JSSengine: \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void createLoggingSocket() throws SSLException {\n        if (debug_port == 0) {\n            return;\n        }\n\n        try {\n            ss_socket = new ServerSocket(debug_port);\n            ss_socket.setReuseAddress(true);\n            ss_socket.setReceiveBufferSize(BUFFER_SIZE);\n\n            c_socket = new Socket(ss_socket.getInetAddress(), ss_socket.getLocalPort());\n            c_socket.setReuseAddress(true);\n            c_socket.setReceiveBufferSize(BUFFER_SIZE);\n            c_socket.setSendBufferSize(BUFFER_SIZE);\n\n            s_socket = ss_socket.accept();\n            s_socket.setReuseAddress(true);\n            s_socket.setReceiveBufferSize(BUFFER_SIZE);\n            s_socket.setSendBufferSize(BUFFER_SIZE);\n\n            s_istream = s_socket.getInputStream();\n            s_ostream = s_socket.getOutputStream();\n\n            c_istream = c_socket.getInputStream();\n            c_ostream = c_socket.getOutputStream();\n        } catch (Exception e) {\n            throw new SSLException(\"Unable to enable debug socket logging! \" + e.getMessage(), e);\n        }\n    }\n\n    private void loggingSocketConsumeAllBytes() {\n        try {\n            int available = s_istream.available();\n            byte[] data = new byte[available];\n            s_istream.read(data);\n        } catch (Exception e) {}\n\n        try {\n            int available = c_istream.available();\n            byte[] data = new byte[available];\n            c_istream.read(data);\n        } catch (Exception e) {}\n    }\n\n    @Override\n    public void beginHandshake() throws SSLException {\n        debug(\"JSSEngine: beginHandshake()\");\n\n        // We assume beginHandshake(...) is the entry point for initializing\n        // the buffer. In particular, wrap(...) / unwrap(...) *MUST* call\n        // beginHandshake(...) if ssl_fd == null.\n\n        // ssl_fd == null <-> we've not initialized anything yet.\n\n        // TLS begins with the client sending a CLIENT_HELLO to the server;\n        // this means that the server needs to unwrap first and the client\n        // needs to wrap first; hence unwrap = as_server. However, if we're\n        // trying to renegotiate this changes. See when ssl_fd != null below.\n        boolean unwrap = as_server;\n\n        if (ssl_fd == null) {\n            // Initialize and create ssl_fd. Throws various RuntimeExceptions\n            // when creation and configuration fails.\n            init();\n            assert(ssl_fd != null);\n\n            // Reset the handshake status, using the new socket and\n            // configuration which was just created. This ensures that\n            // we'll attempt to handshake when ForceHandshake is called.\n            if (SSL.ResetHandshake(ssl_fd, as_server) == SSL.SECFailure) {\n                throw new RuntimeException(\"Unable to begin handshake: \" + errorText(PR.GetError()));\n            }\n        } else {\n            // When ssl_fd exists, we need to re-handshake. Usually, the\n            // server initiates the conversation (especially when we want\n            // to upgrade to requiring client auth from not requiring it).\n            //\n            // This means that when we're a (as_server == true), we should\n            // now wrap, rather than unwrap. So, negate unwrap.\n            unwrap = !as_server;\n\n            // TLS v1.3 differs from all previous versions in that it removed\n            // the ability to completely rehandshake. This makes the first\n            // portion more complicated than the latter.\n            if (session.getSSLVersion() == SSLVersion.TLS_1_3) {\n                // We only send the certificate request as a server when we\n                // need client auth. Otherwise, we'll have to issue a rekey\n                // request.\n                boolean send_certificate_request = as_server && need_client_auth;\n                if (send_certificate_request) {\n                    if (SSL.SendCertificateRequest(ssl_fd) == SSL.SECFailure) {\n                        throw new RuntimeException(\"Unable to issue certificate request on TLSv1.3: \" + errorText(PR.GetError()));\n                    }\n                } else {\n                    // Our best guess at what the user wants is to update\n                    // their keys. They don't need client authentication but\n                    // they explicitly called beginHandshake() again.\n                    if (SSL.KeyUpdate(ssl_fd, false) == SSL.SECFailure) {\n                        throw new RuntimeException(\"Unable to request a new key on TLSv1.3: \" + errorText(PR.GetError()));\n                    }\n                }\n            } else {\n                // On older protocol versions, this is easier: just issue a\n                // new handshake request. This is different from\n                // ResetHandshake as for security reasons, the semantics have\n                // to differ.\n                if (SSL.ReHandshake(ssl_fd, true) == SSL.SECFailure) {\n                    throw new RuntimeException(\"Unable to rehandshake: \" + errorText(PR.GetError()));\n                }\n            }\n        }\n\n        // Make sure we reset the handshake completion status in order for the\n        // callback to work correctly.\n        ssl_fd.handshakeComplete = false;\n\n        // This leaves setting internal variables for HandshakeStatus and\n        // the reporting up from SSLEngine.\n        if (unwrap) {\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n        } else {\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n        }\n\n        // We've begun a new handshake; make sure we step it and reset\n        // our unknown state count to zero.\n        step_handshake = true;\n        unknown_state_count = 0;\n\n        // Lastly, each handshake must return a FINISHED individually,\n        // reset returned_finished to false.\n        returned_finished = false;\n    }\n\n    @Override\n    public void closeInbound() {\n        debug(\"JSSEngine: closeInbound()\");\n\n        if (!is_inbound_closed && ssl_fd != null && !closed_fd) {\n            // Send PR_SHUTDOWN_RCV only once. Additionally, this call\n            // crashes when ssl_fd == NULL or when the socket is already\n            // closed.\n            PR.Shutdown(ssl_fd, PR.SHUTDOWN_RCV);\n        }\n\n        is_inbound_closed = true;\n    }\n\n    @Override\n    public void closeOutbound() {\n        debug(\"JSSEngine: closeOutbound()\");\n\n        if (!is_outbound_closed && ssl_fd != null && !closed_fd) {\n            // Send PR_SHUTDOWN_SEND only once. Additionally, this call\n            // crashes when ssl_fd == NULL or when the socket is already\n            // closed.\n            PR.Shutdown(ssl_fd, PR.SHUTDOWN_SEND);\n        }\n\n        is_outbound_closed = true;\n    }\n\n    public String getHostname() {\n        return hostname;\n    }\n\n    @Override\n    public Runnable getDelegatedTask() {\n        debug(\"JSSEngine: getDelegatedTask()\");\n\n        // task can either contain a task instance or null; task gets\n        // populated also during getHandshakeStatus(), wrap(), and\n        // unwrap(). Since wrap()/unwrap() populate the task early (if\n        // one is needed) -- but can return NEED_TASK later with null\n        // task, this could result in a stall if we didn't also check\n        // here. Best to do it (it is cheap if one isn't necessary),\n        // so that way we always return up-to-date information.\n        if (ssl_fd != null) {\n            // Return code is a boolean, whether or not we have a task.\n            // We can safely ignore it here.\n            checkNeedCertValidation();\n        }\n\n        return task;\n    }\n\n    private boolean checkNeedCertValidation() {\n        debug(\"JSSEngine: checkNeedCertValidation()\");\n        if (task != null) {\n            if (!task.finished) {\n                // Already created runnable task; exit with true status to\n                // show it still needs to be run.\n                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n                return true;\n            }\n\n            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n\n            // Since the task has finished, we now need to inform NSS about\n            // the results of our certificate validation step.\n            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n                String msg = \"Got unexpected failure finishing cert \";\n                msg += \"authentication in NSS. Returned code \";\n                msg += task.result;\n                throw new RuntimeException(msg);\n            }\n\n            // After checking certificates, our best guess will be that we\n            // need to run wrap again. This is because we either need to\n            // inform the caller of an error that occurred, or continue the\n            // handshake. Worst case, we'll call updateHandshakeState() and\n            // it'll correct our mistake eventually.\n\n            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n\n            task = null;\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            ssl_fd.needCertValidation = false;\n\n            return false;\n        }\n\n        if (ssl_fd == null) {\n            // If we don't have a SSLFDProxy instance, nothing we can do but\n            // skip checking if the task exists. Return false to show that\n            // we don't yet have a runnable task.\n            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n            return false;\n        }\n\n        if (!ssl_fd.needCertValidation) {\n            // We don't yet need certificate validation. Don't create a\n            // runnable task for now.\n            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n            return false;\n        }\n\n        debug(\"JSSEngine: checkNeedCertValidation() - creating task\");\n\n        // OK, time to create our runnable task.\n        task = new CertValidationTask(ssl_fd);\n\n        // Update our handshake state so we know what to do next.\n        handshake_state = SSLEngineResult.HandshakeStatus.NEED_TASK;\n\n        return true;\n    }\n\n    @Override\n    public SSLEngineResult.HandshakeStatus getHandshakeStatus() {\n        debug(\"JSSEngine: getHandshakeStatus()\");\n\n        // If task is NULL, we need to update the state to check if the\n        // task has been \"run\". Even if it isn't, it would be good to\n        // update the status here as well. However, we DO NOT want to\n        // call updateHandshakeState() in the event we have a task to\n        // run: we need to run it still!\n        if (checkNeedCertValidation()) {\n            return handshake_state;\n        }\n\n        // Always update the handshake state; this ensures that we catch\n        // looping due to missing data and flip our expected direction.\n        updateHandshakeState();\n\n        return handshake_state;\n    }\n\n    @Override\n    public SecurityStatusResult getStatus() {\n        if (ssl_fd == null) {\n            return null;\n        }\n\n        return SSL.SecurityStatus(ssl_fd);\n    }\n\n    /**\n     * Enable writing of encrypted TLS traffic to the specified port in a\n     * client-server relationship (mirroring the actual role of this\n     * SSLEngine) to enable debugging with Wireshark.\n     */\n    public void enableSafeDebugLogging(int port) {\n        debug_port = port;\n    }\n\n    private int computeSize(ByteBuffer[] buffers, int offset, int length) throws IllegalArgumentException {\n        debug(\"JSSEngine: computeSize()\");\n        int result = 0;\n\n        if (buffers == null || buffers.length == 0) {\n            debug(\"JSSEngine.compueSize(): no buffers - result=\" + result);\n            return result;\n        }\n\n        // Semantics of arguments:\n        //\n        // - buffers is where we're reading/writing application data.\n        // - offset is the index of the first buffer we read/write to.\n        // - length is the total number of buffers we read/write to.\n        //\n        // We use a relative index and an absolute index to handle these\n        // constraints.\n        for (int rel_index = 0; rel_index < length; rel_index++) {\n            int index = offset + rel_index;\n            if (index >= buffers.length) {\n                throw new IllegalArgumentException(\"offset (\" + offset + \") or length (\" + length + \") exceeds contract based on number of buffers (\" + buffers.length + \")\");\n            }\n\n            if (rel_index == 0 && buffers[index] == null) {\n                // If our first buffer is null, assume the rest are and skip\n                // everything else. This commonly happens when null is passed\n                // as the src parameter to wrap or when null is passed as the\n                // dst parameter to unwrap.\n                debug(\"JSSEngine.computeSize(): null first buffer - result=\" + result);\n                return result;\n            }\n\n            if (buffers[index] == null) {\n                throw new IllegalArgumentException(\"Buffer at index \" + index + \" is null.\");\n            }\n\n            result += buffers[index].remaining();\n        }\n\n        debug(\"JSSEngine.computeSize(): result=\" + result);\n\n        return result;\n    }\n\n    private int putData(byte[] data, ByteBuffer[] buffers, int offset, int length) {\n        debug(\"JSSEngine: putData()\");\n        // Handle the rather unreasonable task of moving data into the buffers.\n        // We assume the buffer parameters have already been checked by\n        // computeSize(...); that is, offset/length contracts hold and that\n        // each buffer in the range is non-null.\n        //\n        // We also assume that data.length does not exceed the total number\n        // of bytes the buffers can hold; this is what computeSize(...)'s\n        // return value should ensure. This directly means that the inner\n        // while loop won't exceed the bounds of offset+length.\n\n        int buffer_index = offset;\n        int data_index = 0;\n\n        if (data == null || buffers == null) {\n            return data_index;\n        }\n\n        for (data_index = 0; data_index < data.length;) {\n            // Ensure we have have a buffer with capacity.\n            while ((buffers[buffer_index] == null || buffers[buffer_index].remaining() <= 0) &&\n                    (buffer_index < offset + length)) {\n                buffer_index += 1;\n            }\n            if (buffer_index >= offset + length) {\n                break;\n            }\n\n            // Compute the size of the put: it is the minimum of the space\n            // remaining in this buffer and the bytes remaining in the data\n            // array.\n            int put_size = buffers[buffer_index].remaining();\n            if (put_size > (data.length - data_index)) {\n                put_size = data.length - data_index;\n            }\n\n            buffers[buffer_index].put(data, data_index, put_size);\n            data_index += put_size;\n        }\n\n        return data_index;\n    }\n\n    private SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n\n        // Prefer inbound alerts to outbound alerts.\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\t    event.setEngine(this);\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            // Fire inbound alert prior to raising any exception.\n            fireAlertReceived(event);\n\n            // Not every SSL Alert is fatal; toException() only returns a\n            // SSLException on fatal instances. We shouldn't return NULL\n            // early without checking all alerts.\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n            event.setEngine(this);\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n\n            // Fire outbound alert prior to raising any exception. Note that\n            // this still triggers after this alert is written to the output\n            // wire buffer.\n            fireAlertSent(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        return null;\n    }\n\n    private void updateHandshakeState() {\n        debug(\"JSSEngine: updateHandshakeState()\");\n\n        // If we've previously seen an exception, we should just return\n        // here; there's already an alert on the wire, so there's no point\n        // in checking for new ones and/or stepping the handshake: it has\n        // already failed.\n        if (seen_exception) {\n            return;\n        }\n\n        // If we're already done, we should check for SSL ALerts.\n        if (!step_handshake && handshake_state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            debug(\"JSSEngine.updateHandshakeState() - not handshaking\");\n            unknown_state_count = 0;\n\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n            return;\n        }\n\n        // If we've previously finished handshaking, then move to\n        // NOT_HANDSHAKING. Now is also a good time to check for any\n        // alerts.\n        if (!step_handshake && handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            debug(\"JSSEngine.updateHandshakeState() - FINISHED to NOT_HANDSHAKING\");\n\n            // Because updateHandshakeState() gets called multiple times within\n            // a single wrap/unwrap invocation, we need to wait for the FINISHED\n            // message to be returned (from wrap/unwrap) before moving it to\n            // NOT_HANDSHAKING. Otherwise, callers will miss that the handshake\n            // has completed. We aren't in an unknown state though and we don't\n            // need to call SSL.ForceHandshake().\n            if (returned_finished) {\n                handshake_state = SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;\n            }\n\n            unknown_state_count = 0;\n\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n            return;\n        }\n\n        // Since we're not obviously done handshaking, and the last time we\n        // were called, we were still handshaking, step the handshake.\n        debug(\"JSSEngine.updateHandshakeState() - forcing handshake\");\n        if (SSL.ForceHandshake(ssl_fd) == SSL.SECFailure) {\n            int error_value = PR.GetError();\n\n            if (error_value != PRErrors.WOULD_BLOCK_ERROR) {\n                debug(\"JSSEngine.updateHandshakeState() - FATAL \" + getStatus());\n\n                ssl_exception = new SSLHandshakeException(\"Error duing SSL.ForceHandshake() :: \" + errorText(error_value));\n                seen_exception = true;\n\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n                return;\n            }\n        }\n\n        // Check if we've just finished handshaking.\n        debug(\"JSSEngine.updateHandshakeState() - read_buf.read=\" + Buffer.ReadCapacity(read_buf) + \" read_buf.write=\" + Buffer.WriteCapacity(read_buf) + \" write_buf.read=\" + Buffer.ReadCapacity(write_buf) + \" write_buf.write=\" + Buffer.WriteCapacity(write_buf));\n\n        // Set NEED_WRAP when we have data to send to the client.\n        if (Buffer.ReadCapacity(write_buf) > 0 && handshake_state != SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n            // Can't write; to read, we need to call wrap to provide more\n            // data to write.\n            debug(\"JSSEngine.updateHandshakeState() - can write \" + Buffer.ReadCapacity(write_buf) + \" bytes, NEED_WRAP to process\");\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            unknown_state_count = 0;\n            return;\n        }\n\n        // Delay the check to see if the handshake finished until after we\n        // send the CLIENT FINISHED message and recieved the SERVER FINISHED\n        // message if we're a client. Otherwise, wait to send SERVER FINISHED\n        // message. This is because NSS thinks the handshake has finished\n        // (according to SecurityStatusResult since it has sent the massage)\n        // but we haven't yet gotten around to doing so if we're in a WRAP()\n        // call.\n        if (ssl_fd.handshakeComplete && Buffer.ReadCapacity(write_buf) == 0) {\n            debug(\"JSSEngine.updateHandshakeState() - handshakeComplete is \" + ssl_fd.handshakeComplete + \", so we've just finished handshaking\");\n            step_handshake = false;\n            handshake_state = SSLEngineResult.HandshakeStatus.FINISHED;\n            unknown_state_count = 0;\n\n            // Only update peer certificate chain when we've finished\n            // handshaking.\n            try {\n                PK11Cert[] peer_chain = SSL.PeerCertificateChain(ssl_fd);\n                session.setPeerCertificates(peer_chain);\n            } catch (Exception e) {\n                String msg = \"Unable to get peer's certificate chain: \";\n                msg += e.getMessage();\n\n                seen_exception = true;\n                ssl_exception = new SSLException(msg, e);\n            }\n\n            // Also update our session information here.\n            session.refreshData();\n\n            // Finally, fire any handshake completed event listeners now.\n            fireHandshakeComplete(new SSLHandshakeCompletedEvent(this));\n\n            return;\n        }\n\n        if (Buffer.ReadCapacity(read_buf) == 0 && handshake_state != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n            // Set NEED_UNWRAP when we have no data to read from the client.\n            debug(\"JSSEngine.updateHandshakeState() - can read \" + Buffer.ReadCapacity(read_buf) + \" bytes, NEED_UNWRAP to give us more\");\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n            unknown_state_count = 0;\n            return;\n        }\n\n        unknown_state_count += 1;\n        if (unknown_state_count >= 4) {\n            if (handshake_state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n            } else {\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            }\n            unknown_state_count = 1;\n        }\n    }\n\n    private void logUnwrap(ByteBuffer src) {\n        if (debug_port <= 0 || src == null || src.remaining() == 0) {\n            return;\n        }\n\n        loggingSocketConsumeAllBytes();\n\n        OutputStream stream = c_ostream;\n\n        if (!as_server) {\n            // An unwrap from the client means we write data to the outbound\n            // side of the server socket.\n            stream = s_ostream;\n        }\n\n        WritableByteChannel channel = Channels.newChannel(stream);\n\n        int pos = src.position();\n        try {\n            debug(\"JSSEngine: logUnwrap() - writing \" + src.remaining() + \" bytes.\");\n            channel.write(src);\n            stream.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to log contents of unwrap's src to debug socket: \" + e.getMessage(), e);\n        } finally {\n            src.position(pos);\n        }\n    }\n\n    @Override\n    public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int length) throws IllegalArgumentException, SSLException {\n        debug(\"JSSEngine: unwrap(ssl_fd=\" + ssl_fd + \")\");\n\n        // In this method, we're taking the network wire contents of src and\n        // passing them as the read side of our buffer. If there's any data\n        // for us to read from the remote peer (via ssl_fd), we place it in\n        // the various dsts.\n        //\n        // However, we also need to detect if the handshake is still ongoing;\n        // if so, we can't send data (from src) until then.\n\n        if (ssl_fd == null) {\n            beginHandshake();\n        }\n\n        // Before going much further, check to see if we need to run a\n        // delegated task. So far, the only delegated tasks we have are\n        // for checking TrustManagers.\n        if (checkNeedCertValidation()) {\n            return new SSLEngineResult(SSLEngineResult.Status.OK, handshake_state, 0, 0);\n        }\n\n        boolean handshake_already_complete = ssl_fd.handshakeComplete;\n        int src_capacity = src.remaining();\n\n        logUnwrap(src);\n\n        // Order of operations:\n        //  1. Read data from srcs\n        //  2. Update handshake status\n        //  3. Write data to dsts\n        //\n        // Since srcs is coming from the data, it could affect our ability to\n        // handshake. It could also affect our ability to write data to dsts,\n        // as src could provide new data to decrypt. When no new data from src\n        // is present, we could have residual steps in handshake(), in which\n        // case no data would be written to dsts. Lastly, even if no new data\n        // from srcs, could still have residual data in read_buf, so we should\n        // attempt to read from the ssl_fd.\n        //\n        // In order to handle large buffer sizes, wrap everything in a\n        // do-while loop.\n\n        // wire_data is the number of bytes from src we've written into\n        // read_buf.\n        int wire_data = 0;\n\n        // Actual amount of data written to the buffer.\n        int app_data = 0;\n\n        int this_src_write;\n        int this_dst_write;\n\n        do {\n            this_src_write = 0;\n            this_dst_write = 0;\n\n            if (src != null) {\n                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n\n                // When we have data from src, write it to read_buf.\n                if (this_src_write > 0) {\n                    byte[] wire_buffer = new byte[this_src_write];\n                    src.get(wire_buffer);\n\n                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n\n                    wire_data += this_src_write;\n                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n                }\n            }\n\n            // In the above, we should always try to read and write data. Check to\n            // see if we need to step our handshake process or not.\n            updateHandshakeState();\n\n            int max_dst_size = computeSize(dsts, offset, length);\n            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n            int error = PR.GetError();\n            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n            if (app_buffer != null) {\n                this_dst_write = putData(app_buffer, dsts, offset, length);\n                app_data += this_dst_write;\n            } else if (max_dst_size > 0) {\n                // There are two scenarios we need to ignore here:\n                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n                //     not to block. Usually this means we don't have space\n                //     to write any more data.\n                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n                //     underling cause was fatal, we'd catch it after exiting\n                //     the do-while loop, in checkSSLAlerts().\n                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                    ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                    seen_exception = true;\n                }\n            }\n        } while (this_src_write != 0 || this_dst_write != 0);\n\n        if (seen_exception == false && ssl_exception == null) {\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n        }\n\n        // Before we return, check if an exception occurred and throw it if\n        // one did.\n        if (ssl_exception != null) {\n            info(\"JSSEngine.unwrap() - Got SSLException: \" + ssl_exception);\n            SSLException excpt = ssl_exception;\n            ssl_exception = null;\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            tryCleanup();\n            throw excpt;\n        }\n\n        SSLEngineResult.Status handshake_status = SSLEngineResult.Status.OK;\n\n\n        if (is_inbound_closed) {\n            debug(\"Socket is currently closed.\");\n            handshake_status = SSLEngineResult.Status.CLOSED;\n        } else if (handshake_already_complete && src_capacity > 0 && app_data == 0) {\n            debug(\"Underflowed: produced no application data when we expected to.\");\n            handshake_status = SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        // Need a way to introspect the open/closed state of the TLS\n        // connection.\n\n        debug(\"JSSEngine.unwrap() - Finished\");\n        debug(\" - Status: \" + handshake_status);\n        debug(\" - Handshake State: \" + handshake_state);\n        debug(\" - wire_data: \" + wire_data);\n        debug(\" - app_data: \" + app_data);\n\n        if (handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            returned_finished = true;\n        }\n\n        tryCleanup();\n        return new SSLEngineResult(handshake_status, handshake_state, wire_data, app_data);\n    }\n\n    public int writeData(ByteBuffer[] srcs, int offset, int length) {\n        debug(\"JSSEngine: writeData()\");\n        // This is the tough end of reading/writing. There's two potential\n        // places buffering could occur:\n        //\n        //  - Inside the NSS library (unclear if this happens).\n        //  - write_buf\n        //\n        // So when we call PR.Write(ssl_fd, data), it isn't guaranteed that\n        // we can write all of data to ssl_fd (unlike with all our other read\n        // or write operations where we have a clear bound). In the event that\n        // our Write call is truncated, we have to put data back into the\n        // buffer from whence it was read.\n        //\n        // However, we do use Buffer.WriteCapacity(write_buf) as a proxy\n        // metric for how much we can write without having to place data back\n        // in a src buffer.\n        //\n        // When we don't perform an actual NSPR write call, make a dummy\n        // invocation to ensure we always attempt to flush these buffers.\n        int data_length = 0;\n\n        int index = offset;\n        int max_index = offset + length;\n\n        boolean attempted_write = false;\n\n        while (index < max_index) {\n            // If we don't have any remaining bytes in this buffer, skip it.\n            if (srcs[index] == null || srcs[index].remaining() <= 0) {\n                index += 1;\n                continue;\n            }\n            debug(\"JSSEngine.writeData(): index=\" + index + \" max_index=\" + max_index);\n\n            // We expect (i.e., need to construct a buffer) to write up to\n            // this much. Note that this is non-zero since we're taking the\n            // max here and we guarantee with the previous statement that\n            // srcs[index].remaining() > 0. There's no point in getting more\n            // than BUFFER_SIZE bytes either; so cap at the minimum of the\n            // two sizes.\n            int expected_write = Math.min(srcs[index].remaining(), BUFFER_SIZE);\n            debug(\"JSSEngine.writeData(): expected_write=\" + expected_write + \" write_cap=\" + Buffer.WriteCapacity(write_buf) + \" read_cap=\" + Buffer.ReadCapacity(read_buf));\n\n            // Get data from our current srcs[index] buffer.\n            byte[] app_data = new byte[expected_write];\n            srcs[index].get(app_data);\n\n            // Actual amount written. Since this is a PR.Write call, mark\n            // attempted_write.\n            int this_write = PR.Write(ssl_fd, app_data);\n            attempted_write = true;\n\n            // Reset our buffer's position in event of sub-optimal write.\n            if (this_write < expected_write) {\n                int pos = srcs[index].position();\n\n                // When this_write < 0, we want to reset to the beginning\n                // because we assume we haven't written any data due to an\n                // error before writing.\n                int delta = expected_write - Math.max(0, this_write);\n\n                srcs[index].position(pos - delta);\n            }\n\n            debug(\"JSSEngine.writeData(): this_write=\" + this_write);\n            if (this_write < 0) {\n                int error = PR.GetError();\n                if (error == PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                    debug(\"NSPR reports outbound socket is shutdown.\");\n                    is_outbound_closed = true;\n                } else if (error != PRErrors.WOULD_BLOCK_ERROR) {\n                    throw new RuntimeException(\"Unable to write to internal ssl_fd: \" + errorText(PR.GetError()));\n                }\n\n                break;\n            }\n\n            data_length += this_write;\n\n            if (this_write < expected_write) {\n                // If we didn't get an error but we got less than our expected\n                // write, it is best to exit to give us time to drain the\n                // buffers before attempting another write. We're guaranteed\n                // to be called again because we wrote a non-zero amount here.\n                break;\n            }\n        }\n\n        // When we didn't call PR.Write, invoke a dummy call to PR.Write to\n        // ensure we always attempt to write to push data from NSS's internal\n        // buffers into our network buffers.\n        if (!attempted_write) {\n            PR.Write(ssl_fd, null);\n        }\n\n        debug(\"JSSEngine.writeData(): data_length=\" + data_length);\n\n        return data_length;\n    }\n\n    private void logWrap(ByteBuffer dst) {\n        if (debug_port <= 0 || dst == null || dst.remaining() == 0) {\n            return;\n        }\n\n        loggingSocketConsumeAllBytes();\n\n        OutputStream stream = s_ostream;\n\n        if (!as_server) {\n            // A wrap from the client means we write data to the outbound\n            // side of the client socket.\n            stream = c_ostream;\n        }\n\n        WritableByteChannel channel = Channels.newChannel(stream);\n\n        int pos = dst.position();\n        try {\n            dst.flip();\n            debug(\"JSSEngine: logWrap() - writing \" + dst.remaining() + \" bytes.\");\n            channel.write(dst);\n            stream.flush();\n            dst.flip();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to log contents of wrap's dst to debug socket: \" + e.getMessage(), e);\n        } finally {\n            dst.position(pos);\n        }\n    }\n\n    @Override\n    public SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws IllegalArgumentException, SSLException {\n        debug(\"JSSEngine: wrap(ssl_fd=\" + ssl_fd + \")\");\n        // In this method, we're taking the application data from the various\n        // srcs and writing it to the remote peer (via ssl_fd). If there's any\n        // data for us to send to the remote peer, we place it in dst.\n        //\n        // However, we also need to detect if the handshake is still ongoing;\n        // if so, we can't send data (from src) until then.\n\n        if (ssl_fd == null) {\n            beginHandshake();\n        }\n\n        // Before going much further, check to see if we need to run a\n        // delegated task. So far, the only delegated tasks we have are\n        // for checking TrustManagers.\n        if (checkNeedCertValidation()) {\n            return new SSLEngineResult(SSLEngineResult.Status.OK, handshake_state, 0, 0);\n        }\n\n        // Order of operations:\n        //  1. Step the handshake\n        //  2. Write data from srcs to ssl_fd\n        //  3. Write data from write_buf to dst\n        //\n        // This isn't technically locally optimal: it could be that write_buf\n        // is full while we're handshaking so step 1 could be a no-op, but\n        // we could read from write_buf and step the handshake then. However,\n        // on our next call to wrap() would also step the handshake, which\n        // two in a row would almost certainly result in one being a no-op.\n        // Both steps 1 and 2 could write data to dsts. At best 2 will fail if\n        // write_buf is full, however, we'd again end up calling wrap() again\n        // anyways.\n        //\n        // Note that allowances are given for underflow but not overflow: a\n        // single call to PR.Write() might not suffice for step 2; we might\n        // need to execute step 3 and come back and re-execute steps 2 and 3\n        // multiple times in order to send all data. However, since this could\n        // technically also be true of the handshake itself, wrap everything\n        // in the do-while loop.\n\n        // Actual amount of data read from srcs (and written to ssl_fd). This\n        // is determined by the PR.Write(...) call on ssl_fd.\n        int app_data = 0;\n\n        // wire_data is the number of bytes written to dst. This is bounded\n        // above by two fields: the number of bytes we can read from\n        // write_buf, and the size of dst, if present.\n        int wire_data = 0;\n\n        if (is_inbound_closed && !is_outbound_closed) {\n            closeOutbound();\n        }\n\n        int this_src_write;\n        int this_dst_write;\n        do {\n            this_src_write = 0;\n            this_dst_write = 0;\n\n            // First we try updating the handshake state.\n            updateHandshakeState();\n            if (ssl_exception == null && seen_exception) {\n                if (handshake_state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                    // In the event that:\n                    //\n                    //      1. We saw an exception in the past\n                    //          --> (seen_exception is true),\n                    //      2. We've already thrown it from wrap or unwrap,\n                    //          --> (ssl_exception is null),\n                    //      3. We were previously handshaking\n                    //          --> (handshake_state is a handshaking state),\n                    //\n                    // we need to make sure wrap is called again to ensure the\n                    // alert is actually written to the wire. So here we are,\n                    // in wrap and the above hold true; we can mark the handshake\n                    // status as \"FINISHED\" (because well, it is over due to the\n                    // alert). That leaves the return state to be anything other\n                    // than OK to indicate the error.\n                    handshake_state = SSLEngineResult.HandshakeStatus.FINISHED;\n                }\n            }\n\n            // Try writing data from srcs to the other end of the connection. Note\n            // that we always attempt this, even if the handshake isn't yet marked\n            // as finished. This is because we need the call to PR.Write(...) to\n            // tell if an alert is getting sent.\n            this_src_write = writeData(srcs, offset, length);\n            if (this_src_write > 0) {\n                app_data += this_src_write;\n                debug(\"JSSEngine.wrap(): wrote \" + this_src_write + \" from srcs to buffer.\");\n            } else {\n                debug(\"JSSEngine.wrap(): not writing from srcs to buffer: this_src_write=\" + this_src_write);\n            }\n\n            if (dst != null) {\n                // Get an estimate for the expected write to dst; this is\n                // the minimum of write_buf read capacity and dst.remaining\n                // capacity.\n                this_dst_write = Math.min((int) Buffer.ReadCapacity(write_buf), dst.remaining());\n\n                // Try reading data from write_buf to dst; always do this, even\n                // if we didn't write.\n                if (this_dst_write > 0) {\n                    byte[] wire_buffer = Buffer.Read(write_buf, this_dst_write);\n                    dst.put(wire_buffer);\n                    this_dst_write = wire_buffer.length;\n                    wire_data += this_dst_write;\n\n                    debug(\"JSSEngine.wrap() - Wrote \" + wire_buffer.length + \" bytes to dst.\");\n                } else {\n                    debug(\"JSSEngine.wrap(): not writing from write_buf into dst: this_dst_write=0 write_buf.read_capacity=\" + Buffer.ReadCapacity(write_buf) + \" dst.remaining=\" + dst.remaining());\n                }\n            } else {\n                debug(\"JSSEngine.wrap(): not writing from write_buf into NULL dst\");\n            }\n        } while (this_src_write != 0 || this_dst_write != 0);\n\n        if (seen_exception == false && ssl_exception == null) {\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n        }\n\n        logWrap(dst);\n\n        // Before we return, check if an exception occurred and throw it if\n        // one did.\n        if (ssl_exception != null) {\n            info(\"JSSEngine.wrap() - Got SSLException: \" + ssl_exception);\n            SSLException excpt = ssl_exception;\n            ssl_exception = null;\n            cleanup();\n            throw excpt;\n        }\n\n        // Need a way to introspect the open/closed state of the TLS\n        // connection.\n\n        SSLEngineResult.Status handshake_status = SSLEngineResult.Status.OK;\n\n        if (ssl_exception == null && seen_exception) {\n            debug(\"Seen and processed exception; closing inbound and outbound because this was the last wrap(...)\");\n            closeInbound();\n            closeOutbound();\n        }\n\n        if (is_outbound_closed) {\n            debug(\"Socket is currently closed.\");\n            handshake_status = SSLEngineResult.Status.CLOSED;\n        }\n\n        debug(\"JSSEngine.wrap() - Finished\");\n        debug(\" - Status: \" + handshake_status);\n        debug(\" - Handshake State: \" + handshake_state);\n        debug(\" - wire_data: \" + wire_data);\n        debug(\" - app_data: \" + app_data);\n\n        if (handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            returned_finished = true;\n        }\n\n        tryCleanup();\n        return new SSLEngineResult(handshake_status, handshake_state, app_data, wire_data);\n    }\n\n    /**\n     * Calls cleanup only if both inbound and outbound data streams are\n     * closed.\n     *\n     * This prevents accidental cleanup in the case of a partially open\n     * connection.\n     */\n    @Override\n    public void tryCleanup() {\n        debug(\"JSSEngine: tryCleanup()\");\n        if (is_inbound_closed && is_outbound_closed) {\n            // throw new RuntimeException(\"Probably shouldn't be here!\");\n            cleanup();\n        }\n    }\n\n    /**\n     * Performs cleanup of internal data, closing both inbound and outbound\n     * data streams if still open.\n     */\n    @Override\n    public void cleanup() {\n        debug(\"JSSEngine: cleanup()\");\n\n        if (!is_inbound_closed) {\n            debug(\"JSSEngine: cleanup() - closing opened inbound socket\");\n            closeInbound();\n        }\n\n        if (!is_outbound_closed) {\n            debug(\"JSSEngine: cleanup() - closing opened outbound socket\");\n            closeOutbound();\n        }\n\n        // First cleanup any debugging ports, if any.\n        cleanupLoggingSocket();\n\n        // Then clean up the NSS state.\n        cleanupSSLFD();\n\n        // Clean up the session.\n        if (session != null) {\n            session.close();\n            session = null;\n        }\n    }\n\n    private void cleanupLoggingSocket() {\n        if (debug_port > 0) {\n            try {\n                s_socket.close();\n            } catch (Exception e) {}\n\n            try {\n                c_socket.close();\n            } catch (Exception e) {}\n\n            try {\n                ss_socket.close();\n            } catch (Exception e) {}\n        }\n    }\n\n    private void cleanupSSLFD() {\n        if (!closed_fd && ssl_fd != null) {\n            try {\n                SSL.RemoveCallbacks(ssl_fd);\n                ssl_fd.close();\n                ssl_fd = null;\n            } catch (Exception e) {\n                logger.error(\"Got exception trying to cleanup SSLFD\", e);\n            } finally {\n                closed_fd = true;\n            }\n        }\n\n        if (read_buf != null) {\n            Buffer.Free(read_buf);\n            read_buf = null;\n        }\n\n        if (write_buf != null) {\n            Buffer.Free(write_buf);\n            write_buf = null;\n        }\n    }\n\n    // During testing with Tomcat 8.5, most instances did not call\n    // cleanup, so all the JNI resources end up getting leaked: ssl_fd\n    // (and its global ref), read_buf, and write_buf.\n    @Override\n    protected void finalize() {\n        cleanup();\n    }\n\n\n    private class CertValidationTask extends CertAuthHandler {\n        public CertValidationTask(SSLFDProxy fd) {\n            super(fd);\n        }\n\n        public String findAuthType(SSLFDProxy ssl_fd, PK11Cert[] chain) throws Exception {\n            // Java's CryptoManager is supposed to validate that the auth type\n            // chosen by the underlying protocol is compatible with the\n            // certificates in the channel. With TLSv1.3, this is less of a\n            // concern. However, NSS doesn't directly expose an authType\n            // compatible with Java; we're left inquiring for similar\n            // information from the channel info.\n\n            SSLPreliminaryChannelInfo info = SSL.GetPreliminaryChannelInfo(ssl_fd);\n            if (info == null) {\n                String msg = \"Expected non-null result from GetPreliminaryChannelInfo!\";\n                throw new RuntimeException(msg);\n            }\n\n            if (!info.haveProtocolVersion()) {\n                String msg = \"Expected SSLPreliminaryChannelInfo (\";\n                msg += info + \") to have protocol information.\";\n                throw new RuntimeException(msg);\n            }\n\n            if (!info.haveCipherSuite()) {\n                String msg = \"Expected SSLPreliminaryChannelInfo (\";\n                msg += info + \") to have cipher suite information.\";\n                throw new RuntimeException(msg);\n            }\n\n            SSLVersion version = info.getProtocolVersion();\n            SSLCipher suite = info.getCipherSuite();\n\n            if (version.value() < SSLVersion.TLS_1_3.value()) {\n                // When we're doing a TLSv1.2 or earlier protocol exchange,\n                // we can simply check the cipher suite value for the\n                // authentication type.\n                if (suite.requiresRSACert()) {\n                    // Java expects RSA_EXPORT to be handled properly.\n                    // However, rather than checking the actual bits in\n                    // the RSA certificate, return it purely based on\n                    // cipher suite name. In modern reality, these ciphers\n                    // should _NEVER_ be negotiated!\n                    if (suite.name().contains(\"RSA_EXPORT\")) {\n                        return \"RSA_EXPORT\";\n                    }\n\n                    return \"RSA\";\n                } else if (suite.requiresECDSACert()) {\n                    return \"ECDSA\";\n                } else if (suite.requiresDSSCert()) {\n                    // Notably, DSS is the same as DSA, but the suite names\n                    // all use DSS while the JDK uses DSA.\n                    return \"DSA\";\n                }\n                // Implicit else: authType == null, causing TrustManager\n                // check to fail.\n            } else {\n                // For TLSv1.3 and any later protocols, we can't rely on\n                // the above requires() checks, because the actual\n                // signature type depends on the type of the certificate\n                // provided. This makes the TrustManager field redundant,\n                // but yet we still have to provide it.\n                if (chain != null && chain.length > 0 && chain[0] != null) {\n                    PK11Cert cert = chain[0];\n                    PublicKey key = cert.getPublicKey();\n                    return key.getAlgorithm();\n                }\n                // Implicit else here and above: authType == null, which\n                // will cause the TrustManager check to fail.\n            }\n\n            return null;\n        }\n\n        @Override\n        public int check(SSLFDProxy fd) {\n            // Needs to be available for assignException() below.\n            PK11Cert[] chain = null;\n\n            try {\n                chain = SSL.PeerCertificateChain(fd);\n                String authType = findAuthType(fd, chain);\n                debug(\"CertAuthType: \" + authType);\n\n                if (chain == null || chain.length == 0) {\n                    // When the chain is NULL, we'd always fail in the\n                    // TrustManager calls, beacuse they expect a non-NULL,\n                    // non-empty chain. However, this is sometimes desired,\n                    // for instance, if we requested the peer to provide a\n                    // certificate chain and they didn't.\n                    if (as_server == true && !need_client_auth) {\n                        // Since we're a server validating the client's\n                        // chain (and they didn't provide one), we should\n                        // ignore it instead of forcing the problem.\n                        debug(\"No client certificate chain and client cert not needed.\");\n                        return 0;\n                    }\n                }\n\n                for (X509TrustManager tm : trust_managers) {\n                    // X509ExtendedTrustManager lets the TM access the\n                    // SSLEngine while validating certificates. Otherwise,\n                    // the X509TrustManager doesn't have access to that\n                    // parameter. Facilitate it if possible.\n                    if (tm instanceof X509ExtendedTrustManager) {\n                        X509ExtendedTrustManager etm = (X509ExtendedTrustManager) tm;\n                        if (as_server) {\n                            etm.checkClientTrusted(chain, authType, JSSEngineReferenceImpl.this);\n                        } else {\n                            etm.checkServerTrusted(chain, authType, JSSEngineReferenceImpl.this);\n                        }\n                    } else {\n                        if (as_server) {\n                            tm.checkClientTrusted(chain, authType);\n                        } else {\n                            tm.checkServerTrusted(chain, authType);\n                        }\n                    }\n                }\n            } catch (Exception excpt) {\n                return assignException(excpt, chain);\n            }\n\n            return 0;\n        }\n\n        private int assignException(Exception excpt, PK11Cert[] chain) {\n            int nss_code = Cert.MatchExceptionToNSSError(excpt);\n\n            if (seen_exception) {\n                return nss_code;\n            }\n\n            String msg = \"Got exception while trying to validate \";\n            msg += \"peer's certificate chain:\\n\";\n            if (chain == null) {\n                msg += \" - (null chain)\\n\";\n            } else if (chain.length == 0) {\n                msg += \" - (0 length chain)\\n\";\n            } else {\n                for (PK11Cert cert : chain) {\n                    msg += \" - \" + cert + \"\\n\";\n                }\n            }\n            msg += \"with given TrustManagers:\\n\";\n            if (trust_managers == null) {\n                msg += \" - (null TrustManagers)\\n\";\n            } else if (trust_managers.length == 0) {\n                msg += \" - (0 length TrustManagers)\\n\";\n            } else {\n                for (X509TrustManager tm : trust_managers) {\n                    msg += \" - \" + tm + \"\\n\";\n                }\n            }\n            msg += \"exception message: \" + excpt.getMessage();\n\n            seen_exception = true;\n            ssl_exception = new SSLException(msg, excpt);\n            return nss_code;\n        }\n    }\n\n    private class BypassBadHostname extends BadCertHandler {\n        public BypassBadHostname(SSLFDProxy fd, int error) {\n            super(fd, error);\n        }\n\n        @Override\n        public int check(SSLFDProxy fd, int error) {\n            // NSS enforces strict hostname verification via the SSL_SetURL\n            // function call. Java doesn't pass this information to either\n            // SSLSocket or SSLEngine, so we can at best try and infer this\n            // information. However, since this only needs to be validated\n            // on the client side, we can elide this check (like the JCA\n            // suggests and as the SunJSSE implementation does). In order\n            // to do so, we need to check for the BAD_CERT_DOMAIN error\n            // and tell NSS to ignore it.\n            //\n            // This makes the assumptions:\n            //  1. The hostname check is the very last check in the NSS\n            //     certificate validation handler.\n            //  2. As a consequence of (1) an otherwise valid certificate\n            //     will pass all other checks but fail due to hostname==NULL.\n            //  3. As a consequence of (1), all invalid certificates will\n            //     fail earlier.\n            //  4. No other paths report BAD_CERT_DOMAIN earlier than the\n            //     final hostname check.\n            if (error == SSLErrors.BAD_CERT_DOMAIN) {\n                return 0;\n            }\n\n            return error;\n        }\n    }\n}\n"], "fixing_code": ["package org.mozilla.jss.ssl.javax;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.WritableByteChannel;\nimport java.security.PublicKey;\n\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLHandshakeException;\nimport javax.net.ssl.X509ExtendedTrustManager;\nimport javax.net.ssl.X509TrustManager;\n\nimport org.mozilla.jss.nss.BadCertHandler;\nimport org.mozilla.jss.nss.Buffer;\nimport org.mozilla.jss.nss.BufferProxy;\nimport org.mozilla.jss.nss.Cert;\nimport org.mozilla.jss.nss.CertAuthHandler;\nimport org.mozilla.jss.nss.PR;\nimport org.mozilla.jss.nss.PRErrors;\nimport org.mozilla.jss.nss.PRFDProxy;\nimport org.mozilla.jss.nss.SSL;\nimport org.mozilla.jss.nss.SSLErrors;\nimport org.mozilla.jss.nss.SSLFDProxy;\nimport org.mozilla.jss.nss.SSLPreliminaryChannelInfo;\nimport org.mozilla.jss.nss.SecurityStatusResult;\nimport org.mozilla.jss.pkcs11.PK11Cert;\nimport org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\nimport org.mozilla.jss.ssl.SSLAlertDescription;\nimport org.mozilla.jss.ssl.SSLAlertEvent;\nimport org.mozilla.jss.ssl.SSLAlertLevel;\nimport org.mozilla.jss.ssl.SSLCipher;\nimport org.mozilla.jss.ssl.SSLHandshakeCompletedEvent;\nimport org.mozilla.jss.ssl.SSLVersion;\nimport org.mozilla.jss.ssl.SSLVersionRange;\n\n/**\n * The reference JSSEngine implementation.\n *\n * This JSSEngine implementation is a reference for future JSSEngine\n * implementations, providing a pure-Java overview of what should happen at\n * each step of the init, wrap, and unwrap calls.\n *\n * This implementation allows for extended debug logging, but also debug\n * packet logging. The latter writes out packets sent via wrap(...) and\n * received from unwrap(...) to a port on localhost. This allows one to easily\n * attach Wireshark or tcpdump and inspect the TLS packets, even if errors\n * occur during the test suite (where packets aren't sent over the wire by\n * default). This maintains the client/server relationship, and are logged\n * as being from the appropriate side of the TLS connection.\n */\npublic class JSSEngineReferenceImpl extends JSSEngine {\n    /**\n     * Faked peer information that we pass to the underlying BufferPRFD\n     * implementation.\n     *\n     * This is used by NSS for session resumption. However, because we\n     * don't have the exact peer information at the JSSEngine level, at\n     * best we can guess.\n     */\n    private String peer_info;\n\n    /**\n     * Whether or not the underlying ssl_fd is closed or not.\n     *\n     * Because the socket isn't open yet, we set it to true, to indicate\n     * that no data can be sent or received.\n     */\n    private boolean closed_fd = true;\n\n    /**\n     * Data to be read by the NSS SSL implementation; data from the peer.\n     */\n    private BufferProxy read_buf;\n\n    /**\n     * Data written by the NSS SSL implementation; data sent to the peer.\n     */\n    private BufferProxy write_buf;\n\n    /**\n     * Number of times heuristic has not matched the current state.\n     *\n     * Because this JSSEngine uses a heuristic for determining when the\n     * handshake is completed (or, when we need to switch from WRAP to\n     * UNWRAP), and the heuristic is sometimes wrong, we track how many\n     * times it is in an unknown state. When we hit some internal\n     * threshold, we swap states.\n     */\n    private int unknown_state_count;\n\n    /**\n     * Whether or not to step the handshake.\n     */\n    private boolean step_handshake;\n\n    /**\n     * Whether or not a FINISHED handshake status has been returned to our\n     * caller.\n     *\n     * Because this JSSEngine implementation re-enters the\n     * updateHandshakeState() method potentially multiple times during a\n     * single call to wrap() or unwrap(), we need to know whether or not\n     * the top-level call has returned a FINISHED result. If it hasn't,\n     * we want to keep the state on FINISHED until it has been returned,\n     * otherwise we'll skip straight to NOT_HANDSHAKING, confusing our\n     * peer.\n     */\n    private boolean returned_finished;\n\n    /**\n     * Value of the SSLException we've encountered.\n     */\n    private SSLException ssl_exception;\n\n    /**\n     * Whether or not we've seen an ssl exception.\n     *\n     * Note that, when the exception ultimately gets thrown to the caller,\n     * ssl_exception will be NULLed; this tracks whether or not the connection\n     * has failed previously for some reason.\n     */\n    private boolean seen_exception;\n\n    // In this reference implementation, we allow logging of (encrypted) data\n    // to a Socket for ease of testing. By default, this socket is disabled.\n    private int debug_port;\n    private ServerSocket ss_socket;\n    private Socket s_socket;\n    private Socket c_socket;\n    private InputStream s_istream;\n    private OutputStream s_ostream;\n    private InputStream c_istream;\n    private OutputStream c_ostream;\n\n    /**\n     * Internal name for this JSSEngine instance; most commonly used during\n     * testing.\n     */\n    private String name;\n\n    /**\n     * Automatically generated prefix for debug information.\n     */\n    private String prefix = \"\";\n\n    /**\n     * Runnable task; this performs certificate validation against user-provided\n     * TrustManager instances, passing the result back to NSS.\n     */\n    private CertValidationTask task;\n\n    public JSSEngineReferenceImpl() {\n        super();\n\n        // We were given no hints about our peer so we have no information\n        // to signal to NSS for session resumption.\n        peer_info = null;\n\n        debug(\"JSSEngine: constructor()\");\n    }\n\n    public JSSEngineReferenceImpl(String peerHost, int peerPort) {\n        super(peerHost, peerPort);\n\n        // Signal host and port for session resumption. Only do it when we've\n        // been given valid information.\n        if (peerHost != null && peerPort != 0) {\n            peer_info = peerHost + \":\" + peerPort;\n        }\n\n        // Massive hack for compatibility. In particular, Java usually\n        // specifies the peer information here. NSS uses SSL_SetURL not only\n        // for hostname verification, but also for SNI (!!) on the client.\n        // This means that there's no way to indicate (to those servers like\n        // google.com which require SNI) hostname for the client WITHOUT\n        // also validating the hostname at certificate verification time.\n        // Because the certificate hostname explicitly isn't provided (per\n        // JCA specification) for validation, this might break other clients\n        // which don't provide this information. However, the alternative is\n        // that we never add SNI indication, ever.\n        //\n        // Specifically, this breaks a dead-simple Apache HTTP Components\n        // client:\n        //\n        //     CloseableHttpClient client = HttpClients.createDefault();\n        //     HttpGet request = new HttpGet(\"https://google.com/\");\n        //     HttpResponse response = client.execute(request);\n        //     System.out.println(response);\n        //\n        // Without this, we have no way for the above to work.\n        setHostname(peerHost);\n\n        debug(\"JSSEngine: constructor(\" + peerHost + \", \" + peerPort + \")\");\n    }\n\n    public JSSEngineReferenceImpl(String peerHost, int peerPort,\n                     org.mozilla.jss.crypto.X509Certificate localCert,\n                     org.mozilla.jss.crypto.PrivateKey localKey) {\n        super(peerHost, peerPort, localCert, localKey);\n\n        // Signal host and port for session resumption. Only do it when we've\n        // been given valid information.\n        if (peerHost != null && peerPort != 0) {\n            peer_info = peerHost + \":\" + peerPort;\n        }\n\n        // See above.\n        setHostname(peerHost);\n\n        prefix = prefix + \"[\" + peer_info + \"] \";\n\n        debug(\"JSSEngine: constructor(\" + peerHost + \", \" + peerPort + \", \" + localCert + \", \" + localKey + \")\");\n    }\n\n    private void debug(String msg) {\n        logger.debug(prefix + msg);\n    }\n\n    private void info(String msg) {\n        logger.info(prefix + msg);\n    }\n\n    private void warn(String msg) {\n        logger.warn(prefix + msg);\n    }\n\n    /**\n     * Set the name of this JSSEngine instance, to be printed in logging calls.\n     *\n     * This helps when debugging output from multiple JSSEngine instances at\n     * the same time, such as within the JSS test suite.\n     */\n    public void setName(String name) {\n        this.name = name;\n        prefix = \"[\" + this.name + \"] \" + prefix;\n    }\n\n    private void init() throws SSLException {\n        debug(\"JSSEngine: init()\");\n\n        // Initialize our JSSEngine when we begin to handshake; otherwise,\n        // calls to Set<Option>(...) won't be processed if we initialize it\n        // too early; some of these need to be applied at initialization time\n        // in order to take affect.\n\n        // Ensure we don't leak ssl_fd if we're called multiple times.\n        if (ssl_fd != null && !closed_fd) {\n            is_inbound_closed = true;\n            is_outbound_closed = true;\n            cleanup();\n        }\n\n        ssl_fd = null;\n\n        // Create buffers for interacting with NSS.\n        createBuffers();\n        createBufferFD();\n\n        // Initialize the appropriate end of this connection.\n        if (as_server) {\n            initServer();\n        } else {\n            initClient();\n        }\n\n        // Apply the requested cipher suites and protocols.\n        applyProtocols();\n        applyCiphers();\n        applyConfig();\n\n        // Apply hostname information (via setURL). Note that this is an\n        // extension to SSLEngine for use with NSS; we don't always get this\n        // information and so need to work around it sometimes. See\n        // initClient() for the workaround.\n        applyHosts();\n\n        // Apply TrustManager(s) information for validating the peer's\n        // certificate.\n        applyTrustManagers();\n\n        // Finally, set up any debug logging necessary.\n        createLoggingSocket();\n    }\n\n    private void createBuffers() {\n        debug(\"JSSEngine: createBuffers()\");\n\n        // If the buffers exist, destroy them and then recreate them.\n\n        if (read_buf != null) {\n            Buffer.Free(read_buf);\n        }\n        read_buf = Buffer.Create(BUFFER_SIZE);\n\n        if (write_buf != null) {\n            Buffer.Free(write_buf);\n        }\n        write_buf = Buffer.Create(BUFFER_SIZE);\n    }\n\n    private void createBufferFD() throws SSLException {\n        debug(\"JSSEngine: createBufferFD()\");\n\n        // Create the basis for the ssl_fd from the pair of buffers we created\n        // above.\n\n        PRFDProxy fd;\n        if (peer_info != null && peer_info.length() != 0) {\n            // When we have peer information, indicate it via BufferPRFD so\n            // that NSS can use it for session resumption.\n            fd = PR.NewBufferPRFD(read_buf, write_buf, peer_info.getBytes());\n        } else {\n            fd = PR.NewBufferPRFD(read_buf, write_buf, null);\n        }\n\n        if (fd == null) {\n            throw new SSLException(\"Error creating buffer-backed PRFileDesc.\");\n        }\n\n        SSLFDProxy model = null;\n        if (as_server) {\n            // As a performance improvement, we can copy the server template\n            // (containing the desired key and certificate) rather than\n            // re-creating it from scratch. This saves a significant amount of\n            // time during construction. The implementation lives in JSSEngine,\n            // to be shared by all other JSSEngine implementations.\n            model = getServerTemplate(cert, key);\n        }\n\n        // Initialize ssl_fd from the model Buffer-backed PRFileDesc.\n        ssl_fd = SSL.ImportFD(model, fd);\n        if (ssl_fd == null) {\n            PR.Close(fd);\n            throw new SSLException(\"Error creating SSL socket on top of buffer-backed PRFileDesc.\");\n        }\n\n        fd = null;\n        closed_fd = false;\n\n        // Turn on SSL Alert Logging for the ssl_fd object.\n        int ret = SSL.EnableAlertLogging(ssl_fd);\n        if (ret == SSL.SECFailure) {\n            throw new SSLException(\"Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n        }\n\n        // Turn on notifications of handshake completion. This is the best\n        // source of this information, compared to SSL_SecurityStatus().on;\n        // the latter can indicate \"on\" before the final FINISHED method has\n        // been sent.\n        ret = SSL.EnableHandshakeCallback(ssl_fd);\n        if (ret == SSL.SECFailure) {\n            throw new SSLException(\"Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n        }\n\n        // Pass this ssl_fd to the session object so that we can use\n        // SSL methods to invalidate the session.\n    }\n\n    private void initClient() throws SSLException {\n        debug(\"JSSEngine: initClient()\");\n\n        if (cert != null && key != null) {\n            // NSS uses a callback to check for the client certificate; we\n            // assume we have knowledge of it ahead of time and set it\n            // directly on our SSLFDProxy instance.\n            //\n            // In the future, we could use a KeyManager for inquiring at\n            // selection time which certificate to use.\n            debug(\"JSSEngine.initClient(): Enabling client auth: \" + cert);\n            ssl_fd.SetClientCert(cert);\n            if (SSL.AttachClientCertCallback(ssl_fd) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to attach client certificate auth callback.\");\n            }\n        }\n\n        if (hostname == null) {\n            // When we're a client with no hostname, assume we're running\n            // under standard JDK JCA semantics with no hostname available.\n            // Bypass NSS's hostname check by adding a BadCertHandler, which\n            // check ONLY for the bad hostname error and allows it. This is\n            // safe since this is the LAST check in every (NSS, PKIX, and\n            // JSS) certificate validation step. And, under JCA semantics, we\n            // can assume the caller checks the hostname for us.\n            ssl_fd.badCertHandler = new BypassBadHostname(ssl_fd, 0);\n            if (SSL.ConfigSyncBadCertCallback(ssl_fd) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to attach bad cert callback.\");\n            }\n        }\n    }\n\n    private void initServer() throws SSLException {\n        debug(\"JSSEngine: initServer()\");\n\n        // The only time cert and key are strictly required are when we're\n        // creating a server SSLEngine.\n        if (cert == null || key == null) {\n            throw new IllegalArgumentException(\"JSSEngine: must be initialized with server certificate and key!\");\n        }\n\n        debug(\"JSSEngine.initServer(): \" + cert);\n        debug(\"JSSEngine.initServer(): \" + key);\n\n        session.setLocalCertificates(new PK11Cert[]{ cert } );\n\n        // Create a small server session cache.\n        //\n        // TODO: Make this configurable.\n        initializeSessionCache(1, 100, null);\n\n        configureClientAuth();\n    }\n\n    private void configureClientAuth() throws SSLException {\n        debug(\"SSLFileDesc: \" + ssl_fd);\n\n        // Only specify these on the server side as they affect what we\n        // want from the remote peer in NSS. In the server case, this is\n        // client auth, but if we were to set these on the client, it would\n        // affect server auth.\n        if (SSL.OptionSet(ssl_fd, SSL.REQUEST_CERTIFICATE, want_client_auth || need_client_auth ? 1 : 0) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to configure SSL_REQUEST_CERTIFICATE option: \" + errorText(PR.GetError()));\n        }\n\n        if (SSL.OptionSet(ssl_fd, SSL.REQUIRE_CERTIFICATE, need_client_auth ? SSL.REQUIRE_ALWAYS : 0) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to configure SSL_REQUIRE_CERTIFICATE option: \" + errorText(PR.GetError()));\n        }\n    }\n\n    @Override\n    protected void reconfigureClientAuth() {\n        if (ssl_fd == null || !as_server) {\n            return;\n        }\n\n        // This method is called by JSSEngine's setNeedClientAuth and\n        // setWantClientAuth to inform us of a change in value here. When\n        // we've already configured ssl_fd and we're a server, we need to\n        // inform NSS of this change; this usually indicates Post-Handshake\n        // Authentication is required.\n\n        try {\n            configureClientAuth();\n        } catch (SSLException se) {\n            // We cannot throw SSLException from this helper because it\n            // is called from setNeedClientAuth and setWantClientAuth,\n            // both of which don't disclose SSLException.\n            throw new RuntimeException(se.getMessage(), se);\n        }\n    }\n\n    private void applyCiphers() throws SSLException {\n        debug(\"JSSEngine: applyCiphers()\");\n        // Enabled the ciphersuites specified by setEnabledCipherSuites(...).\n        // When this isn't called, enabled_ciphers will be null, so we'll just\n        // use whatever is enabled by default.\n        if (enabled_ciphers == null) {\n            return;\n        }\n\n        // We need to disable the suite if it isn't present in the list of\n        // suites above. Be lazy about it for the time being and disable all\n        // cipher suites first.\n        for (SSLCipher suite : SSLCipher.values()) {\n            if (SSL.CipherPrefSet(ssl_fd, suite.getID(), false) == SSL.SECFailure) {\n                // warn(\"Unable to set cipher suite preference for \" + suite.name() + \": \" + errorText(PR.GetError()));\n            }\n        }\n\n        // Only enable these particular suites. When a cipher suite can't be\n        // enabled it is most likely due to local policy. Log it. Also log\n        // which ciphers were successfully enabled for debugging purposes.\n        for (SSLCipher suite : enabled_ciphers) {\n            if (suite == null) {\n                continue;\n            }\n\n            if (SSL.CipherPrefSet(ssl_fd, suite.getID(), true) == SSL.SECFailure) {\n                warn(\"Unable to enable cipher suite \" + suite + \": \" + errorText(PR.GetError()));\n            } else {\n                debug(\"Enabled cipher suite \" + suite + \": \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void applyProtocols() throws SSLException {\n        debug(\"JSSEngine: applyProtocols() min_protocol=\" + min_protocol + \" max_protocol=\" + max_protocol);\n        // Enable the protocols only when both a maximum and minimum protocol\n        // version are specified.\n        if (min_protocol == null || max_protocol == null) {\n            debug(\"JSSEngine: applyProtocols() - missing min_protocol or max_protocol; using defaults\");\n            return;\n        }\n\n        // We should bound this range by crypto-policies in the future to\n        // match the current behavior. However, Tomcat already bounds\n        // what we set in the server.xml config by what the JSSEngine\n        // indicates it supports. Because we only indicate we support\n        // what is allowed under crypto-policies, it effective does\n        // this bounding for us.\n        SSLVersionRange vrange = new SSLVersionRange(min_protocol, max_protocol);\n        if (SSL.VersionRangeSet(ssl_fd, vrange) == SSL.SECFailure) {\n            throw new SSLException(\"Unable to set version range: \" + errorText(PR.GetError()));\n        }\n    }\n\n    private void applyConfig() throws SSLException {\n        debug(\"JSSEngine: applyConfig()\");\n        for (Integer key : config.keySet()) {\n            Integer value = config.get(key);\n\n            debug(\"Setting configuration option: \" + key + \"=\" + value);\n            if (SSL.OptionSet(ssl_fd, key, value) != SSL.SECSuccess) {\n                throw new SSLException(\"Unable to set configuration value: \" + key + \"=\" + value);\n            }\n        }\n    }\n\n    private void applyHosts() throws SSLException {\n        debug(\"JSSEngine: applyHosts()\");\n\n        // This is most useful for the client end of the connection; this\n        // specifies what to match the server's certificate against.\n        if (hostname != null) {\n            if (SSL.SetURL(ssl_fd, hostname) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure server hostname: \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void applyTrustManagers() throws SSLException {\n        debug(\"JSSEngine: applyTrustManagers()\");\n\n        // If none have been specified, exit early.\n        if (trust_managers == null || trust_managers.length == 0) {\n            // Use the default NSS certificate authentication handler. We\n            // don't need to do anything to use it.\n            debug(\"JSSEngine: no TrustManagers to apply.\");\n            return;\n        }\n\n        // Determine which configuration to use for checking certificates. Our\n        // options are a Native trust manager (most performant) or using a set\n        // of X509TrustManagers.\n        if (trust_managers.length == 1 && trust_managers[0] instanceof JSSNativeTrustManager) {\n            // This is a dummy TrustManager. It signifies that we should call\n            // SSL.ConfigJSSDefaultCertAuthCallback(...) on this SSL\n            // PRFileDesc pointer, letting us utilize the same certificate\n            // validation logic that SSLSocket had.\n            debug(\"JSSEngine: applyTrustManagers() - adding Native TrustManager\");\n            if (SSL.ConfigJSSDefaultCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure JSSNativeTrustManager on this JSSengine: \" + errorText(PR.GetError()));\n            }\n            return;\n        }\n\n        if (as_server) {\n            // We need to manually invoke the async cert auth handler. However,\n            // SSLFDProxy makes this easy for us: our CertAuthHandler derives\n            // from Runnable, so we can reuse it here as well. We can create\n            // it ahead of time though. In this case, checkNeedCertValidation()\n            // is never called.\n            ssl_fd.certAuthHandler = new CertValidationTask(ssl_fd);\n\n            if (SSL.ConfigSyncTrustManagerCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure TrustManager validation on this JSSengine: \" + errorText(PR.GetError()));\n            }\n        } else {\n            // Otherwise, we need a hook from NSS into the SSLFDProxy.\n            //\n            // This hook executes all TrustManagers and if any exception\n            // occurs, we'll turn it into the proper response within NSS.\n            if (SSL.ConfigAsyncTrustManagerCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                throw new SSLException(\"Unable to configure TrustManager validation on this JSSengine: \" + errorText(PR.GetError()));\n            }\n        }\n    }\n\n    private void createLoggingSocket() throws SSLException {\n        if (debug_port == 0) {\n            return;\n        }\n\n        try {\n            ss_socket = new ServerSocket(debug_port);\n            ss_socket.setReuseAddress(true);\n            ss_socket.setReceiveBufferSize(BUFFER_SIZE);\n\n            c_socket = new Socket(ss_socket.getInetAddress(), ss_socket.getLocalPort());\n            c_socket.setReuseAddress(true);\n            c_socket.setReceiveBufferSize(BUFFER_SIZE);\n            c_socket.setSendBufferSize(BUFFER_SIZE);\n\n            s_socket = ss_socket.accept();\n            s_socket.setReuseAddress(true);\n            s_socket.setReceiveBufferSize(BUFFER_SIZE);\n            s_socket.setSendBufferSize(BUFFER_SIZE);\n\n            s_istream = s_socket.getInputStream();\n            s_ostream = s_socket.getOutputStream();\n\n            c_istream = c_socket.getInputStream();\n            c_ostream = c_socket.getOutputStream();\n        } catch (Exception e) {\n            throw new SSLException(\"Unable to enable debug socket logging! \" + e.getMessage(), e);\n        }\n    }\n\n    private void loggingSocketConsumeAllBytes() {\n        try {\n            int available = s_istream.available();\n            byte[] data = new byte[available];\n            s_istream.read(data);\n        } catch (Exception e) {}\n\n        try {\n            int available = c_istream.available();\n            byte[] data = new byte[available];\n            c_istream.read(data);\n        } catch (Exception e) {}\n    }\n\n    @Override\n    public void beginHandshake() throws SSLException {\n        debug(\"JSSEngine: beginHandshake()\");\n\n        // We assume beginHandshake(...) is the entry point for initializing\n        // the buffer. In particular, wrap(...) / unwrap(...) *MUST* call\n        // beginHandshake(...) if ssl_fd == null.\n\n        // ssl_fd == null <-> we've not initialized anything yet.\n\n        // TLS begins with the client sending a CLIENT_HELLO to the server;\n        // this means that the server needs to unwrap first and the client\n        // needs to wrap first; hence unwrap = as_server. However, if we're\n        // trying to renegotiate this changes. See when ssl_fd != null below.\n        boolean unwrap = as_server;\n\n        if (ssl_fd == null) {\n            // Initialize and create ssl_fd. Throws various RuntimeExceptions\n            // when creation and configuration fails.\n            init();\n            assert(ssl_fd != null);\n\n            // Reset the handshake status, using the new socket and\n            // configuration which was just created. This ensures that\n            // we'll attempt to handshake when ForceHandshake is called.\n            if (SSL.ResetHandshake(ssl_fd, as_server) == SSL.SECFailure) {\n                throw new RuntimeException(\"Unable to begin handshake: \" + errorText(PR.GetError()));\n            }\n        } else {\n            // When ssl_fd exists, we need to re-handshake. Usually, the\n            // server initiates the conversation (especially when we want\n            // to upgrade to requiring client auth from not requiring it).\n            //\n            // This means that when we're a (as_server == true), we should\n            // now wrap, rather than unwrap. So, negate unwrap.\n            unwrap = !as_server;\n\n            // TLS v1.3 differs from all previous versions in that it removed\n            // the ability to completely rehandshake. This makes the first\n            // portion more complicated than the latter.\n            if (session.getSSLVersion() == SSLVersion.TLS_1_3) {\n                // We only send the certificate request as a server when we\n                // need client auth. Otherwise, we'll have to issue a rekey\n                // request.\n                boolean send_certificate_request = as_server && need_client_auth;\n                if (send_certificate_request) {\n                    if (SSL.SendCertificateRequest(ssl_fd) == SSL.SECFailure) {\n                        throw new RuntimeException(\"Unable to issue certificate request on TLSv1.3: \" + errorText(PR.GetError()));\n                    }\n                } else {\n                    // Our best guess at what the user wants is to update\n                    // their keys. They don't need client authentication but\n                    // they explicitly called beginHandshake() again.\n                    if (SSL.KeyUpdate(ssl_fd, false) == SSL.SECFailure) {\n                        throw new RuntimeException(\"Unable to request a new key on TLSv1.3: \" + errorText(PR.GetError()));\n                    }\n                }\n            } else {\n                // On older protocol versions, this is easier: just issue a\n                // new handshake request. This is different from\n                // ResetHandshake as for security reasons, the semantics have\n                // to differ.\n                if (SSL.ReHandshake(ssl_fd, true) == SSL.SECFailure) {\n                    throw new RuntimeException(\"Unable to rehandshake: \" + errorText(PR.GetError()));\n                }\n            }\n        }\n\n        // Make sure we reset the handshake completion status in order for the\n        // callback to work correctly.\n        ssl_fd.handshakeComplete = false;\n\n        // This leaves setting internal variables for HandshakeStatus and\n        // the reporting up from SSLEngine.\n        if (unwrap) {\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n        } else {\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n        }\n\n        // We've begun a new handshake; make sure we step it and reset\n        // our unknown state count to zero.\n        step_handshake = true;\n        unknown_state_count = 0;\n\n        // Lastly, each handshake must return a FINISHED individually,\n        // reset returned_finished to false.\n        returned_finished = false;\n    }\n\n    @Override\n    public void closeInbound() {\n        debug(\"JSSEngine: closeInbound()\");\n\n        if (!is_inbound_closed && ssl_fd != null && !closed_fd) {\n            // Send PR_SHUTDOWN_RCV only once. Additionally, this call\n            // crashes when ssl_fd == NULL or when the socket is already\n            // closed.\n            PR.Shutdown(ssl_fd, PR.SHUTDOWN_RCV);\n        }\n\n        is_inbound_closed = true;\n    }\n\n    @Override\n    public void closeOutbound() {\n        debug(\"JSSEngine: closeOutbound()\");\n\n        if (!is_outbound_closed && ssl_fd != null && !closed_fd) {\n            // Send PR_SHUTDOWN_SEND only once. Additionally, this call\n            // crashes when ssl_fd == NULL or when the socket is already\n            // closed.\n            PR.Shutdown(ssl_fd, PR.SHUTDOWN_SEND);\n        }\n\n        is_outbound_closed = true;\n    }\n\n    public String getHostname() {\n        return hostname;\n    }\n\n    @Override\n    public Runnable getDelegatedTask() {\n        debug(\"JSSEngine: getDelegatedTask()\");\n\n        // task can either contain a task instance or null; task gets\n        // populated also during getHandshakeStatus(), wrap(), and\n        // unwrap(). Since wrap()/unwrap() populate the task early (if\n        // one is needed) -- but can return NEED_TASK later with null\n        // task, this could result in a stall if we didn't also check\n        // here. Best to do it (it is cheap if one isn't necessary),\n        // so that way we always return up-to-date information.\n        if (ssl_fd != null) {\n            // Return code is a boolean, whether or not we have a task.\n            // We can safely ignore it here.\n            checkNeedCertValidation();\n        }\n\n        return task;\n    }\n\n    private boolean checkNeedCertValidation() {\n        debug(\"JSSEngine: checkNeedCertValidation()\");\n        if (task != null) {\n            if (!task.finished) {\n                // Already created runnable task; exit with true status to\n                // show it still needs to be run.\n                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n                return true;\n            }\n\n            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n\n            // Since the task has finished, we now need to inform NSS about\n            // the results of our certificate validation step.\n            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n                String msg = \"Got unexpected failure finishing cert \";\n                msg += \"authentication in NSS. Returned code \";\n                msg += task.result;\n                throw new RuntimeException(msg);\n            }\n\n            // After checking certificates, our best guess will be that we\n            // need to run wrap again. This is because we either need to\n            // inform the caller of an error that occurred, or continue the\n            // handshake. Worst case, we'll call updateHandshakeState() and\n            // it'll correct our mistake eventually.\n\n            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n\n            task = null;\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            ssl_fd.needCertValidation = false;\n\n            return false;\n        }\n\n        if (ssl_fd == null) {\n            // If we don't have a SSLFDProxy instance, nothing we can do but\n            // skip checking if the task exists. Return false to show that\n            // we don't yet have a runnable task.\n            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n            return false;\n        }\n\n        if (!ssl_fd.needCertValidation) {\n            // We don't yet need certificate validation. Don't create a\n            // runnable task for now.\n            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n            return false;\n        }\n\n        debug(\"JSSEngine: checkNeedCertValidation() - creating task\");\n\n        // OK, time to create our runnable task.\n        task = new CertValidationTask(ssl_fd);\n\n        // Update our handshake state so we know what to do next.\n        handshake_state = SSLEngineResult.HandshakeStatus.NEED_TASK;\n\n        return true;\n    }\n\n    @Override\n    public SSLEngineResult.HandshakeStatus getHandshakeStatus() {\n        debug(\"JSSEngine: getHandshakeStatus()\");\n\n        // If task is NULL, we need to update the state to check if the\n        // task has been \"run\". Even if it isn't, it would be good to\n        // update the status here as well. However, we DO NOT want to\n        // call updateHandshakeState() in the event we have a task to\n        // run: we need to run it still!\n        if (checkNeedCertValidation()) {\n            return handshake_state;\n        }\n\n        // Always update the handshake state; this ensures that we catch\n        // looping due to missing data and flip our expected direction.\n        updateHandshakeState();\n\n        return handshake_state;\n    }\n\n    @Override\n    public SecurityStatusResult getStatus() {\n        if (ssl_fd == null) {\n            return null;\n        }\n\n        return SSL.SecurityStatus(ssl_fd);\n    }\n\n    /**\n     * Enable writing of encrypted TLS traffic to the specified port in a\n     * client-server relationship (mirroring the actual role of this\n     * SSLEngine) to enable debugging with Wireshark.\n     */\n    public void enableSafeDebugLogging(int port) {\n        debug_port = port;\n    }\n\n    private int computeSize(ByteBuffer[] buffers, int offset, int length) throws IllegalArgumentException {\n        debug(\"JSSEngine: computeSize()\");\n        int result = 0;\n\n        if (buffers == null || buffers.length == 0) {\n            debug(\"JSSEngine.compueSize(): no buffers - result=\" + result);\n            return result;\n        }\n\n        // Semantics of arguments:\n        //\n        // - buffers is where we're reading/writing application data.\n        // - offset is the index of the first buffer we read/write to.\n        // - length is the total number of buffers we read/write to.\n        //\n        // We use a relative index and an absolute index to handle these\n        // constraints.\n        for (int rel_index = 0; rel_index < length; rel_index++) {\n            int index = offset + rel_index;\n            if (index >= buffers.length) {\n                throw new IllegalArgumentException(\"offset (\" + offset + \") or length (\" + length + \") exceeds contract based on number of buffers (\" + buffers.length + \")\");\n            }\n\n            if (rel_index == 0 && buffers[index] == null) {\n                // If our first buffer is null, assume the rest are and skip\n                // everything else. This commonly happens when null is passed\n                // as the src parameter to wrap or when null is passed as the\n                // dst parameter to unwrap.\n                debug(\"JSSEngine.computeSize(): null first buffer - result=\" + result);\n                return result;\n            }\n\n            if (buffers[index] == null) {\n                throw new IllegalArgumentException(\"Buffer at index \" + index + \" is null.\");\n            }\n\n            result += buffers[index].remaining();\n        }\n\n        debug(\"JSSEngine.computeSize(): result=\" + result);\n\n        return result;\n    }\n\n    private int putData(byte[] data, ByteBuffer[] buffers, int offset, int length) {\n        debug(\"JSSEngine: putData()\");\n        // Handle the rather unreasonable task of moving data into the buffers.\n        // We assume the buffer parameters have already been checked by\n        // computeSize(...); that is, offset/length contracts hold and that\n        // each buffer in the range is non-null.\n        //\n        // We also assume that data.length does not exceed the total number\n        // of bytes the buffers can hold; this is what computeSize(...)'s\n        // return value should ensure. This directly means that the inner\n        // while loop won't exceed the bounds of offset+length.\n\n        int buffer_index = offset;\n        int data_index = 0;\n\n        if (data == null || buffers == null) {\n            return data_index;\n        }\n\n        for (data_index = 0; data_index < data.length;) {\n            // Ensure we have have a buffer with capacity.\n            while ((buffers[buffer_index] == null || buffers[buffer_index].remaining() <= 0) &&\n                    (buffer_index < offset + length)) {\n                buffer_index += 1;\n            }\n            if (buffer_index >= offset + length) {\n                break;\n            }\n\n            // Compute the size of the put: it is the minimum of the space\n            // remaining in this buffer and the bytes remaining in the data\n            // array.\n            int put_size = buffers[buffer_index].remaining();\n            if (put_size > (data.length - data_index)) {\n                put_size = data.length - data_index;\n            }\n\n            buffers[buffer_index].put(data, data_index, put_size);\n            data_index += put_size;\n        }\n\n        return data_index;\n    }\n\n    private SSLException checkSSLAlerts() {\n        debug(\"JSSEngine: Checking inbound and outbound SSL Alerts. Have \" + ssl_fd.inboundAlerts.size() + \" inbound and \" + ssl_fd.outboundAlerts.size() + \" outbound alerts.\");\n\n        // Prefer inbound alerts to outbound alerts.\n        while (ssl_fd.inboundOffset < ssl_fd.inboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.inboundAlerts.get(ssl_fd.inboundOffset);\n            ssl_fd.inboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Got inbound CLOSE_NOTIFY alert\");\n                closeInbound();\n            }\n\n            debug(\"JSSEngine: Got inbound alert: \" + event);\n\n            // Fire inbound alert prior to raising any exception.\n            fireAlertReceived(event);\n\n            // Not every SSL Alert is fatal; toException() only returns a\n            // SSLException on fatal instances. We shouldn't return NULL\n            // early without checking all alerts.\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        while (ssl_fd.outboundOffset < ssl_fd.outboundAlerts.size()) {\n            SSLAlertEvent event = ssl_fd.outboundAlerts.get(ssl_fd.outboundOffset);\n            ssl_fd.outboundOffset += 1;\n\n            if (event.getLevelEnum() == SSLAlertLevel.WARNING && event.getDescriptionEnum() == SSLAlertDescription.CLOSE_NOTIFY) {\n                debug(\"Sent outbound CLOSE_NOTIFY alert.\");\n                closeOutbound();\n            }\n\n            debug(\"JSSEngine: Got outbound alert: \" + event);\n\n            // Fire outbound alert prior to raising any exception. Note that\n            // this still triggers after this alert is written to the output\n            // wire buffer.\n            fireAlertSent(event);\n\n            SSLException exception = event.toException();\n            if (exception != null) {\n                return exception;\n            }\n        }\n\n        return null;\n    }\n\n    private void updateHandshakeState() {\n        debug(\"JSSEngine: updateHandshakeState()\");\n\n        // If we've previously seen an exception, we should just return\n        // here; there's already an alert on the wire, so there's no point\n        // in checking for new ones and/or stepping the handshake: it has\n        // already failed.\n        if (seen_exception) {\n            return;\n        }\n\n        // If we're already done, we should check for SSL ALerts.\n        if (!step_handshake && handshake_state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            debug(\"JSSEngine.updateHandshakeState() - not handshaking\");\n            unknown_state_count = 0;\n\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n            return;\n        }\n\n        // If we've previously finished handshaking, then move to\n        // NOT_HANDSHAKING. Now is also a good time to check for any\n        // alerts.\n        if (!step_handshake && handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            debug(\"JSSEngine.updateHandshakeState() - FINISHED to NOT_HANDSHAKING\");\n\n            // Because updateHandshakeState() gets called multiple times within\n            // a single wrap/unwrap invocation, we need to wait for the FINISHED\n            // message to be returned (from wrap/unwrap) before moving it to\n            // NOT_HANDSHAKING. Otherwise, callers will miss that the handshake\n            // has completed. We aren't in an unknown state though and we don't\n            // need to call SSL.ForceHandshake().\n            if (returned_finished) {\n                handshake_state = SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;\n            }\n\n            unknown_state_count = 0;\n\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n            return;\n        }\n\n        // Since we're not obviously done handshaking, and the last time we\n        // were called, we were still handshaking, step the handshake.\n        debug(\"JSSEngine.updateHandshakeState() - forcing handshake\");\n        if (SSL.ForceHandshake(ssl_fd) == SSL.SECFailure) {\n            int error_value = PR.GetError();\n\n            if (error_value != PRErrors.WOULD_BLOCK_ERROR) {\n                debug(\"JSSEngine.updateHandshakeState() - FATAL \" + getStatus());\n\n                ssl_exception = new SSLHandshakeException(\"Error duing SSL.ForceHandshake() :: \" + errorText(error_value));\n                seen_exception = true;\n\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n                return;\n            }\n        }\n\n        // Check if we've just finished handshaking.\n        debug(\"JSSEngine.updateHandshakeState() - read_buf.read=\" + Buffer.ReadCapacity(read_buf) + \" read_buf.write=\" + Buffer.WriteCapacity(read_buf) + \" write_buf.read=\" + Buffer.ReadCapacity(write_buf) + \" write_buf.write=\" + Buffer.WriteCapacity(write_buf));\n\n        // Set NEED_WRAP when we have data to send to the client.\n        if (Buffer.ReadCapacity(write_buf) > 0 && handshake_state != SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n            // Can't write; to read, we need to call wrap to provide more\n            // data to write.\n            debug(\"JSSEngine.updateHandshakeState() - can write \" + Buffer.ReadCapacity(write_buf) + \" bytes, NEED_WRAP to process\");\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            unknown_state_count = 0;\n            return;\n        }\n\n        // Delay the check to see if the handshake finished until after we\n        // send the CLIENT FINISHED message and recieved the SERVER FINISHED\n        // message if we're a client. Otherwise, wait to send SERVER FINISHED\n        // message. This is because NSS thinks the handshake has finished\n        // (according to SecurityStatusResult since it has sent the massage)\n        // but we haven't yet gotten around to doing so if we're in a WRAP()\n        // call.\n        if (ssl_fd.handshakeComplete && Buffer.ReadCapacity(write_buf) == 0) {\n            debug(\"JSSEngine.updateHandshakeState() - handshakeComplete is \" + ssl_fd.handshakeComplete + \", so we've just finished handshaking\");\n            step_handshake = false;\n            handshake_state = SSLEngineResult.HandshakeStatus.FINISHED;\n            unknown_state_count = 0;\n\n            // Only update peer certificate chain when we've finished\n            // handshaking.\n            try {\n                PK11Cert[] peer_chain = SSL.PeerCertificateChain(ssl_fd);\n                session.setPeerCertificates(peer_chain);\n            } catch (Exception e) {\n                String msg = \"Unable to get peer's certificate chain: \";\n                msg += e.getMessage();\n\n                seen_exception = true;\n                ssl_exception = new SSLException(msg, e);\n            }\n\n            // Also update our session information here.\n            session.refreshData();\n\n            // Finally, fire any handshake completed event listeners now.\n            fireHandshakeComplete(new SSLHandshakeCompletedEvent(this));\n\n            return;\n        }\n\n        if (Buffer.ReadCapacity(read_buf) == 0 && handshake_state != SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n            // Set NEED_UNWRAP when we have no data to read from the client.\n            debug(\"JSSEngine.updateHandshakeState() - can read \" + Buffer.ReadCapacity(read_buf) + \" bytes, NEED_UNWRAP to give us more\");\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n            unknown_state_count = 0;\n            return;\n        }\n\n        unknown_state_count += 1;\n        if (unknown_state_count >= 4) {\n            if (handshake_state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n            } else {\n                handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            }\n            unknown_state_count = 1;\n        }\n    }\n\n    private void logUnwrap(ByteBuffer src) {\n        if (debug_port <= 0 || src == null || src.remaining() == 0) {\n            return;\n        }\n\n        loggingSocketConsumeAllBytes();\n\n        OutputStream stream = c_ostream;\n\n        if (!as_server) {\n            // An unwrap from the client means we write data to the outbound\n            // side of the server socket.\n            stream = s_ostream;\n        }\n\n        WritableByteChannel channel = Channels.newChannel(stream);\n\n        int pos = src.position();\n        try {\n            debug(\"JSSEngine: logUnwrap() - writing \" + src.remaining() + \" bytes.\");\n            channel.write(src);\n            stream.flush();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to log contents of unwrap's src to debug socket: \" + e.getMessage(), e);\n        } finally {\n            src.position(pos);\n        }\n    }\n\n    @Override\n    public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int length) throws IllegalArgumentException, SSLException {\n        debug(\"JSSEngine: unwrap(ssl_fd=\" + ssl_fd + \")\");\n\n        // In this method, we're taking the network wire contents of src and\n        // passing them as the read side of our buffer. If there's any data\n        // for us to read from the remote peer (via ssl_fd), we place it in\n        // the various dsts.\n        //\n        // However, we also need to detect if the handshake is still ongoing;\n        // if so, we can't send data (from src) until then.\n\n        if (ssl_fd == null) {\n            beginHandshake();\n        }\n\n        // Before going much further, check to see if we need to run a\n        // delegated task. So far, the only delegated tasks we have are\n        // for checking TrustManagers.\n        if (checkNeedCertValidation()) {\n            return new SSLEngineResult(SSLEngineResult.Status.OK, handshake_state, 0, 0);\n        }\n\n        boolean handshake_already_complete = ssl_fd.handshakeComplete;\n        int src_capacity = src.remaining();\n\n        logUnwrap(src);\n\n        // Order of operations:\n        //  1. Read data from srcs\n        //  2. Update handshake status\n        //  3. Write data to dsts\n        //\n        // Since srcs is coming from the data, it could affect our ability to\n        // handshake. It could also affect our ability to write data to dsts,\n        // as src could provide new data to decrypt. When no new data from src\n        // is present, we could have residual steps in handshake(), in which\n        // case no data would be written to dsts. Lastly, even if no new data\n        // from srcs, could still have residual data in read_buf, so we should\n        // attempt to read from the ssl_fd.\n        //\n        // In order to handle large buffer sizes, wrap everything in a\n        // do-while loop.\n\n        // wire_data is the number of bytes from src we've written into\n        // read_buf.\n        int wire_data = 0;\n\n        // Actual amount of data written to the buffer.\n        int app_data = 0;\n\n        int this_src_write;\n        int this_dst_write;\n\n        do {\n            this_src_write = 0;\n            this_dst_write = 0;\n\n            if (src != null) {\n                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n\n                // When we have data from src, write it to read_buf.\n                if (this_src_write > 0) {\n                    byte[] wire_buffer = new byte[this_src_write];\n                    src.get(wire_buffer);\n\n                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n\n                    wire_data += this_src_write;\n                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n                }\n            }\n\n            // In the above, we should always try to read and write data. Check to\n            // see if we need to step our handshake process or not.\n            updateHandshakeState();\n\n            int max_dst_size = computeSize(dsts, offset, length);\n            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n            int error = PR.GetError();\n            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n            if (app_buffer != null) {\n                this_dst_write = putData(app_buffer, dsts, offset, length);\n                app_data += this_dst_write;\n            } else if (max_dst_size > 0) {\n                // There are two scenarios we need to ignore here:\n                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n                //     not to block. Usually this means we don't have space\n                //     to write any more data.\n                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n                //     underling cause was fatal, we'd catch it after exiting\n                //     the do-while loop, in checkSSLAlerts().\n                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                    ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                    seen_exception = true;\n                }\n            }\n        } while (this_src_write != 0 || this_dst_write != 0);\n\n        if (seen_exception == false && ssl_exception == null) {\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n        }\n\n        // Before we return, check if an exception occurred and throw it if\n        // one did.\n        if (ssl_exception != null) {\n            info(\"JSSEngine.unwrap() - Got SSLException: \" + ssl_exception);\n            SSLException excpt = ssl_exception;\n            ssl_exception = null;\n            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n            tryCleanup();\n            throw excpt;\n        }\n\n        SSLEngineResult.Status handshake_status = SSLEngineResult.Status.OK;\n\n\n        if (is_inbound_closed) {\n            debug(\"Socket is currently closed.\");\n            handshake_status = SSLEngineResult.Status.CLOSED;\n        } else if (handshake_already_complete && src_capacity > 0 && app_data == 0) {\n            debug(\"Underflowed: produced no application data when we expected to.\");\n            handshake_status = SSLEngineResult.Status.BUFFER_UNDERFLOW;\n        }\n\n        // Need a way to introspect the open/closed state of the TLS\n        // connection.\n\n        debug(\"JSSEngine.unwrap() - Finished\");\n        debug(\" - Status: \" + handshake_status);\n        debug(\" - Handshake State: \" + handshake_state);\n        debug(\" - wire_data: \" + wire_data);\n        debug(\" - app_data: \" + app_data);\n\n        if (handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            returned_finished = true;\n        }\n\n        tryCleanup();\n        return new SSLEngineResult(handshake_status, handshake_state, wire_data, app_data);\n    }\n\n    public int writeData(ByteBuffer[] srcs, int offset, int length) {\n        debug(\"JSSEngine: writeData()\");\n        // This is the tough end of reading/writing. There's two potential\n        // places buffering could occur:\n        //\n        //  - Inside the NSS library (unclear if this happens).\n        //  - write_buf\n        //\n        // So when we call PR.Write(ssl_fd, data), it isn't guaranteed that\n        // we can write all of data to ssl_fd (unlike with all our other read\n        // or write operations where we have a clear bound). In the event that\n        // our Write call is truncated, we have to put data back into the\n        // buffer from whence it was read.\n        //\n        // However, we do use Buffer.WriteCapacity(write_buf) as a proxy\n        // metric for how much we can write without having to place data back\n        // in a src buffer.\n        //\n        // When we don't perform an actual NSPR write call, make a dummy\n        // invocation to ensure we always attempt to flush these buffers.\n        int data_length = 0;\n\n        int index = offset;\n        int max_index = offset + length;\n\n        boolean attempted_write = false;\n\n        while (index < max_index) {\n            // If we don't have any remaining bytes in this buffer, skip it.\n            if (srcs[index] == null || srcs[index].remaining() <= 0) {\n                index += 1;\n                continue;\n            }\n            debug(\"JSSEngine.writeData(): index=\" + index + \" max_index=\" + max_index);\n\n            // We expect (i.e., need to construct a buffer) to write up to\n            // this much. Note that this is non-zero since we're taking the\n            // max here and we guarantee with the previous statement that\n            // srcs[index].remaining() > 0. There's no point in getting more\n            // than BUFFER_SIZE bytes either; so cap at the minimum of the\n            // two sizes.\n            int expected_write = Math.min(srcs[index].remaining(), BUFFER_SIZE);\n            debug(\"JSSEngine.writeData(): expected_write=\" + expected_write + \" write_cap=\" + Buffer.WriteCapacity(write_buf) + \" read_cap=\" + Buffer.ReadCapacity(read_buf));\n\n            // Get data from our current srcs[index] buffer.\n            byte[] app_data = new byte[expected_write];\n            srcs[index].get(app_data);\n\n            // Actual amount written. Since this is a PR.Write call, mark\n            // attempted_write.\n            int this_write = PR.Write(ssl_fd, app_data);\n            attempted_write = true;\n\n            // Reset our buffer's position in event of sub-optimal write.\n            if (this_write < expected_write) {\n                int pos = srcs[index].position();\n\n                // When this_write < 0, we want to reset to the beginning\n                // because we assume we haven't written any data due to an\n                // error before writing.\n                int delta = expected_write - Math.max(0, this_write);\n\n                srcs[index].position(pos - delta);\n            }\n\n            debug(\"JSSEngine.writeData(): this_write=\" + this_write);\n            if (this_write < 0) {\n                int error = PR.GetError();\n                if (error == PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                    debug(\"NSPR reports outbound socket is shutdown.\");\n                    is_outbound_closed = true;\n                } else if (error != PRErrors.WOULD_BLOCK_ERROR) {\n                    throw new RuntimeException(\"Unable to write to internal ssl_fd: \" + errorText(PR.GetError()));\n                }\n\n                break;\n            }\n\n            data_length += this_write;\n\n            if (this_write < expected_write) {\n                // If we didn't get an error but we got less than our expected\n                // write, it is best to exit to give us time to drain the\n                // buffers before attempting another write. We're guaranteed\n                // to be called again because we wrote a non-zero amount here.\n                break;\n            }\n        }\n\n        // When we didn't call PR.Write, invoke a dummy call to PR.Write to\n        // ensure we always attempt to write to push data from NSS's internal\n        // buffers into our network buffers.\n        if (!attempted_write) {\n            PR.Write(ssl_fd, null);\n        }\n\n        debug(\"JSSEngine.writeData(): data_length=\" + data_length);\n\n        return data_length;\n    }\n\n    private void logWrap(ByteBuffer dst) {\n        if (debug_port <= 0 || dst == null || dst.remaining() == 0) {\n            return;\n        }\n\n        loggingSocketConsumeAllBytes();\n\n        OutputStream stream = s_ostream;\n\n        if (!as_server) {\n            // A wrap from the client means we write data to the outbound\n            // side of the client socket.\n            stream = c_ostream;\n        }\n\n        WritableByteChannel channel = Channels.newChannel(stream);\n\n        int pos = dst.position();\n        try {\n            dst.flip();\n            debug(\"JSSEngine: logWrap() - writing \" + dst.remaining() + \" bytes.\");\n            channel.write(dst);\n            stream.flush();\n            dst.flip();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to log contents of wrap's dst to debug socket: \" + e.getMessage(), e);\n        } finally {\n            dst.position(pos);\n        }\n    }\n\n    @Override\n    public SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws IllegalArgumentException, SSLException {\n        debug(\"JSSEngine: wrap(ssl_fd=\" + ssl_fd + \")\");\n        // In this method, we're taking the application data from the various\n        // srcs and writing it to the remote peer (via ssl_fd). If there's any\n        // data for us to send to the remote peer, we place it in dst.\n        //\n        // However, we also need to detect if the handshake is still ongoing;\n        // if so, we can't send data (from src) until then.\n\n        if (ssl_fd == null) {\n            beginHandshake();\n        }\n\n        // Before going much further, check to see if we need to run a\n        // delegated task. So far, the only delegated tasks we have are\n        // for checking TrustManagers.\n        if (checkNeedCertValidation()) {\n            return new SSLEngineResult(SSLEngineResult.Status.OK, handshake_state, 0, 0);\n        }\n\n        // Order of operations:\n        //  1. Step the handshake\n        //  2. Write data from srcs to ssl_fd\n        //  3. Write data from write_buf to dst\n        //\n        // This isn't technically locally optimal: it could be that write_buf\n        // is full while we're handshaking so step 1 could be a no-op, but\n        // we could read from write_buf and step the handshake then. However,\n        // on our next call to wrap() would also step the handshake, which\n        // two in a row would almost certainly result in one being a no-op.\n        // Both steps 1 and 2 could write data to dsts. At best 2 will fail if\n        // write_buf is full, however, we'd again end up calling wrap() again\n        // anyways.\n        //\n        // Note that allowances are given for underflow but not overflow: a\n        // single call to PR.Write() might not suffice for step 2; we might\n        // need to execute step 3 and come back and re-execute steps 2 and 3\n        // multiple times in order to send all data. However, since this could\n        // technically also be true of the handshake itself, wrap everything\n        // in the do-while loop.\n\n        // Actual amount of data read from srcs (and written to ssl_fd). This\n        // is determined by the PR.Write(...) call on ssl_fd.\n        int app_data = 0;\n\n        // wire_data is the number of bytes written to dst. This is bounded\n        // above by two fields: the number of bytes we can read from\n        // write_buf, and the size of dst, if present.\n        int wire_data = 0;\n\n        if (is_inbound_closed && !is_outbound_closed) {\n            closeOutbound();\n        }\n\n        int this_src_write;\n        int this_dst_write;\n        do {\n            this_src_write = 0;\n            this_dst_write = 0;\n\n            // First we try updating the handshake state.\n            updateHandshakeState();\n            if (ssl_exception == null && seen_exception) {\n                if (handshake_state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                    // In the event that:\n                    //\n                    //      1. We saw an exception in the past\n                    //          --> (seen_exception is true),\n                    //      2. We've already thrown it from wrap or unwrap,\n                    //          --> (ssl_exception is null),\n                    //      3. We were previously handshaking\n                    //          --> (handshake_state is a handshaking state),\n                    //\n                    // we need to make sure wrap is called again to ensure the\n                    // alert is actually written to the wire. So here we are,\n                    // in wrap and the above hold true; we can mark the handshake\n                    // status as \"FINISHED\" (because well, it is over due to the\n                    // alert). That leaves the return state to be anything other\n                    // than OK to indicate the error.\n                    handshake_state = SSLEngineResult.HandshakeStatus.FINISHED;\n                }\n            }\n\n            // Try writing data from srcs to the other end of the connection. Note\n            // that we always attempt this, even if the handshake isn't yet marked\n            // as finished. This is because we need the call to PR.Write(...) to\n            // tell if an alert is getting sent.\n            this_src_write = writeData(srcs, offset, length);\n            if (this_src_write > 0) {\n                app_data += this_src_write;\n                debug(\"JSSEngine.wrap(): wrote \" + this_src_write + \" from srcs to buffer.\");\n            } else {\n                debug(\"JSSEngine.wrap(): not writing from srcs to buffer: this_src_write=\" + this_src_write);\n            }\n\n            if (dst != null) {\n                // Get an estimate for the expected write to dst; this is\n                // the minimum of write_buf read capacity and dst.remaining\n                // capacity.\n                this_dst_write = Math.min((int) Buffer.ReadCapacity(write_buf), dst.remaining());\n\n                // Try reading data from write_buf to dst; always do this, even\n                // if we didn't write.\n                if (this_dst_write > 0) {\n                    byte[] wire_buffer = Buffer.Read(write_buf, this_dst_write);\n                    dst.put(wire_buffer);\n                    this_dst_write = wire_buffer.length;\n                    wire_data += this_dst_write;\n\n                    debug(\"JSSEngine.wrap() - Wrote \" + wire_buffer.length + \" bytes to dst.\");\n                } else {\n                    debug(\"JSSEngine.wrap(): not writing from write_buf into dst: this_dst_write=0 write_buf.read_capacity=\" + Buffer.ReadCapacity(write_buf) + \" dst.remaining=\" + dst.remaining());\n                }\n            } else {\n                debug(\"JSSEngine.wrap(): not writing from write_buf into NULL dst\");\n            }\n        } while (this_src_write != 0 || this_dst_write != 0);\n\n        if (seen_exception == false && ssl_exception == null) {\n            ssl_exception = checkSSLAlerts();\n            seen_exception = (ssl_exception != null);\n        }\n\n        logWrap(dst);\n\n        // Before we return, check if an exception occurred and throw it if\n        // one did.\n        if (ssl_exception != null) {\n            info(\"JSSEngine.wrap() - Got SSLException: \" + ssl_exception);\n            SSLException excpt = ssl_exception;\n            ssl_exception = null;\n            cleanup();\n            throw excpt;\n        }\n\n        // Need a way to introspect the open/closed state of the TLS\n        // connection.\n\n        SSLEngineResult.Status handshake_status = SSLEngineResult.Status.OK;\n\n        if (ssl_exception == null && seen_exception) {\n            debug(\"Seen and processed exception; closing inbound and outbound because this was the last wrap(...)\");\n            closeInbound();\n            closeOutbound();\n        }\n\n        if (is_outbound_closed) {\n            debug(\"Socket is currently closed.\");\n            handshake_status = SSLEngineResult.Status.CLOSED;\n        }\n\n        debug(\"JSSEngine.wrap() - Finished\");\n        debug(\" - Status: \" + handshake_status);\n        debug(\" - Handshake State: \" + handshake_state);\n        debug(\" - wire_data: \" + wire_data);\n        debug(\" - app_data: \" + app_data);\n\n        if (handshake_state == SSLEngineResult.HandshakeStatus.FINISHED) {\n            returned_finished = true;\n        }\n\n        tryCleanup();\n        return new SSLEngineResult(handshake_status, handshake_state, app_data, wire_data);\n    }\n\n    /**\n     * Calls cleanup only if both inbound and outbound data streams are\n     * closed.\n     *\n     * This prevents accidental cleanup in the case of a partially open\n     * connection.\n     */\n    @Override\n    public void tryCleanup() {\n        debug(\"JSSEngine: tryCleanup()\");\n        if (is_inbound_closed && is_outbound_closed) {\n            // throw new RuntimeException(\"Probably shouldn't be here!\");\n            cleanup();\n        }\n    }\n\n    /**\n     * Performs cleanup of internal data, closing both inbound and outbound\n     * data streams if still open.\n     */\n    @Override\n    public void cleanup() {\n        debug(\"JSSEngine: cleanup()\");\n\n        if (!is_inbound_closed) {\n            debug(\"JSSEngine: cleanup() - closing opened inbound socket\");\n            closeInbound();\n        }\n\n        if (!is_outbound_closed) {\n            debug(\"JSSEngine: cleanup() - closing opened outbound socket\");\n            closeOutbound();\n        }\n\n        // First cleanup any debugging ports, if any.\n        cleanupLoggingSocket();\n\n        // Then clean up the NSS state.\n        cleanupSSLFD();\n\n        // Clean up the session.\n        if (session != null) {\n            session.close();\n            session = null;\n        }\n    }\n\n    private void cleanupLoggingSocket() {\n        if (debug_port > 0) {\n            try {\n                s_socket.close();\n            } catch (Exception e) {}\n\n            try {\n                c_socket.close();\n            } catch (Exception e) {}\n\n            try {\n                ss_socket.close();\n            } catch (Exception e) {}\n        }\n    }\n\n    private void cleanupSSLFD() {\n        if (!closed_fd && ssl_fd != null) {\n            try {\n                SSL.RemoveCallbacks(ssl_fd);\n                ssl_fd.close();\n                ssl_fd = null;\n            } catch (Exception e) {\n                logger.error(\"Got exception trying to cleanup SSLFD\", e);\n            } finally {\n                closed_fd = true;\n            }\n        }\n\n        if (read_buf != null) {\n            Buffer.Free(read_buf);\n            read_buf = null;\n        }\n\n        if (write_buf != null) {\n            Buffer.Free(write_buf);\n            write_buf = null;\n        }\n    }\n\n    // During testing with Tomcat 8.5, most instances did not call\n    // cleanup, so all the JNI resources end up getting leaked: ssl_fd\n    // (and its global ref), read_buf, and write_buf.\n    @Override\n    protected void finalize() {\n        cleanup();\n    }\n\n\n    private class CertValidationTask extends CertAuthHandler {\n        public CertValidationTask(SSLFDProxy fd) {\n            super(fd);\n        }\n\n        public String findAuthType(SSLFDProxy ssl_fd, PK11Cert[] chain) throws Exception {\n            // Java's CryptoManager is supposed to validate that the auth type\n            // chosen by the underlying protocol is compatible with the\n            // certificates in the channel. With TLSv1.3, this is less of a\n            // concern. However, NSS doesn't directly expose an authType\n            // compatible with Java; we're left inquiring for similar\n            // information from the channel info.\n\n            SSLPreliminaryChannelInfo info = SSL.GetPreliminaryChannelInfo(ssl_fd);\n            if (info == null) {\n                String msg = \"Expected non-null result from GetPreliminaryChannelInfo!\";\n                throw new RuntimeException(msg);\n            }\n\n            if (!info.haveProtocolVersion()) {\n                String msg = \"Expected SSLPreliminaryChannelInfo (\";\n                msg += info + \") to have protocol information.\";\n                throw new RuntimeException(msg);\n            }\n\n            if (!info.haveCipherSuite()) {\n                String msg = \"Expected SSLPreliminaryChannelInfo (\";\n                msg += info + \") to have cipher suite information.\";\n                throw new RuntimeException(msg);\n            }\n\n            SSLVersion version = info.getProtocolVersion();\n            SSLCipher suite = info.getCipherSuite();\n\n            if (version.value() < SSLVersion.TLS_1_3.value()) {\n                // When we're doing a TLSv1.2 or earlier protocol exchange,\n                // we can simply check the cipher suite value for the\n                // authentication type.\n                if (suite.requiresRSACert()) {\n                    // Java expects RSA_EXPORT to be handled properly.\n                    // However, rather than checking the actual bits in\n                    // the RSA certificate, return it purely based on\n                    // cipher suite name. In modern reality, these ciphers\n                    // should _NEVER_ be negotiated!\n                    if (suite.name().contains(\"RSA_EXPORT\")) {\n                        return \"RSA_EXPORT\";\n                    }\n\n                    return \"RSA\";\n                } else if (suite.requiresECDSACert()) {\n                    return \"ECDSA\";\n                } else if (suite.requiresDSSCert()) {\n                    // Notably, DSS is the same as DSA, but the suite names\n                    // all use DSS while the JDK uses DSA.\n                    return \"DSA\";\n                }\n                // Implicit else: authType == null, causing TrustManager\n                // check to fail.\n            } else {\n                // For TLSv1.3 and any later protocols, we can't rely on\n                // the above requires() checks, because the actual\n                // signature type depends on the type of the certificate\n                // provided. This makes the TrustManager field redundant,\n                // but yet we still have to provide it.\n                if (chain != null && chain.length > 0 && chain[0] != null) {\n                    PK11Cert cert = chain[0];\n                    PublicKey key = cert.getPublicKey();\n                    return key.getAlgorithm();\n                }\n                // Implicit else here and above: authType == null, which\n                // will cause the TrustManager check to fail.\n            }\n\n            return null;\n        }\n\n        @Override\n        public int check(SSLFDProxy fd) {\n            // Needs to be available for assignException() below.\n            PK11Cert[] chain = null;\n\n            try {\n                chain = SSL.PeerCertificateChain(fd);\n                String authType = findAuthType(fd, chain);\n                debug(\"CertAuthType: \" + authType);\n\n                if (chain == null || chain.length == 0) {\n                    // When the chain is NULL, we'd always fail in the\n                    // TrustManager calls, beacuse they expect a non-NULL,\n                    // non-empty chain. However, this is sometimes desired,\n                    // for instance, if we requested the peer to provide a\n                    // certificate chain and they didn't.\n                    if (as_server == true && !need_client_auth) {\n                        // Since we're a server validating the client's\n                        // chain (and they didn't provide one), we should\n                        // ignore it instead of forcing the problem.\n                        debug(\"No client certificate chain and client cert not needed.\");\n                        return 0;\n                    }\n                }\n\n                for (X509TrustManager tm : trust_managers) {\n                    // X509ExtendedTrustManager lets the TM access the\n                    // SSLEngine while validating certificates. Otherwise,\n                    // the X509TrustManager doesn't have access to that\n                    // parameter. Facilitate it if possible.\n                    if (tm instanceof X509ExtendedTrustManager) {\n                        X509ExtendedTrustManager etm = (X509ExtendedTrustManager) tm;\n                        if (as_server) {\n                            etm.checkClientTrusted(chain, authType, JSSEngineReferenceImpl.this);\n                        } else {\n                            etm.checkServerTrusted(chain, authType, JSSEngineReferenceImpl.this);\n                        }\n                    } else {\n                        if (as_server) {\n                            tm.checkClientTrusted(chain, authType);\n                        } else {\n                            tm.checkServerTrusted(chain, authType);\n                        }\n                    }\n                }\n            } catch (Exception excpt) {\n                return assignException(excpt, chain);\n            }\n\n            return 0;\n        }\n\n        private int assignException(Exception excpt, PK11Cert[] chain) {\n            int nss_code = Cert.MatchExceptionToNSSError(excpt);\n\n            if (seen_exception) {\n                return nss_code;\n            }\n\n            String msg = \"Got exception while trying to validate \";\n            msg += \"peer's certificate chain:\\n\";\n            if (chain == null) {\n                msg += \" - (null chain)\\n\";\n            } else if (chain.length == 0) {\n                msg += \" - (0 length chain)\\n\";\n            } else {\n                for (PK11Cert cert : chain) {\n                    msg += \" - \" + cert + \"\\n\";\n                }\n            }\n            msg += \"with given TrustManagers:\\n\";\n            if (trust_managers == null) {\n                msg += \" - (null TrustManagers)\\n\";\n            } else if (trust_managers.length == 0) {\n                msg += \" - (0 length TrustManagers)\\n\";\n            } else {\n                for (X509TrustManager tm : trust_managers) {\n                    msg += \" - \" + tm + \"\\n\";\n                }\n            }\n            msg += \"exception message: \" + excpt.getMessage();\n\n            seen_exception = true;\n            ssl_exception = new SSLException(msg, excpt);\n            return nss_code;\n        }\n    }\n\n    private class BypassBadHostname extends BadCertHandler {\n        public BypassBadHostname(SSLFDProxy fd, int error) {\n            super(fd, error);\n        }\n\n        @Override\n        public int check(SSLFDProxy fd, int error) {\n            // NSS enforces strict hostname verification via the SSL_SetURL\n            // function call. Java doesn't pass this information to either\n            // SSLSocket or SSLEngine, so we can at best try and infer this\n            // information. However, since this only needs to be validated\n            // on the client side, we can elide this check (like the JCA\n            // suggests and as the SunJSSE implementation does). In order\n            // to do so, we need to check for the BAD_CERT_DOMAIN error\n            // and tell NSS to ignore it.\n            //\n            // This makes the assumptions:\n            //  1. The hostname check is the very last check in the NSS\n            //     certificate validation handler.\n            //  2. As a consequence of (1) an otherwise valid certificate\n            //     will pass all other checks but fail due to hostname==NULL.\n            //  3. As a consequence of (1), all invalid certificates will\n            //     fail earlier.\n            //  4. No other paths report BAD_CERT_DOMAIN earlier than the\n            //     final hostname check.\n            if (error == SSLErrors.BAD_CERT_DOMAIN) {\n                return 0;\n            }\n\n            return error;\n        }\n    }\n}\n"], "filenames": ["src/main/java/org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java"], "buggy_code_start_loc": [964], "buggy_code_end_loc": [989], "fixing_code_start_loc": [963], "fixing_code_end_loc": [986], "type": "CWE-401", "message": "A flaw was found in JSS, where it did not properly free up all memory. Over time, the wasted memory builds up in the server memory, saturating the server\u2019s RAM. This flaw allows an attacker to force the invocation of an out-of-memory process, causing a denial of service.", "other": {"cve": {"id": "CVE-2021-4213", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-24T16:15:09.980", "lastModified": "2022-08-29T13:19:08.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in JSS, where it did not properly free up all memory. Over time, the wasted memory builds up in the server memory, saturating the server\u2019s RAM. This flaw allows an attacker to force the invocation of an out-of-memory process, causing a denial of service."}, {"lang": "es", "value": "Se ha encontrado un fallo en JSS, que no libera apropiadamente toda la memoria. Con el tiempo, la memoria desperdiciada es acumulada en la memoria del servidor, saturando la RAM del mismo. Este fallo permite a un atacante forzar la invocaci\u00f3n de un proceso fuera de memoria, causando una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dogtagpki:network_security_services_for_java:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.3", "matchCriteriaId": "FE906ED1-3382-4027-81C4-4572B2E27BC2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dogtagpki:network_security_services_for_java:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.1.0", "matchCriteriaId": "AC95A8E0-BC9C-495E-B675-A2ECD52CC984"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-4213", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2042900", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/dogtagpki/jss/commit/3aabe0e9d59b0a42e68ac8cd0468f9c5179967d2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dogtagpki/jss/commit/5922560a78d0dee61af8a33cc9cfbf4cfa291448", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2021-4213", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dogtagpki/jss/commit/3aabe0e9d59b0a42e68ac8cd0468f9c5179967d2"}}