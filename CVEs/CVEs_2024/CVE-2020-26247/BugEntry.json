{"buggy_code": ["/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.iso_relax.verifier.Schema;\nimport org.iso_relax.verifier.Verifier;\nimport org.iso_relax.verifier.VerifierConfigurationException;\nimport org.iso_relax.verifier.VerifierFactory;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.runtime.ThreadContext;\nimport org.w3c.dom.Document;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\n\n/**\n * Class for Nokogiri::XML::RelaxNG\n * \n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::RelaxNG\", parent=\"Nokogiri::XML::Schema\")\npublic class XmlRelaxng extends XmlSchema {\n    private Verifier verifier;\n\n    public XmlRelaxng(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n    \n    private void setVerifier(Verifier verifier) {\n        this.verifier = verifier;\n    }\n    \n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n        Ruby runtime = context.getRuntime();\n        XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);\n        xmlRelaxng.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        \n        try {\n            Schema schema = xmlRelaxng.getSchema(source, context);\n            xmlRelaxng.setVerifier(schema.newVerifier());\n            return xmlRelaxng;\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    private Schema getSchema(Source source, ThreadContext context) {\n        InputStream is;\n        VerifierFactory factory = new com.thaiopensource.relaxng.jarv.VerifierFactoryImpl();\n        if (source instanceof StreamSource) {\n            StreamSource ss = (StreamSource)source;\n            is = ss.getInputStream();\n        } else { //if (this.source instanceof DOMSource)\n            DOMSource ds = (DOMSource)source;\n            StringWriter xmlAsWriter = new StringWriter();\n            StreamResult result = new StreamResult(xmlAsWriter);\n            try {\n                TransformerFactory.newInstance().newTransformer().transform(ds, result);\n            } catch (TransformerConfigurationException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            } catch (TransformerException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n            try {\n                is = new ByteArrayInputStream(xmlAsWriter.toString().getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n        }\n\n        try {\n            return factory.compileSchema(is);\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (SAXException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (IOException ex) {\n            throw context.getRuntime().newIOError(ex.getMessage());\n        }\n    }\n    \n    @Override\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        verifier.setErrorHandler(errorHandler);\n    }\n    \n    @Override\n    protected void validate(Document document) throws SAXException, IOException {\n        verifier.verify(document);\n    }\n}\n", "/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.adjustSystemIdIfNecessary;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\n\nimport nokogiri.internals.IgnoreSchemaErrorsErrorHandler;\nimport nokogiri.internals.SchemaErrorHandler;\nimport nokogiri.internals.XmlDomParserContext;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.Visibility;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.ls.LSInput;\nimport org.w3c.dom.ls.LSResourceResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Class for Nokogiri::XML::Schema\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::Schema\")\npublic class XmlSchema extends RubyObject {\n    private Validator validator;\n\n    public XmlSchema(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n\n    /**\n     * Create and return a copy of this object.\n     *\n     * @return a clone of this object\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    private Schema getSchema(Source source, String currentDir, String scriptFileName, SchemaErrorHandler error_handler) throws SAXException {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        SchemaResourceResolver resourceResolver = new SchemaResourceResolver(currentDir, scriptFileName, null, error_handler);\n        schemaFactory.setResourceResolver(resourceResolver);\n        schemaFactory.setErrorHandler(error_handler);\n        return schemaFactory.newSchema(source);\n    }\n\n    private void setValidator(Validator validator) {\n        this.validator = validator;\n    }\n\n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source) {\n        Ruby runtime = context.getRuntime();\n        XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n        xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n\n        try {\n            SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));\n            Schema schema = xmlSchema.getSchema(source, context.getRuntime().getCurrentDirectory(), context.getRuntime().getInstanceConfig().getScriptFileName(), error_handler);\n            xmlSchema.setValidator(schema.newValidator());\n            return xmlSchema;\n        } catch (SAXException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    /*\n     * call-seq:\n     *  from_document(doc)\n     *\n     * Create a new Schema from the Nokogiri::XML::Document +doc+\n     */\n    @JRubyMethod(meta=true)\n    public static IRubyObject from_document(ThreadContext context, IRubyObject klazz, IRubyObject document) {\n        XmlDocument doc = ((XmlDocument) ((XmlNode) document).document(context));\n\n        RubyArray errors = (RubyArray) doc.getInstanceVariable(\"@errors\");\n        if (!errors.isEmpty()) {\n            throw ((XmlSyntaxError) errors.first()).toThrowable();\n        }\n\n        DOMSource source = new DOMSource(doc.getDocument());\n\n        IRubyObject uri = doc.url(context);\n\n        if (!uri.isNil()) {\n            source.setSystemId(uri.convertToString().asJavaString());\n        }\n\n        return getSchema(context, (RubyClass)klazz, source);\n    }\n\n    private static IRubyObject getSchema(ThreadContext context, RubyClass klazz, Source source) {\n        String moduleName = klazz.getName();\n        if (\"Nokogiri::XML::Schema\".equals(moduleName)) {\n            return XmlSchema.createSchemaInstance(context, klazz, source);\n        } else if (\"Nokogiri::XML::RelaxNG\".equals(moduleName)) {\n            return XmlRelaxng.createSchemaInstance(context, klazz, source);\n        }\n        return context.getRuntime().getNil();\n    }\n\n    @JRubyMethod(meta=true)\n    public static IRubyObject read_memory(ThreadContext context, IRubyObject klazz, IRubyObject content) {\n        String data = content.convertToString().asJavaString();\n        return getSchema(context, (RubyClass) klazz, new StreamSource(new StringReader(data)));\n    }\n\n    @JRubyMethod(visibility=Visibility.PRIVATE)\n    public IRubyObject validate_document(ThreadContext context, IRubyObject document) {\n        return validate_document_or_file(context, (XmlDocument)document);\n    }\n\n    @JRubyMethod(visibility=Visibility.PRIVATE)\n    public IRubyObject validate_file(ThreadContext context, IRubyObject file) {\n        Ruby runtime = context.runtime;\n\n        XmlDomParserContext ctx = new XmlDomParserContext(runtime, RubyFixnum.newFixnum(runtime, 1L));\n        ctx.setInputSourceFile(context, file);\n        XmlDocument xmlDocument = ctx.parse(context, getNokogiriClass(runtime, \"Nokogiri::XML::Document\"), context.nil);\n        return validate_document_or_file(context, xmlDocument);\n    }\n\n    IRubyObject validate_document_or_file(ThreadContext context, XmlDocument xmlDocument) {\n        RubyArray errors = (RubyArray) this.getInstanceVariable(\"@errors\");\n        ErrorHandler errorHandler = new SchemaErrorHandler(context.runtime, errors);\n        setErrorHandler(errorHandler);\n\n        try {\n            validate(xmlDocument.getDocument());\n        }\n        catch (SAXException ex) {\n            XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n            xmlSyntaxError.setException(ex);\n            errors.append(xmlSyntaxError);\n        }\n        catch (IOException ex) {\n            throw context.runtime.newIOError(ex.getMessage());\n        }\n\n        return errors;\n    }\n\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        validator.setErrorHandler(errorHandler);\n    }\n\n    protected void validate(Document document) throws SAXException, IOException {\n        DOMSource docSource = new DOMSource(document);\n        validator.validate(docSource);\n    }\n\n    private class SchemaResourceResolver implements LSResourceResolver {\n        SchemaLSInput lsInput = new SchemaLSInput();\n        String currentDir;\n        String scriptFileName;\n        SchemaErrorHandler error_handler;\n        //String defaultURI;\n\n        SchemaResourceResolver(String currentDir, String scriptFileName, Object input, SchemaErrorHandler error_handler) {\n            this.currentDir = currentDir;\n            this.scriptFileName = scriptFileName;\n            this.error_handler = error_handler;\n            if (input == null) return;\n            if (input instanceof String) {\n                lsInput.setStringData((String)input);\n            } else if (input instanceof Reader) {\n                lsInput.setCharacterStream((Reader)input);\n            } else if (input instanceof InputStream) {\n                lsInput.setByteStream((InputStream)input);\n            }\n        }\n\n        @Override\n        public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {\n            String adjusted = adjustSystemIdIfNecessary(currentDir, scriptFileName, baseURI, systemId);\n            lsInput.setPublicId(publicId);\n            lsInput.setSystemId(adjusted != null? adjusted : systemId);\n            lsInput.setBaseURI(baseURI);\n            return lsInput;\n        }\n    }\n\n    private class SchemaLSInput implements LSInput {\n        protected String fPublicId;\n        protected String fSystemId;\n        protected String fBaseSystemId;\n        protected InputStream fByteStream;\n        protected Reader fCharStream;\n        protected String fData;\n        protected String fEncoding;\n        protected boolean fCertifiedText = false;\n\n        @Override\n        public String getBaseURI() {\n            return fBaseSystemId;\n        }\n\n        @Override\n        public InputStream getByteStream() {\n            return fByteStream;\n        }\n\n        @Override\n        public boolean getCertifiedText() {\n            return fCertifiedText;\n        }\n\n        @Override\n        public Reader getCharacterStream() {\n            return fCharStream;\n        }\n\n        @Override\n        public String getEncoding() {\n            return fEncoding;\n        }\n\n        @Override\n        public String getPublicId() {\n            return fPublicId;\n        }\n\n        @Override\n        public String getStringData() {\n            return fData;\n        }\n\n        @Override\n        public String getSystemId() {\n            return fSystemId;\n        }\n\n        @Override\n        public void setBaseURI(String baseURI) {\n            fBaseSystemId = baseURI;\n        }\n\n        @Override\n        public void setByteStream(InputStream byteStream) {\n            fByteStream = byteStream;\n        }\n\n        @Override\n        public void setCertifiedText(boolean certified) {\n            fCertifiedText = certified;\n        }\n\n        @Override\n        public void setCharacterStream(Reader charStream) {\n            fCharStream = charStream;\n        }\n\n        @Override\n        public void setEncoding(String encoding) {\n            fEncoding = encoding;\n        }\n\n        @Override\n        public void setPublicId(String pubId) {\n            fPublicId = pubId;\n        }\n\n        @Override\n        public void setStringData(String stringData) {\n            fData = stringData;\n        }\n\n        @Override\n        public void setSystemId(String sysId) {\n            fSystemId = sysId;\n        }\n\n    }\n}\n", "#include <xml_relax_ng.h>\n\nstatic void dealloc(xmlRelaxNGPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlRelaxNGFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}\n\n/*\n * call-seq:\n *  validate_document(document)\n *\n * Validate a Nokogiri::XML::Document against this RelaxNG schema.\n */\nstatic VALUE validate_document(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  xmlRelaxNGValidCtxtPtr valid_ctxt;\n\n  Data_Get_Struct(self, xmlRelaxNG, schema);\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\n  xmlRelaxNGSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlRelaxNGValidateDoc(valid_ctxt, doc);\n\n  xmlRelaxNGFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  read_memory(string)\n *\n * Create a new RelaxNG from the contents of +string+\n */\nstatic VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}\n\n/*\n * call-seq:\n *  from_document(doc)\n *\n * Create a new RelaxNG schema from the Nokogiri::XML::Document +doc+\n */\nstatic VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}\n\nVALUE cNokogiriXmlRelaxNG;\nvoid init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}\n", "#include <xml_schema.h>\n\nstatic void dealloc(xmlSchemaPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlSchemaFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}\n\n/*\n * call-seq:\n *  validate_document(document)\n *\n * Validate a Nokogiri::XML::Document against this Schema.\n */\nstatic VALUE validate_document(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaPtr schema;\n  xmlSchemaValidCtxtPtr valid_ctxt;\n  VALUE errors;\n\n  Data_Get_Struct(self, xmlSchema, schema);\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlSchemaNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS\n  xmlSchemaSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlSchemaValidateDoc(valid_ctxt, doc);\n\n  xmlSchemaFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  validate_file(filename)\n *\n * Validate a file against this Schema.\n */\nstatic VALUE validate_file(VALUE self, VALUE rb_filename)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaValidCtxtPtr valid_ctxt;\n  const char *filename ;\n  VALUE errors;\n\n  Data_Get_Struct(self, xmlSchema, schema);\n  filename = (const char*)StringValueCStr(rb_filename) ;\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlSchemaNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS\n  xmlSchemaSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlSchemaValidateFile(valid_ctxt, filename, 0);\n\n  xmlSchemaFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  read_memory(string)\n *\n * Create a new Schema from the contents of +string+\n */\nstatic VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}\n\n/* Schema creation will remove and deallocate \"blank\" nodes.\n * If those blank nodes have been exposed to Ruby, they could get freed\n * out from under the VALUE pointer.  This function checks to see if any of\n * those nodes have been exposed to Ruby, and if so we should raise an exception.\n */\nstatic int has_blank_nodes_p(VALUE cache)\n{\n    long i;\n\n    if (NIL_P(cache)) {\n        return 0;\n    }\n\n    for (i = 0; i < RARRAY_LEN(cache); i++) {\n        xmlNodePtr node;\n        VALUE element = rb_ary_entry(cache, i);\n        Data_Get_Struct(element, xmlNode, node);\n        if (xmlIsBlankNode(node)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * call-seq:\n *  from_document(doc)\n *\n * Create a new Schema from the Nokogiri::XML::Document +doc+\n */\nstatic VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n\n  return Qnil;\n}\n\nVALUE cNokogiriXmlSchema;\nvoid init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n\n  cNokogiriXmlSchema = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    ###\n    # Parse options for passing to Nokogiri.XML or Nokogiri.HTML\n    #\n    # == Building combinations of parse options\n    # You can build your own combinations of these parse options by using any of the following methods:\n    # *Note*: All examples attempt to set the +RECOVER+ & +NOENT+ options.\n    # [Ruby's bitwise operators] You can use the Ruby bitwise operators to set various combinations.\n    #   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new((1 << 0) | (1 << 1)))\n    # [Method chaining] Every option has an equivalent method in lowercase. You can chain these methods together to set various combinations.\n    #   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new.recover.noent)\n    # [Using Ruby Blocks] You can also setup parse combinations in the block passed to Nokogiri.XML or Nokogiri.HTML\n    #   Nokogiri.XML('<content>Chapter 1</content') {|config| config.recover.noent}\n    #\n    # == Removing particular parse options\n    # You can also remove options from an instance of +ParseOptions+ dynamically.\n    # Every option has an equivalent <code>no{option}</code> method in lowercase. You can call these methods on an instance of +ParseOptions+ to remove the option.\n    # Note that this is not available for +STRICT+.\n    #\n    #   # Setting the RECOVER & NOENT options...\n    #   options = Nokogiri::XML::ParseOptions.new.recover.noent\n    #   # later...\n    #   options.norecover # Removes the Nokogiri::XML::ParseOptions::RECOVER option\n    #   options.nonoent # Removes the Nokogiri::XML::ParseOptions::NOENT option\n    #\n    class ParseOptions\n      # Strict parsing\n      STRICT      = 0\n      # Recover from errors\n      RECOVER     = 1 << 0\n      # Substitute entities\n      NOENT       = 1 << 1\n      # Load external subsets\n      DTDLOAD     = 1 << 2\n      # Default DTD attributes\n      DTDATTR     = 1 << 3\n      # validate with the DTD\n      DTDVALID    = 1 << 4\n      # suppress error reports\n      NOERROR     = 1 << 5\n      # suppress warning reports\n      NOWARNING   = 1 << 6\n      # pedantic error reporting\n      PEDANTIC    = 1 << 7\n      # remove blank nodes\n      NOBLANKS    = 1 << 8\n      # use the SAX1 interface internally\n      SAX1        = 1 << 9\n      # Implement XInclude substitution\n      XINCLUDE    = 1 << 10\n      # Forbid network access. Recommended for dealing with untrusted documents.\n      NONET       = 1 << 11\n      # Do not reuse the context dictionary\n      NODICT      = 1 << 12\n      # remove redundant namespaces declarations\n      NSCLEAN     = 1 << 13\n      # merge CDATA as text nodes\n      NOCDATA     = 1 << 14\n      # do not generate XINCLUDE START/END nodes\n      NOXINCNODE  = 1 << 15\n      # compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)\n      COMPACT     = 1 << 16\n      # parse using XML-1.0 before update 5\n      OLD10       = 1 << 17\n      # do not fixup XINCLUDE xml:base uris\n      NOBASEFIX   = 1 << 18\n      # relax any hardcoded limit from the parser\n      HUGE        = 1 << 19\n\n      # the default options used for parsing XML documents\n      DEFAULT_XML  = RECOVER | NONET\n      # the default options used for parsing HTML documents\n      DEFAULT_HTML = RECOVER | NOERROR | NOWARNING | NONET\n\n      attr_accessor :options\n      def initialize options = STRICT\n        @options = options\n      end\n\n      constants.each do |constant|\n        next if constant.to_sym == :STRICT\n        class_eval %{\n          def #{constant.downcase}\n            @options |= #{constant}\n            self\n          end\n\n          def no#{constant.downcase}\n            @options &= ~#{constant}\n            self\n          end\n\n          def #{constant.downcase}?\n            #{constant} & @options == #{constant}\n          end\n        }\n      end\n\n      def strict\n        @options &= ~RECOVER\n        self\n      end\n\n      def strict?\n        @options & RECOVER == STRICT\n      end\n\n      def ==(other)\n        other.to_i == to_i\n      end\n\n      alias :to_i :options\n\n      def inspect\n        options = []\n        self.class.constants.each do |k|\n          options << k.downcase if send(:\"#{k.downcase}?\")\n        end\n        super.sub(/>$/, \" \" + options.join(', ') + \">\")\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    class << self\n      ###\n      # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.\n      # See Nokogiri::XML::RelaxNG for an example.\n      def RelaxNG string_or_io\n        RelaxNG.new(string_or_io)\n      end\n    end\n\n    ###\n    # Nokogiri::XML::RelaxNG is used for validating XML against a\n    # RelaxNG schema.\n    #\n    # == Synopsis\n    #\n    # Validate an XML document against a RelaxNG schema.  Loop over the errors\n    # that are returned and print them out:\n    #\n    #   schema  = Nokogiri::XML::RelaxNG(File.open(ADDRESS_SCHEMA_FILE))\n    #   doc     = Nokogiri::XML(File.open(ADDRESS_XML_FILE))\n    #\n    #   schema.validate(doc).each do |error|\n    #     puts error.message\n    #   end\n    #\n    # The list of errors are Nokogiri::XML::SyntaxError objects.\n    class RelaxNG < Nokogiri::XML::Schema\n    end\n  end\nend\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    class << self\n      ###\n      # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n      # object.\n      def Schema string_or_io\n        Schema.new(string_or_io)\n      end\n    end\n\n    ###\n    # Nokogiri::XML::Schema is used for validating XML against a schema\n    # (usually from an xsd file).\n    #\n    # == Synopsis\n    #\n    # Validate an XML document against a Schema.  Loop over the errors that\n    # are returned and print them out:\n    #\n    #   xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n    #   doc = Nokogiri::XML(File.read(PO_XML_FILE))\n    #\n    #   xsd.validate(doc).each do |error|\n    #     puts error.message\n    #   end\n    #\n    # The list of errors are Nokogiri::XML::SyntaxError objects.\n    class Schema\n      # Errors while parsing the schema file\n      attr_accessor :errors\n\n      ###\n      # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n      # object.\n      def self.new string_or_io\n        from_document Nokogiri::XML(string_or_io)\n      end\n\n      ###\n      # Validate +thing+ against this schema.  +thing+ can be a\n      # Nokogiri::XML::Document object, or a filename.  An Array of\n      # Nokogiri::XML::SyntaxError objects found while validating the\n      # +thing+ is returned.\n      def validate thing\n        if thing.is_a?(Nokogiri::XML::Document) \n          validate_document(thing) \n        elsif File.file?(thing)\n          validate_file(thing)\n        else\n          raise ArgumentError, \"Must provide Nokogiri::Xml::Document or the name of an existing file\"\n        end\n      end\n\n      ###\n      # Returns true if +thing+ is a valid Nokogiri::XML::Document or\n      # file.\n      def valid? thing\n        validate(thing).length == 0\n      end\n    end\n  end\nend\n", "require \"helper\"\n\nmodule Nokogiri\n  module XML\n    class TestRelaxNG < Nokogiri::TestCase\n      def setup\n        assert @schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE))\n      end\n\n      def test_parse_with_memory\n        assert_instance_of Nokogiri::XML::RelaxNG, @schema\n        assert_equal 0, @schema.errors.length\n      end\n\n      def test_new\n        assert schema = Nokogiri::XML::RelaxNG.new(\n          File.read(ADDRESS_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::RelaxNG, schema\n      end\n\n      def test_parse_with_io\n        xsd = nil\n        File.open(ADDRESS_SCHEMA_FILE, 'rb') { |f|\n          assert xsd = Nokogiri::XML::RelaxNG(f)\n        }\n        assert_equal 0, xsd.errors.length\n      end\n\n      def test_parse_with_errors\n        xml = File.read(ADDRESS_SCHEMA_FILE).sub(/name=\"/, 'name=')\n        assert_raises(Nokogiri::XML::SyntaxError) {\n          Nokogiri::XML::RelaxNG(xml)\n        }\n      end\n\n      def test_validate_document\n        doc = Nokogiri::XML(File.read(ADDRESS_XML_FILE))\n        assert errors = @schema.validate(doc)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_invalid_document\n        # Empty address book is not allowed\n        read_doc = '<addressBook></addressBook>'\n\n        assert errors = @schema.validate(Nokogiri::XML(read_doc))\n        assert_equal 1, errors.length\n      end\n\n      def test_valid?\n        valid_doc = Nokogiri::XML(File.read(ADDRESS_XML_FILE))\n\n        invalid_doc = Nokogiri::XML('<addressBook></addressBook>')\n\n        assert(@schema.valid?(valid_doc))\n        assert(!@schema.valid?(invalid_doc))\n      end\n    end\n  end\nend\n", "require \"helper\"\n\nmodule Nokogiri\n  module XML\n    class TestSchema < Nokogiri::TestCase\n      def setup\n        assert @xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n      end\n\n      def test_issue_1985_segv_on_schema_parse\n        skip(\"Pure Java version doesn't have this bug\") unless Nokogiri.uses_libxml?\n\n        # This is a test for a workaround for a bug in LibXML2.  The upstream\n        # bug is here: https://gitlab.gnome.org/GNOME/libxml2/issues/148\n        # Schema creation can result in dangling pointers.  If no nodes have\n        # been exposed, then it should be fine to create a schema.  If nodes\n        # have been exposed to Ruby, then we need to make sure they won't be\n        # freed out from under us.\n        doc = <<~EOF\n          <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n          <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n            <xs:element name=\"foo\" type=\"xs:string\"/>\n          </xs:schema>\n        EOF\n\n        # This is OK, no nodes have been exposed\n        xsd_doc = Nokogiri::XML(doc)\n        assert Nokogiri::XML::Schema.from_document(xsd_doc)\n\n        # This is not OK, nodes have been exposed to Ruby\n        xsd_doc = Nokogiri::XML(doc)\n        xsd_doc.root.children.find(&:blank?) # Finds a node\n\n        ex = assert_raise(ArgumentError) do\n          Nokogiri::XML::Schema.from_document(xsd_doc)\n        end\n        assert_match(/blank nodes/, ex.message)\n      end\n\n      def test_schema_read_memory\n        xsd = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_schema_from_document\n        doc = Nokogiri::XML(File.open(PO_SCHEMA_FILE))\n        assert doc\n        xsd = Nokogiri::XML::Schema.from_document doc\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_invalid_schema_do_not_raise_exceptions\n        xsd = Nokogiri::XML::Schema.new(<<~EOF)\n          <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n            <xs:group name=\"foo1\">\n              <xs:sequence>\n                <xs:element name=\"bar\" type=\"xs:boolean\" />\n              </xs:sequence>\n            </xs:group>\n            <xs:group name=\"foo2\">\n              <xs:sequence>\n                <xs:element name=\"bar\" type=\"xs:string\" />\n              </xs:sequence>\n            </xs:group>\n            <xs:element name=\"foo\">\n              <xs:complexType>\n                <xs:choice>\n                  <xs:group ref=\"foo1\"/>\n                  <xs:group ref=\"foo2\"/>\n                </xs:choice>\n              </xs:complexType>\n            </xs:element>\n          </xs:schema>\n        EOF\n\n        assert_instance_of Nokogiri::XML::Schema, xsd\n\n        if Nokogiri.jruby?\n          assert xsd.errors.length > 0\n          assert_equal 1, xsd.errors.map(&:to_s).grep(/cos-element-consistent/).length\n          assert_equal 1, xsd.errors.map(&:to_s).grep(/cos-nonambig/).length\n        end\n      end\n\n      def test_schema_from_document_node\n        doc = Nokogiri::XML(File.open(PO_SCHEMA_FILE))\n        assert doc\n        xsd = Nokogiri::XML::Schema.from_document doc.root\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_schema_validates_with_relative_paths\n        xsd = File.join(ASSETS_DIR, \"foo\", \"foo.xsd\")\n        xml = File.join(ASSETS_DIR, \"valid_bar.xml\")\n        doc = Nokogiri::XML(File.open(xsd))\n        xsd = Nokogiri::XML::Schema.from_document doc\n\n        doc = Nokogiri::XML(File.open(xml))\n        assert xsd.valid?(doc)\n      end\n\n      def test_parse_with_memory\n        assert_instance_of Nokogiri::XML::Schema, @xsd\n        assert_equal 0, @xsd.errors.length\n      end\n\n      def test_new\n        assert xsd = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_parse_with_io\n        xsd = nil\n        File.open(PO_SCHEMA_FILE, \"rb\") { |f|\n          assert xsd = Nokogiri::XML::Schema(f)\n        }\n        assert_equal 0, xsd.errors.length\n      end\n\n      def test_parse_with_errors\n        xml = File.read(PO_SCHEMA_FILE).sub(/name=\"/, \"name=\")\n        assert_raises(Nokogiri::XML::SyntaxError) {\n          Nokogiri::XML::Schema(xml)\n        }\n      end\n\n      def test_validate_document\n        doc = Nokogiri::XML(File.read(PO_XML_FILE))\n        assert errors = @xsd.validate(doc)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_file\n        assert errors = @xsd.validate(PO_XML_FILE)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_invalid_document\n        doc = Nokogiri::XML File.read(PO_XML_FILE)\n        doc.css(\"city\").unlink\n\n        assert errors = @xsd.validate(doc)\n        assert_equal 2, errors.length\n      end\n\n      def test_validate_invalid_file\n        tempfile = Tempfile.new(\"xml\")\n\n        doc = Nokogiri::XML File.read(PO_XML_FILE)\n        doc.css(\"city\").unlink\n        tempfile.write doc.to_xml\n        tempfile.close\n\n        assert errors = @xsd.validate(tempfile.path)\n        assert_equal 2, errors.length\n      end\n\n      def test_validate_non_document\n        string = File.read(PO_XML_FILE)\n        assert_raise(ArgumentError) { @xsd.validate(string) }\n      end\n\n      def test_valid?\n        valid_doc = Nokogiri::XML(File.read(PO_XML_FILE))\n\n        invalid_doc = Nokogiri::XML(\n          File.read(PO_XML_FILE).gsub(/<city>[^<]*<\\/city>/, \"\")\n        )\n\n        assert(@xsd.valid?(valid_doc))\n        assert(!@xsd.valid?(invalid_doc))\n      end\n\n      def test_xsd_with_dtd\n        Dir.chdir(File.join(ASSETS_DIR, \"saml\")) do\n          # works\n          Nokogiri::XML::Schema(IO.read(\"xmldsig_schema.xsd\"))\n          # was not working\n          Nokogiri::XML::Schema(IO.read(\"saml20protocol_schema.xsd\"))\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.iso_relax.verifier.Schema;\nimport org.iso_relax.verifier.Verifier;\nimport org.iso_relax.verifier.VerifierConfigurationException;\nimport org.iso_relax.verifier.VerifierFactory;\nimport org.jruby.Ruby;\nimport org.jruby.RubyClass;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\n\n/**\n * Class for Nokogiri::XML::RelaxNG\n * \n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::RelaxNG\", parent=\"Nokogiri::XML::Schema\")\npublic class XmlRelaxng extends XmlSchema {\n    private Verifier verifier;\n\n    public XmlRelaxng(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n    \n    private void setVerifier(Verifier verifier) {\n        this.verifier = verifier;\n    }\n    \n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n        Ruby runtime = context.getRuntime();\n        XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);\n\n        if (parseOptions == null) {\n            parseOptions = defaultParseOptions(context.getRuntime());\n        }\n\n        xmlRelaxng.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        xmlRelaxng.setInstanceVariable(\"@parse_options\", parseOptions);\n\n        try {\n            Schema schema = xmlRelaxng.getSchema(source, context);\n            xmlRelaxng.setVerifier(schema.newVerifier());\n            return xmlRelaxng;\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    private Schema getSchema(Source source, ThreadContext context) {\n        InputStream is;\n        VerifierFactory factory = new com.thaiopensource.relaxng.jarv.VerifierFactoryImpl();\n        if (source instanceof StreamSource) {\n            StreamSource ss = (StreamSource)source;\n            is = ss.getInputStream();\n        } else { //if (this.source instanceof DOMSource)\n            DOMSource ds = (DOMSource)source;\n            StringWriter xmlAsWriter = new StringWriter();\n            StreamResult result = new StreamResult(xmlAsWriter);\n            try {\n                TransformerFactory.newInstance().newTransformer().transform(ds, result);\n            } catch (TransformerConfigurationException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            } catch (TransformerException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n            try {\n                is = new ByteArrayInputStream(xmlAsWriter.toString().getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException ex) {\n                throw context.getRuntime()\n                    .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n            }\n        }\n\n        try {\n            return factory.compileSchema(is);\n        } catch (VerifierConfigurationException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (SAXException ex) {\n            throw context.getRuntime()\n                .newRuntimeError(\"Could not parse document: \"+ex.getMessage());\n        } catch (IOException ex) {\n            throw context.getRuntime().newIOError(ex.getMessage());\n        }\n    }\n    \n    @Override\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        verifier.setErrorHandler(errorHandler);\n    }\n    \n    @Override\n    protected void validate(Document document) throws SAXException, IOException {\n        verifier.verify(document);\n    }\n}\n", "/**\n * (The MIT License)\n *\n * Copyright (c) 2008 - 2011:\n *\n * * {Aaron Patterson}[http://tenderlovemaking.com]\n * * {Mike Dalessio}[http://mike.daless.io]\n * * {Charles Nutter}[http://blog.headius.com]\n * * {Sergio Arbeo}[http://www.serabe.com]\n * * {Patrick Mahoney}[http://polycrystal.org]\n * * {Yoko Harada}[http://yokolet.blogspot.com]\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage nokogiri;\n\nimport static nokogiri.internals.NokogiriHelpers.adjustSystemIdIfNecessary;\nimport static nokogiri.internals.NokogiriHelpers.getNokogiriClass;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\n\nimport nokogiri.internals.IgnoreSchemaErrorsErrorHandler;\nimport nokogiri.internals.SchemaErrorHandler;\nimport nokogiri.internals.XmlDomParserContext;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyFixnum;\nimport org.jruby.RubyObject;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.exceptions.RaiseException;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.Visibility;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.ls.LSInput;\nimport org.w3c.dom.ls.LSResourceResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\n/**\n * Class for Nokogiri::XML::Schema\n *\n * @author sergio\n * @author Yoko Harada <yokolet@gmail.com>\n */\n@JRubyClass(name=\"Nokogiri::XML::Schema\")\npublic class XmlSchema extends RubyObject {\n    private Validator validator;\n\n    public XmlSchema(Ruby ruby, RubyClass klazz) {\n        super(ruby, klazz);\n    }\n\n    /**\n     * Create and return a copy of this object.\n     *\n     * @return a clone of this object\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    private Schema getSchema(Source source, String currentDir, String scriptFileName, SchemaErrorHandler error_handler) throws SAXException {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        SchemaResourceResolver resourceResolver = new SchemaResourceResolver(currentDir, scriptFileName, null, error_handler);\n        schemaFactory.setResourceResolver(resourceResolver);\n        schemaFactory.setErrorHandler(error_handler);\n        return schemaFactory.newSchema(source);\n    }\n\n    private void setValidator(Validator validator) {\n        this.validator = validator;\n    }\n\n    static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n        Ruby runtime = context.getRuntime();\n        XmlSchema xmlSchema = (XmlSchema) NokogiriService.XML_SCHEMA_ALLOCATOR.allocate(runtime, klazz);\n\n        if (parseOptions == null) {\n            parseOptions = defaultParseOptions(context.getRuntime());\n        }\n\n        xmlSchema.setInstanceVariable(\"@errors\", runtime.newEmptyArray());\n        xmlSchema.setInstanceVariable(\"@parse_options\", parseOptions);\n\n        try {\n            SchemaErrorHandler error_handler = new SchemaErrorHandler(context.getRuntime(), (RubyArray)xmlSchema.getInstanceVariable(\"@errors\"));\n            Schema schema = xmlSchema.getSchema(source, context.getRuntime().getCurrentDirectory(), context.getRuntime().getInstanceConfig().getScriptFileName(), error_handler);\n            xmlSchema.setValidator(schema.newValidator());\n            return xmlSchema;\n        } catch (SAXException ex) {\n            throw context.getRuntime().newRuntimeError(\"Could not parse document: \" + ex.getMessage());\n        }\n    }\n\n    protected static IRubyObject defaultParseOptions(Ruby runtime) {\n        return ((RubyClass)runtime.getClassFromPath(\"Nokogiri::XML::ParseOptions\")).getConstant(\"DEFAULT_SCHEMA\");\n    }\n\n    /*\n     * call-seq:\n     *  from_document(doc)\n     *\n     * Create a new Schema from the Nokogiri::XML::Document +doc+\n     */\n    @JRubyMethod(meta=true, required=1, optional=1)\n    public static IRubyObject from_document(ThreadContext context, IRubyObject klazz, IRubyObject[] args) {\n        IRubyObject document = args[0];\n        IRubyObject parseOptions = null;\n        if (args.length > 1) {\n            parseOptions = args[1];\n        }\n\n        XmlDocument doc = ((XmlDocument) ((XmlNode) document).document(context));\n\n        RubyArray errors = (RubyArray) doc.getInstanceVariable(\"@errors\");\n        if (!errors.isEmpty()) {\n            throw ((XmlSyntaxError) errors.first()).toThrowable();\n        }\n\n        DOMSource source = new DOMSource(doc.getDocument());\n\n        IRubyObject uri = doc.url(context);\n\n        if (!uri.isNil()) {\n            source.setSystemId(uri.convertToString().asJavaString());\n        }\n\n        return getSchema(context, (RubyClass)klazz, source, parseOptions);\n    }\n\n    @JRubyMethod(meta=true, required=1, optional=1)\n    public static IRubyObject read_memory(ThreadContext context, IRubyObject klazz, IRubyObject[] args) {\n        IRubyObject content = args[0];\n        IRubyObject parseOptions = null;\n        if (args.length > 1) {\n            parseOptions = args[1];\n        }\n        String data = content.convertToString().asJavaString();\n        return getSchema(context, (RubyClass) klazz, new StreamSource(new StringReader(data)), parseOptions);\n    }\n\n    private static IRubyObject getSchema(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {\n        String moduleName = klazz.getName();\n        if (\"Nokogiri::XML::Schema\".equals(moduleName)) {\n            return XmlSchema.createSchemaInstance(context, klazz, source, parseOptions);\n        } else if (\"Nokogiri::XML::RelaxNG\".equals(moduleName)) {\n            return XmlRelaxng.createSchemaInstance(context, klazz, source, parseOptions);\n        }\n        return context.getRuntime().getNil();\n    }\n\n    @JRubyMethod(visibility=Visibility.PRIVATE)\n    public IRubyObject validate_document(ThreadContext context, IRubyObject document) {\n        return validate_document_or_file(context, (XmlDocument)document);\n    }\n\n    @JRubyMethod(visibility=Visibility.PRIVATE)\n    public IRubyObject validate_file(ThreadContext context, IRubyObject file) {\n        Ruby runtime = context.runtime;\n\n        XmlDomParserContext ctx = new XmlDomParserContext(runtime, RubyFixnum.newFixnum(runtime, 1L));\n        ctx.setInputSourceFile(context, file);\n        XmlDocument xmlDocument = ctx.parse(context, getNokogiriClass(runtime, \"Nokogiri::XML::Document\"), context.nil);\n        return validate_document_or_file(context, xmlDocument);\n    }\n\n    IRubyObject validate_document_or_file(ThreadContext context, XmlDocument xmlDocument) {\n        RubyArray errors = (RubyArray) this.getInstanceVariable(\"@errors\");\n        ErrorHandler errorHandler = new SchemaErrorHandler(context.runtime, errors);\n        setErrorHandler(errorHandler);\n\n        try {\n            validate(xmlDocument.getDocument());\n        }\n        catch (SAXException ex) {\n            XmlSyntaxError xmlSyntaxError = XmlSyntaxError.createXMLSyntaxError(context.runtime);\n            xmlSyntaxError.setException(ex);\n            errors.append(xmlSyntaxError);\n        }\n        catch (IOException ex) {\n            throw context.runtime.newIOError(ex.getMessage());\n        }\n\n        return errors;\n    }\n\n    protected void setErrorHandler(ErrorHandler errorHandler) {\n        validator.setErrorHandler(errorHandler);\n    }\n\n    protected void validate(Document document) throws SAXException, IOException {\n        DOMSource docSource = new DOMSource(document);\n        validator.validate(docSource);\n    }\n\n    private class SchemaResourceResolver implements LSResourceResolver {\n        SchemaLSInput lsInput = new SchemaLSInput();\n        String currentDir;\n        String scriptFileName;\n        SchemaErrorHandler error_handler;\n        //String defaultURI;\n\n        SchemaResourceResolver(String currentDir, String scriptFileName, Object input, SchemaErrorHandler error_handler) {\n            this.currentDir = currentDir;\n            this.scriptFileName = scriptFileName;\n            this.error_handler = error_handler;\n            if (input == null) return;\n            if (input instanceof String) {\n                lsInput.setStringData((String)input);\n            } else if (input instanceof Reader) {\n                lsInput.setCharacterStream((Reader)input);\n            } else if (input instanceof InputStream) {\n                lsInput.setByteStream((InputStream)input);\n            }\n        }\n\n        @Override\n        public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {\n            String adjusted = adjustSystemIdIfNecessary(currentDir, scriptFileName, baseURI, systemId);\n            lsInput.setPublicId(publicId);\n            lsInput.setSystemId(adjusted != null? adjusted : systemId);\n            lsInput.setBaseURI(baseURI);\n            return lsInput;\n        }\n    }\n\n    private class SchemaLSInput implements LSInput {\n        protected String fPublicId;\n        protected String fSystemId;\n        protected String fBaseSystemId;\n        protected InputStream fByteStream;\n        protected Reader fCharStream;\n        protected String fData;\n        protected String fEncoding;\n        protected boolean fCertifiedText = false;\n\n        @Override\n        public String getBaseURI() {\n            return fBaseSystemId;\n        }\n\n        @Override\n        public InputStream getByteStream() {\n            return fByteStream;\n        }\n\n        @Override\n        public boolean getCertifiedText() {\n            return fCertifiedText;\n        }\n\n        @Override\n        public Reader getCharacterStream() {\n            return fCharStream;\n        }\n\n        @Override\n        public String getEncoding() {\n            return fEncoding;\n        }\n\n        @Override\n        public String getPublicId() {\n            return fPublicId;\n        }\n\n        @Override\n        public String getStringData() {\n            return fData;\n        }\n\n        @Override\n        public String getSystemId() {\n            return fSystemId;\n        }\n\n        @Override\n        public void setBaseURI(String baseURI) {\n            fBaseSystemId = baseURI;\n        }\n\n        @Override\n        public void setByteStream(InputStream byteStream) {\n            fByteStream = byteStream;\n        }\n\n        @Override\n        public void setCertifiedText(boolean certified) {\n            fCertifiedText = certified;\n        }\n\n        @Override\n        public void setCharacterStream(Reader charStream) {\n            fCharStream = charStream;\n        }\n\n        @Override\n        public void setEncoding(String encoding) {\n            fEncoding = encoding;\n        }\n\n        @Override\n        public void setPublicId(String pubId) {\n            fPublicId = pubId;\n        }\n\n        @Override\n        public void setStringData(String stringData) {\n            fData = stringData;\n        }\n\n        @Override\n        public void setSystemId(String sysId) {\n            fSystemId = sysId;\n        }\n\n    }\n}\n", "#include <xml_relax_ng.h>\n\nstatic void dealloc(xmlRelaxNGPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlRelaxNGFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}\n\n/*\n * call-seq:\n *  validate_document(document)\n *\n * Validate a Nokogiri::XML::Document against this RelaxNG schema.\n */\nstatic VALUE validate_document(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  xmlRelaxNGValidCtxtPtr valid_ctxt;\n\n  Data_Get_Struct(self, xmlRelaxNG, schema);\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlRelaxNGNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLRELAXNGSETVALIDSTRUCTUREDERRORS\n  xmlRelaxNGSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlRelaxNGValidateDoc(valid_ctxt, doc);\n\n  xmlRelaxNGFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  read_memory(string)\n *\n * Create a new RelaxNG from the contents of +string+\n */\nstatic VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n\n/*\n * call-seq:\n *  from_document(doc)\n *\n * Create a new RelaxNG schema from the Nokogiri::XML::Document +doc+\n */\nstatic VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n\nVALUE cNokogiriXmlRelaxNG;\nvoid init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}\n", "#include <xml_schema.h>\n\nstatic void dealloc(xmlSchemaPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlSchemaFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}\n\n/*\n * call-seq:\n *  validate_document(document)\n *\n * Validate a Nokogiri::XML::Document against this Schema.\n */\nstatic VALUE validate_document(VALUE self, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaPtr schema;\n  xmlSchemaValidCtxtPtr valid_ctxt;\n  VALUE errors;\n\n  Data_Get_Struct(self, xmlSchema, schema);\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlSchemaNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS\n  xmlSchemaSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlSchemaValidateDoc(valid_ctxt, doc);\n\n  xmlSchemaFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  validate_file(filename)\n *\n * Validate a file against this Schema.\n */\nstatic VALUE validate_file(VALUE self, VALUE rb_filename)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaValidCtxtPtr valid_ctxt;\n  const char *filename ;\n  VALUE errors;\n\n  Data_Get_Struct(self, xmlSchema, schema);\n  filename = (const char*)StringValueCStr(rb_filename) ;\n\n  errors = rb_ary_new();\n\n  valid_ctxt = xmlSchemaNewValidCtxt(schema);\n\n  if(NULL == valid_ctxt) {\n    /* we have a problem */\n    rb_raise(rb_eRuntimeError, \"Could not create a validation context\");\n  }\n\n#ifdef HAVE_XMLSCHEMASETVALIDSTRUCTUREDERRORS\n  xmlSchemaSetValidStructuredErrors(\n    valid_ctxt,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  xmlSchemaValidateFile(valid_ctxt, filename, 0);\n\n  xmlSchemaFreeValidCtxt(valid_ctxt);\n\n  return errors;\n}\n\n/*\n * call-seq:\n *  read_memory(string)\n *\n * Create a new Schema from the contents of +string+\n */\nstatic VALUE read_memory(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE content;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &content, &parse_options);\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  ctx = xmlSchemaNewMemParserCtxt((const char *)StringValuePtr(content), (int)RSTRING_LEN(content));\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n    );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}\n\n/* Schema creation will remove and deallocate \"blank\" nodes.\n * If those blank nodes have been exposed to Ruby, they could get freed\n * out from under the VALUE pointer.  This function checks to see if any of\n * those nodes have been exposed to Ruby, and if so we should raise an exception.\n */\nstatic int has_blank_nodes_p(VALUE cache)\n{\n    long i;\n\n    if (NIL_P(cache)) {\n        return 0;\n    }\n\n    for (i = 0; i < RARRAY_LEN(cache); i++) {\n        xmlNodePtr node;\n        VALUE element = rb_ary_entry(cache, i);\n        Data_Get_Struct(element, xmlNode, node);\n        if (xmlIsBlankNode(node)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * call-seq:\n *  from_document(doc)\n *\n * Create a new Schema from the Nokogiri::XML::Document +doc+\n */\nstatic VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  int parse_options_int;\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n  parse_options_int = (int)NUM2INT(rb_funcall(parse_options, rb_intern(\"to_i\"), 0));\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n\n  return Qnil;\n}\n\nVALUE cNokogiriXmlSchema;\nvoid init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n\n  cNokogiriXmlSchema = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, -1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, -1);\n\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    ###\n    # Parse options for passing to Nokogiri.XML or Nokogiri.HTML\n    #\n    # == Building combinations of parse options\n    # You can build your own combinations of these parse options by using any of the following methods:\n    # *Note*: All examples attempt to set the +RECOVER+ & +NOENT+ options.\n    # [Ruby's bitwise operators] You can use the Ruby bitwise operators to set various combinations.\n    #   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new((1 << 0) | (1 << 1)))\n    # [Method chaining] Every option has an equivalent method in lowercase. You can chain these methods together to set various combinations.\n    #   Nokogiri.XML('<content>Chapter 1</content', nil, nil, Nokogiri::XML::ParseOptions.new.recover.noent)\n    # [Using Ruby Blocks] You can also setup parse combinations in the block passed to Nokogiri.XML or Nokogiri.HTML\n    #   Nokogiri.XML('<content>Chapter 1</content') {|config| config.recover.noent}\n    #\n    # == Removing particular parse options\n    # You can also remove options from an instance of +ParseOptions+ dynamically.\n    # Every option has an equivalent <code>no{option}</code> method in lowercase. You can call these methods on an instance of +ParseOptions+ to remove the option.\n    # Note that this is not available for +STRICT+.\n    #\n    #   # Setting the RECOVER & NOENT options...\n    #   options = Nokogiri::XML::ParseOptions.new.recover.noent\n    #   # later...\n    #   options.norecover # Removes the Nokogiri::XML::ParseOptions::RECOVER option\n    #   options.nonoent # Removes the Nokogiri::XML::ParseOptions::NOENT option\n    #\n    class ParseOptions\n      # Strict parsing\n      STRICT      = 0\n      # Recover from errors\n      RECOVER     = 1 << 0\n      # Substitute entities\n      NOENT       = 1 << 1\n      # Load external subsets\n      DTDLOAD     = 1 << 2\n      # Default DTD attributes\n      DTDATTR     = 1 << 3\n      # validate with the DTD\n      DTDVALID    = 1 << 4\n      # suppress error reports\n      NOERROR     = 1 << 5\n      # suppress warning reports\n      NOWARNING   = 1 << 6\n      # pedantic error reporting\n      PEDANTIC    = 1 << 7\n      # remove blank nodes\n      NOBLANKS    = 1 << 8\n      # use the SAX1 interface internally\n      SAX1        = 1 << 9\n      # Implement XInclude substitution\n      XINCLUDE    = 1 << 10\n      # Forbid network access. Recommended for dealing with untrusted documents.\n      NONET       = 1 << 11\n      # Do not reuse the context dictionary\n      NODICT      = 1 << 12\n      # remove redundant namespaces declarations\n      NSCLEAN     = 1 << 13\n      # merge CDATA as text nodes\n      NOCDATA     = 1 << 14\n      # do not generate XINCLUDE START/END nodes\n      NOXINCNODE  = 1 << 15\n      # compact small text nodes; no modification of the tree allowed afterwards (will possibly crash if you try to modify the tree)\n      COMPACT     = 1 << 16\n      # parse using XML-1.0 before update 5\n      OLD10       = 1 << 17\n      # do not fixup XINCLUDE xml:base uris\n      NOBASEFIX   = 1 << 18\n      # relax any hardcoded limit from the parser\n      HUGE        = 1 << 19\n\n      # the default options used for parsing XML documents\n      DEFAULT_XML  = RECOVER | NONET\n      # the default options used for parsing HTML documents\n      DEFAULT_HTML = RECOVER | NOERROR | NOWARNING | NONET\n      # the default options used for parsing XML schemas\n      DEFAULT_SCHEMA = NONET\n\n      attr_accessor :options\n      def initialize options = STRICT\n        @options = options\n      end\n\n      constants.each do |constant|\n        next if constant.to_sym == :STRICT\n        class_eval %{\n          def #{constant.downcase}\n            @options |= #{constant}\n            self\n          end\n\n          def no#{constant.downcase}\n            @options &= ~#{constant}\n            self\n          end\n\n          def #{constant.downcase}?\n            #{constant} & @options == #{constant}\n          end\n        }\n      end\n\n      def strict\n        @options &= ~RECOVER\n        self\n      end\n\n      def strict?\n        @options & RECOVER == STRICT\n      end\n\n      def ==(other)\n        other.to_i == to_i\n      end\n\n      alias :to_i :options\n\n      def inspect\n        options = []\n        self.class.constants.each do |k|\n          options << k.downcase if send(:\"#{k.downcase}?\")\n        end\n        super.sub(/>$/, \" \" + options.join(', ') + \">\")\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    class << self\n      ###\n      # Create a new Nokogiri::XML::RelaxNG document from +string_or_io+.\n      # See Nokogiri::XML::RelaxNG for an example.\n      def RelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n        RelaxNG.new(string_or_io, options)\n      end\n    end\n\n    ###\n    # Nokogiri::XML::RelaxNG is used for validating XML against a\n    # RelaxNG schema.\n    #\n    # == Synopsis\n    #\n    # Validate an XML document against a RelaxNG schema.  Loop over the errors\n    # that are returned and print them out:\n    #\n    #   schema  = Nokogiri::XML::RelaxNG(File.open(ADDRESS_SCHEMA_FILE))\n    #   doc     = Nokogiri::XML(File.open(ADDRESS_XML_FILE))\n    #\n    #   schema.validate(doc).each do |error|\n    #     puts error.message\n    #   end\n    #\n    # The list of errors are Nokogiri::XML::SyntaxError objects.\n    class RelaxNG < Nokogiri::XML::Schema\n    end\n  end\nend\n", "# frozen_string_literal: true\nmodule Nokogiri\n  module XML\n    class << self\n      ###\n      # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n      # object.\n      def Schema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA)\n        Schema.new(string_or_io, options)\n      end\n    end\n\n    ###\n    # Nokogiri::XML::Schema is used for validating XML against a schema\n    # (usually from an xsd file).\n    #\n    # == Synopsis\n    #\n    # Validate an XML document against a Schema.  Loop over the errors that\n    # are returned and print them out:\n    #\n    #   xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n    #   doc = Nokogiri::XML(File.read(PO_XML_FILE))\n    #\n    #   xsd.validate(doc).each do |error|\n    #     puts error.message\n    #   end\n    #\n    # The list of errors are Nokogiri::XML::SyntaxError objects.\n    class Schema\n      # Errors while parsing the schema file\n      attr_accessor :errors\n      # The Nokogiri::XML::ParseOptions used to parse the schema\n      attr_accessor :parse_options\n\n      ###\n      # Create a new Nokogiri::XML::Schema object using a +string_or_io+\n      # object.\n      def self.new string_or_io, options = ParseOptions::DEFAULT_SCHEMA\n        from_document(Nokogiri::XML(string_or_io), options)\n      end\n\n      ###\n      # Validate +thing+ against this schema.  +thing+ can be a\n      # Nokogiri::XML::Document object, or a filename.  An Array of\n      # Nokogiri::XML::SyntaxError objects found while validating the\n      # +thing+ is returned.\n      def validate thing\n        if thing.is_a?(Nokogiri::XML::Document) \n          validate_document(thing) \n        elsif File.file?(thing)\n          validate_file(thing)\n        else\n          raise ArgumentError, \"Must provide Nokogiri::Xml::Document or the name of an existing file\"\n        end\n      end\n\n      ###\n      # Returns true if +thing+ is a valid Nokogiri::XML::Document or\n      # file.\n      def valid? thing\n        validate(thing).length == 0\n      end\n    end\n  end\nend\n", "require \"helper\"\n\nmodule Nokogiri\n  module XML\n    class TestRelaxNG < Nokogiri::TestCase\n      def setup\n        assert @schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE))\n      end\n\n      def test_parse_with_memory\n        assert_instance_of Nokogiri::XML::RelaxNG, @schema\n        assert_equal 0, @schema.errors.length\n      end\n\n      def test_new\n        assert schema = Nokogiri::XML::RelaxNG.new(\n          File.read(ADDRESS_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::RelaxNG, schema\n      end\n\n      def test_parse_with_io\n        xsd = nil\n        File.open(ADDRESS_SCHEMA_FILE, 'rb') { |f|\n          assert xsd = Nokogiri::XML::RelaxNG(f)\n        }\n        assert_equal 0, xsd.errors.length\n      end\n\n      def test_constructor_method_with_parse_options\n        schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::RelaxNG(File.read(ADDRESS_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_new_with_parse_options\n        schema = Nokogiri::XML::RelaxNG.new(File.read(ADDRESS_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::RelaxNG.new(File.read(ADDRESS_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_from_document_with_parse_options\n        schema = Nokogiri::XML::RelaxNG.from_document(Nokogiri::XML::Document.parse(File.read(ADDRESS_SCHEMA_FILE)))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::RelaxNG.from_document(Nokogiri::XML::Document.parse(File.read(ADDRESS_SCHEMA_FILE)),\n                                                      Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_read_memory_with_parse_options\n        schema = Nokogiri::XML::RelaxNG.read_memory(File.read(ADDRESS_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::RelaxNG.read_memory(File.read(ADDRESS_SCHEMA_FILE),\n                                                    Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_parse_with_errors\n        xml = File.read(ADDRESS_SCHEMA_FILE).sub(/name=\"/, 'name=')\n        assert_raises(Nokogiri::XML::SyntaxError) {\n          Nokogiri::XML::RelaxNG(xml)\n        }\n      end\n\n      def test_validate_document\n        doc = Nokogiri::XML(File.read(ADDRESS_XML_FILE))\n        assert errors = @schema.validate(doc)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_invalid_document\n        # Empty address book is not allowed\n        read_doc = '<addressBook></addressBook>'\n\n        assert errors = @schema.validate(Nokogiri::XML(read_doc))\n        assert_equal 1, errors.length\n      end\n\n      def test_valid?\n        valid_doc = Nokogiri::XML(File.read(ADDRESS_XML_FILE))\n\n        invalid_doc = Nokogiri::XML('<addressBook></addressBook>')\n\n        assert(@schema.valid?(valid_doc))\n        assert(!@schema.valid?(invalid_doc))\n      end\n    end\n  end\nend\n", "require \"helper\"\n\nmodule Nokogiri\n  module XML\n    class TestSchema < Nokogiri::TestCase\n      def setup\n        assert @xsd = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n      end\n\n      def test_issue_1985_segv_on_schema_parse\n        skip(\"Pure Java version doesn't have this bug\") unless Nokogiri.uses_libxml?\n\n        # This is a test for a workaround for a bug in LibXML2.  The upstream\n        # bug is here: https://gitlab.gnome.org/GNOME/libxml2/issues/148\n        # Schema creation can result in dangling pointers.  If no nodes have\n        # been exposed, then it should be fine to create a schema.  If nodes\n        # have been exposed to Ruby, then we need to make sure they won't be\n        # freed out from under us.\n        doc = <<~EOF\n          <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n          <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n            <xs:element name=\"foo\" type=\"xs:string\"/>\n          </xs:schema>\n        EOF\n\n        # This is OK, no nodes have been exposed\n        xsd_doc = Nokogiri::XML(doc)\n        assert Nokogiri::XML::Schema.from_document(xsd_doc)\n\n        # This is not OK, nodes have been exposed to Ruby\n        xsd_doc = Nokogiri::XML(doc)\n        xsd_doc.root.children.find(&:blank?) # Finds a node\n\n        ex = assert_raise(ArgumentError) do\n          Nokogiri::XML::Schema.from_document(xsd_doc)\n        end\n        assert_match(/blank nodes/, ex.message)\n      end\n\n      def test_schema_read_memory\n        xsd = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_schema_from_document\n        doc = Nokogiri::XML(File.open(PO_SCHEMA_FILE))\n        assert doc\n        xsd = Nokogiri::XML::Schema.from_document doc\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_invalid_schema_do_not_raise_exceptions\n        xsd = Nokogiri::XML::Schema.new(<<~EOF)\n          <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\n            <xs:group name=\"foo1\">\n              <xs:sequence>\n                <xs:element name=\"bar\" type=\"xs:boolean\" />\n              </xs:sequence>\n            </xs:group>\n            <xs:group name=\"foo2\">\n              <xs:sequence>\n                <xs:element name=\"bar\" type=\"xs:string\" />\n              </xs:sequence>\n            </xs:group>\n            <xs:element name=\"foo\">\n              <xs:complexType>\n                <xs:choice>\n                  <xs:group ref=\"foo1\"/>\n                  <xs:group ref=\"foo2\"/>\n                </xs:choice>\n              </xs:complexType>\n            </xs:element>\n          </xs:schema>\n        EOF\n\n        assert_instance_of Nokogiri::XML::Schema, xsd\n\n        if Nokogiri.jruby?\n          assert xsd.errors.length > 0\n          assert_equal 1, xsd.errors.map(&:to_s).grep(/cos-element-consistent/).length\n          assert_equal 1, xsd.errors.map(&:to_s).grep(/cos-nonambig/).length\n        end\n      end\n\n      def test_schema_from_document_node\n        doc = Nokogiri::XML(File.open(PO_SCHEMA_FILE))\n        assert doc\n        xsd = Nokogiri::XML::Schema.from_document doc.root\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_schema_validates_with_relative_paths\n        xsd = File.join(ASSETS_DIR, \"foo\", \"foo.xsd\")\n        xml = File.join(ASSETS_DIR, \"valid_bar.xml\")\n        doc = Nokogiri::XML(File.open(xsd))\n        xsd = Nokogiri::XML::Schema.from_document doc\n\n        doc = Nokogiri::XML(File.open(xml))\n        assert xsd.valid?(doc)\n      end\n\n      def test_parse_with_memory\n        assert_instance_of Nokogiri::XML::Schema, @xsd\n        assert_equal 0, @xsd.errors.length\n      end\n\n      def test_new\n        assert xsd = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE))\n        assert_instance_of Nokogiri::XML::Schema, xsd\n      end\n\n      def test_schema_method_with_parse_options\n        schema = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::Schema(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_schema_new_with_parse_options\n        schema = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::Schema.new(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_schema_from_document_with_parse_options\n        schema = Nokogiri::XML::Schema.from_document(Nokogiri::XML::Document.parse(File.read(PO_SCHEMA_FILE)))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::Schema.from_document(Nokogiri::XML::Document.parse(File.read(PO_SCHEMA_FILE)),\n                                                     Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_schema_read_memory_with_parse_options\n        schema = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE))\n        assert_equal Nokogiri::XML::ParseOptions::DEFAULT_SCHEMA, schema.parse_options\n\n        schema = Nokogiri::XML::Schema.read_memory(File.read(PO_SCHEMA_FILE), Nokogiri::XML::ParseOptions.new.recover)\n        assert_equal Nokogiri::XML::ParseOptions.new.recover, schema.parse_options\n      end\n\n      def test_parse_with_io\n        xsd = nil\n        File.open(PO_SCHEMA_FILE, \"rb\") { |f|\n          assert xsd = Nokogiri::XML::Schema(f)\n        }\n        assert_equal 0, xsd.errors.length\n      end\n\n      def test_parse_with_errors\n        xml = File.read(PO_SCHEMA_FILE).sub(/name=\"/, \"name=\")\n        assert_raises(Nokogiri::XML::SyntaxError) {\n          Nokogiri::XML::Schema(xml)\n        }\n      end\n\n      def test_validate_document\n        doc = Nokogiri::XML(File.read(PO_XML_FILE))\n        assert errors = @xsd.validate(doc)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_file\n        assert errors = @xsd.validate(PO_XML_FILE)\n        assert_equal 0, errors.length\n      end\n\n      def test_validate_invalid_document\n        doc = Nokogiri::XML File.read(PO_XML_FILE)\n        doc.css(\"city\").unlink\n\n        assert errors = @xsd.validate(doc)\n        assert_equal 2, errors.length\n      end\n\n      def test_validate_invalid_file\n        tempfile = Tempfile.new(\"xml\")\n\n        doc = Nokogiri::XML File.read(PO_XML_FILE)\n        doc.css(\"city\").unlink\n        tempfile.write doc.to_xml\n        tempfile.close\n\n        assert errors = @xsd.validate(tempfile.path)\n        assert_equal 2, errors.length\n      end\n\n      def test_validate_non_document\n        string = File.read(PO_XML_FILE)\n        assert_raise(ArgumentError) { @xsd.validate(string) }\n      end\n\n      def test_valid?\n        valid_doc = Nokogiri::XML(File.read(PO_XML_FILE))\n\n        invalid_doc = Nokogiri::XML(\n          File.read(PO_XML_FILE).gsub(/<city>[^<]*<\\/city>/, \"\")\n        )\n\n        assert(@xsd.valid?(valid_doc))\n        assert(!@xsd.valid?(invalid_doc))\n      end\n\n      def test_xsd_with_dtd\n        Dir.chdir(File.join(ASSETS_DIR, \"saml\")) do\n          # works\n          Nokogiri::XML::Schema(IO.read(\"xmldsig_schema.xsd\"))\n          # was not working\n          Nokogiri::XML::Schema(IO.read(\"saml20protocol_schema.xsd\"))\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["ext/java/nokogiri/XmlRelaxng.java", "ext/java/nokogiri/XmlSchema.java", "ext/nokogiri/xml_relax_ng.c", "ext/nokogiri/xml_schema.c", "lib/nokogiri/xml/parse_options.rb", "lib/nokogiri/xml/relax_ng.rb", "lib/nokogiri/xml/schema.rb", "test/xml/test_relax_ng.rb", "test/xml/test_schema.rb"], "buggy_code_start_loc": [58, 109, 56, 96, 75, 8, 8, 26, 111], "buggy_code_end_loc": [86, 164, 161, 231, 75, 10, 39, 26, 111], "fixing_code_start_loc": [59, 109, 56, 96, 76, 8, 8, 27, 112], "fixing_code_end_loc": [93, 184, 178, 253, 78, 10, 41, 61, 145], "type": "CWE-611", "message": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.", "other": {"cve": {"id": "CVE-2020-26247", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-30T19:15:12.920", "lastModified": "2022-10-19T18:53:09.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4."}, {"lang": "es", "value": "Nokogiri es un Rubygem que proporciona analizadores de HTML, XML, SAX y Reader con compatibilidad con el selector XPath y CSS.&#xa0;En Nokogiri versiones anteriores a 1.11.0.rc4, se presenta una vulnerabilidad de tipo XXE.&#xa0;Los esquemas XML analizados por la funci\u00f3n Nokogiri::XML::Schema son confiables por defecto, permitiendo acceder a recursos externos por medio de la red, potencialmente permitiendo ataques de tipo XXE o SSRF.&#xa0;Este comportamiento es contrario a la pol\u00edtica de seguridad seguida por los mantenedores de Nokogiri, que consiste en tratar todas las entradas como no confiables por defecto siempre que sea posible.&#xa0;Esto es corregido en Nokogiri versi\u00f3n 1.11.0.rc4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.11.0", "matchCriteriaId": "F2ECF6A9-F5A7-43D2-A508-A1107B8CEF84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:1.11.0:rc1:*:*:*:ruby:*:*", "matchCriteriaId": "837DC793-18F6-4FD5-B3A4-369FEDC1C4BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:1.11.0:rc2:*:*:*:ruby:*:*", "matchCriteriaId": "57AD249D-C891-45F2-8640-EBCEBA8D661D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nokogiri:nokogiri:1.11.0:rc3:*:*:*:ruby:*:*", "matchCriteriaId": "B562CEEB-9707-42FC-A135-39DECE7E92A7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/nokogiri/releases/tag/v1.11.0.rc4", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/sparklemotion/nokogiri/security/advisories/GHSA-vr8q-g5c7-m54m", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://hackerone.com/reports/747489", "source": "security-advisories@github.com", "tags": ["Permissions Required"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/06/msg00007.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00018.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://rubygems.org/gems/nokogiri", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-29", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sparklemotion/nokogiri/commit/9c87439d9afa14a365ff13e73adc809cb2c3d97b"}}