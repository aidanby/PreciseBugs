{"buggy_code": ["/**\n * ldm - Support for Windows Logical Disk Manager (Dynamic Disks)\n *\n * Copyright (C) 2001,2002 Richard Russon <ldm@flatcap.org>\n * Copyright (c) 2001-2007 Anton Altaparmakov\n * Copyright (C) 2001,2002 Jakob Kemi <jakob.kemi@telia.com>\n *\n * Documentation is available at http://www.linux-ntfs.org/doku.php?id=downloads \n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program (in the main directory of the source in the file COPYING); if\n * not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n * Boston, MA  02111-1307  USA\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include \"ldm.h\"\n#include \"check.h\"\n#include \"msdos.h\"\n\n/**\n * ldm_debug/info/error/crit - Output an error message\n * @f:    A printf format string containing the message\n * @...:  Variables to substitute into @f\n *\n * ldm_debug() writes a DEBUG level message to the syslog but only if the\n * driver was compiled with debug enabled. Otherwise, the call turns into a NOP.\n */\n#ifndef CONFIG_LDM_DEBUG\n#define ldm_debug(...)\tdo {} while (0)\n#else\n#define ldm_debug(f, a...) _ldm_printk (KERN_DEBUG, __func__, f, ##a)\n#endif\n\n#define ldm_crit(f, a...)  _ldm_printk (KERN_CRIT,  __func__, f, ##a)\n#define ldm_error(f, a...) _ldm_printk (KERN_ERR,   __func__, f, ##a)\n#define ldm_info(f, a...)  _ldm_printk (KERN_INFO,  __func__, f, ##a)\n\n__attribute__ ((format (printf, 3, 4)))\nstatic void _ldm_printk (const char *level, const char *function,\n\t\t\t const char *fmt, ...)\n{\n\tstatic char buf[128];\n\tva_list args;\n\n\tva_start (args, fmt);\n\tvsnprintf (buf, sizeof (buf), fmt, args);\n\tva_end (args);\n\n\tprintk (\"%s%s(): %s\\n\", level, function, buf);\n}\n\n/**\n * ldm_parse_hexbyte - Convert a ASCII hex number to a byte\n * @src:  Pointer to at least 2 characters to convert.\n *\n * Convert a two character ASCII hex string to a number.\n *\n * Return:  0-255  Success, the byte was parsed correctly\n *          -1     Error, an invalid character was supplied\n */\nstatic int ldm_parse_hexbyte (const u8 *src)\n{\n\tunsigned int x;\t\t/* For correct wrapping */\n\tint h;\n\n\t/* high part */\n\tx = h = hex_to_bin(src[0]);\n\tif (h < 0)\n\t\treturn -1;\n\n\t/* low part */\n\th = hex_to_bin(src[1]);\n\tif (h < 0)\n\t\treturn -1;\n\n\treturn (x << 4) + h;\n}\n\n/**\n * ldm_parse_guid - Convert GUID from ASCII to binary\n * @src:   36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba\n * @dest:  Memory block to hold binary GUID (16 bytes)\n *\n * N.B. The GUID need not be NULL terminated.\n *\n * Return:  'true'   @dest contains binary GUID\n *          'false'  @dest contents are undefined\n */\nstatic bool ldm_parse_guid (const u8 *src, u8 *dest)\n{\n\tstatic const int size[] = { 4, 2, 2, 2, 6 };\n\tint i, j, v;\n\n\tif (src[8]  != '-' || src[13] != '-' ||\n\t    src[18] != '-' || src[23] != '-')\n\t\treturn false;\n\n\tfor (j = 0; j < 5; j++, src++)\n\t\tfor (i = 0; i < size[j]; i++, src+=2, *dest++ = v)\n\t\t\tif ((v = ldm_parse_hexbyte (src)) < 0)\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_privhead - Read the LDM Database PRIVHEAD structure\n * @data:  Raw database PRIVHEAD structure loaded from the device\n * @ph:    In-memory privhead structure in which to return parsed information\n *\n * This parses the LDM database PRIVHEAD structure supplied in @data and\n * sets up the in-memory privhead structure @ph with the obtained information.\n *\n * Return:  'true'   @ph contains the PRIVHEAD data\n *          'false'  @ph contents are undefined\n */\nstatic bool ldm_parse_privhead(const u8 *data, struct privhead *ph)\n{\n\tbool is_vista = false;\n\n\tBUG_ON(!data || !ph);\n\tif (MAGIC_PRIVHEAD != get_unaligned_be64(data)) {\n\t\tldm_error(\"Cannot find PRIVHEAD structure. LDM database is\"\n\t\t\t\" corrupt. Aborting.\");\n\t\treturn false;\n\t}\n\tph->ver_major = get_unaligned_be16(data + 0x000C);\n\tph->ver_minor = get_unaligned_be16(data + 0x000E);\n\tph->logical_disk_start = get_unaligned_be64(data + 0x011B);\n\tph->logical_disk_size = get_unaligned_be64(data + 0x0123);\n\tph->config_start = get_unaligned_be64(data + 0x012B);\n\tph->config_size = get_unaligned_be64(data + 0x0133);\n\t/* Version 2.11 is Win2k/XP and version 2.12 is Vista. */\n\tif (ph->ver_major == 2 && ph->ver_minor == 12)\n\t\tis_vista = true;\n\tif (!is_vista && (ph->ver_major != 2 || ph->ver_minor != 11)) {\n\t\tldm_error(\"Expected PRIVHEAD version 2.11 or 2.12, got %d.%d.\"\n\t\t\t\" Aborting.\", ph->ver_major, ph->ver_minor);\n\t\treturn false;\n\t}\n\tldm_debug(\"PRIVHEAD version %d.%d (Windows %s).\", ph->ver_major,\n\t\t\tph->ver_minor, is_vista ? \"Vista\" : \"2000/XP\");\n\tif (ph->config_size != LDM_DB_SIZE) {\t/* 1 MiB in sectors. */\n\t\t/* Warn the user and continue, carefully. */\n\t\tldm_info(\"Database is normally %u bytes, it claims to \"\n\t\t\t\"be %llu bytes.\", LDM_DB_SIZE,\n\t\t\t(unsigned long long)ph->config_size);\n\t}\n\tif ((ph->logical_disk_size == 0) || (ph->logical_disk_start +\n\t\t\tph->logical_disk_size > ph->config_start)) {\n\t\tldm_error(\"PRIVHEAD disk size doesn't match real disk size\");\n\t\treturn false;\n\t}\n\tif (!ldm_parse_guid(data + 0x0030, ph->disk_id)) {\n\t\tldm_error(\"PRIVHEAD contains an invalid GUID.\");\n\t\treturn false;\n\t}\n\tldm_debug(\"Parsed PRIVHEAD successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_parse_tocblock - Read the LDM Database TOCBLOCK structure\n * @data:  Raw database TOCBLOCK structure loaded from the device\n * @toc:   In-memory toc structure in which to return parsed information\n *\n * This parses the LDM Database TOCBLOCK (table of contents) structure supplied\n * in @data and sets up the in-memory tocblock structure @toc with the obtained\n * information.\n *\n * N.B.  The *_start and *_size values returned in @toc are not range-checked.\n *\n * Return:  'true'   @toc contains the TOCBLOCK data\n *          'false'  @toc contents are undefined\n */\nstatic bool ldm_parse_tocblock (const u8 *data, struct tocblock *toc)\n{\n\tBUG_ON (!data || !toc);\n\n\tif (MAGIC_TOCBLOCK != get_unaligned_be64(data)) {\n\t\tldm_crit (\"Cannot find TOCBLOCK, database may be corrupt.\");\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap1_name, data + 0x24, sizeof (toc->bitmap1_name));\n\ttoc->bitmap1_name[sizeof (toc->bitmap1_name) - 1] = 0;\n\ttoc->bitmap1_start = get_unaligned_be64(data + 0x2E);\n\ttoc->bitmap1_size  = get_unaligned_be64(data + 0x36);\n\n\tif (strncmp (toc->bitmap1_name, TOC_BITMAP1,\n\t\t\tsizeof (toc->bitmap1_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's first bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP1, toc->bitmap1_name);\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap2_name, data + 0x46, sizeof (toc->bitmap2_name));\n\ttoc->bitmap2_name[sizeof (toc->bitmap2_name) - 1] = 0;\n\ttoc->bitmap2_start = get_unaligned_be64(data + 0x50);\n\ttoc->bitmap2_size  = get_unaligned_be64(data + 0x58);\n\tif (strncmp (toc->bitmap2_name, TOC_BITMAP2,\n\t\t\tsizeof (toc->bitmap2_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's second bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP2, toc->bitmap2_name);\n\t\treturn false;\n\t}\n\tldm_debug (\"Parsed TOCBLOCK successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_parse_vmdb - Read the LDM Database VMDB structure\n * @data:  Raw database VMDB structure loaded from the device\n * @vm:    In-memory vmdb structure in which to return parsed information\n *\n * This parses the LDM Database VMDB structure supplied in @data and sets up\n * the in-memory vmdb structure @vm with the obtained information.\n *\n * N.B.  The *_start, *_size and *_seq values will be range-checked later.\n *\n * Return:  'true'   @vm contains VMDB info\n *          'false'  @vm contents are undefined\n */\nstatic bool ldm_parse_vmdb (const u8 *data, struct vmdb *vm)\n{\n\tBUG_ON (!data || !vm);\n\n\tif (MAGIC_VMDB != get_unaligned_be32(data)) {\n\t\tldm_crit (\"Cannot find the VMDB, database may be corrupt.\");\n\t\treturn false;\n\t}\n\n\tvm->ver_major = get_unaligned_be16(data + 0x12);\n\tvm->ver_minor = get_unaligned_be16(data + 0x14);\n\tif ((vm->ver_major != 4) || (vm->ver_minor != 10)) {\n\t\tldm_error (\"Expected VMDB version %d.%d, got %d.%d. \"\n\t\t\t\"Aborting.\", 4, 10, vm->ver_major, vm->ver_minor);\n\t\treturn false;\n\t}\n\n\tvm->vblk_size     = get_unaligned_be32(data + 0x08);\n\tif (vm->vblk_size == 0) {\n\t\tldm_error (\"Illegal VBLK size\");\n\t\treturn false;\n\t}\n\n\tvm->vblk_offset   = get_unaligned_be32(data + 0x0C);\n\tvm->last_vblk_seq = get_unaligned_be32(data + 0x04);\n\n\tldm_debug (\"Parsed VMDB successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_compare_privheads - Compare two privhead objects\n * @ph1:  First privhead\n * @ph2:  Second privhead\n *\n * This compares the two privhead structures @ph1 and @ph2.\n *\n * Return:  'true'   Identical\n *          'false'  Different\n */\nstatic bool ldm_compare_privheads (const struct privhead *ph1,\n\t\t\t\t   const struct privhead *ph2)\n{\n\tBUG_ON (!ph1 || !ph2);\n\n\treturn ((ph1->ver_major          == ph2->ver_major)\t\t&&\n\t\t(ph1->ver_minor          == ph2->ver_minor)\t\t&&\n\t\t(ph1->logical_disk_start == ph2->logical_disk_start)\t&&\n\t\t(ph1->logical_disk_size  == ph2->logical_disk_size)\t&&\n\t\t(ph1->config_start       == ph2->config_start)\t\t&&\n\t\t(ph1->config_size        == ph2->config_size)\t\t&&\n\t\t!memcmp (ph1->disk_id, ph2->disk_id, GUID_SIZE));\n}\n\n/**\n * ldm_compare_tocblocks - Compare two tocblock objects\n * @toc1:  First toc\n * @toc2:  Second toc\n *\n * This compares the two tocblock structures @toc1 and @toc2.\n *\n * Return:  'true'   Identical\n *          'false'  Different\n */\nstatic bool ldm_compare_tocblocks (const struct tocblock *toc1,\n\t\t\t\t   const struct tocblock *toc2)\n{\n\tBUG_ON (!toc1 || !toc2);\n\n\treturn ((toc1->bitmap1_start == toc2->bitmap1_start)\t&&\n\t\t(toc1->bitmap1_size  == toc2->bitmap1_size)\t&&\n\t\t(toc1->bitmap2_start == toc2->bitmap2_start)\t&&\n\t\t(toc1->bitmap2_size  == toc2->bitmap2_size)\t&&\n\t\t!strncmp (toc1->bitmap1_name, toc2->bitmap1_name,\n\t\t\tsizeof (toc1->bitmap1_name))\t\t&&\n\t\t!strncmp (toc1->bitmap2_name, toc2->bitmap2_name,\n\t\t\tsizeof (toc1->bitmap2_name)));\n}\n\n/**\n * ldm_validate_privheads - Compare the primary privhead with its backups\n * @state: Partition check state including device holding the LDM Database\n * @ph1:   Memory struct to fill with ph contents\n *\n * Read and compare all three privheads from disk.\n *\n * The privheads on disk show the size and location of the main disk area and\n * the configuration area (the database).  The values are range-checked against\n * @hd, which contains the real size of the disk.\n *\n * Return:  'true'   Success\n *          'false'  Error\n */\nstatic bool ldm_validate_privheads(struct parsed_partitions *state,\n\t\t\t\t   struct privhead *ph1)\n{\n\tstatic const int off[3] = { OFF_PRIV1, OFF_PRIV2, OFF_PRIV3 };\n\tstruct privhead *ph[3] = { ph1 };\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tlong num_sects;\n\tint i;\n\n\tBUG_ON (!state || !ph1);\n\n\tph[1] = kmalloc (sizeof (*ph[1]), GFP_KERNEL);\n\tph[2] = kmalloc (sizeof (*ph[2]), GFP_KERNEL);\n\tif (!ph[1] || !ph[2]) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t/* off[1 & 2] are relative to ph[0]->config_start */\n\tph[0]->config_start = 0;\n\n\t/* Read and parse privheads */\n\tfor (i = 0; i < 3; i++) {\n\t\tdata = read_part_sector(state, ph[0]->config_start + off[i],\n\t\t\t\t\t&sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\t\tresult = ldm_parse_privhead (data, ph[i]);\n\t\tput_dev_sector (sect);\n\t\tif (!result) {\n\t\t\tldm_error (\"Cannot find PRIVHEAD %d.\", i+1); /* Log again */\n\t\t\tif (i < 2)\n\t\t\t\tgoto out;\t/* Already logged */\n\t\t\telse\n\t\t\t\tbreak;\t/* FIXME ignore for now, 3rd PH can fail on odd-sized disks */\n\t\t}\n\t}\n\n\tnum_sects = state->bdev->bd_inode->i_size >> 9;\n\n\tif ((ph[0]->config_start > num_sects) ||\n\t   ((ph[0]->config_start + ph[0]->config_size) > num_sects)) {\n\t\tldm_crit (\"Database extends beyond the end of the disk.\");\n\t\tgoto out;\n\t}\n\n\tif ((ph[0]->logical_disk_start > ph[0]->config_start) ||\n\t   ((ph[0]->logical_disk_start + ph[0]->logical_disk_size)\n\t\t    > ph[0]->config_start)) {\n\t\tldm_crit (\"Disk and database overlap.\");\n\t\tgoto out;\n\t}\n\n\tif (!ldm_compare_privheads (ph[0], ph[1])) {\n\t\tldm_crit (\"Primary and backup PRIVHEADs don't match.\");\n\t\tgoto out;\n\t}\n\t/* FIXME ignore this for now\n\tif (!ldm_compare_privheads (ph[0], ph[2])) {\n\t\tldm_crit (\"Primary and backup PRIVHEADs don't match.\");\n\t\tgoto out;\n\t}*/\n\tldm_debug (\"Validated PRIVHEADs successfully.\");\n\tresult = true;\nout:\n\tkfree (ph[1]);\n\tkfree (ph[2]);\n\treturn result;\n}\n\n/**\n * ldm_validate_tocblocks - Validate the table of contents and its backups\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @state->bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * Find and compare the four tables of contents of the LDM Database stored on\n * @state->bdev and return the parsed information into @toc1.\n *\n * The offsets and sizes of the configs are range-checked against a privhead.\n *\n * Return:  'true'   @toc1 contains validated TOCBLOCK info\n *          'false'  @toc1 contents are undefined\n */\nstatic bool ldm_validate_tocblocks(struct parsed_partitions *state,\n\t\t\t\t   unsigned long base, struct ldmdb *ldb)\n{\n\tstatic const int off[4] = { OFF_TOCB1, OFF_TOCB2, OFF_TOCB3, OFF_TOCB4};\n\tstruct tocblock *tb[4];\n\tstruct privhead *ph;\n\tSector sect;\n\tu8 *data;\n\tint i, nr_tbs;\n\tbool result = false;\n\n\tBUG_ON(!state || !ldb);\n\tph = &ldb->ph;\n\ttb[0] = &ldb->toc;\n\ttb[1] = kmalloc(sizeof(*tb[1]) * 3, GFP_KERNEL);\n\tif (!tb[1]) {\n\t\tldm_crit(\"Out of memory.\");\n\t\tgoto err;\n\t}\n\ttb[2] = (struct tocblock*)((u8*)tb[1] + sizeof(*tb[1]));\n\ttb[3] = (struct tocblock*)((u8*)tb[2] + sizeof(*tb[2]));\n\t/*\n\t * Try to read and parse all four TOCBLOCKs.\n\t *\n\t * Windows Vista LDM v2.12 does not always have all four TOCBLOCKs so\n\t * skip any that fail as long as we get at least one valid TOCBLOCK.\n\t */\n\tfor (nr_tbs = i = 0; i < 4; i++) {\n\t\tdata = read_part_sector(state, base + off[i], &sect);\n\t\tif (!data) {\n\t\t\tldm_error(\"Disk read failed for TOCBLOCK %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ldm_parse_tocblock(data, tb[nr_tbs]))\n\t\t\tnr_tbs++;\n\t\tput_dev_sector(sect);\n\t}\n\tif (!nr_tbs) {\n\t\tldm_crit(\"Failed to find a valid TOCBLOCK.\");\n\t\tgoto err;\n\t}\n\t/* Range check the TOCBLOCK against a privhead. */\n\tif (((tb[0]->bitmap1_start + tb[0]->bitmap1_size) > ph->config_size) ||\n\t\t\t((tb[0]->bitmap2_start + tb[0]->bitmap2_size) >\n\t\t\tph->config_size)) {\n\t\tldm_crit(\"The bitmaps are out of range.  Giving up.\");\n\t\tgoto err;\n\t}\n\t/* Compare all loaded TOCBLOCKs. */\n\tfor (i = 1; i < nr_tbs; i++) {\n\t\tif (!ldm_compare_tocblocks(tb[0], tb[i])) {\n\t\t\tldm_crit(\"TOCBLOCKs 0 and %d do not match.\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tldm_debug(\"Validated %d TOCBLOCKs successfully.\", nr_tbs);\n\tresult = true;\nerr:\n\tkfree(tb[1]);\n\treturn result;\n}\n\n/**\n * ldm_validate_vmdb - Read the VMDB and validate it\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * Find the vmdb of the LDM Database stored on @bdev and return the parsed\n * information in @ldb.\n *\n * Return:  'true'   @ldb contains validated VBDB info\n *          'false'  @ldb contents are undefined\n */\nstatic bool ldm_validate_vmdb(struct parsed_partitions *state,\n\t\t\t      unsigned long base, struct ldmdb *ldb)\n{\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tstruct vmdb *vm;\n\tstruct tocblock *toc;\n\n\tBUG_ON (!state || !ldb);\n\n\tvm  = &ldb->vm;\n\ttoc = &ldb->toc;\n\n\tdata = read_part_sector(state, base + OFF_VMDB, &sect);\n\tif (!data) {\n\t\tldm_crit (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vmdb (data, vm))\n\t\tgoto out;\t\t\t\t/* Already logged */\n\n\t/* Are there uncommitted transactions? */\n\tif (get_unaligned_be16(data + 0x10) != 0x01) {\n\t\tldm_crit (\"Database is not in a consistent state.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tif (vm->vblk_offset != 512)\n\t\tldm_info (\"VBLKs start at offset 0x%04x.\", vm->vblk_offset);\n\n\t/*\n\t * The last_vblkd_seq can be before the end of the vmdb, just make sure\n\t * it is not out of bounds.\n\t */\n\tif ((vm->vblk_size * vm->last_vblk_seq) > (toc->bitmap1_size << 9)) {\n\t\tldm_crit (\"VMDB exceeds allowed size specified by TOCBLOCK.  \"\n\t\t\t\t\"Database is corrupt.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tresult = true;\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n\n/**\n * ldm_validate_partition_table - Determine whether bdev might be a dynamic disk\n * @state: Partition check state including device holding the LDM Database\n *\n * This function provides a weak test to decide whether the device is a dynamic\n * disk or not.  It looks for an MS-DOS-style partition table containing at\n * least one partition of type 0x42 (formerly SFS, now used by Windows for\n * dynamic disks).\n *\n * N.B.  The only possible error can come from the read_part_sector and that is\n *       only likely to happen if the underlying device is strange.  If that IS\n *       the case we should return zero to let someone else try.\n *\n * Return:  'true'   @state->bdev is a dynamic disk\n *          'false'  @state->bdev is not a dynamic disk, or an error occurred\n */\nstatic bool ldm_validate_partition_table(struct parsed_partitions *state)\n{\n\tSector sect;\n\tu8 *data;\n\tstruct partition *p;\n\tint i;\n\tbool result = false;\n\n\tBUG_ON(!state);\n\n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data) {\n\t\tldm_crit (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (*(__le16*) (data + 0x01FE) != cpu_to_le16 (MSDOS_LABEL_MAGIC))\n\t\tgoto out;\n\n\tp = (struct partition*)(data + 0x01BE);\n\tfor (i = 0; i < 4; i++, p++)\n\t\tif (SYS_IND (p) == LDM_PARTITION) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (result)\n\t\tldm_debug (\"Found W2K dynamic disk partition type.\");\n\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n/**\n * ldm_get_disk_objid - Search a linked list of vblk's for a given Disk Id\n * @ldb:  Cache of the database structures\n *\n * The LDM Database contains a list of all partitions on all dynamic disks.\n * The primary PRIVHEAD, at the beginning of the physical disk, tells us\n * the GUID of this disk.  This function searches for the GUID in a linked\n * list of vblk's.\n *\n * Return:  Pointer, A matching vblk was found\n *          NULL,    No match, or an error\n */\nstatic struct vblk * ldm_get_disk_objid (const struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\n\tBUG_ON (!ldb);\n\n\tlist_for_each (item, &ldb->v_disk) {\n\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\tif (!memcmp (v->vblk.disk.disk_id, ldb->ph.disk_id, GUID_SIZE))\n\t\t\treturn v;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * ldm_create_data_partitions - Create data partitions for this device\n * @pp:   List of the partitions parsed so far\n * @ldb:  Cache of the database structures\n *\n * The database contains ALL the partitions for ALL disk groups, so we need to\n * filter out this specific disk. Using the disk's object id, we can find all\n * the partitions in the database that belong to this disk.\n *\n * Add each partition in our database, to the parsed_partitions structure.\n *\n * N.B.  This function creates the partitions in the order it finds partition\n *       objects in the linked list.\n *\n * Return:  'true'   Partition created\n *          'false'  Error, probably a range checking problem\n */\nstatic bool ldm_create_data_partitions (struct parsed_partitions *pp,\n\t\t\t\t\tconst struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\tstruct vblk *vb;\n\tstruct vblk *disk;\n\tstruct vblk_part *part;\n\tint part_num = 1;\n\n\tBUG_ON (!pp || !ldb);\n\n\tdisk = ldm_get_disk_objid (ldb);\n\tif (!disk) {\n\t\tldm_crit (\"Can't find the ID of this disk in the database.\");\n\t\treturn false;\n\t}\n\n\tstrlcat(pp->pp_buf, \" [LDM]\", PAGE_SIZE);\n\n\t/* Create the data partitions */\n\tlist_for_each (item, &ldb->v_part) {\n\t\tvb = list_entry (item, struct vblk, list);\n\t\tpart = &vb->vblk.part;\n\n\t\tif (part->disk_id != disk->obj_id)\n\t\t\tcontinue;\n\n\t\tput_partition (pp, part_num, ldb->ph.logical_disk_start +\n\t\t\t\tpart->start, part->size);\n\t\tpart_num++;\n\t}\n\n\tstrlcat(pp->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn true;\n}\n\n\n/**\n * ldm_relative - Calculate the next relative offset\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @base:    Size of the previous fixed width fields\n * @offset:  Cumulative size of the previous variable-width fields\n *\n * Because many of the VBLK fields are variable-width, it's necessary\n * to calculate each offset based on the previous one and the length\n * of the field it pointed to.\n *\n * Return:  -1 Error, the calculated offset exceeded the size of the buffer\n *           n OK, a range-checked offset into buffer\n */\nstatic int ldm_relative(const u8 *buffer, int buflen, int base, int offset)\n{\n\n\tbase += offset;\n\tif (!buffer || offset < 0 || base > buflen) {\n\t\tif (!buffer)\n\t\t\tldm_error(\"!buffer\");\n\t\tif (offset < 0)\n\t\t\tldm_error(\"offset (%d) < 0\", offset);\n\t\tif (base > buflen)\n\t\t\tldm_error(\"base (%d) > buflen (%d)\", base, buflen);\n\t\treturn -1;\n\t}\n\tif (base + buffer[base] >= buflen) {\n\t\tldm_error(\"base (%d) + buffer[base] (%d) >= buflen (%d)\", base,\n\t\t\t\tbuffer[base], buflen);\n\t\treturn -1;\n\t}\n\treturn buffer[base] + offset + 1;\n}\n\n/**\n * ldm_get_vnum - Convert a variable-width, big endian number, into cpu order\n * @block:  Pointer to the variable-width number to convert\n *\n * Large numbers in the LDM Database are often stored in a packed format.  Each\n * number is prefixed by a one byte width marker.  All numbers in the database\n * are stored in big-endian byte order.  This function reads one of these\n * numbers and returns the result\n *\n * N.B.  This function DOES NOT perform any range checking, though the most\n *       it will read is eight bytes.\n *\n * Return:  n A number\n *          0 Zero, or an error occurred\n */\nstatic u64 ldm_get_vnum (const u8 *block)\n{\n\tu64 tmp = 0;\n\tu8 length;\n\n\tBUG_ON (!block);\n\n\tlength = *block++;\n\n\tif (length && length <= 8)\n\t\twhile (length--)\n\t\t\ttmp = (tmp << 8) | *block++;\n\telse\n\t\tldm_error (\"Illegal length %d.\", length);\n\n\treturn tmp;\n}\n\n/**\n * ldm_get_vstr - Read a length-prefixed string into a buffer\n * @block:   Pointer to the length marker\n * @buffer:  Location to copy string to\n * @buflen:  Size of the output buffer\n *\n * Many of the strings in the LDM Database are not NULL terminated.  Instead\n * they are prefixed by a one byte length marker.  This function copies one of\n * these strings into a buffer.\n *\n * N.B.  This function DOES NOT perform any range checking on the input.\n *       If the buffer is too small, the output will be truncated.\n *\n * Return:  0, Error and @buffer contents are undefined\n *          n, String length in characters (excluding NULL)\n *          buflen-1, String was truncated.\n */\nstatic int ldm_get_vstr (const u8 *block, u8 *buffer, int buflen)\n{\n\tint length;\n\n\tBUG_ON (!block || !buffer);\n\n\tlength = block[0];\n\tif (length >= buflen) {\n\t\tldm_error (\"Truncating string %d -> %d.\", length, buflen);\n\t\tlength = buflen - 1;\n\t}\n\tmemcpy (buffer, block + 1, length);\n\tbuffer[length] = 0;\n\treturn length;\n}\n\n\n/**\n * ldm_parse_cmp3 - Read a raw VBLK Component object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Component object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Component VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_cmp3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vstate, r_child, r_parent, r_stripe, r_cols, len;\n\tstruct vblk_comp *comp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_vstate = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_child  = ldm_relative (buffer, buflen, 0x1D, r_vstate);\n\tr_parent = ldm_relative (buffer, buflen, 0x2D, r_child);\n\n\tif (buffer[0x12] & VBLK_FLAG_COMP_STRIPE) {\n\t\tr_stripe = ldm_relative (buffer, buflen, 0x2E, r_parent);\n\t\tr_cols   = ldm_relative (buffer, buflen, 0x2E, r_stripe);\n\t\tlen = r_cols;\n\t} else {\n\t\tr_stripe = 0;\n\t\tr_cols   = 0;\n\t\tlen = r_parent;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_CMP3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tcomp = &vb->vblk.comp;\n\tldm_get_vstr (buffer + 0x18 + r_name, comp->state,\n\t\tsizeof (comp->state));\n\tcomp->type      = buffer[0x18 + r_vstate];\n\tcomp->children  = ldm_get_vnum (buffer + 0x1D + r_vstate);\n\tcomp->parent_id = ldm_get_vnum (buffer + 0x2D + r_child);\n\tcomp->chunksize = r_stripe ? ldm_get_vnum (buffer+r_parent+0x2E) : 0;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_dgr3 - Read a raw VBLK Disk Group object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk Group object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk Group VBLK\n *          'false'  @vb contents are not defined\n */\nstatic int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\tldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\n\t\tsizeof (dgrp->disk_id));\n\treturn true;\n}\n\n/**\n * ldm_parse_dgr4 - Read a raw VBLK Disk Group object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk Group object (version 4) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk Group VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dgr4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tchar buf[64];\n\tint r_objid, r_name, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR4_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x44, r_name);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x44, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_name;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\n\tldm_get_vstr (buffer + 0x18 + r_objid, buf, sizeof (buf));\n\treturn true;\n}\n\n/**\n * ldm_parse_dsk3 - Read a raw VBLK Disk object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dsk3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_altname, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid   = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name    = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid  = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_altname = ldm_relative (buffer, buflen, 0x18, r_diskid);\n\tlen = r_altname;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tldm_get_vstr (buffer + 0x18 + r_diskid, disk->alt_name,\n\t\tsizeof (disk->alt_name));\n\tif (!ldm_parse_guid (buffer + 0x19 + r_name, disk->disk_id))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_dsk4 - Read a raw VBLK Disk object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk object (version 4) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name  = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tlen     = r_name;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tmemcpy (disk->disk_id, buffer + 0x18 + r_name, GUID_SIZE);\n\treturn true;\n}\n\n/**\n * ldm_parse_prt3 - Read a raw VBLK Partition object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Partition object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Partition VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_prt3(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_size, r_parent, r_diskid, r_index, len;\n\tstruct vblk_part *part;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x34, r_name);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tr_parent = ldm_relative(buffer, buflen, 0x34, r_size);\n\tif (r_parent < 0) {\n\t\tldm_error(\"r_parent %d < 0\", r_parent);\n\t\treturn false;\n\t}\n\tr_diskid = ldm_relative(buffer, buflen, 0x34, r_parent);\n\tif (r_diskid < 0) {\n\t\tldm_error(\"r_diskid %d < 0\", r_diskid);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_PART_INDEX) {\n\t\tr_index = ldm_relative(buffer, buflen, 0x34, r_diskid);\n\t\tif (r_index < 0) {\n\t\t\tldm_error(\"r_index %d < 0\", r_index);\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_index;\n\t} else {\n\t\tr_index = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_PRT3;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tpart = &vb->vblk.part;\n\tpart->start = get_unaligned_be64(buffer + 0x24 + r_name);\n\tpart->volume_offset = get_unaligned_be64(buffer + 0x2C + r_name);\n\tpart->size = ldm_get_vnum(buffer + 0x34 + r_name);\n\tpart->parent_id = ldm_get_vnum(buffer + 0x34 + r_size);\n\tpart->disk_id = ldm_get_vnum(buffer + 0x34 + r_parent);\n\tif (vb->flags & VBLK_FLAG_PART_INDEX)\n\t\tpart->partnum = buffer[0x35 + r_diskid];\n\telse\n\t\tpart->partnum = 0;\n\treturn true;\n}\n\n/**\n * ldm_parse_vol5 - Read a raw VBLK Volume object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Volume object (version 5) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Volume VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_vol5(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vtype, r_disable_drive_letter, r_child, r_size;\n\tint r_id1, r_id2, r_size2, r_drive, len;\n\tstruct vblk_volu *volu;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_vtype = ldm_relative(buffer, buflen, 0x18, r_name);\n\tif (r_vtype < 0) {\n\t\tldm_error(\"r_vtype %d < 0\", r_vtype);\n\t\treturn false;\n\t}\n\tr_disable_drive_letter = ldm_relative(buffer, buflen, 0x18, r_vtype);\n\tif (r_disable_drive_letter < 0) {\n\t\tldm_error(\"r_disable_drive_letter %d < 0\",\n\t\t\t\tr_disable_drive_letter);\n\t\treturn false;\n\t}\n\tr_child = ldm_relative(buffer, buflen, 0x2D, r_disable_drive_letter);\n\tif (r_child < 0) {\n\t\tldm_error(\"r_child %d < 0\", r_child);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x3D, r_child);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID1) {\n\t\tr_id1 = ldm_relative(buffer, buflen, 0x52, r_size);\n\t\tif (r_id1 < 0) {\n\t\t\tldm_error(\"r_id1 %d < 0\", r_id1);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id1 = r_size;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID2) {\n\t\tr_id2 = ldm_relative(buffer, buflen, 0x52, r_id1);\n\t\tif (r_id2 < 0) {\n\t\t\tldm_error(\"r_id2 %d < 0\", r_id2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id2 = r_id1;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_SIZE) {\n\t\tr_size2 = ldm_relative(buffer, buflen, 0x52, r_id2);\n\t\tif (r_size2 < 0) {\n\t\t\tldm_error(\"r_size2 %d < 0\", r_size2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_size2 = r_id2;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tr_drive = ldm_relative(buffer, buflen, 0x52, r_size2);\n\t\tif (r_drive < 0) {\n\t\t\tldm_error(\"r_drive %d < 0\", r_drive);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_drive = r_size2;\n\tlen = r_drive;\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_VOL5;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tvolu = &vb->vblk.volu;\n\tldm_get_vstr(buffer + 0x18 + r_name, volu->volume_type,\n\t\t\tsizeof(volu->volume_type));\n\tmemcpy(volu->volume_state, buffer + 0x18 + r_disable_drive_letter,\n\t\t\tsizeof(volu->volume_state));\n\tvolu->size = ldm_get_vnum(buffer + 0x3D + r_child);\n\tvolu->partition_type = buffer[0x41 + r_size];\n\tmemcpy(volu->guid, buffer + 0x42 + r_size, sizeof(volu->guid));\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tldm_get_vstr(buffer + 0x52 + r_size, volu->drive_hint,\n\t\t\t\tsizeof(volu->drive_hint));\n\t}\n\treturn true;\n}\n\n/**\n * ldm_parse_vblk - Read a raw VBLK object into a vblk structure\n * @buf:  Block of data being worked on\n * @len:  Size of the block of data\n * @vb:   In-memory vblk in which to return information\n *\n * Read a raw VBLK object into a vblk structure.  This function just reads the\n * information common to all VBLK types, then delegates the rest of the work to\n * helper functions: ldm_parse_*.\n *\n * Return:  'true'   @vb contains a VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_vblk (const u8 *buf, int len, struct vblk *vb)\n{\n\tbool result = false;\n\tint r_objid;\n\n\tBUG_ON (!buf || !vb);\n\n\tr_objid = ldm_relative (buf, len, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error (\"VBLK header is corrupt.\");\n\t\treturn false;\n\t}\n\n\tvb->flags  = buf[0x12];\n\tvb->type   = buf[0x13];\n\tvb->obj_id = ldm_get_vnum (buf + 0x18);\n\tldm_get_vstr (buf+0x18+r_objid, vb->name, sizeof (vb->name));\n\n\tswitch (vb->type) {\n\t\tcase VBLK_CMP3:  result = ldm_parse_cmp3 (buf, len, vb); break;\n\t\tcase VBLK_DSK3:  result = ldm_parse_dsk3 (buf, len, vb); break;\n\t\tcase VBLK_DSK4:  result = ldm_parse_dsk4 (buf, len, vb); break;\n\t\tcase VBLK_DGR3:  result = ldm_parse_dgr3 (buf, len, vb); break;\n\t\tcase VBLK_DGR4:  result = ldm_parse_dgr4 (buf, len, vb); break;\n\t\tcase VBLK_PRT3:  result = ldm_parse_prt3 (buf, len, vb); break;\n\t\tcase VBLK_VOL5:  result = ldm_parse_vol5 (buf, len, vb); break;\n\t}\n\n\tif (result)\n\t\tldm_debug (\"Parsed VBLK 0x%llx (type: 0x%02x) ok.\",\n\t\t\t (unsigned long long) vb->obj_id, vb->type);\n\telse\n\t\tldm_error (\"Failed to parse VBLK 0x%llx (type: 0x%02x).\",\n\t\t\t(unsigned long long) vb->obj_id, vb->type);\n\n\treturn result;\n}\n\n\n/**\n * ldm_ldmdb_add - Adds a raw VBLK entry to the ldmdb database\n * @data:  Raw VBLK to add to the database\n * @len:   Size of the raw VBLK\n * @ldb:   Cache of the database structures\n *\n * The VBLKs are sorted into categories.  Partitions are also sorted by offset.\n *\n * N.B.  This function does not check the validity of the VBLKs.\n *\n * Return:  'true'   The VBLK was added\n *          'false'  An error occurred\n */\nstatic bool ldm_ldmdb_add (u8 *data, int len, struct ldmdb *ldb)\n{\n\tstruct vblk *vb;\n\tstruct list_head *item;\n\n\tBUG_ON (!data || !ldb);\n\n\tvb = kmalloc (sizeof (*vb), GFP_KERNEL);\n\tif (!vb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vblk (data, len, vb)) {\n\t\tkfree(vb);\n\t\treturn false;\t\t\t/* Already logged */\n\t}\n\n\t/* Put vblk into the correct list. */\n\tswitch (vb->type) {\n\tcase VBLK_DGR3:\n\tcase VBLK_DGR4:\n\t\tlist_add (&vb->list, &ldb->v_dgrp);\n\t\tbreak;\n\tcase VBLK_DSK3:\n\tcase VBLK_DSK4:\n\t\tlist_add (&vb->list, &ldb->v_disk);\n\t\tbreak;\n\tcase VBLK_VOL5:\n\t\tlist_add (&vb->list, &ldb->v_volu);\n\t\tbreak;\n\tcase VBLK_CMP3:\n\t\tlist_add (&vb->list, &ldb->v_comp);\n\t\tbreak;\n\tcase VBLK_PRT3:\n\t\t/* Sort by the partition's start sector. */\n\t\tlist_for_each (item, &ldb->v_part) {\n\t\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\t\tif ((v->vblk.part.disk_id == vb->vblk.part.disk_id) &&\n\t\t\t    (v->vblk.part.start > vb->vblk.part.start)) {\n\t\t\t\tlist_add_tail (&vb->list, &v->list);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail (&vb->list, &ldb->v_part);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n/**\n * ldm_frag_add - Add a VBLK fragment to a list\n * @data:   Raw fragment to be added to the list\n * @size:   Size of the raw fragment\n * @frags:  Linked list of VBLK fragments\n *\n * Fragmented VBLKs may not be consecutive in the database, so they are placed\n * in a list so they can be pieced together later.\n *\n * Return:  'true'   Success, the VBLK was added to the list\n *          'false'  Error, a problem occurred\n */\nstatic bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n\n/**\n * ldm_frag_free - Free a linked list of VBLK fragments\n * @list:  Linked list of fragments\n *\n * Free a linked list of VBLK fragments\n *\n * Return:  none\n */\nstatic void ldm_frag_free (struct list_head *list)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!list);\n\n\tlist_for_each_safe (item, tmp, list)\n\t\tkfree (list_entry (item, struct frag, list));\n}\n\n/**\n * ldm_frag_commit - Validate fragmented VBLKs and add them to the database\n * @frags:  Linked list of VBLK fragments\n * @ldb:    Cache of the database structures\n *\n * Now that all the fragmented VBLKs have been collected, they must be added to\n * the database for later use.\n *\n * Return:  'true'   All the fragments we added successfully\n *          'false'  One or more of the fragments we invalid\n */\nstatic bool ldm_frag_commit (struct list_head *frags, struct ldmdb *ldb)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\n\tBUG_ON (!frags || !ldb);\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\n\t\tif (f->map != 0xFF) {\n\t\t\tldm_error (\"VBLK group %d is incomplete (0x%02x).\",\n\t\t\t\tf->group, f->map);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!ldm_ldmdb_add (f->data, f->num*ldb->vm.vblk_size, ldb))\n\t\t\treturn false;\t\t/* Already logged */\n\t}\n\treturn true;\n}\n\n/**\n * ldm_get_vblks - Read the on-disk database of VBLKs into memory\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @state->bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * To use the information from the VBLKs, they need to be read from the disk,\n * unpacked and validated.  We cache them in @ldb according to their type.\n *\n * Return:  'true'   All the VBLKs were read successfully\n *          'false'  An error occurred\n */\nstatic bool ldm_get_vblks(struct parsed_partitions *state, unsigned long base,\n\t\t\t  struct ldmdb *ldb)\n{\n\tint size, perbuf, skip, finish, s, v, recs;\n\tu8 *data = NULL;\n\tSector sect;\n\tbool result = false;\n\tLIST_HEAD (frags);\n\n\tBUG_ON(!state || !ldb);\n\n\tsize   = ldb->vm.vblk_size;\n\tperbuf = 512 / size;\n\tskip   = ldb->vm.vblk_offset >> 9;\t\t/* Bytes to sectors */\n\tfinish = (size * ldb->vm.last_vblk_seq) >> 9;\n\n\tfor (s = skip; s < finish; s++) {\t\t/* For each sector */\n\t\tdata = read_part_sector(state, base + OFF_VMDB + s, &sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (v = 0; v < perbuf; v++, data+=size) {  /* For each vblk */\n\t\t\tif (MAGIC_VBLK != get_unaligned_be32(data)) {\n\t\t\t\tldm_error (\"Expected to find a VBLK.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trecs = get_unaligned_be16(data + 0x0E);\t/* Number of records */\n\t\t\tif (recs == 1) {\n\t\t\t\tif (!ldm_ldmdb_add (data, size, ldb))\n\t\t\t\t\tgoto out;\t/* Already logged */\n\t\t\t} else if (recs > 1) {\n\t\t\t\tif (!ldm_frag_add (data, size, &frags))\n\t\t\t\t\tgoto out;\t/* Already logged */\n\t\t\t}\n\t\t\t/* else Record is not in use, ignore it. */\n\t\t}\n\t\tput_dev_sector (sect);\n\t\tdata = NULL;\n\t}\n\n\tresult = ldm_frag_commit (&frags, ldb);\t/* Failures, already logged */\nout:\n\tif (data)\n\t\tput_dev_sector (sect);\n\tldm_frag_free (&frags);\n\n\treturn result;\n}\n\n/**\n * ldm_free_vblks - Free a linked list of vblk's\n * @lh:  Head of a linked list of struct vblk\n *\n * Free a list of vblk's and free the memory used to maintain the list.\n *\n * Return:  none\n */\nstatic void ldm_free_vblks (struct list_head *lh)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!lh);\n\n\tlist_for_each_safe (item, tmp, lh)\n\t\tkfree (list_entry (item, struct vblk, list));\n}\n\n\n/**\n * ldm_partition - Find out whether a device is a dynamic disk and handle it\n * @state: Partition check state including device holding the LDM Database\n *\n * This determines whether the device @bdev is a dynamic disk and if so creates\n * the partitions necessary in the gendisk structure pointed to by @hd.\n *\n * We create a dummy device 1, which contains the LDM database, and then create\n * each partition described by the LDM database in sequence as devices 2+. For\n * example, if the device is hda, we would have: hda1: LDM database, hda2, hda3,\n * and so on: the actual data containing partitions.\n *\n * Return:  1 Success, @state->bdev is a dynamic disk and we handled it\n *          0 Success, @state->bdev is not a dynamic disk\n *         -1 An error occurred before enough information had been read\n *            Or @state->bdev is a dynamic disk, but it may be corrupted\n */\nint ldm_partition(struct parsed_partitions *state)\n{\n\tstruct ldmdb  *ldb;\n\tunsigned long base;\n\tint result = -1;\n\n\tBUG_ON(!state);\n\n\t/* Look for signs of a Dynamic Disk */\n\tif (!ldm_validate_partition_table(state))\n\t\treturn 0;\n\n\tldb = kmalloc (sizeof (*ldb), GFP_KERNEL);\n\tif (!ldb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t/* Parse and check privheads. */\n\tif (!ldm_validate_privheads(state, &ldb->ph))\n\t\tgoto out;\t\t/* Already logged */\n\n\t/* All further references are relative to base (database start). */\n\tbase = ldb->ph.config_start;\n\n\t/* Parse and check tocs and vmdb. */\n\tif (!ldm_validate_tocblocks(state, base, ldb) ||\n\t    !ldm_validate_vmdb(state, base, ldb))\n\t    \tgoto out;\t\t/* Already logged */\n\n\t/* Initialize vblk lists in ldmdb struct */\n\tINIT_LIST_HEAD (&ldb->v_dgrp);\n\tINIT_LIST_HEAD (&ldb->v_disk);\n\tINIT_LIST_HEAD (&ldb->v_volu);\n\tINIT_LIST_HEAD (&ldb->v_comp);\n\tINIT_LIST_HEAD (&ldb->v_part);\n\n\tif (!ldm_get_vblks(state, base, ldb)) {\n\t\tldm_crit (\"Failed to read the VBLKs from the database.\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Finally, create the data partition devices. */\n\tif (ldm_create_data_partitions(state, ldb)) {\n\t\tldm_debug (\"Parsed LDM database successfully.\");\n\t\tresult = 1;\n\t}\n\t/* else Already logged */\n\ncleanup:\n\tldm_free_vblks (&ldb->v_dgrp);\n\tldm_free_vblks (&ldb->v_disk);\n\tldm_free_vblks (&ldb->v_volu);\n\tldm_free_vblks (&ldb->v_comp);\n\tldm_free_vblks (&ldb->v_part);\nout:\n\tkfree (ldb);\n\treturn result;\n}\n"], "fixing_code": ["/**\n * ldm - Support for Windows Logical Disk Manager (Dynamic Disks)\n *\n * Copyright (C) 2001,2002 Richard Russon <ldm@flatcap.org>\n * Copyright (c) 2001-2007 Anton Altaparmakov\n * Copyright (C) 2001,2002 Jakob Kemi <jakob.kemi@telia.com>\n *\n * Documentation is available at http://www.linux-ntfs.org/doku.php?id=downloads \n *\n * This program is free software; you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation; either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program (in the main directory of the source in the file COPYING); if\n * not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n * Boston, MA  02111-1307  USA\n */\n\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include \"ldm.h\"\n#include \"check.h\"\n#include \"msdos.h\"\n\n/**\n * ldm_debug/info/error/crit - Output an error message\n * @f:    A printf format string containing the message\n * @...:  Variables to substitute into @f\n *\n * ldm_debug() writes a DEBUG level message to the syslog but only if the\n * driver was compiled with debug enabled. Otherwise, the call turns into a NOP.\n */\n#ifndef CONFIG_LDM_DEBUG\n#define ldm_debug(...)\tdo {} while (0)\n#else\n#define ldm_debug(f, a...) _ldm_printk (KERN_DEBUG, __func__, f, ##a)\n#endif\n\n#define ldm_crit(f, a...)  _ldm_printk (KERN_CRIT,  __func__, f, ##a)\n#define ldm_error(f, a...) _ldm_printk (KERN_ERR,   __func__, f, ##a)\n#define ldm_info(f, a...)  _ldm_printk (KERN_INFO,  __func__, f, ##a)\n\n__attribute__ ((format (printf, 3, 4)))\nstatic void _ldm_printk (const char *level, const char *function,\n\t\t\t const char *fmt, ...)\n{\n\tstatic char buf[128];\n\tva_list args;\n\n\tva_start (args, fmt);\n\tvsnprintf (buf, sizeof (buf), fmt, args);\n\tva_end (args);\n\n\tprintk (\"%s%s(): %s\\n\", level, function, buf);\n}\n\n/**\n * ldm_parse_hexbyte - Convert a ASCII hex number to a byte\n * @src:  Pointer to at least 2 characters to convert.\n *\n * Convert a two character ASCII hex string to a number.\n *\n * Return:  0-255  Success, the byte was parsed correctly\n *          -1     Error, an invalid character was supplied\n */\nstatic int ldm_parse_hexbyte (const u8 *src)\n{\n\tunsigned int x;\t\t/* For correct wrapping */\n\tint h;\n\n\t/* high part */\n\tx = h = hex_to_bin(src[0]);\n\tif (h < 0)\n\t\treturn -1;\n\n\t/* low part */\n\th = hex_to_bin(src[1]);\n\tif (h < 0)\n\t\treturn -1;\n\n\treturn (x << 4) + h;\n}\n\n/**\n * ldm_parse_guid - Convert GUID from ASCII to binary\n * @src:   36 char string of the form fa50ff2b-f2e8-45de-83fa-65417f2f49ba\n * @dest:  Memory block to hold binary GUID (16 bytes)\n *\n * N.B. The GUID need not be NULL terminated.\n *\n * Return:  'true'   @dest contains binary GUID\n *          'false'  @dest contents are undefined\n */\nstatic bool ldm_parse_guid (const u8 *src, u8 *dest)\n{\n\tstatic const int size[] = { 4, 2, 2, 2, 6 };\n\tint i, j, v;\n\n\tif (src[8]  != '-' || src[13] != '-' ||\n\t    src[18] != '-' || src[23] != '-')\n\t\treturn false;\n\n\tfor (j = 0; j < 5; j++, src++)\n\t\tfor (i = 0; i < size[j]; i++, src+=2, *dest++ = v)\n\t\t\tif ((v = ldm_parse_hexbyte (src)) < 0)\n\t\t\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_privhead - Read the LDM Database PRIVHEAD structure\n * @data:  Raw database PRIVHEAD structure loaded from the device\n * @ph:    In-memory privhead structure in which to return parsed information\n *\n * This parses the LDM database PRIVHEAD structure supplied in @data and\n * sets up the in-memory privhead structure @ph with the obtained information.\n *\n * Return:  'true'   @ph contains the PRIVHEAD data\n *          'false'  @ph contents are undefined\n */\nstatic bool ldm_parse_privhead(const u8 *data, struct privhead *ph)\n{\n\tbool is_vista = false;\n\n\tBUG_ON(!data || !ph);\n\tif (MAGIC_PRIVHEAD != get_unaligned_be64(data)) {\n\t\tldm_error(\"Cannot find PRIVHEAD structure. LDM database is\"\n\t\t\t\" corrupt. Aborting.\");\n\t\treturn false;\n\t}\n\tph->ver_major = get_unaligned_be16(data + 0x000C);\n\tph->ver_minor = get_unaligned_be16(data + 0x000E);\n\tph->logical_disk_start = get_unaligned_be64(data + 0x011B);\n\tph->logical_disk_size = get_unaligned_be64(data + 0x0123);\n\tph->config_start = get_unaligned_be64(data + 0x012B);\n\tph->config_size = get_unaligned_be64(data + 0x0133);\n\t/* Version 2.11 is Win2k/XP and version 2.12 is Vista. */\n\tif (ph->ver_major == 2 && ph->ver_minor == 12)\n\t\tis_vista = true;\n\tif (!is_vista && (ph->ver_major != 2 || ph->ver_minor != 11)) {\n\t\tldm_error(\"Expected PRIVHEAD version 2.11 or 2.12, got %d.%d.\"\n\t\t\t\" Aborting.\", ph->ver_major, ph->ver_minor);\n\t\treturn false;\n\t}\n\tldm_debug(\"PRIVHEAD version %d.%d (Windows %s).\", ph->ver_major,\n\t\t\tph->ver_minor, is_vista ? \"Vista\" : \"2000/XP\");\n\tif (ph->config_size != LDM_DB_SIZE) {\t/* 1 MiB in sectors. */\n\t\t/* Warn the user and continue, carefully. */\n\t\tldm_info(\"Database is normally %u bytes, it claims to \"\n\t\t\t\"be %llu bytes.\", LDM_DB_SIZE,\n\t\t\t(unsigned long long)ph->config_size);\n\t}\n\tif ((ph->logical_disk_size == 0) || (ph->logical_disk_start +\n\t\t\tph->logical_disk_size > ph->config_start)) {\n\t\tldm_error(\"PRIVHEAD disk size doesn't match real disk size\");\n\t\treturn false;\n\t}\n\tif (!ldm_parse_guid(data + 0x0030, ph->disk_id)) {\n\t\tldm_error(\"PRIVHEAD contains an invalid GUID.\");\n\t\treturn false;\n\t}\n\tldm_debug(\"Parsed PRIVHEAD successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_parse_tocblock - Read the LDM Database TOCBLOCK structure\n * @data:  Raw database TOCBLOCK structure loaded from the device\n * @toc:   In-memory toc structure in which to return parsed information\n *\n * This parses the LDM Database TOCBLOCK (table of contents) structure supplied\n * in @data and sets up the in-memory tocblock structure @toc with the obtained\n * information.\n *\n * N.B.  The *_start and *_size values returned in @toc are not range-checked.\n *\n * Return:  'true'   @toc contains the TOCBLOCK data\n *          'false'  @toc contents are undefined\n */\nstatic bool ldm_parse_tocblock (const u8 *data, struct tocblock *toc)\n{\n\tBUG_ON (!data || !toc);\n\n\tif (MAGIC_TOCBLOCK != get_unaligned_be64(data)) {\n\t\tldm_crit (\"Cannot find TOCBLOCK, database may be corrupt.\");\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap1_name, data + 0x24, sizeof (toc->bitmap1_name));\n\ttoc->bitmap1_name[sizeof (toc->bitmap1_name) - 1] = 0;\n\ttoc->bitmap1_start = get_unaligned_be64(data + 0x2E);\n\ttoc->bitmap1_size  = get_unaligned_be64(data + 0x36);\n\n\tif (strncmp (toc->bitmap1_name, TOC_BITMAP1,\n\t\t\tsizeof (toc->bitmap1_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's first bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP1, toc->bitmap1_name);\n\t\treturn false;\n\t}\n\tstrncpy (toc->bitmap2_name, data + 0x46, sizeof (toc->bitmap2_name));\n\ttoc->bitmap2_name[sizeof (toc->bitmap2_name) - 1] = 0;\n\ttoc->bitmap2_start = get_unaligned_be64(data + 0x50);\n\ttoc->bitmap2_size  = get_unaligned_be64(data + 0x58);\n\tif (strncmp (toc->bitmap2_name, TOC_BITMAP2,\n\t\t\tsizeof (toc->bitmap2_name)) != 0) {\n\t\tldm_crit (\"TOCBLOCK's second bitmap is '%s', should be '%s'.\",\n\t\t\t\tTOC_BITMAP2, toc->bitmap2_name);\n\t\treturn false;\n\t}\n\tldm_debug (\"Parsed TOCBLOCK successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_parse_vmdb - Read the LDM Database VMDB structure\n * @data:  Raw database VMDB structure loaded from the device\n * @vm:    In-memory vmdb structure in which to return parsed information\n *\n * This parses the LDM Database VMDB structure supplied in @data and sets up\n * the in-memory vmdb structure @vm with the obtained information.\n *\n * N.B.  The *_start, *_size and *_seq values will be range-checked later.\n *\n * Return:  'true'   @vm contains VMDB info\n *          'false'  @vm contents are undefined\n */\nstatic bool ldm_parse_vmdb (const u8 *data, struct vmdb *vm)\n{\n\tBUG_ON (!data || !vm);\n\n\tif (MAGIC_VMDB != get_unaligned_be32(data)) {\n\t\tldm_crit (\"Cannot find the VMDB, database may be corrupt.\");\n\t\treturn false;\n\t}\n\n\tvm->ver_major = get_unaligned_be16(data + 0x12);\n\tvm->ver_minor = get_unaligned_be16(data + 0x14);\n\tif ((vm->ver_major != 4) || (vm->ver_minor != 10)) {\n\t\tldm_error (\"Expected VMDB version %d.%d, got %d.%d. \"\n\t\t\t\"Aborting.\", 4, 10, vm->ver_major, vm->ver_minor);\n\t\treturn false;\n\t}\n\n\tvm->vblk_size     = get_unaligned_be32(data + 0x08);\n\tif (vm->vblk_size == 0) {\n\t\tldm_error (\"Illegal VBLK size\");\n\t\treturn false;\n\t}\n\n\tvm->vblk_offset   = get_unaligned_be32(data + 0x0C);\n\tvm->last_vblk_seq = get_unaligned_be32(data + 0x04);\n\n\tldm_debug (\"Parsed VMDB successfully.\");\n\treturn true;\n}\n\n/**\n * ldm_compare_privheads - Compare two privhead objects\n * @ph1:  First privhead\n * @ph2:  Second privhead\n *\n * This compares the two privhead structures @ph1 and @ph2.\n *\n * Return:  'true'   Identical\n *          'false'  Different\n */\nstatic bool ldm_compare_privheads (const struct privhead *ph1,\n\t\t\t\t   const struct privhead *ph2)\n{\n\tBUG_ON (!ph1 || !ph2);\n\n\treturn ((ph1->ver_major          == ph2->ver_major)\t\t&&\n\t\t(ph1->ver_minor          == ph2->ver_minor)\t\t&&\n\t\t(ph1->logical_disk_start == ph2->logical_disk_start)\t&&\n\t\t(ph1->logical_disk_size  == ph2->logical_disk_size)\t&&\n\t\t(ph1->config_start       == ph2->config_start)\t\t&&\n\t\t(ph1->config_size        == ph2->config_size)\t\t&&\n\t\t!memcmp (ph1->disk_id, ph2->disk_id, GUID_SIZE));\n}\n\n/**\n * ldm_compare_tocblocks - Compare two tocblock objects\n * @toc1:  First toc\n * @toc2:  Second toc\n *\n * This compares the two tocblock structures @toc1 and @toc2.\n *\n * Return:  'true'   Identical\n *          'false'  Different\n */\nstatic bool ldm_compare_tocblocks (const struct tocblock *toc1,\n\t\t\t\t   const struct tocblock *toc2)\n{\n\tBUG_ON (!toc1 || !toc2);\n\n\treturn ((toc1->bitmap1_start == toc2->bitmap1_start)\t&&\n\t\t(toc1->bitmap1_size  == toc2->bitmap1_size)\t&&\n\t\t(toc1->bitmap2_start == toc2->bitmap2_start)\t&&\n\t\t(toc1->bitmap2_size  == toc2->bitmap2_size)\t&&\n\t\t!strncmp (toc1->bitmap1_name, toc2->bitmap1_name,\n\t\t\tsizeof (toc1->bitmap1_name))\t\t&&\n\t\t!strncmp (toc1->bitmap2_name, toc2->bitmap2_name,\n\t\t\tsizeof (toc1->bitmap2_name)));\n}\n\n/**\n * ldm_validate_privheads - Compare the primary privhead with its backups\n * @state: Partition check state including device holding the LDM Database\n * @ph1:   Memory struct to fill with ph contents\n *\n * Read and compare all three privheads from disk.\n *\n * The privheads on disk show the size and location of the main disk area and\n * the configuration area (the database).  The values are range-checked against\n * @hd, which contains the real size of the disk.\n *\n * Return:  'true'   Success\n *          'false'  Error\n */\nstatic bool ldm_validate_privheads(struct parsed_partitions *state,\n\t\t\t\t   struct privhead *ph1)\n{\n\tstatic const int off[3] = { OFF_PRIV1, OFF_PRIV2, OFF_PRIV3 };\n\tstruct privhead *ph[3] = { ph1 };\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tlong num_sects;\n\tint i;\n\n\tBUG_ON (!state || !ph1);\n\n\tph[1] = kmalloc (sizeof (*ph[1]), GFP_KERNEL);\n\tph[2] = kmalloc (sizeof (*ph[2]), GFP_KERNEL);\n\tif (!ph[1] || !ph[2]) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t/* off[1 & 2] are relative to ph[0]->config_start */\n\tph[0]->config_start = 0;\n\n\t/* Read and parse privheads */\n\tfor (i = 0; i < 3; i++) {\n\t\tdata = read_part_sector(state, ph[0]->config_start + off[i],\n\t\t\t\t\t&sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\t\tresult = ldm_parse_privhead (data, ph[i]);\n\t\tput_dev_sector (sect);\n\t\tif (!result) {\n\t\t\tldm_error (\"Cannot find PRIVHEAD %d.\", i+1); /* Log again */\n\t\t\tif (i < 2)\n\t\t\t\tgoto out;\t/* Already logged */\n\t\t\telse\n\t\t\t\tbreak;\t/* FIXME ignore for now, 3rd PH can fail on odd-sized disks */\n\t\t}\n\t}\n\n\tnum_sects = state->bdev->bd_inode->i_size >> 9;\n\n\tif ((ph[0]->config_start > num_sects) ||\n\t   ((ph[0]->config_start + ph[0]->config_size) > num_sects)) {\n\t\tldm_crit (\"Database extends beyond the end of the disk.\");\n\t\tgoto out;\n\t}\n\n\tif ((ph[0]->logical_disk_start > ph[0]->config_start) ||\n\t   ((ph[0]->logical_disk_start + ph[0]->logical_disk_size)\n\t\t    > ph[0]->config_start)) {\n\t\tldm_crit (\"Disk and database overlap.\");\n\t\tgoto out;\n\t}\n\n\tif (!ldm_compare_privheads (ph[0], ph[1])) {\n\t\tldm_crit (\"Primary and backup PRIVHEADs don't match.\");\n\t\tgoto out;\n\t}\n\t/* FIXME ignore this for now\n\tif (!ldm_compare_privheads (ph[0], ph[2])) {\n\t\tldm_crit (\"Primary and backup PRIVHEADs don't match.\");\n\t\tgoto out;\n\t}*/\n\tldm_debug (\"Validated PRIVHEADs successfully.\");\n\tresult = true;\nout:\n\tkfree (ph[1]);\n\tkfree (ph[2]);\n\treturn result;\n}\n\n/**\n * ldm_validate_tocblocks - Validate the table of contents and its backups\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @state->bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * Find and compare the four tables of contents of the LDM Database stored on\n * @state->bdev and return the parsed information into @toc1.\n *\n * The offsets and sizes of the configs are range-checked against a privhead.\n *\n * Return:  'true'   @toc1 contains validated TOCBLOCK info\n *          'false'  @toc1 contents are undefined\n */\nstatic bool ldm_validate_tocblocks(struct parsed_partitions *state,\n\t\t\t\t   unsigned long base, struct ldmdb *ldb)\n{\n\tstatic const int off[4] = { OFF_TOCB1, OFF_TOCB2, OFF_TOCB3, OFF_TOCB4};\n\tstruct tocblock *tb[4];\n\tstruct privhead *ph;\n\tSector sect;\n\tu8 *data;\n\tint i, nr_tbs;\n\tbool result = false;\n\n\tBUG_ON(!state || !ldb);\n\tph = &ldb->ph;\n\ttb[0] = &ldb->toc;\n\ttb[1] = kmalloc(sizeof(*tb[1]) * 3, GFP_KERNEL);\n\tif (!tb[1]) {\n\t\tldm_crit(\"Out of memory.\");\n\t\tgoto err;\n\t}\n\ttb[2] = (struct tocblock*)((u8*)tb[1] + sizeof(*tb[1]));\n\ttb[3] = (struct tocblock*)((u8*)tb[2] + sizeof(*tb[2]));\n\t/*\n\t * Try to read and parse all four TOCBLOCKs.\n\t *\n\t * Windows Vista LDM v2.12 does not always have all four TOCBLOCKs so\n\t * skip any that fail as long as we get at least one valid TOCBLOCK.\n\t */\n\tfor (nr_tbs = i = 0; i < 4; i++) {\n\t\tdata = read_part_sector(state, base + off[i], &sect);\n\t\tif (!data) {\n\t\t\tldm_error(\"Disk read failed for TOCBLOCK %d.\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ldm_parse_tocblock(data, tb[nr_tbs]))\n\t\t\tnr_tbs++;\n\t\tput_dev_sector(sect);\n\t}\n\tif (!nr_tbs) {\n\t\tldm_crit(\"Failed to find a valid TOCBLOCK.\");\n\t\tgoto err;\n\t}\n\t/* Range check the TOCBLOCK against a privhead. */\n\tif (((tb[0]->bitmap1_start + tb[0]->bitmap1_size) > ph->config_size) ||\n\t\t\t((tb[0]->bitmap2_start + tb[0]->bitmap2_size) >\n\t\t\tph->config_size)) {\n\t\tldm_crit(\"The bitmaps are out of range.  Giving up.\");\n\t\tgoto err;\n\t}\n\t/* Compare all loaded TOCBLOCKs. */\n\tfor (i = 1; i < nr_tbs; i++) {\n\t\tif (!ldm_compare_tocblocks(tb[0], tb[i])) {\n\t\t\tldm_crit(\"TOCBLOCKs 0 and %d do not match.\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tldm_debug(\"Validated %d TOCBLOCKs successfully.\", nr_tbs);\n\tresult = true;\nerr:\n\tkfree(tb[1]);\n\treturn result;\n}\n\n/**\n * ldm_validate_vmdb - Read the VMDB and validate it\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * Find the vmdb of the LDM Database stored on @bdev and return the parsed\n * information in @ldb.\n *\n * Return:  'true'   @ldb contains validated VBDB info\n *          'false'  @ldb contents are undefined\n */\nstatic bool ldm_validate_vmdb(struct parsed_partitions *state,\n\t\t\t      unsigned long base, struct ldmdb *ldb)\n{\n\tSector sect;\n\tu8 *data;\n\tbool result = false;\n\tstruct vmdb *vm;\n\tstruct tocblock *toc;\n\n\tBUG_ON (!state || !ldb);\n\n\tvm  = &ldb->vm;\n\ttoc = &ldb->toc;\n\n\tdata = read_part_sector(state, base + OFF_VMDB, &sect);\n\tif (!data) {\n\t\tldm_crit (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vmdb (data, vm))\n\t\tgoto out;\t\t\t\t/* Already logged */\n\n\t/* Are there uncommitted transactions? */\n\tif (get_unaligned_be16(data + 0x10) != 0x01) {\n\t\tldm_crit (\"Database is not in a consistent state.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tif (vm->vblk_offset != 512)\n\t\tldm_info (\"VBLKs start at offset 0x%04x.\", vm->vblk_offset);\n\n\t/*\n\t * The last_vblkd_seq can be before the end of the vmdb, just make sure\n\t * it is not out of bounds.\n\t */\n\tif ((vm->vblk_size * vm->last_vblk_seq) > (toc->bitmap1_size << 9)) {\n\t\tldm_crit (\"VMDB exceeds allowed size specified by TOCBLOCK.  \"\n\t\t\t\t\"Database is corrupt.  Aborting.\");\n\t\tgoto out;\n\t}\n\n\tresult = true;\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n\n/**\n * ldm_validate_partition_table - Determine whether bdev might be a dynamic disk\n * @state: Partition check state including device holding the LDM Database\n *\n * This function provides a weak test to decide whether the device is a dynamic\n * disk or not.  It looks for an MS-DOS-style partition table containing at\n * least one partition of type 0x42 (formerly SFS, now used by Windows for\n * dynamic disks).\n *\n * N.B.  The only possible error can come from the read_part_sector and that is\n *       only likely to happen if the underlying device is strange.  If that IS\n *       the case we should return zero to let someone else try.\n *\n * Return:  'true'   @state->bdev is a dynamic disk\n *          'false'  @state->bdev is not a dynamic disk, or an error occurred\n */\nstatic bool ldm_validate_partition_table(struct parsed_partitions *state)\n{\n\tSector sect;\n\tu8 *data;\n\tstruct partition *p;\n\tint i;\n\tbool result = false;\n\n\tBUG_ON(!state);\n\n\tdata = read_part_sector(state, 0, &sect);\n\tif (!data) {\n\t\tldm_crit (\"Disk read failed.\");\n\t\treturn false;\n\t}\n\n\tif (*(__le16*) (data + 0x01FE) != cpu_to_le16 (MSDOS_LABEL_MAGIC))\n\t\tgoto out;\n\n\tp = (struct partition*)(data + 0x01BE);\n\tfor (i = 0; i < 4; i++, p++)\n\t\tif (SYS_IND (p) == LDM_PARTITION) {\n\t\t\tresult = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (result)\n\t\tldm_debug (\"Found W2K dynamic disk partition type.\");\n\nout:\n\tput_dev_sector (sect);\n\treturn result;\n}\n\n/**\n * ldm_get_disk_objid - Search a linked list of vblk's for a given Disk Id\n * @ldb:  Cache of the database structures\n *\n * The LDM Database contains a list of all partitions on all dynamic disks.\n * The primary PRIVHEAD, at the beginning of the physical disk, tells us\n * the GUID of this disk.  This function searches for the GUID in a linked\n * list of vblk's.\n *\n * Return:  Pointer, A matching vblk was found\n *          NULL,    No match, or an error\n */\nstatic struct vblk * ldm_get_disk_objid (const struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\n\tBUG_ON (!ldb);\n\n\tlist_for_each (item, &ldb->v_disk) {\n\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\tif (!memcmp (v->vblk.disk.disk_id, ldb->ph.disk_id, GUID_SIZE))\n\t\t\treturn v;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * ldm_create_data_partitions - Create data partitions for this device\n * @pp:   List of the partitions parsed so far\n * @ldb:  Cache of the database structures\n *\n * The database contains ALL the partitions for ALL disk groups, so we need to\n * filter out this specific disk. Using the disk's object id, we can find all\n * the partitions in the database that belong to this disk.\n *\n * Add each partition in our database, to the parsed_partitions structure.\n *\n * N.B.  This function creates the partitions in the order it finds partition\n *       objects in the linked list.\n *\n * Return:  'true'   Partition created\n *          'false'  Error, probably a range checking problem\n */\nstatic bool ldm_create_data_partitions (struct parsed_partitions *pp,\n\t\t\t\t\tconst struct ldmdb *ldb)\n{\n\tstruct list_head *item;\n\tstruct vblk *vb;\n\tstruct vblk *disk;\n\tstruct vblk_part *part;\n\tint part_num = 1;\n\n\tBUG_ON (!pp || !ldb);\n\n\tdisk = ldm_get_disk_objid (ldb);\n\tif (!disk) {\n\t\tldm_crit (\"Can't find the ID of this disk in the database.\");\n\t\treturn false;\n\t}\n\n\tstrlcat(pp->pp_buf, \" [LDM]\", PAGE_SIZE);\n\n\t/* Create the data partitions */\n\tlist_for_each (item, &ldb->v_part) {\n\t\tvb = list_entry (item, struct vblk, list);\n\t\tpart = &vb->vblk.part;\n\n\t\tif (part->disk_id != disk->obj_id)\n\t\t\tcontinue;\n\n\t\tput_partition (pp, part_num, ldb->ph.logical_disk_start +\n\t\t\t\tpart->start, part->size);\n\t\tpart_num++;\n\t}\n\n\tstrlcat(pp->pp_buf, \"\\n\", PAGE_SIZE);\n\treturn true;\n}\n\n\n/**\n * ldm_relative - Calculate the next relative offset\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @base:    Size of the previous fixed width fields\n * @offset:  Cumulative size of the previous variable-width fields\n *\n * Because many of the VBLK fields are variable-width, it's necessary\n * to calculate each offset based on the previous one and the length\n * of the field it pointed to.\n *\n * Return:  -1 Error, the calculated offset exceeded the size of the buffer\n *           n OK, a range-checked offset into buffer\n */\nstatic int ldm_relative(const u8 *buffer, int buflen, int base, int offset)\n{\n\n\tbase += offset;\n\tif (!buffer || offset < 0 || base > buflen) {\n\t\tif (!buffer)\n\t\t\tldm_error(\"!buffer\");\n\t\tif (offset < 0)\n\t\t\tldm_error(\"offset (%d) < 0\", offset);\n\t\tif (base > buflen)\n\t\t\tldm_error(\"base (%d) > buflen (%d)\", base, buflen);\n\t\treturn -1;\n\t}\n\tif (base + buffer[base] >= buflen) {\n\t\tldm_error(\"base (%d) + buffer[base] (%d) >= buflen (%d)\", base,\n\t\t\t\tbuffer[base], buflen);\n\t\treturn -1;\n\t}\n\treturn buffer[base] + offset + 1;\n}\n\n/**\n * ldm_get_vnum - Convert a variable-width, big endian number, into cpu order\n * @block:  Pointer to the variable-width number to convert\n *\n * Large numbers in the LDM Database are often stored in a packed format.  Each\n * number is prefixed by a one byte width marker.  All numbers in the database\n * are stored in big-endian byte order.  This function reads one of these\n * numbers and returns the result\n *\n * N.B.  This function DOES NOT perform any range checking, though the most\n *       it will read is eight bytes.\n *\n * Return:  n A number\n *          0 Zero, or an error occurred\n */\nstatic u64 ldm_get_vnum (const u8 *block)\n{\n\tu64 tmp = 0;\n\tu8 length;\n\n\tBUG_ON (!block);\n\n\tlength = *block++;\n\n\tif (length && length <= 8)\n\t\twhile (length--)\n\t\t\ttmp = (tmp << 8) | *block++;\n\telse\n\t\tldm_error (\"Illegal length %d.\", length);\n\n\treturn tmp;\n}\n\n/**\n * ldm_get_vstr - Read a length-prefixed string into a buffer\n * @block:   Pointer to the length marker\n * @buffer:  Location to copy string to\n * @buflen:  Size of the output buffer\n *\n * Many of the strings in the LDM Database are not NULL terminated.  Instead\n * they are prefixed by a one byte length marker.  This function copies one of\n * these strings into a buffer.\n *\n * N.B.  This function DOES NOT perform any range checking on the input.\n *       If the buffer is too small, the output will be truncated.\n *\n * Return:  0, Error and @buffer contents are undefined\n *          n, String length in characters (excluding NULL)\n *          buflen-1, String was truncated.\n */\nstatic int ldm_get_vstr (const u8 *block, u8 *buffer, int buflen)\n{\n\tint length;\n\n\tBUG_ON (!block || !buffer);\n\n\tlength = block[0];\n\tif (length >= buflen) {\n\t\tldm_error (\"Truncating string %d -> %d.\", length, buflen);\n\t\tlength = buflen - 1;\n\t}\n\tmemcpy (buffer, block + 1, length);\n\tbuffer[length] = 0;\n\treturn length;\n}\n\n\n/**\n * ldm_parse_cmp3 - Read a raw VBLK Component object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Component object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Component VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_cmp3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vstate, r_child, r_parent, r_stripe, r_cols, len;\n\tstruct vblk_comp *comp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_vstate = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_child  = ldm_relative (buffer, buflen, 0x1D, r_vstate);\n\tr_parent = ldm_relative (buffer, buflen, 0x2D, r_child);\n\n\tif (buffer[0x12] & VBLK_FLAG_COMP_STRIPE) {\n\t\tr_stripe = ldm_relative (buffer, buflen, 0x2E, r_parent);\n\t\tr_cols   = ldm_relative (buffer, buflen, 0x2E, r_stripe);\n\t\tlen = r_cols;\n\t} else {\n\t\tr_stripe = 0;\n\t\tr_cols   = 0;\n\t\tlen = r_parent;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_CMP3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tcomp = &vb->vblk.comp;\n\tldm_get_vstr (buffer + 0x18 + r_name, comp->state,\n\t\tsizeof (comp->state));\n\tcomp->type      = buffer[0x18 + r_vstate];\n\tcomp->children  = ldm_get_vnum (buffer + 0x1D + r_vstate);\n\tcomp->parent_id = ldm_get_vnum (buffer + 0x2D + r_child);\n\tcomp->chunksize = r_stripe ? ldm_get_vnum (buffer+r_parent+0x2E) : 0;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_dgr3 - Read a raw VBLK Disk Group object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk Group object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk Group VBLK\n *          'false'  @vb contents are not defined\n */\nstatic int ldm_parse_dgr3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid = ldm_relative (buffer, buflen, 0x18, r_name);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR3_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x24, r_diskid);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x24, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\tldm_get_vstr (buffer + 0x18 + r_name, dgrp->disk_id,\n\t\tsizeof (dgrp->disk_id));\n\treturn true;\n}\n\n/**\n * ldm_parse_dgr4 - Read a raw VBLK Disk Group object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk Group object (version 4) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk Group VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dgr4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tchar buf[64];\n\tint r_objid, r_name, r_id1, r_id2, len;\n\tstruct vblk_dgrp *dgrp;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid  = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name   = ldm_relative (buffer, buflen, 0x18, r_objid);\n\n\tif (buffer[0x12] & VBLK_FLAG_DGR4_IDS) {\n\t\tr_id1 = ldm_relative (buffer, buflen, 0x44, r_name);\n\t\tr_id2 = ldm_relative (buffer, buflen, 0x44, r_id1);\n\t\tlen = r_id2;\n\t} else {\n\t\tr_id1 = 0;\n\t\tr_id2 = 0;\n\t\tlen = r_name;\n\t}\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DGR4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdgrp = &vb->vblk.dgrp;\n\n\tldm_get_vstr (buffer + 0x18 + r_objid, buf, sizeof (buf));\n\treturn true;\n}\n\n/**\n * ldm_parse_dsk3 - Read a raw VBLK Disk object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dsk3 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_diskid, r_altname, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid   = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name    = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tr_diskid  = ldm_relative (buffer, buflen, 0x18, r_name);\n\tr_altname = ldm_relative (buffer, buflen, 0x18, r_diskid);\n\tlen = r_altname;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK3;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tldm_get_vstr (buffer + 0x18 + r_diskid, disk->alt_name,\n\t\tsizeof (disk->alt_name));\n\tif (!ldm_parse_guid (buffer + 0x19 + r_name, disk->disk_id))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * ldm_parse_dsk4 - Read a raw VBLK Disk object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Disk object (version 4) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Disk VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_dsk4 (const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, len;\n\tstruct vblk_disk *disk;\n\n\tBUG_ON (!buffer || !vb);\n\n\tr_objid = ldm_relative (buffer, buflen, 0x18, 0);\n\tr_name  = ldm_relative (buffer, buflen, 0x18, r_objid);\n\tlen     = r_name;\n\tif (len < 0)\n\t\treturn false;\n\n\tlen += VBLK_SIZE_DSK4;\n\tif (len != get_unaligned_be32(buffer + 0x14))\n\t\treturn false;\n\n\tdisk = &vb->vblk.disk;\n\tmemcpy (disk->disk_id, buffer + 0x18 + r_name, GUID_SIZE);\n\treturn true;\n}\n\n/**\n * ldm_parse_prt3 - Read a raw VBLK Partition object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Partition object (version 3) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Partition VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_prt3(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_size, r_parent, r_diskid, r_index, len;\n\tstruct vblk_part *part;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x34, r_name);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tr_parent = ldm_relative(buffer, buflen, 0x34, r_size);\n\tif (r_parent < 0) {\n\t\tldm_error(\"r_parent %d < 0\", r_parent);\n\t\treturn false;\n\t}\n\tr_diskid = ldm_relative(buffer, buflen, 0x34, r_parent);\n\tif (r_diskid < 0) {\n\t\tldm_error(\"r_diskid %d < 0\", r_diskid);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_PART_INDEX) {\n\t\tr_index = ldm_relative(buffer, buflen, 0x34, r_diskid);\n\t\tif (r_index < 0) {\n\t\t\tldm_error(\"r_index %d < 0\", r_index);\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_index;\n\t} else {\n\t\tr_index = 0;\n\t\tlen = r_diskid;\n\t}\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_PRT3;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tpart = &vb->vblk.part;\n\tpart->start = get_unaligned_be64(buffer + 0x24 + r_name);\n\tpart->volume_offset = get_unaligned_be64(buffer + 0x2C + r_name);\n\tpart->size = ldm_get_vnum(buffer + 0x34 + r_name);\n\tpart->parent_id = ldm_get_vnum(buffer + 0x34 + r_size);\n\tpart->disk_id = ldm_get_vnum(buffer + 0x34 + r_parent);\n\tif (vb->flags & VBLK_FLAG_PART_INDEX)\n\t\tpart->partnum = buffer[0x35 + r_diskid];\n\telse\n\t\tpart->partnum = 0;\n\treturn true;\n}\n\n/**\n * ldm_parse_vol5 - Read a raw VBLK Volume object into a vblk structure\n * @buffer:  Block of data being worked on\n * @buflen:  Size of the block of data\n * @vb:      In-memory vblk in which to return information\n *\n * Read a raw VBLK Volume object (version 5) into a vblk structure.\n *\n * Return:  'true'   @vb contains a Volume VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_vol5(const u8 *buffer, int buflen, struct vblk *vb)\n{\n\tint r_objid, r_name, r_vtype, r_disable_drive_letter, r_child, r_size;\n\tint r_id1, r_id2, r_size2, r_drive, len;\n\tstruct vblk_volu *volu;\n\n\tBUG_ON(!buffer || !vb);\n\tr_objid = ldm_relative(buffer, buflen, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error(\"r_objid %d < 0\", r_objid);\n\t\treturn false;\n\t}\n\tr_name = ldm_relative(buffer, buflen, 0x18, r_objid);\n\tif (r_name < 0) {\n\t\tldm_error(\"r_name %d < 0\", r_name);\n\t\treturn false;\n\t}\n\tr_vtype = ldm_relative(buffer, buflen, 0x18, r_name);\n\tif (r_vtype < 0) {\n\t\tldm_error(\"r_vtype %d < 0\", r_vtype);\n\t\treturn false;\n\t}\n\tr_disable_drive_letter = ldm_relative(buffer, buflen, 0x18, r_vtype);\n\tif (r_disable_drive_letter < 0) {\n\t\tldm_error(\"r_disable_drive_letter %d < 0\",\n\t\t\t\tr_disable_drive_letter);\n\t\treturn false;\n\t}\n\tr_child = ldm_relative(buffer, buflen, 0x2D, r_disable_drive_letter);\n\tif (r_child < 0) {\n\t\tldm_error(\"r_child %d < 0\", r_child);\n\t\treturn false;\n\t}\n\tr_size = ldm_relative(buffer, buflen, 0x3D, r_child);\n\tif (r_size < 0) {\n\t\tldm_error(\"r_size %d < 0\", r_size);\n\t\treturn false;\n\t}\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID1) {\n\t\tr_id1 = ldm_relative(buffer, buflen, 0x52, r_size);\n\t\tif (r_id1 < 0) {\n\t\t\tldm_error(\"r_id1 %d < 0\", r_id1);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id1 = r_size;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_ID2) {\n\t\tr_id2 = ldm_relative(buffer, buflen, 0x52, r_id1);\n\t\tif (r_id2 < 0) {\n\t\t\tldm_error(\"r_id2 %d < 0\", r_id2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_id2 = r_id1;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_SIZE) {\n\t\tr_size2 = ldm_relative(buffer, buflen, 0x52, r_id2);\n\t\tif (r_size2 < 0) {\n\t\t\tldm_error(\"r_size2 %d < 0\", r_size2);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_size2 = r_id2;\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tr_drive = ldm_relative(buffer, buflen, 0x52, r_size2);\n\t\tif (r_drive < 0) {\n\t\t\tldm_error(\"r_drive %d < 0\", r_drive);\n\t\t\treturn false;\n\t\t}\n\t} else\n\t\tr_drive = r_size2;\n\tlen = r_drive;\n\tif (len < 0) {\n\t\tldm_error(\"len %d < 0\", len);\n\t\treturn false;\n\t}\n\tlen += VBLK_SIZE_VOL5;\n\tif (len > get_unaligned_be32(buffer + 0x14)) {\n\t\tldm_error(\"len %d > BE32(buffer + 0x14) %d\", len,\n\t\t\t\tget_unaligned_be32(buffer + 0x14));\n\t\treturn false;\n\t}\n\tvolu = &vb->vblk.volu;\n\tldm_get_vstr(buffer + 0x18 + r_name, volu->volume_type,\n\t\t\tsizeof(volu->volume_type));\n\tmemcpy(volu->volume_state, buffer + 0x18 + r_disable_drive_letter,\n\t\t\tsizeof(volu->volume_state));\n\tvolu->size = ldm_get_vnum(buffer + 0x3D + r_child);\n\tvolu->partition_type = buffer[0x41 + r_size];\n\tmemcpy(volu->guid, buffer + 0x42 + r_size, sizeof(volu->guid));\n\tif (buffer[0x12] & VBLK_FLAG_VOLU_DRIVE) {\n\t\tldm_get_vstr(buffer + 0x52 + r_size, volu->drive_hint,\n\t\t\t\tsizeof(volu->drive_hint));\n\t}\n\treturn true;\n}\n\n/**\n * ldm_parse_vblk - Read a raw VBLK object into a vblk structure\n * @buf:  Block of data being worked on\n * @len:  Size of the block of data\n * @vb:   In-memory vblk in which to return information\n *\n * Read a raw VBLK object into a vblk structure.  This function just reads the\n * information common to all VBLK types, then delegates the rest of the work to\n * helper functions: ldm_parse_*.\n *\n * Return:  'true'   @vb contains a VBLK\n *          'false'  @vb contents are not defined\n */\nstatic bool ldm_parse_vblk (const u8 *buf, int len, struct vblk *vb)\n{\n\tbool result = false;\n\tint r_objid;\n\n\tBUG_ON (!buf || !vb);\n\n\tr_objid = ldm_relative (buf, len, 0x18, 0);\n\tif (r_objid < 0) {\n\t\tldm_error (\"VBLK header is corrupt.\");\n\t\treturn false;\n\t}\n\n\tvb->flags  = buf[0x12];\n\tvb->type   = buf[0x13];\n\tvb->obj_id = ldm_get_vnum (buf + 0x18);\n\tldm_get_vstr (buf+0x18+r_objid, vb->name, sizeof (vb->name));\n\n\tswitch (vb->type) {\n\t\tcase VBLK_CMP3:  result = ldm_parse_cmp3 (buf, len, vb); break;\n\t\tcase VBLK_DSK3:  result = ldm_parse_dsk3 (buf, len, vb); break;\n\t\tcase VBLK_DSK4:  result = ldm_parse_dsk4 (buf, len, vb); break;\n\t\tcase VBLK_DGR3:  result = ldm_parse_dgr3 (buf, len, vb); break;\n\t\tcase VBLK_DGR4:  result = ldm_parse_dgr4 (buf, len, vb); break;\n\t\tcase VBLK_PRT3:  result = ldm_parse_prt3 (buf, len, vb); break;\n\t\tcase VBLK_VOL5:  result = ldm_parse_vol5 (buf, len, vb); break;\n\t}\n\n\tif (result)\n\t\tldm_debug (\"Parsed VBLK 0x%llx (type: 0x%02x) ok.\",\n\t\t\t (unsigned long long) vb->obj_id, vb->type);\n\telse\n\t\tldm_error (\"Failed to parse VBLK 0x%llx (type: 0x%02x).\",\n\t\t\t(unsigned long long) vb->obj_id, vb->type);\n\n\treturn result;\n}\n\n\n/**\n * ldm_ldmdb_add - Adds a raw VBLK entry to the ldmdb database\n * @data:  Raw VBLK to add to the database\n * @len:   Size of the raw VBLK\n * @ldb:   Cache of the database structures\n *\n * The VBLKs are sorted into categories.  Partitions are also sorted by offset.\n *\n * N.B.  This function does not check the validity of the VBLKs.\n *\n * Return:  'true'   The VBLK was added\n *          'false'  An error occurred\n */\nstatic bool ldm_ldmdb_add (u8 *data, int len, struct ldmdb *ldb)\n{\n\tstruct vblk *vb;\n\tstruct list_head *item;\n\n\tBUG_ON (!data || !ldb);\n\n\tvb = kmalloc (sizeof (*vb), GFP_KERNEL);\n\tif (!vb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tif (!ldm_parse_vblk (data, len, vb)) {\n\t\tkfree(vb);\n\t\treturn false;\t\t\t/* Already logged */\n\t}\n\n\t/* Put vblk into the correct list. */\n\tswitch (vb->type) {\n\tcase VBLK_DGR3:\n\tcase VBLK_DGR4:\n\t\tlist_add (&vb->list, &ldb->v_dgrp);\n\t\tbreak;\n\tcase VBLK_DSK3:\n\tcase VBLK_DSK4:\n\t\tlist_add (&vb->list, &ldb->v_disk);\n\t\tbreak;\n\tcase VBLK_VOL5:\n\t\tlist_add (&vb->list, &ldb->v_volu);\n\t\tbreak;\n\tcase VBLK_CMP3:\n\t\tlist_add (&vb->list, &ldb->v_comp);\n\t\tbreak;\n\tcase VBLK_PRT3:\n\t\t/* Sort by the partition's start sector. */\n\t\tlist_for_each (item, &ldb->v_part) {\n\t\t\tstruct vblk *v = list_entry (item, struct vblk, list);\n\t\t\tif ((v->vblk.part.disk_id == vb->vblk.part.disk_id) &&\n\t\t\t    (v->vblk.part.start > vb->vblk.part.start)) {\n\t\t\t\tlist_add_tail (&vb->list, &v->list);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail (&vb->list, &ldb->v_part);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n/**\n * ldm_frag_add - Add a VBLK fragment to a list\n * @data:   Raw fragment to be added to the list\n * @size:   Size of the raw fragment\n * @frags:  Linked list of VBLK fragments\n *\n * Fragmented VBLKs may not be consecutive in the database, so they are placed\n * in a list so they can be pieced together later.\n *\n * Return:  'true'   Success, the VBLK was added to the list\n *          'false'  Error, a problem occurred\n */\nstatic bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\n\tBUG_ON (!data || !frags);\n\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t/* Mark the group as broken */\n\t\treturn false;\n\t}\n\n\tf->map |= (1 << rec);\n\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\n\treturn true;\n}\n\n/**\n * ldm_frag_free - Free a linked list of VBLK fragments\n * @list:  Linked list of fragments\n *\n * Free a linked list of VBLK fragments\n *\n * Return:  none\n */\nstatic void ldm_frag_free (struct list_head *list)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!list);\n\n\tlist_for_each_safe (item, tmp, list)\n\t\tkfree (list_entry (item, struct frag, list));\n}\n\n/**\n * ldm_frag_commit - Validate fragmented VBLKs and add them to the database\n * @frags:  Linked list of VBLK fragments\n * @ldb:    Cache of the database structures\n *\n * Now that all the fragmented VBLKs have been collected, they must be added to\n * the database for later use.\n *\n * Return:  'true'   All the fragments we added successfully\n *          'false'  One or more of the fragments we invalid\n */\nstatic bool ldm_frag_commit (struct list_head *frags, struct ldmdb *ldb)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\n\tBUG_ON (!frags || !ldb);\n\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\n\t\tif (f->map != 0xFF) {\n\t\t\tldm_error (\"VBLK group %d is incomplete (0x%02x).\",\n\t\t\t\tf->group, f->map);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!ldm_ldmdb_add (f->data, f->num*ldb->vm.vblk_size, ldb))\n\t\t\treturn false;\t\t/* Already logged */\n\t}\n\treturn true;\n}\n\n/**\n * ldm_get_vblks - Read the on-disk database of VBLKs into memory\n * @state: Partition check state including device holding the LDM Database\n * @base:  Offset, into @state->bdev, of the database\n * @ldb:   Cache of the database structures\n *\n * To use the information from the VBLKs, they need to be read from the disk,\n * unpacked and validated.  We cache them in @ldb according to their type.\n *\n * Return:  'true'   All the VBLKs were read successfully\n *          'false'  An error occurred\n */\nstatic bool ldm_get_vblks(struct parsed_partitions *state, unsigned long base,\n\t\t\t  struct ldmdb *ldb)\n{\n\tint size, perbuf, skip, finish, s, v, recs;\n\tu8 *data = NULL;\n\tSector sect;\n\tbool result = false;\n\tLIST_HEAD (frags);\n\n\tBUG_ON(!state || !ldb);\n\n\tsize   = ldb->vm.vblk_size;\n\tperbuf = 512 / size;\n\tskip   = ldb->vm.vblk_offset >> 9;\t\t/* Bytes to sectors */\n\tfinish = (size * ldb->vm.last_vblk_seq) >> 9;\n\n\tfor (s = skip; s < finish; s++) {\t\t/* For each sector */\n\t\tdata = read_part_sector(state, base + OFF_VMDB + s, &sect);\n\t\tif (!data) {\n\t\t\tldm_crit (\"Disk read failed.\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (v = 0; v < perbuf; v++, data+=size) {  /* For each vblk */\n\t\t\tif (MAGIC_VBLK != get_unaligned_be32(data)) {\n\t\t\t\tldm_error (\"Expected to find a VBLK.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trecs = get_unaligned_be16(data + 0x0E);\t/* Number of records */\n\t\t\tif (recs == 1) {\n\t\t\t\tif (!ldm_ldmdb_add (data, size, ldb))\n\t\t\t\t\tgoto out;\t/* Already logged */\n\t\t\t} else if (recs > 1) {\n\t\t\t\tif (!ldm_frag_add (data, size, &frags))\n\t\t\t\t\tgoto out;\t/* Already logged */\n\t\t\t}\n\t\t\t/* else Record is not in use, ignore it. */\n\t\t}\n\t\tput_dev_sector (sect);\n\t\tdata = NULL;\n\t}\n\n\tresult = ldm_frag_commit (&frags, ldb);\t/* Failures, already logged */\nout:\n\tif (data)\n\t\tput_dev_sector (sect);\n\tldm_frag_free (&frags);\n\n\treturn result;\n}\n\n/**\n * ldm_free_vblks - Free a linked list of vblk's\n * @lh:  Head of a linked list of struct vblk\n *\n * Free a list of vblk's and free the memory used to maintain the list.\n *\n * Return:  none\n */\nstatic void ldm_free_vblks (struct list_head *lh)\n{\n\tstruct list_head *item, *tmp;\n\n\tBUG_ON (!lh);\n\n\tlist_for_each_safe (item, tmp, lh)\n\t\tkfree (list_entry (item, struct vblk, list));\n}\n\n\n/**\n * ldm_partition - Find out whether a device is a dynamic disk and handle it\n * @state: Partition check state including device holding the LDM Database\n *\n * This determines whether the device @bdev is a dynamic disk and if so creates\n * the partitions necessary in the gendisk structure pointed to by @hd.\n *\n * We create a dummy device 1, which contains the LDM database, and then create\n * each partition described by the LDM database in sequence as devices 2+. For\n * example, if the device is hda, we would have: hda1: LDM database, hda2, hda3,\n * and so on: the actual data containing partitions.\n *\n * Return:  1 Success, @state->bdev is a dynamic disk and we handled it\n *          0 Success, @state->bdev is not a dynamic disk\n *         -1 An error occurred before enough information had been read\n *            Or @state->bdev is a dynamic disk, but it may be corrupted\n */\nint ldm_partition(struct parsed_partitions *state)\n{\n\tstruct ldmdb  *ldb;\n\tunsigned long base;\n\tint result = -1;\n\n\tBUG_ON(!state);\n\n\t/* Look for signs of a Dynamic Disk */\n\tif (!ldm_validate_partition_table(state))\n\t\treturn 0;\n\n\tldb = kmalloc (sizeof (*ldb), GFP_KERNEL);\n\tif (!ldb) {\n\t\tldm_crit (\"Out of memory.\");\n\t\tgoto out;\n\t}\n\n\t/* Parse and check privheads. */\n\tif (!ldm_validate_privheads(state, &ldb->ph))\n\t\tgoto out;\t\t/* Already logged */\n\n\t/* All further references are relative to base (database start). */\n\tbase = ldb->ph.config_start;\n\n\t/* Parse and check tocs and vmdb. */\n\tif (!ldm_validate_tocblocks(state, base, ldb) ||\n\t    !ldm_validate_vmdb(state, base, ldb))\n\t    \tgoto out;\t\t/* Already logged */\n\n\t/* Initialize vblk lists in ldmdb struct */\n\tINIT_LIST_HEAD (&ldb->v_dgrp);\n\tINIT_LIST_HEAD (&ldb->v_disk);\n\tINIT_LIST_HEAD (&ldb->v_volu);\n\tINIT_LIST_HEAD (&ldb->v_comp);\n\tINIT_LIST_HEAD (&ldb->v_part);\n\n\tif (!ldm_get_vblks(state, base, ldb)) {\n\t\tldm_crit (\"Failed to read the VBLKs from the database.\");\n\t\tgoto cleanup;\n\t}\n\n\t/* Finally, create the data partition devices. */\n\tif (ldm_create_data_partitions(state, ldb)) {\n\t\tldm_debug (\"Parsed LDM database successfully.\");\n\t\tresult = 1;\n\t}\n\t/* else Already logged */\n\ncleanup:\n\tldm_free_vblks (&ldb->v_dgrp);\n\tldm_free_vblks (&ldb->v_disk);\n\tldm_free_vblks (&ldb->v_volu);\n\tldm_free_vblks (&ldb->v_comp);\n\tldm_free_vblks (&ldb->v_part);\nout:\n\tkfree (ldb);\n\treturn result;\n}\n"], "filenames": ["fs/partitions/ldm.c"], "buggy_code_start_loc": [1337], "buggy_code_end_loc": [1337], "fixing_code_start_loc": [1338], "fixing_code_end_loc": [1343], "type": "CWE-119", "message": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table. NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017.", "other": {"cve": {"id": "CVE-2011-2182", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-13T10:24:54.390", "lastModified": "2023-02-13T01:19:35.287", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ldm_frag_add function in fs/partitions/ldm.c in the Linux kernel before 2.6.39.1 does not properly handle memory allocation for non-initial fragments, which might allow local users to conduct buffer overflow attacks, and gain privileges or obtain sensitive information, via a crafted LDM partition table. NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1017."}, {"lang": "es", "value": "La funci\u00f3n ldm_frag_add de fs/partitions/ldm.c del kernel de Linux en versiones anteriores a la 2.6.39.1 no maneja apropiadamente la reserva de memoria para fragmentos no iniciales, lo que permite a usuarios locales realizar ataques de desbordamiento de buffer y escalar privilegios u obtener informaci\u00f3n confidencial a trav\u00e9s de una tabla de particiones LDM.  NOTA: esta vulnerabilidad se debe a una soluci\u00f3n incompleta de CVE-2011-1017."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.39", "matchCriteriaId": "DA8EF989-5837-4B53-8242-AA7FDFEA5FD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc1:*:*:*:*:*:*", "matchCriteriaId": "2493C2FB-2BA1-4DB3-BC04-E282C9CD399D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc2:*:*:*:*:*:*", "matchCriteriaId": "18DBC8AF-18ED-4879-8888-23022E494D14"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc3:*:*:*:*:*:*", "matchCriteriaId": "75EB375B-8ADF-4EAB-A3FB-ED5D35E5E719"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc4:*:*:*:*:*:*", "matchCriteriaId": "D49BB231-622E-4F20-97C8-E6289933912C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc5:*:*:*:*:*:*", "matchCriteriaId": "2D6859AA-DA7F-4AF9-8443-05962171D6E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc6:*:*:*:*:*:*", "matchCriteriaId": "9B79A89D-F048-48C5-B148-4B38A6C3953B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.39:rc7:*:*:*:*:*:*", "matchCriteriaId": "BEBA9217-9105-4BA3-BE1E-FE387FECEF87"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39.1", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=cae13fe4cc3f24820ffb990c09110626837e85d4", "source": "secalert@redhat.com"}, {"url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/06/05/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.securityfocus.com/bid/52334", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cae13fe4cc3f24820ffb990c09110626837e85d4"}}