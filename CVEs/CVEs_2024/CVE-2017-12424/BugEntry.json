{"buggy_code": ["/*\n * Copyright (c) 1990 - 1994, Julianne Frances Haugh\n * Copyright (c) 1996 - 2001, Marek Micha\u0142kiewicz\n * Copyright (c) 2001 - 2006, Tomasz K\u0142oczko\n * Copyright (c) 2007 - 2011, Nicolas Fran\u00e7ois\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the copyright holders or contributors may not be used to\n *    endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#ident \"$Id$\"\n\n#include \"defines.h\"\n#include <assert.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <utime.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include \"nscd.h\"\n#ifdef WITH_TCB\n#include <tcb.h>\n#endif\t\t\t\t/* WITH_TCB */\n#include \"prototypes.h\"\n#include \"commonio.h\"\n\n/* local function prototypes */\nstatic int lrename (const char *, const char *);\nstatic int check_link_count (const char *file);\nstatic int do_lock_file (const char *file, const char *lock, bool log);\nstatic /*@null@*/ /*@dependent@*/FILE *fopen_set_perms (\n\tconst char *name,\n\tconst char *mode,\n\tconst struct stat *sb);\nstatic int create_backup (const char *, FILE *);\nstatic void free_linked_list (struct commonio_db *);\nstatic void add_one_entry (\n\tstruct commonio_db *db,\n\t/*@owned@*/struct commonio_entry *p);\nstatic bool name_is_nis (const char *name);\nstatic int write_all (const struct commonio_db *);\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *find_entry_by_name (\n\tstruct commonio_db *,\n\tconst char *);\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *next_entry_by_name (\n\tstruct commonio_db *,\n\t/*@null@*/struct commonio_entry *pos,\n\tconst char *);\n\nstatic int lock_count = 0;\nstatic bool nscd_need_reload = false;\n\n/*\n * Simple rename(P) alternative that attempts to rename to symlink\n * target.\n */\nint lrename (const char *old, const char *new)\n{\n\tint res;\n\tchar *r = NULL;\n\n#if defined(S_ISLNK)\n#ifndef __GLIBC__\n\tchar resolved_path[PATH_MAX];\n#endif\t\t\t\t/* !__GLIBC__ */\n\tstruct stat sb;\n\tif (lstat (new, &sb) == 0 && S_ISLNK (sb.st_mode)) {\n#ifdef __GLIBC__ /* now a POSIX.1-2008 feature */\n\t\tr = realpath (new, NULL);\n#else\t\t\t\t/* !__GLIBC__ */\n\t\tr = realpath (new, resolved_path);\n#endif\t\t\t\t/* !__GLIBC__ */\n\t\tif (NULL == r) {\n\t\t\tperror (\"realpath in lrename()\");\n\t\t} else {\n\t\t\tnew = r;\n\t\t}\n\t}\n#endif\t\t\t\t/* S_ISLNK */\n\n\tres = rename (old, new);\n\n#ifdef __GLIBC__\n\tif (NULL != r) {\n\t\tfree (r);\n\t}\n#endif\t\t\t\t/* __GLIBC__ */\n\n\treturn res;\n}\n\nstatic int check_link_count (const char *file)\n{\n\tstruct stat sb;\n\n\tif (stat (file, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\tif (sb.st_nlink != 2) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic int do_lock_file (const char *file, const char *lock, bool log)\n{\n\tint fd;\n\tpid_t pid;\n\tssize_t len;\n\tint retval;\n\tchar buf[32];\n\n\tfd = open (file, O_CREAT | O_EXCL | O_WRONLY, 0600);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpid = getpid ();\n\tsnprintf (buf, sizeof buf, \"%lu\", (unsigned long) pid);\n\tlen = (ssize_t) strlen (buf) + 1;\n\tif (write (fd, buf, (size_t) len) != len) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\t(void) close (fd);\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\tclose (fd);\n\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t\tunlink (file);\n\t\treturn retval;\n\t}\n\n\tfd = open (lock, O_RDWR);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tlen = read (fd, buf, sizeof (buf) - 1);\n\tclose (fd);\n\tif (len <= 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s without a PID\\n\",\n\t\t\t                Prog, lock);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tbuf[len] = '\\0';\n\tif (get_pid (buf, &pid) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s with an invalid PID '%s'\\n\",\n\t\t\t                Prog, lock, buf);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (kill (pid, 0) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: lock %s already used by PID %lu\\n\",\n\t\t\t                Prog, lock, (unsigned long) pid);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EEXIST;\n\t\treturn 0;\n\t}\n\tif (unlink (lock) != 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\n\tretval = 0;\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t} else {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t}\n\n\tunlink (file);\n\treturn retval;\n}\n\n\nstatic /*@null@*/ /*@dependent@*/FILE *fopen_set_perms (\n\tconst char *name,\n\tconst char *mode,\n\tconst struct stat *sb)\n{\n\tFILE *fp;\n\tmode_t mask;\n\n\tmask = umask (0777);\n\tfp = fopen (name, mode);\n\t(void) umask (mask);\n\tif (NULL == fp) {\n\t\treturn NULL;\n\t}\n\n#ifdef HAVE_FCHOWN\n\tif (fchown (fileno (fp), sb->st_uid, sb->st_gid) != 0) {\n\t\tgoto fail;\n\t}\n#else\t\t\t\t/* !HAVE_FCHOWN */\n\tif (chown (name, sb->st_mode) != 0) {\n\t\tgoto fail;\n\t}\n#endif\t\t\t\t/* !HAVE_FCHOWN */\n\n#ifdef HAVE_FCHMOD\n\tif (fchmod (fileno (fp), sb->st_mode & 0664) != 0) {\n\t\tgoto fail;\n\t}\n#else\t\t\t\t/* !HAVE_FCHMOD */\n\tif (chmod (name, sb->st_mode & 0664) != 0) {\n\t\tgoto fail;\n\t}\n#endif\t\t\t\t/* !HAVE_FCHMOD */\n\treturn fp;\n\n      fail:\n\t(void) fclose (fp);\n\t/* fopen_set_perms is used for intermediate files */\n\t(void) unlink (name);\n\treturn NULL;\n}\n\n\nstatic int create_backup (const char *backup, FILE * fp)\n{\n\tstruct stat sb;\n\tstruct utimbuf ub;\n\tFILE *bkfp;\n\tint c;\n\n\tif (fstat (fileno (fp), &sb) != 0) {\n\t\treturn -1;\n\t}\n\n\tbkfp = fopen_set_perms (backup, \"w\", &sb);\n\tif (NULL == bkfp) {\n\t\treturn -1;\n\t}\n\n\t/* TODO: faster copy, not one-char-at-a-time.  --marekm */\n\tc = 0;\n\tif (fseek (fp, 0, SEEK_SET) == 0) {\n\t\twhile ((c = getc (fp)) != EOF) {\n\t\t\tif (putc (c, bkfp) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((c != EOF) || (ferror (fp) != 0) || (fflush (bkfp) != 0)) {\n\t\t(void) fclose (bkfp);\n\t\t/* FIXME: unlink the backup file? */\n\t\treturn -1;\n\t}\n\tif (   (fsync (fileno (bkfp)) != 0)\n\t    || (fclose (bkfp) != 0)) {\n\t\t/* FIXME: unlink the backup file? */\n\t\treturn -1;\n\t}\n\n\tub.actime = sb.st_atime;\n\tub.modtime = sb.st_mtime;\n\t(void) utime (backup, &ub);\n\treturn 0;\n}\n\n\nstatic void free_linked_list (struct commonio_db *db)\n{\n\tstruct commonio_entry *p;\n\n\twhile (NULL != db->head) {\n\t\tp = db->head;\n\t\tdb->head = p->next;\n\n\t\tif (NULL != p->line) {\n\t\t\tfree (p->line);\n\t\t}\n\n\t\tif (NULL != p->eptr) {\n\t\t\tdb->ops->free (p->eptr);\n\t\t}\n\n\t\tfree (p);\n\t}\n\tdb->tail = NULL;\n}\n\n\nint commonio_setname (struct commonio_db *db, const char *name)\n{\n\tsnprintf (db->filename, sizeof (db->filename), \"%s\", name);\n\treturn 1;\n}\n\n\nbool commonio_present (const struct commonio_db *db)\n{\n\treturn (access (db->filename, F_OK) == 0);\n}\n\n\nint commonio_lock_nowait (struct commonio_db *db, bool log)\n{\n\tchar file[1024];\n\tchar lock[1024];\n\n\tif (db->locked) {\n\t\treturn 1;\n\t}\n\n\tsnprintf (file, sizeof file, \"%s.%lu\",\n\t          db->filename, (unsigned long) getpid ());\n\tsnprintf (lock, sizeof lock, \"%s.lock\", db->filename);\n\tif (do_lock_file (file, lock, log) != 0) {\n\t\tdb->locked = true;\n\t\tlock_count++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nint commonio_lock (struct commonio_db *db)\n{\n#ifdef HAVE_LCKPWDF\n\t/*\n\t * only if the system libc has a real lckpwdf() - the one from\n\t * lockpw.c calls us and would cause infinite recursion!\n\t */\n\n\t/*\n\t * Call lckpwdf() on the first lock.\n\t * If it succeeds, call *_lock() only once\n\t * (no retries, it should always succeed).\n\t */\n\tif (0 == lock_count) {\n\t\tif (lckpwdf () == -1) {\n\t\t\tif (geteuid () != 0) {\n\t\t\t\t(void) fprintf (stderr,\n\t\t\t\t                \"%s: Permission denied.\\n\",\n\t\t\t\t                Prog);\n\t\t\t}\n\t\t\treturn 0;\t/* failure */\n\t\t}\n\t}\n\n\tif (commonio_lock_nowait (db, true) != 0) {\n\t\treturn 1;\t/* success */\n\t}\n\n\tulckpwdf ();\n\treturn 0;\t\t/* failure */\n#else\t\t\t\t/* !HAVE_LCKPWDF */\n\tint i;\n\n\t/*\n\t * lckpwdf() not used - do it the old way.\n\t */\n#ifndef LOCK_TRIES\n#define LOCK_TRIES 15\n#endif\n\n#ifndef LOCK_SLEEP\n#define LOCK_SLEEP 1\n#endif\n\tfor (i = 0; i < LOCK_TRIES; i++) {\n\t\tif (i > 0) {\n\t\t\tsleep (LOCK_SLEEP);\t/* delay between retries */\n\t\t}\n\t\tif (commonio_lock_nowait (db, i==LOCK_TRIES-1) != 0) {\n\t\t\treturn 1;\t/* success */\n\t\t}\n\t\t/* no unnecessary retries on \"permission denied\" errors */\n\t\tif (geteuid () != 0) {\n\t\t\t(void) fprintf (stderr, \"%s: Permission denied.\\n\",\n\t\t\t                Prog);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\t\t/* failure */\n#endif\t\t\t\t/* !HAVE_LCKPWDF */\n}\n\nstatic void dec_lock_count (void)\n{\n\tif (lock_count > 0) {\n\t\tlock_count--;\n\t\tif (lock_count == 0) {\n\t\t\t/* Tell nscd when lock count goes to zero,\n\t\t\t   if any of the files were changed.  */\n\t\t\tif (nscd_need_reload) {\n\t\t\t\tnscd_flush_cache (\"passwd\");\n\t\t\t\tnscd_flush_cache (\"group\");\n\t\t\t\tnscd_need_reload = false;\n\t\t\t}\n#ifdef HAVE_LCKPWDF\n\t\t\tulckpwdf ();\n#endif\t\t\t\t/* HAVE_LCKPWDF */\n\t\t}\n\t}\n}\n\n\nint commonio_unlock (struct commonio_db *db)\n{\n\tchar lock[1024];\n\n\tif (db->isopen) {\n\t\tdb->readonly = true;\n\t\tif (commonio_close (db) == 0) {\n\t\t\tif (db->locked) {\n\t\t\t\tdec_lock_count ();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db->locked) {\n\t\t/*\n\t\t * Unlock in reverse order: remove the lock file,\n\t\t * then call ulckpwdf() (if used) on last unlock.\n\t\t */\n\t\tdb->locked = false;\n\t\tsnprintf (lock, sizeof lock, \"%s.lock\", db->filename);\n\t\tunlink (lock);\n\t\tdec_lock_count ();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n/*\n * Add an entry at the end.\n *\n * defines p->next, p->prev\n * (unfortunately, owned special are not supported)\n */\nstatic void add_one_entry (struct commonio_db *db,\n                           /*@owned@*/struct commonio_entry *p)\n{\n\t/*@-mustfreeonly@*/\n\tp->next = NULL;\n\tp->prev = db->tail;\n\t/*@=mustfreeonly@*/\n\tif (NULL == db->head) {\n\t\tdb->head = p;\n\t}\n\tif (NULL != db->tail) {\n\t\tdb->tail->next = p;\n\t}\n\tdb->tail = p;\n}\n\n\nstatic bool name_is_nis (const char *name)\n{\n\treturn (('+' == name[0]) || ('-' == name[0]));\n}\n\n\n/*\n * New entries are inserted before the first NIS entry.  Order is preserved\n * when db is written out.\n */\n#ifndef KEEP_NIS_AT_END\n#define KEEP_NIS_AT_END 1\n#endif\n\n#if KEEP_NIS_AT_END\nstatic void add_one_entry_nis (struct commonio_db *db,\n                               /*@owned@*/struct commonio_entry *newp);\n\n/*\n * Insert an entry between the regular entries, and the NIS entries.\n *\n * defines newp->next, newp->prev\n * (unfortunately, owned special are not supported)\n */\nstatic void add_one_entry_nis (struct commonio_db *db,\n                               /*@owned@*/struct commonio_entry *newp)\n{\n\tstruct commonio_entry *p;\n\n\tfor (p = db->head; NULL != p; p = p->next) {\n\t\tif (name_is_nis (p->eptr ? db->ops->getname (p->eptr)\n\t\t                         : p->line)) {\n\t\t\t/*@-mustfreeonly@*/\n\t\t\tnewp->next = p;\n\t\t\tnewp->prev = p->prev;\n\t\t\t/*@=mustfreeonly@*/\n\t\t\tif (NULL != p->prev) {\n\t\t\t\tp->prev->next = newp;\n\t\t\t} else {\n\t\t\t\tdb->head = newp;\n\t\t\t}\n\t\t\tp->prev = newp;\n\t\t\treturn;\n\t\t}\n\t}\n\tadd_one_entry (db, newp);\n}\n#endif\t\t\t\t/* KEEP_NIS_AT_END */\n\n/* Initial buffer size, as well as increment if not sufficient\n   (for reading very long lines in group files).  */\n#define BUFLEN 4096\n\nint commonio_open (struct commonio_db *db, int mode)\n{\n\tchar *buf;\n\tchar *cp;\n\tchar *line;\n\tstruct commonio_entry *p;\n\tvoid *eptr = NULL;\n\tint flags = mode;\n\tsize_t buflen;\n\tint fd;\n\tint saved_errno;\n\n\tmode &= ~O_CREAT;\n\n\tif (   db->isopen\n\t    || (   (O_RDONLY != mode)\n\t        && (O_RDWR != mode))) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->readonly = (mode == O_RDONLY);\n\tif (!db->readonly && !db->locked) {\n\t\terrno = EACCES;\n\t\treturn 0;\n\t}\n\n\tdb->head = NULL;\n\tdb->tail = NULL;\n\tdb->cursor = NULL;\n\tdb->changed = false;\n\n\tfd = open (db->filename,\n\t             (db->readonly ? O_RDONLY : O_RDWR)\n\t           | O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);\n\tsaved_errno = errno;\n\tdb->fp = NULL;\n\tif (fd >= 0) {\n#ifdef WITH_TCB\n\t\tif (tcb_is_suspect (fd) != 0) {\n\t\t\t(void) close (fd);\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n#endif\t\t\t\t/* WITH_TCB */\n\t\tdb->fp = fdopen (fd, db->readonly ? \"r\" : \"r+\");\n\t\tsaved_errno = errno;\n\t\tif (NULL == db->fp) {\n\t\t\t(void) close (fd);\n\t\t}\n\t}\n\terrno = saved_errno;\n\n\t/*\n\t * If O_CREAT was specified and the file didn't exist, it will be\n\t * created by commonio_close().  We have no entries to read yet.  --marekm\n\t */\n\tif (NULL == db->fp) {\n\t\tif (((flags & O_CREAT) != 0) && (ENOENT == errno)) {\n\t\t\tdb->isopen = true;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Do not inherit fd in spawned processes (e.g. nscd) */\n\tfcntl (fileno (db->fp), F_SETFD, FD_CLOEXEC);\n\n\tbuflen = BUFLEN;\n\tbuf = (char *) malloc (buflen);\n\tif (NULL == buf) {\n\t\tgoto cleanup_ENOMEM;\n\t}\n\n\twhile (db->ops->fgets (buf, (int) buflen, db->fp) == buf) {\n\t\twhile (   ((cp = strrchr (buf, '\\n')) == NULL)\n\t\t       && (feof (db->fp) == 0)) {\n\t\t\tsize_t len;\n\n\t\t\tbuflen += BUFLEN;\n\t\t\tcp = (char *) realloc (buf, buflen);\n\t\t\tif (NULL == cp) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t\tbuf = cp;\n\t\t\tlen = strlen (buf);\n\t\t\tif (db->ops->fgets (buf + len,\n\t\t\t                    (int) (buflen - len),\n\t\t\t                    db->fp) == NULL) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t}\n\t\tcp = strrchr (buf, '\\n');\n\t\tif (NULL != cp) {\n\t\t\t*cp = '\\0';\n\t\t}\n\n\t\tline = strdup (buf);\n\t\tif (NULL == line) {\n\t\t\tgoto cleanup_buf;\n\t\t}\n\n\t\tif (name_is_nis (line)) {\n\t\t\teptr = NULL;\n\t\t} else {\n\t\t\teptr = db->ops->parse (line);\n\t\t\tif (NULL != eptr) {\n\t\t\t\teptr = db->ops->dup (eptr);\n\t\t\t\tif (NULL == eptr) {\n\t\t\t\t\tgoto cleanup_line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = (struct commonio_entry *) malloc (sizeof *p);\n\t\tif (NULL == p) {\n\t\t\tgoto cleanup_entry;\n\t\t}\n\n\t\tp->eptr = eptr;\n\t\tp->line = line;\n\t\tp->changed = false;\n\n\t\tadd_one_entry (db, p);\n\t}\n\n\tfree (buf);\n\n\tif (ferror (db->fp) != 0) {\n\t\tgoto cleanup_errno;\n\t}\n\n\tif ((NULL != db->ops->open_hook) && (db->ops->open_hook () == 0)) {\n\t\tgoto cleanup_errno;\n\t}\n\n\tdb->isopen = true;\n\treturn 1;\n\n      cleanup_entry:\n\tif (NULL != eptr) {\n\t\tdb->ops->free (eptr);\n\t}\n      cleanup_line:\n\tfree (line);\n      cleanup_buf:\n\tfree (buf);\n      cleanup_ENOMEM:\n\terrno = ENOMEM;\n      cleanup_errno:\n\tsaved_errno = errno;\n\tfree_linked_list (db);\n\tfclose (db->fp);\n\tdb->fp = NULL;\n\terrno = saved_errno;\n\treturn 0;\n}\n\n/*\n * Sort given db according to cmp function (usually compares uids)\n */\nint\ncommonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && (NULL != ptr->line)\n\t     && (   ('+' != ptr->line[0])\n\t         && ('-' != ptr->line[0]))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif ((NULL != ptr) && (NULL != ptr->line)) {\n\t\tnis = ptr;\n\t}\n#endif\n\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n/*@ -nullderef @*/\n\t     ptr = ptr->next\n/*@ +nullderef @*/\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\n\t/* Take care of the head and tail separately */\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\n\t/* Now other elements have prev and next entries */\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\n\tfree (entries);\n\tdb->changed = true;\n\n\treturn 0;\n}\n\n/*\n * Sort entries in db according to order in another.\n */\nint commonio_sort_wrt (struct commonio_db *shadow,\n                       const struct commonio_db *passwd)\n{\n\tstruct commonio_entry *head = NULL, *pw_ptr, *spw_ptr;\n\tconst char *name;\n\n\tif ((NULL == shadow) || (NULL == shadow->head)) {\n\t\treturn 0;\n\t}\n\n\tfor (pw_ptr = passwd->head; NULL != pw_ptr; pw_ptr = pw_ptr->next) {\n\t\tif (NULL == pw_ptr->eptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = passwd->ops->getname (pw_ptr->eptr);\n\t\tfor (spw_ptr = shadow->head;\n\t\t     NULL != spw_ptr;\n\t\t     spw_ptr = spw_ptr->next) {\n\t\t\tif (NULL == spw_ptr->eptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp (name, shadow->ops->getname (spw_ptr->eptr))\n\t\t\t    == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (NULL == spw_ptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tcommonio_del_entry (shadow, spw_ptr);\n\t\tspw_ptr->next = head;\n\t\thead = spw_ptr;\n\t}\n\n\tfor (spw_ptr = head; NULL != spw_ptr; spw_ptr = head) {\n\t\thead = head->next;\n\n\t\tif (NULL != shadow->head) {\n\t\t\tshadow->head->prev = spw_ptr;\n\t\t}\n\t\tspw_ptr->next = shadow->head;\n\t\tshadow->head = spw_ptr;\n\t}\n\n\tshadow->head->prev = NULL;\n\tshadow->changed = true;\n\n\treturn 0;\n}\n\n/*\n * write_all - Write the database to its file.\n *\n * It returns 0 if all the entries could be written correctly.\n */\nstatic int write_all (const struct commonio_db *db)\n\t/*@requires notnull db->fp@*/\n{\n\tconst struct commonio_entry *p;\n\tvoid *eptr;\n\n\tfor (p = db->head; NULL != p; p = p->next) {\n\t\tif (p->changed) {\n\t\t\teptr = p->eptr;\n\t\t\tassert (NULL != eptr);\n\t\t\tif (db->ops->put (eptr, db->fp) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (NULL != p->line) {\n\t\t\tif (db->ops->fputs (p->line, db->fp) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (putc ('\\n', db->fp) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint commonio_close (struct commonio_db *db)\n\t/*@requires notnull db->fp@*/\n{\n\tchar buf[1024];\n\tint errors = 0;\n\tstruct stat sb;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->isopen = false;\n\n\tif (!db->changed || db->readonly) {\n\t\t(void) fclose (db->fp);\n\t\tdb->fp = NULL;\n\t\tgoto success;\n\t}\n\n\tif ((NULL != db->ops->close_hook) && (db->ops->close_hook () == 0)) {\n\t\tgoto fail;\n\t}\n\n\tmemzero (&sb, sizeof sb);\n\tif (NULL != db->fp) {\n\t\tif (fstat (fileno (db->fp), &sb) != 0) {\n\t\t\t(void) fclose (db->fp);\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Create backup file.\n\t\t */\n\t\tsnprintf (buf, sizeof buf, \"%s-\", db->filename);\n\n#ifdef WITH_SELINUX\n\t\tif (set_selinux_file_context (buf) != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (create_backup (buf, db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n\n\t\tif (fclose (db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n\n#ifdef WITH_SELINUX\n\t\tif (reset_selinux_file_context () != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (errors != 0) {\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default permissions for new [g]shadow files.\n\t\t */\n\t\tsb.st_mode = db->st_mode;\n\t\tsb.st_uid = db->st_uid;\n\t\tsb.st_gid = db->st_gid;\n\t}\n\n\tsnprintf (buf, sizeof buf, \"%s+\", db->filename);\n\n#ifdef WITH_SELINUX\n\tif (set_selinux_file_context (buf) != 0) {\n\t\terrors++;\n\t}\n#endif\n\n\tdb->fp = fopen_set_perms (buf, \"w\", &sb);\n\tif (NULL == db->fp) {\n\t\tgoto fail;\n\t}\n\n\tif (write_all (db) != 0) {\n\t\terrors++;\n\t}\n\n\tif (fflush (db->fp) != 0) {\n\t\terrors++;\n\t}\n#ifdef HAVE_FSYNC\n\tif (fsync (fileno (db->fp)) != 0) {\n\t\terrors++;\n\t}\n#else\t\t\t\t/* !HAVE_FSYNC */\n\tsync ();\n#endif\t\t\t\t/* !HAVE_FSYNC */\n\tif (fclose (db->fp) != 0) {\n\t\terrors++;\n\t}\n\n\tdb->fp = NULL;\n\n\tif (errors != 0) {\n\t\tunlink (buf);\n\t\tgoto fail;\n\t}\n\n\tif (lrename (buf, db->filename) != 0) {\n\t\tgoto fail;\n\t}\n\n#ifdef WITH_SELINUX\n\tif (reset_selinux_file_context () != 0) {\n\t\tgoto fail;\n\t}\n#endif\n\n\tnscd_need_reload = true;\n\tgoto success;\n      fail:\n\terrors++;\n      success:\n\n\tfree_linked_list (db);\n\treturn errors == 0;\n}\n\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *next_entry_by_name (\n\tstruct commonio_db *db,\n\t/*@null@*/struct commonio_entry *pos,\n\tconst char *name)\n{\n\tstruct commonio_entry *p;\n\tvoid *ep;\n\n\tif (NULL == pos) {\n\t\treturn NULL;\n\t}\n\n\tfor (p = pos; NULL != p; p = p->next) {\n\t\tep = p->eptr;\n\t\tif (   (NULL != ep)\n\t\t    && (strcmp (db->ops->getname (ep), name) == 0)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *find_entry_by_name (\n\tstruct commonio_db *db,\n\tconst char *name)\n{\n\treturn next_entry_by_name (db, db->head, name);\n}\n\n\nint commonio_update (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp = find_entry_by_name (db, db->ops->getname (eptr));\n\tif (NULL != p) {\n\t\tif (next_entry_by_name (db, p->next, db->ops->getname (eptr)) != NULL) {\n\t\t\tfprintf (stderr, _(\"Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\\n\"), db->ops->getname (eptr), db->filename);\n\t\t\tdb->ops->free (nentry);\n\t\t\treturn 0;\n\t\t}\n\t\tdb->ops->free (p->eptr);\n\t\tp->eptr = nentry;\n\t\tp->changed = true;\n\t\tdb->cursor = p;\n\n\t\tdb->changed = true;\n\t\treturn 1;\n\t}\n\t/* not found, new entry */\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n\n#if KEEP_NIS_AT_END\n\tadd_one_entry_nis (db, p);\n#else\t\t\t\t/* !KEEP_NIS_AT_END */\n\tadd_one_entry (db, p);\n#endif\t\t\t\t/* !KEEP_NIS_AT_END */\n\n\tdb->changed = true;\n\treturn 1;\n}\n\n#ifdef ENABLE_SUBIDS\nint commonio_append (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\t/* new entry */\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n\tadd_one_entry (db, p);\n\n\tdb->changed = true;\n\treturn 1;\n}\n#endif\t\t\t\t/* ENABLE_SUBIDS */\n\nvoid commonio_del_entry (struct commonio_db *db, const struct commonio_entry *p)\n{\n\tif (p == db->cursor) {\n\t\tdb->cursor = p->next;\n\t}\n\n\tif (NULL != p->prev) {\n\t\tp->prev->next = p->next;\n\t} else {\n\t\tdb->head = p->next;\n\t}\n\n\tif (NULL != p->next) {\n\t\tp->next->prev = p->prev;\n\t} else {\n\t\tdb->tail = p->prev;\n\t}\n\n\tdb->changed = true;\n}\n\n/*\n * commonio_remove - Remove the entry of the given name from the database.\n */\nint commonio_remove (struct commonio_db *db, const char *name)\n{\n\tstruct commonio_entry *p;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tp = find_entry_by_name (db, name);\n\tif (NULL == p) {\n\t\terrno = ENOENT;\n\t\treturn 0;\n\t}\n\tif (next_entry_by_name (db, p->next, name) != NULL) {\n\t\tfprintf (stderr, _(\"Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\\n\"), name, db->filename);\n\t\treturn 0;\n\t}\n\n\tcommonio_del_entry (db, p);\n\n\tif (NULL != p->line) {\n\t\tfree (p->line);\n\t}\n\n\tif (NULL != p->eptr) {\n\t\tdb->ops->free (p->eptr);\n\t}\n\n\treturn 1;\n}\n\n/*\n * commonio_locate - Find the first entry with the specified name in\n *                   the database.\n *\n *\tIf found, it returns the entry and set the cursor of the database to\n *\tthat entry.\n *\n *\tOtherwise, it returns NULL.\n */\n/*@observer@*/ /*@null@*/const void *commonio_locate (struct commonio_db *db, const char *name)\n{\n\tstruct commonio_entry *p;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tp = find_entry_by_name (db, name);\n\tif (NULL == p) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\tdb->cursor = p;\n\treturn p->eptr;\n}\n\n/*\n * commonio_rewind - Restore the database cursor to the first entry.\n *\n * It returns 0 on error, 1 on success.\n */\nint commonio_rewind (struct commonio_db *db)\n{\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->cursor = NULL;\n\treturn 1;\n}\n\n/*\n * commonio_next - Return the next entry of the specified database\n *\n * It returns the next entry, or NULL if no other entries could be found.\n */\n/*@observer@*/ /*@null@*/const void *commonio_next (struct commonio_db *db)\n{\n\tvoid *eptr;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (NULL == db->cursor) {\n\t\tdb->cursor = db->head;\n\t} else {\n\t\tdb->cursor = db->cursor->next;\n\t}\n\n\twhile (NULL != db->cursor) {\n\t\teptr = db->cursor->eptr;\n\t\tif (NULL != eptr) {\n\t\t\treturn eptr;\n\t\t}\n\n\t\tdb->cursor = db->cursor->next;\n\t}\n\treturn NULL;\n}\n\n"], "fixing_code": ["/*\n * Copyright (c) 1990 - 1994, Julianne Frances Haugh\n * Copyright (c) 1996 - 2001, Marek Micha\u0142kiewicz\n * Copyright (c) 2001 - 2006, Tomasz K\u0142oczko\n * Copyright (c) 2007 - 2011, Nicolas Fran\u00e7ois\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the copyright holders or contributors may not be used to\n *    endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT\n * HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <config.h>\n\n#ident \"$Id$\"\n\n#include \"defines.h\"\n#include <assert.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <utime.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdio.h>\n#include <signal.h>\n#include \"nscd.h\"\n#ifdef WITH_TCB\n#include <tcb.h>\n#endif\t\t\t\t/* WITH_TCB */\n#include \"prototypes.h\"\n#include \"commonio.h\"\n\n/* local function prototypes */\nstatic int lrename (const char *, const char *);\nstatic int check_link_count (const char *file);\nstatic int do_lock_file (const char *file, const char *lock, bool log);\nstatic /*@null@*/ /*@dependent@*/FILE *fopen_set_perms (\n\tconst char *name,\n\tconst char *mode,\n\tconst struct stat *sb);\nstatic int create_backup (const char *, FILE *);\nstatic void free_linked_list (struct commonio_db *);\nstatic void add_one_entry (\n\tstruct commonio_db *db,\n\t/*@owned@*/struct commonio_entry *p);\nstatic bool name_is_nis (const char *name);\nstatic int write_all (const struct commonio_db *);\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *find_entry_by_name (\n\tstruct commonio_db *,\n\tconst char *);\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *next_entry_by_name (\n\tstruct commonio_db *,\n\t/*@null@*/struct commonio_entry *pos,\n\tconst char *);\n\nstatic int lock_count = 0;\nstatic bool nscd_need_reload = false;\n\n/*\n * Simple rename(P) alternative that attempts to rename to symlink\n * target.\n */\nint lrename (const char *old, const char *new)\n{\n\tint res;\n\tchar *r = NULL;\n\n#if defined(S_ISLNK)\n#ifndef __GLIBC__\n\tchar resolved_path[PATH_MAX];\n#endif\t\t\t\t/* !__GLIBC__ */\n\tstruct stat sb;\n\tif (lstat (new, &sb) == 0 && S_ISLNK (sb.st_mode)) {\n#ifdef __GLIBC__ /* now a POSIX.1-2008 feature */\n\t\tr = realpath (new, NULL);\n#else\t\t\t\t/* !__GLIBC__ */\n\t\tr = realpath (new, resolved_path);\n#endif\t\t\t\t/* !__GLIBC__ */\n\t\tif (NULL == r) {\n\t\t\tperror (\"realpath in lrename()\");\n\t\t} else {\n\t\t\tnew = r;\n\t\t}\n\t}\n#endif\t\t\t\t/* S_ISLNK */\n\n\tres = rename (old, new);\n\n#ifdef __GLIBC__\n\tif (NULL != r) {\n\t\tfree (r);\n\t}\n#endif\t\t\t\t/* __GLIBC__ */\n\n\treturn res;\n}\n\nstatic int check_link_count (const char *file)\n{\n\tstruct stat sb;\n\n\tif (stat (file, &sb) != 0) {\n\t\treturn 0;\n\t}\n\n\tif (sb.st_nlink != 2) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic int do_lock_file (const char *file, const char *lock, bool log)\n{\n\tint fd;\n\tpid_t pid;\n\tssize_t len;\n\tint retval;\n\tchar buf[32];\n\n\tfd = open (file, O_CREAT | O_EXCL | O_WRONLY, 0600);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpid = getpid ();\n\tsnprintf (buf, sizeof buf, \"%lu\", (unsigned long) pid);\n\tlen = (ssize_t) strlen (buf) + 1;\n\tif (write (fd, buf, (size_t) len) != len) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, file, strerror (errno));\n\t\t}\n\t\t(void) close (fd);\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\tclose (fd);\n\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t\tunlink (file);\n\t\treturn retval;\n\t}\n\n\tfd = open (lock, O_RDWR);\n\tif (-1 == fd) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tlen = read (fd, buf, sizeof (buf) - 1);\n\tclose (fd);\n\tif (len <= 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s without a PID\\n\",\n\t\t\t                Prog, lock);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tbuf[len] = '\\0';\n\tif (get_pid (buf, &pid) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: existing lock file %s with an invalid PID '%s'\\n\",\n\t\t\t                Prog, lock, buf);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (kill (pid, 0) == 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: lock %s already used by PID %lu\\n\",\n\t\t\t                Prog, lock, (unsigned long) pid);\n\t\t}\n\t\tunlink (file);\n\t\terrno = EEXIST;\n\t\treturn 0;\n\t}\n\tif (unlink (lock) != 0) {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t\tunlink (file);\n\t\treturn 0;\n\t}\n\n\tretval = 0;\n\tif (link (file, lock) == 0) {\n\t\tretval = check_link_count (file);\n\t\tif ((0==retval) && log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: %s: lock file already used\\n\",\n\t\t\t                Prog, file);\n\t\t}\n\t} else {\n\t\tif (log) {\n\t\t\t(void) fprintf (stderr,\n\t\t\t                \"%s: cannot get lock %s: %s\\n\",\n\t\t\t                Prog, lock, strerror (errno));\n\t\t}\n\t}\n\n\tunlink (file);\n\treturn retval;\n}\n\n\nstatic /*@null@*/ /*@dependent@*/FILE *fopen_set_perms (\n\tconst char *name,\n\tconst char *mode,\n\tconst struct stat *sb)\n{\n\tFILE *fp;\n\tmode_t mask;\n\n\tmask = umask (0777);\n\tfp = fopen (name, mode);\n\t(void) umask (mask);\n\tif (NULL == fp) {\n\t\treturn NULL;\n\t}\n\n#ifdef HAVE_FCHOWN\n\tif (fchown (fileno (fp), sb->st_uid, sb->st_gid) != 0) {\n\t\tgoto fail;\n\t}\n#else\t\t\t\t/* !HAVE_FCHOWN */\n\tif (chown (name, sb->st_mode) != 0) {\n\t\tgoto fail;\n\t}\n#endif\t\t\t\t/* !HAVE_FCHOWN */\n\n#ifdef HAVE_FCHMOD\n\tif (fchmod (fileno (fp), sb->st_mode & 0664) != 0) {\n\t\tgoto fail;\n\t}\n#else\t\t\t\t/* !HAVE_FCHMOD */\n\tif (chmod (name, sb->st_mode & 0664) != 0) {\n\t\tgoto fail;\n\t}\n#endif\t\t\t\t/* !HAVE_FCHMOD */\n\treturn fp;\n\n      fail:\n\t(void) fclose (fp);\n\t/* fopen_set_perms is used for intermediate files */\n\t(void) unlink (name);\n\treturn NULL;\n}\n\n\nstatic int create_backup (const char *backup, FILE * fp)\n{\n\tstruct stat sb;\n\tstruct utimbuf ub;\n\tFILE *bkfp;\n\tint c;\n\n\tif (fstat (fileno (fp), &sb) != 0) {\n\t\treturn -1;\n\t}\n\n\tbkfp = fopen_set_perms (backup, \"w\", &sb);\n\tif (NULL == bkfp) {\n\t\treturn -1;\n\t}\n\n\t/* TODO: faster copy, not one-char-at-a-time.  --marekm */\n\tc = 0;\n\tif (fseek (fp, 0, SEEK_SET) == 0) {\n\t\twhile ((c = getc (fp)) != EOF) {\n\t\t\tif (putc (c, bkfp) == EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((c != EOF) || (ferror (fp) != 0) || (fflush (bkfp) != 0)) {\n\t\t(void) fclose (bkfp);\n\t\t/* FIXME: unlink the backup file? */\n\t\treturn -1;\n\t}\n\tif (   (fsync (fileno (bkfp)) != 0)\n\t    || (fclose (bkfp) != 0)) {\n\t\t/* FIXME: unlink the backup file? */\n\t\treturn -1;\n\t}\n\n\tub.actime = sb.st_atime;\n\tub.modtime = sb.st_mtime;\n\t(void) utime (backup, &ub);\n\treturn 0;\n}\n\n\nstatic void free_linked_list (struct commonio_db *db)\n{\n\tstruct commonio_entry *p;\n\n\twhile (NULL != db->head) {\n\t\tp = db->head;\n\t\tdb->head = p->next;\n\n\t\tif (NULL != p->line) {\n\t\t\tfree (p->line);\n\t\t}\n\n\t\tif (NULL != p->eptr) {\n\t\t\tdb->ops->free (p->eptr);\n\t\t}\n\n\t\tfree (p);\n\t}\n\tdb->tail = NULL;\n}\n\n\nint commonio_setname (struct commonio_db *db, const char *name)\n{\n\tsnprintf (db->filename, sizeof (db->filename), \"%s\", name);\n\treturn 1;\n}\n\n\nbool commonio_present (const struct commonio_db *db)\n{\n\treturn (access (db->filename, F_OK) == 0);\n}\n\n\nint commonio_lock_nowait (struct commonio_db *db, bool log)\n{\n\tchar file[1024];\n\tchar lock[1024];\n\n\tif (db->locked) {\n\t\treturn 1;\n\t}\n\n\tsnprintf (file, sizeof file, \"%s.%lu\",\n\t          db->filename, (unsigned long) getpid ());\n\tsnprintf (lock, sizeof lock, \"%s.lock\", db->filename);\n\tif (do_lock_file (file, lock, log) != 0) {\n\t\tdb->locked = true;\n\t\tlock_count++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nint commonio_lock (struct commonio_db *db)\n{\n#ifdef HAVE_LCKPWDF\n\t/*\n\t * only if the system libc has a real lckpwdf() - the one from\n\t * lockpw.c calls us and would cause infinite recursion!\n\t */\n\n\t/*\n\t * Call lckpwdf() on the first lock.\n\t * If it succeeds, call *_lock() only once\n\t * (no retries, it should always succeed).\n\t */\n\tif (0 == lock_count) {\n\t\tif (lckpwdf () == -1) {\n\t\t\tif (geteuid () != 0) {\n\t\t\t\t(void) fprintf (stderr,\n\t\t\t\t                \"%s: Permission denied.\\n\",\n\t\t\t\t                Prog);\n\t\t\t}\n\t\t\treturn 0;\t/* failure */\n\t\t}\n\t}\n\n\tif (commonio_lock_nowait (db, true) != 0) {\n\t\treturn 1;\t/* success */\n\t}\n\n\tulckpwdf ();\n\treturn 0;\t\t/* failure */\n#else\t\t\t\t/* !HAVE_LCKPWDF */\n\tint i;\n\n\t/*\n\t * lckpwdf() not used - do it the old way.\n\t */\n#ifndef LOCK_TRIES\n#define LOCK_TRIES 15\n#endif\n\n#ifndef LOCK_SLEEP\n#define LOCK_SLEEP 1\n#endif\n\tfor (i = 0; i < LOCK_TRIES; i++) {\n\t\tif (i > 0) {\n\t\t\tsleep (LOCK_SLEEP);\t/* delay between retries */\n\t\t}\n\t\tif (commonio_lock_nowait (db, i==LOCK_TRIES-1) != 0) {\n\t\t\treturn 1;\t/* success */\n\t\t}\n\t\t/* no unnecessary retries on \"permission denied\" errors */\n\t\tif (geteuid () != 0) {\n\t\t\t(void) fprintf (stderr, \"%s: Permission denied.\\n\",\n\t\t\t                Prog);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\t\t/* failure */\n#endif\t\t\t\t/* !HAVE_LCKPWDF */\n}\n\nstatic void dec_lock_count (void)\n{\n\tif (lock_count > 0) {\n\t\tlock_count--;\n\t\tif (lock_count == 0) {\n\t\t\t/* Tell nscd when lock count goes to zero,\n\t\t\t   if any of the files were changed.  */\n\t\t\tif (nscd_need_reload) {\n\t\t\t\tnscd_flush_cache (\"passwd\");\n\t\t\t\tnscd_flush_cache (\"group\");\n\t\t\t\tnscd_need_reload = false;\n\t\t\t}\n#ifdef HAVE_LCKPWDF\n\t\t\tulckpwdf ();\n#endif\t\t\t\t/* HAVE_LCKPWDF */\n\t\t}\n\t}\n}\n\n\nint commonio_unlock (struct commonio_db *db)\n{\n\tchar lock[1024];\n\n\tif (db->isopen) {\n\t\tdb->readonly = true;\n\t\tif (commonio_close (db) == 0) {\n\t\t\tif (db->locked) {\n\t\t\t\tdec_lock_count ();\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (db->locked) {\n\t\t/*\n\t\t * Unlock in reverse order: remove the lock file,\n\t\t * then call ulckpwdf() (if used) on last unlock.\n\t\t */\n\t\tdb->locked = false;\n\t\tsnprintf (lock, sizeof lock, \"%s.lock\", db->filename);\n\t\tunlink (lock);\n\t\tdec_lock_count ();\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\n/*\n * Add an entry at the end.\n *\n * defines p->next, p->prev\n * (unfortunately, owned special are not supported)\n */\nstatic void add_one_entry (struct commonio_db *db,\n                           /*@owned@*/struct commonio_entry *p)\n{\n\t/*@-mustfreeonly@*/\n\tp->next = NULL;\n\tp->prev = db->tail;\n\t/*@=mustfreeonly@*/\n\tif (NULL == db->head) {\n\t\tdb->head = p;\n\t}\n\tif (NULL != db->tail) {\n\t\tdb->tail->next = p;\n\t}\n\tdb->tail = p;\n}\n\n\nstatic bool name_is_nis (const char *name)\n{\n\treturn (('+' == name[0]) || ('-' == name[0]));\n}\n\n\n/*\n * New entries are inserted before the first NIS entry.  Order is preserved\n * when db is written out.\n */\n#ifndef KEEP_NIS_AT_END\n#define KEEP_NIS_AT_END 1\n#endif\n\n#if KEEP_NIS_AT_END\nstatic void add_one_entry_nis (struct commonio_db *db,\n                               /*@owned@*/struct commonio_entry *newp);\n\n/*\n * Insert an entry between the regular entries, and the NIS entries.\n *\n * defines newp->next, newp->prev\n * (unfortunately, owned special are not supported)\n */\nstatic void add_one_entry_nis (struct commonio_db *db,\n                               /*@owned@*/struct commonio_entry *newp)\n{\n\tstruct commonio_entry *p;\n\n\tfor (p = db->head; NULL != p; p = p->next) {\n\t\tif (name_is_nis (p->eptr ? db->ops->getname (p->eptr)\n\t\t                         : p->line)) {\n\t\t\t/*@-mustfreeonly@*/\n\t\t\tnewp->next = p;\n\t\t\tnewp->prev = p->prev;\n\t\t\t/*@=mustfreeonly@*/\n\t\t\tif (NULL != p->prev) {\n\t\t\t\tp->prev->next = newp;\n\t\t\t} else {\n\t\t\t\tdb->head = newp;\n\t\t\t}\n\t\t\tp->prev = newp;\n\t\t\treturn;\n\t\t}\n\t}\n\tadd_one_entry (db, newp);\n}\n#endif\t\t\t\t/* KEEP_NIS_AT_END */\n\n/* Initial buffer size, as well as increment if not sufficient\n   (for reading very long lines in group files).  */\n#define BUFLEN 4096\n\nint commonio_open (struct commonio_db *db, int mode)\n{\n\tchar *buf;\n\tchar *cp;\n\tchar *line;\n\tstruct commonio_entry *p;\n\tvoid *eptr = NULL;\n\tint flags = mode;\n\tsize_t buflen;\n\tint fd;\n\tint saved_errno;\n\n\tmode &= ~O_CREAT;\n\n\tif (   db->isopen\n\t    || (   (O_RDONLY != mode)\n\t        && (O_RDWR != mode))) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->readonly = (mode == O_RDONLY);\n\tif (!db->readonly && !db->locked) {\n\t\terrno = EACCES;\n\t\treturn 0;\n\t}\n\n\tdb->head = NULL;\n\tdb->tail = NULL;\n\tdb->cursor = NULL;\n\tdb->changed = false;\n\n\tfd = open (db->filename,\n\t             (db->readonly ? O_RDONLY : O_RDWR)\n\t           | O_NOCTTY | O_NONBLOCK | O_NOFOLLOW);\n\tsaved_errno = errno;\n\tdb->fp = NULL;\n\tif (fd >= 0) {\n#ifdef WITH_TCB\n\t\tif (tcb_is_suspect (fd) != 0) {\n\t\t\t(void) close (fd);\n\t\t\terrno = EINVAL;\n\t\t\treturn 0;\n\t\t}\n#endif\t\t\t\t/* WITH_TCB */\n\t\tdb->fp = fdopen (fd, db->readonly ? \"r\" : \"r+\");\n\t\tsaved_errno = errno;\n\t\tif (NULL == db->fp) {\n\t\t\t(void) close (fd);\n\t\t}\n\t}\n\terrno = saved_errno;\n\n\t/*\n\t * If O_CREAT was specified and the file didn't exist, it will be\n\t * created by commonio_close().  We have no entries to read yet.  --marekm\n\t */\n\tif (NULL == db->fp) {\n\t\tif (((flags & O_CREAT) != 0) && (ENOENT == errno)) {\n\t\t\tdb->isopen = true;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Do not inherit fd in spawned processes (e.g. nscd) */\n\tfcntl (fileno (db->fp), F_SETFD, FD_CLOEXEC);\n\n\tbuflen = BUFLEN;\n\tbuf = (char *) malloc (buflen);\n\tif (NULL == buf) {\n\t\tgoto cleanup_ENOMEM;\n\t}\n\n\twhile (db->ops->fgets (buf, (int) buflen, db->fp) == buf) {\n\t\twhile (   ((cp = strrchr (buf, '\\n')) == NULL)\n\t\t       && (feof (db->fp) == 0)) {\n\t\t\tsize_t len;\n\n\t\t\tbuflen += BUFLEN;\n\t\t\tcp = (char *) realloc (buf, buflen);\n\t\t\tif (NULL == cp) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t\tbuf = cp;\n\t\t\tlen = strlen (buf);\n\t\t\tif (db->ops->fgets (buf + len,\n\t\t\t                    (int) (buflen - len),\n\t\t\t                    db->fp) == NULL) {\n\t\t\t\tgoto cleanup_buf;\n\t\t\t}\n\t\t}\n\t\tcp = strrchr (buf, '\\n');\n\t\tif (NULL != cp) {\n\t\t\t*cp = '\\0';\n\t\t}\n\n\t\tline = strdup (buf);\n\t\tif (NULL == line) {\n\t\t\tgoto cleanup_buf;\n\t\t}\n\n\t\tif (name_is_nis (line)) {\n\t\t\teptr = NULL;\n\t\t} else {\n\t\t\teptr = db->ops->parse (line);\n\t\t\tif (NULL != eptr) {\n\t\t\t\teptr = db->ops->dup (eptr);\n\t\t\t\tif (NULL == eptr) {\n\t\t\t\t\tgoto cleanup_line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = (struct commonio_entry *) malloc (sizeof *p);\n\t\tif (NULL == p) {\n\t\t\tgoto cleanup_entry;\n\t\t}\n\n\t\tp->eptr = eptr;\n\t\tp->line = line;\n\t\tp->changed = false;\n\n\t\tadd_one_entry (db, p);\n\t}\n\n\tfree (buf);\n\n\tif (ferror (db->fp) != 0) {\n\t\tgoto cleanup_errno;\n\t}\n\n\tif ((NULL != db->ops->open_hook) && (db->ops->open_hook () == 0)) {\n\t\tgoto cleanup_errno;\n\t}\n\n\tdb->isopen = true;\n\treturn 1;\n\n      cleanup_entry:\n\tif (NULL != eptr) {\n\t\tdb->ops->free (eptr);\n\t}\n      cleanup_line:\n\tfree (line);\n      cleanup_buf:\n\tfree (buf);\n      cleanup_ENOMEM:\n\terrno = ENOMEM;\n      cleanup_errno:\n\tsaved_errno = errno;\n\tfree_linked_list (db);\n\tfclose (db->fp);\n\tdb->fp = NULL;\n\terrno = saved_errno;\n\treturn 0;\n}\n\n/*\n * Sort given db according to cmp function (usually compares uids)\n */\nint\ncommonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && ((NULL == ptr->line)\n\t         || (('+' != ptr->line[0])\n\t             && ('-' != ptr->line[0])))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif (NULL != ptr) {\n\t\tnis = ptr;\n\t}\n#endif\n\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n/*@ -nullderef @*/\n\t     ptr = ptr->next\n/*@ +nullderef @*/\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\n\t/* Take care of the head and tail separately */\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\n\t/* Now other elements have prev and next entries */\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\n\tfree (entries);\n\tdb->changed = true;\n\n\treturn 0;\n}\n\n/*\n * Sort entries in db according to order in another.\n */\nint commonio_sort_wrt (struct commonio_db *shadow,\n                       const struct commonio_db *passwd)\n{\n\tstruct commonio_entry *head = NULL, *pw_ptr, *spw_ptr;\n\tconst char *name;\n\n\tif ((NULL == shadow) || (NULL == shadow->head)) {\n\t\treturn 0;\n\t}\n\n\tfor (pw_ptr = passwd->head; NULL != pw_ptr; pw_ptr = pw_ptr->next) {\n\t\tif (NULL == pw_ptr->eptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tname = passwd->ops->getname (pw_ptr->eptr);\n\t\tfor (spw_ptr = shadow->head;\n\t\t     NULL != spw_ptr;\n\t\t     spw_ptr = spw_ptr->next) {\n\t\t\tif (NULL == spw_ptr->eptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp (name, shadow->ops->getname (spw_ptr->eptr))\n\t\t\t    == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (NULL == spw_ptr) {\n\t\t\tcontinue;\n\t\t}\n\t\tcommonio_del_entry (shadow, spw_ptr);\n\t\tspw_ptr->next = head;\n\t\thead = spw_ptr;\n\t}\n\n\tfor (spw_ptr = head; NULL != spw_ptr; spw_ptr = head) {\n\t\thead = head->next;\n\n\t\tif (NULL != shadow->head) {\n\t\t\tshadow->head->prev = spw_ptr;\n\t\t}\n\t\tspw_ptr->next = shadow->head;\n\t\tshadow->head = spw_ptr;\n\t}\n\n\tshadow->head->prev = NULL;\n\tshadow->changed = true;\n\n\treturn 0;\n}\n\n/*\n * write_all - Write the database to its file.\n *\n * It returns 0 if all the entries could be written correctly.\n */\nstatic int write_all (const struct commonio_db *db)\n\t/*@requires notnull db->fp@*/\n{\n\tconst struct commonio_entry *p;\n\tvoid *eptr;\n\n\tfor (p = db->head; NULL != p; p = p->next) {\n\t\tif (p->changed) {\n\t\t\teptr = p->eptr;\n\t\t\tassert (NULL != eptr);\n\t\t\tif (db->ops->put (eptr, db->fp) != 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (NULL != p->line) {\n\t\t\tif (db->ops->fputs (p->line, db->fp) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (putc ('\\n', db->fp) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint commonio_close (struct commonio_db *db)\n\t/*@requires notnull db->fp@*/\n{\n\tchar buf[1024];\n\tint errors = 0;\n\tstruct stat sb;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->isopen = false;\n\n\tif (!db->changed || db->readonly) {\n\t\t(void) fclose (db->fp);\n\t\tdb->fp = NULL;\n\t\tgoto success;\n\t}\n\n\tif ((NULL != db->ops->close_hook) && (db->ops->close_hook () == 0)) {\n\t\tgoto fail;\n\t}\n\n\tmemzero (&sb, sizeof sb);\n\tif (NULL != db->fp) {\n\t\tif (fstat (fileno (db->fp), &sb) != 0) {\n\t\t\t(void) fclose (db->fp);\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * Create backup file.\n\t\t */\n\t\tsnprintf (buf, sizeof buf, \"%s-\", db->filename);\n\n#ifdef WITH_SELINUX\n\t\tif (set_selinux_file_context (buf) != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (create_backup (buf, db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n\n\t\tif (fclose (db->fp) != 0) {\n\t\t\terrors++;\n\t\t}\n\n#ifdef WITH_SELINUX\n\t\tif (reset_selinux_file_context () != 0) {\n\t\t\terrors++;\n\t\t}\n#endif\n\t\tif (errors != 0) {\n\t\t\tdb->fp = NULL;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Default permissions for new [g]shadow files.\n\t\t */\n\t\tsb.st_mode = db->st_mode;\n\t\tsb.st_uid = db->st_uid;\n\t\tsb.st_gid = db->st_gid;\n\t}\n\n\tsnprintf (buf, sizeof buf, \"%s+\", db->filename);\n\n#ifdef WITH_SELINUX\n\tif (set_selinux_file_context (buf) != 0) {\n\t\terrors++;\n\t}\n#endif\n\n\tdb->fp = fopen_set_perms (buf, \"w\", &sb);\n\tif (NULL == db->fp) {\n\t\tgoto fail;\n\t}\n\n\tif (write_all (db) != 0) {\n\t\terrors++;\n\t}\n\n\tif (fflush (db->fp) != 0) {\n\t\terrors++;\n\t}\n#ifdef HAVE_FSYNC\n\tif (fsync (fileno (db->fp)) != 0) {\n\t\terrors++;\n\t}\n#else\t\t\t\t/* !HAVE_FSYNC */\n\tsync ();\n#endif\t\t\t\t/* !HAVE_FSYNC */\n\tif (fclose (db->fp) != 0) {\n\t\terrors++;\n\t}\n\n\tdb->fp = NULL;\n\n\tif (errors != 0) {\n\t\tunlink (buf);\n\t\tgoto fail;\n\t}\n\n\tif (lrename (buf, db->filename) != 0) {\n\t\tgoto fail;\n\t}\n\n#ifdef WITH_SELINUX\n\tif (reset_selinux_file_context () != 0) {\n\t\tgoto fail;\n\t}\n#endif\n\n\tnscd_need_reload = true;\n\tgoto success;\n      fail:\n\terrors++;\n      success:\n\n\tfree_linked_list (db);\n\treturn errors == 0;\n}\n\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *next_entry_by_name (\n\tstruct commonio_db *db,\n\t/*@null@*/struct commonio_entry *pos,\n\tconst char *name)\n{\n\tstruct commonio_entry *p;\n\tvoid *ep;\n\n\tif (NULL == pos) {\n\t\treturn NULL;\n\t}\n\n\tfor (p = pos; NULL != p; p = p->next) {\n\t\tep = p->eptr;\n\t\tif (   (NULL != ep)\n\t\t    && (strcmp (db->ops->getname (ep), name) == 0)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nstatic /*@dependent@*/ /*@null@*/struct commonio_entry *find_entry_by_name (\n\tstruct commonio_db *db,\n\tconst char *name)\n{\n\treturn next_entry_by_name (db, db->head, name);\n}\n\n\nint commonio_update (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\tp = find_entry_by_name (db, db->ops->getname (eptr));\n\tif (NULL != p) {\n\t\tif (next_entry_by_name (db, p->next, db->ops->getname (eptr)) != NULL) {\n\t\t\tfprintf (stderr, _(\"Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\\n\"), db->ops->getname (eptr), db->filename);\n\t\t\tdb->ops->free (nentry);\n\t\t\treturn 0;\n\t\t}\n\t\tdb->ops->free (p->eptr);\n\t\tp->eptr = nentry;\n\t\tp->changed = true;\n\t\tdb->cursor = p;\n\n\t\tdb->changed = true;\n\t\treturn 1;\n\t}\n\t/* not found, new entry */\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n\n#if KEEP_NIS_AT_END\n\tadd_one_entry_nis (db, p);\n#else\t\t\t\t/* !KEEP_NIS_AT_END */\n\tadd_one_entry (db, p);\n#endif\t\t\t\t/* !KEEP_NIS_AT_END */\n\n\tdb->changed = true;\n\treturn 1;\n}\n\n#ifdef ENABLE_SUBIDS\nint commonio_append (struct commonio_db *db, const void *eptr)\n{\n\tstruct commonio_entry *p;\n\tvoid *nentry;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tnentry = db->ops->dup (eptr);\n\tif (NULL == nentry) {\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\t/* new entry */\n\tp = (struct commonio_entry *) malloc (sizeof *p);\n\tif (NULL == p) {\n\t\tdb->ops->free (nentry);\n\t\terrno = ENOMEM;\n\t\treturn 0;\n\t}\n\n\tp->eptr = nentry;\n\tp->line = NULL;\n\tp->changed = true;\n\tadd_one_entry (db, p);\n\n\tdb->changed = true;\n\treturn 1;\n}\n#endif\t\t\t\t/* ENABLE_SUBIDS */\n\nvoid commonio_del_entry (struct commonio_db *db, const struct commonio_entry *p)\n{\n\tif (p == db->cursor) {\n\t\tdb->cursor = p->next;\n\t}\n\n\tif (NULL != p->prev) {\n\t\tp->prev->next = p->next;\n\t} else {\n\t\tdb->head = p->next;\n\t}\n\n\tif (NULL != p->next) {\n\t\tp->next->prev = p->prev;\n\t} else {\n\t\tdb->tail = p->prev;\n\t}\n\n\tdb->changed = true;\n}\n\n/*\n * commonio_remove - Remove the entry of the given name from the database.\n */\nint commonio_remove (struct commonio_db *db, const char *name)\n{\n\tstruct commonio_entry *p;\n\n\tif (!db->isopen || db->readonly) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tp = find_entry_by_name (db, name);\n\tif (NULL == p) {\n\t\terrno = ENOENT;\n\t\treturn 0;\n\t}\n\tif (next_entry_by_name (db, p->next, name) != NULL) {\n\t\tfprintf (stderr, _(\"Multiple entries named '%s' in %s. Please fix this with pwck or grpck.\\n\"), name, db->filename);\n\t\treturn 0;\n\t}\n\n\tcommonio_del_entry (db, p);\n\n\tif (NULL != p->line) {\n\t\tfree (p->line);\n\t}\n\n\tif (NULL != p->eptr) {\n\t\tdb->ops->free (p->eptr);\n\t}\n\n\treturn 1;\n}\n\n/*\n * commonio_locate - Find the first entry with the specified name in\n *                   the database.\n *\n *\tIf found, it returns the entry and set the cursor of the database to\n *\tthat entry.\n *\n *\tOtherwise, it returns NULL.\n */\n/*@observer@*/ /*@null@*/const void *commonio_locate (struct commonio_db *db, const char *name)\n{\n\tstruct commonio_entry *p;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tp = find_entry_by_name (db, name);\n\tif (NULL == p) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\tdb->cursor = p;\n\treturn p->eptr;\n}\n\n/*\n * commonio_rewind - Restore the database cursor to the first entry.\n *\n * It returns 0 on error, 1 on success.\n */\nint commonio_rewind (struct commonio_db *db)\n{\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tdb->cursor = NULL;\n\treturn 1;\n}\n\n/*\n * commonio_next - Return the next entry of the specified database\n *\n * It returns the next entry, or NULL if no other entries could be found.\n */\n/*@observer@*/ /*@null@*/const void *commonio_next (struct commonio_db *db)\n{\n\tvoid *eptr;\n\n\tif (!db->isopen) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (NULL == db->cursor) {\n\t\tdb->cursor = db->head;\n\t} else {\n\t\tdb->cursor = db->cursor->next;\n\t}\n\n\twhile (NULL != db->cursor) {\n\t\teptr = db->cursor->eptr;\n\t\tif (NULL != eptr) {\n\t\t\treturn eptr;\n\t\t}\n\n\t\tdb->cursor = db->cursor->next;\n\t}\n\treturn NULL;\n}\n\n"], "filenames": ["lib/commonio.c"], "buggy_code_start_loc": [754], "buggy_code_end_loc": [764], "fixing_code_start_loc": [754], "fixing_code_end_loc": [764], "type": "CWE-119", "message": "In shadow before 4.5, the newusers tool could be made to manipulate internal data structures in ways unintended by the authors. Malformed input may lead to crashes (with a buffer overflow or other memory corruption) or other unspecified behaviors. This crosses a privilege boundary in, for example, certain web-hosting environments in which a Control Panel allows an unprivileged user account to create subaccounts.", "other": {"cve": {"id": "CVE-2017-12424", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-04T09:29:00.187", "lastModified": "2021-03-23T20:02:18.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In shadow before 4.5, the newusers tool could be made to manipulate internal data structures in ways unintended by the authors. Malformed input may lead to crashes (with a buffer overflow or other memory corruption) or other unspecified behaviors. This crosses a privilege boundary in, for example, certain web-hosting environments in which a Control Panel allows an unprivileged user account to create subaccounts."}, {"lang": "es", "value": "En las versiones de Shadow anteriores a la 4.5, la herramienta newusers podr\u00eda utilizarse para manipular estructuras de datos internas de formas no permitidas por los desarrolladores. Las entradas manipuladas podr\u00edan llevar a ca\u00eddas (con un desbordamiento de b\u00fafer u otros tipos de corrupci\u00f3n de memoria) o a otro tipo de comportamiento sin especificar. Esto provoca un l\u00edmite de privilegios en, por ejemplo, ciertos entornos de hospedaje web en los que un Panel de Control permite que una cuenta de usuario sin privilegios cree subcuentas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:shadow_project:shadow:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5", "matchCriteriaId": "47C73BF7-91C6-44B6-B55B-4477B6F66C04"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=756630", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/shadow/+bug/1266675", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/03/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-16", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952"}}