{"buggy_code": ["<?php\n/**\n * This file is part of FacturaScripts\n * Copyright (C) 2018-2022 Carlos Garcia Gomez <carlos@facturascripts.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nnamespace FacturaScripts\\Core\\App;\n\nuse FacturaScripts\\Core\\Base\\MyFilesToken;\nuse FacturaScripts\\Core\\Base\\PluginManager;\n\n/**\n * Description of AppRouter\n *\n * @author Carlos Garc\u00eda G\u00f3mez <carlos@facturascripts.com>\n */\nfinal class AppRouter\n{\n\n    /**\n     * Path to list of routes stored on file.\n     */\n    const ROUTE_LIST_FILE = FS_FOLDER . DIRECTORY_SEPARATOR . 'MyFiles' . DIRECTORY_SEPARATOR . 'routes.json';\n\n    /**\n     * List of routes.\n     *\n     * @var array\n     */\n    private $routes;\n\n    /**\n     * AppRouter constructor.\n     */\n    public function __construct()\n    {\n        if (false === defined('FS_ROUTE')) {\n            define('FS_ROUTE', '');\n        }\n\n        $this->routes = $this->loadFromFile();\n    }\n\n    /**\n     * Clear the App routes.\n     */\n    public function clear()\n    {\n        $this->routes = [];\n        $this->save();\n    }\n\n    /**\n     * Return the specific App controller for any kind of petition.\n     *\n     * @return App\n     */\n    public function getApp()\n    {\n        $uri = $this->getUri();\n        if ('/api' === $uri || '/api/' === substr($uri, 0, 5)) {\n            return new AppAPI($uri);\n        }\n\n        if ('/cron' === $uri) {\n            return new AppCron($uri);\n        }\n\n        if ('/deploy' === $uri) {\n            $this->deploy();\n        }\n\n        foreach ($this->routes as $key => $data) {\n            if ($uri === $key) {\n                return $this->newAppController($uri, $data['controller']);\n            }\n\n            if ('*' !== substr($key, -1)) {\n                continue;\n            }\n\n            if (0 === strncmp($uri, $key, strlen($key) - 1)) {\n                return $this->newAppController($uri, $data['controller']);\n            }\n        }\n\n        return $this->newAppController($uri);\n    }\n\n    /**\n     * Return true if can output a file, false otherwise.\n     *\n     * @return bool\n     */\n    public function getFile(): bool\n    {\n        $uri = $this->getUri();\n        $filePath = FS_FOLDER . urldecode($uri);\n\n        // favicon.ico\n        if ('/favicon.ico' == $uri) {\n            $filePath = FS_FOLDER . '/Dinamic/Assets/Images/favicon.ico';\n            header('Content-Type: ' . $this->getMime($filePath));\n            readfile($filePath);\n            return true;\n        }\n\n        // Not a file? Not a safe file?\n        if (false === is_file($filePath) || false === $this->isFileSafe($filePath)) {\n            return false;\n        }\n\n        // Allowed folder?\n        $allowedFolders = ['node_modules', 'vendor', 'Dinamic', 'Core', 'Plugins', 'MyFiles/Public'];\n        foreach ($allowedFolders as $folder) {\n            if ('/' . $folder === substr($uri, 0, 1 + strlen($folder))) {\n                header('Content-Type: ' . $this->getMime($filePath));\n                readfile($filePath);\n                return true;\n            }\n        }\n\n        // MyFiles and token?\n        $token = filter_input(INPUT_GET, 'myft');\n        $fixedFilePath = substr(urldecode($uri), 1);\n        if ('/MyFiles/' === substr($uri, 0, 9) && $token && MyFilesToken::validate($fixedFilePath, $token)) {\n            header('Content-Type: ' . $this->getMime($filePath));\n\n            // disable the buffer if enabled\n            if (ob_get_contents()) {\n                ob_end_flush();\n            }\n\n            readfile($filePath);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param string $filePath\n     *\n     * @return bool\n     */\n    public static function isFileSafe(string $filePath): bool\n    {\n        $parts = explode('.', $filePath);\n        $safe = [\n            'avi', 'css', 'csv', 'eot', 'gif', 'gz', 'ico', 'jpeg', 'jpg', 'js',\n            'json', 'map', 'mkv', 'mp4', 'ogg', 'pdf', 'png', 'sql', 'svg',\n            'ttf', 'webm', 'woff', 'woff2', 'xls', 'xlsx', 'xml', 'xsig', 'zip'\n        ];\n        return empty($parts) || count($parts) === 1 || in_array(end($parts), $safe, true);\n    }\n\n    /**\n     * Adds this route to the ap routes.\n     *\n     * @param string $newRoute\n     * @param string $controllerName\n     * @param string $optionalId\n     * @param bool $checkOptionalId\n     */\n    public function setRoute(string $newRoute, string $controllerName, string $optionalId = '', bool $checkOptionalId = true)\n    {\n        if (!empty($optionalId) && $checkOptionalId) {\n            // if optionalId, then remove previous items with that data\n            foreach ($this->routes as $route => $routeItem) {\n                if ($routeItem['controller'] === $controllerName && $routeItem['optionalId'] === $optionalId) {\n                    unset($this->routes[$route]);\n                }\n            }\n        }\n\n        $this->routes[$newRoute] = [\n            'controller' => $controllerName,\n            'optionalId' => $optionalId\n        ];\n\n        $this->save();\n    }\n\n    /**\n     * Deploy all dynamic files.\n     */\n    private function deploy()\n    {\n        if (false === file_exists(FS_FOLDER . DIRECTORY_SEPARATOR . 'Dinamic')) {\n            $pluginManager = new PluginManager();\n            $pluginManager->deploy();\n        }\n    }\n\n    /**\n     * Return the mime type from given file.\n     *\n     * @param string $filePath\n     *\n     * @return string\n     */\n    private function getMime(string $filePath): string\n    {\n        if ('.css' === substr($filePath, -4)) {\n            return 'text/css';\n        }\n\n        if ('.js' === substr($filePath, -3)) {\n            return 'application/javascript';\n        }\n\n        return mime_content_type($filePath);\n    }\n\n    /**\n     * Return the uri from the request.\n     *\n     * @return bool|string\n     */\n    private function getUri()\n    {\n        $uri = filter_input(INPUT_SERVER, 'REQUEST_URI');\n        $uri2 = is_null($uri) ? filter_var($_SERVER['REQUEST_URI'], FILTER_SANITIZE_URL) : $uri;\n        $uriArray = explode('?', $uri2);\n\n        return substr($uriArray[0], strlen(FS_ROUTE));\n    }\n\n    /**\n     * Returns an array with the list of plugins in the plugin.list file.\n     *\n     * @return array\n     */\n    private function loadFromFile(): array\n    {\n        if (file_exists(self::ROUTE_LIST_FILE)) {\n            $content = file_get_contents(self::ROUTE_LIST_FILE);\n            if ($content !== false) {\n                return json_decode($content, true);\n            }\n        }\n\n        return [];\n    }\n\n    /**\n     * @param string $uri\n     * @param string $pageName\n     *\n     * @return App\n     */\n    private function newAppController(string $uri, string $pageName = '')\n    {\n        return FS_DEBUG ? new AppDebugController($uri, $pageName) : new AppController($uri, $pageName);\n    }\n\n    /**\n     * Save the routes in a file.\n     *\n     * @return void\n     */\n    private function save(): void\n    {\n        $content = json_encode($this->routes);\n        file_put_contents(self::ROUTE_LIST_FILE, $content);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * This file is part of FacturaScripts\n * Copyright (C) 2018-2022 Carlos Garcia Gomez <carlos@facturascripts.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nnamespace FacturaScripts\\Core\\App;\n\nuse FacturaScripts\\Core\\Base\\MyFilesToken;\nuse FacturaScripts\\Core\\Base\\PluginManager;\n\n/**\n * Description of AppRouter\n *\n * @author Carlos Garc\u00eda G\u00f3mez <carlos@facturascripts.com>\n */\nfinal class AppRouter\n{\n\n    /**\n     * Path to list of routes stored on file.\n     */\n    const ROUTE_LIST_FILE = FS_FOLDER . DIRECTORY_SEPARATOR . 'MyFiles' . DIRECTORY_SEPARATOR . 'routes.json';\n\n    /**\n     * List of routes.\n     *\n     * @var array\n     */\n    private $routes;\n\n    /**\n     * AppRouter constructor.\n     */\n    public function __construct()\n    {\n        if (false === defined('FS_ROUTE')) {\n            define('FS_ROUTE', '');\n        }\n\n        $this->routes = $this->loadFromFile();\n    }\n\n    /**\n     * Clear the App routes.\n     */\n    public function clear()\n    {\n        $this->routes = [];\n        $this->save();\n    }\n\n    /**\n     * Return the specific App controller for any kind of petition.\n     *\n     * @return App\n     */\n    public function getApp()\n    {\n        $uri = $this->getUri();\n        if ('/api' === $uri || '/api/' === substr($uri, 0, 5)) {\n            return new AppAPI($uri);\n        }\n\n        if ('/cron' === $uri) {\n            return new AppCron($uri);\n        }\n\n        if ('/deploy' === $uri) {\n            $this->deploy();\n        }\n\n        foreach ($this->routes as $key => $data) {\n            if ($uri === $key) {\n                return $this->newAppController($uri, $data['controller']);\n            }\n\n            if ('*' !== substr($key, -1)) {\n                continue;\n            }\n\n            if (0 === strncmp($uri, $key, strlen($key) - 1)) {\n                return $this->newAppController($uri, $data['controller']);\n            }\n        }\n\n        return $this->newAppController($uri);\n    }\n\n    /**\n     * Return true if can output a file, false otherwise.\n     *\n     * @return bool\n     */\n    public function getFile(): bool\n    {\n        $uri = $this->getUri();\n        $filePath = FS_FOLDER . urldecode($uri);\n\n        // favicon.ico\n        if ('/favicon.ico' == $uri) {\n            $filePath = FS_FOLDER . '/Dinamic/Assets/Images/favicon.ico';\n            header('Content-Type: ' . $this->getMime($filePath));\n            readfile($filePath);\n            return true;\n        }\n\n        // Not a file? Not a safe file?\n        if (false === is_file($filePath) || false === $this->isFileSafe($filePath)) {\n            return false;\n        }\n\n        // Allowed folder?\n        $allowedFolders = ['node_modules', 'vendor', 'Dinamic', 'Core', 'Plugins', 'MyFiles/Public'];\n        foreach ($allowedFolders as $folder) {\n            if ('/' . $folder === substr($uri, 0, 1 + strlen($folder))) {\n                $this->download($filePath);\n                return true;\n            }\n        }\n\n        // MyFiles and token?\n        $token = filter_input(INPUT_GET, 'myft');\n        $fixedFilePath = substr(urldecode($uri), 1);\n        if ('/MyFiles/' === substr($uri, 0, 9) && $token && MyFilesToken::validate($fixedFilePath, $token)) {\n            $this->download($filePath);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param string $filePath\n     *\n     * @return bool\n     */\n    public static function isFileSafe(string $filePath): bool\n    {\n        $parts = explode('.', $filePath);\n        $safe = [\n            'avi', 'css', 'csv', 'eot', 'gif', 'gz', 'ico', 'jpeg', 'jpg', 'js',\n            'json', 'map', 'mkv', 'mp4', 'ogg', 'pdf', 'png', 'sql', 'svg',\n            'ttf', 'webm', 'woff', 'woff2', 'xls', 'xlsx', 'xml', 'xsig', 'zip'\n        ];\n        return empty($parts) || count($parts) === 1 || in_array(end($parts), $safe, true);\n    }\n\n    /**\n     * Adds this route to the ap routes.\n     *\n     * @param string $newRoute\n     * @param string $controllerName\n     * @param string $optionalId\n     * @param bool $checkOptionalId\n     */\n    public function setRoute(string $newRoute, string $controllerName, string $optionalId = '', bool $checkOptionalId = true)\n    {\n        if (!empty($optionalId) && $checkOptionalId) {\n            // if optionalId, then remove previous items with that data\n            foreach ($this->routes as $route => $routeItem) {\n                if ($routeItem['controller'] === $controllerName && $routeItem['optionalId'] === $optionalId) {\n                    unset($this->routes[$route]);\n                }\n            }\n        }\n\n        $this->routes[$newRoute] = [\n            'controller' => $controllerName,\n            'optionalId' => $optionalId\n        ];\n\n        $this->save();\n    }\n\n    /**\n     * Deploy all dynamic files.\n     */\n    private function deploy()\n    {\n        if (false === file_exists(FS_FOLDER . DIRECTORY_SEPARATOR . 'Dinamic')) {\n            $pluginManager = new PluginManager();\n            $pluginManager->deploy();\n        }\n    }\n\n    private function download(string $filePath)\n    {\n        header('Content-Type: ' . $this->getMime($filePath));\n\n        // disable the buffer if enabled\n        if (ob_get_contents()) {\n            ob_end_flush();\n        }\n\n        // force to download svg files to prevent XSS attacks\n        if (strpos($filePath, '.svg') !== false) {\n            header('Content-Disposition: attachment; filename=\"' . basename($filePath) . '\"');\n        }\n\n        readfile($filePath);\n    }\n\n    /**\n     * Return the mime type from given file.\n     *\n     * @param string $filePath\n     *\n     * @return string\n     */\n    private function getMime(string $filePath): string\n    {\n        if ('.css' === substr($filePath, -4)) {\n            return 'text/css';\n        }\n\n        if ('.js' === substr($filePath, -3)) {\n            return 'application/javascript';\n        }\n\n        return mime_content_type($filePath);\n    }\n\n    /**\n     * Return the uri from the request.\n     *\n     * @return bool|string\n     */\n    private function getUri()\n    {\n        $uri = filter_input(INPUT_SERVER, 'REQUEST_URI');\n        $uri2 = is_null($uri) ? filter_var($_SERVER['REQUEST_URI'], FILTER_SANITIZE_URL) : $uri;\n        $uriArray = explode('?', $uri2);\n\n        return substr($uriArray[0], strlen(FS_ROUTE));\n    }\n\n    /**\n     * Returns an array with the list of plugins in the plugin.list file.\n     *\n     * @return array\n     */\n    private function loadFromFile(): array\n    {\n        if (file_exists(self::ROUTE_LIST_FILE)) {\n            $content = file_get_contents(self::ROUTE_LIST_FILE);\n            if ($content !== false) {\n                return json_decode($content, true);\n            }\n        }\n\n        return [];\n    }\n\n    /**\n     * @param string $uri\n     * @param string $pageName\n     *\n     * @return App\n     */\n    private function newAppController(string $uri, string $pageName = '')\n    {\n        return FS_DEBUG ? new AppDebugController($uri, $pageName) : new AppController($uri, $pageName);\n    }\n\n    /**\n     * Save the routes in a file.\n     *\n     * @return void\n     */\n    private function save(): void\n    {\n        $content = json_encode($this->routes);\n        file_put_contents(self::ROUTE_LIST_FILE, $content);\n    }\n}\n"], "filenames": ["Core/App/AppRouter.php"], "buggy_code_start_loc": [130], "buggy_code_end_loc": [207], "fixing_code_start_loc": [130], "fixing_code_end_loc": [217], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository neorazorx/facturascripts prior to 2022.06.", "other": {"cve": {"id": "CVE-2022-2065", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-13T13:15:13.497", "lastModified": "2022-06-22T16:20:27.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository neorazorx/facturascripts prior to 2022.06."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en el repositorio GitHub neorazorx/facturascripts versiones anteriores a 2022.06"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facturascripts:facturascripts:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022.06", "matchCriteriaId": "4D19608D-8D38-4581-89F0-4C4318197848"}]}]}], "references": [{"url": "https://github.com/neorazorx/facturascripts/commit/1d1edb40b40016d7fd2893b410b98569d7facca1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/bcb44da4-d5c9-4830-924f-02d6defe6506", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neorazorx/facturascripts/commit/1d1edb40b40016d7fd2893b410b98569d7facca1"}}