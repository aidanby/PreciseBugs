{"buggy_code": ["/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n/*\n * lsquic_full_conn_ietf.c -- IETF QUIC connection.\n */\n\n#include <assert.h>\n#include <errno.h>\n#include <inttypes.h>\n#define _USE_MATH_DEFINES   /* Need this for M_E on Windows */\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/queue.h>\n\n#include <openssl/aead.h>\n#include <openssl/rand.h>\n\n#include \"fiu-local.h\"\n\n#include \"lsquic.h\"\n#include \"lsxpack_header.h\"\n#include \"lsquic_types.h\"\n#include \"lsquic_int_types.h\"\n#include \"lsquic_attq.h\"\n#include \"lsquic_packet_common.h\"\n#include \"lsquic_packet_ietf.h\"\n#include \"lsquic_packet_in.h\"\n#include \"lsquic_packet_out.h\"\n#include \"lsquic_hash.h\"\n#include \"lsquic_conn.h\"\n#include \"lsquic_rechist.h\"\n#include \"lsquic_senhist.h\"\n#include \"lsquic_cubic.h\"\n#include \"lsquic_pacer.h\"\n#include \"lsquic_sfcw.h\"\n#include \"lsquic_conn_flow.h\"\n#include \"lsquic_varint.h\"\n#include \"lsquic_hq.h\"\n#include \"lsquic_stream.h\"\n#include \"lsquic_rtt.h\"\n#include \"lsquic_conn_public.h\"\n#include \"lsquic_bw_sampler.h\"\n#include \"lsquic_minmax.h\"\n#include \"lsquic_bbr.h\"\n#include \"lsquic_adaptive_cc.h\"\n#include \"lsquic_send_ctl.h\"\n#include \"lsquic_alarmset.h\"\n#include \"lsquic_ver_neg.h\"\n#include \"lsquic_mm.h\"\n#include \"lsquic_engine_public.h\"\n#include \"lsquic_set.h\"\n#include \"lsquic_sizes.h\"\n#include \"lsquic_trans_params.h\"\n#include \"lsquic_version.h\"\n#include \"lsquic_parse.h\"\n#include \"lsquic_util.h\"\n#include \"lsquic_enc_sess.h\"\n#include \"lsquic_ev_log.h\"\n#include \"lsquic_malo.h\"\n#include \"lsquic_frab_list.h\"\n#include \"lsquic_hcso_writer.h\"\n#include \"lsquic_hcsi_reader.h\"\n#include \"lsqpack.h\"\n#include \"lsquic_http1x_if.h\"\n#include \"lsquic_qenc_hdl.h\"\n#include \"lsquic_qdec_hdl.h\"\n#include \"lsquic_trechist.h\"\n#include \"lsquic_mini_conn_ietf.h\"\n#include \"lsquic_tokgen.h\"\n#include \"lsquic_full_conn.h\"\n#include \"lsquic_spi.h\"\n#include \"lsquic_min_heap.h\"\n#include \"lsquic_hpi.h\"\n#include \"lsquic_ietf.h\"\n#include \"lsquic_push_promise.h\"\n#include \"lsquic_headers.h\"\n#include \"lsquic_crand.h\"\n#include \"ls-sfparser.h\"\n#include \"lsquic_qpack_exp.h\"\n\n#define LSQUIC_LOGGER_MODULE LSQLM_CONN\n#define LSQUIC_LOG_CONN_ID lsquic_conn_log_cid(&conn->ifc_conn)\n#include \"lsquic_logger.h\"\n\n#define MAX_RETR_PACKETS_SINCE_LAST_ACK 2\n#define MAX_ANY_PACKETS_SINCE_LAST_ACK 20\n#define ACK_TIMEOUT                    (TP_DEF_MAX_ACK_DELAY * 1000)\n#define INITIAL_CHAL_TIMEOUT            250000\n#define HSK_PING_TIMEOUT                200000\n\n/* Retire original CID after this much time has elapsed: */\n#define RET_CID_TIMEOUT                 2000000\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n/* IETF QUIC push promise does not contain stream ID.  This means that, unlike\n * in GQUIC, one cannot create a stream immediately and pass it to the client.\n * We may have to add a special API for IETF push promises.  That's in the\n * future: right now, we punt it.\n */\n#define CLIENT_PUSH_SUPPORT 0\n\n\n\n/* IMPORTANT: Keep values of IFC_SERVER and IFC_HTTP same as LSENG_SERVER\n * and LSENG_HTTP.\n */\nenum ifull_conn_flags\n{\n    IFC_SERVER        = LSENG_SERVER,   /* Server mode */\n    IFC_HTTP          = LSENG_HTTP,     /* HTTP mode */\n    IFC_ACK_HAD_MISS  = 1 << 2,\n#define IFC_BIT_ERROR 3\n    IFC_ERROR         = 1 << IFC_BIT_ERROR,\n    IFC_TIMED_OUT     = 1 << 4,\n    IFC_ABORTED       = 1 << 5,\n    IFC_HSK_FAILED    = 1 << 6,\n    IFC_GOING_AWAY    = 1 << 7,\n    IFC_CLOSING       = 1 << 8,   /* Closing */\n    IFC_RECV_CLOSE    = 1 << 9,  /* Received CONNECTION_CLOSE frame */\n    IFC_TICK_CLOSE    = 1 << 10,  /* We returned TICK_CLOSE */\n    IFC_CREATED_OK    = 1 << 11,\n    IFC_HAVE_SAVED_ACK= 1 << 12,\n    IFC_ABORT_COMPLAINED\n                      = 1 << 13,\n    IFC_DCID_SET      = 1 << 14,\n#define IFCBIT_ACK_QUED_SHIFT 15\n    IFC_ACK_QUED_INIT = 1 << 15,\n    IFC_ACK_QUED_HSK  = IFC_ACK_QUED_INIT << PNS_HSK,\n    IFC_ACK_QUED_APP  = IFC_ACK_QUED_INIT << PNS_APP,\n#define IFC_ACK_QUEUED (IFC_ACK_QUED_INIT|IFC_ACK_QUED_HSK|IFC_ACK_QUED_APP)\n    IFC_HAVE_PEER_SET = 1 << 18,\n    IFC_GOT_PRST      = 1 << 19,\n    IFC_IGNORE_INIT   = 1 << 20,\n    IFC_RETRIED       = 1 << 21,\n    IFC_SWITCH_DCID   = 1 << 22, /* Perform DCID switch when a new CID becomes available */\n    IFC_GOAWAY_CLOSE  = 1 << 23,\n    IFC_FIRST_TICK    = 1 << 24,\n    IFC_IGNORE_HSK    = 1 << 25,\n    IFC_PROC_CRYPTO   = 1 << 26,\n    IFC_MIGRA         = 1 << 27,\n    IFC_HTTP_INITED   = 1 << 28, /* HTTP initialized */\n    IFC_DELAYED_ACKS  = 1 << 29, /* Delayed ACKs are enabled */\n    IFC_TIMESTAMPS    = 1 << 30, /* Timestamps are enabled */\n    IFC_DATAGRAMS     = 1u<< 31, /* Datagrams are enabled */\n};\n\n\nenum more_flags\n{\n    MF_VALIDATE_PATH    = 1 << 0,\n    MF_NOPROG_TIMEOUT   = 1 << 1,\n    MF_CHECK_MTU_PROBE  = 1 << 2,\n    MF_IGNORE_MISSING   = 1 << 3,\n    MF_CONN_CLOSE_PACK  = 1 << 4,   /* CONNECTION_CLOSE has been packetized */\n    MF_SEND_WRONG_COUNTS= 1 << 5,   /* Send wrong ECN counts to peer */\n    MF_WANT_DATAGRAM_WRITE  = 1 << 6,\n    MF_DOING_0RTT       = 1 << 7,\n    MF_HAVE_HCSI        = 1 << 8,   /* Have HTTP Control Stream Incoming */\n};\n\n\n#define N_PATHS 4\n\nenum send\n{\n    /* PATH_CHALLENGE and PATH_RESPONSE frames are not retransmittable.  They\n     * are positioned first in the enum to optimize packetization.\n     */\n    SEND_PATH_CHAL,\n    SEND_PATH_CHAL_PATH_0 = SEND_PATH_CHAL + 0,\n    SEND_PATH_CHAL_PATH_1 = SEND_PATH_CHAL + 1,\n    SEND_PATH_CHAL_PATH_2 = SEND_PATH_CHAL + 2,\n    SEND_PATH_CHAL_PATH_3 = SEND_PATH_CHAL + 3,\n    SEND_PATH_RESP,\n    SEND_PATH_RESP_PATH_0 = SEND_PATH_RESP + 0,\n    SEND_PATH_RESP_PATH_1 = SEND_PATH_RESP + 1,\n    SEND_PATH_RESP_PATH_2 = SEND_PATH_RESP + 2,\n    SEND_PATH_RESP_PATH_3 = SEND_PATH_RESP + 3,\n    SEND_MAX_DATA,\n    SEND_PING,\n    SEND_NEW_CID,\n    SEND_RETIRE_CID,\n    SEND_CONN_CLOSE,\n    SEND_STREAMS_BLOCKED,\n    SEND_STREAMS_BLOCKED_BIDI = SEND_STREAMS_BLOCKED + SD_BIDI,\n    SEND_STREAMS_BLOCKED_UNI = SEND_STREAMS_BLOCKED + SD_UNI,\n    SEND_MAX_STREAMS,\n    SEND_MAX_STREAMS_BIDI = SEND_MAX_STREAMS + SD_BIDI,\n    SEND_MAX_STREAMS_UNI = SEND_MAX_STREAMS + SD_UNI,\n    SEND_STOP_SENDING,\n    SEND_NEW_TOKEN,\n    SEND_HANDSHAKE_DONE,\n    SEND_ACK_FREQUENCY,\n    N_SEND\n};\n\nenum send_flags\n{\n    SF_SEND_MAX_DATA                = 1 << SEND_MAX_DATA,\n    SF_SEND_PING                    = 1 << SEND_PING,\n    SF_SEND_PATH_CHAL               = 1 << SEND_PATH_CHAL,\n    SF_SEND_PATH_CHAL_PATH_0        = 1 << SEND_PATH_CHAL_PATH_0,\n    SF_SEND_PATH_CHAL_PATH_1        = 1 << SEND_PATH_CHAL_PATH_1,\n    SF_SEND_PATH_CHAL_PATH_2        = 1 << SEND_PATH_CHAL_PATH_2,\n    SF_SEND_PATH_CHAL_PATH_3        = 1 << SEND_PATH_CHAL_PATH_3,\n    SF_SEND_PATH_RESP               = 1 << SEND_PATH_RESP,\n    SF_SEND_PATH_RESP_PATH_0        = 1 << SEND_PATH_RESP_PATH_0,\n    SF_SEND_PATH_RESP_PATH_1        = 1 << SEND_PATH_RESP_PATH_1,\n    SF_SEND_PATH_RESP_PATH_2        = 1 << SEND_PATH_RESP_PATH_2,\n    SF_SEND_PATH_RESP_PATH_3        = 1 << SEND_PATH_RESP_PATH_3,\n    SF_SEND_NEW_CID                 = 1 << SEND_NEW_CID,\n    SF_SEND_RETIRE_CID              = 1 << SEND_RETIRE_CID,\n    SF_SEND_CONN_CLOSE              = 1 << SEND_CONN_CLOSE,\n    SF_SEND_STREAMS_BLOCKED         = 1 << SEND_STREAMS_BLOCKED,\n    SF_SEND_STREAMS_BLOCKED_BIDI    = 1 << SEND_STREAMS_BLOCKED_BIDI,\n    SF_SEND_STREAMS_BLOCKED_UNI     = 1 << SEND_STREAMS_BLOCKED_UNI,\n    SF_SEND_MAX_STREAMS             = 1 << SEND_MAX_STREAMS,\n    SF_SEND_MAX_STREAMS_BIDI        = 1 << SEND_MAX_STREAMS_BIDI,\n    SF_SEND_MAX_STREAMS_UNI         = 1 << SEND_MAX_STREAMS_UNI,\n    SF_SEND_STOP_SENDING            = 1 << SEND_STOP_SENDING,\n    SF_SEND_NEW_TOKEN               = 1 << SEND_NEW_TOKEN,\n    SF_SEND_HANDSHAKE_DONE          = 1 << SEND_HANDSHAKE_DONE,\n    SF_SEND_ACK_FREQUENCY           = 1 << SEND_ACK_FREQUENCY,\n};\n\n#define SF_SEND_PATH_CHAL_ALL \\\n            (((SF_SEND_PATH_CHAL << N_PATHS) - 1) & ~(SF_SEND_PATH_CHAL - 1))\n\n#define IFC_IMMEDIATE_CLOSE_FLAGS \\\n            (IFC_TIMED_OUT|IFC_ERROR|IFC_ABORTED|IFC_HSK_FAILED|IFC_GOT_PRST)\n\n#define MAX_ERRMSG 256\n\n#define MAX_SCID 8\n\n#define SET_ERRMSG(conn, ...) do {                                          \\\n    if (!(conn)->ifc_errmsg)                                                \\\n    {                                                                       \\\n        (conn)->ifc_errmsg = malloc(MAX_ERRMSG);                            \\\n        if ((conn)->ifc_errmsg)                                             \\\n            snprintf((conn)->ifc_errmsg, MAX_ERRMSG, __VA_ARGS__);          \\\n    }                                                                       \\\n} while (0)\n\n#define ABORT_WITH_FLAG(conn, log_level, flag, ...) do {                    \\\n    SET_ERRMSG(conn, __VA_ARGS__);                                          \\\n    if (!((conn)->ifc_flags & IFC_ABORT_COMPLAINED))                        \\\n        LSQ_LOG(log_level, \"Abort connection: \" __VA_ARGS__);               \\\n    (conn)->ifc_flags |= flag|IFC_ABORT_COMPLAINED;                         \\\n} while (0)\n\n#define ABORT_ERROR(...) \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_ERROR, IFC_ERROR, __VA_ARGS__)\n#define ABORT_WARN(...) \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_WARN, IFC_ERROR, __VA_ARGS__)\n\n#define CONN_ERR(app_error_, code_) (struct conn_err) { \\\n                            .app_error = (app_error_), .u.err = (code_), }\n\n/* Use this for protocol errors; they do not need to be as loud as our own\n * internal errors.\n */\n#define ABORT_QUIETLY(app_error, code, ...) do {                            \\\n    conn->ifc_error = CONN_ERR(app_error, code);                            \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_INFO, IFC_ERROR, __VA_ARGS__);            \\\n} while (0)\n\n\nstatic enum stream_id_type\ngen_sit (unsigned server, enum stream_dir sd)\n{\n    return (server > 0) | ((sd > 0) << SD_SHIFT);\n}\n\n\nstruct stream_id_to_ss\n{\n    STAILQ_ENTRY(stream_id_to_ss)   sits_next;\n    lsquic_stream_id_t              sits_stream_id;\n    enum http_error_code            sits_error_code;\n};\n\nstruct http_ctl_stream_in\n{\n    struct hcsi_reader  reader;\n};\n\nstruct conn_err\n{\n    int                         app_error;\n    union\n    {\n        enum trans_error_code   tec;\n        enum http_error_code    hec;\n        unsigned                err;\n    }                           u;\n};\n\n\nstruct dplpmtud_state\n{\n    lsquic_packno_t     ds_probe_packno;\n#ifndef NDEBUG\n    lsquic_time_t       ds_probe_sent;\n#endif\n    enum {\n        DS_PROBE_SENT   = 1 << 0,\n    }                   ds_flags;\n    unsigned short      ds_probed_size,\n                        ds_failed_size; /* If non-zero, defines ceiling */\n    unsigned char       ds_probe_count;\n};\n\n\nstruct conn_path\n{\n    struct network_path         cop_path;\n    uint64_t                    cop_path_chals[8];  /* Arbitrary number */\n    uint64_t                    cop_inc_chal;       /* Incoming challenge */\n    lsquic_packno_t             cop_max_packno;\n    enum {\n        /* Initialized covers cop_path.np_pack_size and cop_path.np_dcid */\n        COP_INITIALIZED = 1 << 0,\n        /* This flag is set when we received a response to one of path\n         * challenges we sent on this path.\n         */\n        COP_VALIDATED   = 1 << 1,\n        /* Received non-probing frames.  This flag is not set for the\n         * original path.\n         */\n        COP_GOT_NONPROB = 1 << 2,\n        /* Spin bit is enabled on this path. */\n        COP_SPIN_BIT    = 1 << 3,\n        /* Allow padding packet to 1200 bytes */\n        COP_ALLOW_MTU_PADDING = 1 << 4,\n        /* Verified that the path MTU is at least 1200 bytes */\n        COP_VALIDATED_MTU = 1 << 5,\n    }                           cop_flags;\n    unsigned char               cop_n_chals;\n    unsigned char               cop_cce_idx;\n    unsigned char               cop_spin_bit;\n    struct dplpmtud_state       cop_dplpmtud;\n};\n\n\nstruct packet_tolerance_stats\n{\n    unsigned        n_acks;     /* Number of ACKs between probes */\n    float           integral_error;\n    lsquic_time_t   last_sample;\n};\n\n\nunion prio_iter\n{\n    struct stream_prio_iter spi;\n    struct http_prio_iter   hpi;\n};\n\n\nstruct prio_iter_if\n{\n    void (*pii_init) (void *, struct lsquic_stream *first,\n             struct lsquic_stream *last, uintptr_t next_ptr_offset,\n             struct lsquic_conn_public *, const char *name,\n             int (*filter)(void *filter_ctx, struct lsquic_stream *),\n             void *filter_ctx);\n\n    struct lsquic_stream * (*pii_first) (void *);\n\n    struct lsquic_stream * (*pii_next) (void *);\n\n    void (*pii_drop_non_high) (void *);\n\n    void (*pii_drop_high) (void *);\n\n    void (*pii_cleanup) (void *);\n};\n\n\nstatic const struct prio_iter_if orig_prio_iter_if = {\n    lsquic_spi_init,\n    lsquic_spi_first,\n    lsquic_spi_next,\n    lsquic_spi_drop_non_high,\n    lsquic_spi_drop_high,\n    lsquic_spi_cleanup,\n};\n\n\nstatic const struct prio_iter_if ext_prio_iter_if = {\n    lsquic_hpi_init,\n    lsquic_hpi_first,\n    lsquic_hpi_next,\n    lsquic_hpi_drop_non_high,\n    lsquic_hpi_drop_high,\n    lsquic_hpi_cleanup,\n};\n\n\nstruct ietf_full_conn\n{\n    struct lsquic_conn          ifc_conn;\n    struct conn_cid_elem        ifc_cces[MAX_SCID];\n    struct lsquic_rechist       ifc_rechist[N_PNS];\n    /* App PNS only, used to calculate was_missing: */\n    lsquic_packno_t             ifc_max_ackable_packno_in;\n    struct lsquic_send_ctl      ifc_send_ctl;\n    struct lsquic_conn_public   ifc_pub;\n    lsquic_alarmset_t           ifc_alset;\n    struct lsquic_set64         ifc_closed_stream_ids[N_SITS];\n    lsquic_stream_id_t          ifc_n_created_streams[N_SDS];\n    /* Not including the value stored in ifc_max_allowed_stream_id: */\n    lsquic_stream_id_t          ifc_max_allowed_stream_id[N_SITS];\n    uint64_t                    ifc_closed_peer_streams[N_SDS];\n    /* Maximum number of open stream initiated by peer: */\n    unsigned                    ifc_max_streams_in[N_SDS];\n    uint64_t                    ifc_max_stream_data_uni;\n    enum ifull_conn_flags       ifc_flags;\n    enum more_flags             ifc_mflags;\n    enum send_flags             ifc_send_flags;\n    enum send_flags             ifc_delayed_send;\n    struct {\n        uint64_t    streams_blocked[N_SDS];\n    }                           ifc_send;\n    struct conn_err             ifc_error;\n    unsigned                    ifc_n_delayed_streams;\n    unsigned                    ifc_n_cons_unretx;\n    const struct prio_iter_if  *ifc_pii;\n    char                       *ifc_errmsg;\n    struct lsquic_engine_public\n                               *ifc_enpub;\n    const struct lsquic_engine_settings\n                               *ifc_settings;\n    STAILQ_HEAD(, stream_id_to_ss)\n                                ifc_stream_ids_to_ss;\n    lsquic_time_t               ifc_created;\n    lsquic_time_t               ifc_saved_ack_received;\n    lsquic_packno_t             ifc_max_ack_packno[N_PNS];\n    lsquic_packno_t             ifc_max_non_probing;\n    struct {\n        uint64_t    max_stream_send;\n        uint8_t     ack_exp;\n    }                           ifc_cfg;\n    int                       (*ifc_process_incoming_packet)(\n                                                struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n    /* Number ackable packets received since last ACK was sent: */\n    unsigned                    ifc_n_slack_akbl[N_PNS];\n    unsigned                    ifc_n_slack_all;    /* App PNS only */\n    unsigned                    ifc_max_retx_since_last_ack;\n    lsquic_time_t               ifc_max_ack_delay;\n    uint64_t                    ifc_ecn_counts_in[N_PNS][4];\n    lsquic_stream_id_t          ifc_max_req_id;\n    struct hcso_writer          ifc_hcso;\n    struct http_ctl_stream_in   ifc_hcsi;\n    struct qpack_enc_hdl        ifc_qeh;\n    struct qpack_dec_hdl        ifc_qdh;\n    struct {\n        uint64_t    header_table_size,\n                    qpack_blocked_streams;\n    }                           ifc_peer_hq_settings;\n    struct dcid_elem           *ifc_dces[MAX_IETF_CONN_DCIDS];\n    TAILQ_HEAD(, dcid_elem)     ifc_to_retire;\n    unsigned                    ifc_scid_seqno;\n    lsquic_time_t               ifc_scid_timestamp[MAX_SCID];\n    /* Last 8 packets had ECN markings? */\n    uint8_t                     ifc_incoming_ecn;\n    unsigned char               ifc_cur_path_id;    /* Indexes ifc_paths */\n    unsigned char               ifc_used_paths;     /* Bitmask */\n    unsigned char               ifc_mig_path_id;\n    /* ifc_active_cids_limit is the maximum number of CIDs at any one time this\n     * endpoint is allowed to issue to peer.  If the TP value exceeds cn_n_cces,\n     * it is reduced to it.  ifc_active_cids_count tracks how many CIDs have\n     * been issued.  It is decremented each time a CID is retired.\n     */\n    unsigned char               ifc_active_cids_limit;\n    unsigned char               ifc_active_cids_count;\n    unsigned char               ifc_first_active_cid_seqno;\n    unsigned char               ifc_ping_unretx_thresh;\n    unsigned                    ifc_last_retire_prior_to;\n    unsigned                    ifc_ack_freq_seqno;\n    unsigned                    ifc_last_pack_tol;\n    unsigned                    ifc_last_calc_pack_tol;\n#if LSQUIC_CONN_STATS\n    unsigned                    ifc_min_pack_tol_sent;\n    unsigned                    ifc_max_pack_tol_sent;\n#endif\n    unsigned                    ifc_max_ack_freq_seqno; /* Incoming */\n    unsigned short              ifc_max_udp_payload;    /* Cached TP */\n    lsquic_time_t               ifc_last_live_update;\n    struct conn_path            ifc_paths[N_PATHS];\n    union {\n        struct {\n            struct lsquic_stream   *crypto_streams[N_ENC_LEVS];\n            struct ver_neg\n                        ifcli_ver_neg;\n            uint64_t    ifcli_max_push_id;\n            uint64_t    ifcli_min_goaway_stream_id;\n            enum {\n                IFCLI_PUSH_ENABLED    = 1 << 0,\n                IFCLI_HSK_SENT_OR_DEL = 1 << 1,\n            }           ifcli_flags;\n            unsigned    ifcli_packets_out;\n        }                           cli;\n        struct {\n            uint64_t    ifser_max_push_id;\n            uint64_t    ifser_next_push_id;\n            enum {\n                IFSER_PUSH_ENABLED    = 1 << 0,\n                IFSER_MAX_PUSH_ID     = 1 << 1,   /* ifser_max_push_id is set */\n            }           ifser_flags;\n        }                           ser;\n    }                           ifc_u;\n    lsquic_time_t               ifc_idle_to;\n    lsquic_time_t               ifc_ping_period;\n    struct lsquic_hash         *ifc_bpus;\n    uint64_t                    ifc_last_max_data_off_sent;\n    unsigned short              ifc_min_dg_sz,\n                                ifc_max_dg_sz;\n    struct packet_tolerance_stats\n                                ifc_pts;\n#if LSQUIC_CONN_STATS\n    struct conn_stats           ifc_stats,\n                               *ifc_last_stats;\n#endif\n    struct ack_info             ifc_ack;\n};\n\n#define CUR_CPATH(conn_) (&(conn_)->ifc_paths[(conn_)->ifc_cur_path_id])\n#define CUR_NPATH(conn_) (&(CUR_CPATH(conn_)->cop_path))\n#define CUR_DCID(conn_) (&(CUR_NPATH(conn_)->np_dcid))\n\n#define DCES_END(conn_) ((conn_)->ifc_dces + (sizeof((conn_)->ifc_dces) \\\n                                            / sizeof((conn_)->ifc_dces[0])))\n\n#define NPATH2CPATH(npath_) ((struct conn_path *) \\\n            ((char *) (npath_) - offsetof(struct conn_path, cop_path)))\n\n#if LSQUIC_CONN_STATS\n#define CONN_STATS(what_, count_) do {                                  \\\n    conn->ifc_stats.what_ += (count_);                                  \\\n} while (0)\n#else\n#define CONN_STATS(what_, count_)\n#endif\n\nstatic const struct ver_neg server_ver_neg;\n\nstatic const struct conn_iface *ietf_full_conn_iface_ptr;\nstatic const struct conn_iface *ietf_full_conn_prehsk_iface_ptr;\n\nstatic int\nprocess_incoming_packet_verneg (struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n\nstatic int\nprocess_incoming_packet_fast (struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n\nstatic void\nietf_full_conn_ci_packet_in (struct lsquic_conn *, struct lsquic_packet_in *);\n\nstatic int\nhandshake_ok (struct lsquic_conn *);\n\nstatic void\nignore_init (struct ietf_full_conn *);\n\nstatic void\nignore_hsk (struct ietf_full_conn *);\n\nstatic unsigned\nietf_full_conn_ci_n_avail_streams (const struct lsquic_conn *);\n\nstatic void\nietf_full_conn_ci_destroy (struct lsquic_conn *);\n\nstatic int\ninsert_new_dcid (struct ietf_full_conn *, uint64_t seqno,\n    const lsquic_cid_t *, const unsigned char *token, int update_cur_dcid);\n\nstatic struct conn_cid_elem *\nfind_cce_by_cid (struct ietf_full_conn *, const lsquic_cid_t *);\n\nstatic void\nmtu_probe_too_large (struct ietf_full_conn *, const struct lsquic_packet_out *);\n\nstatic int\napply_trans_params (struct ietf_full_conn *, const struct transport_params *);\n\nstatic void\npacket_tolerance_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now);\n\nstatic int\ninit_http (struct ietf_full_conn *);\n\nstatic unsigned\nhighest_bit_set (unsigned sz)\n{\n#if __GNUC__\n    unsigned clz = __builtin_clz(sz);\n    return 31 - clz;\n#else\n    unsigned n, y;\n    n = 32;\n    y = sz >> 16;   if (y) { n -= 16; sz = y; }\n    y = sz >>  8;   if (y) { n -=  8; sz = y; }\n    y = sz >>  4;   if (y) { n -=  4; sz = y; }\n    y = sz >>  2;   if (y) { n -=  2; sz = y; }\n    y = sz >>  1;   if (y) return 31 - n + 2;\n    return 31 - n + sz;\n#endif\n}\n\n\nstatic void\nset_versions (struct ietf_full_conn *conn, unsigned versions,\n                                                    enum lsquic_version *ver)\n{\n    conn->ifc_u.cli.ifcli_ver_neg.vn_supp = versions;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_ver  = (ver) ? *ver : highest_bit_set(versions);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_buf  = lsquic_ver2tag(conn->ifc_u.cli.ifcli_ver_neg.vn_ver);\n    conn->ifc_conn.cn_version = conn->ifc_u.cli.ifcli_ver_neg.vn_ver;\n}\n\n\nstatic void\ninit_ver_neg (struct ietf_full_conn *conn, unsigned versions,\n                                                    enum lsquic_version *ver)\n{\n    set_versions(conn, versions, ver);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_tag   = &conn->ifc_u.cli.ifcli_ver_neg.vn_buf;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_START;\n}\n\n\nstatic void\nack_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                        lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = ctx;\n    assert(al_id == AL_ACK_APP);\n    LSQ_DEBUG(\"%s ACK timer expired (%\"PRIu64\" < %\"PRIu64\"): ACK queued\",\n        lsquic_pns2str[PNS_APP], expiry, now);\n    conn->ifc_flags |= IFC_ACK_QUED_APP;\n}\n\n\nstatic void\nidle_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n\n    if ((conn->ifc_mflags & MF_NOPROG_TIMEOUT)\n        && conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout < now)\n    {\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"connection timed out due to \"\n                                                            \"lack of progress\");\n        /* Different flag so that CONNECTION_CLOSE frame is sent */\n        ABORT_QUIETLY(0, TEC_APPLICATION_ERROR,\n                                \"connection timed out due to lack of progress\");\n    }\n    else\n    {\n        LSQ_DEBUG(\"connection timed out\");\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"connection timed out\");\n        conn->ifc_flags |= IFC_TIMED_OUT;\n    }\n}\n\n\nstatic void\nhandshake_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"connection timed out: handshake timed out\");\n    conn->ifc_flags |= IFC_TIMED_OUT;\n}\n\n\n/*\n * When this alarm expires, at least one SCID slot shoud be available\n * for generation.\n */\nstatic void\ncid_throt_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"%s\", __func__);\n    conn->ifc_send_flags |= SF_SEND_NEW_CID;\n    return;\n}\n\n\nstatic void\nwipe_path (struct ietf_full_conn *conn, unsigned path_id)\n{\n    void *peer_ctx = conn->ifc_paths[path_id].cop_path.np_peer_ctx;\n    memset(&conn->ifc_paths[path_id], 0, sizeof(conn->ifc_paths[0]));\n    conn->ifc_paths[path_id].cop_path.np_path_id = path_id;\n    conn->ifc_paths[path_id].cop_path.np_peer_ctx = peer_ctx;\n    conn->ifc_used_paths &= ~(1 << path_id);\n}\n\n\nstatic void\npath_chal_alarm_expired (enum alarm_id al_id, void *ctx,\n                                lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    const unsigned path_id = al_id - AL_PATH_CHAL;\n    struct conn_path *const copath = &conn->ifc_paths[path_id];\n\n    if (copath->cop_n_chals < sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]))\n    {\n        LSQ_DEBUG(\"path #%u challenge expired, schedule another one\", path_id);\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL << path_id;\n    }\n    else if (conn->ifc_cur_path_id != path_id)\n    {\n        LSQ_INFO(\"migration to path #%u failed after none of %u path \"\n            \"challenges received responses\", path_id, copath->cop_n_chals);\n        /* There may be a lingering challenge if its generation is delayed */\n        lsquic_send_ctl_cancel_path_verification(&conn->ifc_send_ctl,\n                                                        &copath->cop_path);\n        wipe_path(conn, path_id);\n    }\n    else\n        LSQ_INFO(\"no path challenge responses on current path %u, stop \"\n            \"sending path challenges\", path_id);\n}\n\n\n/* Sending DATA_BLOCKED and STREAM_DATA_BLOCKED frames is a way to elicit\n * incoming packets from peer when it is too slow to read data.  This is\n * recommended by [draft-ietf-quic-transport-25] Section 4.1.\n *\n * If we are still in the blocked state, we schedule a blocked frame to\n * be sent.\n */\nstatic void\nblocked_ka_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    int has_send_flag;\n\n    if (lsquic_conn_cap_avail(&conn->ifc_pub.conn_cap) == 0)\n    {\n        LSQ_DEBUG(\"set SEND_BLOCKED flag on connection\");\n        conn->ifc_conn.cn_flags |= LSCONN_SEND_BLOCKED;\n        return;\n    }\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                         el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (lsquic_stream_is_blocked(stream))\n        {\n            has_send_flag = (stream->sm_qflags & SMQF_SENDING_FLAGS);\n            stream->sm_qflags |= SMQF_SEND_BLOCKED;\n            LSQ_DEBUG(\"set SEND_BLOCKED flag on stream %\"PRIu64, stream->id);\n            if (!lsquic_sendctl_gen_stream_blocked_frame(\n                        stream->conn_pub->send_ctl, stream))\n            {\n                LSQ_DEBUG(\"failed to send STREAM_BLOCKED frame for\"\n                        \" stream %\"PRIu64 \" immedately, postpone.\", stream->id);\n                if (!has_send_flag)\n                    TAILQ_INSERT_TAIL(&conn->ifc_pub.sending_streams, stream,\n                                                            next_send_stream);\n            }\n        }\n    }\n}\n\n\nstatic void\nmtu_probe_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n\n    LSQ_DEBUG(\"MTU probe alarm expired: set `check MTU probe' flag\");\n    assert(!(conn->ifc_mflags & MF_CHECK_MTU_PROBE));\n    conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n}\n\n\nstatic int\nmigra_is_on (const struct ietf_full_conn *conn, unsigned path_id)\n{\n    return (conn->ifc_send_flags & (SF_SEND_PATH_CHAL << path_id))\n        || lsquic_alarmset_is_set(&conn->ifc_alset, AL_PATH_CHAL + path_id);\n}\n\n\n#define TRANSPORT_OVERHEAD(is_ipv6) (((is_ipv6) ? 40 : 20) + 8 /* UDP */)\n\nstatic unsigned short\ncalc_base_packet_size (const struct ietf_full_conn *conn, int is_ipv6)\n{\n    unsigned short size;\n\n    if (conn->ifc_settings->es_base_plpmtu)\n        size = conn->ifc_settings->es_base_plpmtu;\n    else if (is_ipv6)\n        size = IQUIC_MAX_IPv6_PACKET_SZ;\n    else\n        size = IQUIC_MAX_IPv4_PACKET_SZ;\n\n    return size;\n}\n\n\nstatic void\nmigra_begin (struct ietf_full_conn *conn, struct conn_path *copath,\n                struct dcid_elem *dce, const struct sockaddr *dest_sa,\n                const struct transport_params *params)\n{\n    assert(!(migra_is_on(conn, copath - conn->ifc_paths)));\n\n    dce->de_flags |= DE_ASSIGNED;\n    copath->cop_flags |= COP_INITIALIZED;\n    copath->cop_path.np_dcid = dce->de_cid;\n    copath->cop_path.np_peer_ctx = CUR_NPATH(conn)->np_peer_ctx;\n    copath->cop_path.np_pack_size\n                = calc_base_packet_size(conn, NP_IS_IPv6(CUR_NPATH(conn)));\n    if (conn->ifc_max_udp_payload < copath->cop_path.np_pack_size)\n        copath->cop_path.np_pack_size = conn->ifc_max_udp_payload;\n    memcpy(&copath->cop_path.np_local_addr, NP_LOCAL_SA(CUR_NPATH(conn)),\n                                    sizeof(copath->cop_path.np_local_addr));\n    memcpy(&copath->cop_path.np_peer_addr, dest_sa,\n                                    sizeof(copath->cop_path.np_peer_addr));\n\n    conn->ifc_mig_path_id = copath - conn->ifc_paths;\n    conn->ifc_used_paths |= 1 << conn->ifc_mig_path_id;\n    conn->ifc_send_flags |= SF_SEND_PATH_CHAL << conn->ifc_mig_path_id;\n    LSQ_DEBUG(\"Schedule migration to path %hhu: will send PATH_CHALLENGE\",\n        conn->ifc_mig_path_id);\n}\n\n\nstatic void\nping_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"Ping alarm rang: schedule PING frame to be generated\");\n    conn->ifc_send_flags |= SF_SEND_PING;\n}\n\n\nstatic void\nretire_cid (struct ietf_full_conn *, struct conn_cid_elem *, lsquic_time_t);\n\n\nstatic void\nlog_scids (const struct ietf_full_conn *conn)\n{\n    const struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct conn_cid_elem *cce;\n    char flags[5];\n    unsigned idx;\n    int fi;\n\n    LSQ_DEBUG(\"Log SCID array: (n_cces %hhu; mask: 0x%hhX; \"\n                                        \"active: %hhu; limit: %hhu)\",\n        conn->ifc_conn.cn_n_cces, conn->ifc_conn.cn_cces_mask,\n        conn->ifc_active_cids_count, conn->ifc_active_cids_limit);\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        idx = cce - lconn->cn_cces;\n        fi = 0;\n        if (cce->cce_flags & CCE_PORT)  flags[fi++] = 'p';\n        if (cce->cce_flags & CCE_REG)   flags[fi++] = 'r';\n        if (cce->cce_flags & CCE_SEQNO) flags[fi++] = 's';\n        if (cce->cce_flags & CCE_USED)  flags[fi++] = 'u';\n        flags[fi]                                   = '\\0';\n        if (lconn->cn_cces_mask & (1 << idx))\n        {\n            if (cce->cce_flags & CCE_PORT)\n                LSQ_DEBUG( \"  %u: flags %-4s; port %hu\", idx, flags,\n                                                            cce->cce_port);\n            else if (cce->cce_flags & CCE_SEQNO)\n                LSQ_DEBUGC(\"  %u: flags %-4s; seqno: %u; %\"CID_FMT, idx,\n                            flags, cce->cce_seqno, CID_BITS(&cce->cce_cid));\n            else\n                LSQ_DEBUGC(\"  %u: flags %-4s; %\"CID_FMT, idx, flags,\n                                                    CID_BITS(&cce->cce_cid));\n        }\n        else\n                LSQ_DEBUG( \"  %u: flags %-4s; <empty>\",  idx, flags);\n    }\n}\n\n\n#define LOG_SCIDS(conn_) do {                                               \\\n    if (LSQ_LOG_ENABLED(LSQ_LOG_DEBUG))                                     \\\n        log_scids(conn_);                                                   \\\n} while (0)\n\n\nstatic void\nret_cids_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n    unsigned idx;\n\n    LSQ_DEBUG(\"The 'retire original CIDs' alarm rang\");\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        idx = cce - lconn->cn_cces;\n        if ((lconn->cn_cces_mask & (1 << idx))\n                            && (cce->cce_flags & (CCE_SEQNO|CCE_PORT)) == 0)\n        {\n            LSQ_DEBUG(\"retiring original CID at index %u\", idx);\n            retire_cid(conn, cce, now);\n        }\n    }\n    LOG_SCIDS(conn);\n}\n\n\nstatic ssize_t\ncrypto_stream_write (void *stream, const void *buf, size_t len)\n{\n    return lsquic_stream_write(stream, buf, len);\n}\n\n\nstatic int\ncrypto_stream_flush (void *stream)\n{\n    return lsquic_stream_flush(stream);\n}\n\n\nstatic ssize_t\ncrypto_stream_readf (void *stream,\n        size_t (*readf)(void *, const unsigned char *, size_t, int), void *ctx)\n{\n    return lsquic_stream_readf(stream, readf, ctx);\n}\n\n\nstatic int\ncrypto_stream_wantwrite (void *stream, int is_want)\n{\n    return lsquic_stream_wantwrite(stream, is_want);\n}\n\n\nstatic int\ncrypto_stream_wantread (void *stream, int is_want)\n{\n    return lsquic_stream_wantread(stream, is_want);\n}\n\n\nstatic enum enc_level\ncrypto_stream_enc_level (void *streamp)\n{\n    const struct lsquic_stream *stream = streamp;\n    return crypto_level(stream);\n}\n\n\nstatic const struct crypto_stream_if crypto_stream_if =\n{\n    .csi_write      = crypto_stream_write,\n    .csi_flush      = crypto_stream_flush,\n    .csi_readf      = crypto_stream_readf,\n    .csi_wantwrite  = crypto_stream_wantwrite,\n    .csi_wantread   = crypto_stream_wantread,\n    .csi_enc_level  = crypto_stream_enc_level,\n};\n\n\nstatic const struct lsquic_stream_if *unicla_if_ptr;\n\n\nstatic lsquic_stream_id_t\ngenerate_stream_id (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    lsquic_stream_id_t id;\n\n    id = conn->ifc_n_created_streams[sd]++;\n    return id << SIT_SHIFT\n         | sd << SD_SHIFT\n         | !!(conn->ifc_flags & IFC_SERVER)\n        ;\n}\n\n\nstatic lsquic_stream_id_t\navail_streams_count (const struct ietf_full_conn *conn, int server,\n                                                            enum stream_dir sd)\n{\n    enum stream_id_type sit;\n    lsquic_stream_id_t max_count;\n\n    sit = gen_sit(server, sd);\n    max_count = conn->ifc_max_allowed_stream_id[sit] >> SIT_SHIFT;\n    LSQ_DEBUG(\"sit-%u streams: max count: %\"PRIu64\"; created streams: %\"PRIu64,\n        sit, max_count, conn->ifc_n_created_streams[sd]);\n    if (max_count >= conn->ifc_n_created_streams[sd])\n        return max_count - conn->ifc_n_created_streams[sd];\n    else\n    {\n        assert(0);\n        return 0;\n    }\n}\n\n\n/* If `priority' is negative, this means that the stream is critical */\nstatic int\ncreate_uni_stream_out (struct ietf_full_conn *conn, int priority,\n        const struct lsquic_stream_if *stream_if, void *stream_if_ctx)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n\n    stream_id = generate_stream_id(conn, SD_UNI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub, stream_if,\n                stream_if_ctx, 0, conn->ifc_max_stream_data_uni,\n                SCF_IETF | (priority < 0 ? SCF_CRITICAL : 0));\n    if (!stream)\n        return -1;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return -1;\n    }\n    if (priority >= 0)\n        lsquic_stream_set_priority_internal(stream, priority);\n    else\n        ++conn->ifc_pub.n_special_streams;\n    lsquic_stream_call_on_new(stream);\n    return 0;\n}\n\n\nstatic int\ncreate_ctl_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_hcso_writer_if, &conn->ifc_hcso);\n}\n\n\nstatic int\ncreate_qenc_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_qeh_enc_sm_out_if, &conn->ifc_qeh);\n}\n\n\nstatic int\ncreate_qdec_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_qdh_dec_sm_out_if, &conn->ifc_qdh);\n}\n\n\nstatic int\ncreate_bidi_stream_out (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    enum stream_ctor_flags flags;\n\n    flags = SCF_IETF|SCF_DI_AUTOSWITCH;\n    if (conn->ifc_enpub->enp_settings.es_rw_once)\n        flags |= SCF_DISP_RW_ONCE;\n    if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n        flags |= SCF_DELAY_ONCLOSE;\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        flags |= SCF_HTTP;\n        if (conn->ifc_pii == &ext_prio_iter_if)\n            flags |= SCF_HTTP_PRIO;\n    }\n\n    stream_id = generate_stream_id(conn, SD_BIDI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                conn->ifc_enpub->enp_stream_if,\n                conn->ifc_enpub->enp_stream_if_ctx,\n                conn->ifc_settings->es_init_max_stream_data_bidi_local,\n                conn->ifc_cfg.max_stream_send, flags);\n    if (!stream)\n        return -1;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return -1;\n    }\n    lsquic_stream_call_on_new(stream);\n    return 0;\n}\n\n\nstatic struct lsquic_stream *\ncreate_push_stream (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    enum stream_ctor_flags flags;\n\n    assert((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) == (IFC_SERVER|IFC_HTTP));\n\n    flags = SCF_IETF|SCF_HTTP;\n    if (conn->ifc_enpub->enp_settings.es_rw_once)\n        flags |= SCF_DISP_RW_ONCE;\n    if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n        flags |= SCF_DELAY_ONCLOSE;\n\n    stream_id = generate_stream_id(conn, SD_UNI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                conn->ifc_enpub->enp_stream_if,\n                conn->ifc_enpub->enp_stream_if_ctx,\n                conn->ifc_settings->es_init_max_stream_data_bidi_local,\n                conn->ifc_cfg.max_stream_send, flags);\n    if (!stream)\n        return NULL;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return NULL;\n    }\n    return stream;\n}\n\n\n/* This function looks through the SCID array searching for an available\n * slot. If it finds an available slot it will\n *  1. generate an SCID,\n *  2. mark with latest seqno,\n *  3. increment seqno,\n *  4. turn on CCE_SEQNO flag,\n *  5. turn on flag given through flag paramter,\n *  6. add cce to mask, and\n *  7. add timestamp for when slot is new available for CID generation.\n */\nstatic struct conn_cid_elem *\nietf_full_conn_add_scid (struct ietf_full_conn *conn,\n                            struct lsquic_engine_public *enpub,\n                            enum conn_cce_flags flags,\n                            lsquic_time_t now)\n{\n    struct conn_cid_elem *cce;\n    struct lsquic_conn *lconn = &conn->ifc_conn;\n    lsquic_time_t *min_timestamp;\n    int i;\n\n    if (enpub->enp_settings.es_scid_len)\n    {\n        for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n            if (!(lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces))))\n                break;\n    }\n    else if (0 == lconn->cn_cces_mask)\n        cce = lconn->cn_cces;\n    else\n        cce = END_OF_CCES(lconn);\n\n    if (cce >= END_OF_CCES(lconn))\n    {\n        LSQ_LOG1(LSQ_LOG_DEBUG, \"cannot find slot for new SCID\");\n        return NULL;\n    }\n\n    if (enpub->enp_settings.es_scid_len)\n        enpub->enp_generate_scid(enpub->enp_gen_scid_ctx, lconn, &cce->cce_cid,\n                                            enpub->enp_settings.es_scid_len);\n\n    cce->cce_seqno = conn->ifc_scid_seqno++;\n    cce->cce_flags |= CCE_SEQNO | flags;\n    lconn->cn_cces_mask |= 1 << (cce - lconn->cn_cces);\n    ++conn->ifc_active_cids_count;\n    if (enpub->enp_settings.es_scid_iss_rate)\n    {\n        min_timestamp = &conn->ifc_scid_timestamp[0];\n        for (i = 1; i < lconn->cn_n_cces; i++)\n            if (conn->ifc_scid_timestamp[i] < *min_timestamp)\n                    min_timestamp = &conn->ifc_scid_timestamp[i];\n        *min_timestamp = now;\n    }\n    LSQ_LOG1C(LSQ_LOG_DEBUG, \"generated and assigned SCID %\"CID_FMT,\n                                                    CID_BITS(&cce->cce_cid));\n    return cce;\n}\n\n\n/* From [draft-ietf-quic-transport-25] Section 17.3.1:\n *  \" endpoints MUST disable their use of the spin bit for a random selection\n *  \" of at least one in every 16 network paths, or for one in every 16\n *  \" connection IDs.\n */\nstatic void\nmaybe_enable_spin (struct ietf_full_conn *conn, struct conn_path *cpath)\n{\n    uint8_t nyb;\n\n    if (conn->ifc_settings->es_spin\n                    && lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand))\n    {\n        cpath->cop_flags |= COP_SPIN_BIT;\n        cpath->cop_spin_bit = 0;\n        LSQ_DEBUG(\"spin bit enabled on path %hhu\", cpath->cop_path.np_path_id);\n    }\n    else\n    {\n        /* \" It is RECOMMENDED that endpoints set the spin bit to a random\n         * \" value either chosen independently for each packet or chosen\n         * \" independently for each connection ID.\n         * (ibid.)\n         */\n        cpath->cop_flags &= ~COP_SPIN_BIT;\n        nyb = lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand);\n        cpath->cop_spin_bit = nyb & 1;\n        LSQ_DEBUG(\"spin bit disabled %s on path %hhu; random spin bit \"\n            \"value is %hhu\",\n            !conn->ifc_settings->es_spin ? \"via settings\" : \"randomly\",\n            cpath->cop_path.np_path_id, cpath->cop_spin_bit);\n    }\n}\n\n\nstatic int\nietf_full_conn_init (struct ietf_full_conn *conn,\n           struct lsquic_engine_public *enpub, unsigned flags, int ecn)\n{\n    if (flags & IFC_SERVER)\n        conn->ifc_conn.cn_if = ietf_full_conn_iface_ptr;\n    else\n        conn->ifc_conn.cn_if = ietf_full_conn_prehsk_iface_ptr;\n    if (enpub->enp_settings.es_scid_len)\n        assert(CN_SCID(&conn->ifc_conn)->len);\n    conn->ifc_enpub = enpub;\n    conn->ifc_settings = &enpub->enp_settings;\n    conn->ifc_pub.lconn = &conn->ifc_conn;\n    conn->ifc_pub.send_ctl = &conn->ifc_send_ctl;\n    conn->ifc_pub.enpub = enpub;\n    conn->ifc_pub.mm = &enpub->enp_mm;\n#if LSQUIC_CONN_STATS\n    conn->ifc_pub.conn_stats = &conn->ifc_stats;\n#endif\n    conn->ifc_pub.path = CUR_NPATH(conn);\n    TAILQ_INIT(&conn->ifc_pub.sending_streams);\n    TAILQ_INIT(&conn->ifc_pub.read_streams);\n    TAILQ_INIT(&conn->ifc_pub.write_streams);\n    TAILQ_INIT(&conn->ifc_pub.service_streams);\n    STAILQ_INIT(&conn->ifc_stream_ids_to_ss);\n    TAILQ_INIT(&conn->ifc_to_retire);\n\n    lsquic_alarmset_init(&conn->ifc_alset, &conn->ifc_conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_IDLE, idle_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_ACK_APP, ack_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PING, ping_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_HANDSHAKE, handshake_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_CID_THROT, cid_throt_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_0, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_1, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_2, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_3, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_BLOCKED_KA, blocked_ka_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_MTU_PROBE, mtu_probe_alarm_expired, conn);\n    /* For Init and Handshake, we don't expect many ranges at all.  For\n     * the regular receive history, set limit to a value that would never\n     * be reached under normal circumstances, yet small enough that would\n     * use little memory when under attack and be robust (fast).  The\n     * value 1000 limits receive history to about 16KB.\n     */\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_INIT], 1, 10);\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_HSK], 1, 10);\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_APP], 1, 1000);\n    lsquic_send_ctl_init(&conn->ifc_send_ctl, &conn->ifc_alset, enpub,\n        flags & IFC_SERVER ? &server_ver_neg : &conn->ifc_u.cli.ifcli_ver_neg,\n        &conn->ifc_pub, SC_IETF|SC_NSTP|(ecn ? SC_ECN : 0));\n    lsquic_cfcw_init(&conn->ifc_pub.cfcw, &conn->ifc_pub,\n                                        conn->ifc_settings->es_init_max_data);\n    conn->ifc_pub.all_streams = lsquic_hash_create();\n    if (!conn->ifc_pub.all_streams)\n        return -1;\n    conn->ifc_pub.u.ietf.qeh = &conn->ifc_qeh;\n    conn->ifc_pub.u.ietf.qdh = &conn->ifc_qdh;\n    conn->ifc_pub.u.ietf.hcso = &conn->ifc_hcso;\n\n    conn->ifc_peer_hq_settings.header_table_size     = HQ_DF_QPACK_MAX_TABLE_CAPACITY;\n    conn->ifc_peer_hq_settings.qpack_blocked_streams = HQ_DF_QPACK_BLOCKED_STREAMS;\n\n    conn->ifc_flags = flags | IFC_FIRST_TICK;\n    conn->ifc_max_ack_packno[PNS_INIT] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ack_packno[PNS_HSK] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ack_packno[PNS_APP] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ackable_packno_in = 0;\n    conn->ifc_paths[0].cop_path.np_path_id = 0;\n    conn->ifc_paths[1].cop_path.np_path_id = 1;\n    conn->ifc_paths[2].cop_path.np_path_id = 2;\n    conn->ifc_paths[3].cop_path.np_path_id = 3;\n#define valid_stream_id(v) ((v) <= VINT_MAX_VALUE)\n    conn->ifc_max_req_id = VINT_MAX_VALUE + 1;\n    conn->ifc_ping_unretx_thresh = 20;\n    conn->ifc_max_retx_since_last_ack = MAX_RETR_PACKETS_SINCE_LAST_ACK;\n    conn->ifc_max_ack_delay = ACK_TIMEOUT;\n    if (conn->ifc_settings->es_noprogress_timeout)\n        conn->ifc_mflags |= MF_NOPROG_TIMEOUT;\n    if (conn->ifc_settings->es_ext_http_prio)\n        conn->ifc_pii = &ext_prio_iter_if;\n    else\n        conn->ifc_pii = &orig_prio_iter_if;\n    return 0;\n}\n\n\nstruct lsquic_conn *\nlsquic_ietf_full_conn_client_new (struct lsquic_engine_public *enpub,\n           unsigned versions, unsigned flags,\n           const char *hostname, unsigned short base_plpmtu, int is_ipv4,\n           const unsigned char *sess_resume, size_t sess_resume_sz,\n           const unsigned char *token, size_t token_sz, void* peer_ctx)\n{\n    const struct transport_params *params;\n    const struct enc_session_funcs_iquic *esfi;\n    struct ietf_full_conn *conn;\n    enum lsquic_version ver, sess_resume_version;\n    lsquic_time_t now;\n\n    conn = calloc(1, sizeof(*conn));\n    if (!conn)\n        goto err0;\n    now = lsquic_time_now();\n    /* Set the flags early so that correct CID is used for logging */\n    conn->ifc_conn.cn_flags |= LSCONN_IETF;\n    conn->ifc_conn.cn_cces = conn->ifc_cces;\n    conn->ifc_conn.cn_n_cces = sizeof(conn->ifc_cces)\n                                                / sizeof(conn->ifc_cces[0]);\n    if (!ietf_full_conn_add_scid(conn, enpub, CCE_USED, now))\n        goto err1;\n    conn->ifc_conn.cn_logid = *CN_SCID(&conn->ifc_conn);\n    assert(versions);\n    versions &= LSQUIC_IETF_VERSIONS;\n    if (versions & (1 << LSQVER_I001))\n        ver = LSQVER_I001;\n    else\n        ver = highest_bit_set(versions);\n    if (sess_resume)\n    {\n        sess_resume_version = lsquic_sess_resume_version(sess_resume, sess_resume_sz);\n        if (sess_resume_version < N_LSQVER && ((1 << sess_resume_version) & versions))\n            ver = sess_resume_version;\n    }\n    esfi = select_esf_iquic_by_ver(ver);\n\n    if (0 != ietf_full_conn_init(conn, enpub, flags,\n                                                enpub->enp_settings.es_ecn))\n        goto err2;\n\n    if (base_plpmtu)\n        conn->ifc_paths[0].cop_path.np_pack_size\n                                = base_plpmtu - TRANSPORT_OVERHEAD(!is_ipv4);\n    else\n        conn->ifc_paths[0].cop_path.np_pack_size\n                                = calc_base_packet_size(conn, !is_ipv4);\n\n    if (token)\n    {\n        if (0 != lsquic_send_ctl_set_token(&conn->ifc_send_ctl, token,\n                                                                token_sz))\n            goto err2;\n    }\n\n    /* Do not infer anything about server limits before processing its\n     * transport parameters.\n     */\n    conn->ifc_max_streams_in[SD_BIDI] = enpub->enp_settings.es_max_streams_in;\n    conn->ifc_max_allowed_stream_id[SIT_BIDI_SERVER] =\n        enpub->enp_settings.es_max_streams_in << SIT_SHIFT;\n\n    if (flags & IFC_HTTP)\n    {\n        if (enpub->enp_settings.es_support_push && CLIENT_PUSH_SUPPORT)\n            conn->ifc_max_streams_in[SD_UNI]\n                            = MAX(3, enpub->enp_settings.es_max_streams_in);\n        else\n            conn->ifc_max_streams_in[SD_UNI] = 3;\n    }\n    else\n        conn->ifc_max_streams_in[SD_UNI] = enpub->enp_settings.es_max_streams_in;\n    conn->ifc_max_allowed_stream_id[SIT_UNI_SERVER]\n                                = conn->ifc_max_streams_in[SD_UNI] << SIT_SHIFT;\n\n    init_ver_neg(conn, versions, &ver);\n    assert(ver == conn->ifc_u.cli.ifcli_ver_neg.vn_ver);\n    if (conn->ifc_settings->es_handshake_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_HANDSHAKE,\n                    lsquic_time_now() + conn->ifc_settings->es_handshake_to);\n    conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n    if (conn->ifc_idle_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, now + conn->ifc_idle_to);\n    if (enpub->enp_settings.es_support_push && CLIENT_PUSH_SUPPORT)\n    {\n        conn->ifc_u.cli.ifcli_flags |= IFCLI_PUSH_ENABLED;\n        conn->ifc_u.cli.ifcli_max_push_id = 100;\n        LSQ_DEBUG(\"push enabled: set MAX_PUSH_ID to %\"PRIu64,\n                                            conn->ifc_u.cli.ifcli_max_push_id);\n    }\n    conn->ifc_conn.cn_pf = select_pf_by_ver(ver);\n    conn->ifc_conn.cn_esf_c = select_esf_common_by_ver(ver);\n    conn->ifc_conn.cn_esf.i = esfi;\n    lsquic_generate_cid(CUR_DCID(conn), 0);\n    conn->ifc_conn.cn_enc_session =\n            conn->ifc_conn.cn_esf.i->esfi_create_client(hostname,\n                conn->ifc_enpub, &conn->ifc_conn, CUR_DCID(conn),\n                &conn->ifc_u.cli.ifcli_ver_neg,\n                (void **) conn->ifc_u.cli.crypto_streams, &crypto_stream_if,\n                sess_resume, sess_resume_sz, &conn->ifc_alset,\n                conn->ifc_max_streams_in[SD_UNI], peer_ctx);\n    if (!conn->ifc_conn.cn_enc_session)\n        goto err2;\n\n    conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT] = lsquic_stream_new_crypto(\n                ENC_LEV_INIT, &conn->ifc_pub, &lsquic_cry_sm_if,\n        conn->ifc_conn.cn_enc_session,\n        SCF_IETF|SCF_DI_AUTOSWITCH|SCF_CALL_ON_NEW|SCF_CRITICAL);\n    if (!conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT])\n        goto err3;\n    if (!lsquic_stream_get_ctx(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]))\n        goto err4;\n    conn->ifc_pub.packet_out_malo =\n                        lsquic_malo_create(sizeof(struct lsquic_packet_out));\n    if (!conn->ifc_pub.packet_out_malo)\n        goto err4;\n    conn->ifc_flags |= IFC_PROC_CRYPTO;\n\n    LSQ_DEBUG(\"negotiating version %s\",\n                        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver]);\n    conn->ifc_process_incoming_packet = process_incoming_packet_verneg;\n    conn->ifc_created = now;\n    LSQ_DEBUG(\"logging using client SCID\");\n    if (sess_resume && (params\n            = conn->ifc_conn.cn_esf.i->esfi_get_peer_transport_params(\n                            conn->ifc_conn.cn_enc_session), params != NULL))\n    {\n        LSQ_DEBUG(\"initializing transport parameters for 0RTT\");\n        if (0 != apply_trans_params(conn, params))\n            goto full_err;\n        if ((conn->ifc_flags & IFC_HTTP) && 0 != init_http(conn))\n            goto full_err;\n        conn->ifc_mflags |= MF_DOING_0RTT;\n    }\n    conn->ifc_flags |= IFC_CREATED_OK;\n    return &conn->ifc_conn;\n\n  err4:\n    lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]);\n  err3:\n    conn->ifc_conn.cn_esf.i->esfi_destroy(conn->ifc_conn.cn_enc_session);\n  err2:\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    if (conn->ifc_pub.all_streams)\n        lsquic_hash_destroy(conn->ifc_pub.all_streams);\n  err1:\n    free(conn);\n  err0:\n    return NULL;\n\n  full_err:\n    ietf_full_conn_ci_destroy(&conn->ifc_conn);\n    return NULL;\n}\n\n\ntypedef char mini_conn_does_not_have_more_cces[\n    sizeof(((struct ietf_mini_conn *)0)->imc_cces)\n    <= sizeof(((struct ietf_full_conn *)0)->ifc_cces) ? 1 : -1];\n\nstruct lsquic_conn *\nlsquic_ietf_full_conn_server_new (struct lsquic_engine_public *enpub,\n               unsigned flags, struct lsquic_conn *mini_conn)\n{\n    struct ietf_mini_conn *const imc = (void *) mini_conn;\n    struct ietf_full_conn *conn;\n    struct lsquic_packet_out *packet_out;\n    struct lsquic_packet_in *packet_in;\n    struct conn_cid_elem *cce;\n    int have_outgoing_ack;\n    lsquic_packno_t next_packno;\n    lsquic_time_t now;\n    enum packnum_space pns;\n    unsigned i;\n    struct ietf_mini_rechist mini_rechist;\n\n    conn = calloc(1, sizeof(*conn));\n    if (!conn)\n        goto err0;\n    now = lsquic_time_now();\n    conn->ifc_conn.cn_cces = conn->ifc_cces;\n    conn->ifc_conn.cn_n_cces = sizeof(conn->ifc_cces)\n                                                / sizeof(conn->ifc_cces[0]);\n    assert(conn->ifc_conn.cn_n_cces >= mini_conn->cn_n_cces);\n    conn->ifc_conn.cn_cur_cce_idx = mini_conn->cn_cur_cce_idx;\n    conn->ifc_conn.cn_cces_mask = mini_conn->cn_cces_mask;\n    for (cce = mini_conn->cn_cces, i = 0; cce < END_OF_CCES(mini_conn);\n                                                                    ++cce, ++i)\n        if ((1 << (cce - mini_conn->cn_cces)) & mini_conn->cn_cces_mask)\n        {\n            conn->ifc_conn.cn_cces[i].cce_cid   = cce->cce_cid;\n            conn->ifc_conn.cn_cces[i].cce_flags = cce->cce_flags;\n            if (cce->cce_flags & CCE_SEQNO)\n            {\n                if (cce->cce_seqno > conn->ifc_scid_seqno)\n                    conn->ifc_scid_seqno = cce->cce_seqno;\n                conn->ifc_conn.cn_cces[i].cce_seqno = cce->cce_seqno;\n                ++conn->ifc_active_cids_count;\n            }\n            conn->ifc_scid_timestamp[i] = now;\n        }\n    ++conn->ifc_scid_seqno;\n    conn->ifc_conn.cn_logid = mini_conn->cn_logid;\n    /* Set the flags early so that correct CID is used for logging */\n    conn->ifc_conn.cn_flags |= LSCONN_IETF | LSCONN_SERVER;\n\n    if (0 != ietf_full_conn_init(conn, enpub, flags,\n                                        lsquic_mini_conn_ietf_ecn_ok(imc)))\n        goto err1;\n    conn->ifc_pub.packet_out_malo =\n                        lsquic_malo_create(sizeof(struct lsquic_packet_out));\n    if (!conn->ifc_pub.packet_out_malo)\n        goto err1;\n    if (imc->imc_flags & IMC_IGNORE_INIT)\n        conn->ifc_flags |= IFC_IGNORE_INIT;\n    if (enpub->enp_settings.es_support_srej)\n        conn->ifc_send_flags |= SF_SEND_NEW_TOKEN;\n\n    conn->ifc_paths[0].cop_path = imc->imc_path;\n    conn->ifc_paths[0].cop_flags = COP_VALIDATED|COP_INITIALIZED|COP_ALLOW_MTU_PADDING;\n    conn->ifc_used_paths = 1 << 0;\n    maybe_enable_spin(conn, &conn->ifc_paths[0]);\n    if (imc->imc_flags & IMC_ADDR_VALIDATED)\n        lsquic_send_ctl_path_validated(&conn->ifc_send_ctl);\n    else\n        conn->ifc_mflags |= MF_VALIDATE_PATH;\n    conn->ifc_pub.bytes_out = imc->imc_bytes_out;\n    conn->ifc_pub.bytes_in = imc->imc_bytes_in;\n    if (imc->imc_flags & IMC_PATH_CHANGED)\n    {\n        LSQ_DEBUG(\"path changed during mini conn: schedule PATH_CHALLENGE\");\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL_PATH_0;\n    }\n\n    conn->ifc_max_streams_in[SD_BIDI]\n        = enpub->enp_settings.es_init_max_streams_bidi;\n    conn->ifc_max_allowed_stream_id[SIT_BIDI_CLIENT]\n        = conn->ifc_max_streams_in[SD_BIDI] << SIT_SHIFT;\n    conn->ifc_max_streams_in[SD_UNI]\n        = enpub->enp_settings.es_init_max_streams_uni;\n    conn->ifc_max_allowed_stream_id[SIT_UNI_CLIENT]\n        = conn->ifc_max_streams_in[SD_UNI] << SIT_SHIFT;\n    conn->ifc_conn.cn_version     = mini_conn->cn_version;\n    conn->ifc_conn.cn_flags      |= LSCONN_VER_SET;\n    conn->ifc_conn.cn_pf          = mini_conn->cn_pf;\n    conn->ifc_conn.cn_esf_c       = mini_conn->cn_esf_c;\n    conn->ifc_conn.cn_esf         = mini_conn->cn_esf;\n\n    if (enpub->enp_settings.es_support_push)\n        conn->ifc_u.ser.ifser_flags |= IFSER_PUSH_ENABLED;\n    if (flags & IFC_HTTP)\n    {\n        fiu_do_on(\"full_conn_ietf/promise_hash\", goto promise_alloc_failed);\n        conn->ifc_pub.u.ietf.promises = lsquic_hash_create();\n#if FIU_ENABLE\n  promise_alloc_failed:\n#endif\n        if (!conn->ifc_pub.u.ietf.promises)\n            goto err2;\n    }\n\n    assert(mini_conn->cn_flags & LSCONN_HANDSHAKE_DONE);\n    conn->ifc_conn.cn_flags      |= LSCONN_HANDSHAKE_DONE;\n    if (!(imc->imc_flags & IMC_HSK_DONE_SENT))\n    {\n        LSQ_DEBUG(\"HANDSHAKE_DONE not yet sent, will process CRYPTO frames\");\n        conn->ifc_flags |= IFC_PROC_CRYPTO;\n    }\n\n    conn->ifc_conn.cn_enc_session = mini_conn->cn_enc_session;\n    mini_conn->cn_enc_session     = NULL;\n    conn->ifc_conn.cn_esf_c->esf_set_conn(conn->ifc_conn.cn_enc_session,\n                                                            &conn->ifc_conn);\n    conn->ifc_process_incoming_packet = process_incoming_packet_fast;\n\n    conn->ifc_send_ctl.sc_cur_packno = imc->imc_next_packno - 1;\n    conn->ifc_incoming_ecn = imc->imc_incoming_ecn;\n    conn->ifc_pub.rtt_stats = imc->imc_rtt_stats;\n\n    conn->ifc_last_live_update = now;\n\n    lsquic_send_ctl_begin_optack_detection(&conn->ifc_send_ctl);\n\n    for (pns = 0; pns < IMICO_N_PNS; ++pns)\n    {\n        lsquic_imico_rechist_init(&mini_rechist, imc, pns);\n        if (pns < IMICO_N_PNS)\n        {\n            if (0 != lsquic_rechist_copy_ranges(&conn->ifc_rechist[pns],\n                                    &mini_rechist, lsquic_imico_rechist_first,\n                                    lsquic_imico_rechist_next))\n                goto err2;\n            conn->ifc_rechist[pns].rh_largest_acked_received\n                                                = imc->imc_largest_recvd[pns];\n        }\n    }\n\n    /* Mini connection sends out packets 0, 1, 2... and so on.  It deletes\n     * packets that have been successfully sent and acked or those that have\n     * been lost.  We take ownership of all packets in mc_packets_out; those\n     * that are not on the list are recorded in fc_send_ctl.sc_senhist.\n     */\n    have_outgoing_ack = 0;\n    next_packno = ~0ULL;\n    /* mini conn may drop Init packets, making gaps; don't warn about them: */\n    conn->ifc_send_ctl.sc_senhist.sh_flags |= SH_GAP_OK;\n    while ((packet_out = TAILQ_FIRST(&imc->imc_packets_out)))\n    {\n        TAILQ_REMOVE(&imc->imc_packets_out, packet_out, po_next);\n\n        /* Holes in the sequence signify no-longer-relevant Initial packets or\n         * ACKed or lost packets.\n         */\n        ++next_packno;\n        for ( ; next_packno < packet_out->po_packno; ++next_packno)\n        {\n            lsquic_senhist_add(&conn->ifc_send_ctl.sc_senhist, next_packno);\n            conn->ifc_send_ctl.sc_senhist.sh_warn_thresh = next_packno;\n        }\n\n        packet_out->po_path = CUR_NPATH(conn);\n        if (imc->imc_sent_packnos & (1ULL << packet_out->po_packno))\n        {\n            LSQ_DEBUG(\"got sent packet_out %\"PRIu64\" from mini\",\n                                                   packet_out->po_packno);\n            if (0 != lsquic_send_ctl_sent_packet(&conn->ifc_send_ctl,\n                                                             packet_out))\n            {\n                LSQ_WARN(\"could not add packet %\"PRIu64\" to sent set: %s\",\n                    packet_out->po_packno, strerror(errno));\n                goto err2;\n            }\n        }\n        else\n        {\n            LSQ_DEBUG(\"got unsent packet_out %\"PRIu64\" from mini (will send)\",\n                                                   packet_out->po_packno);\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n            have_outgoing_ack |= packet_out->po_frame_types &\n                                                (1 << QUIC_FRAME_ACK);\n        }\n    }\n    conn->ifc_send_ctl.sc_senhist.sh_flags &= ~SH_GAP_OK;\n    /* ...Yes, that's a bunch of little annoying steps to suppress the gap\n     * warnings, but it would have been even more annoying (and expensive)\n     * to add packet renumbering logic to the mini conn.\n     */\n\n    for (pns = 0; pns < IMICO_N_PNS; ++pns)\n        for (i = 0; i < 4; ++i)\n        {\n            conn->ifc_ecn_counts_in[pns][i]  = imc->imc_ecn_counts_in[pns][i];\n        }\n\n    if (0 != handshake_ok(&conn->ifc_conn))\n        goto err3;\n\n    LSQ_DEBUG(\"Calling on_new_conn callback\");\n    conn->ifc_conn.cn_conn_ctx = conn->ifc_enpub->enp_stream_if->on_new_conn(\n                        conn->ifc_enpub->enp_stream_if_ctx, &conn->ifc_conn);\n    conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n\n    conn->ifc_created = now;\n    if (conn->ifc_idle_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE,\n                                        now + conn->ifc_idle_to);\n    while ((packet_in = TAILQ_FIRST(&imc->imc_app_packets)))\n    {\n        TAILQ_REMOVE(&imc->imc_app_packets, packet_in, pi_next);\n        LSQ_DEBUG(\"inherit packet %\"PRIu64\" from mini conn\",\n                                                        packet_in->pi_packno);\n        ietf_full_conn_ci_packet_in(&conn->ifc_conn, packet_in);\n        lsquic_packet_in_put(conn->ifc_pub.mm, packet_in);\n    }\n\n    LSQ_DEBUG(\"logging using %s SCID\",\n        LSQUIC_LOG_CONN_ID == CN_SCID(&conn->ifc_conn) ? \"server\" : \"client\");\n    conn->ifc_flags |= IFC_CREATED_OK;\n    return &conn->ifc_conn;\n\n  err3:\n    ietf_full_conn_ci_destroy(&conn->ifc_conn);\n    return NULL;\n\n  err2:\n    lsquic_malo_destroy(conn->ifc_pub.packet_out_malo);\n  err1:\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    if (conn->ifc_pub.all_streams)\n        lsquic_hash_destroy(conn->ifc_pub.all_streams);\n    free(conn);\n  err0:\n    return NULL;\n}\n\n\nstatic int\nshould_generate_ack (struct ietf_full_conn *conn,\n                                            enum ifull_conn_flags ack_queued)\n{\n    unsigned lost_acks;\n\n    /* Need to set which ACKs are queued because generate_ack_frame() does not\n     * generate ACKs unconditionally.\n     */\n    lost_acks = lsquic_send_ctl_lost_ack(&conn->ifc_send_ctl);\n    if (lost_acks)\n        conn->ifc_flags |= lost_acks << IFCBIT_ACK_QUED_SHIFT;\n\n    return (conn->ifc_flags & ack_queued) != 0;\n}\n\n\nstatic int\nietf_full_conn_ci_can_write_ack (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    /* Follow opportunistic ACK logic.  Because this method is only used by\n     * buffered packets code path, no need to check whether anything is\n     * writing: we know it is.\n     */\n    return conn->ifc_n_slack_akbl[PNS_APP] > 0\n        && lsquic_send_ctl_can_send(&conn->ifc_send_ctl);\n}\n\n\nstatic unsigned\nietf_full_conn_ci_cancel_pending_streams (struct lsquic_conn *lconn, unsigned n)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    if (n > conn->ifc_n_delayed_streams)\n        conn->ifc_n_delayed_streams = 0;\n    else\n        conn->ifc_n_delayed_streams -= n;\n    return conn->ifc_n_delayed_streams;\n}\n\n\n/* Best effort.  If timestamp frame does not fit, oh well */\nstatic void\ngenerate_timestamp_frame (struct ietf_full_conn *conn,\n                    struct lsquic_packet_out *packet_out, lsquic_time_t now)\n{\n    uint64_t timestamp;\n    int w;\n\n    timestamp = (now - conn->ifc_created) >> TP_DEF_ACK_DELAY_EXP;\n    w = conn->ifc_conn.cn_pf->pf_gen_timestamp_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), timestamp);\n    if (w < 0)\n    {\n        LSQ_DEBUG(\"could not generate TIMESTAMP frame\");\n        return;\n    }\n    LSQ_DEBUG(\"generated TIMESTAMP(%\"PRIu64\" us) frame\",\n                                        timestamp << TP_DEF_ACK_DELAY_EXP);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated TIMESTAMP(%\"\n                    PRIu64\" us) frame\", timestamp << TP_DEF_ACK_DELAY_EXP);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_TIMESTAMP, packet_out->po_data_sz, w))\n    {\n        LSQ_DEBUG(\"%s: adding frame to packet failed: %d\", __func__, errno);\n        return;\n    }\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_TIMESTAMP;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n}\n\n\nstruct ietf_ack_state\n{\n    enum ifull_conn_flags   conn_flags;\n    enum send_flags         send_flags;\n    enum alarm_id_bit       armed_set;\n    unsigned                n_slack_akbl;\n    unsigned                n_slack_all;\n    unsigned char           unretx_thresh;\n};\n\n\ntypedef char ack_state_size[sizeof(struct ietf_ack_state)\n                                    <= sizeof(struct ack_state) ? 1 : - 1];\n\nstatic void\nietf_full_conn_ci_ack_snapshot (struct lsquic_conn *lconn,\n                                                    struct ack_state *opaque)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct ietf_ack_state *const ack_state = (struct ietf_ack_state *) opaque;\n\n    ack_state->conn_flags   = conn->ifc_flags;\n    ack_state->send_flags   = conn->ifc_send_flags;\n    ack_state->armed_set    = conn->ifc_alset.as_armed_set;\n    ack_state->n_slack_akbl = conn->ifc_n_slack_akbl[PNS_APP];\n    ack_state->n_slack_all  = conn->ifc_n_slack_all;\n    ack_state->unretx_thresh= conn->ifc_ping_unretx_thresh;\n    LSQ_DEBUG(\"take ACK snapshot\");\n}\n\n\nstatic void\nietf_full_conn_ci_ack_rollback (struct lsquic_conn *lconn,\n                                                    struct ack_state *opaque)\n{\n    struct ietf_ack_state *const ack_state = (struct ietf_ack_state *) opaque;\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    conn->ifc_flags &= ~(IFC_ACK_HAD_MISS|IFC_ACK_QUED_APP);\n    conn->ifc_flags |= (IFC_ACK_HAD_MISS|IFC_ACK_QUED_APP)\n                                        & ack_state->conn_flags;\n\n    conn->ifc_send_flags &= ~SF_SEND_PING;\n    conn->ifc_send_flags |= SF_SEND_PING & ack_state->send_flags;\n\n    conn->ifc_alset.as_armed_set &= ~ALBIT_ACK_APP;\n    conn->ifc_alset.as_armed_set |= ALBIT_ACK_APP & ack_state->armed_set;\n\n    conn->ifc_n_slack_akbl[PNS_APP]     = ack_state->n_slack_akbl;\n    conn->ifc_n_slack_all               = ack_state->n_slack_all;\n    conn->ifc_ping_unretx_thresh        = ack_state->unretx_thresh;\n\n    LSQ_DEBUG(\"roll back ACK state\");\n}\n\n\nstatic int\ngenerate_ack_frame_for_pns (struct ietf_full_conn *conn,\n                struct lsquic_packet_out *packet_out, enum packnum_space pns,\n                lsquic_time_t now)\n{\n    const uint64_t *ecn_counts;\n    int has_missing, w;\n\n    if (conn->ifc_incoming_ecn\n                        && lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n        ecn_counts = conn->ifc_ecn_counts_in[pns];\n    else if ((conn->ifc_mflags & MF_SEND_WRONG_COUNTS) && pns == PNS_APP)\n    {\n        /* We try once.  A more advanced version would wait until we get a\n         * packet from peer and only then stop.\n         */\n        conn->ifc_mflags &= ~MF_SEND_WRONG_COUNTS;\n        ecn_counts = conn->ifc_ecn_counts_in[pns];\n    }\n    else\n        ecn_counts = NULL;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_ack_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            (gaf_rechist_first_f)        lsquic_rechist_first,\n            (gaf_rechist_next_f)         lsquic_rechist_next,\n            (gaf_rechist_largest_recv_f) lsquic_rechist_largest_recv,\n            &conn->ifc_rechist[pns], now, &has_missing, &packet_out->po_ack2ed,\n            ecn_counts);\n    if (w < 0) {\n        ABORT_ERROR(\"%s generating ACK frame failed: %d\", lsquic_pns2str[pns], errno);\n        return -1;\n    }\n    CONN_STATS(out.acks, 1);\n    char buf[0x100];\n    lsquic_hexstr(packet_out->po_data + packet_out->po_data_sz, w, buf, sizeof(buf));\n    LSQ_DEBUG(\"ACK bytes: %s\", buf);\n    EV_LOG_GENERATED_ACK_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    lsquic_send_ctl_scheduled_ack(&conn->ifc_send_ctl, pns,\n                                                    packet_out->po_ack2ed);\n\n    // NOTE: Add a PING frame after ACK frame before HANDSHAKE_DONE, in a hacky way\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        && packet_out->po_data_sz + w < packet_out->po_n_alloc)\n    {\n        LSQ_DEBUG(\"add a PING frame before HANDSHAKE_DONE\");\n        *(packet_out->po_data + packet_out->po_data_sz + w) = '\\x01';\n        ++w;\n    }\n\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_ACK;\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_ACK, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n    if (has_missing && !(conn->ifc_mflags & MF_IGNORE_MISSING))\n        conn->ifc_flags |= IFC_ACK_HAD_MISS;\n    else\n        conn->ifc_flags &= ~IFC_ACK_HAD_MISS;\n    LSQ_DEBUG(\"Put %d bytes of ACK frame into packet %\" PRIu64\n              \" on outgoing queue\", w, packet_out->po_packno);\n    if (conn->ifc_n_cons_unretx >= conn->ifc_ping_unretx_thresh &&\n                !lsquic_send_ctl_have_outgoing_retx_frames(&conn->ifc_send_ctl))\n    {\n        LSQ_DEBUG(\"schedule PING frame after %u non-retx \"\n                                    \"packets sent\", conn->ifc_n_cons_unretx);\n        conn->ifc_send_flags |= SF_SEND_PING;\n        /* This gives a range [12, 27]: */\n        conn->ifc_ping_unretx_thresh = 12\n                    + lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand);\n    }\n\n    conn->ifc_n_slack_akbl[pns] = 0;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << pns);\n    if (pns == PNS_APP)\n    {\n        conn->ifc_n_slack_all = 0;\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n    }\n    lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n    LSQ_DEBUG(\"%s ACK state reset\", lsquic_pns2str[pns]);\n\n    if (pns == PNS_APP && (conn->ifc_flags & IFC_TIMESTAMPS))\n        generate_timestamp_frame(conn, packet_out, now);\n\n    return 0;\n}\n\n\n/* Return number of packets scheduled or 0 on error */\nstatic unsigned\ngenerate_ack_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    enum packnum_space pns;\n    unsigned count;\n    int s;\n\n    count = 0;\n    for (pns = 0; pns < N_PNS; ++pns)\n        if (conn->ifc_flags & (IFC_ACK_QUED_INIT << pns))\n        {\n            packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl,\n                                                        0, pns, CUR_NPATH(conn));\n            if (!packet_out)\n            {\n                ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n                return 0;\n            }\n            s = generate_ack_frame_for_pns(conn, packet_out, pns, now);\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n            if (s != 0)\n                return 0;\n            ++count;\n        }\n\n    return count;\n}\n\n\nstatic struct lsquic_packet_out *\nget_writeable_packet_on_path (struct ietf_full_conn *conn,\n                    unsigned need_at_least, const struct network_path *path,\n                    int regen_match)\n{\n    struct lsquic_packet_out *packet_out;\n    int is_err;\n\n    packet_out = lsquic_send_ctl_get_writeable_packet(&conn->ifc_send_ctl,\n                            PNS_APP, need_at_least, path, regen_match, &is_err);\n    if (!packet_out && is_err)\n        ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n    return packet_out;\n}\n\n\nstatic struct lsquic_packet_out *\nget_writeable_packet (struct ietf_full_conn *conn, unsigned need_at_least)\n{\n    return get_writeable_packet_on_path(conn, need_at_least,\n                                                        CUR_NPATH(conn), 0);\n}\n\n\nstatic void\ngenerate_max_data_frame (struct ietf_full_conn *conn)\n{\n    const uint64_t offset = lsquic_cfcw_get_fc_recv_off(&conn->ifc_pub.cfcw);\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_max_data_frame_size(offset);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n    w = conn->ifc_conn.cn_pf->pf_gen_max_data_frame(\n                         packet_out->po_data + packet_out->po_data_sz,\n                         lsquic_packet_out_avail(packet_out), offset);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"Generating MAX_DATA frame failed\");\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte MAX_DATA frame (offset: %\"PRIu64\")\", w, offset);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated MAX_DATA frame, offset=%\"\n                                                                PRIu64, offset);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_MAX_DATA, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_frame_types |= QUIC_FTBIT_MAX_DATA;\n    conn->ifc_send_flags &= ~SF_SEND_MAX_DATA;\n    conn->ifc_last_max_data_off_sent = offset;\n}\n\n\nstatic void\ngenerate_new_token_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    const struct network_path *path;\n    ssize_t token_sz;\n    size_t need;\n    int w;\n    unsigned char token_buf[MAX_RETRY_TOKEN_LEN];\n\n    path = &conn->ifc_paths[conn->ifc_cur_path_id].cop_path;\n    token_sz = lsquic_tg_token_size(conn->ifc_enpub->enp_tokgen, TOKEN_RESUME,\n                                                            NP_PEER_SA(path));\n    need = conn->ifc_conn.cn_pf->pf_new_token_frame_size(token_sz);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    token_sz = lsquic_tg_generate_resume(conn->ifc_enpub->enp_tokgen, token_buf,\n                                        sizeof(token_buf), NP_PEER_SA(path));\n    if (token_sz < 0)\n    {\n        LSQ_WARN(\"could not generate resume token\");\n        conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN; /* Let's not try again */\n        return;\n    }\n\n    w = conn->ifc_conn.cn_pf->pf_gen_new_token_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), token_buf, token_sz);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating NEW_TOKEN frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte NEW_TOKEN frame\", w);\n    EV_LOG_GENERATED_NEW_TOKEN_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_NEW_TOKEN, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_NEW_TOKEN;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN;\n    (void) token_sz;\n}\n\n\nstatic int\ncan_issue_cids (const struct ietf_full_conn *conn)\n{\n    int can;\n\n    can = ((1 << conn->ifc_conn.cn_n_cces) - 1\n                                            != conn->ifc_conn.cn_cces_mask)\n       && conn->ifc_enpub->enp_settings.es_scid_len\n       && conn->ifc_active_cids_count < conn->ifc_active_cids_limit;\n    LSQ_DEBUG(\"can issue CIDs: %d (n_cces %hhu; mask: 0x%hhX; \"\n                                        \"active: %hhu; limit: %hhu)\",\n        can, conn->ifc_conn.cn_n_cces, conn->ifc_conn.cn_cces_mask,\n        conn->ifc_active_cids_count, conn->ifc_active_cids_limit);\n    return can;\n}\n\n\nstatic int\ngenerate_new_cid_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_cid_elem *cce;\n    size_t need;\n    int w;\n    unsigned char token_buf[IQUIC_SRESET_TOKEN_SZ];\n\n    assert(conn->ifc_enpub->enp_settings.es_scid_len);\n\n    need = conn->ifc_conn.cn_pf->pf_new_connection_id_frame_size(\n            conn->ifc_scid_seqno, conn->ifc_enpub->enp_settings.es_scid_len);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    if (!(cce = ietf_full_conn_add_scid(conn, conn->ifc_enpub, 0, now)))\n    {\n        ABORT_WARN(\"cannot add a new SCID\");\n        return -1;\n    }\n\n    lsquic_tg_generate_sreset(conn->ifc_enpub->enp_tokgen, &cce->cce_cid,\n                                                                    token_buf);\n\n    if (0 != lsquic_engine_add_cid(conn->ifc_enpub, &conn->ifc_conn,\n                                                        cce - conn->ifc_cces))\n    {\n        ABORT_WARN(\"cannot track new SCID\");\n        return -1;\n    }\n\n    w = conn->ifc_conn.cn_pf->pf_gen_new_connection_id_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), cce->cce_seqno,\n            &cce->cce_cid, token_buf, sizeof(token_buf));\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating NEW_CONNECTION_ID frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUGC(\"generated %d-byte NEW_CONNECTION_ID frame (CID: %\"CID_FMT\")\",\n        w, CID_BITS(&cce->cce_cid));\n    EV_LOG_GENERATED_NEW_CONNECTION_ID_FRAME(LSQUIC_LOG_CONN_ID,\n        conn->ifc_conn.cn_pf, packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_NEW_CONNECTION_ID, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_NEW_CONNECTION_ID;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    if (!can_issue_cids(conn))\n    {\n        conn->ifc_send_flags &= ~SF_SEND_NEW_CID;\n        LSQ_DEBUG(\"All %u SCID slots have been assigned\",\n                                                conn->ifc_conn.cn_n_cces);\n    }\n\n    return 0;\n}\n\n\nstatic void\nmaybe_get_rate_available_scid_slot (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    const struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct conn_cid_elem *cce;\n    unsigned active_cid;\n    lsquic_time_t total_elapsed, elapsed_thresh, period, wait_time;\n\n    if (!conn->ifc_enpub->enp_settings.es_scid_iss_rate)\n    {\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n        return;\n    }\n\n    /* period: usec per cid */\n    period = (60 * 1000000) / conn->ifc_enpub->enp_settings.es_scid_iss_rate;\n    active_cid = 0;\n    total_elapsed = 0;\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        if ((cce->cce_flags & (CCE_SEQNO|CCE_PORT)) == CCE_SEQNO)\n        {\n            active_cid += 1;\n            /* When server is promoted, the timestamp may be larger than the\n             * first tick time.\n             */\n            if (now > conn->ifc_scid_timestamp[cce - lconn->cn_cces])\n                total_elapsed +=\n                        now - conn->ifc_scid_timestamp[cce - lconn->cn_cces];\n        }\n    }\n    elapsed_thresh = ((active_cid * (active_cid + 1)) / 2) * period;\n    /* compare total elapsed usec to elapsed usec threshold */\n    if (total_elapsed < elapsed_thresh)\n    {\n        wait_time = (elapsed_thresh - total_elapsed) / active_cid;\n        LSQ_DEBUG(\"cid_throt no SCID slots available (rate-limited), \"\n                    \"must wait %\"PRIu64\" usec\", wait_time);\n        lsquic_alarmset_set(&conn->ifc_alset, AL_CID_THROT, now + wait_time);\n        conn->ifc_send_flags &= ~SF_SEND_NEW_CID;\n    }\n    else\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n}\n\n\nstatic void\ngenerate_new_cid_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    int s;\n\n    do\n    {\n        s = generate_new_cid_frame(conn, now);\n        if (s < 0)\n            break;\n        if (conn->ifc_send_flags & SF_SEND_NEW_CID)\n            maybe_get_rate_available_scid_slot(conn, now);\n    }\n    while (conn->ifc_send_flags & SF_SEND_NEW_CID);\n    LOG_SCIDS(conn);\n}\n\n\nstatic int\ngenerate_retire_cid_frame (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    struct dcid_elem *dce;\n    size_t need;\n    int w;\n\n    dce = TAILQ_FIRST(&conn->ifc_to_retire);\n    assert(dce);\n\n    need = conn->ifc_conn.cn_pf->pf_retire_cid_frame_size(dce->de_seqno);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_retire_cid_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), dce->de_seqno);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating RETIRE_CONNECTION_ID frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated %d-byte RETIRE_CONNECTION_ID frame (seqno: %u)\",\n        w, dce->de_seqno);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated RETIRE_CONNECTION_ID \"\n                                            \"frame, seqno=%u\", dce->de_seqno);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                QUIC_FRAME_RETIRE_CONNECTION_ID, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_RETIRE_CONNECTION_ID;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    TAILQ_REMOVE(&conn->ifc_to_retire, dce, de_next_to_ret);\n    lsquic_malo_put(dce);\n\n    if (TAILQ_EMPTY(&conn->ifc_to_retire))\n        conn->ifc_send_flags &= ~SF_SEND_RETIRE_CID;\n\n    return 0;\n}\n\n\nstatic void\ngenerate_retire_cid_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    int s;\n\n    do\n        s = generate_retire_cid_frame(conn);\n    while (0 == s && (conn->ifc_send_flags & SF_SEND_RETIRE_CID));\n}\n\n\nstatic void\ngenerate_streams_blocked_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    struct lsquic_packet_out *packet_out;\n    uint64_t limit;\n    size_t need;\n    int w;\n\n    limit = conn->ifc_send.streams_blocked[sd];\n    need = conn->ifc_conn.cn_pf->pf_streams_blocked_frame_size(limit);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_streams_blocked_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), sd == SD_UNI, limit);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating STREAMS_BLOCKED frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte STREAMS_BLOCKED frame (uni: %d, \"\n                                \"limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte STREAMS_BLOCKED \"\n                \"frame (uni: %d, limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_STREAMS_BLOCKED, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_STREAM_BLOCKED;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    conn->ifc_send_flags &= ~(SF_SEND_STREAMS_BLOCKED << sd);\n}\n\n\nstatic void\ngenerate_streams_blocked_uni_frame (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    generate_streams_blocked_frame(conn, SD_UNI);\n}\n\n\nstatic void\ngenerate_streams_blocked_bidi_frame (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    generate_streams_blocked_frame(conn, SD_BIDI);\n}\n\n\nstatic void\ngenerate_max_streams_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    struct lsquic_packet_out *packet_out;\n    enum stream_id_type sit;\n    uint64_t limit;\n    size_t need;\n    int w;\n\n    limit = conn->ifc_closed_peer_streams[sd] + conn->ifc_max_streams_in[sd];\n    need = conn->ifc_conn.cn_pf->pf_max_streams_frame_size(limit);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_max_streams_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), sd, limit);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating MAX_STREAMS frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte MAX_STREAMS frame (uni: %d, \"\n                                \"limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte MAX_STREAMS \"\n                \"frame (uni: %d, limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_MAX_STREAMS, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_MAX_STREAMS;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    conn->ifc_send_flags &= ~(SF_SEND_MAX_STREAMS << sd);\n\n    sit = gen_sit(!(conn->ifc_flags & IFC_SERVER), sd);\n    LSQ_DEBUG(\"max_allowed_stream_id[ %u ] goes from %\"PRIu64\" to %\"PRIu64,\n        sit, conn->ifc_max_allowed_stream_id[ sit ], limit << SIT_SHIFT);\n    conn->ifc_max_allowed_stream_id[ sit ] = limit << SIT_SHIFT;\n}\n\n\nstatic void\ngenerate_max_streams_uni_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_max_streams_frame(conn, SD_UNI);\n}\n\n\nstatic void\ngenerate_max_streams_bidi_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_max_streams_frame(conn, SD_BIDI);\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_blocked_frame (struct ietf_full_conn *conn)\n{\n    const uint64_t offset = conn->ifc_pub.conn_cap.cc_blocked;\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_blocked_frame_size(offset);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_blocked_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), offset);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating BLOCKED frame failed: %d\", errno);\n        return 0;\n    }\n    LSQ_DEBUG(\"generated %d-byte BLOCKED frame (offset: %\"PRIu64\")\", w, offset);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated BLOCKED frame, offset=%\"\n                                                                PRIu64, offset);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_BLOCKED, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_BLOCKED;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    return 1;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_max_stream_data_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    uint64_t off;\n    int sz;\n\n    off = lsquic_stream_fc_recv_off_const(stream);\n    need = conn->ifc_conn.cn_pf->pf_max_stream_data_frame_size(stream->id, off);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n    sz = conn->ifc_conn.cn_pf->pf_gen_max_stream_data_frame(\n                         packet_out->po_data + packet_out->po_data_sz,\n                         lsquic_packet_out_avail(packet_out), stream->id, off);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"Generating MAX_STREAM_DATA frame failed\");\n        return 0;\n    }\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte MAX_STREAM_DATA \"\n        \"frame; stream_id: %\"PRIu64\"; offset: %\"PRIu64, sz, stream->id, off);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_MAX_STREAM_DATA, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_MAX_STREAM_DATA;\n    lsquic_stream_max_stream_data_sent(stream);\n    return 1;\n}\n\n\nstatic int\ngenerate_stop_sending_frame_by_id (struct ietf_full_conn *conn,\n                lsquic_stream_id_t stream_id, enum http_error_code error_code)\n{\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_stop_sending_frame_size(stream_id,\n                                                                    error_code);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_stop_sending_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            stream_id, error_code);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating STOP_SENDING frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated %d-byte STOP_SENDING frame (stream id: %\"PRIu64\", \"\n        \"error code: %u)\", w, stream_id, error_code);\n    EV_LOG_GENERATED_STOP_SENDING_FRAME(LSQUIC_LOG_CONN_ID, stream_id,\n                                                                error_code);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_STOP_SENDING, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_STOP_SENDING;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    return 0;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_stop_sending_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    if (0 == generate_stop_sending_frame_by_id(conn, stream->id, HEC_NO_ERROR))\n    {\n        lsquic_stream_ss_frame_sent(stream);\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic void\ngenerate_stop_sending_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct stream_id_to_ss *sits;\n\n    assert(conn->ifc_send_flags & SF_SEND_STOP_SENDING);\n\n    while (!STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n    {\n        sits = STAILQ_FIRST(&conn->ifc_stream_ids_to_ss);\n        if (0 == generate_stop_sending_frame_by_id(conn, sits->sits_stream_id,\n                                                        sits->sits_error_code))\n        {\n            STAILQ_REMOVE_HEAD(&conn->ifc_stream_ids_to_ss, sits_next);\n            free(sits);\n        }\n        else\n            break;\n    }\n\n    if (STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n        conn->ifc_send_flags &= ~SF_SEND_STOP_SENDING;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_rst_stream_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    lsquic_packet_out_t *packet_out;\n    unsigned need;\n    int sz;\n\n    need = conn->ifc_conn.cn_pf->pf_rst_frame_size(stream->id,\n                                    stream->tosend_off, stream->error_code);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for RESET_STREAM frame\");\n        return 0;\n    }\n    sz = conn->ifc_conn.cn_pf->pf_gen_rst_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out), stream->id,\n                            stream->tosend_off, stream->error_code);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"gen_rst_frame failed\");\n        return 0;\n    }\n    if (0 != lsquic_packet_out_add_stream(packet_out, conn->ifc_pub.mm, stream,\n                            QUIC_FRAME_RST_STREAM, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_RST_STREAM;\n    lsquic_stream_rst_frame_sent(stream);\n    LSQ_DEBUG(\"wrote RST: stream %\"PRIu64\"; offset %\"PRIu64\"; error code \"\n              \"%\"PRIu64, stream->id, stream->tosend_off, stream->error_code);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated RESET_STREAM: stream \"\n        \"%\"PRIu64\"; offset %\"PRIu64\"; error code %\"PRIu64, stream->id,\n        stream->tosend_off, stream->error_code);\n\n    return 1;\n}\n\n\nstatic int\nis_our_stream (const struct ietf_full_conn *conn,\n                                        const struct lsquic_stream *stream)\n{\n    const unsigned is_server = !!(conn->ifc_flags & IFC_SERVER);\n    return (1 & stream->id) == is_server;\n}\n\n\nstatic int\nis_peer_initiated (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    const unsigned is_server = !!(conn->ifc_flags & IFC_SERVER);\n    return (1 & stream_id) != is_server;\n}\n\n\nstatic void\nsched_max_bidi_streams (void *conn_p)\n{\n    struct ietf_full_conn *conn = conn_p;\n\n    conn->ifc_send_flags |= SF_SEND_MAX_STREAMS_BIDI;\n    conn->ifc_delayed_send &= ~SF_SEND_MAX_STREAMS_BIDI;\n    LSQ_DEBUG(\"schedule MAX_STREAMS frame for bidirectional streams (was \"\n        \"delayed)\");\n}\n\n\n/* Do not allow peer to open more streams while QPACK decoder stream has\n * unsent data.\n */\nstatic int\ncan_give_peer_streams_credit (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    /* This logic only applies to HTTP servers. */\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) != (IFC_SERVER|IFC_HTTP))\n        return 1;\n    /* HTTP client does not open unidirectional streams (other than the\n     * standard three), not applicable.\n     */\n    if (SD_UNI == sd)\n        return 1;\n    if (conn->ifc_delayed_send & (SF_SEND_MAX_STREAMS << sd))\n        return 0;\n    if (lsquic_qdh_arm_if_unsent(&conn->ifc_qdh, sched_max_bidi_streams, conn))\n    {\n        LSQ_DEBUG(\"delay sending more streams credit to peer until QPACK \"\n            \"decoder sends unsent data\");\n        conn->ifc_delayed_send |= SF_SEND_MAX_STREAMS << sd;\n        return 0;\n    }\n    else\n        return 1;\n}\n\n\n/* Because stream IDs are distributed unevenly, it is more efficient to\n * maintain four sets of closed stream IDs.\n */\nstatic void\nconn_mark_stream_closed (struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    lsquic_stream_id_t shifted_id;\n    uint64_t max_allowed, thresh;\n    enum stream_id_type idx;\n    enum stream_dir sd;\n\n    idx = stream_id & SIT_MASK;\n    shifted_id = stream_id >> SIT_SHIFT;\n\n    if (is_peer_initiated(conn, stream_id)\n            && !lsquic_set64_has(&conn->ifc_closed_stream_ids[idx], shifted_id))\n    {\n        sd = (stream_id >> SD_SHIFT) & 1;\n        ++conn->ifc_closed_peer_streams[sd];\n        if (0 == (conn->ifc_send_flags & (SF_SEND_MAX_STREAMS << sd)))\n        {\n            max_allowed = conn->ifc_max_allowed_stream_id[idx] >> SIT_SHIFT;\n            thresh = conn->ifc_closed_peer_streams[sd]\n                                            + conn->ifc_max_streams_in[sd] / 2;\n            if (thresh >= max_allowed && can_give_peer_streams_credit(conn, sd))\n            {\n                LSQ_DEBUG(\"closed incoming %sdirectional streams reached \"\n                    \"%\"PRIu64\", scheduled MAX_STREAMS frame\",\n                    sd == SD_UNI ? \"uni\" : \"bi\",\n                    conn->ifc_closed_peer_streams[sd]);\n                conn->ifc_send_flags |= SF_SEND_MAX_STREAMS << sd;\n            }\n        }\n    }\n\n    if (0 == lsquic_set64_add(&conn->ifc_closed_stream_ids[idx], shifted_id))\n        LSQ_DEBUG(\"marked stream %\"PRIu64\" as closed\", stream_id);\n    else\n        ABORT_ERROR(\"could not add element to set: %s\", strerror(errno));\n}\n\n\nstatic int\nconn_is_stream_closed (struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type idx = stream_id & SIT_MASK;\n    stream_id >>= SIT_SHIFT;\n    return lsquic_set64_has(&conn->ifc_closed_stream_ids[idx], stream_id);\n}\n\n\nstatic int\neither_side_going_away (const struct ietf_full_conn *conn)\n{\n    return (conn->ifc_flags & IFC_GOING_AWAY)\n        || (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY);\n}\n\n\nstatic void\nmaybe_create_delayed_streams (struct ietf_full_conn *conn)\n{\n    unsigned avail, delayed;\n\n    delayed = conn->ifc_n_delayed_streams;\n    if (0 == delayed)\n        return;\n\n    avail = ietf_full_conn_ci_n_avail_streams(&conn->ifc_conn);\n    while (avail > 0)\n    {\n        if (0 == create_bidi_stream_out(conn))\n        {\n            --avail;\n            --conn->ifc_n_delayed_streams;\n            if (0 == conn->ifc_n_delayed_streams)\n                break;\n        }\n        else\n        {\n            LSQ_INFO(\"cannot create BIDI stream\");\n            break;\n        }\n    }\n\n    LSQ_DEBUG(\"created %u delayed stream%.*s\",\n        delayed - conn->ifc_n_delayed_streams,\n        delayed - conn->ifc_n_delayed_streams != 1, \"s\");\n}\n\n\nstatic int\nhave_bidi_streams (const struct ietf_full_conn *conn)\n{\n    const struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                         el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (SIT_BIDI_CLIENT == (stream->id & SIT_MASK))\n            return 1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nconn_ok_to_close (const struct ietf_full_conn *conn)\n{\n    assert(conn->ifc_flags & IFC_CLOSING);\n    return !(conn->ifc_flags & IFC_SERVER)\n        || (conn->ifc_flags & IFC_RECV_CLOSE)\n        || (\n               !lsquic_send_ctl_have_outgoing_stream_frames(&conn->ifc_send_ctl)\n            && !have_bidi_streams(conn)\n            && !lsquic_send_ctl_have_unacked_stream_frames(\n                                                    &conn->ifc_send_ctl));\n}\n\n\nstatic void\nmaybe_close_conn (struct ietf_full_conn *conn)\n{\n    if ((conn->ifc_flags & (IFC_CLOSING|IFC_GOING_AWAY|IFC_SERVER))\n                                            == (IFC_GOING_AWAY|IFC_SERVER)\n        && !have_bidi_streams(conn))\n    {\n        conn->ifc_flags |= IFC_CLOSING|IFC_GOAWAY_CLOSE;\n        LSQ_DEBUG(\"maybe_close_conn: GOAWAY sent and no responses remain\");\n        if (conn_ok_to_close(conn))\n        {\n            conn->ifc_send_flags |= SF_SEND_CONN_CLOSE;\n            LSQ_DEBUG(\"maybe_close_conn: ok to close: \"\n                      \"schedule to send CONNECTION_CLOSE\");\n        }\n    }\n}\n\n\nstatic void\nservice_streams (struct ietf_full_conn *conn)\n{\n    struct lsquic_hash_elem *el;\n    lsquic_stream_t *stream, *next;\n\n    for (stream = TAILQ_FIRST(&conn->ifc_pub.service_streams); stream;\n                                                                stream = next)\n    {\n        next = TAILQ_NEXT(stream, next_service_stream);\n        if (stream->sm_qflags & SMQF_ABORT_CONN)\n            /* No need to unset this flag or remove this stream: the connection\n             * is about to be aborted.\n             */\n            ABORT_ERROR(\"aborted due to error in stream %\"PRIu64, stream->id);\n        if (stream->sm_qflags & SMQF_CALL_ONCLOSE)\n            lsquic_stream_call_on_close(stream);\n        if (stream->sm_qflags & SMQF_FREE_STREAM)\n        {\n            TAILQ_REMOVE(&conn->ifc_pub.service_streams, stream,\n                                                        next_service_stream);\n            if (!(stream->sm_bflags & SMBF_CRYPTO))\n            {\n                el = lsquic_hash_find(conn->ifc_pub.all_streams,\n                                            &stream->id, sizeof(stream->id));\n                if (el)\n                    lsquic_hash_erase(conn->ifc_pub.all_streams, el);\n                conn_mark_stream_closed(conn, stream->id);\n            }\n            else\n                assert(!(stream->sm_hash_el.qhe_flags & QHE_HASHED));\n            lsquic_stream_destroy(stream);\n        }\n    }\n\n    /* TODO: this chunk of code, too, should probably live elsewhere */\n    if (either_side_going_away(conn))\n    {\n        while (conn->ifc_n_delayed_streams)\n        {\n            --conn->ifc_n_delayed_streams;\n            LSQ_DEBUG(\"goaway mode: delayed stream results in null ctor\");\n            (void) conn->ifc_enpub->enp_stream_if->on_new_stream(\n                                    conn->ifc_enpub->enp_stream_if_ctx, NULL);\n        }\n        maybe_close_conn(conn);\n    }\n    else\n        maybe_create_delayed_streams(conn);\n}\n\n\nstatic int\nprocess_stream_ready_to_send (struct ietf_full_conn *conn,\n                                            struct lsquic_stream *stream)\n{\n    int r = 1;\n    if (stream->sm_qflags & SMQF_SEND_MAX_STREAM_DATA)\n        r &= generate_max_stream_data_frame(conn, stream);\n    if (stream->sm_qflags & SMQF_SEND_BLOCKED)\n        r &= lsquic_sendctl_gen_stream_blocked_frame(&conn->ifc_send_ctl, stream);\n    if (stream->sm_qflags & SMQF_SEND_RST)\n        r &= generate_rst_stream_frame(conn, stream);\n    if (stream->sm_qflags & SMQF_SEND_STOP_SENDING)\n        r &= generate_stop_sending_frame(conn, stream);\n    return r;\n}\n\n\nstatic void\nprocess_streams_ready_to_send (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    union prio_iter pi;\n\n    assert(!TAILQ_EMPTY(&conn->ifc_pub.sending_streams));\n\n    conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.sending_streams),\n        TAILQ_LAST(&conn->ifc_pub.sending_streams, lsquic_streams_tailq),\n        (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_send_stream),\n        &conn->ifc_pub, \"send\", NULL, NULL);\n\n    for (stream = conn->ifc_pii->pii_first(&pi); stream;\n                                    stream = conn->ifc_pii->pii_next(&pi))\n        if (!process_stream_ready_to_send(conn, stream))\n            break;\n\n    conn->ifc_pii->pii_cleanup(&pi);\n}\n\n\nstatic void\nietf_full_conn_ci_write_ack (struct lsquic_conn *lconn,\n                                        struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    generate_ack_frame_for_pns(conn, packet_out, PNS_APP, lsquic_time_now());\n}\n\n\nstatic int\nietf_full_conn_ci_want_datagram_write (struct lsquic_conn *lconn, int is_want)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    int old;\n\n    if (conn->ifc_flags & IFC_DATAGRAMS)\n    {\n        old = !!(conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE);\n        if (is_want)\n        {\n            conn->ifc_mflags |= MF_WANT_DATAGRAM_WRITE;\n            if (lsquic_send_ctl_can_send (&conn->ifc_send_ctl))\n                lsquic_engine_add_conn_to_tickable(conn->ifc_enpub,\n                                                             &conn->ifc_conn);\n        }\n        else\n            conn->ifc_mflags &= ~MF_WANT_DATAGRAM_WRITE;\n        LSQ_DEBUG(\"turn %s \\\"want datagram write\\\" flag\",\n                                                    is_want ? \"on\" : \"off\");\n        return old;\n    }\n    else\n        return -1;\n}\n\n\nstatic void\nietf_full_conn_ci_client_call_on_new (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    assert(conn->ifc_flags & IFC_CREATED_OK);\n    lconn->cn_conn_ctx = conn->ifc_enpub->enp_stream_if->on_new_conn(\n                                conn->ifc_enpub->enp_stream_if_ctx, lconn);\n}\n\n\nstatic void\nietf_full_conn_ci_close (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_dir sd;\n\n    if (!(conn->ifc_flags & IFC_CLOSING))\n    {\n        for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n        {\n            stream = lsquic_hashelem_getdata(el);\n            sd = (stream->id >> SD_SHIFT) & 1;\n            if (SD_BIDI == sd)\n                lsquic_stream_maybe_reset(stream, 0, 1);\n        }\n        conn->ifc_flags |= IFC_CLOSING;\n        if (conn_ok_to_close(conn))\n        {\n            conn->ifc_send_flags |= SF_SEND_CONN_CLOSE;\n            LSQ_DEBUG(\"ietf_full_conn_ci_close: ok to close: \"\n                      \"schedule to send CONNECTION_CLOSE\");\n        }\n        lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_abort (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    LSQ_INFO(\"User aborted connection\");\n    conn->ifc_flags |= IFC_ABORTED;\n    lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n}\n\n\nstatic void\nretire_dcid (struct ietf_full_conn *conn, struct dcid_elem **dce)\n{\n    if ((*dce)->de_hash_el.qhe_flags & QHE_HASHED)\n        lsquic_hash_erase(conn->ifc_enpub->enp_srst_hash, &(*dce)->de_hash_el);\n    TAILQ_INSERT_TAIL(&conn->ifc_to_retire, *dce, de_next_to_ret);\n    LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32\"\", (*dce)->de_seqno);\n    *dce = NULL;\n    conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n}\n\n\nstatic void\nretire_seqno (struct ietf_full_conn *conn, unsigned seqno)\n{\n    struct dcid_elem *dce;\n\n    dce = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n    if (dce)\n    {\n        memset(dce, 0, sizeof(*dce));\n        dce->de_seqno = seqno;\n        TAILQ_INSERT_TAIL(&conn->ifc_to_retire, dce, de_next_to_ret);\n        LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32, seqno);\n        conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n    }\n    else\n        LSQ_INFO(\"%s: cannot allocate dce\", __func__);\n}\n\n\n/* This function exists for testing purposes.\n *\n * The user can switch DCIDs and request that the old DCID is retired.\n *\n * If the user calls this function frequently in a short amount of time,\n * this should trigger the CID issuance throttling.\n */\nstatic void\nietf_full_conn_ci_retire_cid (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct dcid_elem **el, **dces[2];\n    int eq;\n    /*\n     * Find two DCIDs:\n     *  1. the current DCID that will be retire_cid\n     *  2. an available DCID that will be switched\n     * Continue searching until there are no more DCIDs\n     * or when both DCIDs are found.\n     */\n    dces[0] = NULL; // future DCID  (does not match current DCID)\n    dces[1] = NULL; // current DCID (does match current DCID)\n    for (el = conn->ifc_dces; el < DCES_END(conn) && !(dces[0] && dces[1]); ++el)\n        if (*el)\n        {\n            eq = LSQUIC_CIDS_EQ(&(*el)->de_cid, CUR_DCID(conn));\n            if (!dces[eq])\n                dces[eq] = el;\n        }\n    if (!dces[1])\n    {\n        ABORT_WARN(\"%s: cannot find own DCID\", __func__);\n        return;\n    }\n    if (!dces[0])\n    {\n        LSQ_INFO(\"No DCID available: cannot switch\");\n        /* TODO: implemened delayed switch */\n        // conn->ifc_flags |= IFC_SWITCH_DCID;\n        return;\n    }\n    /*\n     * Switch DCID.\n     */\n    *CUR_DCID(conn) = (*dces[0])->de_cid;\n    if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n        CUR_CPATH(conn)->cop_spin_bit = 0;\n    LSQ_INFOC(\"switched DCID to %\"CID_FMT, CID_BITS(CUR_DCID(conn)));\n    /*\n     * Mark old DCID for retirement.\n     */\n    retire_dcid(conn, dces[1]);\n}\n\n\nstatic void\ndrop_crypto_streams (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **streamp;\n    unsigned count;\n\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_PROC_CRYPTO)) != IFC_PROC_CRYPTO)\n        return;\n\n    conn->ifc_flags &= ~IFC_PROC_CRYPTO;\n\n    count = 0;\n    for (streamp = conn->ifc_u.cli.crypto_streams; streamp <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++streamp)\n        if (*streamp)\n        {\n            lsquic_stream_force_finish(*streamp);\n            *streamp = NULL;\n            ++count;\n        }\n\n    LSQ_DEBUG(\"dropped %u crypto stream%.*s\", count, count != 1, \"s\");\n}\n\n\nstatic void\nietf_full_conn_ci_destroy (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream **streamp, *stream;\n    struct stream_id_to_ss *sits;\n    struct dcid_elem **dcep, *dce;\n    struct lsquic_hash_elem *el;\n    unsigned i;\n\n    if (!(conn->ifc_flags & IFC_SERVER))\n    {\n        for (streamp = conn->ifc_u.cli.crypto_streams; streamp <\n                conn->ifc_u.cli.crypto_streams\n                    + sizeof(conn->ifc_u.cli.crypto_streams)\n                        / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++streamp)\n            if (*streamp)\n                lsquic_stream_destroy(*streamp);\n    }\n    while ((el = lsquic_hash_first(conn->ifc_pub.all_streams)))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        lsquic_hash_erase(conn->ifc_pub.all_streams, el);\n        lsquic_stream_destroy(stream);\n    }\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        lsquic_qdh_cleanup(&conn->ifc_qdh);\n        lsquic_qeh_cleanup(&conn->ifc_qeh);\n    }\n    for (dcep = conn->ifc_dces; dcep < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++dcep)\n        if (*dcep)\n        {\n            if ((*dcep)->de_hash_el.qhe_flags & QHE_HASHED)\n                lsquic_hash_erase(conn->ifc_enpub->enp_srst_hash,\n                                                        &(*dcep)->de_hash_el);\n            lsquic_malo_put(*dcep);\n        }\n    while ((dce = TAILQ_FIRST(&conn->ifc_to_retire)))\n    {\n        TAILQ_REMOVE(&conn->ifc_to_retire, dce, de_next_to_ret);\n        lsquic_malo_put(dce);\n    }\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    for (i = 0; i < N_PNS; ++i)\n        lsquic_rechist_cleanup(&conn->ifc_rechist[i]);\n    lsquic_malo_destroy(conn->ifc_pub.packet_out_malo);\n    if (conn->ifc_flags & IFC_CREATED_OK)\n        conn->ifc_enpub->enp_stream_if->on_conn_closed(&conn->ifc_conn);\n    assert(conn->ifc_conn.cn_conn_ctx == NULL);\n    if (conn->ifc_conn.cn_enc_session)\n        conn->ifc_conn.cn_esf.i->esfi_destroy(conn->ifc_conn.cn_enc_session);\n    while (!STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n    {\n        sits = STAILQ_FIRST(&conn->ifc_stream_ids_to_ss);\n        STAILQ_REMOVE_HEAD(&conn->ifc_stream_ids_to_ss, sits_next);\n        free(sits);\n    }\n    if (conn->ifc_flags & IFC_SERVER)\n    {\n        if (conn->ifc_pub.u.ietf.promises)\n            lsquic_hash_destroy(conn->ifc_pub.u.ietf.promises);\n    }\n    for (i = 0; i < N_SITS; ++i)\n        lsquic_set64_cleanup(&conn->ifc_closed_stream_ids[i]);\n    if (conn->ifc_bpus)\n    {\n        for (el = lsquic_hash_first(conn->ifc_bpus); el;\n                                        el = lsquic_hash_next(conn->ifc_bpus))\n            free(lsquic_hashelem_getdata(el));\n        lsquic_hash_destroy(conn->ifc_bpus);\n    }\n    lsquic_hash_destroy(conn->ifc_pub.all_streams);\n#if LSQUIC_CONN_STATS\n    if (conn->ifc_flags & IFC_CREATED_OK)\n    {\n        LSQ_NOTICE(\"# ticks: %lu\", conn->ifc_stats.n_ticks);\n        LSQ_NOTICE(\"sent %lu packets\", conn->ifc_stats.out.packets);\n        LSQ_NOTICE(\"received %lu packets, of which %lu were not decryptable, %lu were \"\n            \"dups and %lu were errors; sent %lu packets, avg stream data per outgoing\"\n            \" packet is %lu bytes\",\n            conn->ifc_stats.in.packets, conn->ifc_stats.in.undec_packets,\n            conn->ifc_stats.in.dup_packets, conn->ifc_stats.in.err_packets,\n            conn->ifc_stats.out.packets,\n            conn->ifc_stats.out.stream_data_sz /\n                (conn->ifc_stats.out.packets ? conn->ifc_stats.out.packets : 1));\n        if (conn->ifc_flags & IFC_DELAYED_ACKS)\n            LSQ_NOTICE(\"delayed ACKs settings: (%u/%.3f/%.3f/%.3f/%.3f/%.3f); \"\n                \"packet tolerances sent: count: %u, min: %u, max: %u\",\n                conn->ifc_settings->es_ptpc_periodicity,\n                conn->ifc_settings->es_ptpc_target,\n                conn->ifc_settings->es_ptpc_prop_gain,\n                conn->ifc_settings->es_ptpc_int_gain,\n                conn->ifc_settings->es_ptpc_err_thresh,\n                conn->ifc_settings->es_ptpc_err_divisor,\n                conn->ifc_ack_freq_seqno,\n                conn->ifc_min_pack_tol_sent, conn->ifc_max_pack_tol_sent);\n        LSQ_NOTICE(\"ACKs: delayed acks on: %s; in: %lu; processed: %lu; merged: %lu\",\n            conn->ifc_flags & IFC_DELAYED_ACKS ? \"yes\" : \"no\",\n            conn->ifc_stats.in.n_acks, conn->ifc_stats.in.n_acks_proc,\n            conn->ifc_stats.in.n_acks_merged);\n    }\n    if (conn->ifc_last_stats)\n        free(conn->ifc_last_stats);\n#endif\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"full connection destroyed\");\n    free(conn->ifc_errmsg);\n    free(conn);\n}\n\n\nstatic uint64_t\ncalc_drain_time (const struct ietf_full_conn *conn)\n{\n    lsquic_time_t drain_time, pto, srtt, var;\n\n    /* PTO Calculation: [draft-ietf-quic-recovery-18], Section 6.2.2.1;\n     * Drain time: [draft-ietf-quic-transport-19], Section 10.1.\n     */\n    srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n    var = lsquic_rtt_stats_get_rttvar(&conn->ifc_pub.rtt_stats);\n    pto = srtt + 4 * var + TP_DEF_MAX_ACK_DELAY * 1000;\n    drain_time = 3 * pto;\n\n    return drain_time;\n}\n\n\nstatic lsquic_time_t\nietf_full_conn_ci_drain_time (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_time_t drain_time;\n\n    /* Only applicable to a server whose connection was not timed out */\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_TIMED_OUT)) != IFC_SERVER)\n    {\n        LSQ_DEBUG(\"drain time is zero (don't drain)\");\n        return 0;\n    }\n\n    drain_time = calc_drain_time(conn);\n    LSQ_DEBUG(\"drain time is %\"PRIu64\" usec\", drain_time);\n    return drain_time;\n}\n\n\nstatic void\nietf_full_conn_ci_going_away (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        if (!(conn->ifc_flags & (IFC_CLOSING|IFC_GOING_AWAY)))\n        {\n            LSQ_INFO(\"connection marked as going away, last stream: %\" PRIu64,\n                     conn->ifc_max_req_id);\n            conn->ifc_flags |= IFC_GOING_AWAY;\n            const lsquic_stream_id_t stream_id = conn->ifc_max_req_id + N_SITS;\n            if (valid_stream_id(stream_id))\n            {\n                if (0 == lsquic_hcso_write_goaway(&conn->ifc_hcso,\n                                                        conn->ifc_max_req_id))\n                    lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n                else\n                    /* We're already going away, don't abort because of this */\n                    LSQ_WARN(\"could not write GOAWAY frame\");\n            }\n            maybe_close_conn(conn);\n        }\n    }\n    else\n        LSQ_NOTICE(\"going away has no effect in non-HTTP mode\");\n}\n\n\nstatic void\nhandshake_failed (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    LSQ_DEBUG(\"handshake failed\");\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_HANDSHAKE);\n    conn->ifc_flags |= IFC_HSK_FAILED;\n}\n\n\nstatic struct dcid_elem *\nget_new_dce (struct ietf_full_conn *conn)\n{\n    struct dcid_elem **el;\n\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (!*el)\n            return *el = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n\n    return NULL;\n}\n\n\nstatic void\nqueue_streams_blocked_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    enum stream_id_type sit;\n    uint64_t limit;\n\n    if (0 == (conn->ifc_send_flags & (SF_SEND_STREAMS_BLOCKED << sd)))\n    {\n        conn->ifc_send_flags |= SF_SEND_STREAMS_BLOCKED << sd;\n        sit = gen_sit(conn->ifc_flags & IFC_SERVER, sd);\n        limit = conn->ifc_max_allowed_stream_id[sit] >> SIT_SHIFT;\n        conn->ifc_send.streams_blocked[sd] = limit;\n        LSQ_DEBUG(\"scheduled %sdirectional STREAMS_BLOCKED (limit=%\"PRIu64\n            \") frame\", sd == SD_BIDI ? \"bi\" : \"uni\", limit);\n    }\n    else\n        LSQ_DEBUG(\"%sdirectional STREAMS_BLOCKED frame already queued\",\n            sd == SD_BIDI ? \"bi\" : \"uni\");\n}\n\n\nstatic void\nretire_cid_from_tp (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct dcid_elem *dce;\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_ERROR(\"cannot allocate DCE\");\n        return;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = params->tp_preferred_address.cid;\n    dce->de_seqno = 1;\n    memcpy(dce->de_srst, params->tp_preferred_address.srst,\n                                                    sizeof(dce->de_srst));\n    dce->de_flags = DE_SRST;\n    TAILQ_INSERT_TAIL(&conn->ifc_to_retire, dce, de_next_to_ret);\n    LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32, dce->de_seqno);\n    conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n}\n\n\nstatic enum { BM_MIGRATING, BM_NOT_MIGRATING, BM_ERROR, }\ntry_to_begin_migration (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct conn_path *copath;\n    struct dcid_elem *dce;\n    int is_ipv6;\n    union {\n        struct sockaddr_in  v4;\n        struct sockaddr_in6 v6;\n    } sockaddr;\n\n    if (!conn->ifc_settings->es_allow_migration)\n    {\n        LSQ_DEBUG(\"Migration not allowed: retire PreferredAddress CID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    if (conn->ifc_conn.cn_version <= LSQVER_ID27 /* Starting with ID-29,\n        disable_active_migration TP applies only to the time period during\n        the handshake.  Our client does not migrate during the handshake:\n        this code runs only after handshake has succeeded. */\n                && (params->tp_set & (1 << TPI_DISABLE_ACTIVE_MIGRATION)))\n    {\n        LSQ_DEBUG(\"TP disables migration: retire PreferredAddress CID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    is_ipv6 = NP_IS_IPv6(CUR_NPATH(conn));\n    if ((is_ipv6 && !lsquic_tp_has_pref_ipv6(params))\n                || (!is_ipv6 && !lsquic_tp_has_pref_ipv4(params)))\n    {\n        /* XXX This is a limitation in the client code outside of the library.\n         * To support cross-IP-version migration, we need to add some callbacks\n         * to open a different socket.\n         */\n        LSQ_DEBUG(\"Cannot migrate from IPv%u to IPv%u\", is_ipv6 ? 6 : 4,\n            is_ipv6 ? 4 : 6);\n        return BM_NOT_MIGRATING;\n    }\n\n    if (0 == params->tp_preferred_address.cid.len)\n    {\n        /* TODO: mark with a new flag and begin migration when a non-zero length\n         * DCID becomes available.\n         */\n        LSQ_DEBUG(\"Cannot migrate using zero-length DCID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_WARN(\"cannot allocate DCE\");\n        return BM_ERROR;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = params->tp_preferred_address.cid;\n    dce->de_seqno = 1;\n    dce->de_flags = DE_SRST;\n    memcpy(dce->de_srst, params->tp_preferred_address.srst,\n                                                    sizeof(dce->de_srst));\n    if (conn->ifc_enpub->enp_srst_hash)\n    {\n        if (!lsquic_hash_insert(conn->ifc_enpub->enp_srst_hash,\n                dce->de_srst, sizeof(dce->de_srst), &conn->ifc_conn,\n                &dce->de_hash_el))\n        {\n            lsquic_malo_put(dce);\n            ABORT_WARN(\"cannot insert DCE\");\n            return BM_ERROR;\n        }\n    }\n\n    if (is_ipv6)\n    {\n        sockaddr.v6.sin6_family = AF_INET6;\n        sockaddr.v6.sin6_port   = htons(params->tp_preferred_address.ipv6_port);\n        memcpy(&sockaddr.v6.sin6_addr, params->tp_preferred_address.ipv6_addr,\n                                                sizeof(sockaddr.v6.sin6_addr));\n    }\n    else\n    {\n        sockaddr.v4.sin_family = AF_INET;\n        sockaddr.v4.sin_port   = htons(params->tp_preferred_address.ipv4_port);\n        memcpy(&sockaddr.v4.sin_addr, params->tp_preferred_address.ipv4_addr,\n                                                sizeof(sockaddr.v4.sin_addr));\n    }\n\n    copath = &conn->ifc_paths[1];\n    assert(!(conn->ifc_used_paths & (1 << (copath - conn->ifc_paths))));\n\n    migra_begin(conn, copath, dce, (struct sockaddr *) &sockaddr, params);\n    return BM_MIGRATING;\n}\n\n\nstatic void\nmaybe_start_migration (struct ietf_full_conn *conn)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct transport_params *params;\n\n    params = lconn->cn_esf.i->esfi_get_peer_transport_params(\n                                                        lconn->cn_enc_session);\n    if (params->tp_set & (1 << TPI_PREFERRED_ADDRESS))\n        switch (try_to_begin_migration(conn, params))\n        {\n        case BM_MIGRATING:\n            break;\n        case BM_NOT_MIGRATING:\n            if (lconn->cn_version == LSQVER_ID27)\n                retire_cid_from_tp(conn, params);\n            else\n            {\n/*\n * [draft-ietf-quic-transport-28] Section 5.1.1:\n \"                         Connection IDs that are issued and not\n \" retired are considered active; any active connection ID is valid for\n \" use with the current connection at any time, in any packet type.\n \" This includes the connection ID issued by the server via the\n \" preferred_address transport parameter.\n */\n                LSQ_DEBUG(\"not migrating: save DCID from transport params\");\n                (void) insert_new_dcid(conn, 1,\n                            &params->tp_preferred_address.cid,\n                            params->tp_preferred_address.srst, 0);\n            }\n            break;\n        case BM_ERROR:\n            ABORT_QUIETLY(0, TEC_INTERNAL_ERROR, \"error initiating migration\");\n            break;\n        }\n}\n\n\nstatic int\napply_trans_params (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n    uint64_t limit;\n\n    if ((params->tp_set & (1 << TPI_LOSS_BITS))\n                                    && conn->ifc_settings->es_ql_bits == 2)\n    {\n        LSQ_DEBUG(\"turn on QL loss bits\");\n        lsquic_send_ctl_do_ql_bits(&conn->ifc_send_ctl);\n    }\n\n    if (params->tp_init_max_streams_bidi > (1ull << 60)\n                            || params->tp_init_max_streams_uni > (1ull << 60))\n    {\n        if (params->tp_init_max_streams_bidi > (1ull << 60))\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"init_max_streams_bidi is \"\n                \"too large: %\"PRIu64, params->tp_init_max_streams_bidi);\n        else\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"init_max_streams_uni is \"\n                \"too large: %\"PRIu64, params->tp_init_max_streams_uni);\n        return -1;\n    }\n\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_BIDI);\n    conn->ifc_max_allowed_stream_id[sit] =\n                        params->tp_init_max_streams_bidi << SIT_SHIFT;\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_UNI);\n    conn->ifc_max_allowed_stream_id[sit] =\n                        params->tp_init_max_streams_uni << SIT_SHIFT;\n\n    conn->ifc_max_stream_data_uni      = params->tp_init_max_stream_data_uni;\n\n    if (params->tp_init_max_data < conn->ifc_pub.conn_cap.cc_sent)\n    {\n        ABORT_WARN(\"peer specified init_max_data=%\"PRIu64\" bytes, which is \"\n            \"smaller than the amount of data already sent on this connection \"\n            \"(%\"PRIu64\" bytes)\", params->tp_init_max_data,\n            conn->ifc_pub.conn_cap.cc_sent);\n        return -1;\n    }\n\n    conn->ifc_pub.conn_cap.cc_max = params->tp_init_max_data;\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (is_our_stream(conn, stream))\n            limit = params->tp_init_max_stream_data_bidi_remote;\n        else\n            limit = params->tp_init_max_stream_data_bidi_local;\n        if (0 != lsquic_stream_set_max_send_off(stream, limit))\n        {\n            ABORT_WARN(\"cannot set peer-supplied max_stream_data=%\"PRIu64\n                \"on stream %\"PRIu64, limit, stream->id);\n            return -1;\n        }\n    }\n\n    if (conn->ifc_flags & IFC_SERVER)\n        conn->ifc_cfg.max_stream_send\n                                = params->tp_init_max_stream_data_bidi_local;\n    else\n        conn->ifc_cfg.max_stream_send\n                                = params->tp_init_max_stream_data_bidi_remote;\n    conn->ifc_cfg.ack_exp = params->tp_ack_delay_exponent;\n\n    switch ((!!conn->ifc_settings->es_idle_timeout << 1)\n                | !!params->tp_max_idle_timeout)\n    {\n    case       (0 << 1) | 0:\n        LSQ_DEBUG(\"neither side specified max idle time out, turn it off\");\n        break;\n    case       (0 << 1) | 1:\n        LSQ_DEBUG(\"peer specified max idle timeout of %\"PRIu64\" ms (vs ours \"\n            \"of zero): use it\", params->tp_max_idle_timeout);\n        conn->ifc_idle_to = params->tp_max_idle_timeout * 1000;\n        break;\n    case       (1 << 1) | 0:\n        LSQ_DEBUG(\"peer did not specify max idle timeout, while ours is \"\n            \"%u ms: use it\", conn->ifc_settings->es_idle_timeout * 1000);\n        conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n        break;\n    default:/* (1 << 1) | 1 */\n        LSQ_DEBUG(\"our max idle timeout is %u ms, peer's is %\"PRIu64\" ms; \"\n            \"use minimum value of %\"PRIu64\" ms\",\n            conn->ifc_settings->es_idle_timeout * 1000,\n            params->tp_max_idle_timeout,\n            MIN(conn->ifc_settings->es_idle_timeout * 1000,\n                                            params->tp_max_idle_timeout));\n        conn->ifc_idle_to = 1000 * MIN(conn->ifc_settings->es_idle_timeout\n                                        * 1000, params->tp_max_idle_timeout);\n        break;\n    }\n\n    if (conn->ifc_idle_to >= 2000000\n                            && conn->ifc_enpub->enp_settings.es_ping_period)\n        conn->ifc_ping_period = conn->ifc_idle_to / 2;\n    else\n        conn->ifc_ping_period = 0;\n    LSQ_DEBUG(\"PING period is set to %\"PRIu64\" usec\", conn->ifc_ping_period);\n\n    if (conn->ifc_settings->es_delayed_acks\n            && (params->tp_set\n                    & ((1 << TPI_MIN_ACK_DELAY)|(1 << TPI_MIN_ACK_DELAY_02))))\n    {\n        /* We do not use the min_ack_delay value for anything at the moment,\n         * as ACK_FREQUENCY frames we generate do not change the peer's max\n         * ACK delay.  When or if we do decide to do it, don't forget to use\n         * the correct value here -- based on which TP is set!\n         */\n        LSQ_DEBUG(\"delayed ACKs enabled\");\n        conn->ifc_flags |= IFC_DELAYED_ACKS;\n        lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PACK_TOL,\n                                        packet_tolerance_alarm_expired, conn);\n    }\n    if (conn->ifc_settings->es_timestamps\n            && (params->tp_set & (1 << TPI_TIMESTAMPS))\n                && (params->tp_numerics[TPI_TIMESTAMPS] & TS_WANT_THEM))\n    {\n        LSQ_DEBUG(\"timestamps enabled: will send TIMESTAMP frames\");\n        conn->ifc_flags |= IFC_TIMESTAMPS;\n    }\n    if (conn->ifc_settings->es_datagrams\n            && (params->tp_set & (1 << TPI_MAX_DATAGRAM_FRAME_SIZE)))\n    {\n        LSQ_DEBUG(\"datagrams enabled\");\n        conn->ifc_flags |= IFC_DATAGRAMS;\n        conn->ifc_max_dg_sz =\n            params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE] > USHRT_MAX\n            ? USHRT_MAX : params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE];\n    }\n\n    conn->ifc_pub.max_peer_ack_usec = params->tp_max_ack_delay * 1000;\n\n    if ((params->tp_set & (1 << TPI_MAX_UDP_PAYLOAD_SIZE))\n            /* Second check is so that we don't truncate a large value when\n             * storing it in unsigned short.\n             */\n            && params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE]\n                                                < TP_DEF_MAX_UDP_PAYLOAD_SIZE)\n        conn->ifc_max_udp_payload = params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE];\n    else\n        conn->ifc_max_udp_payload = TP_DEF_MAX_UDP_PAYLOAD_SIZE;\n\n    if (conn->ifc_max_udp_payload < CUR_NPATH(conn)->np_pack_size)\n    {\n        CUR_NPATH(conn)->np_pack_size = conn->ifc_max_udp_payload;\n        LSQ_DEBUG(\"decrease packet size to %hu bytes\",\n                                                CUR_NPATH(conn)->np_pack_size);\n    }\n\n    if (params->tp_active_connection_id_limit > conn->ifc_conn.cn_n_cces)\n        conn->ifc_active_cids_limit = conn->ifc_conn.cn_n_cces;\n    else\n        conn->ifc_active_cids_limit = params->tp_active_connection_id_limit;\n    conn->ifc_first_active_cid_seqno = conn->ifc_scid_seqno;\n\n    return 0;\n}\n\n\nstatic void\nrandomize_qpack_settings (struct ietf_full_conn *conn, const char *side,\n                        unsigned *dyn_table_size, unsigned *max_risked_streams)\n{\n    const unsigned char nybble = lsquic_crand_get_nybble(\n                                                    conn->ifc_enpub->enp_crand);\n    /* For each setting, select one of four levels:\n     *  Table size:     0, 1/4, 1/2, and 1/1 of dyn_table_size\n     *  Risked streams: 0, 1, 5, and max_risked_streams\n     */\n    switch (nybble & 3)\n    {   case 0: *dyn_table_size  = 0; break;\n        case 1: *dyn_table_size /= 4; break;\n        case 2: *dyn_table_size /= 2; break;\n        default:                      break;\n    }\n    if (*dyn_table_size)\n        switch ((nybble >> 2) & 3)\n        {   case 0: *max_risked_streams = 0;                           break;\n            case 1: *max_risked_streams = MIN(1, *max_risked_streams); break;\n            case 2: *max_risked_streams = MIN(5, *max_risked_streams); break;\n            default:                                                   break;\n        }\n    else\n        *max_risked_streams = 0;\n    LSQ_INFO(\"randomized QPACK %s settings: table size: %u; risked \"\n        \"streams: %u\", side, *dyn_table_size, *max_risked_streams);\n}\n\n\nstatic int\ninit_http (struct ietf_full_conn *conn)\n{\n    unsigned max_risked_streams, dyn_table_size;\n\n    fiu_return_on(\"full_conn_ietf/init_http\", -1);\n    lsquic_qeh_init(&conn->ifc_qeh, &conn->ifc_conn);\n    if (conn->ifc_settings->es_qpack_experiment)\n    {\n        conn->ifc_qeh.qeh_exp_rec = lsquic_qpack_exp_new();\n        if (conn->ifc_qeh.qeh_exp_rec)\n        {\n            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_SERVER & conn->ifc_flags;\n            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_ENCODER;\n        }\n    }\n    if (0 == avail_streams_count(conn, conn->ifc_flags & IFC_SERVER,\n                                                                SD_UNI))\n    {\n        ABORT_QUIETLY(1, HEC_GENERAL_PROTOCOL_ERROR, \"cannot create \"\n                            \"control stream due to peer-imposed limit\");\n        conn->ifc_error = CONN_ERR(1, HEC_GENERAL_PROTOCOL_ERROR);\n        return -1;\n    }\n    if (0 != create_ctl_stream_out(conn))\n    {\n        ABORT_WARN(\"cannot create outgoing control stream\");\n        return -1;\n    }\n    dyn_table_size = conn->ifc_settings->es_qpack_dec_max_size;\n    max_risked_streams = conn->ifc_settings->es_qpack_dec_max_blocked;\n    if (conn->ifc_settings->es_qpack_experiment == 2)\n        randomize_qpack_settings(conn, \"decoder\", &dyn_table_size,\n                                                    &max_risked_streams);\n    if (0 != lsquic_hcso_write_settings(&conn->ifc_hcso,\n                conn->ifc_settings->es_max_header_list_size, dyn_table_size,\n                max_risked_streams, conn->ifc_flags & IFC_SERVER))\n    {\n        ABORT_WARN(\"cannot write SETTINGS\");\n        return -1;\n    }\n    if (!(conn->ifc_flags & IFC_SERVER)\n        && (conn->ifc_u.cli.ifcli_flags & IFCLI_PUSH_ENABLED)\n        && 0 != lsquic_hcso_write_max_push_id(&conn->ifc_hcso,\n                                        conn->ifc_u.cli.ifcli_max_push_id))\n    {\n        ABORT_WARN(\"cannot write MAX_PUSH_ID\");\n        return -1;\n    }\n    if (0 != lsquic_qdh_init(&conn->ifc_qdh, &conn->ifc_conn,\n                            conn->ifc_flags & IFC_SERVER, conn->ifc_enpub,\n                            dyn_table_size, max_risked_streams))\n    {\n        ABORT_WARN(\"cannot initialize QPACK decoder\");\n        return -1;\n    }\n    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)\n    {\n        if (0 != create_qdec_stream_out(conn))\n        {\n            ABORT_WARN(\"cannot create outgoing QPACK decoder stream\");\n            return -1;\n        }\n    }\n    else\n    {\n        queue_streams_blocked_frame(conn, SD_UNI);\n        LSQ_DEBUG(\"cannot create outgoing QPACK decoder stream due to \"\n            \"unidir limits\");\n    }\n    conn->ifc_flags |= IFC_HTTP_INITED;\n    return 0;\n}\n\n\nstatic int\nhandshake_ok (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct dcid_elem *dce;\n    const struct transport_params *params;\n    char buf[MAX_TP_STR_SZ];\n\n    fiu_return_on(\"full_conn_ietf/handshake_ok\", -1);\n\n    /* Need to set this flag even we hit an error in the rest of this funciton.\n     * This is because this flag is used to calculate packet out header size\n     */\n    lconn->cn_flags |= LSCONN_HANDSHAKE_DONE;\n\n    params = lconn->cn_esf.i->esfi_get_peer_transport_params(\n                                                        lconn->cn_enc_session);\n    if (!params)\n    {\n        ABORT_WARN(\"could not get transport parameters\");\n        return -1;\n    }\n\n    LSQ_DEBUG(\"peer transport parameters: %s\",\n                    ((lconn->cn_version == LSQVER_ID27 ? lsquic_tp_to_str_27\n                    : lsquic_tp_to_str)(params, buf, sizeof(buf)), buf));\n    if (0 != apply_trans_params(conn, params))\n        return -1;\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_WARN(\"cannot allocate DCE\");\n        return -1;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = *CUR_DCID(conn);\n    dce->de_seqno = 0;\n    if (params->tp_set & (1 << TPI_STATELESS_RESET_TOKEN))\n    {\n        memcpy(dce->de_srst, params->tp_stateless_reset_token,\n                                                    sizeof(dce->de_srst));\n        dce->de_flags = DE_SRST | DE_ASSIGNED;\n        if (conn->ifc_enpub->enp_srst_hash)\n        {\n            if (!lsquic_hash_insert(conn->ifc_enpub->enp_srst_hash,\n                    dce->de_srst, sizeof(dce->de_srst), &conn->ifc_conn,\n                    &dce->de_hash_el))\n            {\n                ABORT_WARN(\"cannot insert DCE\");\n                return -1;\n            }\n        }\n    }\n    else\n        dce->de_flags = DE_ASSIGNED;\n\n    if (!(conn->ifc_flags & IFC_SERVER)\n        && (params->tp_set & (1 << TPI_VERSION_INFORMATION)))\n    {\n        LSQ_DEBUG(\"server chosen version %s\",\n                  lsquic_ver2str[params->tp_chosen_version]);\n        if (((1 << params->tp_chosen_version)\n            & conn->ifc_settings->es_versions) == 0)\n        {\n            ABORT_QUIETLY(0, TEC_VERSION_NEGOTIATION_ERROR,\n                          \"server chosen version %s is not supported\",\n                          lsquic_ver2str[params->tp_chosen_version]\n                         );\n            return -1;\n        }\n//         if (conn->ifc_conn.cn_version != params->tp_chosen_version)\n//         {\n//             LSQ_DEBUG(\"version negociation: switch version from %s to %s\",\n//                   lsquic_ver2str[conn->ifc_conn.cn_version],\n//                   lsquic_ver2str[params->tp_chosen_version]);\n//             conn->ifc_conn.cn_version = params->tp_chosen_version;\n//         }\n    }\n\n    LSQ_INFO(\"applied peer transport parameters\");\n\n    if ((conn->ifc_flags & (IFC_HTTP|IFC_HTTP_INITED)) == IFC_HTTP)\n        if (0 != init_http(conn))\n            return -1;\n\n    if (conn->ifc_settings->es_dplpmtud)\n        conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n\n    if (can_issue_cids(conn))\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n    maybe_create_delayed_streams(conn);\n\n    if (!(conn->ifc_flags & IFC_SERVER))\n        lsquic_send_ctl_0rtt_to_1rtt(&conn->ifc_send_ctl);\n\n    return 0;\n}\n\n\nstatic void\nietf_full_conn_ci_hsk_done (struct lsquic_conn *lconn,\n                                                enum lsquic_hsk_status status)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_HANDSHAKE);\n\n    switch (status)\n    {\n    case LSQ_HSK_OK:\n    case LSQ_HSK_RESUMED_OK:\n        if (0 == handshake_ok(lconn))\n        {\n            if (!(conn->ifc_flags & IFC_SERVER))\n                lsquic_send_ctl_begin_optack_detection(&conn->ifc_send_ctl);\n        }\n        else\n        {\n            LSQ_INFO(\"handshake was reported successful, but later processing \"\n                \"produced an error\");\n            status = LSQ_HSK_FAIL;\n            handshake_failed(lconn);\n        }\n        break;\n    default:\n    case LSQ_HSK_RESUMED_FAIL:  /* IETF crypto never returns this */\n        assert(0);\n        /* fall-through */\n    case LSQ_HSK_FAIL:\n        handshake_failed(lconn);\n        break;\n    }\n    if (conn->ifc_enpub->enp_stream_if->on_hsk_done)\n        conn->ifc_enpub->enp_stream_if->on_hsk_done(lconn, status);\n}\n\n\nstatic void\nietf_full_conn_ci_tls_alert (struct lsquic_conn *lconn, uint8_t alert)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    ABORT_QUIETLY(0, 0x100 + alert, \"TLS alert %\"PRIu8, alert);\n}\n\n\nstatic int\nietf_full_conn_ci_report_live (struct lsquic_conn *lconn, lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    if (conn->ifc_last_live_update + 30000000 < now)\n    {\n        conn->ifc_last_live_update = now;\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic int\nietf_full_conn_ci_is_push_enabled (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    return (conn->ifc_flags & IFC_SERVER)\n        && (conn->ifc_u.ser.ifser_flags\n                & (IFSER_PUSH_ENABLED|IFSER_MAX_PUSH_ID))\n                    == (IFSER_PUSH_ENABLED|IFSER_MAX_PUSH_ID)\n        && conn->ifc_u.ser.ifser_next_push_id\n                        <= conn->ifc_u.ser.ifser_max_push_id\n        && !either_side_going_away(conn)\n        && avail_streams_count(conn, 1, SD_UNI) > 0\n    ;\n}\n\n\nstatic void\nundo_stream_creation (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    enum stream_dir sd;\n\n    assert(stream->sm_hash_el.qhe_flags & QHE_HASHED);\n    assert(!(stream->stream_flags & STREAM_ONCLOSE_DONE));\n\n    LSQ_DEBUG(\"undo creation of stream %\"PRIu64, stream->id);\n    lsquic_hash_erase(conn->ifc_pub.all_streams, &stream->sm_hash_el);\n    sd = (stream->id >> SD_SHIFT) & 1;\n    --conn->ifc_n_created_streams[sd];\n    lsquic_stream_destroy(stream);\n}\n\n\n/* This function is long because there are a lot of steps to perform, several\n * things can go wrong, which we want to roll back, yet at the same time we\n * want to do everything efficiently.\n */\nstatic int\nietf_full_conn_ci_push_stream (struct lsquic_conn *lconn, void *hset,\n    struct lsquic_stream *dep_stream, const struct lsquic_http_headers *headers)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    unsigned char *header_block_buf, *end, *p;\n    size_t hea_sz, enc_sz;\n    ssize_t prefix_sz;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n    struct lsquic_stream *pushed_stream;\n    struct uncompressed_headers *uh;\n    enum lsqpack_enc_status enc_st;\n    int i;\n    unsigned char discard[2];\n    struct lsxpack_header *xhdr;\n\n    if (!ietf_full_conn_ci_is_push_enabled(lconn)\n                                || !lsquic_stream_can_push(dep_stream))\n    {\n        LSQ_DEBUG(\"cannot push using stream %\"PRIu64, dep_stream->id);\n        return -1;\n    }\n\n    if (!hset)\n    {\n        LSQ_ERROR(\"header set must be specified when pushing\");\n        return -1;\n    }\n\n    if (0 != lsqpack_enc_start_header(&conn->ifc_qeh.qeh_encoder, 0, 0))\n    {\n        LSQ_WARN(\"cannot start header for push stream\");\n        return -1;\n    }\n\n    header_block_buf = lsquic_mm_get_4k(conn->ifc_pub.mm);\n    if (!header_block_buf)\n    {\n        LSQ_WARN(\"cannot allocate 4k\");\n        (void) lsqpack_enc_cancel_header(&conn->ifc_qeh.qeh_encoder);\n        return -1;\n    }\n\n    /* Generate header block in cheap 4K memory.  It it will be copied to\n     * a new push_promise object.\n     */\n    p = header_block_buf;\n    end = header_block_buf + 0x1000;\n    enc_sz = 0; /* Should not change */\n    for (i = 0; i < headers->count; ++i)\n    {\n        xhdr = &headers->headers[i];\n        if (!xhdr->buf)\n            continue;\n        hea_sz = end - p;\n        enc_st = lsqpack_enc_encode(&conn->ifc_qeh.qeh_encoder, NULL,\n            &enc_sz, p, &hea_sz, xhdr, LQEF_NO_HIST_UPD|LQEF_NO_DYN);\n        if (enc_st == LQES_OK)\n            p += hea_sz;\n        else\n        {\n            (void) lsqpack_enc_cancel_header(&conn->ifc_qeh.qeh_encoder);\n            lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n            LSQ_DEBUG(\"cannot encode header field for push %u\", enc_st);\n            return -1;\n        }\n    }\n    prefix_sz = lsqpack_enc_end_header(&conn->ifc_qeh.qeh_encoder,\n                                            discard, sizeof(discard), NULL);\n    if (!(prefix_sz == 2 && discard[0] == 0 && discard[1] == 0))\n    {\n        LSQ_WARN(\"stream push: unexpected prefix values %zd, %hhu, %hhu\",\n            prefix_sz, discard[0], discard[1]);\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated push promise header block of %ld bytes\",\n                                            (long) (p - header_block_buf));\n\n    pushed_stream = create_push_stream(conn);\n    if (!pushed_stream)\n    {\n        LSQ_WARN(\"could not create push stream\");\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        return -1;\n    }\n\n    promise = malloc(sizeof(*promise) + (p - header_block_buf));\n    if (!promise)\n    {\n        LSQ_WARN(\"stream push: cannot allocate promise\");\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        undo_stream_creation(conn, pushed_stream);\n        return -1;\n    }\n\n    uh = malloc(sizeof(*uh));\n    if (!uh)\n    {\n        LSQ_WARN(\"stream push: cannot allocate uh\");\n        free(promise);\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        undo_stream_creation(conn, pushed_stream);\n        return -1;\n    }\n    uh->uh_stream_id     = pushed_stream->id;\n    uh->uh_oth_stream_id = 0;\n    uh->uh_weight        = lsquic_stream_priority(dep_stream) / 2 + 1;\n    uh->uh_exclusive     = 0;\n    uh->uh_flags         = UH_FIN;\n    uh->uh_hset          = hset;\n    uh->uh_next          = NULL;\n\n    memset(promise, 0, sizeof(*promise));\n    promise->pp_refcnt = 1; /* This function itself keeps a reference */\n    memcpy(promise->pp_content_buf, header_block_buf, p - header_block_buf);\n    promise->pp_content_len = p - header_block_buf;\n    promise->pp_id = conn->ifc_u.ser.ifser_next_push_id++;\n    lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n\n    el = lsquic_hash_insert(conn->ifc_pub.u.ietf.promises,\n            &promise->pp_id, sizeof(promise->pp_id), promise,\n            &promise->pp_hash_id);\n    if (!el)\n    {\n        LSQ_WARN(\"cannot insert push promise (ID)\");\n        undo_stream_creation(conn, pushed_stream);\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        free(uh);\n        return -1;\n    }\n\n    if (0 != lsquic_stream_push_promise(dep_stream, promise))\n    {\n        LSQ_DEBUG(\"push promise failed\");\n        undo_stream_creation(conn, pushed_stream);\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        free(uh);\n        return -1;\n    }\n\n    if (0 != lsquic_stream_uh_in(pushed_stream, uh))\n    {\n        LSQ_WARN(\"stream barfed when fed synthetic request\");\n        undo_stream_creation(conn, pushed_stream);\n        free(uh);\n        if (0 != lsquic_hcso_write_cancel_push(&conn->ifc_hcso,\n                                                    promise->pp_id))\n            ABORT_WARN(\"cannot write CANCEL_PUSH\");\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        return -1;\n    }\n\n    /* Linking push promise with pushed stream is necessary for cancellation */\n    ++promise->pp_refcnt;\n    promise->pp_pushed_stream = pushed_stream;\n    pushed_stream->sm_promise = promise;\n\n    lsquic_stream_call_on_new(pushed_stream);\n\n    lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n    return 0;\n}\n\n\nstatic int\nietf_full_conn_ci_is_tickable (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream *stream;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.service_streams))\n    {\n        LSQ_DEBUG(\"tickable: there are streams to be serviced\");\n        return 1;\n    }\n\n    if ((conn->ifc_enpub->enp_flags & ENPUB_CAN_SEND)\n        && (should_generate_ack(conn, IFC_ACK_QUEUED) ||\n            !lsquic_send_ctl_sched_is_blocked(&conn->ifc_send_ctl)))\n    {\n        /* XXX What about queued ACKs: why check but not make tickable? */\n        if (conn->ifc_send_flags)\n        {\n            LSQ_DEBUG(\"tickable: send flags: 0x%X\", conn->ifc_send_flags);\n            goto check_can_send;\n        }\n        if (lsquic_send_ctl_has_sendable(&conn->ifc_send_ctl))\n        {\n            LSQ_DEBUG(\"tickable: has sendable packets\");\n            return 1;   /* Don't check can_send: already on scheduled queue */\n        }\n        if (conn->ifc_conn.cn_flags & LSCONN_SEND_BLOCKED)\n        {\n            LSQ_DEBUG(\"tickable: send DATA_BLOCKED frame\");\n            goto check_can_send;\n        }\n        if (conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE)\n        {\n            LSQ_DEBUG(\"tickable: want to write DATAGRAM frame\");\n            goto check_can_send;\n        }\n        if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE ?\n                lsquic_send_ctl_has_buffered(&conn->ifc_send_ctl) :\n                lsquic_send_ctl_has_buffered_high(&conn->ifc_send_ctl))\n        {\n            LSQ_DEBUG(\"tickable: has buffered packets\");\n            goto check_can_send;\n        }\n        if (!TAILQ_EMPTY(&conn->ifc_pub.sending_streams))\n        {\n            LSQ_DEBUG(\"tickable: there are sending streams\");\n            goto check_can_send;\n        }\n        TAILQ_FOREACH(stream, &conn->ifc_pub.write_streams, next_write_stream)\n            if (lsquic_stream_write_avail(stream))\n            {\n                LSQ_DEBUG(\"tickable: stream %\"PRIu64\" can be written to\",\n                    stream->id);\n                goto check_can_send;\n            }\n        goto check_readable_streams;\n  check_can_send:\n        if (lsquic_send_ctl_can_send(&conn->ifc_send_ctl))\n            return 1;\n    }\n\n  check_readable_streams:\n    TAILQ_FOREACH(stream, &conn->ifc_pub.read_streams, next_read_stream)\n        if (lsquic_stream_readable(stream))\n        {\n            LSQ_DEBUG(\"tickable: stream %\"PRIu64\" can be read from\",\n                stream->id);\n            return 1;\n        }\n\n    if (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS)\n    {\n        LSQ_DEBUG(\"tickable: immediate close flags: 0x%X\",\n            (unsigned) (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS));\n        return 1;\n    }\n\n    LSQ_DEBUG(\"not tickable\");\n    return 0;\n}\n\n\nstatic enum tick_st\nimmediate_close (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    const char *error_reason;\n    struct conn_err conn_err;\n    int sz;\n\n    if (conn->ifc_flags & (IFC_TICK_CLOSE|IFC_GOT_PRST))\n        return TICK_CLOSE;\n\n    if (!(conn->ifc_flags & IFC_SERVER)\n            && conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_END)\n        return TICK_CLOSE;\n\n    conn->ifc_flags |= IFC_TICK_CLOSE;\n\n    /* No reason to send anything that's been scheduled if connection is\n     * being closed immedately.  This also ensures that packet numbers\n     * sequence is always increasing.\n     */\n    lsquic_send_ctl_drop_scheduled(&conn->ifc_send_ctl);\n\n    if ((conn->ifc_flags & (IFC_TIMED_OUT|IFC_HSK_FAILED))\n                                    && conn->ifc_settings->es_silent_close)\n        return TICK_CLOSE;\n\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0,\n                                                    PNS_APP, CUR_NPATH(conn));\n    if (!packet_out)\n    {\n        LSQ_WARN(\"cannot allocate packet: %s\", strerror(errno));\n        return TICK_CLOSE;\n    }\n\n    assert(conn->ifc_flags & (IFC_ERROR|IFC_ABORTED|IFC_HSK_FAILED));\n    if (conn->ifc_error.u.err != 0)\n    {\n        conn_err = conn->ifc_error;\n        error_reason = conn->ifc_errmsg;\n    }\n    else if (conn->ifc_flags & IFC_ERROR)\n    {\n        conn_err = CONN_ERR(0, TEC_INTERNAL_ERROR);\n        error_reason = \"connection error\";\n    }\n    else if (conn->ifc_flags & IFC_ABORTED)\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = \"user aborted connection\";\n    }\n    else if (conn->ifc_flags & IFC_HSK_FAILED)\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = \"handshake failed\";\n    }\n    else\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = NULL;\n    }\n\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    sz = conn->ifc_conn.cn_pf->pf_gen_connect_close_frame(\n                     packet_out->po_data + packet_out->po_data_sz,\n                     lsquic_packet_out_avail(packet_out), conn_err.app_error,\n                     conn_err.u.err, error_reason,\n                     error_reason ? strlen(error_reason) : 0);\n    if (sz < 0) {\n        LSQ_WARN(\"%s failed\", __func__);\n        return TICK_CLOSE;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_CONNECTION_CLOSE, packet_out->po_data_sz, sz))\n    {\n        LSQ_WARN(\"%s: adding frame to packet failed: %d\", __func__, errno);\n        return TICK_CLOSE;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_CONNECTION_CLOSE;\n    conn->ifc_mflags |= MF_CONN_CLOSE_PACK;\n    LSQ_DEBUG(\"generated CONNECTION_CLOSE frame in its own packet\");\n    return TICK_SEND|TICK_CLOSE;\n}\n\n\nstatic void\nprocess_streams_read_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    int iters;\n    enum stream_q_flags q_flags, needs_service;\n    union prio_iter pi;\n    static const char *const labels[2] = { \"read-0\", \"read-1\", };\n\n    if (TAILQ_EMPTY(&conn->ifc_pub.read_streams))\n        return;\n\n    conn->ifc_pub.cp_flags &= ~CP_STREAM_UNBLOCKED;\n    iters = 0;\n    do\n    {\n        conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.read_streams),\n            TAILQ_LAST(&conn->ifc_pub.read_streams, lsquic_streams_tailq),\n            (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_read_stream),\n            &conn->ifc_pub, labels[iters], NULL, NULL);\n\n        needs_service = 0;\n        for (stream = conn->ifc_pii->pii_first(&pi); stream;\n                                        stream = conn->ifc_pii->pii_next(&pi))\n        {\n            q_flags = stream->sm_qflags & SMQF_SERVICE_FLAGS;\n            lsquic_stream_dispatch_read_events(stream);\n            needs_service |= q_flags ^ (stream->sm_qflags & SMQF_SERVICE_FLAGS);\n        }\n        conn->ifc_pii->pii_cleanup(&pi);\n\n        if (needs_service)\n            service_streams(conn);\n    }\n    while (iters++ == 0 && (conn->ifc_pub.cp_flags & CP_STREAM_UNBLOCKED));\n}\n\n\nstatic void\nprocess_crypto_stream_read_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **stream;\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    for (stream = conn->ifc_u.cli.crypto_streams; stream <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++stream)\n        if (*stream && (*stream)->sm_qflags & SMQF_WANT_READ)\n            lsquic_stream_dispatch_read_events(*stream);\n}\n\n\nstatic void\nprocess_crypto_stream_write_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **stream;\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    for (stream = conn->ifc_u.cli.crypto_streams; stream <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++stream)\n        if (*stream && (*stream)->sm_qflags & SMQF_WRITE_Q_FLAGS)\n            lsquic_stream_dispatch_write_events(*stream);\n}\n\n\nstatic void\nmaybe_conn_flush_special_streams (struct ietf_full_conn *conn)\n{\n    if (!(conn->ifc_flags & IFC_HTTP))\n        return;\n\n    struct lsquic_stream *const streams[] = {\n        conn->ifc_hcso.how_stream,\n        conn->ifc_qeh.qeh_enc_sm_out,\n        conn->ifc_qdh.qdh_dec_sm_out,\n    };\n    struct lsquic_stream *const *stream;\n\n    for (stream = streams; stream < streams + sizeof(streams)\n                                            / sizeof(streams[0]); ++stream)\n        if (*stream && lsquic_stream_has_data_to_flush(*stream))\n            (void) lsquic_stream_flush(*stream);\n}\n\n\nstatic int\nwrite_is_possible (struct ietf_full_conn *conn)\n{\n    const lsquic_packet_out_t *packet_out;\n\n    packet_out = lsquic_send_ctl_last_scheduled(&conn->ifc_send_ctl, PNS_APP,\n                                                        CUR_NPATH(conn), 0);\n    return (packet_out && lsquic_packet_out_avail(packet_out) > 10)\n        || lsquic_send_ctl_can_send(&conn->ifc_send_ctl);\n}\n\n\nstatic void\nprocess_streams_write_events (struct ietf_full_conn *conn, int high_prio)\n{\n    struct lsquic_stream *stream;\n    union prio_iter pi;\n\n    conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.write_streams),\n        TAILQ_LAST(&conn->ifc_pub.write_streams, lsquic_streams_tailq),\n        (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_write_stream),\n        &conn->ifc_pub,\n        high_prio ? \"write-high\" : \"write-low\", NULL, NULL);\n\n    if (high_prio)\n        conn->ifc_pii->pii_drop_non_high(&pi);\n    else\n        conn->ifc_pii->pii_drop_high(&pi);\n\n    for (stream = conn->ifc_pii->pii_first(&pi);\n                        stream && write_is_possible(conn);\n                                    stream = conn->ifc_pii->pii_next(&pi))\n        if (stream->sm_qflags & SMQF_WRITE_Q_FLAGS)\n            lsquic_stream_dispatch_write_events(stream);\n    conn->ifc_pii->pii_cleanup(&pi);\n\n    maybe_conn_flush_special_streams(conn);\n}\n\n\nstatic void\ngenerate_connection_close_packet (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    int sz;\n\n    /* FIXME Select PNS based on handshake status (possible on the client): if\n     * appropriate keys are not available, encryption will fail.\n     */\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0, PNS_APP,\n                                                                CUR_NPATH(conn));\n    if (!packet_out)\n    {\n        ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n        return;\n    }\n\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    sz = conn->ifc_conn.cn_pf->pf_gen_connect_close_frame(\n                packet_out->po_data + packet_out->po_data_sz,\n                lsquic_packet_out_avail(packet_out), 0, TEC_NO_ERROR, NULL, 0);\n    if (sz < 0) {\n        ABORT_ERROR(\"generate_connection_close_packet failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_CONNECTION_CLOSE, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_CONNECTION_CLOSE;\n    conn->ifc_mflags |= MF_CONN_CLOSE_PACK;\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID,\n            \"generated CONNECTION_CLOSE frame in its own packet\");\n    conn->ifc_send_flags &= ~SF_SEND_CONN_CLOSE;\n}\n\n\nstatic void\nlog_conn_flow_control (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"connection flow cap: wrote: %\"PRIu64\n        \"; max: %\"PRIu64, conn->ifc_pub.conn_cap.cc_sent,\n        conn->ifc_pub.conn_cap.cc_max);\n    LSQ_DEBUG(\"connection flow control window: read: %\"PRIu64\n        \"; max: %\"PRIu64, conn->ifc_pub.cfcw.cf_max_recv_off,\n        conn->ifc_pub.cfcw.cf_recv_off);\n}\n\n\nstatic void\ngenerate_ping_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    int pns;\n    int sz;\n\n    if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        packet_out = get_writeable_packet(conn, 1);\n    else\n    {\n        conn->ifc_ping_period += HSK_PING_TIMEOUT;\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                            now + conn->ifc_ping_period);\n        if (iquic_esf_is_enc_level_ready(conn->ifc_conn.cn_enc_session,\n                                         ENC_LEV_HSK))\n            pns = PNS_HSK;\n        else\n            pns = PNS_INIT;\n        packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0, pns,\n                                                    CUR_NPATH(conn));\n        if (packet_out)\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n\n    }\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for PING frame\");\n        return;\n    }\n    sz = conn->ifc_conn.cn_pf->pf_gen_ping_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0) {\n        ABORT_ERROR(\"gen_ping_frame failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_PING, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_PING;\n    LSQ_DEBUG(\"wrote PING frame\");\n    conn->ifc_send_flags &= ~SF_SEND_PING;\n    if (!(conn->ifc_flags & IFC_SERVER))\n        log_conn_flow_control(conn);\n}\n\n\nstatic void\ngenerate_handshake_done_frame (struct ietf_full_conn *conn,\n                                                        lsquic_time_t unused)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int sz;\n\n    need = conn->ifc_conn.cn_pf->pf_handshake_done_frame_size();\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n    sz = conn->ifc_conn.cn_pf->pf_gen_handshake_done_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"generate_handshake_done_frame failed\");\n        return;\n    }\n\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_HANDSHAKE_DONE, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= QUIC_FTBIT_HANDSHAKE_DONE;\n    LSQ_DEBUG(\"generated HANDSHAKE_DONE frame\");\n    conn->ifc_send_flags &= ~SF_SEND_HANDSHAKE_DONE;\n}\n\n\nstatic void\ngenerate_ack_frequency_frame (struct ietf_full_conn *conn, lsquic_time_t unused)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int sz;\n    /* We tell the peer to ignore reordering because we skip packet numbers to\n     * detect optimistic ACK attacks.\n     */\n    const int ignore = 1;\n\n    need = conn->ifc_conn.cn_pf->pf_ack_frequency_frame_size(\n                        conn->ifc_ack_freq_seqno, conn->ifc_last_calc_pack_tol,\n                        conn->ifc_pub.max_peer_ack_usec);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for ACK_FREQUENCY frame\");\n        return;\n    }\n\n    sz = conn->ifc_conn.cn_pf->pf_gen_ack_frequency_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out),\n                            conn->ifc_ack_freq_seqno, conn->ifc_last_calc_pack_tol,\n                            conn->ifc_pub.max_peer_ack_usec, ignore);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"gen_ack_frequency_frame failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_ACK_FREQUENCY, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    conn->ifc_last_pack_tol = conn->ifc_last_calc_pack_tol;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= QUIC_FTBIT_ACK_FREQUENCY;\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID,\n        \"Generated ACK_FREQUENCY(seqno: %u; pack_tol: %u; \"\n        \"upd: %u; ignore: %d)\", conn->ifc_ack_freq_seqno,\n        conn->ifc_last_pack_tol, conn->ifc_pub.max_peer_ack_usec, ignore);\n    LSQ_DEBUG(\"Generated ACK_FREQUENCY(seqno: %u; pack_tol: %u; \"\n        \"upd: %u; ignore: %d)\", conn->ifc_ack_freq_seqno,\n        conn->ifc_last_pack_tol, conn->ifc_pub.max_peer_ack_usec, ignore);\n    ++conn->ifc_ack_freq_seqno;\n    conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n#if LSQUIC_CONN_STATS\n    if (conn->ifc_last_pack_tol > conn->ifc_max_pack_tol_sent)\n        conn->ifc_max_pack_tol_sent = conn->ifc_last_pack_tol;\n    if (conn->ifc_last_pack_tol < conn->ifc_min_pack_tol_sent\n                                    || 0 == conn->ifc_min_pack_tol_sent)\n        conn->ifc_min_pack_tol_sent = conn->ifc_last_pack_tol;\n#endif\n}\n\n\nstatic void\nmaybe_pad_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_out *packet_out)\n{\n    unsigned short avail;\n\n    avail = lsquic_packet_out_avail(packet_out);\n    if (avail)\n    {\n        memset(packet_out->po_data + packet_out->po_data_sz, 0, avail);\n        lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, avail);\n        packet_out->po_frame_types |= QUIC_FTBIT_PADDING;\n        LSQ_DEBUG(\"added %hu-byte PADDING frame to packet %\"PRIu64, avail,\n                                                        packet_out->po_packno);\n    }\n}\n\n\nstatic void\ngenerate_path_chal_frame (struct ietf_full_conn *conn, lsquic_time_t now,\n                                                            unsigned path_id)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_path *copath;\n    unsigned need;\n    int w;\n    char hexbuf[ sizeof(copath->cop_path_chals[0]) * 2 + 1 ];\n\n    /* For now, we only support sending path challenges on a single path.\n     * This restriction may need to be lifted if the client is probing\n     * several paths at the same time.\n     */\n    if (!(conn->ifc_flags & IFC_SERVER))\n        assert(path_id == conn->ifc_mig_path_id);\n\n    copath = &conn->ifc_paths[path_id];\n    if (copath->cop_n_chals >= sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]))\n    {\n        /* path failure? it is non-fatal, keep trying */\n        memmove(&copath->cop_path_chals[0], &copath->cop_path_chals[1],\n            sizeof(copath->cop_path_chals) - sizeof(copath->cop_path_chals[0]));\n        copath->cop_n_chals = sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]) - 1;\n    }\n\n    need = conn->ifc_conn.cn_pf->pf_path_chal_frame_size();\n    packet_out = get_writeable_packet_on_path(conn, need, &copath->cop_path, 1);\n    if (!packet_out)\n        return;\n\n    RAND_bytes((void *) &copath->cop_path_chals[copath->cop_n_chals],\n                                            sizeof(copath->cop_path_chals[0]));\n    w = conn->ifc_conn.cn_pf->pf_gen_path_chal_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            copath->cop_path_chals[copath->cop_n_chals]);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating PATH_CHALLENGE frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte PATH_CHALLENGE frame; challenge: %s\"\n        \", seq: %u\", w,\n        HEXSTR((unsigned char *) &copath->cop_path_chals[copath->cop_n_chals],\n            sizeof(copath->cop_path_chals[copath->cop_n_chals]), hexbuf),\n        copath->cop_n_chals);\n    ++copath->cop_n_chals;\n    EV_LOG_GENERATED_PATH_CHAL_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_PATH_CHALLENGE, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_PATH_CHALLENGE;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << path_id);\n    /* Anti-amplification, only pad packet if allowed\n     *  (confirmed path or incoming packet >= 400 bytes). */\n    if (copath->cop_flags & COP_ALLOW_MTU_PADDING)\n        maybe_pad_packet(conn, packet_out);\n    /* Only retry for confirmed path */\n    if (copath->cop_flags & COP_VALIDATED)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PATH_CHAL + path_id,\n                    now + (INITIAL_CHAL_TIMEOUT << (copath->cop_n_chals - 1)));\n}\n\n\nstatic void\ngenerate_path_chal_0 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 0);\n}\n\n\nstatic void\ngenerate_path_chal_1 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 1);\n}\n\n\nstatic void\ngenerate_path_chal_2 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 2);\n}\n\n\nstatic void\ngenerate_path_chal_3 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 3);\n}\n\n\nstatic void\ngenerate_path_resp_frame (struct ietf_full_conn *conn, lsquic_time_t now,\n                                                            unsigned path_id)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_path *copath;\n    unsigned need;\n    int w;\n\n    copath = &conn->ifc_paths[path_id];\n    need = conn->ifc_conn.cn_pf->pf_path_resp_frame_size();\n    packet_out = get_writeable_packet_on_path(conn, need, &copath->cop_path, 1);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_path_resp_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            copath->cop_inc_chal);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating PATH_RESPONSE frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte PATH_RESPONSE frame; response: %016\"PRIX64,\n        w, copath->cop_inc_chal);\n    EV_LOG_GENERATED_PATH_RESP_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_PATH_RESPONSE, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_PATH_RESPONSE;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    maybe_pad_packet(conn, packet_out);\n    packet_out->po_regen_sz += w;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP << path_id);\n}\n\n\nstatic void\ngenerate_path_resp_0 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 0);\n}\n\n\nstatic void\ngenerate_path_resp_1 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 1);\n}\n\n\nstatic void\ngenerate_path_resp_2 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 2);\n}\n\n\nstatic void\ngenerate_path_resp_3 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 3);\n}\n\n\nstatic struct lsquic_packet_out *\nietf_full_conn_ci_next_packet_to_send (struct lsquic_conn *lconn,\n                                                const struct to_coal *to_coal)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_packet_out *packet_out;\n    const struct conn_path *cpath;\n\n    packet_out = lsquic_send_ctl_next_packet_to_send(&conn->ifc_send_ctl,\n                                                                    to_coal);\n    if (packet_out)\n    {\n        cpath = NPATH2CPATH(packet_out->po_path);\n        lsquic_packet_out_set_spin_bit(packet_out, cpath->cop_spin_bit);\n    }\n    return packet_out;\n}\n\n\nstatic struct lsquic_packet_out *\nietf_full_conn_ci_next_packet_to_send_pre_hsk (struct lsquic_conn *lconn,\n                                                const struct to_coal *to_coal)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_packet_out *packet_out;\n\n    packet_out = ietf_full_conn_ci_next_packet_to_send(lconn, to_coal);\n    if (packet_out)\n        ++conn->ifc_u.cli.ifcli_packets_out;\n    return packet_out;\n}\n\n\nstatic lsquic_time_t\nietf_full_conn_ci_next_tick_time (struct lsquic_conn *lconn, unsigned *why)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_time_t alarm_time, pacer_time, now;\n    enum alarm_id al_id;\n\n    alarm_time = lsquic_alarmset_mintime(&conn->ifc_alset, &al_id);\n    pacer_time = lsquic_send_ctl_next_pacer_time(&conn->ifc_send_ctl);\n\n    if (pacer_time && LSQ_LOG_ENABLED(LSQ_LOG_DEBUG))\n    {\n        now = lsquic_time_now();\n        if (pacer_time < now)\n            LSQ_DEBUG(\"%s: pacer is %\"PRIu64\" usec in the past\", __func__,\n                                                            now - pacer_time);\n    }\n\n    if (alarm_time && pacer_time)\n    {\n        if (alarm_time < pacer_time)\n        {\n            *why = N_AEWS + al_id;\n            return alarm_time;\n        }\n        else\n        {\n            *why = AEW_PACER;\n            return pacer_time;\n        }\n    }\n    else if (alarm_time)\n    {\n        *why = N_AEWS + al_id;\n        return alarm_time;\n    }\n    else if (pacer_time)\n    {\n        *why = AEW_PACER;\n        return pacer_time;\n    }\n    else\n        return 0;\n}\n\n\nstatic ptrdiff_t\ncount_zero_bytes (const unsigned char *p, size_t len)\n{\n    const unsigned char *const end = p + len;\n    while (p < end && 0 == *p)\n        ++p;\n    return len - (end - p);\n}\n\n\nstatic unsigned\nprocess_padding_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    unsigned sz = (unsigned) count_zero_bytes(p, len);\n    EV_LOG_PADDING_FRAME_IN(LSQUIC_LOG_CONN_ID, sz);\n    return sz;\n}\n\n\nstatic void\nhandshake_confirmed (struct ietf_full_conn *conn)\n{\n    ignore_hsk(conn);\n    /* Even in ID-25, we wait for 1-RTT ACK on the server before dropping keys.\n     */\n    conn->ifc_conn.cn_esf.i->esfi_handshake_confirmed(\n                                        conn->ifc_conn.cn_enc_session);\n    if (!(conn->ifc_flags & (IFC_SERVER|IFC_MIGRA)))\n    {\n        conn->ifc_flags |= IFC_MIGRA;   /* Perform migration just once */\n        maybe_start_migration(conn);\n    }\n}\n\n\nstatic float\ncalc_target (lsquic_time_t srtt_ms)\n{\n    if (srtt_ms <= 5 * 1000)\n        return 2.5;\n    if (srtt_ms <= 10 * 1000)\n        return 2.0;\n    if (srtt_ms <= 15 * 1000)\n        return 1.6;\n    if (srtt_ms <= 20 * 1000)\n        return 1.4;\n    if (srtt_ms <= 30 * 1000)\n        return 1.3;\n    if (srtt_ms <= 40 * 1000)\n        return 1.2;\n    if (srtt_ms <= 50 * 1000)\n        return 1.1;\n    if (srtt_ms <= 60 * 1000)\n        return 1.0;\n    if (srtt_ms <= 70 * 1000)\n        return 0.9;\n    if (srtt_ms <= 80 * 1000)\n        return 0.8;\n    if (srtt_ms <= 100 * 1000)\n        return 0.7;\n    return 0.5;\n}\n\n\nstatic void\npacket_tolerance_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = ctx;\n    const float             Kp = conn->ifc_settings->es_ptpc_prop_gain,\n                            Ki = conn->ifc_settings->es_ptpc_int_gain,\n                    err_thresh = conn->ifc_settings->es_ptpc_err_thresh,\n                   err_divisor = conn->ifc_settings->es_ptpc_err_divisor;\n    const unsigned periodicity = conn->ifc_settings->es_ptpc_periodicity;\n    const unsigned max_packtol = conn->ifc_settings->es_ptpc_max_packtol;\n    float avg_acks_per_rtt, error, combined_error, normalized,\n            combined_error_abs, target, rtts;\n    double dt;\n    lsquic_time_t srtt, begin_t;\n\n    srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n\n    if (srtt == 0)\n        goto end;\n    if (0 == conn->ifc_pts.n_acks)\n        /* Don't reset last_sample and calculate average for both this and next\n         * period the next time around.\n         */\n        goto end;\n\n    if (conn->ifc_settings->es_ptpc_dyn_target)\n        target = calc_target(srtt);\n    else\n        target = conn->ifc_settings->es_ptpc_target;\n\n    dt = periodicity * (double) srtt / 1000000;\n\n    begin_t = conn->ifc_pts.last_sample ? conn->ifc_pts.last_sample\n                                                    : conn->ifc_created;\n    /*\n    LSQ_DEBUG(\"begin: %\"PRIu64\"; now: %\"PRIu64\"; SRTT: %\"PRIu64\"; acks: %u\",\n        begin_t, now, srtt, conn->ifc_pts.n_acks);\n    */\n    rtts = (float) (now - begin_t) / (float) srtt;\n    avg_acks_per_rtt = (float) conn->ifc_pts.n_acks / (float) rtts;\n    normalized = avg_acks_per_rtt * M_E / target;\n    error = logf(normalized) - 1;\n    conn->ifc_pts.integral_error += error * (float) dt;\n    combined_error = Kp * error + Ki * conn->ifc_pts.integral_error;\n    combined_error_abs = fabsf(combined_error);\n    conn->ifc_pts.last_sample = now;\n    if (combined_error_abs > err_thresh)\n    {\n        unsigned adj = combined_error_abs / err_divisor;\n        unsigned last_pack_tol = conn->ifc_last_pack_tol;\n        if (0 == last_pack_tol)\n        {\n            last_pack_tol = (unsigned)\n                lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist)\n                                                    / conn->ifc_pts.n_acks;\n            LSQ_DEBUG(\"packets sent: %\"PRIu64\"; ACKs received: %u; implied \"\n                \"tolerance: %u\",\n                lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist),\n                conn->ifc_pts.n_acks, last_pack_tol);\n            if (last_pack_tol < 2)\n                last_pack_tol = 2;\n            else if (last_pack_tol >= max_packtol)\n                last_pack_tol = max_packtol / 2;\n        }\n        if (combined_error > 0)\n        {\n            conn->ifc_last_calc_pack_tol = last_pack_tol + adj;\n            if (conn->ifc_last_calc_pack_tol >= max_packtol)\n            {\n                /* Clamp integral error when we can go no higher */\n                conn->ifc_pts.integral_error -= error * (float) dt;\n                conn->ifc_last_calc_pack_tol = max_packtol;\n            }\n        }\n        else\n        {\n            if (adj + 2 < last_pack_tol)\n                conn->ifc_last_calc_pack_tol = last_pack_tol - adj;\n            else\n                conn->ifc_last_calc_pack_tol = 2;\n            if (conn->ifc_last_calc_pack_tol == 2)\n            {\n                /* Clamp integral error when we can go no lower */\n                conn->ifc_pts.integral_error -= error * (float) dt;\n            }\n        }\n        if (conn->ifc_last_calc_pack_tol != conn->ifc_last_pack_tol)\n        {\n            LSQ_DEBUG(\"old packet tolerance target: %u, schedule ACK_FREQUENCY \"\n                \"%s to %u\", conn->ifc_last_pack_tol,\n                combined_error > 0 ? \"increase\" : \"decrease\",\n                conn->ifc_last_calc_pack_tol);\n            conn->ifc_send_flags |= SF_SEND_ACK_FREQUENCY;\n        }\n        else\n        {\n            LSQ_DEBUG(\"packet tolerance unchanged at %u\", conn->ifc_last_pack_tol);\n            conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n        }\n    }\n    else\n        conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n    LSQ_DEBUG(\"avg ACKs per RTT: %.3f; normalized: %.3f; target: %.3f; error: %.3f; \"\n        \"p-error: %.3f, i-error: %.3f; Overall: %.3f; \"\n        \"packet tolerance: current: %u, last: %u\",\n        avg_acks_per_rtt, normalized, target, error, Kp * error,\n        conn->ifc_pts.integral_error, combined_error,\n        conn->ifc_last_calc_pack_tol, conn->ifc_last_pack_tol);\n    /* Until we have the first value, don't reset the counters */\n    if (conn->ifc_last_calc_pack_tol != 0)\n        conn->ifc_pts.n_acks = 0;\n\n  end:\n    if (lsquic_send_ctl_have_unacked_retx_data(&conn->ifc_send_ctl))\n    {\n        LSQ_DEBUG(\"set PACK_TOL alarm %\"PRIu64\" microseconds into the future\",\n            srtt * periodicity);\n        lsquic_alarmset_set(&conn->ifc_alset, al_id, now + srtt * periodicity);\n    }\n    else\n        LSQ_DEBUG(\"no unacked retx data: do not rearm the packet tolerance \"\n                                                                    \"alarm\");\n}\n\n\nstatic int\nprocess_ack (struct ietf_full_conn *conn, struct ack_info *acki,\n             lsquic_time_t received, lsquic_time_t now)\n{\n    enum packnum_space pns;\n    lsquic_packno_t packno;\n    int one_rtt_acked;\n\n    CONN_STATS(in.n_acks_proc, 1);\n    LSQ_DEBUG(\"Processing ACK\");\n    one_rtt_acked = lsquic_send_ctl_1rtt_acked(&conn->ifc_send_ctl);\n    if (0 == lsquic_send_ctl_got_ack(&conn->ifc_send_ctl, acki, received, now))\n    {\n        pns = acki->pns;\n        packno = lsquic_send_ctl_largest_ack2ed(&conn->ifc_send_ctl, pns);\n        /* It's OK to skip valid packno 0: the alternative is too expensive */\n        if (packno)\n            lsquic_rechist_stop_wait(&conn->ifc_rechist[ pns ], packno + 1);\n        /* ACK of 1-RTT packet indicates that handshake has been confirmed: */\n        if (!one_rtt_acked && lsquic_send_ctl_1rtt_acked(&conn->ifc_send_ctl))\n        {\n            if (!(conn->ifc_flags & IFC_IGNORE_INIT))\n                ignore_init(conn);\n            handshake_confirmed(conn);\n        }\n        return 0;\n    }\n    else\n    {\n        ABORT_ERROR(\"Received invalid ACK\");\n        return -1;\n    }\n}\n\n\nstatic unsigned\nprocess_path_challenge_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct conn_path *const path = &conn->ifc_paths[packet_in->pi_path_id];\n    int parsed_len;\n    char hexbuf[sizeof(path->cop_inc_chal) * 2 + 1];\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_path_chal_frame(p, len,\n        /* It's OK to overwrite incoming challenge, only reply to latest */\n                                                        &path->cop_inc_chal);\n    if (parsed_len > 0)\n    {\n        LSQ_DEBUG(\"received path challenge %s for path #%hhu\",\n            HEXSTR((unsigned char *) &path->cop_inc_chal,\n                sizeof(path->cop_inc_chal), hexbuf), packet_in->pi_path_id);\n        conn->ifc_send_flags |= SF_SEND_PATH_RESP << packet_in->pi_path_id;\n        return parsed_len;\n    }\n    else\n        return 0;\n}\n\n\n/* Why \"maybe?\"  Because it is possible that the peer did not provide us\n * enough CIDs and we had to reuse one.  See init_new_path().\n */\nstatic void\nmaybe_retire_dcid (struct ietf_full_conn *conn, const lsquic_cid_t *dcid)\n{\n    struct conn_path *copath;\n    struct dcid_elem **dce;\n    unsigned eqs;\n\n    eqs = 0;\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n        eqs += LSQUIC_CIDS_EQ(&copath->cop_path.np_dcid, dcid);\n\n    if (eqs > 1)\n    {\n        LSQ_INFOC(\"cannot retire %\"CID_FMT\", as it is used on more than one\"\n            \"path \", CID_BITS(dcid));\n        return;\n    }\n\n    for (dce = conn->ifc_dces; dce < DCES_END(conn); ++dce)\n        if (*dce && ((*dce)->de_flags & DE_ASSIGNED)\n                            && LSQUIC_CIDS_EQ(&(*dce)->de_cid, dcid))\n            break;\n\n    assert(dce < DCES_END(conn));\n    if (dce < DCES_END(conn))\n        retire_dcid(conn, dce);\n}\n\n\n/* Return true if the two paths differ only in peer port */\nstatic int\nonly_peer_port_changed (const struct network_path *old,\n                                                    struct network_path *new)\n{\n    const struct sockaddr *old_sa, *new_sa;\n\n    if (!lsquic_sockaddr_eq(NP_LOCAL_SA(old), NP_LOCAL_SA(new)))\n        return 0;\n\n    old_sa = NP_PEER_SA(old);\n    new_sa = NP_PEER_SA(new);\n    if (old_sa->sa_family == AF_INET)\n        return old_sa->sa_family == new_sa->sa_family\n            && ((struct sockaddr_in *) old_sa)->sin_addr.s_addr\n                            == ((struct sockaddr_in *) new_sa)->sin_addr.s_addr\n            && ((struct sockaddr_in *) old_sa)->sin_port\n                        != /* NE! */((struct sockaddr_in *) new_sa)->sin_port;\n    else\n        return old_sa->sa_family == new_sa->sa_family\n            && ((struct sockaddr_in6 *) old_sa)->sin6_port != /* NE! */\n                                ((struct sockaddr_in6 *) new_sa)->sin6_port\n            && 0 == memcmp(&((struct sockaddr_in6 *) old_sa)->sin6_addr,\n                        &((struct sockaddr_in6 *) new_sa)->sin6_addr,\n                        sizeof(((struct sockaddr_in6 *) new_sa)->sin6_addr));\n}\n\n\nstatic void\nswitch_path_to (struct ietf_full_conn *conn, unsigned char path_id)\n{\n    const unsigned char old_path_id = conn->ifc_cur_path_id;\n    const int keep_path_properties = conn->ifc_settings->es_optimistic_nat\n                    && only_peer_port_changed(CUR_NPATH(conn),\n                                    &conn->ifc_paths[path_id].cop_path);\n\n    assert(conn->ifc_cur_path_id != path_id);\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"switched paths\");\n    if (keep_path_properties)\n    {\n        conn->ifc_paths[path_id].cop_path.np_pack_size\n                                        = CUR_NPATH(conn)->np_pack_size;\n        LSQ_DEBUG(\"keep path properties: set MTU to %hu\",\n                        conn->ifc_paths[path_id].cop_path.np_pack_size);\n    }\n    lsquic_send_ctl_repath(&conn->ifc_send_ctl,\n        CUR_NPATH(conn), &conn->ifc_paths[path_id].cop_path,\n        keep_path_properties);\n    maybe_retire_dcid(conn, &CUR_NPATH(conn)->np_dcid);\n    conn->ifc_cur_path_id = path_id;\n    conn->ifc_pub.path = CUR_NPATH(conn);\n    conn->ifc_conn.cn_cur_cce_idx = CUR_CPATH(conn)->cop_cce_idx;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << old_path_id);\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP << old_path_id);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_PATH_CHAL + old_path_id);\n    if (conn->ifc_flags & IFC_SERVER)\n        wipe_path(conn, old_path_id);\n}\n\n\nstatic unsigned\nprocess_path_response_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct conn_path *path;\n    int parsed_len;\n    unsigned i;\n    unsigned char path_id;\n    uint64_t path_resp;\n    char hexbuf[ sizeof(path_resp) * 2 + 1 ];\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_path_resp_frame(p, len,\n                                                                &path_resp);\n    if (parsed_len <= 0)\n        return 0;\n\n    LSQ_DEBUG(\"received path response: %s\",\n            HEXSTR((unsigned char *) &path_resp, sizeof(path_resp), hexbuf));\n\n    for (path = conn->ifc_paths; path < conn->ifc_paths\n                + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++path)\n    {\n        path_id = path - conn->ifc_paths;\n        if ((1 << path_id) & conn->ifc_used_paths)\n            for (i = 0; i < path->cop_n_chals; ++i)\n                if (path_resp == path->cop_path_chals[i])\n                    goto found;\n    }\n\n    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"received path response %s that does not correspond to any \"\n            \"challenge sent on this path\",\n            HEXSTR((unsigned char *) &path_resp, sizeof(path_resp), hexbuf));\n    return 0;\n\n  found:\n    if (path->cop_flags & COP_ALLOW_MTU_PADDING)\n    {\n        path->cop_flags |= (COP_VALIDATED | COP_VALIDATED_MTU);\n        conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << path_id);\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_PATH_CHAL + path_id);\n    }\n    else\n    {\n        path->cop_flags |= (COP_VALIDATED | COP_ALLOW_MTU_PADDING);\n        conn->ifc_send_flags |= (SF_SEND_PATH_CHAL << path_id);\n    }\n    switch ((path_id != conn->ifc_cur_path_id) |\n                        (!!(path->cop_flags & COP_GOT_NONPROB) << 1))\n    {\n    case 3:\n        LSQ_INFO(\"path validated: switching from path #%hhu to path #%hhu\",\n            conn->ifc_cur_path_id, path_id);\n        switch_path_to(conn, path_id);\n        break;\n    case 1:\n        if (conn->ifc_flags & IFC_SERVER)\n            /* If you see this message in the log file, remember that\n             * COP_GOT_NONPROB is set after all frames in a packet have\n             * been processed.\n             */\n            LSQ_DEBUG(\"path #%hhu validated, but since no non-probing frames \"\n                \"have been received, delay switching to it\",\n                path_id);\n        else\n        {\n            LSQ_INFO(\"path validated: switching from path #%hhu to path #%hhu\",\n                conn->ifc_cur_path_id, path_id);\n            switch_path_to(conn, path_id);\n        }\n        break;\n    default:\n        LSQ_DEBUG(\"current path validated\");\n        break;\n    }\n\n    return parsed_len;\n}\n\n\nstatic lsquic_stream_t *\nfind_stream_by_id (struct ietf_full_conn *conn, lsquic_stream_id_t stream_id)\n{\n    struct lsquic_hash_elem *el;\n    el = lsquic_hash_find(conn->ifc_pub.all_streams, &stream_id,\n                                                            sizeof(stream_id));\n    if (el)\n        return lsquic_hashelem_getdata(el);\n    else\n        return NULL;\n}\n\n\nstatic void\nmaybe_schedule_ss_for_stream (struct ietf_full_conn *conn,\n                lsquic_stream_id_t stream_id, enum http_error_code error_code)\n{\n    struct stream_id_to_ss *sits;\n\n    if (conn_is_stream_closed(conn, stream_id))\n        return;\n\n    sits = malloc(sizeof(*sits));\n    if (!sits)\n        return;\n\n    sits->sits_stream_id = stream_id;\n    sits->sits_error_code = error_code;\n    STAILQ_INSERT_TAIL(&conn->ifc_stream_ids_to_ss, sits, sits_next);\n    conn->ifc_send_flags |= SF_SEND_STOP_SENDING;\n    conn_mark_stream_closed(conn, stream_id);\n}\n\n\nstruct buffered_priority_update\n{\n    struct lsquic_hash_elem     hash_el;\n    lsquic_stream_id_t          stream_id;\n    struct lsquic_ext_http_prio ehp;\n};\n\n\n#define MAX_CRITICAL_STREAM_ID 12\n/* This function is called to create incoming streams */\nstatic struct lsquic_stream *\nnew_stream (struct ietf_full_conn *conn, lsquic_stream_id_t stream_id,\n            enum stream_ctor_flags flags)\n{\n    const struct lsquic_stream_if *iface;\n    struct buffered_priority_update *bpu;\n    struct lsquic_hash_elem *el;\n    void *stream_ctx;\n    struct lsquic_stream *stream;\n    unsigned initial_window;\n    const int call_on_new = flags & SCF_CALL_ON_NEW;\n\n    flags &= ~SCF_CALL_ON_NEW;\n    flags |= SCF_DI_AUTOSWITCH|SCF_IETF;\n\n    if ((conn->ifc_flags & IFC_HTTP) && ((stream_id >> SD_SHIFT) & 1) == SD_UNI)\n    {\n        iface = unicla_if_ptr;\n        stream_ctx = conn;\n#if CLIENT_PUSH_SUPPORT\n        /* FIXME: This logic does not work for push streams.  Perhaps one way\n         * to address this is to reclassify them later?\n         */\n#endif\n        if (stream_id < MAX_CRITICAL_STREAM_ID)\n        {\n            flags |= SCF_CRITICAL;\n            ++conn->ifc_pub.n_special_streams;\n        }\n    }\n    else\n    {\n        iface = conn->ifc_enpub->enp_stream_if;\n        stream_ctx = conn->ifc_enpub->enp_stream_if_ctx;\n        if (conn->ifc_enpub->enp_settings.es_rw_once)\n            flags |= SCF_DISP_RW_ONCE;\n        if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n            flags |= SCF_DELAY_ONCLOSE;\n        if (conn->ifc_flags & IFC_HTTP)\n        {\n            flags |= SCF_HTTP;\n            if (conn->ifc_pii == &ext_prio_iter_if)\n                flags |= SCF_HTTP_PRIO;\n        }\n    }\n\n    if (((stream_id >> SD_SHIFT) & 1) == SD_UNI)\n        initial_window = conn->ifc_enpub->enp_settings\n                                        .es_init_max_stream_data_uni;\n    else\n        initial_window = conn->ifc_enpub->enp_settings\n                                        .es_init_max_stream_data_bidi_remote;\n\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                               iface, stream_ctx, initial_window,\n                               conn->ifc_cfg.max_stream_send, flags);\n    if (stream)\n    {\n        if (conn->ifc_bpus)\n        {\n            el = lsquic_hash_find(conn->ifc_bpus, &stream->id,\n                                                        sizeof(stream->id));\n            if (el)\n            {\n                LSQ_DEBUG(\"apply buffered PRIORITY_UPDATE to stream %\"PRIu64,\n                                                                stream->id);\n                lsquic_hash_erase(conn->ifc_bpus, el);\n                bpu = lsquic_hashelem_getdata(el);\n                (void) lsquic_stream_set_http_prio(stream, &bpu->ehp);\n                free(bpu);\n            }\n        }\n        if (lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n        {\n            if (call_on_new)\n                lsquic_stream_call_on_new(stream);\n        }\n        else\n        {\n            lsquic_stream_destroy(stream);\n            stream = NULL;\n        }\n    }\n    return stream;\n}\n\n\nstatic int\nconn_is_send_only_stream (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (conn->ifc_flags & IFC_SERVER)\n        return sit == SIT_UNI_SERVER;\n    else\n        return sit == SIT_UNI_CLIENT;\n}\n\n\nstatic int\nconn_is_receive_only_stream (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (conn->ifc_flags & IFC_SERVER)\n        return sit == SIT_UNI_CLIENT;\n    else\n        return sit == SIT_UNI_SERVER;\n}\n\n\nstatic unsigned\nprocess_rst_stream_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t stream_id;\n    uint64_t offset, error_code;\n    lsquic_stream_t *stream;\n    int call_on_new;\n    const int parsed_len = conn->ifc_conn.cn_pf->pf_parse_rst_frame(p, len,\n                                            &stream_id, &offset, &error_code);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_RST_STREAM_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_id, offset,\n                                                                error_code);\n    LSQ_DEBUG(\"Got RST_STREAM; stream: %\"PRIu64\"; offset: 0x%\"PRIX64, stream_id,\n                                                                    offset);\n\n    if (conn_is_send_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received RESET_STREAM on send-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    call_on_new = 0;\n    stream = find_stream_by_id(conn, stream_id);\n    if (!stream)\n    {\n        if (conn_is_stream_closed(conn, stream_id))\n        {\n            LSQ_DEBUG(\"got reset frame for closed stream %\"PRIu64, stream_id);\n            return parsed_len;\n        }\n        if (!is_peer_initiated(conn, stream_id))\n        {\n            ABORT_ERROR(\"received reset for never-initiated stream %\"PRIu64,\n                                                                    stream_id);\n            return 0;\n        }\n\n        stream = new_stream(conn, stream_id, 0);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            return 0;\n        }\n        ++call_on_new;\n    }\n\n    if (0 != lsquic_stream_rst_in(stream, offset, error_code))\n    {\n        ABORT_ERROR(\"received invalid RST_STREAM\");\n        return 0;\n    }\n    if (call_on_new)\n        lsquic_stream_call_on_new(stream);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_stop_sending_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id, max_allowed;\n    uint64_t error_code;\n    int parsed_len, our_stream;\n    enum stream_state_sending sss;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stop_sending_frame(p, len,\n                                                    &stream_id, &error_code);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_STOP_SENDING_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_id, error_code);\n    LSQ_DEBUG(\"Got STOP_SENDING; stream: %\"PRIu64\"; error code: %\"PRIu64,\n                                                        stream_id, error_code);\n\n    if (conn_is_receive_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received STOP_SENDING on receive-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    our_stream = !is_peer_initiated(conn, stream_id);\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n    {\n        if (our_stream &&\n                    SSS_READY == (sss = lsquic_stream_sending_state(stream)))\n        {\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"stream %\"PRIu64\" is in \"\n                \"%s state: receipt of STOP_SENDING frame is a violation\",\n                stream_id, lsquic_sss2str[sss]);\n            return 0;\n        }\n        lsquic_stream_stop_sending_in(stream, error_code);\n    }\n    else if (conn_is_stream_closed(conn, stream_id))\n        LSQ_DEBUG(\"stream %\"PRIu64\" is closed: ignore STOP_SENDING frame\",\n            stream_id);\n    else if (our_stream)\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STOP_SENDING frame \"\n            \"on locally initiated stream that has not yet been opened\");\n        return 0;\n    }\n    else\n    {\n        max_allowed = conn->ifc_max_allowed_stream_id[stream_id & SIT_MASK];\n        if (stream_id >= max_allowed)\n        {\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"incoming STOP_SENDING \"\n                \"for stream %\"PRIu64\" would exceed allowed max of %\"PRIu64,\n                stream_id, max_allowed);\n            return 0;\n        }\n        if (conn->ifc_flags & IFC_GOING_AWAY)\n        {\n            LSQ_DEBUG(\"going away: reject new incoming stream %\"PRIu64,\n                                                                    stream_id);\n            maybe_schedule_ss_for_stream(conn, stream_id, HEC_REQUEST_REJECTED);\n            return parsed_len;\n        }\n        stream = new_stream(conn, stream_id, 0);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            return 0;\n        }\n        lsquic_stream_stop_sending_in(stream, error_code);\n        if (!(conn->ifc_flags & IFC_HTTP))\n            lsquic_stream_call_on_new(stream);\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\ndiscard_crypto_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame stream_frame;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                &stream_frame);\n    if (parsed_len > 0)\n    {\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame\", parsed_len);\n        return (unsigned) parsed_len;\n    }\n    else\n        return 0;\n}\n\n\n/* In the server, we only wait for Finished frame */\nstatic unsigned\nprocess_crypto_frame_server (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame stream_frame;\n    enum enc_level enc_level;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                &stream_frame);\n    if (parsed_len < 0)\n        return 0;\n\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    EV_LOG_CRYPTO_FRAME_IN(LSQUIC_LOG_CONN_ID, &stream_frame, enc_level);\n    LSQ_DEBUG(\"Got CRYPTO frame for enc level #%u\", enc_level);\n    if (!(conn->ifc_flags & IFC_PROC_CRYPTO))\n    {\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame: handshake has been confirmed\",\n                                                                    parsed_len);\n        return (unsigned) parsed_len;\n    }\n    if (enc_level < ENC_LEV_HSK)\n    {   /* Must be dup */\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame on level %s\", parsed_len,\n                                                lsquic_enclev2str[enc_level]);\n        return (unsigned) parsed_len;\n    }\n\n    if (0 != conn->ifc_conn.cn_esf.i->esfi_data_in(\n                    conn->ifc_conn.cn_enc_session,\n                    lsquic_packet_in_enc_level(packet_in),\n                    stream_frame.data_frame.df_data,\n                    stream_frame.data_frame.df_size))\n    {\n        LSQ_DEBUG(\"feeding CRYPTO frame to enc session failed\");\n        return 0;\n    }\n\n    if (!conn->ifc_conn.cn_esf.i->esfi_in_init(conn->ifc_conn.cn_enc_session))\n    {\n        LSQ_DEBUG(\"handshake confirmed: send HANDSHAKE_DONE\");\n        conn->ifc_flags &= ~IFC_PROC_CRYPTO;\n        conn->ifc_send_flags |= SF_SEND_HANDSHAKE_DONE;\n\n        lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_RET_CIDS,\n                                                ret_cids_alarm_expired, conn);\n        lsquic_alarmset_set(&conn->ifc_alset, AL_RET_CIDS,\n                                      lsquic_time_now() + RET_CID_TIMEOUT);\n    }\n\n    return (unsigned) parsed_len;\n}\n\n\nstatic unsigned\nprocess_crypto_frame_client (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame *stream_frame;\n    struct lsquic_stream *stream;\n    enum enc_level enc_level;\n    int parsed_len;\n\n    /* Ignore CRYPTO frames in server mode and in client mode after SSL object\n     * is gone.\n     */\n    if (!(conn->ifc_flags & IFC_PROC_CRYPTO))\n        return discard_crypto_frame(conn, packet_in, p, len);\n\n    stream_frame = lsquic_malo_get(conn->ifc_pub.mm->malo.stream_frame);\n    if (!stream_frame)\n    {\n        LSQ_WARN(\"could not allocate stream frame: %s\", strerror(errno));\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                stream_frame);\n    if (parsed_len < 0) {\n        lsquic_malo_put(stream_frame);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                                                \"cannot decode CRYPTO frame\");\n        return 0;\n    }\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    EV_LOG_CRYPTO_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_frame, enc_level);\n    LSQ_DEBUG(\"Got CRYPTO frame for enc level #%u\", enc_level);\n    if ((conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n                                                && enc_level != ENC_LEV_APP)\n    {\n        LSQ_DEBUG(\"handshake complete: ignore CRYPTO frames in \"\n            \"non-forward-secure packets\");\n        return parsed_len;\n    }\n\n    if (conn->ifc_flags & IFC_CLOSING)\n    {\n        LSQ_DEBUG(\"Connection closing: ignore frame\");\n        lsquic_malo_put(stream_frame);\n        return parsed_len;\n    }\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    if (conn->ifc_u.cli.crypto_streams[enc_level])\n        stream = conn->ifc_u.cli.crypto_streams[enc_level];\n    else\n    {\n        stream = lsquic_stream_new_crypto(enc_level, &conn->ifc_pub,\n                    &lsquic_cry_sm_if, conn->ifc_conn.cn_enc_session,\n                    SCF_IETF|SCF_DI_AUTOSWITCH|SCF_CALL_ON_NEW|SCF_CRITICAL);\n        if (!stream)\n        {\n            lsquic_malo_put(stream_frame);\n            ABORT_WARN(\"cannot create crypto stream for level %u\", enc_level);\n            return 0;\n        }\n        conn->ifc_u.cli.crypto_streams[enc_level] = stream;\n        (void) lsquic_stream_wantread(stream, 1);\n    }\n\n    stream_frame->packet_in = lsquic_packet_in_get(packet_in);\n    if (0 != lsquic_stream_frame_in(stream, stream_frame))\n    {\n        ABORT_ERROR(\"cannot insert stream frame\");\n        return 0;\n    }\n\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {   /* To enable decryption, process handshake stream as soon as its\n         * data frames are received.\n         *\n         * TODO: this does not work when packets are reordered.  A more\n         * flexible solution would defer packet decryption if handshake\n         * has not been completed yet.  Nevertheless, this is good enough\n         * for now.\n         */\n        lsquic_stream_dispatch_read_events(stream);\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_crypto_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    if (conn->ifc_flags & IFC_SERVER)\n        return process_crypto_frame_server(conn, packet_in, p, len);\n    else\n        return process_crypto_frame_client(conn, packet_in, p, len);\n}\n\n\nstatic unsigned\nprocess_stream_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame *stream_frame;\n    struct lsquic_stream *stream;\n    int parsed_len;\n\n    stream_frame = lsquic_malo_get(conn->ifc_pub.mm->malo.stream_frame);\n    if (!stream_frame)\n    {\n        LSQ_WARN(\"could not allocate stream frame: %s\", strerror(errno));\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stream_frame(p, len,\n                                                                stream_frame);\n    if (parsed_len < 0) {\n        lsquic_malo_put(stream_frame);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                                                \"cannot decode STREAM frame\");\n        return 0;\n    }\n    EV_LOG_STREAM_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_frame);\n    CONN_STATS(in.stream_frames, 1);\n    CONN_STATS(in.stream_data_sz, stream_frame->data_frame.df_size);\n\n    if (conn_is_send_only_stream(conn, stream_frame->stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STREAM frame \"\n            \"on send-only stream %\"PRIu64, stream_frame->stream_id);\n        return 0;\n    }\n\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) == IFC_HTTP\n                    && SIT_BIDI_SERVER == (stream_frame->stream_id & SIT_MASK))\n    {\n        ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR, \"HTTP/3 server \"\n            \"is not allowed to initiate bidirectional streams (got \"\n            \"STREAM frame for stream %\"PRIu64, stream_frame->stream_id);\n        return 0;\n    }\n\n    if (conn->ifc_flags & IFC_CLOSING)\n    {\n        LSQ_DEBUG(\"Connection closing: ignore frame\");\n        lsquic_malo_put(stream_frame);\n        return parsed_len;\n    }\n\n    stream = find_stream_by_id(conn, stream_frame->stream_id);\n    if (!stream)\n    {\n        if (conn_is_stream_closed(conn, stream_frame->stream_id))\n        {\n            LSQ_DEBUG(\"drop frame for closed stream %\"PRIu64,\n                                                stream_frame->stream_id);\n            lsquic_malo_put(stream_frame);\n            return parsed_len;\n        }\n        if (is_peer_initiated(conn, stream_frame->stream_id))\n        {\n            const lsquic_stream_id_t max_allowed =\n                conn->ifc_max_allowed_stream_id[stream_frame->stream_id & SIT_MASK];\n            if (stream_frame->stream_id >= max_allowed)\n            {\n                ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"incoming stream \"\n                    \"%\"PRIu64\" exceeds allowed max of %\"PRIu64,\n                    stream_frame->stream_id, max_allowed);\n                lsquic_malo_put(stream_frame);\n                return 0;\n            }\n            if (conn->ifc_flags & IFC_GOING_AWAY)\n            {\n                LSQ_DEBUG(\"going away: reject new incoming stream %\"PRIu64,\n                                                    stream_frame->stream_id);\n                maybe_schedule_ss_for_stream(conn, stream_frame->stream_id,\n                                                        HEC_REQUEST_REJECTED);\n                lsquic_malo_put(stream_frame);\n                return parsed_len;\n            }\n        }\n        else\n        {\n            ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STREAM frame \"\n                                                \"for never-initiated stream\");\n            lsquic_malo_put(stream_frame);\n            return 0;\n        }\n        stream = new_stream(conn, stream_frame->stream_id, SCF_CALL_ON_NEW);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            lsquic_malo_put(stream_frame);\n            return 0;\n        }\n        if (SD_BIDI == ((stream_frame->stream_id >> SD_SHIFT) & 1)\n                && (!valid_stream_id(conn->ifc_max_req_id)\n                        || conn->ifc_max_req_id < stream_frame->stream_id))\n            conn->ifc_max_req_id = stream_frame->stream_id;\n    }\n\n    stream_frame->packet_in = lsquic_packet_in_get(packet_in);\n    if (0 != lsquic_stream_frame_in(stream, stream_frame))\n    {\n        ABORT_ERROR(\"cannot insert stream frame\");\n        return 0;\n    }\n\n    /* Don't wait for the regular on_read dispatch in order to save an\n     * unnecessary blocked/unblocked sequence.\n     */\n    if ((conn->ifc_flags & IFC_HTTP) && conn->ifc_qdh.qdh_enc_sm_in == stream)\n        lsquic_stream_dispatch_read_events(conn->ifc_qdh.qdh_enc_sm_in);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_ack_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct ack_info *new_acki;\n    enum packnum_space pns;\n    int parsed_len;\n    lsquic_time_t warn_time;\n\n    CONN_STATS(in.n_acks, 1);\n\n    if (conn->ifc_flags & IFC_HAVE_SAVED_ACK)\n        new_acki = conn->ifc_pub.mm->acki;\n    else\n        new_acki = &conn->ifc_ack;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_ack_frame(p, len, new_acki,\n                                                        conn->ifc_cfg.ack_exp);\n    if (parsed_len < 0)\n        goto err;\n\n    /* This code to throw out old ACKs is what keeps us compliant with this\n     * requirement:\n     *\n     * [draft-ietf-quic-transport-18] Section 13.3.2.\n     *\n     > Processing counts out of order can result in verification failure.\n     > An endpoint SHOULD NOT perform this verification if the ACK frame is\n     > received in a packet with packet number lower than a previously\n     > received ACK frame.  Verifying based on ACK frames that arrive out of\n     > order can result in disabling ECN unnecessarily.\n     */\n    pns = lsquic_hety2pns[ packet_in->pi_header_type ];\n    if (is_valid_packno(conn->ifc_max_ack_packno[pns]) &&\n                        packet_in->pi_packno <= conn->ifc_max_ack_packno[pns])\n    {\n        LSQ_DEBUG(\"Ignore old ack (max %\"PRIu64\")\",\n                                                conn->ifc_max_ack_packno[pns]);\n        return parsed_len;\n    }\n\n    EV_LOG_ACK_FRAME_IN(LSQUIC_LOG_CONN_ID, new_acki);\n    conn->ifc_max_ack_packno[pns] = packet_in->pi_packno;\n    new_acki->pns = pns;\n\n    ++conn->ifc_pts.n_acks;\n\n    /* Only cache ACKs for PNS_APP */\n    if (pns == PNS_APP && new_acki == &conn->ifc_ack)\n    {\n        LSQ_DEBUG(\"Saved ACK\");\n        conn->ifc_flags |= IFC_HAVE_SAVED_ACK;\n        conn->ifc_saved_ack_received = packet_in->pi_received;\n    }\n    else if (pns == PNS_APP)\n    {\n        if (0 == lsquic_merge_acks(&conn->ifc_ack, new_acki))\n        {\n            CONN_STATS(in.n_acks_merged, 1);\n            LSQ_DEBUG(\"merged into saved ACK, getting %s\",\n                (lsquic_acki2str(&conn->ifc_ack, conn->ifc_pub.mm->ack_str,\n                                MAX_ACKI_STR_SZ), conn->ifc_pub.mm->ack_str));\n        }\n        else\n        {\n            LSQ_DEBUG(\"could not merge new ACK into saved ACK\");\n            if (0 != process_ack(conn, &conn->ifc_ack, packet_in->pi_received,\n                                                        packet_in->pi_received))\n                goto err;\n            conn->ifc_ack = *new_acki;\n        }\n        conn->ifc_saved_ack_received = packet_in->pi_received;\n    }\n    else\n    {\n        if (0 != process_ack(conn, new_acki, packet_in->pi_received,\n                                                packet_in->pi_received))\n            goto err;\n    }\n\n    return parsed_len;\n\n  err:\n    warn_time = lsquic_time_now();\n    if (0 == conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL]\n        || conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL]\n                + WARNING_INTERVAL < warn_time)\n    {\n        conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL] = warn_time;\n        LSQ_WARN(\"Invalid ACK frame\");\n    }\n    return 0;\n}\n\n\nstatic unsigned\nprocess_ping_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{   /* This frame causes ACK frame to be queued, but nothing to do here;\n     * return the length of this frame.\n     */\n    EV_LOG_PING_FRAME_IN(LSQUIC_LOG_CONN_ID);\n    if (conn->ifc_flags & IFC_SERVER)\n        log_conn_flow_control(conn);\n\n    LSQ_DEBUG(\"received PING frame, update last progress to %\"PRIu64,\n                                            conn->ifc_pub.last_tick);\n    conn->ifc_pub.last_prog = conn->ifc_pub.last_tick;\n\n    return 1;\n}\n\n\nstatic int\nis_benign_transport_error_code (uint64_t error_code)\n{\n    switch (error_code)\n    {\n    case TEC_NO_ERROR:\n    case TEC_INTERNAL_ERROR:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\n\nstatic int\nis_benign_application_error_code (uint64_t error_code)\n{\n    switch (error_code)\n    {\n    case HEC_NO_ERROR:\n    case HEC_INTERNAL_ERROR:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\n\nstatic unsigned\nprocess_connection_close_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t error_code;\n    uint16_t reason_len;\n    uint8_t reason_off;\n    int parsed_len, app_error;\n    const char *ua;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_connect_close_frame(p, len,\n                            &app_error, &error_code, &reason_len, &reason_off);\n    if (parsed_len < 0)\n        return 0;\n    EV_LOG_CONNECTION_CLOSE_FRAME_IN(LSQUIC_LOG_CONN_ID, error_code,\n                            (int) reason_len, (const char *) p + reason_off);\n    if (LSQ_LOG_ENABLED(LSQ_LOG_NOTICE)\n        && !(   (!app_error && is_benign_transport_error_code(error_code))\n              ||( app_error && is_benign_application_error_code(error_code))))\n    {\n        if (conn->ifc_flags & IFC_HTTP)\n        {\n            ua = lsquic_qdh_get_ua(&conn->ifc_qdh);\n            if (!ua)\n                ua = \"unknown peer\";\n        }\n        else\n            ua = \"non-HTTP/3 peer\";\n        LSQ_NOTICE(\"Received CONNECTION_CLOSE from <%s> with %s-level error \"\n            \"code %\"PRIu64\", reason: `%.*s'\", ua,\n            app_error ? \"application\" : \"transport\", error_code,\n            (int) reason_len, (const char *) p + reason_off);\n    }\n    else\n        LSQ_INFO(\"Received CONNECTION_CLOSE frame (%s-level code: %\"PRIu64\"; \"\n            \"reason: %.*s)\", app_error ? \"application\" : \"transport\",\n                error_code, (int) reason_len, (const char *) p + reason_off);\n    if (conn->ifc_enpub->enp_stream_if->on_conncloseframe_received)\n        conn->ifc_enpub->enp_stream_if->on_conncloseframe_received(\n            &conn->ifc_conn, app_error, error_code, (const char *) p + reason_off, reason_len);\n    conn->ifc_flags |= IFC_RECV_CLOSE|IFC_CLOSING;\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_data_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t max_data;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_data(p, len, &max_data);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX MAX_DATA frame; offset: %\"PRIu64,\n        max_data);\n    if (max_data > conn->ifc_pub.conn_cap.cc_max)\n    {\n        LSQ_DEBUG(\"max data goes from %\"PRIu64\" to %\"PRIu64,\n                                conn->ifc_pub.conn_cap.cc_max, max_data);\n        conn->ifc_pub.conn_cap.cc_max = max_data;\n    }\n    else\n        LSQ_DEBUG(\"newly supplied max data=%\"PRIu64\" is not larger than the \"\n            \"current value=%\"PRIu64\", ignoring\", max_data,\n                                conn->ifc_pub.conn_cap.cc_max);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_stream_data_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    uint64_t max_data;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_stream_data_frame(p, len,\n                                                            &stream_id, &max_data);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX MAX_STREAM_DATA frame; \"\n        \"stream_id: %\"PRIu64\"; offset: %\"PRIu64, stream_id, max_data);\n    if (conn_is_receive_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received MAX_STREAM_DATA on receive-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n        lsquic_stream_window_update(stream, max_data);\n    else if (conn_is_stream_closed(conn, stream_id))\n        LSQ_DEBUG(\"stream %\"PRIu64\" is closed: ignore MAX_STREAM_DATA frame\",\n                                                                    stream_id);\n    else\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received MAX_STREAM_DATA \"\n            \"frame on never-opened stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_streams_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t max_stream_id;\n    enum stream_id_type sit;\n    enum stream_dir sd;\n    uint64_t max_streams;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_streams_frame(p, len,\n                                                            &sd, &max_streams);\n    if (parsed_len < 0)\n        return 0;\n\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, sd);\n    max_stream_id = max_streams << SIT_SHIFT;\n\n    if (max_stream_id > VINT_MAX_VALUE)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"MAX_STREAMS: max %s stream ID of %\"PRIu64\" exceeds maximum \"\n            \"stream ID\", sd == SD_BIDI ? \"bidi\" : \"uni\", max_stream_id);\n        return 0;\n    }\n\n    if (max_stream_id > conn->ifc_max_allowed_stream_id[sit])\n    {\n        LSQ_DEBUG(\"max %s stream ID updated from %\"PRIu64\" to %\"PRIu64,\n            sd == SD_BIDI ? \"bidi\" : \"uni\",\n            conn->ifc_max_allowed_stream_id[sit], max_stream_id);\n        conn->ifc_max_allowed_stream_id[sit] = max_stream_id;\n    }\n    else\n        LSQ_DEBUG(\"ignore old max %s streams value of %\"PRIu64,\n            sd == SD_BIDI ? \"bidi\" : \"uni\", max_streams);\n\n    return parsed_len;\n}\n\n\n/* Returns true if current DCID was retired.  In this case, it must be\n * replaced.\n */\nstatic int\nretire_dcids_prior_to (struct ietf_full_conn *conn, unsigned retire_prior_to)\n{\n    struct dcid_elem **el;\n    int update_cur_dcid = 0;\n#if LSQUIC_LOWEST_LOG_LEVEL >= LSQ_LOG_DEBUG\n    unsigned count = 0;\n#endif\n\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (*el && (*el)->de_seqno < retire_prior_to)\n        {\n            update_cur_dcid |= LSQUIC_CIDS_EQ(&(*el)->de_cid, CUR_DCID(conn));\n            retire_dcid(conn, el);\n#if LSQUIC_LOWEST_LOG_LEVEL >= LSQ_LOG_DEBUG\n            ++count;\n#endif\n        }\n\n    LSQ_DEBUG(\"retired %u DCID%s due to Retire Prior To=%u\", count,\n        count != 1 ? \"s\" : \"\", retire_prior_to);\n    return update_cur_dcid;\n}\n\n\nstatic int\ninsert_new_dcid (struct ietf_full_conn *conn, uint64_t seqno,\n    const lsquic_cid_t *cid, const unsigned char *token, int update_cur_dcid)\n{\n    struct dcid_elem **dce, **el;\n    char tokstr[IQUIC_SRESET_TOKEN_SZ * 2 + 1];\n\n    dce = NULL;\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (*el)\n        {\n            if ((*el)->de_seqno == seqno)\n            {\n                if (!LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))\n                {\n                    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                        \"NEW_CONNECTION_ID: already have CID seqno %\"PRIu64\n                        \" but with a different CID\", seqno);\n                    return -1;\n                }\n                else\n                {\n                    LSQ_DEBUG(\"Ignore duplicate CID seqno %\"PRIu64, seqno);\n                    return 0;\n                }\n            }\n            else if (LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                    \"NEW_CONNECTION_ID: received the same CID with sequence \"\n                    \"numbers %u and %\"PRIu64, (*el)->de_seqno, seqno);\n                return -1;\n            }\n            else if (((*el)->de_flags & DE_SRST)\n                    && 0 == memcmp((*el)->de_srst, token,\n                                                    IQUIC_SRESET_TOKEN_SZ))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                    \"NEW_CONNECTION_ID: received second instance of reset \"\n                    \"token %s in seqno %\"PRIu64\", same as in seqno %u\",\n                    (lsquic_hexstr(token, IQUIC_SRESET_TOKEN_SZ, tokstr,\n                                                    sizeof(tokstr)), tokstr),\n                    seqno, (*el)->de_seqno);\n                return -1;\n            }\n        }\n        else if (!dce)\n            dce = el;\n\n    if (!dce)\n    {\n        ABORT_QUIETLY(0, TEC_CONNECTION_ID_LIMIT_ERROR,\n            \"NEW_CONNECTION_ID: received connection ID that is going over the \"\n            \"limit of %u CIDs\", MAX_IETF_CONN_DCIDS);\n        return -1;\n    }\n\n    *dce = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n    if (*dce)\n    {\n        memset(*dce, 0, sizeof(**dce));\n        (*dce)->de_seqno = seqno;\n        (*dce)->de_cid = *cid;\n        memcpy((*dce)->de_srst, token, sizeof((*dce)->de_srst));\n        (*dce)->de_flags |= DE_SRST;\n        if (update_cur_dcid)\n        {\n            *CUR_DCID(conn) = *cid;\n            if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n                CUR_CPATH(conn)->cop_spin_bit = 0;\n        }\n    }\n    else\n        LSQ_WARN(\"cannot allocate dce to insert DCID seqno %\"PRIu64, seqno);\n\n    return 0;\n}\n\n\nstatic unsigned\nprocess_new_connection_id_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const unsigned char *token;\n    const char *action_str;\n    lsquic_cid_t cid;\n    uint64_t seqno, retire_prior_to;\n    int parsed_len, update_cur_dcid;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_new_conn_id(p, len,\n                                        &seqno, &retire_prior_to, &cid, &token);\n    if (parsed_len < 0)\n    {\n        if (parsed_len == -2)\n            ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                \"NEW_CONNECTION_ID contains invalid CID length\");\n        return 0;\n    }\n\n    if (seqno > UINT32_MAX || retire_prior_to > UINT32_MAX)\n    {   /* It is wasteful to use 8-byte integers for these counters, so this\n         * is the guard here.  This will \"Never Happen.\"\n         */\n        LSQ_INFO(\"ignoring unreasonably high seqno=%\"PRIu64\" or Retire Prior \"\n            \"To=%\"PRIu64, seqno, retire_prior_to);\n        return parsed_len;\n    }\n\n    if (retire_prior_to > seqno)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"NEW_CONNECTION_ID: Retire Prior To=%\"PRIu64\" is larger then the \"\n            \"Sequence Number=%\"PRIu64, retire_prior_to, seqno);\n        return 0;\n    }\n\n    if (CUR_DCID(conn)->len == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"Received NEW_CONNECTION_ID \"\n            \"frame, but current DCID is zero-length\");\n        return 0;\n    }\n\n    if (seqno < conn->ifc_last_retire_prior_to)\n    {\n        retire_seqno(conn, seqno);\n        action_str = \"Ignored (seqno smaller than last retire_prior_to\";\n        goto end;\n    }\n\n    if (retire_prior_to > conn->ifc_last_retire_prior_to)\n    {\n        conn->ifc_last_retire_prior_to = retire_prior_to;\n        update_cur_dcid = retire_dcids_prior_to(conn, retire_prior_to);\n    }\n    else\n        update_cur_dcid = 0;\n\n    if (0 != insert_new_dcid(conn, seqno, &cid, token, update_cur_dcid))\n        return 0;\n    action_str = \"Saved\";\n\n  end:\n    LSQ_DEBUGC(\"Got new connection ID from peer: seq=%\"PRIu64\"; \"\n        \"cid: %\"CID_FMT\".  %s.\", seqno, CID_BITS(&cid), action_str);\n    return parsed_len;\n}\n\n\nstatic void\nretire_cid (struct ietf_full_conn *conn, struct conn_cid_elem *cce,\n                                                        lsquic_time_t now)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    lsquic_time_t drain_time;\n\n    drain_time = calc_drain_time(conn);\n    LSQ_DEBUGC(\"retiring CID %\"CID_FMT\"; seqno: %u; %s; drain time %\"PRIu64\n                \" usec\", CID_BITS(&cce->cce_cid), cce->cce_seqno,\n                (cce->cce_flags & CCE_SEQNO) ? \"\" : \"original\", drain_time);\n\n    if (cce->cce_flags & CCE_SEQNO)\n        --conn->ifc_active_cids_count;\n    lsquic_engine_retire_cid(conn->ifc_enpub, lconn, cce - lconn->cn_cces, now,\n                                                                    drain_time);\n    memset(cce, 0, sizeof(*cce));\n\n    if (can_issue_cids(conn)\n        && !(lsquic_alarmset_is_set(&conn->ifc_alset, AL_CID_THROT)))\n        maybe_get_rate_available_scid_slot(conn, now);\n}\n\n\nstatic unsigned\nprocess_retire_connection_id_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n    uint64_t seqno;\n    int parsed_len;\n\n    /* [draft-ietf-quic-transport-25] Section 19.16\n     *\n     * - Peer cannot retire zero-lenth CID. (MUST treat as PROTOCOL_VIOLATION)\n     * - Peer cannot retire CID with sequence number that has not been\n     *   allocated yet. (MUST treat as PROTOCOL_VIOLATION)\n     * - Peer cannot retire CID that matches the DCID in packet.\n     *   (MAY treat as PROTOCOL_VIOLATION)\n     */\n    if (conn->ifc_settings->es_scid_len == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire zero-length CID\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_retire_cid_frame(p, len,\n                                                                    &seqno);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"got RETIRE_CONNECTION_ID frame: \"\n                                                        \"seqno=%\"PRIu64, seqno);\n    if (seqno >= conn->ifc_scid_seqno)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire CID seqno=\"\n                        \"%\"PRIu64\" as it has not been allocated yet\", seqno);\n        return 0;\n    }\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if ((lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces))\n                && (cce->cce_flags & CCE_SEQNO)\n                && cce->cce_seqno == seqno))\n            break;\n    /* NOTE: https://github.com/litespeedtech/lsquic/issues/334\n    conn->ifc_active_cids_count -= seqno >= conn->ifc_first_active_cid_seqno;\n    */\n    if (cce < END_OF_CCES(lconn))\n    {\n        if (LSQUIC_CIDS_EQ(&cce->cce_cid, &packet_in->pi_dcid))\n        {\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire CID \"\n                \"seqno=%\"PRIu64\", for it is used as DCID in the packet\", seqno);\n            return 0;\n        }\n        retire_cid(conn, cce, packet_in->pi_received);\n        if (lconn->cn_cur_cce_idx == cce - lconn->cn_cces)\n        {\n            cce = find_cce_by_cid(conn, &packet_in->pi_dcid);\n            if (cce)\n            {\n                cce->cce_flags |= CCE_USED;\n                lconn->cn_cur_cce_idx = cce - lconn->cn_cces;\n                LSQ_DEBUGC(\"current SCID was retired; set current SCID to \"\n                    \"%\"CID_FMT\" based on DCID in incoming packet\",\n                    CID_BITS(&packet_in->pi_dcid));\n            }\n            else\n                LSQ_WARN(\"current SCID was retired; no new SCID candidate\");\n                /* This could theoretically happen when zero-length CIDs were\n                 * used.  Currently, there should be no way lsquic could get\n                 * into this situation.\n                 */\n        }\n    }\n    else\n        LSQ_DEBUG(\"cannot retire CID seqno=%\"PRIu64\": not found\", seqno);\n    LOG_SCIDS(conn);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_new_token_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const unsigned char *token;\n    size_t token_sz;\n    char *token_str;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_new_token_frame(p, len, &token,\n                                                                    &token_sz);\n    if (parsed_len < 0)\n        return 0;\n\n    if (0 == token_sz)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR, \"received an empty \"\n            \"NEW_TOKEN frame\");\n        return 0;\n    }\n\n    if (conn->ifc_flags & IFC_SERVER)\n    {   /* [draft-ietf-quic-transport-34] Section 19.7 */\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                                    \"received unexpected NEW_TOKEN frame\");\n        return 0;\n    }\n\n    if (LSQ_LOG_ENABLED(LSQ_LOG_DEBUG)\n                            || LSQ_LOG_ENABLED_EXT(LSQ_LOG_DEBUG, LSQLM_EVENT))\n    {\n        token_str = malloc(token_sz * 2 + 1);\n        if (token_str)\n        {\n            lsquic_hexstr(token, token_sz, token_str, token_sz * 2 + 1);\n            LSQ_DEBUG(\"Got %zu-byte NEW_TOKEN %s\", token_sz, token_str);\n            EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"got NEW_TOKEN %s\",\n                                                                    token_str);\n            free(token_str);\n        }\n    }\n    if (conn->ifc_enpub->enp_stream_if->on_new_token)\n        conn->ifc_enpub->enp_stream_if->on_new_token(\n                        conn->ifc_enpub->enp_stream_if_ctx, token, token_sz);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_stream_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    uint64_t peer_off;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stream_blocked_frame(p,\n                                                len, &stream_id, &peer_off);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX STREAM_BLOCKED frame: stream \"\n        \"%\"PRIu64\"; offset %\"PRIu64, stream_id, peer_off);\n    LSQ_DEBUG(\"received STREAM_BLOCKED frame: stream %\"PRIu64\n                                    \"; offset %\"PRIu64, stream_id, peer_off);\n\n    if (conn_is_send_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received STREAM_BLOCKED frame on send-only stream %\"PRIu64,\n                                                                stream_id);\n        return 0;\n    }\n\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n        lsquic_stream_peer_blocked(stream, peer_off);\n    else\n        LSQ_DEBUG(\"stream %\"PRIu64\" not found - ignore STREAM_BLOCKED frame\",\n            stream_id);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_streams_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t max_stream_id;\n    uint64_t stream_limit;\n    enum stream_dir sd;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_streams_blocked_frame(p,\n                                                len, &sd, &stream_limit);\n    if (parsed_len < 0)\n        return 0;\n\n    max_stream_id = stream_limit << SIT_SHIFT;\n    if (max_stream_id > VINT_MAX_VALUE)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"STREAMS_BLOCKED: max %s stream ID of %\"PRIu64\" exceeds maximum \"\n            \"stream ID\", sd == SD_BIDI ? \"bidi\" : \"uni\", max_stream_id);\n        return 0;\n    }\n\n    LSQ_DEBUG(\"received STREAMS_BLOCKED frame: limited to %\"PRIu64\n        \" %sdirectional stream%.*s\", stream_limit, sd == SD_UNI ? \"uni\" : \"bi\",\n        stream_limit != 1, \"s\");\n    /* We don't do anything with this information -- at least for now */\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t peer_off;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_blocked_frame(p, len,\n                                                                &peer_off);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX BLOCKED frame: offset %\"PRIu64,\n                                                                    peer_off);\n    LSQ_DEBUG(\"received BLOCKED frame: offset %\"PRIu64, peer_off);\n\n    if (peer_off > conn->ifc_last_max_data_off_sent\n                                && !(conn->ifc_send_flags & SF_SEND_MAX_DATA))\n    {\n        conn->ifc_send_flags |= SF_SEND_MAX_DATA;\n        LSQ_DEBUG(\"marked to send MAX_DATA frame\");\n    }\n    else if (conn->ifc_send_flags & SF_SEND_MAX_DATA)\n        LSQ_DEBUG(\"MAX_STREAM_DATA frame is already scheduled\");\n    else\n        LSQ_DEBUG(\"MAX_DATA(%\"PRIu64\") has already been either \"\n            \"packetized or sent to peer\", conn->ifc_last_max_data_off_sent);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_handshake_done_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_handshake_done_frame(p, len);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX HANDSHAKE_DONE frame\");\n    LSQ_DEBUG(\"received HANDSHAKE_DONE frame\");\n\n    if (conn->ifc_flags & IFC_SERVER)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Client cannot send HANDSHAKE_DONE frame\");\n        return 0;\n    }\n\n    handshake_confirmed(conn);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_ack_frequency_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t seqno, pack_tol, upd_mad;\n    int parsed_len, ignore;\n\n    if (!conn->ifc_settings->es_delayed_acks\n        && !(conn->ifc_flags & IFC_DELAYED_ACKS))\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected ACK_FREQUENCY frame (not negotiated)\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_ack_frequency_frame(p, len,\n                                        &seqno, &pack_tol, &upd_mad, &ignore);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX ACK_FREQUENCY frame: (seqno: %\"PRIu64\"; \"\n        \"pack_tol: %\"PRIu64\"; upd: %\"PRIu64\"; ignore: %d)\", seqno,\n        pack_tol, upd_mad, ignore);\n    LSQ_DEBUG(\"RX ACK_FREQUENCY frame: (seqno: %\"PRIu64\"; pack_tol: %\"PRIu64\"; \"\n        \"upd: %\"PRIu64\"; ignore: %d)\", seqno, pack_tol, upd_mad,\n        ignore);\n\n    if (pack_tol == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Packet Tolerance of zero is invalid\");\n        return 0;\n    }\n\n    if (upd_mad < TP_MIN_ACK_DELAY)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Update Max Ack Delay value of %\"PRIu64\" usec is invalid, as it \"\n            \"is smaller than the advertised min_ack_delay of %u usec\",\n            upd_mad, TP_MIN_ACK_DELAY);\n        return 0;\n    }\n\n    if (conn->ifc_max_ack_freq_seqno > 0\n                                    && seqno <= conn->ifc_max_ack_freq_seqno)\n    {\n        LSQ_DEBUG(\"ignore old ACK_FREQUENCY frame\");\n        return parsed_len;\n    }\n    conn->ifc_max_ack_freq_seqno = seqno;\n\n    if (pack_tol < UINT_MAX)\n    {\n        LSQ_DEBUG(\"set packet tolerance to %\"PRIu64, pack_tol);\n        conn->ifc_max_retx_since_last_ack = pack_tol;\n    }\n\n    if (upd_mad != conn->ifc_max_ack_delay)\n    {\n        conn->ifc_max_ack_delay = upd_mad;\n        LSQ_DEBUG(\"set Max Ack Delay to new value of %\"PRIu64\" usec\",\n            conn->ifc_max_ack_delay);\n    }\n    else\n        LSQ_DEBUG(\"keep Max Ack Delay unchanged at %\"PRIu64\" usec\",\n            conn->ifc_max_ack_delay);\n\n    if (ignore)\n    {\n        conn->ifc_mflags |= MF_IGNORE_MISSING;\n        conn->ifc_flags &= ~IFC_ACK_HAD_MISS;\n    }\n    else\n        conn->ifc_mflags &= ~MF_IGNORE_MISSING;\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_timestamp_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected TIMESTAMP frame (not negotiated)\");\n    return 0;\n}\n\n\nstatic unsigned\nprocess_datagram_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const void *data;\n    size_t data_sz;\n    int parsed_len;\n\n    if (!(conn->ifc_flags & IFC_DATAGRAMS))\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected DATAGRAM frame (not negotiated)\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_datagram_frame(p, len,\n                                                            &data, &data_sz);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"%zd-byte DATAGRAM\", data_sz);\n    LSQ_DEBUG(\"%zd-byte DATAGRAM\", data_sz);\n\n    conn->ifc_enpub->enp_stream_if->on_datagram(&conn->ifc_conn, data, data_sz);\n\n    return parsed_len;\n}\n\n\ntypedef unsigned (*process_frame_f)(\n    struct ietf_full_conn *, struct lsquic_packet_in *,\n    const unsigned char *p, size_t);\n\n\nstatic process_frame_f const process_frames[N_QUIC_FRAMES] =\n{\n    [QUIC_FRAME_PADDING]            =  process_padding_frame,\n    [QUIC_FRAME_RST_STREAM]         =  process_rst_stream_frame,\n    [QUIC_FRAME_CONNECTION_CLOSE]   =  process_connection_close_frame,\n    [QUIC_FRAME_MAX_DATA]           =  process_max_data_frame,\n    [QUIC_FRAME_MAX_STREAM_DATA]    =  process_max_stream_data_frame,\n    [QUIC_FRAME_MAX_STREAMS]        =  process_max_streams_frame,\n    [QUIC_FRAME_PING]               =  process_ping_frame,\n    [QUIC_FRAME_BLOCKED]            =  process_blocked_frame,\n    [QUIC_FRAME_STREAM_BLOCKED]     =  process_stream_blocked_frame,\n    [QUIC_FRAME_STREAMS_BLOCKED]    =  process_streams_blocked_frame,\n    [QUIC_FRAME_NEW_CONNECTION_ID]  =  process_new_connection_id_frame,\n    [QUIC_FRAME_NEW_TOKEN]          =  process_new_token_frame,\n    [QUIC_FRAME_STOP_SENDING]       =  process_stop_sending_frame,\n    [QUIC_FRAME_ACK]                =  process_ack_frame,\n    [QUIC_FRAME_PATH_CHALLENGE]     =  process_path_challenge_frame,\n    [QUIC_FRAME_PATH_RESPONSE]      =  process_path_response_frame,\n    [QUIC_FRAME_RETIRE_CONNECTION_ID] =  process_retire_connection_id_frame,\n    [QUIC_FRAME_STREAM]             =  process_stream_frame,\n    [QUIC_FRAME_CRYPTO]             =  process_crypto_frame,\n    [QUIC_FRAME_HANDSHAKE_DONE]     =  process_handshake_done_frame,\n    [QUIC_FRAME_ACK_FREQUENCY]      =  process_ack_frequency_frame,\n    [QUIC_FRAME_TIMESTAMP]          =  process_timestamp_frame,\n    [QUIC_FRAME_DATAGRAM]           =  process_datagram_frame,\n};\n\n\nstatic unsigned\nprocess_packet_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    enum enc_level enc_level;\n    enum quic_frame_type type;\n    char str[8 * 2 + 1];\n\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    type = conn->ifc_conn.cn_pf->pf_parse_frame_type(p, len);\n    if (lsquic_legal_frames_by_level[conn->ifc_conn.cn_version][enc_level]\n                                                                & (1 << type))\n    {\n        LSQ_DEBUG(\"about to process %s frame\", frame_type_2_str[type]);\n        packet_in->pi_frame_types |= 1 << type;\n        return process_frames[type](conn, packet_in, p, len);\n    }\n    else\n    {\n        LSQ_DEBUG(\"invalid frame %u (bytes: %s) at encryption level %s\",\n            type, HEXSTR(p, MIN(len, 8), str), lsquic_enclev2str[enc_level]);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR, \"invalid frame\");\n        return 0;\n    }\n}\n\n\nstatic struct dcid_elem *\nfind_unassigned_dcid (struct ietf_full_conn *conn)\n{\n    struct dcid_elem **dce;\n\n    for (dce = conn->ifc_dces; dce < DCES_END(conn); ++dce)\n        if (*dce && !((*dce)->de_flags & DE_ASSIGNED))\n            return *dce;\n\n    return NULL;\n}\n\n\nstatic struct conn_cid_elem *\nfind_cce_by_cid (struct ietf_full_conn *conn, const lsquic_cid_t *cid)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if ((lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces)))\n                                        && LSQUIC_CIDS_EQ(&cce->cce_cid, cid))\n            return cce;\n\n    return NULL;\n}\n\n\nstatic int\ninit_new_path (struct ietf_full_conn *conn, struct conn_path *path,\n                                                            int dcid_changed)\n{\n    struct dcid_elem *dce;\n\n    dce = find_unassigned_dcid(conn);\n    if (dce)\n    {\n        LSQ_DEBUGC(\"assigned new DCID %\"CID_FMT\" to new path %u\",\n                CID_BITS(&dce->de_cid), (unsigned) (path - conn->ifc_paths));\n        path->cop_path.np_dcid = dce->de_cid;\n        dce->de_flags |= DE_ASSIGNED;\n    }\n    else if (!dcid_changed || CUR_DCID(conn)->len == 0)\n    {\n        /* It is OK to reuse DCID if it is zero-length or ir the peer did not\n         * use a new DCID when its address changed.  See\n         * [draft-ietf-quic-transport-24] Section 9.5.\n         */\n        path->cop_path.np_dcid = CUR_NPATH(conn)->np_dcid;\n        LSQ_DEBUGC(\"assigned already-used DCID %\"CID_FMT\" to new path %u, \"\n            \"as incoming DCID did not change\",\n            CID_BITS(&path->cop_path.np_dcid),\n            (unsigned) (path - conn->ifc_paths));\n    }\n    else\n    {\n        LSQ_DEBUG(\"Don't have an unassigned DCID: cannot initialize path\");\n        return -1;\n    }\n\n    path->cop_path.np_pack_size\n                = calc_base_packet_size(conn, NP_IS_IPv6(&path->cop_path));\n\n    if (conn->ifc_max_udp_payload < path->cop_path.np_pack_size)\n        path->cop_path.np_pack_size = conn->ifc_max_udp_payload;\n\n    LSQ_DEBUG(\"initialized path %u\", (unsigned) (path - conn->ifc_paths));\n\n    return 0;\n}\n\n\nstatic int\non_new_or_unconfirmed_path (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_path *const path = &conn->ifc_paths[packet_in->pi_path_id];\n    struct conn_cid_elem *cce;\n    int dcid_changed;\n    char cidbuf_[MAX_CID_LEN * 2 + 1];\n\n    /* An endpoint only changes the address that it sends packets to in\n     * response to the highest-numbered non-probing packet.  This ensures\n     * that an endpoint does not send packets to an old peer address in the\n     * case that it receives reordered packets.\n     *\n     * [draft-ietf-quic-transport-20], Section 9.3.\n     */\n    if (lsquic_packet_in_non_probing(packet_in)\n                        && packet_in->pi_packno > conn->ifc_max_non_probing)\n        path->cop_flags |= COP_GOT_NONPROB;\n\n    /* If we cannot find a SCID at this point, something is wrong. */\n    cce = find_cce_by_cid(conn, &packet_in->pi_dcid);\n    if (!cce)\n    {\n        ABORT_ERROR(\"DCID %\"CID_FMT\" not found on new path\",\n                                            CID_BITS(&packet_in->pi_dcid));\n        return -1;\n    }\n\n    dcid_changed = !(cce->cce_flags & CCE_USED);\n    if (!(path->cop_flags & COP_INITIALIZED))\n    {\n        LSQ_DEBUGC(\"current SCID: %\"CID_FMT, CID_BITS(CN_SCID(&conn->ifc_conn)));\n        LSQ_DEBUGC(\"packet in DCID: %\"CID_FMT\"; changed: %d\",\n                                    CID_BITS(&packet_in->pi_dcid), dcid_changed);\n        if (0 == init_new_path(conn, path, dcid_changed))\n        {\n            path->cop_flags |= COP_INITIALIZED;\n            if (packet_in->pi_data_sz >= IQUIC_MIN_INIT_PACKET_SZ / 3)\n                path->cop_flags |= COP_ALLOW_MTU_PADDING;\n        }\n        else\n            return -1;\n\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL << packet_in->pi_path_id;\n        LSQ_DEBUG(\"scheduled return path challenge on path %hhu\",\n                                                        packet_in->pi_path_id);\n    }\n    else if ((path->cop_flags & (COP_VALIDATED|COP_GOT_NONPROB))\n                                            == (COP_VALIDATED|COP_GOT_NONPROB))\n    {\n        assert(path->cop_flags & COP_INITIALIZED);\n        LSQ_DEBUG(\"received non-probing frame on validated path %hhu, \"\n            \"switch to it\", packet_in->pi_path_id);\n        switch_path_to(conn, packet_in->pi_path_id);\n    }\n\n    path->cop_cce_idx = cce - lconn->cn_cces;\n    cce->cce_flags |= CCE_USED;\n    LOG_SCIDS(conn);\n    return 0;\n}\n\n\nstatic void\nparse_regular_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    const unsigned char *p, *pend;\n    unsigned len;\n\n    p = packet_in->pi_data + packet_in->pi_header_sz;\n    pend = packet_in->pi_data + packet_in->pi_data_sz;\n\n    if (p < pend)\n        do\n        {\n            len = process_packet_frame(conn, packet_in, p, pend - p);\n            if (len > 0)\n                p += len;\n            else\n            {\n                ABORT_ERROR(\"Error parsing frame\");\n                break;\n            }\n        }\n        while (p < pend);\n    else\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"packet %\"PRIu64\" has no frames\", packet_in->pi_packno);\n}\n\n\n/* From [draft-ietf-quic-transport-24] Section 13.2.1:\n *      \" An endpoint MUST NOT send a non-ack-eliciting packet in response\n *      \" to a non-ack-eliciting packet, even if there are packet gaps\n *      \" which precede the received packet.\n *\n * To ensure that we always send an ack-eliciting packet in this case, we\n * check that there are frames that are about to be written.\n */\nstatic int\nmany_in_and_will_write (struct ietf_full_conn *conn)\n{\n    return conn->ifc_n_slack_all > MAX_ANY_PACKETS_SINCE_LAST_ACK\n        && (conn->ifc_send_flags\n            || !TAILQ_EMPTY(&conn->ifc_pub.sending_streams)\n            || !TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n        ;\n}\n\n\nstatic void\nforce_queueing_ack_app (struct ietf_full_conn *conn)\n{\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n    lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n    conn->ifc_flags |= IFC_ACK_QUED_APP;\n    LSQ_DEBUG(\"force-queued ACK\");\n}\n\n\nenum was_missing {\n    /* Note that particular enum values matter for speed */\n    WM_NONE    = 0,\n    WM_MAX_GAP = 1, /* Newly arrived ackable packet introduced a gap in incoming\n                     * packet number sequence.\n                     */\n    WM_SMALLER = 2, /* Newly arrived ackable packet is smaller than previously\n                     * seen maximum number.\n                     */\n\n};\n\n\nstatic void\ntry_queueing_ack_app (struct ietf_full_conn *conn,\n                    enum was_missing was_missing, int ecn, lsquic_time_t now)\n{\n    lsquic_time_t srtt, ack_timeout;\n\n    if (conn->ifc_n_slack_akbl[PNS_APP] >= conn->ifc_max_retx_since_last_ack\n/* From [draft-ietf-quic-transport-29] Section 13.2.1:\n \" Similarly, packets marked with the ECN Congestion Experienced (CE)\n \" codepoint in the IP header SHOULD be acknowledged immediately, to\n \" reduce the peer's response time to congestion events.\n */\n            || (ecn == ECN_CE\n                    && lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n            || (was_missing == WM_MAX_GAP)\n            || ((conn->ifc_flags & IFC_ACK_HAD_MISS)\n                    && was_missing == WM_SMALLER\n                    && conn->ifc_n_slack_akbl[PNS_APP] > 0)\n            || many_in_and_will_write(conn))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_flags |= IFC_ACK_QUED_APP;\n        LSQ_DEBUG(\"%s ACK queued: ackable: %u; all: %u; had_miss: %d; \"\n            \"was_missing: %d\",\n            lsquic_pns2str[PNS_APP], conn->ifc_n_slack_akbl[PNS_APP],\n            conn->ifc_n_slack_all,\n            !!(conn->ifc_flags & IFC_ACK_HAD_MISS), (int) was_missing);\n    }\n    else if (conn->ifc_n_slack_akbl[PNS_APP] > 0)\n    {\n        if (!lsquic_alarmset_is_set(&conn->ifc_alset, AL_ACK_APP))\n        {\n            /* See https://github.com/quicwg/base-drafts/issues/3304 for more */\n            srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n            if (srtt)\n                ack_timeout = MAX(1000, MIN(conn->ifc_max_ack_delay, srtt / 4));\n            else\n                ack_timeout = conn->ifc_max_ack_delay;\n            lsquic_alarmset_set(&conn->ifc_alset, AL_ACK_APP,\n                                                            now + ack_timeout);\n            LSQ_DEBUG(\"%s ACK alarm set to %\"PRIu64, lsquic_pns2str[PNS_APP],\n                                                            now + ack_timeout);\n        }\n        else\n            LSQ_DEBUG(\"%s ACK alarm already set to %\"PRIu64\" usec from now\",\n                lsquic_pns2str[PNS_APP],\n                conn->ifc_alset.as_expiry[AL_ACK_APP] - now);\n    }\n}\n\n\nstatic void\ntry_queueing_ack_init_or_hsk (struct ietf_full_conn *conn,\n                                                        enum packnum_space pns)\n{\n    if (conn->ifc_n_slack_akbl[pns] > 0)\n    {\n        conn->ifc_flags |= IFC_ACK_QUED_INIT << pns;\n        LSQ_DEBUG(\"%s ACK queued: ackable: %u\",\n            lsquic_pns2str[pns], conn->ifc_n_slack_akbl[pns]);\n    }\n}\n\n\nstatic int\nmaybe_queue_opp_ack (struct ietf_full_conn *conn)\n{\n    if (/* If there is at least one ackable packet */\n        conn->ifc_n_slack_akbl[PNS_APP] > 0\n        /* ...and there are things to write */\n        && (!TAILQ_EMPTY(&conn->ifc_pub.write_streams) || conn->ifc_send_flags)\n        /* ...and writing is possible */\n        && write_is_possible(conn))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_flags |= IFC_ACK_QUED_APP;\n        LSQ_DEBUG(\"%s ACK queued opportunistically\", lsquic_pns2str[PNS_APP]);\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic int\nverify_retry_packet (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    unsigned char *pseudo_packet;\n    size_t out_len, ad_len;\n    unsigned ret_ver;\n    int verified;\n\n    if (1 + CUR_DCID(conn)->len + packet_in->pi_data_sz > 0x1000)\n    {\n        /* Cover the theoretical possibility that we cannot fit the pseudo-\n         * packet and 16-byte decrypted output into 4 KB:\n         */\n        LSQ_INFO(\"%s: Retry packet is too long: %hu bytes\", __func__,\n                                                        packet_in->pi_data_sz);\n        return -1;\n    }\n\n    pseudo_packet = lsquic_mm_get_4k(conn->ifc_pub.mm);\n    if (!pseudo_packet)\n    {\n        LSQ_INFO(\"%s: cannot allocate memory\", __func__);\n        return -1;\n    }\n\n    pseudo_packet[0] = CUR_DCID(conn)->len;\n    memcpy(pseudo_packet + 1, CUR_DCID(conn)->idbuf, CUR_DCID(conn)->len);\n    memcpy(pseudo_packet + 1 + CUR_DCID(conn)->len, packet_in->pi_data,\n                                                    packet_in->pi_data_sz);\n\n    ret_ver = lsquic_version_2_retryver(conn->ifc_conn.cn_version);\n    out_len = 0;\n    ad_len = 1 + CUR_DCID(conn)->len + packet_in->pi_data_sz - 16;\n    verified = 1 == EVP_AEAD_CTX_open(\n                    &conn->ifc_enpub->enp_retry_aead_ctx[ret_ver],\n                    pseudo_packet + ad_len, &out_len, out_len,\n                    lsquic_retry_nonce_buf[ret_ver], IETF_RETRY_NONCE_SZ,\n                    pseudo_packet + ad_len, 16, pseudo_packet, ad_len)\n            && out_len == 0;\n\n    lsquic_mm_put_4k(conn->ifc_pub.mm, pseudo_packet);\n    return verified ? 0 : -1;\n}\n\n\nstatic int\nprocess_retry_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    lsquic_cid_t scid;\n\n    if (conn->ifc_flags & (IFC_SERVER|IFC_RETRIED))\n    {\n        /* [draft-ietf-quic-transport-24] Section 17.2.5:\n         \" After the client has received and processed an Initial or Retry\n         \" packet from the server, it MUST discard any subsequent Retry\n         \" packets that it receives.\n         */\n        LSQ_DEBUG(\"ignore Retry packet\");\n        return 0;\n    }\n\n    if (CUR_DCID(conn)->len == packet_in->pi_scid_len\n            && 0 == memcmp(CUR_DCID(conn)->idbuf,\n                    packet_in->pi_data + packet_in->pi_scid_off,\n                    packet_in->pi_scid_len))\n    {\n        /*\n         * [draft-ietf-quic-transport-24] Section 17.2.5:\n         \" A client MUST discard a Retry packet that contains a Source\n         \" Connection ID field that is identical to the Destination\n         \" Connection ID field of its Initial packet.\n         */\n        LSQ_DEBUG(\"server provided same SCID as ODCID: discard packet\");\n        return 0;\n    }\n\n    if (0 != verify_retry_packet(conn, packet_in))\n    {\n        LSQ_DEBUG(\"cannot verify retry packet: ignore it\");\n        return 0;\n    }\n\n    if (0 != lsquic_send_ctl_retry(&conn->ifc_send_ctl,\n                    packet_in->pi_data + packet_in->pi_token,\n                            packet_in->pi_token_size))\n        return -1;\n\n    lsquic_scid_from_packet_in(packet_in, &scid);\n    if (0 != conn->ifc_conn.cn_esf.i->esfi_reset_dcid(\n                    conn->ifc_conn.cn_enc_session, CUR_DCID(conn), &scid))\n        return -1;\n\n    *CUR_DCID(conn) = scid;\n    if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n        CUR_CPATH(conn)->cop_spin_bit = 0;\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_INIT);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_HSK);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_APP);\n\n    LSQ_INFO(\"Received a retry packet.  Will retry.\");\n    conn->ifc_flags |= IFC_RETRIED;\n    return 0;\n}\n\n\nstatic int\nis_stateless_reset (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    struct lsquic_hash_elem *el;\n\n    if (packet_in->pi_data_sz < IQUIC_MIN_SRST_SIZE)\n        return 0;\n\n    el = lsquic_hash_find(conn->ifc_enpub->enp_srst_hash,\n            packet_in->pi_data + packet_in->pi_data_sz - IQUIC_SRESET_TOKEN_SZ,\n            IQUIC_SRESET_TOKEN_SZ);\n    if (!el)\n        return 0;\n\n#ifndef NDEBUG\n    const struct lsquic_conn *reset_lconn;\n    reset_lconn = lsquic_hashelem_getdata(el);\n    assert(reset_lconn == &conn->ifc_conn);\n#endif\n    return 1;\n}\n\n\n/*\n * Sets the new current SCID if the DCID in the incoming packet:\n *  (1) was issued by this endpoint and\n *  (2) has not been used before.\n */\nstatic int\non_dcid_change (struct ietf_full_conn *conn, const lsquic_cid_t *dcid_in)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;  /* Shorthand */\n    struct conn_cid_elem *cce;\n\n    LSQ_DEBUG(\"peer switched its DCID, attempt to switch own SCID\");\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if (cce - lconn->cn_cces != lconn->cn_cur_cce_idx\n                && (lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces)))\n                    && LSQUIC_CIDS_EQ(&cce->cce_cid, dcid_in))\n            break;\n\n    if (cce >= END_OF_CCES(lconn))\n    {\n        ABORT_WARN(\"DCID not found\");\n        return -1;\n    }\n\n    if (cce->cce_flags & CCE_USED)\n    {\n        LSQ_DEBUGC(\"Current CID: %\"CID_FMT, CID_BITS(CN_SCID(lconn)));\n        LSQ_DEBUGC(\"DCID %\"CID_FMT\" has been used, not switching\",\n                                                            CID_BITS(dcid_in));\n        return 0;\n    }\n\n    cce->cce_flags |= CCE_USED;\n    lconn->cn_cur_cce_idx = cce - lconn->cn_cces;\n    LSQ_DEBUGC(\"%s: set SCID to %\"CID_FMT, __func__, CID_BITS(CN_SCID(lconn)));\n    LOG_SCIDS(conn);\n\n    return 0;\n}\n\n\nstatic void\nignore_init (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"henceforth, no Initial packets shall be sent or received\");\n    conn->ifc_flags |= IFC_IGNORE_INIT;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << PNS_INIT);\n    lsquic_send_ctl_empty_pns(&conn->ifc_send_ctl, PNS_INIT);\n    lsquic_rechist_cleanup(&conn->ifc_rechist[PNS_INIT]);\n    if (!(conn->ifc_flags & IFC_SERVER))\n    {\n        if (conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT])\n        {\n            lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]);\n            conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT] = NULL;\n        }\n        conn->ifc_conn.cn_if = ietf_full_conn_iface_ptr;\n    }\n}\n\n\nstatic void\nignore_hsk (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"henceforth, no Handshake packets shall be sent or received\");\n    conn->ifc_flags |= IFC_IGNORE_HSK;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << PNS_HSK);\n    lsquic_send_ctl_empty_pns(&conn->ifc_send_ctl, PNS_HSK);\n    lsquic_rechist_cleanup(&conn->ifc_rechist[PNS_HSK]);\n    if (!(conn->ifc_flags & IFC_SERVER))\n        if (conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK])\n        {\n            lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK]);\n            conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK] = NULL;\n        }\n}\n\n\nstatic void\nrecord_dcid (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    unsigned orig_cid_len;\n\n    orig_cid_len = CUR_DCID(conn)->len;\n    conn->ifc_flags |= IFC_DCID_SET;\n    lsquic_scid_from_packet_in(packet_in, CUR_DCID(conn));\n    LSQ_DEBUGC(\"set DCID to %\"CID_FMT, CID_BITS(CUR_DCID(conn)));\n    lsquic_send_ctl_cidlen_change(&conn->ifc_send_ctl, orig_cid_len,\n                                                        CUR_DCID(conn)->len);\n}\n\n\nstatic int\nholes_after (struct lsquic_rechist *rechist, lsquic_packno_t packno)\n{\n    const struct lsquic_packno_range *first_range;\n\n    first_range = lsquic_rechist_peek(rechist);\n    /* If it's not in the very first range, there is obviously a gap\n     * between it and the maximum packet number.  If the packet number\n     * in question preceeds the cutoff, we assume that there are no\n     * holes (as we simply have no information).\n     */\n    return first_range\n        && packno < first_range->low\n        && packno > lsquic_rechist_cutoff(rechist);\n}\n\n\nstatic int\nprocess_regular_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    struct conn_path *cpath;\n    enum packnum_space pns;\n    enum received_st st;\n    enum dec_packin dec_packin;\n    enum was_missing was_missing;\n    int is_rechist_empty;\n    unsigned char saved_path_id;\n    int is_dcid_changed;\n\n    if (HETY_RETRY == packet_in->pi_header_type)\n        return process_retry_packet(conn, packet_in);\n\n    CONN_STATS(in.packets, 1);\n\n    pns = lsquic_hety2pns[ packet_in->pi_header_type ];\n    if ((pns == PNS_INIT && (conn->ifc_flags & IFC_IGNORE_INIT))\n                    || (pns == PNS_HSK  && (conn->ifc_flags & IFC_IGNORE_HSK)))\n    {\n        /* Don't bother decrypting */\n        LSQ_DEBUG(\"ignore %s packet\",\n            pns == PNS_INIT ? \"Initial\" : \"Handshake\");\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"ignore %s packet\",\n                                                        lsquic_pns2str[pns]);\n        return 0;\n    }\n\n    /* If a client receives packets from an unknown server address, the client\n     * MUST discard these packets.\n     *      [draft-ietf-quic-transport-20], Section 9\n     */\n    if (packet_in->pi_path_id != conn->ifc_cur_path_id\n        && 0 == (conn->ifc_flags & IFC_SERVER)\n        && !(packet_in->pi_path_id == conn->ifc_mig_path_id\n                && migra_is_on(conn, conn->ifc_mig_path_id)))\n    {\n        /* The \"known server address\" is recorded in the current path. */\n        switch ((NP_IS_IPv6(CUR_NPATH(conn)) << 1) |\n                 NP_IS_IPv6(&conn->ifc_paths[packet_in->pi_path_id].cop_path))\n        {\n        case (1 << 1) | 1:  /* IPv6 */\n            if (lsquic_sockaddr_eq(NP_PEER_SA(CUR_NPATH(conn)), NP_PEER_SA(\n                        &conn->ifc_paths[packet_in->pi_path_id].cop_path)))\n                goto known_peer_addr;\n            break;\n        case (0 << 1) | 0:  /* IPv4 */\n            if (lsquic_sockaddr_eq(NP_PEER_SA(CUR_NPATH(conn)), NP_PEER_SA(\n                        &conn->ifc_paths[packet_in->pi_path_id].cop_path)))\n                goto known_peer_addr;\n            break;\n        }\n        LSQ_DEBUG(\"ignore packet from unknown server address\");\n        return 0;\n    }\n  known_peer_addr:\n\n    /* The packet is decrypted before receive history is updated.  This is\n     * done to make sure that a bad packet won't occupy a slot in receive\n     * history and subsequent good packet won't be marked as a duplicate.\n     */\n    if (0 == (packet_in->pi_flags & PI_DECRYPTED))\n    {\n        dec_packin = conn->ifc_conn.cn_esf_c->esf_decrypt_packet(\n                            conn->ifc_conn.cn_enc_session, conn->ifc_enpub,\n                            &conn->ifc_conn, packet_in);\n        switch (dec_packin)\n        {\n        case DECPI_BADCRYPT:\n        case DECPI_TOO_SHORT:\n            if (conn->ifc_enpub->enp_settings.es_honor_prst\n                /* In server mode, even if we do support stateless reset packets,\n                 * they are handled in lsquic_engine.c.  No need to have this\n                 * logic here.\n                 */\n                && !(conn->ifc_flags & IFC_SERVER)\n                                        && is_stateless_reset(conn, packet_in))\n            {\n                LSQ_INFO(\"received stateless reset packet: aborting connection\");\n                conn->ifc_flags |= IFC_GOT_PRST;\n                return -1;\n            }\n            else if (dec_packin == DECPI_BADCRYPT)\n            {\n                CONN_STATS(in.undec_packets, 1);\n                LSQ_INFO(\"could not decrypt packet (type %s)\",\n                                    lsquic_hety2str[packet_in->pi_header_type]);\n                return 0;\n            }\n            else\n            {\n                CONN_STATS(in.undec_packets, 1);\n                LSQ_INFO(\"packet is too short to be decrypted\");\n                return 0;\n            }\n        case DECPI_NOT_YET:\n            return 0;\n        case DECPI_NOMEM:\n            return 0;\n        case DECPI_VIOLATION:\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                                    \"decrypter reports protocol violation\");\n            return -1;\n        case DECPI_OK:\n            /* Receiving any other type of packet precludes subsequent retries.\n             * We only set it if decryption is successful.\n             */\n            conn->ifc_flags |= IFC_RETRIED;\n            break;\n        }\n    }\n\n    is_dcid_changed = !LSQUIC_CIDS_EQ(CN_SCID(&conn->ifc_conn),\n                                        &packet_in->pi_dcid);\n    if (pns == PNS_INIT)\n        conn->ifc_conn.cn_esf.i->esfi_set_iscid(conn->ifc_conn.cn_enc_session,\n                                                                    packet_in);\n    else\n    {\n        if (is_dcid_changed)\n        {\n            if (LSQUIC_CIDS_EQ(&conn->ifc_conn.cn_cces[0].cce_cid,\n                            &packet_in->pi_dcid)\n                && !(conn->ifc_conn.cn_cces[0].cce_flags & CCE_SEQNO))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                            \"protocol violation detected bad dcid\");\n                return -1;\n            }\n        }\n        if (pns == PNS_HSK)\n        {\n            if ((conn->ifc_flags & (IFC_SERVER | IFC_IGNORE_INIT)) == IFC_SERVER)\n                ignore_init(conn);\n            lsquic_send_ctl_maybe_calc_rough_rtt(&conn->ifc_send_ctl, pns - 1);\n        }\n    }\n    EV_LOG_PACKET_IN(LSQUIC_LOG_CONN_ID, packet_in);\n\n    is_rechist_empty = lsquic_rechist_is_empty(&conn->ifc_rechist[pns]);\n    st = lsquic_rechist_received(&conn->ifc_rechist[pns], packet_in->pi_packno,\n                                                    packet_in->pi_received);\n    switch (st) {\n    case REC_ST_OK:\n        if (!(conn->ifc_flags & (IFC_SERVER|IFC_DCID_SET)))\n            record_dcid(conn, packet_in);\n        saved_path_id = conn->ifc_cur_path_id;\n        parse_regular_packet(conn, packet_in);\n        if (saved_path_id == conn->ifc_cur_path_id)\n        {\n            if (conn->ifc_cur_path_id != packet_in->pi_path_id)\n            {\n                if (0 != on_new_or_unconfirmed_path(conn, packet_in))\n                {\n                    LSQ_DEBUG(\"path %hhu invalid, cancel any path response \"\n                        \"on it\", packet_in->pi_path_id);\n                    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP\n                                                    << packet_in->pi_path_id);\n                }\n            }\n            else if (is_dcid_changed)\n            {\n                if (0 != on_dcid_change(conn, &packet_in->pi_dcid))\n                    return -1;\n            }\n        }\n        if (lsquic_packet_in_non_probing(packet_in)\n                        && packet_in->pi_packno > conn->ifc_max_non_probing)\n            conn->ifc_max_non_probing = packet_in->pi_packno;\n        /* From [draft-ietf-quic-transport-30] Section 13.2.1:\n         *\n \" In order to assist loss detection at the sender, an endpoint SHOULD\n \" generate and send an ACK frame without delay when it receives an ack-\n \" eliciting packet either:\n \"\n \" *  when the received packet has a packet number less than another\n \"    ack-eliciting packet that has been received, or\n \"\n \" *  when the packet has a packet number larger than the highest-\n \"    numbered ack-eliciting packet that has been received and there are\n \"    missing packets between that packet and this packet.\n        *\n        */\n        if (packet_in->pi_frame_types & IQUIC_FRAME_ACKABLE_MASK)\n        {\n            if (PNS_APP == pns /* was_missing is only used in PNS_APP */)\n            {\n                if (packet_in->pi_packno > conn->ifc_max_ackable_packno_in)\n                {\n                    was_missing = (enum was_missing)    /* WM_MAX_GAP is 1 */\n                        !is_rechist_empty /* Don't count very first packno */\n                        && conn->ifc_max_ackable_packno_in + 1\n                                                    < packet_in->pi_packno\n                        && holes_after(&conn->ifc_rechist[PNS_APP],\n                            conn->ifc_max_ackable_packno_in);\n                    conn->ifc_max_ackable_packno_in = packet_in->pi_packno;\n                }\n                else\n                    was_missing = (enum was_missing)    /* WM_SMALLER is 2 */\n                    /* The check is necessary (rather setting was_missing to\n                     * WM_SMALLER) because we cannot guarantee that peer does\n                     * not have bugs.\n                     */\n                        ((packet_in->pi_packno\n                                    < conn->ifc_max_ackable_packno_in) << 1);\n            }\n            else\n                was_missing = WM_NONE;\n            ++conn->ifc_n_slack_akbl[pns];\n        }\n        else\n            was_missing = WM_NONE;\n        conn->ifc_n_slack_all += PNS_APP == pns;\n        if (0 == (conn->ifc_flags & (IFC_ACK_QUED_INIT << pns)))\n        {\n            if (PNS_APP == pns)\n                try_queueing_ack_app(conn, was_missing,\n                    lsquic_packet_in_ecn(packet_in), packet_in->pi_received);\n            else\n                try_queueing_ack_init_or_hsk(conn, pns);\n        }\n        conn->ifc_incoming_ecn <<= 1;\n        conn->ifc_incoming_ecn |=\n                            lsquic_packet_in_ecn(packet_in) != ECN_NOT_ECT;\n        ++conn->ifc_ecn_counts_in[pns][ lsquic_packet_in_ecn(packet_in) ];\n        if (PNS_APP == pns\n                && (cpath = &conn->ifc_paths[packet_in->pi_path_id],\n                                            cpath->cop_flags & COP_SPIN_BIT)\n                /* [draft-ietf-quic-transport-30] Section 17.3.1 talks about\n                 * how spin bit value is set.\n                 */\n                && (packet_in->pi_packno > cpath->cop_max_packno\n                    /* Zero means \"unset\", in which case any incoming packet\n                     * number will do.  On receipt of second packet numbered\n                     * zero, the rechist module will dup it and this code path\n                     * won't hit.\n                     */\n                    || cpath->cop_max_packno == 0))\n        {\n            cpath->cop_max_packno = packet_in->pi_packno;\n            if (conn->ifc_flags & IFC_SERVER)\n                cpath->cop_spin_bit = lsquic_packet_in_spin_bit(packet_in);\n            else\n                cpath->cop_spin_bit = !lsquic_packet_in_spin_bit(packet_in);\n        }\n        conn->ifc_pub.bytes_in += packet_in->pi_data_sz;\n        if ((conn->ifc_mflags & MF_VALIDATE_PATH) &&\n                (packet_in->pi_header_type == HETY_SHORT\n              || packet_in->pi_header_type == HETY_HANDSHAKE))\n        {\n            conn->ifc_mflags &= ~MF_VALIDATE_PATH;\n            lsquic_send_ctl_path_validated(&conn->ifc_send_ctl);\n        }\n        return 0;\n    case REC_ST_DUP:\n        CONN_STATS(in.dup_packets, 1);\n        LSQ_INFO(\"packet %\"PRIu64\" is a duplicate\", packet_in->pi_packno);\n        return 0;\n    default:\n        assert(0);\n        /* Fall through */\n    case REC_ST_ERR:\n        CONN_STATS(in.err_packets, 1);\n        LSQ_INFO(\"error processing packet %\"PRIu64, packet_in->pi_packno);\n        return -1;\n    }\n}\n\n\nstatic int\nverneg_ok (const struct ietf_full_conn *conn)\n{\n    enum lsquic_version ver;\n\n    ver = highest_bit_set(conn->ifc_u.cli.ifcli_ver_neg.vn_supp);\n    return (1 << ver) & LSQUIC_IETF_VERSIONS;\n}\n\n\nstatic void\nenable_ping_alarm_for_handshake (struct ietf_full_conn *conn)\n{\n    conn->ifc_ping_period = HSK_PING_TIMEOUT;\n    lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                        lsquic_time_now() + conn->ifc_ping_period);\n}\n\n\nstatic int\nswitch_version (struct ietf_full_conn *conn, enum lsquic_version version)\n{\n    conn->ifc_conn.cn_version = version;\n    return iquic_esfi_switch_version(conn->ifc_conn.cn_enc_session, NULL, 0);\n}\n\n\n/* This function is used by the client when version negotiation is not yet\n * complete.\n */\nstatic int\nprocess_incoming_packet_verneg (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    int s;\n    struct ver_iter vi;\n    lsquic_ver_tag_t ver_tag;\n    enum lsquic_version version;\n    unsigned versions;\n\n    if (lsquic_packet_in_is_verneg(packet_in))\n    {\n        LSQ_DEBUG(\"Processing version-negotiation packet\");\n\n        if (conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_START)\n        {\n            LSQ_DEBUG(\"ignore a likely duplicate version negotiation packet\");\n            return 0;\n        }\n\n        if (!(LSQUIC_CIDS_EQ(&conn->ifc_conn.cn_cid, &packet_in->pi_dcid)\n            && CUR_DCID(conn)->len == packet_in->pi_scid_len\n            && 0 == memcmp(CUR_DCID(conn)->idbuf, packet_in->pi_data\n                            + packet_in->pi_scid_off, packet_in->pi_scid_len)))\n        {\n            LSQ_DEBUG(\"SCID and DCID in verneg packet don't match what we \"\n                        \"sent: ignore\");\n            return 0;\n        }\n\n        versions = 0;\n        for (s = lsquic_packet_in_ver_first(packet_in, &vi, &ver_tag); s;\n                         s = lsquic_packet_in_ver_next(&vi, &ver_tag))\n        {\n            version = lsquic_tag2ver(ver_tag);\n            if (version < N_LSQVER)\n            {\n                versions |= 1 << version;\n                LSQ_DEBUG(\"server supports version %s\", lsquic_ver2str[version]);\n                EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,\n                                            \"supports\", lsquic_ver2str[version]);\n            }\n        }\n\n        /* [draft-ietf-quic-transport-28] Section 6.2:\n         \" A client MUST discard a Version Negotiation packet that lists the\n         \" QUIC version selected by the client.\n         */\n        if (versions & (1 << conn->ifc_u.cli.ifcli_ver_neg.vn_ver))\n        {\n            LSQ_DEBUG(\"server replied with version we sent, %s, ignore\",\n                        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver]);\n            return 0;\n        }\n\n        /* [draft-ietf-quic-transport-28] Section 6.2:\n         \" A client that supports only this version of QUIC MUST abandon the\n         \" current connection attempt if it receives a Version Negotiation\n         \" packet [...]\n         */\n        if (!verneg_ok(conn))\n        {\n            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,\n                \"version negotiation not permitted in this version of QUIC\");\n            return -1;\n        }\n\n        versions &= conn->ifc_u.cli.ifcli_ver_neg.vn_supp;\n        if (0 == versions)\n        {\n            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,\n                \"client does not support any of the server-specified versions\");\n            return -1;\n        }\n\n        set_versions(conn, versions, NULL);\n        conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_IN_PROGRESS;\n        lsquic_send_ctl_expire_all(&conn->ifc_send_ctl);\n        return 0;\n    }\n\n    if (packet_in->pi_version != conn->ifc_u.cli.ifcli_ver_neg.vn_ver)\n    {\n        if (!((1 << packet_in->pi_version)\n              & conn->ifc_u.cli.ifcli_ver_neg.vn_supp))\n        {\n            LSQ_DEBUG(\"server version doesn't match versions \"\n                        \"supported: ignore\");\n            return 0;\n        }\n        LSQ_DEBUG(\"version negociation: server switched version from %s to %s\",\n        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver],\n        lsquic_ver2str[packet_in->pi_version]);\n        switch_version(conn, packet_in->pi_version);\n    }\n    else\n        conn->ifc_conn.cn_version = conn->ifc_u.cli.ifcli_ver_neg.vn_ver;\n    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_tag);\n    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_END);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_END;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_tag = NULL;\n    conn->ifc_conn.cn_flags |= LSCONN_VER_SET;\n    LSQ_DEBUG(\"end of version negotiation: agreed upon %s\",\n                    lsquic_ver2str[conn->ifc_conn.cn_version]);\n    EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,\n            \"agreed\", lsquic_ver2str[conn->ifc_conn.cn_version]);\n    conn->ifc_process_incoming_packet = process_regular_packet;\n\n    if (process_regular_packet(conn, packet_in) == 0)\n    {\n        enable_ping_alarm_for_handshake(conn);\n        return 0;\n    }\n    return -1;\n}\n\n\n/* This function is used after version negotiation is completed */\nstatic int\nprocess_incoming_packet_fast (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    return process_regular_packet(conn, packet_in);\n}\n\n\nstatic void\nset_earliest_idle_alarm (struct ietf_full_conn *conn, lsquic_time_t idle_conn_to)\n{\n    lsquic_time_t exp;\n\n    if (conn->ifc_pub.last_prog\n        && (assert(conn->ifc_mflags & MF_NOPROG_TIMEOUT),\n            exp = conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout,\n            exp < idle_conn_to))\n        idle_conn_to = exp;\n    if (idle_conn_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, idle_conn_to);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_in (struct lsquic_conn *lconn,\n                             struct lsquic_packet_in *packet_in)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    CONN_STATS(in.bytes, packet_in->pi_data_sz);\n    set_earliest_idle_alarm(conn, conn->ifc_idle_to\n                    ? packet_in->pi_received + conn->ifc_idle_to : 0);\n    if (0 == (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS))\n        if (0 != conn->ifc_process_incoming_packet(conn, packet_in))\n            conn->ifc_flags |= IFC_ERROR;\n}\n\n\nstatic void\nietf_full_conn_ci_packet_not_sent (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n#ifndef NDEBUG\n    if (packet_out->po_flags & PO_ENCRYPTED)\n        assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_send_ctl_delayed_one(&conn->ifc_send_ctl, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_too_large (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n#ifndef NDEBUG\n    assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n\n    if (packet_out->po_flags & PO_MTU_PROBE)\n    {\n        LSQ_DEBUG(\"%zu-byte MTU probe in packet %\"PRIu64\" is too large\",\n            lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out),\n            packet_out->po_packno);\n        lsquic_send_ctl_mtu_not_sent(&conn->ifc_send_ctl, packet_out);\n        mtu_probe_too_large(conn, packet_out);\n    }\n    else\n        ABORT_WARN(\"non-MTU probe %zu-byte packet %\"PRIu64\" is too large\",\n            lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out),\n            packet_out->po_packno);\n\n    lsquic_packet_out_destroy(packet_out, conn->ifc_enpub,\n                                            packet_out->po_path->np_peer_ctx);\n}\n\n\n/* Calling of ignore_init() must be delayed until all batched packets have\n * been returned by the engine.\n */\nstatic void\npre_hsk_packet_sent_or_delayed (struct ietf_full_conn *conn,\n                               const struct lsquic_packet_out *packet_out)\n{\n#ifndef NDEBUG\n    if (packet_out->po_flags & PO_ENCRYPTED)\n        assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n    /* Once IFC_IGNORE_INIT is set, the pre-hsk wrapper is removed: */\n    assert(!(conn->ifc_flags & IFC_IGNORE_INIT));\n    --conn->ifc_u.cli.ifcli_packets_out;\n    if (PNS_HSK == lsquic_packet_out_pns(packet_out))\n        conn->ifc_u.cli.ifcli_flags |= IFCLI_HSK_SENT_OR_DEL;\n    if (0 == conn->ifc_u.cli.ifcli_packets_out\n                && (conn->ifc_u.cli.ifcli_flags & IFCLI_HSK_SENT_OR_DEL))\n        ignore_init(conn);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_not_sent_pre_hsk (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    ietf_full_conn_ci_packet_not_sent(lconn, packet_out);\n    pre_hsk_packet_sent_or_delayed(conn, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_sent (struct lsquic_conn *lconn,\n                               struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    int s;\n\n    if (packet_out->po_frame_types & (IQUIC_FRAME_RETX_MASK | QUIC_FTBIT_ACK))\n        conn->ifc_n_cons_unretx = 0;\n    else\n        ++conn->ifc_n_cons_unretx;\n    s = lsquic_send_ctl_sent_packet(&conn->ifc_send_ctl, packet_out);\n    if (s != 0)\n        ABORT_ERROR(\"sent packet failed: %s\", strerror(errno));\n    /* Set blocked keep-alive for a [1,8] seconds */\n    if (packet_out->po_frame_types\n                            & (QUIC_FTBIT_BLOCKED|QUIC_FTBIT_STREAM_BLOCKED))\n        lsquic_alarmset_set(&conn->ifc_alset, AL_BLOCKED_KA,\n            packet_out->po_sent + (1 + (7 & lsquic_crand_get_nybble(\n                                conn->ifc_enpub->enp_crand))) * 1000000);\n    conn->ifc_pub.bytes_out += lsquic_packet_out_sent_sz(&conn->ifc_conn,\n                                                                packet_out);\n    CONN_STATS(out.packets, 1);\n    CONN_STATS(out.bytes, lsquic_packet_out_sent_sz(lconn, packet_out));\n}\n\n\nstatic void\nietf_full_conn_ci_packet_sent_pre_hsk (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    ietf_full_conn_ci_packet_sent(lconn, packet_out);\n    pre_hsk_packet_sent_or_delayed(conn, packet_out);\n}\n\n\nstatic void (*const send_funcs[N_SEND])(\n                            struct ietf_full_conn *, lsquic_time_t) =\n{\n    [SEND_NEW_CID]      = generate_new_cid_frames,\n    [SEND_RETIRE_CID]   = generate_retire_cid_frames,\n    [SEND_STREAMS_BLOCKED_UNI]  = generate_streams_blocked_uni_frame,\n    [SEND_STREAMS_BLOCKED_BIDI] = generate_streams_blocked_bidi_frame,\n    [SEND_MAX_STREAMS_UNI]  = generate_max_streams_uni_frame,\n    [SEND_MAX_STREAMS_BIDI] = generate_max_streams_bidi_frame,\n    [SEND_STOP_SENDING] = generate_stop_sending_frames,\n    [SEND_NEW_TOKEN]    = generate_new_token_frame,\n    [SEND_PATH_CHAL_PATH_0]    = generate_path_chal_0,\n    [SEND_PATH_CHAL_PATH_1]    = generate_path_chal_1,\n    [SEND_PATH_CHAL_PATH_2]    = generate_path_chal_2,\n    [SEND_PATH_CHAL_PATH_3]    = generate_path_chal_3,\n    [SEND_PATH_RESP_PATH_0]    = generate_path_resp_0,\n    [SEND_PATH_RESP_PATH_1]    = generate_path_resp_1,\n    [SEND_PATH_RESP_PATH_2]    = generate_path_resp_2,\n    [SEND_PATH_RESP_PATH_3]    = generate_path_resp_3,\n    [SEND_PING]                = generate_ping_frame,\n    [SEND_HANDSHAKE_DONE]      = generate_handshake_done_frame,\n    [SEND_ACK_FREQUENCY]       = generate_ack_frequency_frame,\n};\n\n\n/* List bits that have corresponding entries in send_funcs */\n#define SEND_WITH_FUNCS (SF_SEND_NEW_CID|SF_SEND_RETIRE_CID\\\n    |SF_SEND_STREAMS_BLOCKED_UNI|SF_SEND_STREAMS_BLOCKED_BIDI\\\n    |SF_SEND_MAX_STREAMS_UNI|SF_SEND_MAX_STREAMS_BIDI\\\n    |SF_SEND_PATH_CHAL_PATH_0|SF_SEND_PATH_CHAL_PATH_1\\\n    |SF_SEND_PATH_CHAL_PATH_2|SF_SEND_PATH_CHAL_PATH_3\\\n    |SF_SEND_PATH_RESP_PATH_0|SF_SEND_PATH_RESP_PATH_1\\\n    |SF_SEND_PATH_RESP_PATH_2|SF_SEND_PATH_RESP_PATH_3\\\n    |SF_SEND_PING|SF_SEND_HANDSHAKE_DONE\\\n    |SF_SEND_ACK_FREQUENCY\\\n    |SF_SEND_STOP_SENDING|SF_SEND_NEW_TOKEN)\n\n\n/* This should be called before lsquic_alarmset_ring_expired() */\nstatic void\nmaybe_set_noprogress_alarm (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    lsquic_time_t exp;\n\n    if (conn->ifc_mflags & MF_NOPROG_TIMEOUT)\n    {\n        if (conn->ifc_pub.last_tick)\n        {\n            exp = conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout;\n            if (!lsquic_alarmset_is_set(&conn->ifc_alset, AL_IDLE)\n                                    || exp < conn->ifc_alset.as_expiry[AL_IDLE])\n                lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, exp);\n            conn->ifc_pub.last_tick = now;\n        }\n        else\n        {\n            conn->ifc_pub.last_tick = now;\n            conn->ifc_pub.last_prog = now;\n        }\n    }\n}\n\n\nstatic void\ncheck_or_schedule_mtu_probe (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct conn_path *const cpath = CUR_CPATH(conn);\n    struct dplpmtud_state *const ds = &cpath->cop_dplpmtud;\n    struct lsquic_packet_out *packet_out;\n    unsigned short saved_packet_sz, avail, mtu_ceiling, net_header_sz, probe_sz;\n    int sz;\n\n    if (ds->ds_flags & DS_PROBE_SENT)\n    {\n        assert(ds->ds_probe_sent + conn->ifc_enpub->enp_mtu_probe_timer < now);\n        LSQ_DEBUG(\"MTU probe of %hu bytes lost\", ds->ds_probed_size);\n        ds->ds_flags &= ~DS_PROBE_SENT;\n        conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n        if (ds->ds_probe_count >= 3)\n        {\n            LSQ_DEBUG(\"MTU probe of %hu bytes lost after %hhu tries\",\n                ds->ds_probed_size, ds->ds_probe_count);\n            ds->ds_failed_size = ds->ds_probed_size;\n            ds->ds_probe_count = 0;\n        }\n    }\n\n    assert(0 == ds->ds_probe_sent\n        || ds->ds_probe_sent + conn->ifc_enpub->enp_mtu_probe_timer < now);\n\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        || (conn->ifc_flags & IFC_CLOSING)\n        || ~0ull == lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist)\n        || lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist) < 30\n        || lsquic_send_ctl_in_recovery(&conn->ifc_send_ctl)\n        || !lsquic_send_ctl_can_send_probe(&conn->ifc_send_ctl,\n                                                        &cpath->cop_path))\n    {\n        return;\n    }\n\n    if (ds->ds_failed_size)\n        mtu_ceiling = ds->ds_failed_size;\n    else if (conn->ifc_settings->es_max_plpmtu)\n        mtu_ceiling = conn->ifc_settings->es_max_plpmtu;\n    else\n    {\n        net_header_sz = TRANSPORT_OVERHEAD(NP_IS_IPv6(&cpath->cop_path));\n        mtu_ceiling = 1500 - net_header_sz;\n    }\n\n    if (conn->ifc_max_udp_payload < mtu_ceiling)\n    {\n        LSQ_DEBUG(\"cap MTU ceiling to peer's max_udp_payload_size TP of %hu \"\n            \"bytes\", conn->ifc_max_udp_payload);\n        mtu_ceiling = conn->ifc_max_udp_payload;\n    }\n\n    if (cpath->cop_path.np_pack_size >= mtu_ceiling\n        || (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling >= 0.99)\n    {\n        LSQ_DEBUG(\"stop MTU probing on path %hhu having achieved about \"\n            \"%.1f%% efficiency (detected MTU: %hu; failed MTU: %hu)\",\n            cpath->cop_path.np_path_id,\n            100. * (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling,\n            cpath->cop_path.np_pack_size, ds->ds_failed_size);\n        conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n        return;\n    }\n\n    LSQ_DEBUG(\"MTU ratio: %hu / %hu = %.4f\",\n        cpath->cop_path.np_pack_size, mtu_ceiling,\n        (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling);\n\n    if (!ds->ds_failed_size && mtu_ceiling < 1500)\n        /* Try the largest ethernet MTU immediately */\n        probe_sz = mtu_ceiling;\n    else if (cpath->cop_path.np_pack_size * 2 >= mtu_ceiling)\n        /* Pick half-way point */\n        probe_sz = (mtu_ceiling + cpath->cop_path.np_pack_size) / 2;\n    else\n        probe_sz = cpath->cop_path.np_pack_size * 2;\n\n    /* XXX Changing np_pack_size is action at a distance */\n    saved_packet_sz = cpath->cop_path.np_pack_size;\n    cpath->cop_path.np_pack_size = probe_sz;\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl,\n                                                        0, PNS_APP, CUR_NPATH(conn));\n    if (!packet_out)\n        goto restore_packet_size;\n    sz = conn->ifc_conn.cn_pf->pf_gen_ping_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0) {\n        ABORT_ERROR(\"gen_ping_frame failed\");\n        goto restore_packet_size;\n    }\n    /* We don't record frame records for MTU probes as they are never\n     * resized, only discarded.\n     */\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_PING;\n    avail = lsquic_packet_out_avail(packet_out);\n    if (avail)\n    {\n        memset(packet_out->po_data + packet_out->po_data_sz, 0, avail);\n        lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, avail);\n        packet_out->po_frame_types |= 1 << QUIC_FRAME_PADDING;\n    }\n    packet_out->po_flags |= PO_MTU_PROBE;\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    LSQ_DEBUG(\"generated MTU probe of %hu bytes in packet %\"PRIu64,\n                        cpath->cop_path.np_pack_size, packet_out->po_packno);\n#ifndef NDEBUG\n    ds->ds_probe_sent = now;\n#endif\n    ds->ds_probe_packno = packet_out->po_packno;\n    ds->ds_probed_size = probe_sz;\n    ds->ds_flags |= DS_PROBE_SENT;\n    ++ds->ds_probe_count;\n    conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n    assert(!lsquic_alarmset_is_set(&conn->ifc_alset, AL_MTU_PROBE));\n    lsquic_alarmset_set(&conn->ifc_alset, AL_MTU_PROBE,\n                                now + conn->ifc_enpub->enp_mtu_probe_timer);\n  restore_packet_size:\n    cpath->cop_path.np_pack_size = saved_packet_sz;\n}\n\n\nstatic void\nietf_full_conn_ci_mtu_probe_acked (struct lsquic_conn *lconn,\n                                   const struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct conn_path *cpath;\n    struct dplpmtud_state *ds;\n    unsigned char path_id;\n\n    path_id = packet_out->po_path->np_path_id;\n    cpath = &conn->ifc_paths[path_id];\n    ds = &cpath->cop_dplpmtud;\n    if (ds->ds_probe_packno != packet_out->po_packno)\n    {\n        LSQ_DEBUG(\"Acked MTU probe packet %\"PRIu64\" on path %hhu, but it is \"\n            \"old: discard\", packet_out->po_packno, path_id);\n        return;\n    }\n    ds->ds_flags &= ~DS_PROBE_SENT;\n    ds->ds_probe_count = 0;\n\n    cpath->cop_path.np_pack_size = lsquic_packet_out_sent_sz(&conn->ifc_conn,\n                                                                    packet_out);\n    LSQ_INFO(\"update path %hhu MTU to %hu bytes\", path_id,\n                                                cpath->cop_path.np_pack_size);\n    conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n    lsquic_alarmset_set(&conn->ifc_alset, AL_MTU_PROBE,\n                packet_out->po_sent + conn->ifc_enpub->enp_mtu_probe_timer);\n    LSQ_DEBUG(\"set alarm to %\"PRIu64\" usec \", packet_out->po_sent + conn->ifc_enpub->enp_mtu_probe_timer);\n}\n\n\nstatic void\nmtu_probe_too_large (struct ietf_full_conn *conn,\n                                const struct lsquic_packet_out *packet_out)\n{\n    struct conn_path *cpath;\n    unsigned char path_id;\n\n    path_id = packet_out->po_path->np_path_id;\n    cpath = &conn->ifc_paths[path_id];\n    cpath->cop_dplpmtud.ds_failed_size\n                    = lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_retx_timeout (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    unsigned short pack_size;\n    struct conn_path *cpath;\n    int resize;\n\n    resize = 0;\n    for (cpath = conn->ifc_paths; cpath < conn->ifc_paths + N_PATHS; ++cpath)\n        if (cpath->cop_flags & COP_INITIALIZED)\n        {\n            pack_size = calc_base_packet_size(conn,\n                                                NP_IS_IPv6(&cpath->cop_path));\n            if (cpath->cop_path.np_pack_size > pack_size)\n            {\n                LSQ_DEBUG(\"RTO occurred: change packet size of path %hhu \"\n                    \"to %hu bytes\", cpath->cop_path.np_path_id, pack_size);\n                cpath->cop_path.np_pack_size = pack_size;\n                resize |= 1;\n            }\n        }\n\n    if (resize)\n        lsquic_send_ctl_resize(&conn->ifc_send_ctl);\n    else\n        LSQ_DEBUG(\"RTO occurred, but no MTUs to reset\");\n\n    if (lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n    {\n        LSQ_INFO(\"RTO occurred, disable ECN\");\n        lsquic_send_ctl_disable_ecn(&conn->ifc_send_ctl);\n        if (lsquic_rechist_first(&conn->ifc_rechist[PNS_APP]))\n        {\n            LSQ_DEBUG(\"Send wrong ECN counts to peer so that it turns off \"\n                                                                \"ECN as well\");\n            memset(conn->ifc_ecn_counts_in[PNS_APP], 0,\n                                    sizeof(conn->ifc_ecn_counts_in[PNS_APP]));\n            conn->ifc_mflags |= MF_SEND_WRONG_COUNTS;\n            force_queueing_ack_app(conn);\n            conn->ifc_send_flags |= SF_SEND_PING;\n        }\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_early_data_failed (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    LSQ_DEBUG(\"early data failed\");\n    lsquic_send_ctl_stash_0rtt_packets(&conn->ifc_send_ctl);\n}\n\n\nstatic size_t\nietf_full_conn_ci_get_min_datagram_size (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return (size_t) conn->ifc_min_dg_sz;\n}\n\n\nstatic int\nietf_full_conn_ci_set_min_datagram_size (struct lsquic_conn *lconn,\n                                                            size_t new_size)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    const struct transport_params *const params =\n        lconn->cn_esf.i->esfi_get_peer_transport_params(lconn->cn_enc_session);\n\n    if (!(conn->ifc_flags & IFC_DATAGRAMS))\n    {\n        LSQ_WARN(\"datagrams are not enabled: cannot set minimum size\");\n        return -1;\n    }\n\n    if (new_size > USHRT_MAX)\n    {\n        LSQ_DEBUG(\"min datagram size cannot be larger than %hu\",\n                                                    (unsigned short) USHRT_MAX);\n        return -1;\n    }\n\n    if (new_size > params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE])\n    {\n        LSQ_DEBUG(\"maximum datagram frame size is %\"PRIu64\", cannot change it \"\n            \"to %zd\", params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE],\n            new_size);\n        return -1;\n    }\n\n    conn->ifc_min_dg_sz = new_size;\n    LSQ_DEBUG(\"set minimum datagram size to %zd bytes\", new_size);\n    return 0;\n}\n\n\n/* Return true if datagram was written, false otherwise */\nstatic int\nwrite_datagram (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_datagram_frame_size(conn->ifc_min_dg_sz);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_datagram_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), conn->ifc_min_dg_sz,\n            conn->ifc_max_dg_sz,\n            conn->ifc_enpub->enp_stream_if->on_dg_write, &conn->ifc_conn);\n    if (w < 0)\n    {\n        LSQ_DEBUG(\"could not generate DATAGRAM frame\");\n        return 0;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_DATAGRAM, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding DATAGRAME frame to packet failed: %d\", errno);\n        return 0;\n    }\n    packet_out->po_regen_sz += w;\n    packet_out->po_frame_types |= QUIC_FTBIT_DATAGRAM;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    /* XXX The DATAGRAM frame should really be a regen.  Do it when we\n     * no longer require these frame types to be at the beginning of the\n     * packet.\n     */\n\n    return 1;\n}\n\n\nstatic enum tick_st\nietf_full_conn_ci_tick (struct lsquic_conn *lconn, lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    int have_delayed_packets, s;\n    enum tick_st tick = 0;\n    unsigned n;\n\n#define CLOSE_IF_NECESSARY() do {                                       \\\n    if (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS)                    \\\n    {                                                                   \\\n        tick |= immediate_close(conn);                                  \\\n        goto close_end;                                                 \\\n    }                                                                   \\\n} while (0)\n\n#define RETURN_IF_OUT_OF_PACKETS() do {                                 \\\n    if (!lsquic_send_ctl_can_send(&conn->ifc_send_ctl))                 \\\n    {                                                                   \\\n        if (0 == lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))      \\\n        {                                                               \\\n            LSQ_DEBUG(\"used up packet allowance, quiet now (line %d)\",  \\\n                __LINE__);                                              \\\n            tick |= TICK_QUIET;                                         \\\n        }                                                               \\\n        else                                                            \\\n        {                                                               \\\n            LSQ_DEBUG(\"used up packet allowance, sending now (line %d)\",\\\n                __LINE__);                                              \\\n            tick |= TICK_SEND;                                          \\\n        }                                                               \\\n        goto end;                                                       \\\n    }                                                                   \\\n} while (0)\n\n    CONN_STATS(n_ticks, 1);\n\n    CLOSE_IF_NECESSARY();\n\n    if (conn->ifc_flags & IFC_HAVE_SAVED_ACK)\n    {\n        (void) /* If there is an error, we'll fail shortly */\n        process_ack(conn, &conn->ifc_ack, conn->ifc_saved_ack_received, now);\n        conn->ifc_flags &= ~IFC_HAVE_SAVED_ACK;\n    }\n\n    maybe_set_noprogress_alarm(conn, now);\n\n    lsquic_send_ctl_tick_in(&conn->ifc_send_ctl, now);\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 1);\n    CLOSE_IF_NECESSARY();\n\n    lsquic_alarmset_ring_expired(&conn->ifc_alset, now);\n    CLOSE_IF_NECESSARY();\n\n    /* To make things simple, only stream 1 is active until the handshake\n     * has been completed.  This will be adjusted in the future: the client\n     * does not want to wait if it has the server information.\n     */\n    if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        process_streams_read_events(conn);\n    else\n        process_crypto_stream_read_events(conn);\n    CLOSE_IF_NECESSARY();\n\n    if (lsquic_send_ctl_pacer_blocked(&conn->ifc_send_ctl))\n        goto end_write;\n\n    if (conn->ifc_flags & IFC_FIRST_TICK)\n    {\n        conn->ifc_flags &= ~IFC_FIRST_TICK;\n        have_delayed_packets = 0;\n    }\n    else\n        /* If there are any scheduled packets at this point, it means that\n         * they were not sent during previous tick; in other words, they\n         * are delayed.  When there are delayed packets, the only packet\n         * we sometimes add is a packet with an ACK frame, and we add it\n         * to the *front* of the queue.\n         */\n        have_delayed_packets =\n            lsquic_send_ctl_maybe_squeeze_sched(&conn->ifc_send_ctl);\n\n    if (should_generate_ack(conn, IFC_ACK_QUEUED) ||\n                        (!have_delayed_packets && maybe_queue_opp_ack(conn)))\n    {\n        if (have_delayed_packets)\n            lsquic_send_ctl_reset_packnos(&conn->ifc_send_ctl);\n\n        n = generate_ack_frame(conn, now);\n        CLOSE_IF_NECESSARY();\n\n        if (have_delayed_packets && n)\n            lsquic_send_ctl_ack_to_front(&conn->ifc_send_ctl, n);\n    }\n\n    if (have_delayed_packets)\n    {\n        /* The reason for not adding the other frames below to the packet\n         * carrying ACK frame generated when there are delayed packets is\n         * so that if the ACK packet itself is delayed, it can be dropped\n         * and replaced by new ACK packet.  This way, we are never more\n         * than 1 packet over CWND.\n         */\n        tick |= TICK_SEND;\n        if (conn->ifc_flags & IFC_CLOSING)\n            goto end_write;\n        else\n            goto end;\n    }\n\n    /* Try to fit MAX_DATA before checking if we have run out of room.\n     * If it does not fit, it will be tried next time around.\n     */\n    if (lsquic_cfcw_fc_offsets_changed(&conn->ifc_pub.cfcw) ||\n                                (conn->ifc_send_flags & SF_SEND_MAX_DATA))\n    {\n        conn->ifc_send_flags |= SF_SEND_MAX_DATA;\n        generate_max_data_frame(conn);\n        CLOSE_IF_NECESSARY();\n    }\n\n    if (conn->ifc_send_flags & SEND_WITH_FUNCS)\n    {\n        enum send send;\n        for (send = 0; send < N_SEND; ++send)\n            if (conn->ifc_send_flags & (1 << send) & SEND_WITH_FUNCS)\n            {\n                send_funcs[send](conn, now);\n                CLOSE_IF_NECESSARY();\n            }\n    }\n\n    if (conn->ifc_mflags & MF_CHECK_MTU_PROBE)\n        check_or_schedule_mtu_probe(conn, now);\n\n    n = lsquic_send_ctl_reschedule_packets(&conn->ifc_send_ctl);\n    if (n > 0)\n        CLOSE_IF_NECESSARY();\n\n    if (conn->ifc_conn.cn_flags & LSCONN_SEND_BLOCKED)\n    {\n        RETURN_IF_OUT_OF_PACKETS();\n        if (generate_blocked_frame(conn))\n            conn->ifc_conn.cn_flags &= ~LSCONN_SEND_BLOCKED;\n    }\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.sending_streams))\n    {\n        process_streams_ready_to_send(conn);\n        CLOSE_IF_NECESSARY();\n    }\n\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 0);\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {\n        s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl,\n                                                            BPT_HIGHEST_PRIO);\n        conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n        if (0 == s)\n            process_crypto_stream_write_events(conn);\n        if (!(conn->ifc_mflags & MF_DOING_0RTT))\n        {\n            lsquic_send_ctl_maybe_app_limited(&conn->ifc_send_ctl,\n                                                            CUR_NPATH(conn));\n            goto end_write;\n        }\n    }\n\n    maybe_conn_flush_special_streams(conn);\n\n    s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl, BPT_HIGHEST_PRIO);\n    conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n    if (!write_is_possible(conn))\n        goto end_write;\n\n    while ((conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE) && write_datagram(conn))\n        if (!write_is_possible(conn))\n            goto end_write;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n    {\n        process_streams_write_events(conn, 1);\n        if (!write_is_possible(conn))\n            goto end_write;\n    }\n\n    s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl, BPT_OTHER_PRIO);\n    conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n    if (!write_is_possible(conn))\n        goto end_write;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n        process_streams_write_events(conn, 0);\n\n    lsquic_send_ctl_maybe_app_limited(&conn->ifc_send_ctl, CUR_NPATH(conn));\n\n  end_write:\n    if ((conn->ifc_flags & IFC_CLOSING)\n        && ((conn->ifc_send_flags & SF_SEND_CONN_CLOSE)\n            || conn_ok_to_close(conn)))\n    {\n        LSQ_DEBUG(\"connection is OK to close\");\n        conn->ifc_flags |= IFC_TICK_CLOSE;\n        if (conn->ifc_flags & IFC_RECV_CLOSE)\n            tick |= TICK_CLOSE;\n        if (!(conn->ifc_mflags & MF_CONN_CLOSE_PACK)\n            /* Generate CONNECTION_CLOSE frame if:\n             *     ... this is a client and handshake was successful;\n             */\n            && (!(conn->ifc_flags & (IFC_SERVER|IFC_HSK_FAILED))\n                /* or: sent a GOAWAY frame;\n                 */\n                    || (conn->ifc_flags & IFC_GOAWAY_CLOSE)\n                /* or: we received CONNECTION_CLOSE and we are not a server\n                 * that chooses not to send CONNECTION_CLOSE responses.\n                 * From [draft-ietf-quic-transport-29]:\n                 \" An endpoint that receives a CONNECTION_CLOSE frame MAY send\n                 \" a single packet containing a CONNECTION_CLOSE frame before\n                 \" entering the draining state\n                 */\n                    || ((conn->ifc_flags & IFC_RECV_CLOSE)\n                            && !((conn->ifc_flags & IFC_SERVER)\n                                    && conn->ifc_settings->es_silent_close))\n                /* or: we have packets to send. */\n                    || 0 != lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))\n                )\n        {\n            RETURN_IF_OUT_OF_PACKETS();\n            generate_connection_close_packet(conn);\n            tick |= TICK_SEND|TICK_CLOSE;\n        }\n        else\n            tick |= TICK_CLOSE;\n\n        goto end;\n    }\n\n    if (0 == lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))\n    {\n        if (conn->ifc_send_flags & SF_SEND_PING)\n        {\n            RETURN_IF_OUT_OF_PACKETS();\n            generate_ping_frame(conn, now);\n            CLOSE_IF_NECESSARY();\n            assert(lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl) != 0);\n        }\n        else\n        {\n            tick |= TICK_QUIET;\n            goto end;\n        }\n    }\n    else if (conn->ifc_ping_period\n            && (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_PING);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_send_flags &= ~SF_SEND_PING;   /* It may have rung */\n    }\n\n    /* [draft-ietf-quic-transport-11] Section 7.9:\n     *\n     *     The PING frame can be used to keep a connection alive when an\n     *     application or application protocol wishes to prevent the connection\n     *     from timing out.  An application protocol SHOULD provide guidance\n     *     about the conditions under which generating a PING is recommended.\n     *     This guidance SHOULD indicate whether it is the client or the server\n     *     that is expected to send the PING.  Having both endpoints send PING\n     *     frames without coordination can produce an excessive number of\n     *     packets and poor performance.\n     */\n    if (conn->ifc_ping_period\n                        && lsquic_hash_count(conn->ifc_pub.all_streams) >\n                           conn->ifc_pub.n_special_streams)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                                                now + conn->ifc_ping_period);\n\n    tick |= TICK_SEND;\n\n  end:\n    service_streams(conn);\n    CLOSE_IF_NECESSARY();\n\n  close_end:\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 1);\n    lsquic_send_ctl_tick_out(&conn->ifc_send_ctl);\n    return tick;\n}\n\n\nstatic enum LSQUIC_CONN_STATUS\nietf_full_conn_ci_status (struct lsquic_conn *lconn, char *errbuf, size_t bufsz)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    size_t n;\n\n    /* Test the common case first: */\n    if (!(conn->ifc_flags & (IFC_ERROR\n                            |IFC_TIMED_OUT\n                            |IFC_ABORTED\n                            |IFC_GOT_PRST\n                            |IFC_HSK_FAILED\n                            |IFC_CLOSING\n                            |IFC_GOING_AWAY)))\n    {\n        if (lconn->cn_flags & LSCONN_PEER_GOING_AWAY)\n            return LSCONN_ST_PEER_GOING_AWAY;\n        else if (lconn->cn_flags & LSCONN_HANDSHAKE_DONE)\n            return LSCONN_ST_CONNECTED;\n        else\n            return LSCONN_ST_HSK_IN_PROGRESS;\n    }\n\n    if (errbuf && bufsz)\n    {\n        if (conn->ifc_errmsg)\n        {\n            n = bufsz < MAX_ERRMSG ? bufsz : MAX_ERRMSG;\n            strncpy(errbuf, conn->ifc_errmsg, n);\n            errbuf[n - 1] = '\\0';\n        }\n        else\n            errbuf[0] = '\\0';\n    }\n\n    if (conn->ifc_flags & IFC_ERROR)\n    {\n        if (conn->ifc_flags & IFC_HSK_FAILED)\n            return LSCONN_ST_VERNEG_FAILURE;\n        else\n            return LSCONN_ST_ERROR;\n    }\n    if (conn->ifc_flags & IFC_TIMED_OUT)\n        return LSCONN_ST_TIMED_OUT;\n    if (conn->ifc_flags & IFC_ABORTED)\n        return LSCONN_ST_USER_ABORTED;\n    if (conn->ifc_flags & IFC_GOT_PRST)\n        return LSCONN_ST_RESET;\n    if (conn->ifc_flags & IFC_HSK_FAILED)\n        return LSCONN_ST_HSK_FAILURE;\n    if (conn->ifc_flags & IFC_CLOSING)\n        return LSCONN_ST_CLOSED;\n    assert(conn->ifc_flags & IFC_GOING_AWAY);\n    return LSCONN_ST_GOING_AWAY;\n}\n\n\nstatic void\nietf_full_conn_ci_stateless_reset (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    conn->ifc_flags |= IFC_GOT_PRST;\n    LSQ_INFO(\"stateless reset reported\");\n}\n\n\nstatic struct lsquic_engine *\nietf_full_conn_ci_get_engine (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return conn->ifc_enpub->enp_engine;\n}\n\n\nstatic unsigned\nietf_full_conn_ci_n_pending_streams (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    return conn->ifc_n_delayed_streams;\n}\n\n\nstatic unsigned\nietf_full_conn_ci_n_avail_streams (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    return avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_BIDI);\n}\n\n\nstatic int\nhandshake_done_or_doing_sess_resume (const struct ietf_full_conn *conn)\n{\n    return (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        || conn->ifc_conn.cn_esf_c->esf_is_sess_resume_enabled(\n                                                conn->ifc_conn.cn_enc_session);\n}\n\n\nstatic void\nietf_full_conn_ci_make_stream (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    if (handshake_done_or_doing_sess_resume(conn)\n        && ietf_full_conn_ci_n_avail_streams(lconn) > 0)\n    {\n        if (0 != create_bidi_stream_out(conn))\n            ABORT_ERROR(\"could not create new stream: %s\", strerror(errno));\n    }\n    else if (either_side_going_away(conn))\n    {\n        (void) conn->ifc_enpub->enp_stream_if->on_new_stream(\n                                    conn->ifc_enpub->enp_stream_if_ctx, NULL);\n        LSQ_DEBUG(\"going away: no streams will be initiated\");\n    }\n    else\n    {\n        ++conn->ifc_n_delayed_streams;\n        LSQ_DEBUG(\"delayed stream creation.  Backlog size: %u\",\n                                                conn->ifc_n_delayed_streams);\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_internal_error (struct lsquic_conn *lconn,\n                                                    const char *format, ...)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    LSQ_INFO(\"internal error reported\");\n    ABORT_QUIETLY(0, TEC_INTERNAL_ERROR, \"Internal error\");\n}\n\n\nstatic void\nietf_full_conn_ci_abort_error (struct lsquic_conn *lconn, int is_app,\n                                unsigned error_code, const char *fmt, ...)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    va_list ap;\n    const char *err_str, *percent;\n    char err_buf[0x100];\n\n    if (conn->ifc_error.u.err != 0)\n        return;\n    percent = strchr(fmt, '%');\n    if (percent)\n    {\n        va_start(ap, fmt);\n        vsnprintf(err_buf, sizeof(err_buf), fmt, ap);\n        va_end(ap);\n        err_str = err_buf;\n    }\n    else\n        err_str = fmt;\n    LSQ_INFO(\"abort error: is_app: %d; error code: %u; error str: %s\",\n        is_app, error_code, err_str);\n    ABORT_QUIETLY(is_app, error_code, \"%s\", err_str);\n}\n\n\nstatic int\npath_matches_local_sa (const struct network_path *path,\n                                            const struct sockaddr *local_sa)\n{\n    return lsquic_sockaddr_eq(NP_LOCAL_SA(path), local_sa);\n}\n\n\nstatic struct network_path *\nietf_full_conn_ci_get_path (struct lsquic_conn *lconn,\n                                                    const struct sockaddr *sa)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct conn_path *copath;\n\n    if (NULL == sa || path_matches_local_sa(CUR_NPATH(conn), sa))\n        return CUR_NPATH(conn);\n\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n        if ((conn->ifc_used_paths & (1 << (copath - conn->ifc_paths)))\n                            && path_matches_local_sa(&copath->cop_path, sa))\n            return &copath->cop_path;\n\n    return CUR_NPATH(conn);\n}\n\n\nstatic int\npath_matches (const struct network_path *path,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    return local_sa->sa_family == NP_LOCAL_SA(path)->sa_family\n        && lsquic_sockaddr_eq(local_sa, NP_LOCAL_SA(path))\n        && lsquic_sockaddr_eq(peer_sa, NP_PEER_SA(path));\n}\n\n\nstatic void\nrecord_to_path (struct ietf_full_conn *conn, struct conn_path *copath, void *peer_ctx,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    struct network_path *path;\n    size_t len;\n    char path_str[2][INET6_ADDRSTRLEN + sizeof(\":65535\")];\n\n    LSQ_DEBUG(\"record path %d: (%s - %s)\", (int) (copath - conn->ifc_paths),\n                SA2STR(local_sa, path_str[0]), SA2STR(peer_sa, path_str[1]));\n    path = &copath->cop_path;\n    len = local_sa->sa_family == AF_INET ? sizeof(struct sockaddr_in)\n                                                : sizeof(struct sockaddr_in6);\n    memcpy(NP_LOCAL_SA(path), local_sa, len);\n    len = peer_sa->sa_family == AF_INET ? sizeof(struct sockaddr_in)\n                                            : sizeof(struct sockaddr_in6);\n    memcpy(NP_PEER_SA(path), peer_sa, len);\n    path->np_peer_ctx = peer_ctx;\n}\n\n\nstatic unsigned char\nietf_full_conn_ci_record_addrs (struct lsquic_conn *lconn, void *peer_ctx,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct network_path *path;\n    struct conn_path *copath, *first_unused, *first_unvalidated, *first_other,\n                                                                        *victim;\n\n    path = &conn->ifc_paths[conn->ifc_cur_path_id].cop_path;\n    if (path_matches(path, local_sa, peer_sa))\n    {\n        path->np_peer_ctx = peer_ctx;\n        return conn->ifc_cur_path_id;\n    }\n\n    first_unvalidated = NULL;\n    first_unused = NULL;\n    first_other = NULL;\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n    {\n        if (conn->ifc_used_paths & (1 << (copath - conn->ifc_paths)))\n        {\n            if (path_matches(&copath->cop_path, local_sa, peer_sa))\n            {\n                copath->cop_path.np_peer_ctx = peer_ctx;\n                return copath - conn->ifc_paths;\n            }\n            if (!first_unvalidated\n                            && (0 == (copath->cop_flags & COP_VALIDATED)))\n                first_unvalidated = copath;\n            else if (!first_other)\n                first_other = copath;\n        }\n        else if (!first_unused)\n            first_unused = copath;\n    }\n\n    if (first_unused)\n    {\n        record_to_path(conn, first_unused, peer_ctx, local_sa, peer_sa);\n        if (0 == conn->ifc_used_paths && !(conn->ifc_flags & IFC_SERVER))\n        {\n            /* First path is considered valid immediately */\n            first_unused->cop_flags |= COP_VALIDATED;\n            maybe_enable_spin(conn, first_unused);\n        }\n        LSQ_DEBUG(\"record new path ID %d\",\n                                    (int) (first_unused - conn->ifc_paths));\n        conn->ifc_used_paths |= 1 << (first_unused - conn->ifc_paths);\n        return first_unused - conn->ifc_paths;\n    }\n\n    if (first_unvalidated || first_other)\n    {\n        victim = first_unvalidated ? first_unvalidated : first_other;\n        record_to_path(conn, victim, peer_ctx, local_sa, peer_sa);\n        return victim - conn->ifc_paths;\n    }\n\n    return conn->ifc_cur_path_id;\n}\n\n\nstatic void\nietf_full_conn_ci_drop_crypto_streams (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    drop_crypto_streams(conn);\n}\n\n\nvoid\nietf_full_conn_ci_count_garbage (struct lsquic_conn *lconn, size_t garbage_sz)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    conn->ifc_pub.bytes_in += garbage_sz;\n    LSQ_DEBUG(\"count %zd bytes of garbage, new value: %u bytes\", garbage_sz,\n        conn->ifc_pub.bytes_in);\n}\n\n\n#if LSQUIC_CONN_STATS\nstatic const struct conn_stats *\nietf_full_conn_ci_get_stats (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return &conn->ifc_stats;\n}\n\n\n#include \"lsquic_cong_ctl.h\"\n\nstatic void\nietf_full_conn_ci_log_stats (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct batch_size_stats *const bs = &conn->ifc_enpub->enp_batch_size_stats;\n    struct conn_stats diff_stats;\n    uint64_t cwnd;\n    char cidstr[MAX_CID_LEN * 2 + 1];\n\n    if (!conn->ifc_last_stats)\n    {\n        conn->ifc_last_stats = calloc(1, sizeof(*conn->ifc_last_stats));\n        if (!conn->ifc_last_stats)\n            return;\n        LSQ_DEBUG(\"allocated last stats\");\n    }\n\n    cwnd = conn->ifc_send_ctl.sc_ci->cci_get_cwnd(\n                                            conn->ifc_send_ctl.sc_cong_ctl);\n    lsquic_conn_stats_diff(&conn->ifc_stats, conn->ifc_last_stats, &diff_stats);\n    lsquic_logger_log1(LSQ_LOG_NOTICE, LSQLM_CONN_STATS,\n        \"%s: ticks: %lu; cwnd: %\"PRIu64\"; conn flow: max: %\"PRIu64\n        \", avail: %\"PRIu64\"; packets: sent: %lu, lost: %lu, retx: %lu, rcvd: %lu\"\n        \"; batch: count: %u; min: %u; max: %u; avg: %.2f\",\n        (lsquic_cid2str(LSQUIC_LOG_CONN_ID, cidstr), cidstr),\n        diff_stats.n_ticks, cwnd,\n        conn->ifc_pub.conn_cap.cc_max,\n        lsquic_conn_cap_avail(&conn->ifc_pub.conn_cap),\n        diff_stats.out.packets, diff_stats.out.lost_packets,\n        diff_stats.out.retx_packets, diff_stats.in.packets,\n        bs->count, bs->min, bs->max, bs->avg);\n\n    *conn->ifc_last_stats = conn->ifc_stats;\n    memset(bs, 0, sizeof(*bs));\n}\n\n\n#endif\n\n\n#define IETF_FULL_CONN_FUNCS \\\n    .ci_abort                =  ietf_full_conn_ci_abort, \\\n    .ci_abort_error          =  ietf_full_conn_ci_abort_error, \\\n    .ci_ack_snapshot         =  ietf_full_conn_ci_ack_snapshot, \\\n    .ci_ack_rollback         =  ietf_full_conn_ci_ack_rollback, \\\n    .ci_retire_cid           =  ietf_full_conn_ci_retire_cid, \\\n    .ci_can_write_ack        =  ietf_full_conn_ci_can_write_ack, \\\n    .ci_cancel_pending_streams =  ietf_full_conn_ci_cancel_pending_streams, \\\n    .ci_client_call_on_new   =  ietf_full_conn_ci_client_call_on_new, \\\n    .ci_close                =  ietf_full_conn_ci_close, \\\n    .ci_count_garbage        =  ietf_full_conn_ci_count_garbage, \\\n    .ci_destroy              =  ietf_full_conn_ci_destroy, \\\n    .ci_drain_time           =  ietf_full_conn_ci_drain_time, \\\n    .ci_drop_crypto_streams  =  ietf_full_conn_ci_drop_crypto_streams, \\\n    .ci_early_data_failed    =  ietf_full_conn_ci_early_data_failed, \\\n    .ci_get_engine           =  ietf_full_conn_ci_get_engine, \\\n    .ci_get_min_datagram_size=  ietf_full_conn_ci_get_min_datagram_size, \\\n    .ci_get_path             =  ietf_full_conn_ci_get_path, \\\n    .ci_going_away           =  ietf_full_conn_ci_going_away, \\\n    .ci_hsk_done             =  ietf_full_conn_ci_hsk_done, \\\n    .ci_internal_error       =  ietf_full_conn_ci_internal_error, \\\n    .ci_is_push_enabled      =  ietf_full_conn_ci_is_push_enabled, \\\n    .ci_is_tickable          =  ietf_full_conn_ci_is_tickable, \\\n    .ci_make_stream          =  ietf_full_conn_ci_make_stream, \\\n    .ci_mtu_probe_acked      =  ietf_full_conn_ci_mtu_probe_acked, \\\n    .ci_n_avail_streams      =  ietf_full_conn_ci_n_avail_streams, \\\n    .ci_n_pending_streams    =  ietf_full_conn_ci_n_pending_streams, \\\n    .ci_next_tick_time       =  ietf_full_conn_ci_next_tick_time, \\\n    .ci_packet_in            =  ietf_full_conn_ci_packet_in, \\\n    .ci_push_stream          =  ietf_full_conn_ci_push_stream, \\\n    .ci_record_addrs         =  ietf_full_conn_ci_record_addrs, \\\n    .ci_report_live          =  ietf_full_conn_ci_report_live, \\\n    .ci_retx_timeout         =  ietf_full_conn_ci_retx_timeout, \\\n    .ci_set_min_datagram_size=  ietf_full_conn_ci_set_min_datagram_size, \\\n    .ci_status               =  ietf_full_conn_ci_status, \\\n    .ci_stateless_reset      =  ietf_full_conn_ci_stateless_reset, \\\n    .ci_tick                 =  ietf_full_conn_ci_tick, \\\n    .ci_tls_alert            =  ietf_full_conn_ci_tls_alert, \\\n    .ci_want_datagram_write  =  ietf_full_conn_ci_want_datagram_write, \\\n    .ci_write_ack            =  ietf_full_conn_ci_write_ack\n\nstatic const struct conn_iface ietf_full_conn_iface = {\n    IETF_FULL_CONN_FUNCS,\n    .ci_next_packet_to_send =  ietf_full_conn_ci_next_packet_to_send,\n    .ci_packet_not_sent     =  ietf_full_conn_ci_packet_not_sent,\n    .ci_packet_sent         =  ietf_full_conn_ci_packet_sent,\n    .ci_packet_too_large    =  ietf_full_conn_ci_packet_too_large,\n#if LSQUIC_CONN_STATS\n    .ci_get_stats           =  ietf_full_conn_ci_get_stats,\n    .ci_log_stats           =  ietf_full_conn_ci_log_stats,\n#endif\n};\nstatic const struct conn_iface *ietf_full_conn_iface_ptr =\n                                                &ietf_full_conn_iface;\n\nstatic const struct conn_iface ietf_full_conn_prehsk_iface = {\n    IETF_FULL_CONN_FUNCS,\n    .ci_next_packet_to_send =  ietf_full_conn_ci_next_packet_to_send_pre_hsk,\n    .ci_packet_not_sent     =  ietf_full_conn_ci_packet_not_sent_pre_hsk,\n    .ci_packet_sent         =  ietf_full_conn_ci_packet_sent_pre_hsk,\n#if LSQUIC_CONN_STATS\n    .ci_get_stats           =  ietf_full_conn_ci_get_stats,\n    .ci_log_stats           =  ietf_full_conn_ci_log_stats,\n#endif\n};\nstatic const struct conn_iface *ietf_full_conn_prehsk_iface_ptr =\n                                                &ietf_full_conn_prehsk_iface;\n\n\nstatic void\non_cancel_push_client (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received CANCEL_PUSH(%\"PRIu64\")\",\n                                                                    push_id);\n    if (conn->ifc_u.cli.ifcli_flags & IFCLI_PUSH_ENABLED)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH but push is \"\n                                                                \"not enabled\");\n        return;\n    }\n\n    if (push_id > conn->ifc_u.cli.ifcli_max_push_id)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH with ID=%\"PRIu64\n            \", which is greater than the maximum Push ID=%\"PRIu64, push_id,\n            conn->ifc_u.cli.ifcli_max_push_id);\n        return;\n    }\n\n#if CLIENT_PUSH_SUPPORT\n    LSQ_WARN(\"TODO: support for CANCEL_PUSH is not implemented\");\n#endif\n}\n\n\n/* Careful: this puts promise */\nstatic void\ncancel_push_promise (struct ietf_full_conn *conn, struct push_promise *promise)\n{\n    LSQ_DEBUG(\"cancel promise %\"PRIu64, promise->pp_id);\n    /* Remove promise from hash to prevent multiple cancellations */\n    lsquic_hash_erase(conn->ifc_pub.u.ietf.promises, &promise->pp_hash_id);\n    /* But let stream dtor free the promise object as sm_promise may yet\n     * be used by the stream in some ways.\n     */\n    /* TODO: drop lsquic_stream_shutdown_internal, use something else */\n    lsquic_stream_shutdown_internal(promise->pp_pushed_stream);\n    if (0 != lsquic_hcso_write_cancel_push(&conn->ifc_hcso, promise->pp_id))\n        ABORT_WARN(\"cannot write CANCEL_PUSH\");\n    lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n}\n\n\nstatic void\non_cancel_push_server (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received CANCEL_PUSH(%\"PRIu64\")\",\n                                                                    push_id);\n    if (push_id >= conn->ifc_u.ser.ifser_next_push_id)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH with ID=%\"PRIu64\n            \", which is greater than the maximum Push ID ever generated by \"\n            \"this connection\", push_id);\n        return;\n    }\n\n    el = lsquic_hash_find(conn->ifc_pub.u.ietf.promises, &push_id,\n                                                            sizeof(push_id));\n    if (!el)\n    {\n        LSQ_DEBUG(\"push promise %\"PRIu64\" not found\", push_id);\n        return;\n    }\n\n    promise = lsquic_hashelem_getdata(el);\n    cancel_push_promise(conn, promise);\n}\n\n\nstatic void\non_max_push_id_client (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"client does not expect the server \"\n        \"to send MAX_PUSH_ID frame\");\n}\n\n\nstatic void\non_max_push_id (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    if (!(conn->ifc_u.ser.ifser_flags & IFSER_MAX_PUSH_ID)\n                            || push_id > conn->ifc_u.ser.ifser_max_push_id)\n    {\n        conn->ifc_u.ser.ifser_max_push_id = push_id;\n        conn->ifc_u.ser.ifser_flags |= IFSER_MAX_PUSH_ID;\n        LSQ_DEBUG(\"set MAX_PUSH_ID to %\"PRIu64, push_id);\n    }\n    else if (push_id < conn->ifc_u.ser.ifser_max_push_id)\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"MAX_PUSH_ID reduced from \"\n            \"%\"PRIu64\" to %\"PRIu64, conn->ifc_u.ser.ifser_max_push_id, push_id);\n    else\n        LSQ_DEBUG(\"ignore repeated value of MAX_PUSH_ID=%\"PRIu64, push_id);\n}\n\n\nstatic void\non_settings_frame (void *ctx)\n{\n    struct ietf_full_conn *const conn = ctx;\n    unsigned dyn_table_size, max_risked_streams;\n\n    LSQ_DEBUG(\"SETTINGS frame\");\n    if (conn->ifc_flags & IFC_HAVE_PEER_SET)\n    {\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED,\n            \"second incoming SETTING frame on HTTP control stream\");\n        return;\n    }\n\n    conn->ifc_flags |= IFC_HAVE_PEER_SET;\n    dyn_table_size = MIN(conn->ifc_settings->es_qpack_enc_max_size,\n                                conn->ifc_peer_hq_settings.header_table_size);\n    max_risked_streams = MIN(conn->ifc_settings->es_qpack_enc_max_blocked,\n                            conn->ifc_peer_hq_settings.qpack_blocked_streams);\n    if (conn->ifc_settings->es_qpack_experiment == 2)\n        randomize_qpack_settings(conn, \"encoder\", &dyn_table_size,\n                                                        &max_risked_streams);\n    if (conn->ifc_qeh.qeh_exp_rec)\n    {\n        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_size\n                        = conn->ifc_peer_hq_settings.header_table_size;\n        conn->ifc_qeh.qeh_exp_rec->qer_used_max_size = dyn_table_size;\n        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_blocked\n                        = conn->ifc_peer_hq_settings.qpack_blocked_streams;\n        conn->ifc_qeh.qeh_exp_rec->qer_used_max_blocked = max_risked_streams;\n    }\n    if (0 != lsquic_qeh_settings(&conn->ifc_qeh,\n            conn->ifc_peer_hq_settings.header_table_size,\n            dyn_table_size, max_risked_streams, conn->ifc_flags & IFC_SERVER))\n        ABORT_WARN(\"could not initialize QPACK encoder handler\");\n    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)\n    {\n        if (0 != create_qenc_stream_out(conn))\n            ABORT_WARN(\"cannot create outgoing QPACK encoder stream\");\n    }\n    else\n    {\n        queue_streams_blocked_frame(conn, SD_UNI);\n        LSQ_DEBUG(\"cannot create QPACK encoder stream due to unidir limit\");\n    }\n    maybe_create_delayed_streams(conn);\n}\n\n\nstatic void\non_setting (void *ctx, uint64_t setting_id, uint64_t value)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    switch (setting_id)\n    {\n    case HQSID_QPACK_BLOCKED_STREAMS:\n        LSQ_DEBUG(\"Peer's SETTINGS_QPACK_BLOCKED_STREAMS=%\"PRIu64, value);\n        conn->ifc_peer_hq_settings.qpack_blocked_streams = value;\n        break;\n    case HQSID_QPACK_MAX_TABLE_CAPACITY:\n        LSQ_DEBUG(\"Peer's SETTINGS_QPACK_MAX_TABLE_CAPACITY=%\"PRIu64, value);\n        conn->ifc_peer_hq_settings.header_table_size = value;\n        break;\n    case HQSID_MAX_HEADER_LIST_SIZE:\n        LSQ_DEBUG(\"Peer's SETTINGS_MAX_HEADER_LIST_SIZE=%\"PRIu64\"; \"\n                                                        \"we ignore it\", value);\n        break;\n    default:\n        LSQ_DEBUG(\"received unknown SETTING 0x%\"PRIX64\"=0x%\"PRIX64\n                                        \"; ignore it\", setting_id, value);\n        break;\n    case 2: /* HTTP/2 SETTINGS_ENABLE_PUSH */\n    case 3: /* HTTP/2 SETTINGS_MAX_CONCURRENT_STREAMS */\n    case 4: /* HTTP/2 SETTINGS_INITIAL_WINDOW_SIZE */\n    case 5: /* HTTP/2 SETTINGS_MAX_FRAME_SIZE */\n        /* [draft-ietf-quic-http-30] Section 7.2.4.1 */\n        ABORT_QUIETLY(1, HEC_SETTINGS_ERROR, \"unexpected HTTP/2 setting \"\n            \"%\"PRIu64, setting_id);\n        break;\n    }\n}\n\n\nstatic void\non_goaway_server_27 (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED,\n                                    \"client should not send GOAWAY frames\");\n}\n\n\nstatic void\non_goaway_client_27 (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (sit != SIT_BIDI_CLIENT)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR,\n                            \"stream ID %\"PRIu64\" in GOAWAY frame\", stream_id);\n        return;\n    }\n\n    if (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY)\n    {\n        LSQ_DEBUG(\"ignore duplicate GOAWAY frame\");\n        return;\n    }\n\n    conn->ifc_conn.cn_flags |= LSCONN_PEER_GOING_AWAY;\n    LSQ_DEBUG(\"received GOAWAY frame, last good stream ID: %\"PRIu64, stream_id);\n    if (conn->ifc_enpub->enp_stream_if->on_goaway_received)\n        conn->ifc_enpub->enp_stream_if->on_goaway_received(&conn->ifc_conn);\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (stream->id > stream_id\n                            && (stream->id & SIT_MASK) == SIT_BIDI_CLIENT)\n        {\n            lsquic_stream_received_goaway(stream);\n        }\n    }\n}\n\n\nstatic void\non_goaway_client (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (sit != SIT_BIDI_CLIENT)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR,\n                            \"stream ID %\"PRIu64\" in GOAWAY frame\", stream_id);\n        return;\n    }\n\n    LSQ_DEBUG(\"received GOAWAY frame, last good stream ID: %\"PRIu64, stream_id);\n\n    if (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY)\n    {\n        if (stream_id == conn->ifc_u.cli.ifcli_min_goaway_stream_id)\n        {\n            LSQ_DEBUG(\"ignore duplicate GOAWAY frame\");\n            return;\n        }\n        if (stream_id > conn->ifc_u.cli.ifcli_min_goaway_stream_id)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR,\n                \"stream ID %\"PRIu64\" is larger than one already seen in a \"\n                \"previous GOAWAY frame, %\"PRIu64, stream_id,\n                conn->ifc_u.cli.ifcli_min_goaway_stream_id);\n            return;\n        }\n    }\n    else\n    {\n        conn->ifc_u.cli.ifcli_min_goaway_stream_id = stream_id;\n        conn->ifc_conn.cn_flags |= LSCONN_PEER_GOING_AWAY;\n        if (conn->ifc_enpub->enp_stream_if->on_goaway_received)\n            conn->ifc_enpub->enp_stream_if->on_goaway_received(&conn->ifc_conn);\n    }\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (stream->id > stream_id\n                            && (stream->id & SIT_MASK) == SIT_BIDI_CLIENT)\n        {\n            lsquic_stream_received_goaway(stream);\n        }\n    }\n}\n\n\nstatic void\non_goaway_server (void *ctx, uint64_t max_push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct push_promise *promise;\n    struct lsquic_hash_elem *el;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received GOAWAY(%\"PRIu64\")\",\n                                                                max_push_id);\n    for (el = lsquic_hash_first(conn->ifc_pub.u.ietf.promises); el;\n                        el = lsquic_hash_next(conn->ifc_pub.u.ietf.promises))\n    {\n        promise = lsquic_hashelem_getdata(el);\n        if (promise->pp_id > max_push_id)\n            cancel_push_promise(conn, promise);\n    }\n}\n\n\nstatic void\non_priority_update_client (void *ctx, enum hq_frame_type frame_type,\n                                uint64_t id, const char *pfv, size_t pfv_sz)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    if (conn->ifc_pii == &ext_prio_iter_if)\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"Frame type %u is not \"\n            \"expected to be sent by the server\", (unsigned) frame_type);\n    /* else ignore */\n}\n\n\n/* This should not happen often, so do not bother to optimize memory. */\nstatic int\nbuffer_priority_update (struct ietf_full_conn *conn,\n        lsquic_stream_id_t stream_id, const struct lsquic_ext_http_prio *ehp)\n{\n    struct buffered_priority_update *bpu;\n    struct lsquic_hash_elem *el;\n\n    if (!conn->ifc_bpus)\n    {\n        conn->ifc_bpus = lsquic_hash_create();\n        if (!conn->ifc_bpus)\n        {\n            ABORT_ERROR(\"cannot allocate BPUs hash\");\n            return -1;\n        }\n        goto insert_new;\n    }\n\n    el = lsquic_hash_find(conn->ifc_bpus, &stream_id, sizeof(stream_id));\n    if (el)\n    {\n        bpu = lsquic_hashelem_getdata(el);\n        bpu->ehp = *ehp;\n        return 0;\n    }\n\n  insert_new:\n    bpu = malloc(sizeof(*bpu));\n    if (!bpu)\n    {\n        ABORT_ERROR(\"cannot allocate BPU\");\n        return -1;\n    }\n\n    bpu->hash_el.qhe_flags = 0;\n    bpu->stream_id = stream_id;\n    bpu->ehp = *ehp;\n    if (!lsquic_hash_insert(conn->ifc_bpus, &bpu->stream_id,\n                                sizeof(bpu->stream_id), bpu, &bpu->hash_el))\n    {\n        free(bpu);\n        ABORT_ERROR(\"cannot insert BPU\");\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic void\non_priority_update_server (void *ctx, enum hq_frame_type frame_type,\n                                uint64_t id, const char *pfv, size_t pfv_sz)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n    struct lsquic_stream *stream;\n    enum stream_id_type sit;\n    struct lsquic_ext_http_prio ehp;\n\n    if (conn->ifc_pii != &ext_prio_iter_if)\n    {\n        LSQ_DEBUG(\"Ignore PRIORITY_UPDATE frame\");\n        return;\n    }\n\n    if (frame_type == HQFT_PRIORITY_UPDATE_STREAM)\n    {\n        sit = id & SIT_MASK;\n        if (sit != SIT_BIDI_CLIENT)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"PRIORITY_UPDATE for non-request \"\n                \"stream\");\n            return;\n        }\n        if (id >= conn->ifc_max_allowed_stream_id[sit])\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"PRIORITY_UPDATE for non-existing \"\n                \"stream %\"PRIu64\" exceeds allowed max of %\"PRIu64,\n                id, conn->ifc_max_allowed_stream_id[sit]);\n            return;\n        }\n        stream = find_stream_by_id(conn, id);\n        if (!stream && conn_is_stream_closed(conn, id))\n        {\n            LSQ_DEBUG(\"stream %\"PRIu64\" closed, ignore PRIORITY_UPDATE\", id);\n            return;\n        }\n    }\n    else\n    {\n        if (id >= conn->ifc_u.ser.ifser_next_push_id)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"received PRIORITY_UPDATE with \"\n                \"ID=%\"PRIu64\", which is greater than the maximum Push ID \"\n                \"ever generated by this connection\", id);\n            return;\n        }\n        el = lsquic_hash_find(conn->ifc_pub.u.ietf.promises, &id, sizeof(id));\n        if (!el)\n        {\n            LSQ_DEBUG(\"push promise %\"PRIu64\" not found, ignore \"\n                                                    \"PRIORITY_UPDATE\", id);\n            return;\n        }\n        promise = lsquic_hashelem_getdata(el);\n        stream = promise->pp_pushed_stream;\n        assert(stream);\n    }\n\n    ehp = (struct lsquic_ext_http_prio) {\n        .urgency     = LSQUIC_DEF_HTTP_URGENCY,\n        .incremental = LSQUIC_DEF_HTTP_INCREMENTAL,\n    };\n    if (pfv_sz)\n    {\n        switch (lsquic_http_parse_pfv(pfv, pfv_sz, NULL, &ehp,\n                                    (char *) conn->ifc_pub.mm->acki,\n                                    sizeof(*conn->ifc_pub.mm->acki)))\n        {\n        case 0:\n            LSQ_DEBUG(\"Parsed PFV `%.*s' correctly\", (int) pfv_sz, pfv);\n            break;\n        case -2:    /* Out of memory, ignore */\n            LSQ_INFO(\"Ignore PFV `%.*s': out of memory\", (int) pfv_sz, pfv);\n            return;\n        default:\n            LSQ_INFO(\"connection error due to invalid PFV `%.*s'\",\n                                                        (int) pfv_sz, pfv);\n            /* From the draft (between versions 1 and 2):\n             \" Failure to parse the Priority Field Value MUST be treated\n             \" as a connection error of type FRAME_ENCODING_ERROR.\n             */\n            ABORT_QUIETLY(1, HEC_FRAME_ERROR, \"cannot parse Priority Field \"\n                \"Value in PRIORITY_UPDATE frame\");\n            return;\n        }\n    }\n    else\n        { /* Empty PFV means \"use defaults\" */ }\n\n    if (stream)\n        (void) lsquic_stream_set_http_prio(stream, &ehp);\n    else\n    {\n        assert(frame_type == HQFT_PRIORITY_UPDATE_STREAM);\n        if (0 == buffer_priority_update(conn, id, &ehp))\n            LSQ_INFO(\"buffered priority update for stream %\"PRIu64\"; \"\n                \"urgency: %hhu, incremental: %hhd\", id, ehp.urgency,\n                ehp.incremental);\n    }\n}\n\n\nstatic void\non_frame_error (void *ctx, unsigned code, uint64_t frame_type)\n{\n    struct ietf_full_conn *const conn = ctx;\n    if (code == HEC_MISSING_SETTINGS)\n        ABORT_QUIETLY(1, code, \"The first control frame is not SETTINGS, \"\n                     \"got frame type %\"PRIu64, frame_type);\n    else\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"Frame type %\"PRIu64\" is not \"\n            \"allowed on the control stream\", frame_type);\n}\n\n\nstatic const struct hcsi_callbacks hcsi_callbacks_server_27 =\n{\n    .on_cancel_push         = on_cancel_push_server,\n    .on_max_push_id         = on_max_push_id,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_server_27,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_server,\n};\n\nstatic const struct hcsi_callbacks hcsi_callbacks_client_27 =\n{\n    .on_cancel_push         = on_cancel_push_client,\n    .on_max_push_id         = on_max_push_id_client,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_client_27,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_client,\n};\n\n\nstatic const struct hcsi_callbacks hcsi_callbacks_server_29 =\n{\n    .on_cancel_push         = on_cancel_push_server,\n    .on_max_push_id         = on_max_push_id,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_server,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_server,\n};\n\nstatic const struct hcsi_callbacks hcsi_callbacks_client_29 =\n{\n    .on_cancel_push         = on_cancel_push_client,\n    .on_max_push_id         = on_max_push_id_client,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_client,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_client,\n};\n\n\nstatic lsquic_stream_ctx_t *\nhcsi_on_new (void *stream_if_ctx, struct lsquic_stream *stream)\n{\n    struct ietf_full_conn *const conn = (void *) stream_if_ctx;\n    const struct hcsi_callbacks *callbacks;\n\n    conn->ifc_mflags |= MF_HAVE_HCSI;\n\n    switch ((!!(conn->ifc_flags & IFC_SERVER) << 8) | conn->ifc_conn.cn_version)\n    {\n        case (0 << 8) | LSQVER_ID27:\n            callbacks = &hcsi_callbacks_client_27;\n            break;\n        case (1 << 8) | LSQVER_ID27:\n            callbacks = &hcsi_callbacks_server_27;\n            break;\n        case (0 << 8) | LSQVER_ID29:\n        case (0 << 8) | LSQVER_I001:\n        case (0 << 8) | LSQVER_I002:\n            callbacks = &hcsi_callbacks_client_29;\n            break;\n        default:\n            assert(0);\n            /* fallthru */\n        case (1 << 8) | LSQVER_ID29:\n        case (1 << 8) | LSQVER_I001:\n        case (1 << 8) | LSQVER_I002:\n            callbacks = &hcsi_callbacks_server_29;\n            break;\n    }\n    lsquic_hcsi_reader_init(&conn->ifc_hcsi.reader, &conn->ifc_conn,\n                                                            callbacks, conn);\n    lsquic_stream_wantread(stream, 1);\n    return stream_if_ctx;\n}\n\n\nstruct feed_hcsi_ctx\n{\n    struct ietf_full_conn *conn;\n    int                    s;\n};\n\n\nstatic size_t\nfeed_hcsi_reader (void *ctx, const unsigned char *buf, size_t bufsz, int fin)\n{\n    struct feed_hcsi_ctx *feed_ctx = ctx;\n    struct ietf_full_conn *conn = feed_ctx->conn;\n\n    feed_ctx->s = lsquic_hcsi_reader_feed(&conn->ifc_hcsi.reader, buf, bufsz);\n    return bufsz;\n}\n\n\nstatic void\nhcsi_on_read (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    struct ietf_full_conn *const conn = (void *) ctx;\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct feed_hcsi_ctx feed_ctx = { conn, 0, };\n    ssize_t nread;\n\n    nread = lsquic_stream_readf(stream, feed_hcsi_reader, &feed_ctx);\n    LSQ_DEBUG(\"fed %zd bytes to HTTP control stream reader, status=%d\",\n        nread, feed_ctx.s);\n    if (nread < 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        ABORT_WARN(\"error reading from HTTP control stream\");\n    }\n    else if (nread == 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        LSQ_INFO(\"control stream closed by peer: abort connection\");\n        lconn->cn_if->ci_abort_error(lconn, 1,\n            HEC_CLOSED_CRITICAL_STREAM, \"control stream closed\");\n    }\n    else if (feed_ctx.s != 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        ABORT_WARN(\"error processing HTTP control stream\");\n    }\n}\n\n\nstatic void\nhcsi_on_write (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    assert(0);\n}\n\n\nstatic void\nhcsi_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n}\n\n\nstatic const struct lsquic_stream_if hcsi_if =\n{\n    .on_new_stream  = hcsi_on_new,\n    .on_read        = hcsi_on_read,\n    .on_write       = hcsi_on_write,\n    .on_close       = hcsi_on_close,\n};\n\n\nstatic void\napply_uni_stream_class (struct ietf_full_conn *conn,\n                            struct lsquic_stream *stream, uint64_t stream_type)\n{\n    switch (stream_type)\n    {\n    case HQUST_CONTROL:\n        if (!(conn->ifc_mflags & MF_HAVE_HCSI))\n        {\n            LSQ_DEBUG(\"Incoming HTTP control stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, &hcsi_if, conn);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Attempt to create second control stream\");\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_QPACK_ENC:\n        if (!lsquic_qdh_has_enc_stream(&conn->ifc_qdh))\n        {\n            LSQ_DEBUG(\"Incoming QPACK encoder stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, lsquic_qdh_enc_sm_in_if,\n                                                            &conn->ifc_qdh);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Incoming QPACK encoder stream %\"PRIu64\" already exists: \"\n                \"cannot create second stream %\"PRIu64,\n                conn->ifc_qdh.qdh_enc_sm_in->id, stream->id);\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_QPACK_DEC:\n        if (!lsquic_qeh_has_dec_stream(&conn->ifc_qeh))\n        {\n            LSQ_DEBUG(\"Incoming QPACK decoder stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, lsquic_qeh_dec_sm_in_if,\n                                                            &conn->ifc_qeh);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Incoming QPACK decoder stream %\"PRIu64\" already exists: \"\n                \"cannot create second stream %\"PRIu64,\n                conn->ifc_qeh.qeh_dec_sm_in->id, stream->id);\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_PUSH:\n        if (conn->ifc_flags & IFC_SERVER)\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"clients can't open push streams\");\n        }\n        else\n        {\n            LSQ_DEBUG(\"Refuse push stream %\"PRIu64, stream->id);\n            maybe_schedule_ss_for_stream(conn, stream->id,\n                                                        HEC_REQUEST_CANCELLED);\n        }\n        lsquic_stream_close(stream);\n        break;\n    default:\n        LSQ_DEBUG(\"unknown unidirectional stream %\"PRIu64 \" of type %\"PRIu64\n            \", will send STOP_SENDING and close\", stream->id, stream_type);\n        /* XXX This approach may be risky, as it assumes that the peer updates\n         * its flow control window correctly.  The safe way to do it is to\n         * create a stream and wait for RESET_STREAM frame.  This is not an\n         * issue in the normal case, as the server does not allow the peer to\n         * create more than 3 unidirectional streams.\n         */\n        maybe_schedule_ss_for_stream(conn, stream->id,\n                                                    HEC_STREAM_CREATION_ERROR);\n        lsquic_stream_close(stream);\n        break;\n    }\n}\n\n\nstatic lsquic_stream_ctx_t *\nunicla_on_new (void *stream_if_ctx, struct lsquic_stream *stream)\n{\n    lsquic_stream_wantread(stream, 1);\n    stream->sm_uni_type_state.pos = 0;\n    return stream_if_ctx;\n}\n\n\nstruct unicla_ctx\n{\n    struct varint_read_state               *state;\n    enum { UC_MORE, UC_ERROR, UC_DONE, }    status;\n};\n\n\nstatic const char *const unicla_stat2str[] = {\n    [UC_ERROR] = \"UC_ERROR\", [UC_MORE] = \"UC_MORE\", [UC_DONE] = \"UC_DONE\",\n};\n\n\nstatic size_t\nunicla_readf (void *ctx, const unsigned char *begin, size_t sz, int fin)\n{\n    struct unicla_ctx *const unicla_ctx = ctx;\n    const unsigned char *buf = begin;\n    int s;\n\n    switch (unicla_ctx->status)\n    {\n    case UC_MORE:\n        s = lsquic_varint_read_nb(&buf, begin + sz, unicla_ctx->state);\n        if (s == 0)\n            unicla_ctx->status = UC_DONE;\n        else if (fin)\n            unicla_ctx->status = UC_ERROR;\n        return buf - begin;\n    case UC_DONE:\n        return 0;\n    default:\n        return sz;\n    }\n}\n\n\nstatic void\nunicla_on_read (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    struct ietf_full_conn *const conn = (void *) ctx;\n    struct unicla_ctx unicla_ctx = { .state = &stream->sm_uni_type_state,\n                                     .status = UC_MORE, };\n    ssize_t nr;\n\n    nr = lsquic_stream_readf(stream, unicla_readf, &unicla_ctx);\n    LSQ_DEBUG(\"unistream classifier read %zd byte%.*s, status: %s\", nr,\n                            nr != 1, \"s\", unicla_stat2str[unicla_ctx.status]);\n    if (nr > 0)\n    {\n        if (unicla_ctx.status == UC_DONE)\n            apply_uni_stream_class(conn, stream, unicla_ctx.state->val);\n        else if (unicla_ctx.status == UC_ERROR)\n            goto unexpected_fin;\n        /* else: do nothing */\n    }\n    else if (nr < 0) /* This should never happen */\n    {\n        LSQ_WARN(\"unicla: cannot read from stream %\"PRIu64, stream->id);\n        lsquic_stream_close(stream);\n    }\n    else\n    {\n  unexpected_fin:\n        LSQ_INFO(\"unicla: unexpected FIN while reading stream type from \"\n                                                \"stream %\"PRIu64, stream->id);\n        lsquic_stream_close(stream);\n    }\n}\n\n\nstatic void\nunicla_on_write (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    assert(0);\n}\n\n\nstatic void\nunicla_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n}\n\n\nstatic const struct lsquic_stream_if unicla_if =\n{\n    .on_new_stream  = unicla_on_new,\n    .on_read        = unicla_on_read,\n    .on_write       = unicla_on_write,\n    .on_close       = unicla_on_close,\n};\n\n\nstatic const struct lsquic_stream_if *unicla_if_ptr = &unicla_if;\n\ntypedef char dcid_elem_fits_in_128_bytes[sizeof(struct dcid_elem) <= 128 ? 1 : - 1];\n\n"], "fixing_code": ["/* Copyright (c) 2017 - 2022 LiteSpeed Technologies Inc.  See LICENSE. */\n/*\n * lsquic_full_conn_ietf.c -- IETF QUIC connection.\n */\n\n#include <assert.h>\n#include <errno.h>\n#include <inttypes.h>\n#define _USE_MATH_DEFINES   /* Need this for M_E on Windows */\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/queue.h>\n\n#include <openssl/aead.h>\n#include <openssl/rand.h>\n\n#include \"fiu-local.h\"\n\n#include \"lsquic.h\"\n#include \"lsxpack_header.h\"\n#include \"lsquic_types.h\"\n#include \"lsquic_int_types.h\"\n#include \"lsquic_attq.h\"\n#include \"lsquic_packet_common.h\"\n#include \"lsquic_packet_ietf.h\"\n#include \"lsquic_packet_in.h\"\n#include \"lsquic_packet_out.h\"\n#include \"lsquic_hash.h\"\n#include \"lsquic_conn.h\"\n#include \"lsquic_rechist.h\"\n#include \"lsquic_senhist.h\"\n#include \"lsquic_cubic.h\"\n#include \"lsquic_pacer.h\"\n#include \"lsquic_sfcw.h\"\n#include \"lsquic_conn_flow.h\"\n#include \"lsquic_varint.h\"\n#include \"lsquic_hq.h\"\n#include \"lsquic_stream.h\"\n#include \"lsquic_rtt.h\"\n#include \"lsquic_conn_public.h\"\n#include \"lsquic_bw_sampler.h\"\n#include \"lsquic_minmax.h\"\n#include \"lsquic_bbr.h\"\n#include \"lsquic_adaptive_cc.h\"\n#include \"lsquic_send_ctl.h\"\n#include \"lsquic_alarmset.h\"\n#include \"lsquic_ver_neg.h\"\n#include \"lsquic_mm.h\"\n#include \"lsquic_engine_public.h\"\n#include \"lsquic_set.h\"\n#include \"lsquic_sizes.h\"\n#include \"lsquic_trans_params.h\"\n#include \"lsquic_version.h\"\n#include \"lsquic_parse.h\"\n#include \"lsquic_util.h\"\n#include \"lsquic_enc_sess.h\"\n#include \"lsquic_ev_log.h\"\n#include \"lsquic_malo.h\"\n#include \"lsquic_frab_list.h\"\n#include \"lsquic_hcso_writer.h\"\n#include \"lsquic_hcsi_reader.h\"\n#include \"lsqpack.h\"\n#include \"lsquic_http1x_if.h\"\n#include \"lsquic_qenc_hdl.h\"\n#include \"lsquic_qdec_hdl.h\"\n#include \"lsquic_trechist.h\"\n#include \"lsquic_mini_conn_ietf.h\"\n#include \"lsquic_tokgen.h\"\n#include \"lsquic_full_conn.h\"\n#include \"lsquic_spi.h\"\n#include \"lsquic_min_heap.h\"\n#include \"lsquic_hpi.h\"\n#include \"lsquic_ietf.h\"\n#include \"lsquic_push_promise.h\"\n#include \"lsquic_headers.h\"\n#include \"lsquic_crand.h\"\n#include \"ls-sfparser.h\"\n#include \"lsquic_qpack_exp.h\"\n\n#define LSQUIC_LOGGER_MODULE LSQLM_CONN\n#define LSQUIC_LOG_CONN_ID lsquic_conn_log_cid(&conn->ifc_conn)\n#include \"lsquic_logger.h\"\n\n#define MAX_RETR_PACKETS_SINCE_LAST_ACK 2\n#define MAX_ANY_PACKETS_SINCE_LAST_ACK 20\n#define ACK_TIMEOUT                    (TP_DEF_MAX_ACK_DELAY * 1000)\n#define INITIAL_CHAL_TIMEOUT            250000\n#define HSK_PING_TIMEOUT                200000\n\n/* Retire original CID after this much time has elapsed: */\n#define RET_CID_TIMEOUT                 2000000\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n\n/* IETF QUIC push promise does not contain stream ID.  This means that, unlike\n * in GQUIC, one cannot create a stream immediately and pass it to the client.\n * We may have to add a special API for IETF push promises.  That's in the\n * future: right now, we punt it.\n */\n#define CLIENT_PUSH_SUPPORT 0\n\n\n\n/* IMPORTANT: Keep values of IFC_SERVER and IFC_HTTP same as LSENG_SERVER\n * and LSENG_HTTP.\n */\nenum ifull_conn_flags\n{\n    IFC_SERVER        = LSENG_SERVER,   /* Server mode */\n    IFC_HTTP          = LSENG_HTTP,     /* HTTP mode */\n    IFC_ACK_HAD_MISS  = 1 << 2,\n#define IFC_BIT_ERROR 3\n    IFC_ERROR         = 1 << IFC_BIT_ERROR,\n    IFC_TIMED_OUT     = 1 << 4,\n    IFC_ABORTED       = 1 << 5,\n    IFC_HSK_FAILED    = 1 << 6,\n    IFC_GOING_AWAY    = 1 << 7,\n    IFC_CLOSING       = 1 << 8,   /* Closing */\n    IFC_RECV_CLOSE    = 1 << 9,  /* Received CONNECTION_CLOSE frame */\n    IFC_TICK_CLOSE    = 1 << 10,  /* We returned TICK_CLOSE */\n    IFC_CREATED_OK    = 1 << 11,\n    IFC_HAVE_SAVED_ACK= 1 << 12,\n    IFC_ABORT_COMPLAINED\n                      = 1 << 13,\n    IFC_DCID_SET      = 1 << 14,\n#define IFCBIT_ACK_QUED_SHIFT 15\n    IFC_ACK_QUED_INIT = 1 << 15,\n    IFC_ACK_QUED_HSK  = IFC_ACK_QUED_INIT << PNS_HSK,\n    IFC_ACK_QUED_APP  = IFC_ACK_QUED_INIT << PNS_APP,\n#define IFC_ACK_QUEUED (IFC_ACK_QUED_INIT|IFC_ACK_QUED_HSK|IFC_ACK_QUED_APP)\n    IFC_HAVE_PEER_SET = 1 << 18,\n    IFC_GOT_PRST      = 1 << 19,\n    IFC_IGNORE_INIT   = 1 << 20,\n    IFC_RETRIED       = 1 << 21,\n    IFC_SWITCH_DCID   = 1 << 22, /* Perform DCID switch when a new CID becomes available */\n    IFC_GOAWAY_CLOSE  = 1 << 23,\n    IFC_FIRST_TICK    = 1 << 24,\n    IFC_IGNORE_HSK    = 1 << 25,\n    IFC_PROC_CRYPTO   = 1 << 26,\n    IFC_MIGRA         = 1 << 27,\n    IFC_HTTP_INITED   = 1 << 28, /* HTTP initialized */\n    IFC_DELAYED_ACKS  = 1 << 29, /* Delayed ACKs are enabled */\n    IFC_TIMESTAMPS    = 1 << 30, /* Timestamps are enabled */\n    IFC_DATAGRAMS     = 1u<< 31, /* Datagrams are enabled */\n};\n\n\nenum more_flags\n{\n    MF_VALIDATE_PATH    = 1 << 0,\n    MF_NOPROG_TIMEOUT   = 1 << 1,\n    MF_CHECK_MTU_PROBE  = 1 << 2,\n    MF_IGNORE_MISSING   = 1 << 3,\n    MF_CONN_CLOSE_PACK  = 1 << 4,   /* CONNECTION_CLOSE has been packetized */\n    MF_SEND_WRONG_COUNTS= 1 << 5,   /* Send wrong ECN counts to peer */\n    MF_WANT_DATAGRAM_WRITE  = 1 << 6,\n    MF_DOING_0RTT       = 1 << 7,\n    MF_HAVE_HCSI        = 1 << 8,   /* Have HTTP Control Stream Incoming */\n};\n\n\n#define N_PATHS 4\n\nenum send\n{\n    /* PATH_CHALLENGE and PATH_RESPONSE frames are not retransmittable.  They\n     * are positioned first in the enum to optimize packetization.\n     */\n    SEND_PATH_CHAL,\n    SEND_PATH_CHAL_PATH_0 = SEND_PATH_CHAL + 0,\n    SEND_PATH_CHAL_PATH_1 = SEND_PATH_CHAL + 1,\n    SEND_PATH_CHAL_PATH_2 = SEND_PATH_CHAL + 2,\n    SEND_PATH_CHAL_PATH_3 = SEND_PATH_CHAL + 3,\n    SEND_PATH_RESP,\n    SEND_PATH_RESP_PATH_0 = SEND_PATH_RESP + 0,\n    SEND_PATH_RESP_PATH_1 = SEND_PATH_RESP + 1,\n    SEND_PATH_RESP_PATH_2 = SEND_PATH_RESP + 2,\n    SEND_PATH_RESP_PATH_3 = SEND_PATH_RESP + 3,\n    SEND_MAX_DATA,\n    SEND_PING,\n    SEND_NEW_CID,\n    SEND_RETIRE_CID,\n    SEND_CONN_CLOSE,\n    SEND_STREAMS_BLOCKED,\n    SEND_STREAMS_BLOCKED_BIDI = SEND_STREAMS_BLOCKED + SD_BIDI,\n    SEND_STREAMS_BLOCKED_UNI = SEND_STREAMS_BLOCKED + SD_UNI,\n    SEND_MAX_STREAMS,\n    SEND_MAX_STREAMS_BIDI = SEND_MAX_STREAMS + SD_BIDI,\n    SEND_MAX_STREAMS_UNI = SEND_MAX_STREAMS + SD_UNI,\n    SEND_STOP_SENDING,\n    SEND_NEW_TOKEN,\n    SEND_HANDSHAKE_DONE,\n    SEND_ACK_FREQUENCY,\n    N_SEND\n};\n\nenum send_flags\n{\n    SF_SEND_MAX_DATA                = 1 << SEND_MAX_DATA,\n    SF_SEND_PING                    = 1 << SEND_PING,\n    SF_SEND_PATH_CHAL               = 1 << SEND_PATH_CHAL,\n    SF_SEND_PATH_CHAL_PATH_0        = 1 << SEND_PATH_CHAL_PATH_0,\n    SF_SEND_PATH_CHAL_PATH_1        = 1 << SEND_PATH_CHAL_PATH_1,\n    SF_SEND_PATH_CHAL_PATH_2        = 1 << SEND_PATH_CHAL_PATH_2,\n    SF_SEND_PATH_CHAL_PATH_3        = 1 << SEND_PATH_CHAL_PATH_3,\n    SF_SEND_PATH_RESP               = 1 << SEND_PATH_RESP,\n    SF_SEND_PATH_RESP_PATH_0        = 1 << SEND_PATH_RESP_PATH_0,\n    SF_SEND_PATH_RESP_PATH_1        = 1 << SEND_PATH_RESP_PATH_1,\n    SF_SEND_PATH_RESP_PATH_2        = 1 << SEND_PATH_RESP_PATH_2,\n    SF_SEND_PATH_RESP_PATH_3        = 1 << SEND_PATH_RESP_PATH_3,\n    SF_SEND_NEW_CID                 = 1 << SEND_NEW_CID,\n    SF_SEND_RETIRE_CID              = 1 << SEND_RETIRE_CID,\n    SF_SEND_CONN_CLOSE              = 1 << SEND_CONN_CLOSE,\n    SF_SEND_STREAMS_BLOCKED         = 1 << SEND_STREAMS_BLOCKED,\n    SF_SEND_STREAMS_BLOCKED_BIDI    = 1 << SEND_STREAMS_BLOCKED_BIDI,\n    SF_SEND_STREAMS_BLOCKED_UNI     = 1 << SEND_STREAMS_BLOCKED_UNI,\n    SF_SEND_MAX_STREAMS             = 1 << SEND_MAX_STREAMS,\n    SF_SEND_MAX_STREAMS_BIDI        = 1 << SEND_MAX_STREAMS_BIDI,\n    SF_SEND_MAX_STREAMS_UNI         = 1 << SEND_MAX_STREAMS_UNI,\n    SF_SEND_STOP_SENDING            = 1 << SEND_STOP_SENDING,\n    SF_SEND_NEW_TOKEN               = 1 << SEND_NEW_TOKEN,\n    SF_SEND_HANDSHAKE_DONE          = 1 << SEND_HANDSHAKE_DONE,\n    SF_SEND_ACK_FREQUENCY           = 1 << SEND_ACK_FREQUENCY,\n};\n\n#define SF_SEND_PATH_CHAL_ALL \\\n            (((SF_SEND_PATH_CHAL << N_PATHS) - 1) & ~(SF_SEND_PATH_CHAL - 1))\n\n#define IFC_IMMEDIATE_CLOSE_FLAGS \\\n            (IFC_TIMED_OUT|IFC_ERROR|IFC_ABORTED|IFC_HSK_FAILED|IFC_GOT_PRST)\n\n#define MAX_ERRMSG 256\n\n#define MAX_SCID 8\n\n#define SET_ERRMSG(conn, ...) do {                                          \\\n    if (!(conn)->ifc_errmsg)                                                \\\n    {                                                                       \\\n        (conn)->ifc_errmsg = malloc(MAX_ERRMSG);                            \\\n        if ((conn)->ifc_errmsg)                                             \\\n            snprintf((conn)->ifc_errmsg, MAX_ERRMSG, __VA_ARGS__);          \\\n    }                                                                       \\\n} while (0)\n\n#define ABORT_WITH_FLAG(conn, log_level, flag, ...) do {                    \\\n    SET_ERRMSG(conn, __VA_ARGS__);                                          \\\n    if (!((conn)->ifc_flags & IFC_ABORT_COMPLAINED))                        \\\n        LSQ_LOG(log_level, \"Abort connection: \" __VA_ARGS__);               \\\n    (conn)->ifc_flags |= flag|IFC_ABORT_COMPLAINED;                         \\\n} while (0)\n\n#define ABORT_ERROR(...) \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_ERROR, IFC_ERROR, __VA_ARGS__)\n#define ABORT_WARN(...) \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_WARN, IFC_ERROR, __VA_ARGS__)\n\n#define CONN_ERR(app_error_, code_) (struct conn_err) { \\\n                            .app_error = (app_error_), .u.err = (code_), }\n\n/* Use this for protocol errors; they do not need to be as loud as our own\n * internal errors.\n */\n#define ABORT_QUIETLY(app_error, code, ...) do {                            \\\n    conn->ifc_error = CONN_ERR(app_error, code);                            \\\n    ABORT_WITH_FLAG(conn, LSQ_LOG_INFO, IFC_ERROR, __VA_ARGS__);            \\\n} while (0)\n\n\nstatic enum stream_id_type\ngen_sit (unsigned server, enum stream_dir sd)\n{\n    return (server > 0) | ((sd > 0) << SD_SHIFT);\n}\n\n\nstruct stream_id_to_ss\n{\n    STAILQ_ENTRY(stream_id_to_ss)   sits_next;\n    lsquic_stream_id_t              sits_stream_id;\n    enum http_error_code            sits_error_code;\n};\n\nstruct http_ctl_stream_in\n{\n    struct hcsi_reader  reader;\n};\n\nstruct conn_err\n{\n    int                         app_error;\n    union\n    {\n        enum trans_error_code   tec;\n        enum http_error_code    hec;\n        unsigned                err;\n    }                           u;\n};\n\n\nstruct dplpmtud_state\n{\n    lsquic_packno_t     ds_probe_packno;\n#ifndef NDEBUG\n    lsquic_time_t       ds_probe_sent;\n#endif\n    enum {\n        DS_PROBE_SENT   = 1 << 0,\n    }                   ds_flags;\n    unsigned short      ds_probed_size,\n                        ds_failed_size; /* If non-zero, defines ceiling */\n    unsigned char       ds_probe_count;\n};\n\n\nstruct conn_path\n{\n    struct network_path         cop_path;\n    uint64_t                    cop_path_chals[8];  /* Arbitrary number */\n    uint64_t                    cop_inc_chal;       /* Incoming challenge */\n    lsquic_packno_t             cop_max_packno;\n    enum {\n        /* Initialized covers cop_path.np_pack_size and cop_path.np_dcid */\n        COP_INITIALIZED = 1 << 0,\n        /* This flag is set when we received a response to one of path\n         * challenges we sent on this path.\n         */\n        COP_VALIDATED   = 1 << 1,\n        /* Received non-probing frames.  This flag is not set for the\n         * original path.\n         */\n        COP_GOT_NONPROB = 1 << 2,\n        /* Spin bit is enabled on this path. */\n        COP_SPIN_BIT    = 1 << 3,\n        /* Allow padding packet to 1200 bytes */\n        COP_ALLOW_MTU_PADDING = 1 << 4,\n        /* Verified that the path MTU is at least 1200 bytes */\n        COP_VALIDATED_MTU = 1 << 5,\n    }                           cop_flags;\n    unsigned char               cop_n_chals;\n    unsigned char               cop_cce_idx;\n    unsigned char               cop_spin_bit;\n    struct dplpmtud_state       cop_dplpmtud;\n};\n\n\nstruct packet_tolerance_stats\n{\n    unsigned        n_acks;     /* Number of ACKs between probes */\n    float           integral_error;\n    lsquic_time_t   last_sample;\n};\n\n\nunion prio_iter\n{\n    struct stream_prio_iter spi;\n    struct http_prio_iter   hpi;\n};\n\n\nstruct prio_iter_if\n{\n    void (*pii_init) (void *, struct lsquic_stream *first,\n             struct lsquic_stream *last, uintptr_t next_ptr_offset,\n             struct lsquic_conn_public *, const char *name,\n             int (*filter)(void *filter_ctx, struct lsquic_stream *),\n             void *filter_ctx);\n\n    struct lsquic_stream * (*pii_first) (void *);\n\n    struct lsquic_stream * (*pii_next) (void *);\n\n    void (*pii_drop_non_high) (void *);\n\n    void (*pii_drop_high) (void *);\n\n    void (*pii_cleanup) (void *);\n};\n\n\nstatic const struct prio_iter_if orig_prio_iter_if = {\n    lsquic_spi_init,\n    lsquic_spi_first,\n    lsquic_spi_next,\n    lsquic_spi_drop_non_high,\n    lsquic_spi_drop_high,\n    lsquic_spi_cleanup,\n};\n\n\nstatic const struct prio_iter_if ext_prio_iter_if = {\n    lsquic_hpi_init,\n    lsquic_hpi_first,\n    lsquic_hpi_next,\n    lsquic_hpi_drop_non_high,\n    lsquic_hpi_drop_high,\n    lsquic_hpi_cleanup,\n};\n\n\nstruct ietf_full_conn\n{\n    struct lsquic_conn          ifc_conn;\n    struct conn_cid_elem        ifc_cces[MAX_SCID];\n    struct lsquic_rechist       ifc_rechist[N_PNS];\n    /* App PNS only, used to calculate was_missing: */\n    lsquic_packno_t             ifc_max_ackable_packno_in;\n    struct lsquic_send_ctl      ifc_send_ctl;\n    struct lsquic_conn_public   ifc_pub;\n    lsquic_alarmset_t           ifc_alset;\n    struct lsquic_set64         ifc_closed_stream_ids[N_SITS];\n    lsquic_stream_id_t          ifc_n_created_streams[N_SDS];\n    /* Not including the value stored in ifc_max_allowed_stream_id: */\n    lsquic_stream_id_t          ifc_max_allowed_stream_id[N_SITS];\n    uint64_t                    ifc_closed_peer_streams[N_SDS];\n    /* Maximum number of open stream initiated by peer: */\n    unsigned                    ifc_max_streams_in[N_SDS];\n    uint64_t                    ifc_max_stream_data_uni;\n    enum ifull_conn_flags       ifc_flags;\n    enum more_flags             ifc_mflags;\n    enum send_flags             ifc_send_flags;\n    enum send_flags             ifc_delayed_send;\n    struct {\n        uint64_t    streams_blocked[N_SDS];\n    }                           ifc_send;\n    struct conn_err             ifc_error;\n    unsigned                    ifc_n_delayed_streams;\n    unsigned                    ifc_n_cons_unretx;\n    const struct prio_iter_if  *ifc_pii;\n    char                       *ifc_errmsg;\n    struct lsquic_engine_public\n                               *ifc_enpub;\n    const struct lsquic_engine_settings\n                               *ifc_settings;\n    STAILQ_HEAD(, stream_id_to_ss)\n                                ifc_stream_ids_to_ss;\n    lsquic_time_t               ifc_created;\n    lsquic_time_t               ifc_saved_ack_received;\n    lsquic_packno_t             ifc_max_ack_packno[N_PNS];\n    lsquic_packno_t             ifc_max_non_probing;\n    struct {\n        uint64_t    max_stream_send;\n        uint8_t     ack_exp;\n    }                           ifc_cfg;\n    int                       (*ifc_process_incoming_packet)(\n                                                struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n    /* Number ackable packets received since last ACK was sent: */\n    unsigned                    ifc_n_slack_akbl[N_PNS];\n    unsigned                    ifc_n_slack_all;    /* App PNS only */\n    unsigned                    ifc_max_retx_since_last_ack;\n    lsquic_time_t               ifc_max_ack_delay;\n    uint64_t                    ifc_ecn_counts_in[N_PNS][4];\n    lsquic_stream_id_t          ifc_max_req_id;\n    struct hcso_writer          ifc_hcso;\n    struct http_ctl_stream_in   ifc_hcsi;\n    struct qpack_enc_hdl        ifc_qeh;\n    struct qpack_dec_hdl        ifc_qdh;\n    struct {\n        uint64_t    header_table_size,\n                    qpack_blocked_streams;\n    }                           ifc_peer_hq_settings;\n    struct dcid_elem           *ifc_dces[MAX_IETF_CONN_DCIDS];\n    TAILQ_HEAD(, dcid_elem)     ifc_to_retire;\n    unsigned                    ifc_scid_seqno;\n    lsquic_time_t               ifc_scid_timestamp[MAX_SCID];\n    /* Last 8 packets had ECN markings? */\n    uint8_t                     ifc_incoming_ecn;\n    unsigned char               ifc_cur_path_id;    /* Indexes ifc_paths */\n    unsigned char               ifc_used_paths;     /* Bitmask */\n    unsigned char               ifc_mig_path_id;\n    /* ifc_active_cids_limit is the maximum number of CIDs at any one time this\n     * endpoint is allowed to issue to peer.  If the TP value exceeds cn_n_cces,\n     * it is reduced to it.  ifc_active_cids_count tracks how many CIDs have\n     * been issued.  It is decremented each time a CID is retired.\n     */\n    unsigned char               ifc_active_cids_limit;\n    unsigned char               ifc_active_cids_count;\n    unsigned char               ifc_first_active_cid_seqno;\n    unsigned char               ifc_ping_unretx_thresh;\n    unsigned                    ifc_last_retire_prior_to;\n    unsigned                    ifc_ack_freq_seqno;\n    unsigned                    ifc_last_pack_tol;\n    unsigned                    ifc_last_calc_pack_tol;\n#if LSQUIC_CONN_STATS\n    unsigned                    ifc_min_pack_tol_sent;\n    unsigned                    ifc_max_pack_tol_sent;\n#endif\n    unsigned                    ifc_max_ack_freq_seqno; /* Incoming */\n    unsigned short              ifc_max_udp_payload;    /* Cached TP */\n    lsquic_time_t               ifc_last_live_update;\n    struct conn_path            ifc_paths[N_PATHS];\n    union {\n        struct {\n            struct lsquic_stream   *crypto_streams[N_ENC_LEVS];\n            struct ver_neg\n                        ifcli_ver_neg;\n            uint64_t    ifcli_max_push_id;\n            uint64_t    ifcli_min_goaway_stream_id;\n            enum {\n                IFCLI_PUSH_ENABLED    = 1 << 0,\n                IFCLI_HSK_SENT_OR_DEL = 1 << 1,\n            }           ifcli_flags;\n            unsigned    ifcli_packets_out;\n        }                           cli;\n        struct {\n            uint64_t    ifser_max_push_id;\n            uint64_t    ifser_next_push_id;\n            enum {\n                IFSER_PUSH_ENABLED    = 1 << 0,\n                IFSER_MAX_PUSH_ID     = 1 << 1,   /* ifser_max_push_id is set */\n            }           ifser_flags;\n        }                           ser;\n    }                           ifc_u;\n    lsquic_time_t               ifc_idle_to;\n    lsquic_time_t               ifc_ping_period;\n    struct lsquic_hash         *ifc_bpus;\n    uint64_t                    ifc_last_max_data_off_sent;\n    unsigned short              ifc_min_dg_sz,\n                                ifc_max_dg_sz;\n    struct packet_tolerance_stats\n                                ifc_pts;\n#if LSQUIC_CONN_STATS\n    struct conn_stats           ifc_stats,\n                               *ifc_last_stats;\n#endif\n    struct ack_info             ifc_ack;\n};\n\n#define CUR_CPATH(conn_) (&(conn_)->ifc_paths[(conn_)->ifc_cur_path_id])\n#define CUR_NPATH(conn_) (&(CUR_CPATH(conn_)->cop_path))\n#define CUR_DCID(conn_) (&(CUR_NPATH(conn_)->np_dcid))\n\n#define DCES_END(conn_) ((conn_)->ifc_dces + (sizeof((conn_)->ifc_dces) \\\n                                            / sizeof((conn_)->ifc_dces[0])))\n\n#define NPATH2CPATH(npath_) ((struct conn_path *) \\\n            ((char *) (npath_) - offsetof(struct conn_path, cop_path)))\n\n#if LSQUIC_CONN_STATS\n#define CONN_STATS(what_, count_) do {                                  \\\n    conn->ifc_stats.what_ += (count_);                                  \\\n} while (0)\n#else\n#define CONN_STATS(what_, count_)\n#endif\n\nstatic const struct ver_neg server_ver_neg;\n\nstatic const struct conn_iface *ietf_full_conn_iface_ptr;\nstatic const struct conn_iface *ietf_full_conn_prehsk_iface_ptr;\n\nstatic int\nprocess_incoming_packet_verneg (struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n\nstatic int\nprocess_incoming_packet_fast (struct ietf_full_conn *,\n                                                struct lsquic_packet_in *);\n\nstatic void\nietf_full_conn_ci_packet_in (struct lsquic_conn *, struct lsquic_packet_in *);\n\nstatic int\nhandshake_ok (struct lsquic_conn *);\n\nstatic void\nignore_init (struct ietf_full_conn *);\n\nstatic void\nignore_hsk (struct ietf_full_conn *);\n\nstatic unsigned\nietf_full_conn_ci_n_avail_streams (const struct lsquic_conn *);\n\nstatic void\nietf_full_conn_ci_destroy (struct lsquic_conn *);\n\nstatic int\ninsert_new_dcid (struct ietf_full_conn *, uint64_t seqno,\n    const lsquic_cid_t *, const unsigned char *token, int update_cur_dcid);\n\nstatic struct conn_cid_elem *\nfind_cce_by_cid (struct ietf_full_conn *, const lsquic_cid_t *);\n\nstatic void\nmtu_probe_too_large (struct ietf_full_conn *, const struct lsquic_packet_out *);\n\nstatic int\napply_trans_params (struct ietf_full_conn *, const struct transport_params *);\n\nstatic void\npacket_tolerance_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now);\n\nstatic int\ninit_http (struct ietf_full_conn *);\n\nstatic unsigned\nhighest_bit_set (unsigned sz)\n{\n#if __GNUC__\n    unsigned clz = __builtin_clz(sz);\n    return 31 - clz;\n#else\n    unsigned n, y;\n    n = 32;\n    y = sz >> 16;   if (y) { n -= 16; sz = y; }\n    y = sz >>  8;   if (y) { n -=  8; sz = y; }\n    y = sz >>  4;   if (y) { n -=  4; sz = y; }\n    y = sz >>  2;   if (y) { n -=  2; sz = y; }\n    y = sz >>  1;   if (y) return 31 - n + 2;\n    return 31 - n + sz;\n#endif\n}\n\n\nstatic void\nset_versions (struct ietf_full_conn *conn, unsigned versions,\n                                                    enum lsquic_version *ver)\n{\n    conn->ifc_u.cli.ifcli_ver_neg.vn_supp = versions;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_ver  = (ver) ? *ver : highest_bit_set(versions);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_buf  = lsquic_ver2tag(conn->ifc_u.cli.ifcli_ver_neg.vn_ver);\n    conn->ifc_conn.cn_version = conn->ifc_u.cli.ifcli_ver_neg.vn_ver;\n}\n\n\nstatic void\ninit_ver_neg (struct ietf_full_conn *conn, unsigned versions,\n                                                    enum lsquic_version *ver)\n{\n    set_versions(conn, versions, ver);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_tag   = &conn->ifc_u.cli.ifcli_ver_neg.vn_buf;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_START;\n}\n\n\nstatic void\nack_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                        lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = ctx;\n    assert(al_id == AL_ACK_APP);\n    LSQ_DEBUG(\"%s ACK timer expired (%\"PRIu64\" < %\"PRIu64\"): ACK queued\",\n        lsquic_pns2str[PNS_APP], expiry, now);\n    conn->ifc_flags |= IFC_ACK_QUED_APP;\n}\n\n\nstatic void\nidle_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n\n    if ((conn->ifc_mflags & MF_NOPROG_TIMEOUT)\n        && conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout < now)\n    {\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"connection timed out due to \"\n                                                            \"lack of progress\");\n        /* Different flag so that CONNECTION_CLOSE frame is sent */\n        ABORT_QUIETLY(0, TEC_APPLICATION_ERROR,\n                                \"connection timed out due to lack of progress\");\n    }\n    else\n    {\n        LSQ_DEBUG(\"connection timed out\");\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"connection timed out\");\n        conn->ifc_flags |= IFC_TIMED_OUT;\n    }\n}\n\n\nstatic void\nhandshake_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"connection timed out: handshake timed out\");\n    conn->ifc_flags |= IFC_TIMED_OUT;\n}\n\n\n/*\n * When this alarm expires, at least one SCID slot shoud be available\n * for generation.\n */\nstatic void\ncid_throt_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"%s\", __func__);\n    conn->ifc_send_flags |= SF_SEND_NEW_CID;\n    return;\n}\n\n\nstatic void\nwipe_path (struct ietf_full_conn *conn, unsigned path_id)\n{\n    void *peer_ctx = conn->ifc_paths[path_id].cop_path.np_peer_ctx;\n    memset(&conn->ifc_paths[path_id], 0, sizeof(conn->ifc_paths[0]));\n    conn->ifc_paths[path_id].cop_path.np_path_id = path_id;\n    conn->ifc_paths[path_id].cop_path.np_peer_ctx = peer_ctx;\n    conn->ifc_used_paths &= ~(1 << path_id);\n}\n\n\nstatic void\npath_chal_alarm_expired (enum alarm_id al_id, void *ctx,\n                                lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    const unsigned path_id = al_id - AL_PATH_CHAL;\n    struct conn_path *const copath = &conn->ifc_paths[path_id];\n\n    if (copath->cop_n_chals < sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]))\n    {\n        LSQ_DEBUG(\"path #%u challenge expired, schedule another one\", path_id);\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL << path_id;\n    }\n    else if (conn->ifc_cur_path_id != path_id)\n    {\n        LSQ_INFO(\"migration to path #%u failed after none of %u path \"\n            \"challenges received responses\", path_id, copath->cop_n_chals);\n        /* There may be a lingering challenge if its generation is delayed */\n        lsquic_send_ctl_cancel_path_verification(&conn->ifc_send_ctl,\n                                                        &copath->cop_path);\n        wipe_path(conn, path_id);\n    }\n    else\n        LSQ_INFO(\"no path challenge responses on current path %u, stop \"\n            \"sending path challenges\", path_id);\n}\n\n\n/* Sending DATA_BLOCKED and STREAM_DATA_BLOCKED frames is a way to elicit\n * incoming packets from peer when it is too slow to read data.  This is\n * recommended by [draft-ietf-quic-transport-25] Section 4.1.\n *\n * If we are still in the blocked state, we schedule a blocked frame to\n * be sent.\n */\nstatic void\nblocked_ka_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    int has_send_flag;\n\n    if (lsquic_conn_cap_avail(&conn->ifc_pub.conn_cap) == 0)\n    {\n        LSQ_DEBUG(\"set SEND_BLOCKED flag on connection\");\n        conn->ifc_conn.cn_flags |= LSCONN_SEND_BLOCKED;\n        return;\n    }\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                         el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (lsquic_stream_is_blocked(stream))\n        {\n            has_send_flag = (stream->sm_qflags & SMQF_SENDING_FLAGS);\n            stream->sm_qflags |= SMQF_SEND_BLOCKED;\n            LSQ_DEBUG(\"set SEND_BLOCKED flag on stream %\"PRIu64, stream->id);\n            if (!lsquic_sendctl_gen_stream_blocked_frame(\n                        stream->conn_pub->send_ctl, stream))\n            {\n                LSQ_DEBUG(\"failed to send STREAM_BLOCKED frame for\"\n                        \" stream %\"PRIu64 \" immedately, postpone.\", stream->id);\n                if (!has_send_flag)\n                    TAILQ_INSERT_TAIL(&conn->ifc_pub.sending_streams, stream,\n                                                            next_send_stream);\n            }\n        }\n    }\n}\n\n\nstatic void\nmtu_probe_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n\n    LSQ_DEBUG(\"MTU probe alarm expired: set `check MTU probe' flag\");\n    assert(!(conn->ifc_mflags & MF_CHECK_MTU_PROBE));\n    conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n}\n\n\nstatic int\nmigra_is_on (const struct ietf_full_conn *conn, unsigned path_id)\n{\n    return (conn->ifc_send_flags & (SF_SEND_PATH_CHAL << path_id))\n        || lsquic_alarmset_is_set(&conn->ifc_alset, AL_PATH_CHAL + path_id);\n}\n\n\n#define TRANSPORT_OVERHEAD(is_ipv6) (((is_ipv6) ? 40 : 20) + 8 /* UDP */)\n\nstatic unsigned short\ncalc_base_packet_size (const struct ietf_full_conn *conn, int is_ipv6)\n{\n    unsigned short size;\n\n    if (conn->ifc_settings->es_base_plpmtu)\n        size = conn->ifc_settings->es_base_plpmtu;\n    else if (is_ipv6)\n        size = IQUIC_MAX_IPv6_PACKET_SZ;\n    else\n        size = IQUIC_MAX_IPv4_PACKET_SZ;\n\n    return size;\n}\n\n\nstatic void\nmigra_begin (struct ietf_full_conn *conn, struct conn_path *copath,\n                struct dcid_elem *dce, const struct sockaddr *dest_sa,\n                const struct transport_params *params)\n{\n    assert(!(migra_is_on(conn, copath - conn->ifc_paths)));\n\n    dce->de_flags |= DE_ASSIGNED;\n    copath->cop_flags |= COP_INITIALIZED;\n    copath->cop_path.np_dcid = dce->de_cid;\n    copath->cop_path.np_peer_ctx = CUR_NPATH(conn)->np_peer_ctx;\n    copath->cop_path.np_pack_size\n                = calc_base_packet_size(conn, NP_IS_IPv6(CUR_NPATH(conn)));\n    if (conn->ifc_max_udp_payload < copath->cop_path.np_pack_size)\n        copath->cop_path.np_pack_size = conn->ifc_max_udp_payload;\n    memcpy(&copath->cop_path.np_local_addr, NP_LOCAL_SA(CUR_NPATH(conn)),\n                                    sizeof(copath->cop_path.np_local_addr));\n    memcpy(&copath->cop_path.np_peer_addr, dest_sa,\n                                    sizeof(copath->cop_path.np_peer_addr));\n\n    conn->ifc_mig_path_id = copath - conn->ifc_paths;\n    conn->ifc_used_paths |= 1 << conn->ifc_mig_path_id;\n    conn->ifc_send_flags |= SF_SEND_PATH_CHAL << conn->ifc_mig_path_id;\n    LSQ_DEBUG(\"Schedule migration to path %hhu: will send PATH_CHALLENGE\",\n        conn->ifc_mig_path_id);\n}\n\n\nstatic void\nping_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    LSQ_DEBUG(\"Ping alarm rang: schedule PING frame to be generated\");\n    conn->ifc_send_flags |= SF_SEND_PING;\n}\n\n\nstatic void\nretire_cid (struct ietf_full_conn *, struct conn_cid_elem *, lsquic_time_t);\n\n\nstatic void\nlog_scids (const struct ietf_full_conn *conn)\n{\n    const struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct conn_cid_elem *cce;\n    char flags[5];\n    unsigned idx;\n    int fi;\n\n    LSQ_DEBUG(\"Log SCID array: (n_cces %hhu; mask: 0x%hhX; \"\n                                        \"active: %hhu; limit: %hhu)\",\n        conn->ifc_conn.cn_n_cces, conn->ifc_conn.cn_cces_mask,\n        conn->ifc_active_cids_count, conn->ifc_active_cids_limit);\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        idx = cce - lconn->cn_cces;\n        fi = 0;\n        if (cce->cce_flags & CCE_PORT)  flags[fi++] = 'p';\n        if (cce->cce_flags & CCE_REG)   flags[fi++] = 'r';\n        if (cce->cce_flags & CCE_SEQNO) flags[fi++] = 's';\n        if (cce->cce_flags & CCE_USED)  flags[fi++] = 'u';\n        flags[fi]                                   = '\\0';\n        if (lconn->cn_cces_mask & (1 << idx))\n        {\n            if (cce->cce_flags & CCE_PORT)\n                LSQ_DEBUG( \"  %u: flags %-4s; port %hu\", idx, flags,\n                                                            cce->cce_port);\n            else if (cce->cce_flags & CCE_SEQNO)\n                LSQ_DEBUGC(\"  %u: flags %-4s; seqno: %u; %\"CID_FMT, idx,\n                            flags, cce->cce_seqno, CID_BITS(&cce->cce_cid));\n            else\n                LSQ_DEBUGC(\"  %u: flags %-4s; %\"CID_FMT, idx, flags,\n                                                    CID_BITS(&cce->cce_cid));\n        }\n        else\n                LSQ_DEBUG( \"  %u: flags %-4s; <empty>\",  idx, flags);\n    }\n}\n\n\n#define LOG_SCIDS(conn_) do {                                               \\\n    if (LSQ_LOG_ENABLED(LSQ_LOG_DEBUG))                                     \\\n        log_scids(conn_);                                                   \\\n} while (0)\n\n\nstatic void\nret_cids_alarm_expired (enum alarm_id al_id, void *ctx, lsquic_time_t expiry,\n                                                            lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) ctx;\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n    unsigned idx;\n\n    LSQ_DEBUG(\"The 'retire original CIDs' alarm rang\");\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        idx = cce - lconn->cn_cces;\n        if ((lconn->cn_cces_mask & (1 << idx))\n                            && (cce->cce_flags & (CCE_SEQNO|CCE_PORT)) == 0)\n        {\n            LSQ_DEBUG(\"retiring original CID at index %u\", idx);\n            retire_cid(conn, cce, now);\n        }\n    }\n    LOG_SCIDS(conn);\n}\n\n\nstatic ssize_t\ncrypto_stream_write (void *stream, const void *buf, size_t len)\n{\n    return lsquic_stream_write(stream, buf, len);\n}\n\n\nstatic int\ncrypto_stream_flush (void *stream)\n{\n    return lsquic_stream_flush(stream);\n}\n\n\nstatic ssize_t\ncrypto_stream_readf (void *stream,\n        size_t (*readf)(void *, const unsigned char *, size_t, int), void *ctx)\n{\n    return lsquic_stream_readf(stream, readf, ctx);\n}\n\n\nstatic int\ncrypto_stream_wantwrite (void *stream, int is_want)\n{\n    return lsquic_stream_wantwrite(stream, is_want);\n}\n\n\nstatic int\ncrypto_stream_wantread (void *stream, int is_want)\n{\n    return lsquic_stream_wantread(stream, is_want);\n}\n\n\nstatic enum enc_level\ncrypto_stream_enc_level (void *streamp)\n{\n    const struct lsquic_stream *stream = streamp;\n    return crypto_level(stream);\n}\n\n\nstatic const struct crypto_stream_if crypto_stream_if =\n{\n    .csi_write      = crypto_stream_write,\n    .csi_flush      = crypto_stream_flush,\n    .csi_readf      = crypto_stream_readf,\n    .csi_wantwrite  = crypto_stream_wantwrite,\n    .csi_wantread   = crypto_stream_wantread,\n    .csi_enc_level  = crypto_stream_enc_level,\n};\n\n\nstatic const struct lsquic_stream_if *unicla_if_ptr;\n\n\nstatic lsquic_stream_id_t\ngenerate_stream_id (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    lsquic_stream_id_t id;\n\n    id = conn->ifc_n_created_streams[sd]++;\n    return id << SIT_SHIFT\n         | sd << SD_SHIFT\n         | !!(conn->ifc_flags & IFC_SERVER)\n        ;\n}\n\n\nstatic lsquic_stream_id_t\navail_streams_count (const struct ietf_full_conn *conn, int server,\n                                                            enum stream_dir sd)\n{\n    enum stream_id_type sit;\n    lsquic_stream_id_t max_count;\n\n    sit = gen_sit(server, sd);\n    max_count = conn->ifc_max_allowed_stream_id[sit] >> SIT_SHIFT;\n    LSQ_DEBUG(\"sit-%u streams: max count: %\"PRIu64\"; created streams: %\"PRIu64,\n        sit, max_count, conn->ifc_n_created_streams[sd]);\n    if (max_count >= conn->ifc_n_created_streams[sd])\n        return max_count - conn->ifc_n_created_streams[sd];\n    else\n    {\n        assert(0);\n        return 0;\n    }\n}\n\n\n/* If `priority' is negative, this means that the stream is critical */\nstatic int\ncreate_uni_stream_out (struct ietf_full_conn *conn, int priority,\n        const struct lsquic_stream_if *stream_if, void *stream_if_ctx)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n\n    stream_id = generate_stream_id(conn, SD_UNI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub, stream_if,\n                stream_if_ctx, 0, conn->ifc_max_stream_data_uni,\n                SCF_IETF | (priority < 0 ? SCF_CRITICAL : 0));\n    if (!stream)\n        return -1;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return -1;\n    }\n    if (priority >= 0)\n        lsquic_stream_set_priority_internal(stream, priority);\n    else\n        ++conn->ifc_pub.n_special_streams;\n    lsquic_stream_call_on_new(stream);\n    return 0;\n}\n\n\nstatic int\ncreate_ctl_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_hcso_writer_if, &conn->ifc_hcso);\n}\n\n\nstatic int\ncreate_qenc_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_qeh_enc_sm_out_if, &conn->ifc_qeh);\n}\n\n\nstatic int\ncreate_qdec_stream_out (struct ietf_full_conn *conn)\n{\n    return create_uni_stream_out(conn, -1,\n                                    lsquic_qdh_dec_sm_out_if, &conn->ifc_qdh);\n}\n\n\nstatic int\ncreate_bidi_stream_out (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    enum stream_ctor_flags flags;\n\n    flags = SCF_IETF|SCF_DI_AUTOSWITCH;\n    if (conn->ifc_enpub->enp_settings.es_rw_once)\n        flags |= SCF_DISP_RW_ONCE;\n    if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n        flags |= SCF_DELAY_ONCLOSE;\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        flags |= SCF_HTTP;\n        if (conn->ifc_pii == &ext_prio_iter_if)\n            flags |= SCF_HTTP_PRIO;\n    }\n\n    stream_id = generate_stream_id(conn, SD_BIDI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                conn->ifc_enpub->enp_stream_if,\n                conn->ifc_enpub->enp_stream_if_ctx,\n                conn->ifc_settings->es_init_max_stream_data_bidi_local,\n                conn->ifc_cfg.max_stream_send, flags);\n    if (!stream)\n        return -1;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return -1;\n    }\n    lsquic_stream_call_on_new(stream);\n    return 0;\n}\n\n\nstatic struct lsquic_stream *\ncreate_push_stream (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    enum stream_ctor_flags flags;\n\n    assert((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) == (IFC_SERVER|IFC_HTTP));\n\n    flags = SCF_IETF|SCF_HTTP;\n    if (conn->ifc_enpub->enp_settings.es_rw_once)\n        flags |= SCF_DISP_RW_ONCE;\n    if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n        flags |= SCF_DELAY_ONCLOSE;\n\n    stream_id = generate_stream_id(conn, SD_UNI);\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                conn->ifc_enpub->enp_stream_if,\n                conn->ifc_enpub->enp_stream_if_ctx,\n                conn->ifc_settings->es_init_max_stream_data_bidi_local,\n                conn->ifc_cfg.max_stream_send, flags);\n    if (!stream)\n        return NULL;\n    if (!lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n    {\n        lsquic_stream_destroy(stream);\n        return NULL;\n    }\n    return stream;\n}\n\n\n/* This function looks through the SCID array searching for an available\n * slot. If it finds an available slot it will\n *  1. generate an SCID,\n *  2. mark with latest seqno,\n *  3. increment seqno,\n *  4. turn on CCE_SEQNO flag,\n *  5. turn on flag given through flag paramter,\n *  6. add cce to mask, and\n *  7. add timestamp for when slot is new available for CID generation.\n */\nstatic struct conn_cid_elem *\nietf_full_conn_add_scid (struct ietf_full_conn *conn,\n                            struct lsquic_engine_public *enpub,\n                            enum conn_cce_flags flags,\n                            lsquic_time_t now)\n{\n    struct conn_cid_elem *cce;\n    struct lsquic_conn *lconn = &conn->ifc_conn;\n    lsquic_time_t *min_timestamp;\n    int i;\n\n    if (enpub->enp_settings.es_scid_len)\n    {\n        for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n            if (!(lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces))))\n                break;\n    }\n    else if (0 == lconn->cn_cces_mask)\n        cce = lconn->cn_cces;\n    else\n        cce = END_OF_CCES(lconn);\n\n    if (cce >= END_OF_CCES(lconn))\n    {\n        LSQ_LOG1(LSQ_LOG_DEBUG, \"cannot find slot for new SCID\");\n        return NULL;\n    }\n\n    if (enpub->enp_settings.es_scid_len)\n        enpub->enp_generate_scid(enpub->enp_gen_scid_ctx, lconn, &cce->cce_cid,\n                                            enpub->enp_settings.es_scid_len);\n\n    cce->cce_seqno = conn->ifc_scid_seqno++;\n    cce->cce_flags |= CCE_SEQNO | flags;\n    lconn->cn_cces_mask |= 1 << (cce - lconn->cn_cces);\n    ++conn->ifc_active_cids_count;\n    if (enpub->enp_settings.es_scid_iss_rate)\n    {\n        min_timestamp = &conn->ifc_scid_timestamp[0];\n        for (i = 1; i < lconn->cn_n_cces; i++)\n            if (conn->ifc_scid_timestamp[i] < *min_timestamp)\n                    min_timestamp = &conn->ifc_scid_timestamp[i];\n        *min_timestamp = now;\n    }\n    LSQ_LOG1C(LSQ_LOG_DEBUG, \"generated and assigned SCID %\"CID_FMT,\n                                                    CID_BITS(&cce->cce_cid));\n    return cce;\n}\n\n\n/* From [draft-ietf-quic-transport-25] Section 17.3.1:\n *  \" endpoints MUST disable their use of the spin bit for a random selection\n *  \" of at least one in every 16 network paths, or for one in every 16\n *  \" connection IDs.\n */\nstatic void\nmaybe_enable_spin (struct ietf_full_conn *conn, struct conn_path *cpath)\n{\n    uint8_t nyb;\n\n    if (conn->ifc_settings->es_spin\n                    && lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand))\n    {\n        cpath->cop_flags |= COP_SPIN_BIT;\n        cpath->cop_spin_bit = 0;\n        LSQ_DEBUG(\"spin bit enabled on path %hhu\", cpath->cop_path.np_path_id);\n    }\n    else\n    {\n        /* \" It is RECOMMENDED that endpoints set the spin bit to a random\n         * \" value either chosen independently for each packet or chosen\n         * \" independently for each connection ID.\n         * (ibid.)\n         */\n        cpath->cop_flags &= ~COP_SPIN_BIT;\n        nyb = lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand);\n        cpath->cop_spin_bit = nyb & 1;\n        LSQ_DEBUG(\"spin bit disabled %s on path %hhu; random spin bit \"\n            \"value is %hhu\",\n            !conn->ifc_settings->es_spin ? \"via settings\" : \"randomly\",\n            cpath->cop_path.np_path_id, cpath->cop_spin_bit);\n    }\n}\n\n\nstatic int\nietf_full_conn_init (struct ietf_full_conn *conn,\n           struct lsquic_engine_public *enpub, unsigned flags, int ecn)\n{\n    if (flags & IFC_SERVER)\n        conn->ifc_conn.cn_if = ietf_full_conn_iface_ptr;\n    else\n        conn->ifc_conn.cn_if = ietf_full_conn_prehsk_iface_ptr;\n    if (enpub->enp_settings.es_scid_len)\n        assert(CN_SCID(&conn->ifc_conn)->len);\n    conn->ifc_enpub = enpub;\n    conn->ifc_settings = &enpub->enp_settings;\n    conn->ifc_pub.lconn = &conn->ifc_conn;\n    conn->ifc_pub.send_ctl = &conn->ifc_send_ctl;\n    conn->ifc_pub.enpub = enpub;\n    conn->ifc_pub.mm = &enpub->enp_mm;\n#if LSQUIC_CONN_STATS\n    conn->ifc_pub.conn_stats = &conn->ifc_stats;\n#endif\n    conn->ifc_pub.path = CUR_NPATH(conn);\n    TAILQ_INIT(&conn->ifc_pub.sending_streams);\n    TAILQ_INIT(&conn->ifc_pub.read_streams);\n    TAILQ_INIT(&conn->ifc_pub.write_streams);\n    TAILQ_INIT(&conn->ifc_pub.service_streams);\n    STAILQ_INIT(&conn->ifc_stream_ids_to_ss);\n    TAILQ_INIT(&conn->ifc_to_retire);\n\n    lsquic_alarmset_init(&conn->ifc_alset, &conn->ifc_conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_IDLE, idle_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_ACK_APP, ack_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PING, ping_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_HANDSHAKE, handshake_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_CID_THROT, cid_throt_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_0, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_1, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_2, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PATH_CHAL_3, path_chal_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_BLOCKED_KA, blocked_ka_alarm_expired, conn);\n    lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_MTU_PROBE, mtu_probe_alarm_expired, conn);\n    /* For Init and Handshake, we don't expect many ranges at all.  For\n     * the regular receive history, set limit to a value that would never\n     * be reached under normal circumstances, yet small enough that would\n     * use little memory when under attack and be robust (fast).  The\n     * value 1000 limits receive history to about 16KB.\n     */\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_INIT], 1, 10);\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_HSK], 1, 10);\n    lsquic_rechist_init(&conn->ifc_rechist[PNS_APP], 1, 1000);\n    lsquic_send_ctl_init(&conn->ifc_send_ctl, &conn->ifc_alset, enpub,\n        flags & IFC_SERVER ? &server_ver_neg : &conn->ifc_u.cli.ifcli_ver_neg,\n        &conn->ifc_pub, SC_IETF|SC_NSTP|(ecn ? SC_ECN : 0));\n    lsquic_cfcw_init(&conn->ifc_pub.cfcw, &conn->ifc_pub,\n                                        conn->ifc_settings->es_init_max_data);\n    conn->ifc_pub.all_streams = lsquic_hash_create();\n    if (!conn->ifc_pub.all_streams)\n        return -1;\n    conn->ifc_pub.u.ietf.qeh = &conn->ifc_qeh;\n    conn->ifc_pub.u.ietf.qdh = &conn->ifc_qdh;\n    conn->ifc_pub.u.ietf.hcso = &conn->ifc_hcso;\n\n    conn->ifc_peer_hq_settings.header_table_size     = HQ_DF_QPACK_MAX_TABLE_CAPACITY;\n    conn->ifc_peer_hq_settings.qpack_blocked_streams = HQ_DF_QPACK_BLOCKED_STREAMS;\n\n    conn->ifc_flags = flags | IFC_FIRST_TICK;\n    conn->ifc_max_ack_packno[PNS_INIT] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ack_packno[PNS_HSK] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ack_packno[PNS_APP] = IQUIC_INVALID_PACKNO;\n    conn->ifc_max_ackable_packno_in = 0;\n    conn->ifc_paths[0].cop_path.np_path_id = 0;\n    conn->ifc_paths[1].cop_path.np_path_id = 1;\n    conn->ifc_paths[2].cop_path.np_path_id = 2;\n    conn->ifc_paths[3].cop_path.np_path_id = 3;\n#define valid_stream_id(v) ((v) <= VINT_MAX_VALUE)\n    conn->ifc_max_req_id = VINT_MAX_VALUE + 1;\n    conn->ifc_ping_unretx_thresh = 20;\n    conn->ifc_max_retx_since_last_ack = MAX_RETR_PACKETS_SINCE_LAST_ACK;\n    conn->ifc_max_ack_delay = ACK_TIMEOUT;\n    if (conn->ifc_settings->es_noprogress_timeout)\n        conn->ifc_mflags |= MF_NOPROG_TIMEOUT;\n    if (conn->ifc_settings->es_ext_http_prio)\n        conn->ifc_pii = &ext_prio_iter_if;\n    else\n        conn->ifc_pii = &orig_prio_iter_if;\n    return 0;\n}\n\n\nstruct lsquic_conn *\nlsquic_ietf_full_conn_client_new (struct lsquic_engine_public *enpub,\n           unsigned versions, unsigned flags,\n           const char *hostname, unsigned short base_plpmtu, int is_ipv4,\n           const unsigned char *sess_resume, size_t sess_resume_sz,\n           const unsigned char *token, size_t token_sz, void* peer_ctx)\n{\n    const struct transport_params *params;\n    const struct enc_session_funcs_iquic *esfi;\n    struct ietf_full_conn *conn;\n    enum lsquic_version ver, sess_resume_version;\n    lsquic_time_t now;\n\n    conn = calloc(1, sizeof(*conn));\n    if (!conn)\n        goto err0;\n    now = lsquic_time_now();\n    /* Set the flags early so that correct CID is used for logging */\n    conn->ifc_conn.cn_flags |= LSCONN_IETF;\n    conn->ifc_conn.cn_cces = conn->ifc_cces;\n    conn->ifc_conn.cn_n_cces = sizeof(conn->ifc_cces)\n                                                / sizeof(conn->ifc_cces[0]);\n    if (!ietf_full_conn_add_scid(conn, enpub, CCE_USED, now))\n        goto err1;\n    conn->ifc_conn.cn_logid = *CN_SCID(&conn->ifc_conn);\n    assert(versions);\n    versions &= LSQUIC_IETF_VERSIONS;\n    if (versions & (1 << LSQVER_I001))\n        ver = LSQVER_I001;\n    else\n        ver = highest_bit_set(versions);\n    if (sess_resume)\n    {\n        sess_resume_version = lsquic_sess_resume_version(sess_resume, sess_resume_sz);\n        if (sess_resume_version < N_LSQVER && ((1 << sess_resume_version) & versions))\n            ver = sess_resume_version;\n    }\n    esfi = select_esf_iquic_by_ver(ver);\n\n    if (0 != ietf_full_conn_init(conn, enpub, flags,\n                                                enpub->enp_settings.es_ecn))\n        goto err2;\n\n    if (base_plpmtu)\n        conn->ifc_paths[0].cop_path.np_pack_size\n                                = base_plpmtu - TRANSPORT_OVERHEAD(!is_ipv4);\n    else\n        conn->ifc_paths[0].cop_path.np_pack_size\n                                = calc_base_packet_size(conn, !is_ipv4);\n\n    if (token)\n    {\n        if (0 != lsquic_send_ctl_set_token(&conn->ifc_send_ctl, token,\n                                                                token_sz))\n            goto err2;\n    }\n\n    /* Do not infer anything about server limits before processing its\n     * transport parameters.\n     */\n    conn->ifc_max_streams_in[SD_BIDI] = enpub->enp_settings.es_max_streams_in;\n    conn->ifc_max_allowed_stream_id[SIT_BIDI_SERVER] =\n        enpub->enp_settings.es_max_streams_in << SIT_SHIFT;\n\n    if (flags & IFC_HTTP)\n    {\n        if (enpub->enp_settings.es_support_push && CLIENT_PUSH_SUPPORT)\n            conn->ifc_max_streams_in[SD_UNI]\n                            = MAX(3, enpub->enp_settings.es_max_streams_in);\n        else\n            conn->ifc_max_streams_in[SD_UNI] = 3;\n    }\n    else\n        conn->ifc_max_streams_in[SD_UNI] = enpub->enp_settings.es_max_streams_in;\n    conn->ifc_max_allowed_stream_id[SIT_UNI_SERVER]\n                                = conn->ifc_max_streams_in[SD_UNI] << SIT_SHIFT;\n\n    init_ver_neg(conn, versions, &ver);\n    assert(ver == conn->ifc_u.cli.ifcli_ver_neg.vn_ver);\n    if (conn->ifc_settings->es_handshake_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_HANDSHAKE,\n                    lsquic_time_now() + conn->ifc_settings->es_handshake_to);\n    conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n    if (conn->ifc_idle_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, now + conn->ifc_idle_to);\n    if (enpub->enp_settings.es_support_push && CLIENT_PUSH_SUPPORT)\n    {\n        conn->ifc_u.cli.ifcli_flags |= IFCLI_PUSH_ENABLED;\n        conn->ifc_u.cli.ifcli_max_push_id = 100;\n        LSQ_DEBUG(\"push enabled: set MAX_PUSH_ID to %\"PRIu64,\n                                            conn->ifc_u.cli.ifcli_max_push_id);\n    }\n    conn->ifc_conn.cn_pf = select_pf_by_ver(ver);\n    conn->ifc_conn.cn_esf_c = select_esf_common_by_ver(ver);\n    conn->ifc_conn.cn_esf.i = esfi;\n    lsquic_generate_cid(CUR_DCID(conn), 0);\n    conn->ifc_conn.cn_enc_session =\n            conn->ifc_conn.cn_esf.i->esfi_create_client(hostname,\n                conn->ifc_enpub, &conn->ifc_conn, CUR_DCID(conn),\n                &conn->ifc_u.cli.ifcli_ver_neg,\n                (void **) conn->ifc_u.cli.crypto_streams, &crypto_stream_if,\n                sess_resume, sess_resume_sz, &conn->ifc_alset,\n                conn->ifc_max_streams_in[SD_UNI], peer_ctx);\n    if (!conn->ifc_conn.cn_enc_session)\n        goto err2;\n\n    conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT] = lsquic_stream_new_crypto(\n                ENC_LEV_INIT, &conn->ifc_pub, &lsquic_cry_sm_if,\n        conn->ifc_conn.cn_enc_session,\n        SCF_IETF|SCF_DI_AUTOSWITCH|SCF_CALL_ON_NEW|SCF_CRITICAL);\n    if (!conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT])\n        goto err3;\n    if (!lsquic_stream_get_ctx(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]))\n        goto err4;\n    conn->ifc_pub.packet_out_malo =\n                        lsquic_malo_create(sizeof(struct lsquic_packet_out));\n    if (!conn->ifc_pub.packet_out_malo)\n        goto err4;\n    conn->ifc_flags |= IFC_PROC_CRYPTO;\n\n    LSQ_DEBUG(\"negotiating version %s\",\n                        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver]);\n    conn->ifc_process_incoming_packet = process_incoming_packet_verneg;\n    conn->ifc_created = now;\n    LSQ_DEBUG(\"logging using client SCID\");\n    if (sess_resume && (params\n            = conn->ifc_conn.cn_esf.i->esfi_get_peer_transport_params(\n                            conn->ifc_conn.cn_enc_session), params != NULL))\n    {\n        LSQ_DEBUG(\"initializing transport parameters for 0RTT\");\n        if (0 != apply_trans_params(conn, params))\n            goto full_err;\n        if ((conn->ifc_flags & IFC_HTTP) && 0 != init_http(conn))\n            goto full_err;\n        conn->ifc_mflags |= MF_DOING_0RTT;\n    }\n    conn->ifc_flags |= IFC_CREATED_OK;\n    return &conn->ifc_conn;\n\n  err4:\n    lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]);\n  err3:\n    conn->ifc_conn.cn_esf.i->esfi_destroy(conn->ifc_conn.cn_enc_session);\n  err2:\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    if (conn->ifc_pub.all_streams)\n        lsquic_hash_destroy(conn->ifc_pub.all_streams);\n  err1:\n    free(conn);\n  err0:\n    return NULL;\n\n  full_err:\n    ietf_full_conn_ci_destroy(&conn->ifc_conn);\n    return NULL;\n}\n\n\ntypedef char mini_conn_does_not_have_more_cces[\n    sizeof(((struct ietf_mini_conn *)0)->imc_cces)\n    <= sizeof(((struct ietf_full_conn *)0)->ifc_cces) ? 1 : -1];\n\nstruct lsquic_conn *\nlsquic_ietf_full_conn_server_new (struct lsquic_engine_public *enpub,\n               unsigned flags, struct lsquic_conn *mini_conn)\n{\n    struct ietf_mini_conn *const imc = (void *) mini_conn;\n    struct ietf_full_conn *conn;\n    struct lsquic_packet_out *packet_out;\n    struct lsquic_packet_in *packet_in;\n    struct conn_cid_elem *cce;\n    int have_outgoing_ack;\n    lsquic_packno_t next_packno;\n    lsquic_time_t now;\n    enum packnum_space pns;\n    unsigned i;\n    struct ietf_mini_rechist mini_rechist;\n\n    conn = calloc(1, sizeof(*conn));\n    if (!conn)\n        goto err0;\n    now = lsquic_time_now();\n    conn->ifc_conn.cn_cces = conn->ifc_cces;\n    conn->ifc_conn.cn_n_cces = sizeof(conn->ifc_cces)\n                                                / sizeof(conn->ifc_cces[0]);\n    assert(conn->ifc_conn.cn_n_cces >= mini_conn->cn_n_cces);\n    conn->ifc_conn.cn_cur_cce_idx = mini_conn->cn_cur_cce_idx;\n    conn->ifc_conn.cn_cces_mask = mini_conn->cn_cces_mask;\n    for (cce = mini_conn->cn_cces, i = 0; cce < END_OF_CCES(mini_conn);\n                                                                    ++cce, ++i)\n        if ((1 << (cce - mini_conn->cn_cces)) & mini_conn->cn_cces_mask)\n        {\n            conn->ifc_conn.cn_cces[i].cce_cid   = cce->cce_cid;\n            conn->ifc_conn.cn_cces[i].cce_flags = cce->cce_flags;\n            if (cce->cce_flags & CCE_SEQNO)\n            {\n                if (cce->cce_seqno > conn->ifc_scid_seqno)\n                    conn->ifc_scid_seqno = cce->cce_seqno;\n                conn->ifc_conn.cn_cces[i].cce_seqno = cce->cce_seqno;\n                ++conn->ifc_active_cids_count;\n            }\n            conn->ifc_scid_timestamp[i] = now;\n        }\n    ++conn->ifc_scid_seqno;\n    conn->ifc_conn.cn_logid = mini_conn->cn_logid;\n    /* Set the flags early so that correct CID is used for logging */\n    conn->ifc_conn.cn_flags |= LSCONN_IETF | LSCONN_SERVER;\n\n    if (0 != ietf_full_conn_init(conn, enpub, flags,\n                                        lsquic_mini_conn_ietf_ecn_ok(imc)))\n        goto err1;\n    conn->ifc_pub.packet_out_malo =\n                        lsquic_malo_create(sizeof(struct lsquic_packet_out));\n    if (!conn->ifc_pub.packet_out_malo)\n        goto err1;\n    if (imc->imc_flags & IMC_IGNORE_INIT)\n        conn->ifc_flags |= IFC_IGNORE_INIT;\n    if (enpub->enp_settings.es_support_srej)\n        conn->ifc_send_flags |= SF_SEND_NEW_TOKEN;\n\n    conn->ifc_paths[0].cop_path = imc->imc_path;\n    conn->ifc_paths[0].cop_flags = COP_VALIDATED|COP_INITIALIZED|COP_ALLOW_MTU_PADDING;\n    conn->ifc_used_paths = 1 << 0;\n    maybe_enable_spin(conn, &conn->ifc_paths[0]);\n    if (imc->imc_flags & IMC_ADDR_VALIDATED)\n        lsquic_send_ctl_path_validated(&conn->ifc_send_ctl);\n    else\n        conn->ifc_mflags |= MF_VALIDATE_PATH;\n    conn->ifc_pub.bytes_out = imc->imc_bytes_out;\n    conn->ifc_pub.bytes_in = imc->imc_bytes_in;\n    if (imc->imc_flags & IMC_PATH_CHANGED)\n    {\n        LSQ_DEBUG(\"path changed during mini conn: schedule PATH_CHALLENGE\");\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL_PATH_0;\n    }\n\n    conn->ifc_max_streams_in[SD_BIDI]\n        = enpub->enp_settings.es_init_max_streams_bidi;\n    conn->ifc_max_allowed_stream_id[SIT_BIDI_CLIENT]\n        = conn->ifc_max_streams_in[SD_BIDI] << SIT_SHIFT;\n    conn->ifc_max_streams_in[SD_UNI]\n        = enpub->enp_settings.es_init_max_streams_uni;\n    conn->ifc_max_allowed_stream_id[SIT_UNI_CLIENT]\n        = conn->ifc_max_streams_in[SD_UNI] << SIT_SHIFT;\n    conn->ifc_conn.cn_version     = mini_conn->cn_version;\n    conn->ifc_conn.cn_flags      |= LSCONN_VER_SET;\n    conn->ifc_conn.cn_pf          = mini_conn->cn_pf;\n    conn->ifc_conn.cn_esf_c       = mini_conn->cn_esf_c;\n    conn->ifc_conn.cn_esf         = mini_conn->cn_esf;\n\n    if (enpub->enp_settings.es_support_push)\n        conn->ifc_u.ser.ifser_flags |= IFSER_PUSH_ENABLED;\n    if (flags & IFC_HTTP)\n    {\n        fiu_do_on(\"full_conn_ietf/promise_hash\", goto promise_alloc_failed);\n        conn->ifc_pub.u.ietf.promises = lsquic_hash_create();\n#if FIU_ENABLE\n  promise_alloc_failed:\n#endif\n        if (!conn->ifc_pub.u.ietf.promises)\n            goto err2;\n    }\n\n    assert(mini_conn->cn_flags & LSCONN_HANDSHAKE_DONE);\n    conn->ifc_conn.cn_flags      |= LSCONN_HANDSHAKE_DONE;\n    if (!(imc->imc_flags & IMC_HSK_DONE_SENT))\n    {\n        LSQ_DEBUG(\"HANDSHAKE_DONE not yet sent, will process CRYPTO frames\");\n        conn->ifc_flags |= IFC_PROC_CRYPTO;\n    }\n\n    conn->ifc_conn.cn_enc_session = mini_conn->cn_enc_session;\n    mini_conn->cn_enc_session     = NULL;\n    conn->ifc_conn.cn_esf_c->esf_set_conn(conn->ifc_conn.cn_enc_session,\n                                                            &conn->ifc_conn);\n    conn->ifc_process_incoming_packet = process_incoming_packet_fast;\n\n    conn->ifc_send_ctl.sc_cur_packno = imc->imc_next_packno - 1;\n    conn->ifc_incoming_ecn = imc->imc_incoming_ecn;\n    conn->ifc_pub.rtt_stats = imc->imc_rtt_stats;\n\n    conn->ifc_last_live_update = now;\n\n    lsquic_send_ctl_begin_optack_detection(&conn->ifc_send_ctl);\n\n    for (pns = 0; pns < IMICO_N_PNS; ++pns)\n    {\n        lsquic_imico_rechist_init(&mini_rechist, imc, pns);\n        if (pns < IMICO_N_PNS)\n        {\n            if (0 != lsquic_rechist_copy_ranges(&conn->ifc_rechist[pns],\n                                    &mini_rechist, lsquic_imico_rechist_first,\n                                    lsquic_imico_rechist_next))\n                goto err2;\n            conn->ifc_rechist[pns].rh_largest_acked_received\n                                                = imc->imc_largest_recvd[pns];\n        }\n    }\n\n    /* Mini connection sends out packets 0, 1, 2... and so on.  It deletes\n     * packets that have been successfully sent and acked or those that have\n     * been lost.  We take ownership of all packets in mc_packets_out; those\n     * that are not on the list are recorded in fc_send_ctl.sc_senhist.\n     */\n    have_outgoing_ack = 0;\n    next_packno = ~0ULL;\n    /* mini conn may drop Init packets, making gaps; don't warn about them: */\n    conn->ifc_send_ctl.sc_senhist.sh_flags |= SH_GAP_OK;\n    while ((packet_out = TAILQ_FIRST(&imc->imc_packets_out)))\n    {\n        TAILQ_REMOVE(&imc->imc_packets_out, packet_out, po_next);\n\n        /* Holes in the sequence signify no-longer-relevant Initial packets or\n         * ACKed or lost packets.\n         */\n        ++next_packno;\n        for ( ; next_packno < packet_out->po_packno; ++next_packno)\n        {\n            lsquic_senhist_add(&conn->ifc_send_ctl.sc_senhist, next_packno);\n            conn->ifc_send_ctl.sc_senhist.sh_warn_thresh = next_packno;\n        }\n\n        packet_out->po_path = CUR_NPATH(conn);\n        if (imc->imc_sent_packnos & (1ULL << packet_out->po_packno))\n        {\n            LSQ_DEBUG(\"got sent packet_out %\"PRIu64\" from mini\",\n                                                   packet_out->po_packno);\n            if (0 != lsquic_send_ctl_sent_packet(&conn->ifc_send_ctl,\n                                                             packet_out))\n            {\n                LSQ_WARN(\"could not add packet %\"PRIu64\" to sent set: %s\",\n                    packet_out->po_packno, strerror(errno));\n                goto err2;\n            }\n        }\n        else\n        {\n            LSQ_DEBUG(\"got unsent packet_out %\"PRIu64\" from mini (will send)\",\n                                                   packet_out->po_packno);\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n            have_outgoing_ack |= packet_out->po_frame_types &\n                                                (1 << QUIC_FRAME_ACK);\n        }\n    }\n    conn->ifc_send_ctl.sc_senhist.sh_flags &= ~SH_GAP_OK;\n    /* ...Yes, that's a bunch of little annoying steps to suppress the gap\n     * warnings, but it would have been even more annoying (and expensive)\n     * to add packet renumbering logic to the mini conn.\n     */\n\n    for (pns = 0; pns < IMICO_N_PNS; ++pns)\n        for (i = 0; i < 4; ++i)\n        {\n            conn->ifc_ecn_counts_in[pns][i]  = imc->imc_ecn_counts_in[pns][i];\n        }\n\n    if (0 != handshake_ok(&conn->ifc_conn))\n        goto err3;\n\n    LSQ_DEBUG(\"Calling on_new_conn callback\");\n    conn->ifc_conn.cn_conn_ctx = conn->ifc_enpub->enp_stream_if->on_new_conn(\n                        conn->ifc_enpub->enp_stream_if_ctx, &conn->ifc_conn);\n    conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n\n    conn->ifc_created = now;\n    if (conn->ifc_idle_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE,\n                                        now + conn->ifc_idle_to);\n    while ((packet_in = TAILQ_FIRST(&imc->imc_app_packets)))\n    {\n        TAILQ_REMOVE(&imc->imc_app_packets, packet_in, pi_next);\n        LSQ_DEBUG(\"inherit packet %\"PRIu64\" from mini conn\",\n                                                        packet_in->pi_packno);\n        ietf_full_conn_ci_packet_in(&conn->ifc_conn, packet_in);\n        lsquic_packet_in_put(conn->ifc_pub.mm, packet_in);\n    }\n\n    LSQ_DEBUG(\"logging using %s SCID\",\n        LSQUIC_LOG_CONN_ID == CN_SCID(&conn->ifc_conn) ? \"server\" : \"client\");\n    conn->ifc_flags |= IFC_CREATED_OK;\n    return &conn->ifc_conn;\n\n  err3:\n    ietf_full_conn_ci_destroy(&conn->ifc_conn);\n    return NULL;\n\n  err2:\n    lsquic_malo_destroy(conn->ifc_pub.packet_out_malo);\n  err1:\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    if (conn->ifc_pub.all_streams)\n        lsquic_hash_destroy(conn->ifc_pub.all_streams);\n    free(conn);\n  err0:\n    return NULL;\n}\n\n\nstatic int\nshould_generate_ack (struct ietf_full_conn *conn,\n                                            enum ifull_conn_flags ack_queued)\n{\n    unsigned lost_acks;\n\n    /* Need to set which ACKs are queued because generate_ack_frame() does not\n     * generate ACKs unconditionally.\n     */\n    lost_acks = lsquic_send_ctl_lost_ack(&conn->ifc_send_ctl);\n    if (lost_acks)\n        conn->ifc_flags |= lost_acks << IFCBIT_ACK_QUED_SHIFT;\n\n    return (conn->ifc_flags & ack_queued) != 0;\n}\n\n\nstatic int\nietf_full_conn_ci_can_write_ack (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    /* Follow opportunistic ACK logic.  Because this method is only used by\n     * buffered packets code path, no need to check whether anything is\n     * writing: we know it is.\n     */\n    return conn->ifc_n_slack_akbl[PNS_APP] > 0\n        && lsquic_send_ctl_can_send(&conn->ifc_send_ctl);\n}\n\n\nstatic unsigned\nietf_full_conn_ci_cancel_pending_streams (struct lsquic_conn *lconn, unsigned n)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    if (n > conn->ifc_n_delayed_streams)\n        conn->ifc_n_delayed_streams = 0;\n    else\n        conn->ifc_n_delayed_streams -= n;\n    return conn->ifc_n_delayed_streams;\n}\n\n\n/* Best effort.  If timestamp frame does not fit, oh well */\nstatic void\ngenerate_timestamp_frame (struct ietf_full_conn *conn,\n                    struct lsquic_packet_out *packet_out, lsquic_time_t now)\n{\n    uint64_t timestamp;\n    int w;\n\n    timestamp = (now - conn->ifc_created) >> TP_DEF_ACK_DELAY_EXP;\n    w = conn->ifc_conn.cn_pf->pf_gen_timestamp_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), timestamp);\n    if (w < 0)\n    {\n        LSQ_DEBUG(\"could not generate TIMESTAMP frame\");\n        return;\n    }\n    LSQ_DEBUG(\"generated TIMESTAMP(%\"PRIu64\" us) frame\",\n                                        timestamp << TP_DEF_ACK_DELAY_EXP);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated TIMESTAMP(%\"\n                    PRIu64\" us) frame\", timestamp << TP_DEF_ACK_DELAY_EXP);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_TIMESTAMP, packet_out->po_data_sz, w))\n    {\n        LSQ_DEBUG(\"%s: adding frame to packet failed: %d\", __func__, errno);\n        return;\n    }\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_TIMESTAMP;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n}\n\n\nstruct ietf_ack_state\n{\n    enum ifull_conn_flags   conn_flags;\n    enum send_flags         send_flags;\n    enum alarm_id_bit       armed_set;\n    unsigned                n_slack_akbl;\n    unsigned                n_slack_all;\n    unsigned char           unretx_thresh;\n};\n\n\ntypedef char ack_state_size[sizeof(struct ietf_ack_state)\n                                    <= sizeof(struct ack_state) ? 1 : - 1];\n\nstatic void\nietf_full_conn_ci_ack_snapshot (struct lsquic_conn *lconn,\n                                                    struct ack_state *opaque)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct ietf_ack_state *const ack_state = (struct ietf_ack_state *) opaque;\n\n    ack_state->conn_flags   = conn->ifc_flags;\n    ack_state->send_flags   = conn->ifc_send_flags;\n    ack_state->armed_set    = conn->ifc_alset.as_armed_set;\n    ack_state->n_slack_akbl = conn->ifc_n_slack_akbl[PNS_APP];\n    ack_state->n_slack_all  = conn->ifc_n_slack_all;\n    ack_state->unretx_thresh= conn->ifc_ping_unretx_thresh;\n    LSQ_DEBUG(\"take ACK snapshot\");\n}\n\n\nstatic void\nietf_full_conn_ci_ack_rollback (struct lsquic_conn *lconn,\n                                                    struct ack_state *opaque)\n{\n    struct ietf_ack_state *const ack_state = (struct ietf_ack_state *) opaque;\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    conn->ifc_flags &= ~(IFC_ACK_HAD_MISS|IFC_ACK_QUED_APP);\n    conn->ifc_flags |= (IFC_ACK_HAD_MISS|IFC_ACK_QUED_APP)\n                                        & ack_state->conn_flags;\n\n    conn->ifc_send_flags &= ~SF_SEND_PING;\n    conn->ifc_send_flags |= SF_SEND_PING & ack_state->send_flags;\n\n    conn->ifc_alset.as_armed_set &= ~ALBIT_ACK_APP;\n    conn->ifc_alset.as_armed_set |= ALBIT_ACK_APP & ack_state->armed_set;\n\n    conn->ifc_n_slack_akbl[PNS_APP]     = ack_state->n_slack_akbl;\n    conn->ifc_n_slack_all               = ack_state->n_slack_all;\n    conn->ifc_ping_unretx_thresh        = ack_state->unretx_thresh;\n\n    LSQ_DEBUG(\"roll back ACK state\");\n}\n\n\nstatic int\ngenerate_ack_frame_for_pns (struct ietf_full_conn *conn,\n                struct lsquic_packet_out *packet_out, enum packnum_space pns,\n                lsquic_time_t now)\n{\n    const uint64_t *ecn_counts;\n    int has_missing, w;\n\n    if (conn->ifc_incoming_ecn\n                        && lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n        ecn_counts = conn->ifc_ecn_counts_in[pns];\n    else if ((conn->ifc_mflags & MF_SEND_WRONG_COUNTS) && pns == PNS_APP)\n    {\n        /* We try once.  A more advanced version would wait until we get a\n         * packet from peer and only then stop.\n         */\n        conn->ifc_mflags &= ~MF_SEND_WRONG_COUNTS;\n        ecn_counts = conn->ifc_ecn_counts_in[pns];\n    }\n    else\n        ecn_counts = NULL;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_ack_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            (gaf_rechist_first_f)        lsquic_rechist_first,\n            (gaf_rechist_next_f)         lsquic_rechist_next,\n            (gaf_rechist_largest_recv_f) lsquic_rechist_largest_recv,\n            &conn->ifc_rechist[pns], now, &has_missing, &packet_out->po_ack2ed,\n            ecn_counts);\n    if (w < 0) {\n        ABORT_ERROR(\"%s generating ACK frame failed: %d\", lsquic_pns2str[pns], errno);\n        return -1;\n    }\n    CONN_STATS(out.acks, 1);\n    char buf[0x100];\n    lsquic_hexstr(packet_out->po_data + packet_out->po_data_sz, w, buf, sizeof(buf));\n    LSQ_DEBUG(\"ACK bytes: %s\", buf);\n    EV_LOG_GENERATED_ACK_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    lsquic_send_ctl_scheduled_ack(&conn->ifc_send_ctl, pns,\n                                                    packet_out->po_ack2ed);\n\n    // NOTE: Add a PING frame after ACK frame before HANDSHAKE_DONE, in a hacky way\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        && packet_out->po_data_sz + w < packet_out->po_n_alloc)\n    {\n        LSQ_DEBUG(\"add a PING frame before HANDSHAKE_DONE\");\n        *(packet_out->po_data + packet_out->po_data_sz + w) = '\\x01';\n        ++w;\n    }\n\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_ACK;\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_ACK, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n    if (has_missing && !(conn->ifc_mflags & MF_IGNORE_MISSING))\n        conn->ifc_flags |= IFC_ACK_HAD_MISS;\n    else\n        conn->ifc_flags &= ~IFC_ACK_HAD_MISS;\n    LSQ_DEBUG(\"Put %d bytes of ACK frame into packet %\" PRIu64\n              \" on outgoing queue\", w, packet_out->po_packno);\n    if (conn->ifc_n_cons_unretx >= conn->ifc_ping_unretx_thresh &&\n                !lsquic_send_ctl_have_outgoing_retx_frames(&conn->ifc_send_ctl))\n    {\n        LSQ_DEBUG(\"schedule PING frame after %u non-retx \"\n                                    \"packets sent\", conn->ifc_n_cons_unretx);\n        conn->ifc_send_flags |= SF_SEND_PING;\n        /* This gives a range [12, 27]: */\n        conn->ifc_ping_unretx_thresh = 12\n                    + lsquic_crand_get_nybble(conn->ifc_enpub->enp_crand);\n    }\n\n    conn->ifc_n_slack_akbl[pns] = 0;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << pns);\n    if (pns == PNS_APP)\n    {\n        conn->ifc_n_slack_all = 0;\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n    }\n    lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n    LSQ_DEBUG(\"%s ACK state reset\", lsquic_pns2str[pns]);\n\n    if (pns == PNS_APP && (conn->ifc_flags & IFC_TIMESTAMPS))\n        generate_timestamp_frame(conn, packet_out, now);\n\n    return 0;\n}\n\n\n/* Return number of packets scheduled or 0 on error */\nstatic unsigned\ngenerate_ack_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    enum packnum_space pns;\n    unsigned count;\n    int s;\n\n    count = 0;\n    for (pns = 0; pns < N_PNS; ++pns)\n        if (conn->ifc_flags & (IFC_ACK_QUED_INIT << pns))\n        {\n            packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl,\n                                                        0, pns, CUR_NPATH(conn));\n            if (!packet_out)\n            {\n                ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n                return 0;\n            }\n            s = generate_ack_frame_for_pns(conn, packet_out, pns, now);\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n            if (s != 0)\n                return 0;\n            ++count;\n        }\n\n    return count;\n}\n\n\nstatic struct lsquic_packet_out *\nget_writeable_packet_on_path (struct ietf_full_conn *conn,\n                    unsigned need_at_least, const struct network_path *path,\n                    int regen_match)\n{\n    struct lsquic_packet_out *packet_out;\n    int is_err;\n\n    packet_out = lsquic_send_ctl_get_writeable_packet(&conn->ifc_send_ctl,\n                            PNS_APP, need_at_least, path, regen_match, &is_err);\n    if (!packet_out && is_err)\n        ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n    return packet_out;\n}\n\n\nstatic struct lsquic_packet_out *\nget_writeable_packet (struct ietf_full_conn *conn, unsigned need_at_least)\n{\n    return get_writeable_packet_on_path(conn, need_at_least,\n                                                        CUR_NPATH(conn), 0);\n}\n\n\nstatic void\ngenerate_max_data_frame (struct ietf_full_conn *conn)\n{\n    const uint64_t offset = lsquic_cfcw_get_fc_recv_off(&conn->ifc_pub.cfcw);\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_max_data_frame_size(offset);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n    w = conn->ifc_conn.cn_pf->pf_gen_max_data_frame(\n                         packet_out->po_data + packet_out->po_data_sz,\n                         lsquic_packet_out_avail(packet_out), offset);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"Generating MAX_DATA frame failed\");\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte MAX_DATA frame (offset: %\"PRIu64\")\", w, offset);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated MAX_DATA frame, offset=%\"\n                                                                PRIu64, offset);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_MAX_DATA, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_frame_types |= QUIC_FTBIT_MAX_DATA;\n    conn->ifc_send_flags &= ~SF_SEND_MAX_DATA;\n    conn->ifc_last_max_data_off_sent = offset;\n}\n\n\nstatic void\ngenerate_new_token_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    const struct network_path *path;\n    ssize_t token_sz;\n    size_t need;\n    int w;\n    unsigned char token_buf[MAX_RETRY_TOKEN_LEN];\n\n    path = &conn->ifc_paths[conn->ifc_cur_path_id].cop_path;\n    token_sz = lsquic_tg_token_size(conn->ifc_enpub->enp_tokgen, TOKEN_RESUME,\n                                                            NP_PEER_SA(path));\n    need = conn->ifc_conn.cn_pf->pf_new_token_frame_size(token_sz);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    token_sz = lsquic_tg_generate_resume(conn->ifc_enpub->enp_tokgen, token_buf,\n                                        sizeof(token_buf), NP_PEER_SA(path));\n    if (token_sz < 0)\n    {\n        LSQ_WARN(\"could not generate resume token\");\n        conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN; /* Let's not try again */\n        return;\n    }\n\n    w = conn->ifc_conn.cn_pf->pf_gen_new_token_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), token_buf, token_sz);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating NEW_TOKEN frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte NEW_TOKEN frame\", w);\n    EV_LOG_GENERATED_NEW_TOKEN_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_NEW_TOKEN, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_NEW_TOKEN;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN;\n    (void) token_sz;\n}\n\n\nstatic int\ncan_issue_cids (const struct ietf_full_conn *conn)\n{\n    int can;\n\n    can = ((1 << conn->ifc_conn.cn_n_cces) - 1\n                                            != conn->ifc_conn.cn_cces_mask)\n       && conn->ifc_enpub->enp_settings.es_scid_len\n       && conn->ifc_active_cids_count < conn->ifc_active_cids_limit;\n    LSQ_DEBUG(\"can issue CIDs: %d (n_cces %hhu; mask: 0x%hhX; \"\n                                        \"active: %hhu; limit: %hhu)\",\n        can, conn->ifc_conn.cn_n_cces, conn->ifc_conn.cn_cces_mask,\n        conn->ifc_active_cids_count, conn->ifc_active_cids_limit);\n    return can;\n}\n\n\nstatic int\ngenerate_new_cid_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_cid_elem *cce;\n    size_t need;\n    int w;\n    unsigned char token_buf[IQUIC_SRESET_TOKEN_SZ];\n\n    assert(conn->ifc_enpub->enp_settings.es_scid_len);\n\n    need = conn->ifc_conn.cn_pf->pf_new_connection_id_frame_size(\n            conn->ifc_scid_seqno, conn->ifc_enpub->enp_settings.es_scid_len);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    if (!(cce = ietf_full_conn_add_scid(conn, conn->ifc_enpub, 0, now)))\n    {\n        ABORT_WARN(\"cannot add a new SCID\");\n        return -1;\n    }\n\n    lsquic_tg_generate_sreset(conn->ifc_enpub->enp_tokgen, &cce->cce_cid,\n                                                                    token_buf);\n\n    if (0 != lsquic_engine_add_cid(conn->ifc_enpub, &conn->ifc_conn,\n                                                        cce - conn->ifc_cces))\n    {\n        ABORT_WARN(\"cannot track new SCID\");\n        return -1;\n    }\n\n    w = conn->ifc_conn.cn_pf->pf_gen_new_connection_id_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), cce->cce_seqno,\n            &cce->cce_cid, token_buf, sizeof(token_buf));\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating NEW_CONNECTION_ID frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUGC(\"generated %d-byte NEW_CONNECTION_ID frame (CID: %\"CID_FMT\")\",\n        w, CID_BITS(&cce->cce_cid));\n    EV_LOG_GENERATED_NEW_CONNECTION_ID_FRAME(LSQUIC_LOG_CONN_ID,\n        conn->ifc_conn.cn_pf, packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_NEW_CONNECTION_ID, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_NEW_CONNECTION_ID;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    if (!can_issue_cids(conn))\n    {\n        conn->ifc_send_flags &= ~SF_SEND_NEW_CID;\n        LSQ_DEBUG(\"All %u SCID slots have been assigned\",\n                                                conn->ifc_conn.cn_n_cces);\n    }\n\n    return 0;\n}\n\n\nstatic void\nmaybe_get_rate_available_scid_slot (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    const struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct conn_cid_elem *cce;\n    unsigned active_cid;\n    lsquic_time_t total_elapsed, elapsed_thresh, period, wait_time;\n\n    if (!conn->ifc_enpub->enp_settings.es_scid_iss_rate)\n    {\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n        return;\n    }\n\n    /* period: usec per cid */\n    period = (60 * 1000000) / conn->ifc_enpub->enp_settings.es_scid_iss_rate;\n    active_cid = 0;\n    total_elapsed = 0;\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n    {\n        if ((cce->cce_flags & (CCE_SEQNO|CCE_PORT)) == CCE_SEQNO)\n        {\n            active_cid += 1;\n            /* When server is promoted, the timestamp may be larger than the\n             * first tick time.\n             */\n            if (now > conn->ifc_scid_timestamp[cce - lconn->cn_cces])\n                total_elapsed +=\n                        now - conn->ifc_scid_timestamp[cce - lconn->cn_cces];\n        }\n    }\n    elapsed_thresh = ((active_cid * (active_cid + 1)) / 2) * period;\n    /* compare total elapsed usec to elapsed usec threshold */\n    if (total_elapsed < elapsed_thresh)\n    {\n        wait_time = (elapsed_thresh - total_elapsed) / active_cid;\n        LSQ_DEBUG(\"cid_throt no SCID slots available (rate-limited), \"\n                    \"must wait %\"PRIu64\" usec\", wait_time);\n        lsquic_alarmset_set(&conn->ifc_alset, AL_CID_THROT, now + wait_time);\n        conn->ifc_send_flags &= ~SF_SEND_NEW_CID;\n    }\n    else\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n}\n\n\nstatic void\ngenerate_new_cid_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    int s;\n\n    do\n    {\n        s = generate_new_cid_frame(conn, now);\n        if (s < 0)\n            break;\n        if (conn->ifc_send_flags & SF_SEND_NEW_CID)\n            maybe_get_rate_available_scid_slot(conn, now);\n    }\n    while (conn->ifc_send_flags & SF_SEND_NEW_CID);\n    LOG_SCIDS(conn);\n}\n\n\nstatic int\ngenerate_retire_cid_frame (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    struct dcid_elem *dce;\n    size_t need;\n    int w;\n\n    dce = TAILQ_FIRST(&conn->ifc_to_retire);\n    assert(dce);\n\n    need = conn->ifc_conn.cn_pf->pf_retire_cid_frame_size(dce->de_seqno);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_retire_cid_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), dce->de_seqno);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating RETIRE_CONNECTION_ID frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated %d-byte RETIRE_CONNECTION_ID frame (seqno: %u)\",\n        w, dce->de_seqno);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated RETIRE_CONNECTION_ID \"\n                                            \"frame, seqno=%u\", dce->de_seqno);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                QUIC_FRAME_RETIRE_CONNECTION_ID, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_RETIRE_CONNECTION_ID;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    TAILQ_REMOVE(&conn->ifc_to_retire, dce, de_next_to_ret);\n    lsquic_malo_put(dce);\n\n    if (TAILQ_EMPTY(&conn->ifc_to_retire))\n        conn->ifc_send_flags &= ~SF_SEND_RETIRE_CID;\n\n    return 0;\n}\n\n\nstatic void\ngenerate_retire_cid_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    int s;\n\n    do\n        s = generate_retire_cid_frame(conn);\n    while (0 == s && (conn->ifc_send_flags & SF_SEND_RETIRE_CID));\n}\n\n\nstatic void\ngenerate_streams_blocked_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    struct lsquic_packet_out *packet_out;\n    uint64_t limit;\n    size_t need;\n    int w;\n\n    limit = conn->ifc_send.streams_blocked[sd];\n    need = conn->ifc_conn.cn_pf->pf_streams_blocked_frame_size(limit);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_streams_blocked_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), sd == SD_UNI, limit);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating STREAMS_BLOCKED frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte STREAMS_BLOCKED frame (uni: %d, \"\n                                \"limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte STREAMS_BLOCKED \"\n                \"frame (uni: %d, limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_STREAMS_BLOCKED, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_STREAM_BLOCKED;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    conn->ifc_send_flags &= ~(SF_SEND_STREAMS_BLOCKED << sd);\n}\n\n\nstatic void\ngenerate_streams_blocked_uni_frame (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    generate_streams_blocked_frame(conn, SD_UNI);\n}\n\n\nstatic void\ngenerate_streams_blocked_bidi_frame (struct ietf_full_conn *conn,\n                                                            lsquic_time_t now)\n{\n    generate_streams_blocked_frame(conn, SD_BIDI);\n}\n\n\nstatic void\ngenerate_max_streams_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    struct lsquic_packet_out *packet_out;\n    enum stream_id_type sit;\n    uint64_t limit;\n    size_t need;\n    int w;\n\n    limit = conn->ifc_closed_peer_streams[sd] + conn->ifc_max_streams_in[sd];\n    need = conn->ifc_conn.cn_pf->pf_max_streams_frame_size(limit);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_max_streams_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), sd, limit);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating MAX_STREAMS frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte MAX_STREAMS frame (uni: %d, \"\n                                \"limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte MAX_STREAMS \"\n                \"frame (uni: %d, limit: %\"PRIu64\")\", w, sd == SD_UNI, limit);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_MAX_STREAMS, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_MAX_STREAMS;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    conn->ifc_send_flags &= ~(SF_SEND_MAX_STREAMS << sd);\n\n    sit = gen_sit(!(conn->ifc_flags & IFC_SERVER), sd);\n    LSQ_DEBUG(\"max_allowed_stream_id[ %u ] goes from %\"PRIu64\" to %\"PRIu64,\n        sit, conn->ifc_max_allowed_stream_id[ sit ], limit << SIT_SHIFT);\n    conn->ifc_max_allowed_stream_id[ sit ] = limit << SIT_SHIFT;\n}\n\n\nstatic void\ngenerate_max_streams_uni_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_max_streams_frame(conn, SD_UNI);\n}\n\n\nstatic void\ngenerate_max_streams_bidi_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_max_streams_frame(conn, SD_BIDI);\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_blocked_frame (struct ietf_full_conn *conn)\n{\n    const uint64_t offset = conn->ifc_pub.conn_cap.cc_blocked;\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_blocked_frame_size(offset);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_blocked_frame(\n        packet_out->po_data + packet_out->po_data_sz,\n        lsquic_packet_out_avail(packet_out), offset);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating BLOCKED frame failed: %d\", errno);\n        return 0;\n    }\n    LSQ_DEBUG(\"generated %d-byte BLOCKED frame (offset: %\"PRIu64\")\", w, offset);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated BLOCKED frame, offset=%\"\n                                                                PRIu64, offset);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_BLOCKED, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_BLOCKED;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    return 1;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_max_stream_data_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    uint64_t off;\n    int sz;\n\n    off = lsquic_stream_fc_recv_off_const(stream);\n    need = conn->ifc_conn.cn_pf->pf_max_stream_data_frame_size(stream->id, off);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n    sz = conn->ifc_conn.cn_pf->pf_gen_max_stream_data_frame(\n                         packet_out->po_data + packet_out->po_data_sz,\n                         lsquic_packet_out_avail(packet_out), stream->id, off);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"Generating MAX_STREAM_DATA frame failed\");\n        return 0;\n    }\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated %d-byte MAX_STREAM_DATA \"\n        \"frame; stream_id: %\"PRIu64\"; offset: %\"PRIu64, sz, stream->id, off);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_MAX_STREAM_DATA, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_MAX_STREAM_DATA;\n    lsquic_stream_max_stream_data_sent(stream);\n    return 1;\n}\n\n\nstatic int\ngenerate_stop_sending_frame_by_id (struct ietf_full_conn *conn,\n                lsquic_stream_id_t stream_id, enum http_error_code error_code)\n{\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_stop_sending_frame_size(stream_id,\n                                                                    error_code);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return -1;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_stop_sending_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            stream_id, error_code);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating STOP_SENDING frame failed: %d\", errno);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated %d-byte STOP_SENDING frame (stream id: %\"PRIu64\", \"\n        \"error code: %u)\", w, stream_id, error_code);\n    EV_LOG_GENERATED_STOP_SENDING_FRAME(LSQUIC_LOG_CONN_ID, stream_id,\n                                                                error_code);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_STOP_SENDING, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return -1;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_STOP_SENDING;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n\n    return 0;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_stop_sending_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    if (0 == generate_stop_sending_frame_by_id(conn, stream->id, HEC_NO_ERROR))\n    {\n        lsquic_stream_ss_frame_sent(stream);\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic void\ngenerate_stop_sending_frames (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct stream_id_to_ss *sits;\n\n    assert(conn->ifc_send_flags & SF_SEND_STOP_SENDING);\n\n    while (!STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n    {\n        sits = STAILQ_FIRST(&conn->ifc_stream_ids_to_ss);\n        if (0 == generate_stop_sending_frame_by_id(conn, sits->sits_stream_id,\n                                                        sits->sits_error_code))\n        {\n            STAILQ_REMOVE_HEAD(&conn->ifc_stream_ids_to_ss, sits_next);\n            free(sits);\n        }\n        else\n            break;\n    }\n\n    if (STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n        conn->ifc_send_flags &= ~SF_SEND_STOP_SENDING;\n}\n\n\n/* Return true if generated, false otherwise */\nstatic int\ngenerate_rst_stream_frame (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    lsquic_packet_out_t *packet_out;\n    unsigned need;\n    int sz;\n\n    need = conn->ifc_conn.cn_pf->pf_rst_frame_size(stream->id,\n                                    stream->tosend_off, stream->error_code);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for RESET_STREAM frame\");\n        return 0;\n    }\n    sz = conn->ifc_conn.cn_pf->pf_gen_rst_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out), stream->id,\n                            stream->tosend_off, stream->error_code);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"gen_rst_frame failed\");\n        return 0;\n    }\n    if (0 != lsquic_packet_out_add_stream(packet_out, conn->ifc_pub.mm, stream,\n                            QUIC_FRAME_RST_STREAM, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return 0;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_RST_STREAM;\n    lsquic_stream_rst_frame_sent(stream);\n    LSQ_DEBUG(\"wrote RST: stream %\"PRIu64\"; offset %\"PRIu64\"; error code \"\n              \"%\"PRIu64, stream->id, stream->tosend_off, stream->error_code);\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"generated RESET_STREAM: stream \"\n        \"%\"PRIu64\"; offset %\"PRIu64\"; error code %\"PRIu64, stream->id,\n        stream->tosend_off, stream->error_code);\n\n    return 1;\n}\n\n\nstatic int\nis_our_stream (const struct ietf_full_conn *conn,\n                                        const struct lsquic_stream *stream)\n{\n    const unsigned is_server = !!(conn->ifc_flags & IFC_SERVER);\n    return (1 & stream->id) == is_server;\n}\n\n\nstatic int\nis_peer_initiated (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    const unsigned is_server = !!(conn->ifc_flags & IFC_SERVER);\n    return (1 & stream_id) != is_server;\n}\n\n\nstatic void\nsched_max_bidi_streams (void *conn_p)\n{\n    struct ietf_full_conn *conn = conn_p;\n\n    conn->ifc_send_flags |= SF_SEND_MAX_STREAMS_BIDI;\n    conn->ifc_delayed_send &= ~SF_SEND_MAX_STREAMS_BIDI;\n    LSQ_DEBUG(\"schedule MAX_STREAMS frame for bidirectional streams (was \"\n        \"delayed)\");\n}\n\n\n/* Do not allow peer to open more streams while QPACK decoder stream has\n * unsent data.\n */\nstatic int\ncan_give_peer_streams_credit (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    /* This logic only applies to HTTP servers. */\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) != (IFC_SERVER|IFC_HTTP))\n        return 1;\n    /* HTTP client does not open unidirectional streams (other than the\n     * standard three), not applicable.\n     */\n    if (SD_UNI == sd)\n        return 1;\n    if (conn->ifc_delayed_send & (SF_SEND_MAX_STREAMS << sd))\n        return 0;\n    if (lsquic_qdh_arm_if_unsent(&conn->ifc_qdh, sched_max_bidi_streams, conn))\n    {\n        LSQ_DEBUG(\"delay sending more streams credit to peer until QPACK \"\n            \"decoder sends unsent data\");\n        conn->ifc_delayed_send |= SF_SEND_MAX_STREAMS << sd;\n        return 0;\n    }\n    else\n        return 1;\n}\n\n\n/* Because stream IDs are distributed unevenly, it is more efficient to\n * maintain four sets of closed stream IDs.\n */\nstatic void\nconn_mark_stream_closed (struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    lsquic_stream_id_t shifted_id;\n    uint64_t max_allowed, thresh;\n    enum stream_id_type idx;\n    enum stream_dir sd;\n\n    idx = stream_id & SIT_MASK;\n    shifted_id = stream_id >> SIT_SHIFT;\n\n    if (is_peer_initiated(conn, stream_id)\n            && !lsquic_set64_has(&conn->ifc_closed_stream_ids[idx], shifted_id))\n    {\n        sd = (stream_id >> SD_SHIFT) & 1;\n        ++conn->ifc_closed_peer_streams[sd];\n        if (0 == (conn->ifc_send_flags & (SF_SEND_MAX_STREAMS << sd)))\n        {\n            max_allowed = conn->ifc_max_allowed_stream_id[idx] >> SIT_SHIFT;\n            thresh = conn->ifc_closed_peer_streams[sd]\n                                            + conn->ifc_max_streams_in[sd] / 2;\n            if (thresh >= max_allowed && can_give_peer_streams_credit(conn, sd))\n            {\n                LSQ_DEBUG(\"closed incoming %sdirectional streams reached \"\n                    \"%\"PRIu64\", scheduled MAX_STREAMS frame\",\n                    sd == SD_UNI ? \"uni\" : \"bi\",\n                    conn->ifc_closed_peer_streams[sd]);\n                conn->ifc_send_flags |= SF_SEND_MAX_STREAMS << sd;\n            }\n        }\n    }\n\n    if (0 == lsquic_set64_add(&conn->ifc_closed_stream_ids[idx], shifted_id))\n        LSQ_DEBUG(\"marked stream %\"PRIu64\" as closed\", stream_id);\n    else\n        ABORT_ERROR(\"could not add element to set: %s\", strerror(errno));\n}\n\n\nstatic int\nconn_is_stream_closed (struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type idx = stream_id & SIT_MASK;\n    stream_id >>= SIT_SHIFT;\n    return lsquic_set64_has(&conn->ifc_closed_stream_ids[idx], stream_id);\n}\n\n\nstatic int\neither_side_going_away (const struct ietf_full_conn *conn)\n{\n    return (conn->ifc_flags & IFC_GOING_AWAY)\n        || (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY);\n}\n\n\nstatic void\nmaybe_create_delayed_streams (struct ietf_full_conn *conn)\n{\n    unsigned avail, delayed;\n\n    delayed = conn->ifc_n_delayed_streams;\n    if (0 == delayed)\n        return;\n\n    avail = ietf_full_conn_ci_n_avail_streams(&conn->ifc_conn);\n    while (avail > 0)\n    {\n        if (0 == create_bidi_stream_out(conn))\n        {\n            --avail;\n            --conn->ifc_n_delayed_streams;\n            if (0 == conn->ifc_n_delayed_streams)\n                break;\n        }\n        else\n        {\n            LSQ_INFO(\"cannot create BIDI stream\");\n            break;\n        }\n    }\n\n    LSQ_DEBUG(\"created %u delayed stream%.*s\",\n        delayed - conn->ifc_n_delayed_streams,\n        delayed - conn->ifc_n_delayed_streams != 1, \"s\");\n}\n\n\nstatic int\nhave_bidi_streams (const struct ietf_full_conn *conn)\n{\n    const struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                         el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (SIT_BIDI_CLIENT == (stream->id & SIT_MASK))\n            return 1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nconn_ok_to_close (const struct ietf_full_conn *conn)\n{\n    assert(conn->ifc_flags & IFC_CLOSING);\n    return !(conn->ifc_flags & IFC_SERVER)\n        || (conn->ifc_flags & IFC_RECV_CLOSE)\n        || (\n               !lsquic_send_ctl_have_outgoing_stream_frames(&conn->ifc_send_ctl)\n            && !have_bidi_streams(conn)\n            && !lsquic_send_ctl_have_unacked_stream_frames(\n                                                    &conn->ifc_send_ctl));\n}\n\n\nstatic void\nmaybe_close_conn (struct ietf_full_conn *conn)\n{\n    if ((conn->ifc_flags & (IFC_CLOSING|IFC_GOING_AWAY|IFC_SERVER))\n                                            == (IFC_GOING_AWAY|IFC_SERVER)\n        && !have_bidi_streams(conn))\n    {\n        conn->ifc_flags |= IFC_CLOSING|IFC_GOAWAY_CLOSE;\n        LSQ_DEBUG(\"maybe_close_conn: GOAWAY sent and no responses remain\");\n        if (conn_ok_to_close(conn))\n        {\n            conn->ifc_send_flags |= SF_SEND_CONN_CLOSE;\n            LSQ_DEBUG(\"maybe_close_conn: ok to close: \"\n                      \"schedule to send CONNECTION_CLOSE\");\n        }\n    }\n}\n\n\nstatic void\nservice_streams (struct ietf_full_conn *conn)\n{\n    struct lsquic_hash_elem *el;\n    lsquic_stream_t *stream, *next;\n\n    for (stream = TAILQ_FIRST(&conn->ifc_pub.service_streams); stream;\n                                                                stream = next)\n    {\n        next = TAILQ_NEXT(stream, next_service_stream);\n        if (stream->sm_qflags & SMQF_ABORT_CONN)\n            /* No need to unset this flag or remove this stream: the connection\n             * is about to be aborted.\n             */\n            ABORT_ERROR(\"aborted due to error in stream %\"PRIu64, stream->id);\n        if (stream->sm_qflags & SMQF_CALL_ONCLOSE)\n            lsquic_stream_call_on_close(stream);\n        if (stream->sm_qflags & SMQF_FREE_STREAM)\n        {\n            TAILQ_REMOVE(&conn->ifc_pub.service_streams, stream,\n                                                        next_service_stream);\n            if (!(stream->sm_bflags & SMBF_CRYPTO))\n            {\n                el = lsquic_hash_find(conn->ifc_pub.all_streams,\n                                            &stream->id, sizeof(stream->id));\n                if (el)\n                    lsquic_hash_erase(conn->ifc_pub.all_streams, el);\n                conn_mark_stream_closed(conn, stream->id);\n            }\n            else\n                assert(!(stream->sm_hash_el.qhe_flags & QHE_HASHED));\n            lsquic_stream_destroy(stream);\n        }\n    }\n\n    /* TODO: this chunk of code, too, should probably live elsewhere */\n    if (either_side_going_away(conn))\n    {\n        while (conn->ifc_n_delayed_streams)\n        {\n            --conn->ifc_n_delayed_streams;\n            LSQ_DEBUG(\"goaway mode: delayed stream results in null ctor\");\n            (void) conn->ifc_enpub->enp_stream_if->on_new_stream(\n                                    conn->ifc_enpub->enp_stream_if_ctx, NULL);\n        }\n        maybe_close_conn(conn);\n    }\n    else\n        maybe_create_delayed_streams(conn);\n}\n\n\nstatic int\nprocess_stream_ready_to_send (struct ietf_full_conn *conn,\n                                            struct lsquic_stream *stream)\n{\n    int r = 1;\n    if (stream->sm_qflags & SMQF_SEND_MAX_STREAM_DATA)\n        r &= generate_max_stream_data_frame(conn, stream);\n    if (stream->sm_qflags & SMQF_SEND_BLOCKED)\n        r &= lsquic_sendctl_gen_stream_blocked_frame(&conn->ifc_send_ctl, stream);\n    if (stream->sm_qflags & SMQF_SEND_RST)\n        r &= generate_rst_stream_frame(conn, stream);\n    if (stream->sm_qflags & SMQF_SEND_STOP_SENDING)\n        r &= generate_stop_sending_frame(conn, stream);\n    return r;\n}\n\n\nstatic void\nprocess_streams_ready_to_send (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    union prio_iter pi;\n\n    assert(!TAILQ_EMPTY(&conn->ifc_pub.sending_streams));\n\n    conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.sending_streams),\n        TAILQ_LAST(&conn->ifc_pub.sending_streams, lsquic_streams_tailq),\n        (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_send_stream),\n        &conn->ifc_pub, \"send\", NULL, NULL);\n\n    for (stream = conn->ifc_pii->pii_first(&pi); stream;\n                                    stream = conn->ifc_pii->pii_next(&pi))\n        if (!process_stream_ready_to_send(conn, stream))\n            break;\n\n    conn->ifc_pii->pii_cleanup(&pi);\n}\n\n\nstatic void\nietf_full_conn_ci_write_ack (struct lsquic_conn *lconn,\n                                        struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    generate_ack_frame_for_pns(conn, packet_out, PNS_APP, lsquic_time_now());\n}\n\n\nstatic int\nietf_full_conn_ci_want_datagram_write (struct lsquic_conn *lconn, int is_want)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    int old;\n\n    if (conn->ifc_flags & IFC_DATAGRAMS)\n    {\n        old = !!(conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE);\n        if (is_want)\n        {\n            conn->ifc_mflags |= MF_WANT_DATAGRAM_WRITE;\n            if (lsquic_send_ctl_can_send (&conn->ifc_send_ctl))\n                lsquic_engine_add_conn_to_tickable(conn->ifc_enpub,\n                                                             &conn->ifc_conn);\n        }\n        else\n            conn->ifc_mflags &= ~MF_WANT_DATAGRAM_WRITE;\n        LSQ_DEBUG(\"turn %s \\\"want datagram write\\\" flag\",\n                                                    is_want ? \"on\" : \"off\");\n        return old;\n    }\n    else\n        return -1;\n}\n\n\nstatic void\nietf_full_conn_ci_client_call_on_new (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    assert(conn->ifc_flags & IFC_CREATED_OK);\n    lconn->cn_conn_ctx = conn->ifc_enpub->enp_stream_if->on_new_conn(\n                                conn->ifc_enpub->enp_stream_if_ctx, lconn);\n}\n\n\nstatic void\nietf_full_conn_ci_close (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_dir sd;\n\n    if (!(conn->ifc_flags & IFC_CLOSING))\n    {\n        for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n        {\n            stream = lsquic_hashelem_getdata(el);\n            sd = (stream->id >> SD_SHIFT) & 1;\n            if (SD_BIDI == sd)\n                lsquic_stream_maybe_reset(stream, 0, 1);\n        }\n        conn->ifc_flags |= IFC_CLOSING;\n        if (conn_ok_to_close(conn))\n        {\n            conn->ifc_send_flags |= SF_SEND_CONN_CLOSE;\n            LSQ_DEBUG(\"ietf_full_conn_ci_close: ok to close: \"\n                      \"schedule to send CONNECTION_CLOSE\");\n        }\n        lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_abort (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    LSQ_INFO(\"User aborted connection\");\n    conn->ifc_flags |= IFC_ABORTED;\n    lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n}\n\n\nstatic void\nretire_dcid (struct ietf_full_conn *conn, struct dcid_elem **dce)\n{\n    if ((*dce)->de_hash_el.qhe_flags & QHE_HASHED)\n        lsquic_hash_erase(conn->ifc_enpub->enp_srst_hash, &(*dce)->de_hash_el);\n    TAILQ_INSERT_TAIL(&conn->ifc_to_retire, *dce, de_next_to_ret);\n    LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32\"\", (*dce)->de_seqno);\n    *dce = NULL;\n    conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n}\n\n\nstatic void\nretire_seqno (struct ietf_full_conn *conn, unsigned seqno)\n{\n    struct dcid_elem *dce;\n\n    dce = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n    if (dce)\n    {\n        memset(dce, 0, sizeof(*dce));\n        dce->de_seqno = seqno;\n        TAILQ_INSERT_TAIL(&conn->ifc_to_retire, dce, de_next_to_ret);\n        LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32, seqno);\n        conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n    }\n    else\n        LSQ_INFO(\"%s: cannot allocate dce\", __func__);\n}\n\n\n/* This function exists for testing purposes.\n *\n * The user can switch DCIDs and request that the old DCID is retired.\n *\n * If the user calls this function frequently in a short amount of time,\n * this should trigger the CID issuance throttling.\n */\nstatic void\nietf_full_conn_ci_retire_cid (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct dcid_elem **el, **dces[2];\n    int eq;\n    /*\n     * Find two DCIDs:\n     *  1. the current DCID that will be retire_cid\n     *  2. an available DCID that will be switched\n     * Continue searching until there are no more DCIDs\n     * or when both DCIDs are found.\n     */\n    dces[0] = NULL; // future DCID  (does not match current DCID)\n    dces[1] = NULL; // current DCID (does match current DCID)\n    for (el = conn->ifc_dces; el < DCES_END(conn) && !(dces[0] && dces[1]); ++el)\n        if (*el)\n        {\n            eq = LSQUIC_CIDS_EQ(&(*el)->de_cid, CUR_DCID(conn));\n            if (!dces[eq])\n                dces[eq] = el;\n        }\n    if (!dces[1])\n    {\n        ABORT_WARN(\"%s: cannot find own DCID\", __func__);\n        return;\n    }\n    if (!dces[0])\n    {\n        LSQ_INFO(\"No DCID available: cannot switch\");\n        /* TODO: implemened delayed switch */\n        // conn->ifc_flags |= IFC_SWITCH_DCID;\n        return;\n    }\n    /*\n     * Switch DCID.\n     */\n    *CUR_DCID(conn) = (*dces[0])->de_cid;\n    if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n        CUR_CPATH(conn)->cop_spin_bit = 0;\n    LSQ_INFOC(\"switched DCID to %\"CID_FMT, CID_BITS(CUR_DCID(conn)));\n    /*\n     * Mark old DCID for retirement.\n     */\n    retire_dcid(conn, dces[1]);\n}\n\n\nstatic void\ndrop_crypto_streams (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **streamp;\n    unsigned count;\n\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_PROC_CRYPTO)) != IFC_PROC_CRYPTO)\n        return;\n\n    conn->ifc_flags &= ~IFC_PROC_CRYPTO;\n\n    count = 0;\n    for (streamp = conn->ifc_u.cli.crypto_streams; streamp <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++streamp)\n        if (*streamp)\n        {\n            lsquic_stream_force_finish(*streamp);\n            *streamp = NULL;\n            ++count;\n        }\n\n    LSQ_DEBUG(\"dropped %u crypto stream%.*s\", count, count != 1, \"s\");\n}\n\n\nstatic void\nietf_full_conn_ci_destroy (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream **streamp, *stream;\n    struct stream_id_to_ss *sits;\n    struct dcid_elem **dcep, *dce;\n    struct lsquic_hash_elem *el;\n    unsigned i;\n\n    if (!(conn->ifc_flags & IFC_SERVER))\n    {\n        for (streamp = conn->ifc_u.cli.crypto_streams; streamp <\n                conn->ifc_u.cli.crypto_streams\n                    + sizeof(conn->ifc_u.cli.crypto_streams)\n                        / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++streamp)\n            if (*streamp)\n                lsquic_stream_destroy(*streamp);\n    }\n    while ((el = lsquic_hash_first(conn->ifc_pub.all_streams)))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        lsquic_hash_erase(conn->ifc_pub.all_streams, el);\n        lsquic_stream_destroy(stream);\n    }\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        lsquic_qdh_cleanup(&conn->ifc_qdh);\n        lsquic_qeh_cleanup(&conn->ifc_qeh);\n    }\n    for (dcep = conn->ifc_dces; dcep < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++dcep)\n        if (*dcep)\n        {\n            if ((*dcep)->de_hash_el.qhe_flags & QHE_HASHED)\n                lsquic_hash_erase(conn->ifc_enpub->enp_srst_hash,\n                                                        &(*dcep)->de_hash_el);\n            lsquic_malo_put(*dcep);\n        }\n    while ((dce = TAILQ_FIRST(&conn->ifc_to_retire)))\n    {\n        TAILQ_REMOVE(&conn->ifc_to_retire, dce, de_next_to_ret);\n        lsquic_malo_put(dce);\n    }\n    lsquic_send_ctl_cleanup(&conn->ifc_send_ctl);\n    for (i = 0; i < N_PNS; ++i)\n        lsquic_rechist_cleanup(&conn->ifc_rechist[i]);\n    lsquic_malo_destroy(conn->ifc_pub.packet_out_malo);\n    if (conn->ifc_flags & IFC_CREATED_OK)\n        conn->ifc_enpub->enp_stream_if->on_conn_closed(&conn->ifc_conn);\n    assert(conn->ifc_conn.cn_conn_ctx == NULL);\n    if (conn->ifc_conn.cn_enc_session)\n        conn->ifc_conn.cn_esf.i->esfi_destroy(conn->ifc_conn.cn_enc_session);\n    while (!STAILQ_EMPTY(&conn->ifc_stream_ids_to_ss))\n    {\n        sits = STAILQ_FIRST(&conn->ifc_stream_ids_to_ss);\n        STAILQ_REMOVE_HEAD(&conn->ifc_stream_ids_to_ss, sits_next);\n        free(sits);\n    }\n    if (conn->ifc_flags & IFC_SERVER)\n    {\n        if (conn->ifc_pub.u.ietf.promises)\n            lsquic_hash_destroy(conn->ifc_pub.u.ietf.promises);\n    }\n    for (i = 0; i < N_SITS; ++i)\n        lsquic_set64_cleanup(&conn->ifc_closed_stream_ids[i]);\n    if (conn->ifc_bpus)\n    {\n        for (el = lsquic_hash_first(conn->ifc_bpus); el;\n                                        el = lsquic_hash_next(conn->ifc_bpus))\n            free(lsquic_hashelem_getdata(el));\n        lsquic_hash_destroy(conn->ifc_bpus);\n    }\n    lsquic_hash_destroy(conn->ifc_pub.all_streams);\n#if LSQUIC_CONN_STATS\n    if (conn->ifc_flags & IFC_CREATED_OK)\n    {\n        LSQ_NOTICE(\"# ticks: %lu\", conn->ifc_stats.n_ticks);\n        LSQ_NOTICE(\"sent %lu packets\", conn->ifc_stats.out.packets);\n        LSQ_NOTICE(\"received %lu packets, of which %lu were not decryptable, %lu were \"\n            \"dups and %lu were errors; sent %lu packets, avg stream data per outgoing\"\n            \" packet is %lu bytes\",\n            conn->ifc_stats.in.packets, conn->ifc_stats.in.undec_packets,\n            conn->ifc_stats.in.dup_packets, conn->ifc_stats.in.err_packets,\n            conn->ifc_stats.out.packets,\n            conn->ifc_stats.out.stream_data_sz /\n                (conn->ifc_stats.out.packets ? conn->ifc_stats.out.packets : 1));\n        if (conn->ifc_flags & IFC_DELAYED_ACKS)\n            LSQ_NOTICE(\"delayed ACKs settings: (%u/%.3f/%.3f/%.3f/%.3f/%.3f); \"\n                \"packet tolerances sent: count: %u, min: %u, max: %u\",\n                conn->ifc_settings->es_ptpc_periodicity,\n                conn->ifc_settings->es_ptpc_target,\n                conn->ifc_settings->es_ptpc_prop_gain,\n                conn->ifc_settings->es_ptpc_int_gain,\n                conn->ifc_settings->es_ptpc_err_thresh,\n                conn->ifc_settings->es_ptpc_err_divisor,\n                conn->ifc_ack_freq_seqno,\n                conn->ifc_min_pack_tol_sent, conn->ifc_max_pack_tol_sent);\n        LSQ_NOTICE(\"ACKs: delayed acks on: %s; in: %lu; processed: %lu; merged: %lu\",\n            conn->ifc_flags & IFC_DELAYED_ACKS ? \"yes\" : \"no\",\n            conn->ifc_stats.in.n_acks, conn->ifc_stats.in.n_acks_proc,\n            conn->ifc_stats.in.n_acks_merged);\n    }\n    if (conn->ifc_last_stats)\n        free(conn->ifc_last_stats);\n#endif\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"full connection destroyed\");\n    free(conn->ifc_errmsg);\n    free(conn);\n}\n\n\nstatic uint64_t\ncalc_drain_time (const struct ietf_full_conn *conn)\n{\n    lsquic_time_t drain_time, pto, srtt, var;\n\n    /* PTO Calculation: [draft-ietf-quic-recovery-18], Section 6.2.2.1;\n     * Drain time: [draft-ietf-quic-transport-19], Section 10.1.\n     */\n    srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n    var = lsquic_rtt_stats_get_rttvar(&conn->ifc_pub.rtt_stats);\n    pto = srtt + 4 * var + TP_DEF_MAX_ACK_DELAY * 1000;\n    drain_time = 3 * pto;\n\n    return drain_time;\n}\n\n\nstatic lsquic_time_t\nietf_full_conn_ci_drain_time (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_time_t drain_time;\n\n    /* Only applicable to a server whose connection was not timed out */\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_TIMED_OUT)) != IFC_SERVER)\n    {\n        LSQ_DEBUG(\"drain time is zero (don't drain)\");\n        return 0;\n    }\n\n    drain_time = calc_drain_time(conn);\n    LSQ_DEBUG(\"drain time is %\"PRIu64\" usec\", drain_time);\n    return drain_time;\n}\n\n\nstatic void\nietf_full_conn_ci_going_away (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    if (conn->ifc_flags & IFC_HTTP)\n    {\n        if (!(conn->ifc_flags & (IFC_CLOSING|IFC_GOING_AWAY)))\n        {\n            LSQ_INFO(\"connection marked as going away, last stream: %\" PRIu64,\n                     conn->ifc_max_req_id);\n            conn->ifc_flags |= IFC_GOING_AWAY;\n            const lsquic_stream_id_t stream_id = conn->ifc_max_req_id + N_SITS;\n            if (valid_stream_id(stream_id))\n            {\n                if (0 == lsquic_hcso_write_goaway(&conn->ifc_hcso,\n                                                        conn->ifc_max_req_id))\n                    lsquic_engine_add_conn_to_tickable(conn->ifc_enpub, lconn);\n                else\n                    /* We're already going away, don't abort because of this */\n                    LSQ_WARN(\"could not write GOAWAY frame\");\n            }\n            maybe_close_conn(conn);\n        }\n    }\n    else\n        LSQ_NOTICE(\"going away has no effect in non-HTTP mode\");\n}\n\n\nstatic void\nhandshake_failed (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    LSQ_DEBUG(\"handshake failed\");\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_HANDSHAKE);\n    conn->ifc_flags |= IFC_HSK_FAILED;\n}\n\n\nstatic struct dcid_elem *\nget_new_dce (struct ietf_full_conn *conn)\n{\n    struct dcid_elem **el;\n\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (!*el)\n            return *el = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n\n    return NULL;\n}\n\n\nstatic void\nqueue_streams_blocked_frame (struct ietf_full_conn *conn, enum stream_dir sd)\n{\n    enum stream_id_type sit;\n    uint64_t limit;\n\n    if (0 == (conn->ifc_send_flags & (SF_SEND_STREAMS_BLOCKED << sd)))\n    {\n        conn->ifc_send_flags |= SF_SEND_STREAMS_BLOCKED << sd;\n        sit = gen_sit(conn->ifc_flags & IFC_SERVER, sd);\n        limit = conn->ifc_max_allowed_stream_id[sit] >> SIT_SHIFT;\n        conn->ifc_send.streams_blocked[sd] = limit;\n        LSQ_DEBUG(\"scheduled %sdirectional STREAMS_BLOCKED (limit=%\"PRIu64\n            \") frame\", sd == SD_BIDI ? \"bi\" : \"uni\", limit);\n    }\n    else\n        LSQ_DEBUG(\"%sdirectional STREAMS_BLOCKED frame already queued\",\n            sd == SD_BIDI ? \"bi\" : \"uni\");\n}\n\n\nstatic void\nretire_cid_from_tp (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct dcid_elem *dce;\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_ERROR(\"cannot allocate DCE\");\n        return;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = params->tp_preferred_address.cid;\n    dce->de_seqno = 1;\n    memcpy(dce->de_srst, params->tp_preferred_address.srst,\n                                                    sizeof(dce->de_srst));\n    dce->de_flags = DE_SRST;\n    TAILQ_INSERT_TAIL(&conn->ifc_to_retire, dce, de_next_to_ret);\n    LSQ_DEBUG(\"prepare to retire DCID seqno %\"PRIu32, dce->de_seqno);\n    conn->ifc_send_flags |= SF_SEND_RETIRE_CID;\n}\n\n\nstatic enum { BM_MIGRATING, BM_NOT_MIGRATING, BM_ERROR, }\ntry_to_begin_migration (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct conn_path *copath;\n    struct dcid_elem *dce;\n    int is_ipv6;\n    union {\n        struct sockaddr_in  v4;\n        struct sockaddr_in6 v6;\n    } sockaddr;\n\n    if (!conn->ifc_settings->es_allow_migration)\n    {\n        LSQ_DEBUG(\"Migration not allowed: retire PreferredAddress CID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    if (conn->ifc_conn.cn_version <= LSQVER_ID27 /* Starting with ID-29,\n        disable_active_migration TP applies only to the time period during\n        the handshake.  Our client does not migrate during the handshake:\n        this code runs only after handshake has succeeded. */\n                && (params->tp_set & (1 << TPI_DISABLE_ACTIVE_MIGRATION)))\n    {\n        LSQ_DEBUG(\"TP disables migration: retire PreferredAddress CID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    is_ipv6 = NP_IS_IPv6(CUR_NPATH(conn));\n    if ((is_ipv6 && !lsquic_tp_has_pref_ipv6(params))\n                || (!is_ipv6 && !lsquic_tp_has_pref_ipv4(params)))\n    {\n        /* XXX This is a limitation in the client code outside of the library.\n         * To support cross-IP-version migration, we need to add some callbacks\n         * to open a different socket.\n         */\n        LSQ_DEBUG(\"Cannot migrate from IPv%u to IPv%u\", is_ipv6 ? 6 : 4,\n            is_ipv6 ? 4 : 6);\n        return BM_NOT_MIGRATING;\n    }\n\n    if (0 == params->tp_preferred_address.cid.len)\n    {\n        /* TODO: mark with a new flag and begin migration when a non-zero length\n         * DCID becomes available.\n         */\n        LSQ_DEBUG(\"Cannot migrate using zero-length DCID\");\n        return BM_NOT_MIGRATING;\n    }\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_WARN(\"cannot allocate DCE\");\n        return BM_ERROR;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = params->tp_preferred_address.cid;\n    dce->de_seqno = 1;\n    dce->de_flags = DE_SRST;\n    memcpy(dce->de_srst, params->tp_preferred_address.srst,\n                                                    sizeof(dce->de_srst));\n    if (conn->ifc_enpub->enp_srst_hash)\n    {\n        if (!lsquic_hash_insert(conn->ifc_enpub->enp_srst_hash,\n                dce->de_srst, sizeof(dce->de_srst), &conn->ifc_conn,\n                &dce->de_hash_el))\n        {\n            lsquic_malo_put(dce);\n            ABORT_WARN(\"cannot insert DCE\");\n            return BM_ERROR;\n        }\n    }\n\n    if (is_ipv6)\n    {\n        sockaddr.v6.sin6_family = AF_INET6;\n        sockaddr.v6.sin6_port   = htons(params->tp_preferred_address.ipv6_port);\n        memcpy(&sockaddr.v6.sin6_addr, params->tp_preferred_address.ipv6_addr,\n                                                sizeof(sockaddr.v6.sin6_addr));\n    }\n    else\n    {\n        sockaddr.v4.sin_family = AF_INET;\n        sockaddr.v4.sin_port   = htons(params->tp_preferred_address.ipv4_port);\n        memcpy(&sockaddr.v4.sin_addr, params->tp_preferred_address.ipv4_addr,\n                                                sizeof(sockaddr.v4.sin_addr));\n    }\n\n    copath = &conn->ifc_paths[1];\n    assert(!(conn->ifc_used_paths & (1 << (copath - conn->ifc_paths))));\n\n    migra_begin(conn, copath, dce, (struct sockaddr *) &sockaddr, params);\n    return BM_MIGRATING;\n}\n\n\nstatic void\nmaybe_start_migration (struct ietf_full_conn *conn)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    const struct transport_params *params;\n\n    params = lconn->cn_esf.i->esfi_get_peer_transport_params(\n                                                        lconn->cn_enc_session);\n    if (params->tp_set & (1 << TPI_PREFERRED_ADDRESS))\n        switch (try_to_begin_migration(conn, params))\n        {\n        case BM_MIGRATING:\n            break;\n        case BM_NOT_MIGRATING:\n            if (lconn->cn_version == LSQVER_ID27)\n                retire_cid_from_tp(conn, params);\n            else\n            {\n/*\n * [draft-ietf-quic-transport-28] Section 5.1.1:\n \"                         Connection IDs that are issued and not\n \" retired are considered active; any active connection ID is valid for\n \" use with the current connection at any time, in any packet type.\n \" This includes the connection ID issued by the server via the\n \" preferred_address transport parameter.\n */\n                LSQ_DEBUG(\"not migrating: save DCID from transport params\");\n                (void) insert_new_dcid(conn, 1,\n                            &params->tp_preferred_address.cid,\n                            params->tp_preferred_address.srst, 0);\n            }\n            break;\n        case BM_ERROR:\n            ABORT_QUIETLY(0, TEC_INTERNAL_ERROR, \"error initiating migration\");\n            break;\n        }\n}\n\n\nstatic int\napply_trans_params (struct ietf_full_conn *conn,\n                                        const struct transport_params *params)\n{\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n    uint64_t limit;\n\n    if ((params->tp_set & (1 << TPI_LOSS_BITS))\n                                    && conn->ifc_settings->es_ql_bits == 2)\n    {\n        LSQ_DEBUG(\"turn on QL loss bits\");\n        lsquic_send_ctl_do_ql_bits(&conn->ifc_send_ctl);\n    }\n\n    if (params->tp_init_max_streams_bidi > (1ull << 60)\n                            || params->tp_init_max_streams_uni > (1ull << 60))\n    {\n        if (params->tp_init_max_streams_bidi > (1ull << 60))\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"init_max_streams_bidi is \"\n                \"too large: %\"PRIu64, params->tp_init_max_streams_bidi);\n        else\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"init_max_streams_uni is \"\n                \"too large: %\"PRIu64, params->tp_init_max_streams_uni);\n        return -1;\n    }\n\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_BIDI);\n    conn->ifc_max_allowed_stream_id[sit] =\n                        params->tp_init_max_streams_bidi << SIT_SHIFT;\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, SD_UNI);\n    conn->ifc_max_allowed_stream_id[sit] =\n                        params->tp_init_max_streams_uni << SIT_SHIFT;\n\n    conn->ifc_max_stream_data_uni      = params->tp_init_max_stream_data_uni;\n\n    if (params->tp_init_max_data < conn->ifc_pub.conn_cap.cc_sent)\n    {\n        ABORT_WARN(\"peer specified init_max_data=%\"PRIu64\" bytes, which is \"\n            \"smaller than the amount of data already sent on this connection \"\n            \"(%\"PRIu64\" bytes)\", params->tp_init_max_data,\n            conn->ifc_pub.conn_cap.cc_sent);\n        return -1;\n    }\n\n    conn->ifc_pub.conn_cap.cc_max = params->tp_init_max_data;\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (is_our_stream(conn, stream))\n            limit = params->tp_init_max_stream_data_bidi_remote;\n        else\n            limit = params->tp_init_max_stream_data_bidi_local;\n        if (0 != lsquic_stream_set_max_send_off(stream, limit))\n        {\n            ABORT_WARN(\"cannot set peer-supplied max_stream_data=%\"PRIu64\n                \"on stream %\"PRIu64, limit, stream->id);\n            return -1;\n        }\n    }\n\n    if (conn->ifc_flags & IFC_SERVER)\n        conn->ifc_cfg.max_stream_send\n                                = params->tp_init_max_stream_data_bidi_local;\n    else\n        conn->ifc_cfg.max_stream_send\n                                = params->tp_init_max_stream_data_bidi_remote;\n    conn->ifc_cfg.ack_exp = params->tp_ack_delay_exponent;\n\n    switch ((!!conn->ifc_settings->es_idle_timeout << 1)\n                | !!params->tp_max_idle_timeout)\n    {\n    case       (0 << 1) | 0:\n        LSQ_DEBUG(\"neither side specified max idle time out, turn it off\");\n        break;\n    case       (0 << 1) | 1:\n        LSQ_DEBUG(\"peer specified max idle timeout of %\"PRIu64\" ms (vs ours \"\n            \"of zero): use it\", params->tp_max_idle_timeout);\n        conn->ifc_idle_to = params->tp_max_idle_timeout * 1000;\n        break;\n    case       (1 << 1) | 0:\n        LSQ_DEBUG(\"peer did not specify max idle timeout, while ours is \"\n            \"%u ms: use it\", conn->ifc_settings->es_idle_timeout * 1000);\n        conn->ifc_idle_to = conn->ifc_settings->es_idle_timeout * 1000000;\n        break;\n    default:/* (1 << 1) | 1 */\n        LSQ_DEBUG(\"our max idle timeout is %u ms, peer's is %\"PRIu64\" ms; \"\n            \"use minimum value of %\"PRIu64\" ms\",\n            conn->ifc_settings->es_idle_timeout * 1000,\n            params->tp_max_idle_timeout,\n            MIN(conn->ifc_settings->es_idle_timeout * 1000,\n                                            params->tp_max_idle_timeout));\n        conn->ifc_idle_to = 1000 * MIN(conn->ifc_settings->es_idle_timeout\n                                        * 1000, params->tp_max_idle_timeout);\n        break;\n    }\n\n    if (conn->ifc_idle_to >= 2000000\n                            && conn->ifc_enpub->enp_settings.es_ping_period)\n        conn->ifc_ping_period = conn->ifc_idle_to / 2;\n    else\n        conn->ifc_ping_period = 0;\n    LSQ_DEBUG(\"PING period is set to %\"PRIu64\" usec\", conn->ifc_ping_period);\n\n    if (conn->ifc_settings->es_delayed_acks\n            && (params->tp_set\n                    & ((1 << TPI_MIN_ACK_DELAY)|(1 << TPI_MIN_ACK_DELAY_02))))\n    {\n        /* We do not use the min_ack_delay value for anything at the moment,\n         * as ACK_FREQUENCY frames we generate do not change the peer's max\n         * ACK delay.  When or if we do decide to do it, don't forget to use\n         * the correct value here -- based on which TP is set!\n         */\n        LSQ_DEBUG(\"delayed ACKs enabled\");\n        conn->ifc_flags |= IFC_DELAYED_ACKS;\n        lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_PACK_TOL,\n                                        packet_tolerance_alarm_expired, conn);\n    }\n    if (conn->ifc_settings->es_timestamps\n            && (params->tp_set & (1 << TPI_TIMESTAMPS))\n                && (params->tp_numerics[TPI_TIMESTAMPS] & TS_WANT_THEM))\n    {\n        LSQ_DEBUG(\"timestamps enabled: will send TIMESTAMP frames\");\n        conn->ifc_flags |= IFC_TIMESTAMPS;\n    }\n    if (conn->ifc_settings->es_datagrams\n            && (params->tp_set & (1 << TPI_MAX_DATAGRAM_FRAME_SIZE)))\n    {\n        LSQ_DEBUG(\"datagrams enabled\");\n        conn->ifc_flags |= IFC_DATAGRAMS;\n        conn->ifc_max_dg_sz =\n            params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE] > USHRT_MAX\n            ? USHRT_MAX : params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE];\n    }\n\n    conn->ifc_pub.max_peer_ack_usec = params->tp_max_ack_delay * 1000;\n\n    if ((params->tp_set & (1 << TPI_MAX_UDP_PAYLOAD_SIZE))\n            /* Second check is so that we don't truncate a large value when\n             * storing it in unsigned short.\n             */\n            && params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE]\n                                                < TP_DEF_MAX_UDP_PAYLOAD_SIZE)\n        conn->ifc_max_udp_payload = params->tp_numerics[TPI_MAX_UDP_PAYLOAD_SIZE];\n    else\n        conn->ifc_max_udp_payload = TP_DEF_MAX_UDP_PAYLOAD_SIZE;\n\n    if (conn->ifc_max_udp_payload < CUR_NPATH(conn)->np_pack_size)\n    {\n        CUR_NPATH(conn)->np_pack_size = conn->ifc_max_udp_payload;\n        LSQ_DEBUG(\"decrease packet size to %hu bytes\",\n                                                CUR_NPATH(conn)->np_pack_size);\n    }\n\n    if (params->tp_active_connection_id_limit > conn->ifc_conn.cn_n_cces)\n        conn->ifc_active_cids_limit = conn->ifc_conn.cn_n_cces;\n    else\n        conn->ifc_active_cids_limit = params->tp_active_connection_id_limit;\n    conn->ifc_first_active_cid_seqno = conn->ifc_scid_seqno;\n\n    return 0;\n}\n\n\nstatic void\nrandomize_qpack_settings (struct ietf_full_conn *conn, const char *side,\n                        unsigned *dyn_table_size, unsigned *max_risked_streams)\n{\n    const unsigned char nybble = lsquic_crand_get_nybble(\n                                                    conn->ifc_enpub->enp_crand);\n    /* For each setting, select one of four levels:\n     *  Table size:     0, 1/4, 1/2, and 1/1 of dyn_table_size\n     *  Risked streams: 0, 1, 5, and max_risked_streams\n     */\n    switch (nybble & 3)\n    {   case 0: *dyn_table_size  = 0; break;\n        case 1: *dyn_table_size /= 4; break;\n        case 2: *dyn_table_size /= 2; break;\n        default:                      break;\n    }\n    if (*dyn_table_size)\n        switch ((nybble >> 2) & 3)\n        {   case 0: *max_risked_streams = 0;                           break;\n            case 1: *max_risked_streams = MIN(1, *max_risked_streams); break;\n            case 2: *max_risked_streams = MIN(5, *max_risked_streams); break;\n            default:                                                   break;\n        }\n    else\n        *max_risked_streams = 0;\n    LSQ_INFO(\"randomized QPACK %s settings: table size: %u; risked \"\n        \"streams: %u\", side, *dyn_table_size, *max_risked_streams);\n}\n\n\nstatic int\ninit_http (struct ietf_full_conn *conn)\n{\n    unsigned max_risked_streams, dyn_table_size;\n\n    fiu_return_on(\"full_conn_ietf/init_http\", -1);\n    lsquic_qeh_init(&conn->ifc_qeh, &conn->ifc_conn);\n    if (conn->ifc_settings->es_qpack_experiment)\n    {\n        conn->ifc_qeh.qeh_exp_rec = lsquic_qpack_exp_new();\n        if (conn->ifc_qeh.qeh_exp_rec)\n        {\n            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_SERVER & conn->ifc_flags;\n            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_ENCODER;\n        }\n    }\n    if (0 == avail_streams_count(conn, conn->ifc_flags & IFC_SERVER,\n                                                                SD_UNI))\n    {\n        ABORT_QUIETLY(1, HEC_GENERAL_PROTOCOL_ERROR, \"cannot create \"\n                            \"control stream due to peer-imposed limit\");\n        conn->ifc_error = CONN_ERR(1, HEC_GENERAL_PROTOCOL_ERROR);\n        return -1;\n    }\n    if (0 != create_ctl_stream_out(conn))\n    {\n        ABORT_WARN(\"cannot create outgoing control stream\");\n        return -1;\n    }\n    dyn_table_size = conn->ifc_settings->es_qpack_dec_max_size;\n    max_risked_streams = conn->ifc_settings->es_qpack_dec_max_blocked;\n    if (conn->ifc_settings->es_qpack_experiment == 2)\n        randomize_qpack_settings(conn, \"decoder\", &dyn_table_size,\n                                                    &max_risked_streams);\n    if (0 != lsquic_hcso_write_settings(&conn->ifc_hcso,\n                conn->ifc_settings->es_max_header_list_size, dyn_table_size,\n                max_risked_streams, conn->ifc_flags & IFC_SERVER))\n    {\n        ABORT_WARN(\"cannot write SETTINGS\");\n        return -1;\n    }\n    if (!(conn->ifc_flags & IFC_SERVER)\n        && (conn->ifc_u.cli.ifcli_flags & IFCLI_PUSH_ENABLED)\n        && 0 != lsquic_hcso_write_max_push_id(&conn->ifc_hcso,\n                                        conn->ifc_u.cli.ifcli_max_push_id))\n    {\n        ABORT_WARN(\"cannot write MAX_PUSH_ID\");\n        return -1;\n    }\n    if (0 != lsquic_qdh_init(&conn->ifc_qdh, &conn->ifc_conn,\n                            conn->ifc_flags & IFC_SERVER, conn->ifc_enpub,\n                            dyn_table_size, max_risked_streams))\n    {\n        ABORT_WARN(\"cannot initialize QPACK decoder\");\n        return -1;\n    }\n    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)\n    {\n        if (0 != create_qdec_stream_out(conn))\n        {\n            ABORT_WARN(\"cannot create outgoing QPACK decoder stream\");\n            return -1;\n        }\n    }\n    else\n    {\n        queue_streams_blocked_frame(conn, SD_UNI);\n        LSQ_DEBUG(\"cannot create outgoing QPACK decoder stream due to \"\n            \"unidir limits\");\n    }\n    conn->ifc_flags |= IFC_HTTP_INITED;\n    return 0;\n}\n\n\nstatic int\nhandshake_ok (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct dcid_elem *dce;\n    const struct transport_params *params;\n    char buf[MAX_TP_STR_SZ];\n\n    fiu_return_on(\"full_conn_ietf/handshake_ok\", -1);\n\n    /* Need to set this flag even we hit an error in the rest of this funciton.\n     * This is because this flag is used to calculate packet out header size\n     */\n    lconn->cn_flags |= LSCONN_HANDSHAKE_DONE;\n\n    params = lconn->cn_esf.i->esfi_get_peer_transport_params(\n                                                        lconn->cn_enc_session);\n    if (!params)\n    {\n        ABORT_WARN(\"could not get transport parameters\");\n        return -1;\n    }\n\n    LSQ_DEBUG(\"peer transport parameters: %s\",\n                    ((lconn->cn_version == LSQVER_ID27 ? lsquic_tp_to_str_27\n                    : lsquic_tp_to_str)(params, buf, sizeof(buf)), buf));\n    if (0 != apply_trans_params(conn, params))\n        return -1;\n\n    dce = get_new_dce(conn);\n    if (!dce)\n    {\n        ABORT_WARN(\"cannot allocate DCE\");\n        return -1;\n    }\n\n    memset(dce, 0, sizeof(*dce));\n    dce->de_cid = *CUR_DCID(conn);\n    dce->de_seqno = 0;\n    if (params->tp_set & (1 << TPI_STATELESS_RESET_TOKEN))\n    {\n        memcpy(dce->de_srst, params->tp_stateless_reset_token,\n                                                    sizeof(dce->de_srst));\n        dce->de_flags = DE_SRST | DE_ASSIGNED;\n        if (conn->ifc_enpub->enp_srst_hash)\n        {\n            if (!lsquic_hash_insert(conn->ifc_enpub->enp_srst_hash,\n                    dce->de_srst, sizeof(dce->de_srst), &conn->ifc_conn,\n                    &dce->de_hash_el))\n            {\n                ABORT_WARN(\"cannot insert DCE\");\n                return -1;\n            }\n        }\n    }\n    else\n        dce->de_flags = DE_ASSIGNED;\n\n    if (!(conn->ifc_flags & IFC_SERVER)\n        && (params->tp_set & (1 << TPI_VERSION_INFORMATION)))\n    {\n        LSQ_DEBUG(\"server chosen version %s\",\n                  lsquic_ver2str[params->tp_chosen_version]);\n        if (((1 << params->tp_chosen_version)\n            & conn->ifc_settings->es_versions) == 0)\n        {\n            ABORT_QUIETLY(0, TEC_VERSION_NEGOTIATION_ERROR,\n                          \"server chosen version %s is not supported\",\n                          lsquic_ver2str[params->tp_chosen_version]\n                         );\n            return -1;\n        }\n//         if (conn->ifc_conn.cn_version != params->tp_chosen_version)\n//         {\n//             LSQ_DEBUG(\"version negociation: switch version from %s to %s\",\n//                   lsquic_ver2str[conn->ifc_conn.cn_version],\n//                   lsquic_ver2str[params->tp_chosen_version]);\n//             conn->ifc_conn.cn_version = params->tp_chosen_version;\n//         }\n    }\n\n    LSQ_INFO(\"applied peer transport parameters\");\n\n    if ((conn->ifc_flags & (IFC_HTTP|IFC_HTTP_INITED)) == IFC_HTTP)\n        if (0 != init_http(conn))\n            return -1;\n\n    if (conn->ifc_settings->es_dplpmtud)\n        conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n\n    if (can_issue_cids(conn))\n        conn->ifc_send_flags |= SF_SEND_NEW_CID;\n    maybe_create_delayed_streams(conn);\n\n    if (!(conn->ifc_flags & IFC_SERVER))\n        lsquic_send_ctl_0rtt_to_1rtt(&conn->ifc_send_ctl);\n\n    return 0;\n}\n\n\nstatic void\nietf_full_conn_ci_hsk_done (struct lsquic_conn *lconn,\n                                                enum lsquic_hsk_status status)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_HANDSHAKE);\n\n    switch (status)\n    {\n    case LSQ_HSK_OK:\n    case LSQ_HSK_RESUMED_OK:\n        if (0 == handshake_ok(lconn))\n        {\n            if (!(conn->ifc_flags & IFC_SERVER))\n                lsquic_send_ctl_begin_optack_detection(&conn->ifc_send_ctl);\n        }\n        else\n        {\n            LSQ_INFO(\"handshake was reported successful, but later processing \"\n                \"produced an error\");\n            status = LSQ_HSK_FAIL;\n            handshake_failed(lconn);\n        }\n        break;\n    default:\n    case LSQ_HSK_RESUMED_FAIL:  /* IETF crypto never returns this */\n        assert(0);\n        /* fall-through */\n    case LSQ_HSK_FAIL:\n        handshake_failed(lconn);\n        break;\n    }\n    if (conn->ifc_enpub->enp_stream_if->on_hsk_done)\n        conn->ifc_enpub->enp_stream_if->on_hsk_done(lconn, status);\n}\n\n\nstatic void\nietf_full_conn_ci_tls_alert (struct lsquic_conn *lconn, uint8_t alert)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    ABORT_QUIETLY(0, 0x100 + alert, \"TLS alert %\"PRIu8, alert);\n}\n\n\nstatic int\nietf_full_conn_ci_report_live (struct lsquic_conn *lconn, lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    if (conn->ifc_last_live_update + 30000000 < now)\n    {\n        conn->ifc_last_live_update = now;\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic int\nietf_full_conn_ci_is_push_enabled (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    return (conn->ifc_flags & IFC_SERVER)\n        && (conn->ifc_u.ser.ifser_flags\n                & (IFSER_PUSH_ENABLED|IFSER_MAX_PUSH_ID))\n                    == (IFSER_PUSH_ENABLED|IFSER_MAX_PUSH_ID)\n        && conn->ifc_u.ser.ifser_next_push_id\n                        <= conn->ifc_u.ser.ifser_max_push_id\n        && !either_side_going_away(conn)\n        && avail_streams_count(conn, 1, SD_UNI) > 0\n    ;\n}\n\n\nstatic void\nundo_stream_creation (struct ietf_full_conn *conn,\n                                                struct lsquic_stream *stream)\n{\n    enum stream_dir sd;\n\n    assert(stream->sm_hash_el.qhe_flags & QHE_HASHED);\n    assert(!(stream->stream_flags & STREAM_ONCLOSE_DONE));\n\n    LSQ_DEBUG(\"undo creation of stream %\"PRIu64, stream->id);\n    lsquic_hash_erase(conn->ifc_pub.all_streams, &stream->sm_hash_el);\n    sd = (stream->id >> SD_SHIFT) & 1;\n    --conn->ifc_n_created_streams[sd];\n    lsquic_stream_destroy(stream);\n}\n\n\n/* This function is long because there are a lot of steps to perform, several\n * things can go wrong, which we want to roll back, yet at the same time we\n * want to do everything efficiently.\n */\nstatic int\nietf_full_conn_ci_push_stream (struct lsquic_conn *lconn, void *hset,\n    struct lsquic_stream *dep_stream, const struct lsquic_http_headers *headers)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    unsigned char *header_block_buf, *end, *p;\n    size_t hea_sz, enc_sz;\n    ssize_t prefix_sz;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n    struct lsquic_stream *pushed_stream;\n    struct uncompressed_headers *uh;\n    enum lsqpack_enc_status enc_st;\n    int i;\n    unsigned char discard[2];\n    struct lsxpack_header *xhdr;\n\n    if (!ietf_full_conn_ci_is_push_enabled(lconn)\n                                || !lsquic_stream_can_push(dep_stream))\n    {\n        LSQ_DEBUG(\"cannot push using stream %\"PRIu64, dep_stream->id);\n        return -1;\n    }\n\n    if (!hset)\n    {\n        LSQ_ERROR(\"header set must be specified when pushing\");\n        return -1;\n    }\n\n    if (0 != lsqpack_enc_start_header(&conn->ifc_qeh.qeh_encoder, 0, 0))\n    {\n        LSQ_WARN(\"cannot start header for push stream\");\n        return -1;\n    }\n\n    header_block_buf = lsquic_mm_get_4k(conn->ifc_pub.mm);\n    if (!header_block_buf)\n    {\n        LSQ_WARN(\"cannot allocate 4k\");\n        (void) lsqpack_enc_cancel_header(&conn->ifc_qeh.qeh_encoder);\n        return -1;\n    }\n\n    /* Generate header block in cheap 4K memory.  It it will be copied to\n     * a new push_promise object.\n     */\n    p = header_block_buf;\n    end = header_block_buf + 0x1000;\n    enc_sz = 0; /* Should not change */\n    for (i = 0; i < headers->count; ++i)\n    {\n        xhdr = &headers->headers[i];\n        if (!xhdr->buf)\n            continue;\n        hea_sz = end - p;\n        enc_st = lsqpack_enc_encode(&conn->ifc_qeh.qeh_encoder, NULL,\n            &enc_sz, p, &hea_sz, xhdr, LQEF_NO_HIST_UPD|LQEF_NO_DYN);\n        if (enc_st == LQES_OK)\n            p += hea_sz;\n        else\n        {\n            (void) lsqpack_enc_cancel_header(&conn->ifc_qeh.qeh_encoder);\n            lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n            LSQ_DEBUG(\"cannot encode header field for push %u\", enc_st);\n            return -1;\n        }\n    }\n    prefix_sz = lsqpack_enc_end_header(&conn->ifc_qeh.qeh_encoder,\n                                            discard, sizeof(discard), NULL);\n    if (!(prefix_sz == 2 && discard[0] == 0 && discard[1] == 0))\n    {\n        LSQ_WARN(\"stream push: unexpected prefix values %zd, %hhu, %hhu\",\n            prefix_sz, discard[0], discard[1]);\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        return -1;\n    }\n    LSQ_DEBUG(\"generated push promise header block of %ld bytes\",\n                                            (long) (p - header_block_buf));\n\n    pushed_stream = create_push_stream(conn);\n    if (!pushed_stream)\n    {\n        LSQ_WARN(\"could not create push stream\");\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        return -1;\n    }\n\n    promise = malloc(sizeof(*promise) + (p - header_block_buf));\n    if (!promise)\n    {\n        LSQ_WARN(\"stream push: cannot allocate promise\");\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        undo_stream_creation(conn, pushed_stream);\n        return -1;\n    }\n\n    uh = malloc(sizeof(*uh));\n    if (!uh)\n    {\n        LSQ_WARN(\"stream push: cannot allocate uh\");\n        free(promise);\n        lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n        undo_stream_creation(conn, pushed_stream);\n        return -1;\n    }\n    uh->uh_stream_id     = pushed_stream->id;\n    uh->uh_oth_stream_id = 0;\n    uh->uh_weight        = lsquic_stream_priority(dep_stream) / 2 + 1;\n    uh->uh_exclusive     = 0;\n    uh->uh_flags         = UH_FIN;\n    uh->uh_hset          = hset;\n    uh->uh_next          = NULL;\n\n    memset(promise, 0, sizeof(*promise));\n    promise->pp_refcnt = 1; /* This function itself keeps a reference */\n    memcpy(promise->pp_content_buf, header_block_buf, p - header_block_buf);\n    promise->pp_content_len = p - header_block_buf;\n    promise->pp_id = conn->ifc_u.ser.ifser_next_push_id++;\n    lsquic_mm_put_4k(conn->ifc_pub.mm, header_block_buf);\n\n    el = lsquic_hash_insert(conn->ifc_pub.u.ietf.promises,\n            &promise->pp_id, sizeof(promise->pp_id), promise,\n            &promise->pp_hash_id);\n    if (!el)\n    {\n        LSQ_WARN(\"cannot insert push promise (ID)\");\n        undo_stream_creation(conn, pushed_stream);\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        free(uh);\n        return -1;\n    }\n\n    if (0 != lsquic_stream_push_promise(dep_stream, promise))\n    {\n        LSQ_DEBUG(\"push promise failed\");\n        undo_stream_creation(conn, pushed_stream);\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        free(uh);\n        return -1;\n    }\n\n    if (0 != lsquic_stream_uh_in(pushed_stream, uh))\n    {\n        LSQ_WARN(\"stream barfed when fed synthetic request\");\n        undo_stream_creation(conn, pushed_stream);\n        free(uh);\n        if (0 != lsquic_hcso_write_cancel_push(&conn->ifc_hcso,\n                                                    promise->pp_id))\n            ABORT_WARN(\"cannot write CANCEL_PUSH\");\n        lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n        return -1;\n    }\n\n    /* Linking push promise with pushed stream is necessary for cancellation */\n    ++promise->pp_refcnt;\n    promise->pp_pushed_stream = pushed_stream;\n    pushed_stream->sm_promise = promise;\n\n    lsquic_stream_call_on_new(pushed_stream);\n\n    lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n    return 0;\n}\n\n\nstatic int\nietf_full_conn_ci_is_tickable (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_stream *stream;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.service_streams))\n    {\n        LSQ_DEBUG(\"tickable: there are streams to be serviced\");\n        return 1;\n    }\n\n    if ((conn->ifc_enpub->enp_flags & ENPUB_CAN_SEND)\n        && (should_generate_ack(conn, IFC_ACK_QUEUED) ||\n            !lsquic_send_ctl_sched_is_blocked(&conn->ifc_send_ctl)))\n    {\n        /* XXX What about queued ACKs: why check but not make tickable? */\n        if (conn->ifc_send_flags)\n        {\n            LSQ_DEBUG(\"tickable: send flags: 0x%X\", conn->ifc_send_flags);\n            goto check_can_send;\n        }\n        if (lsquic_send_ctl_has_sendable(&conn->ifc_send_ctl))\n        {\n            LSQ_DEBUG(\"tickable: has sendable packets\");\n            return 1;   /* Don't check can_send: already on scheduled queue */\n        }\n        if (conn->ifc_conn.cn_flags & LSCONN_SEND_BLOCKED)\n        {\n            LSQ_DEBUG(\"tickable: send DATA_BLOCKED frame\");\n            goto check_can_send;\n        }\n        if (conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE)\n        {\n            LSQ_DEBUG(\"tickable: want to write DATAGRAM frame\");\n            goto check_can_send;\n        }\n        if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE ?\n                lsquic_send_ctl_has_buffered(&conn->ifc_send_ctl) :\n                lsquic_send_ctl_has_buffered_high(&conn->ifc_send_ctl))\n        {\n            LSQ_DEBUG(\"tickable: has buffered packets\");\n            goto check_can_send;\n        }\n        if (!TAILQ_EMPTY(&conn->ifc_pub.sending_streams))\n        {\n            LSQ_DEBUG(\"tickable: there are sending streams\");\n            goto check_can_send;\n        }\n        TAILQ_FOREACH(stream, &conn->ifc_pub.write_streams, next_write_stream)\n            if (lsquic_stream_write_avail(stream))\n            {\n                LSQ_DEBUG(\"tickable: stream %\"PRIu64\" can be written to\",\n                    stream->id);\n                goto check_can_send;\n            }\n        goto check_readable_streams;\n  check_can_send:\n        if (lsquic_send_ctl_can_send(&conn->ifc_send_ctl))\n            return 1;\n    }\n\n  check_readable_streams:\n    TAILQ_FOREACH(stream, &conn->ifc_pub.read_streams, next_read_stream)\n        if (lsquic_stream_readable(stream))\n        {\n            LSQ_DEBUG(\"tickable: stream %\"PRIu64\" can be read from\",\n                stream->id);\n            return 1;\n        }\n\n    if (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS)\n    {\n        LSQ_DEBUG(\"tickable: immediate close flags: 0x%X\",\n            (unsigned) (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS));\n        return 1;\n    }\n\n    LSQ_DEBUG(\"not tickable\");\n    return 0;\n}\n\n\nstatic enum tick_st\nimmediate_close (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    const char *error_reason;\n    struct conn_err conn_err;\n    int sz;\n\n    if (conn->ifc_flags & (IFC_TICK_CLOSE|IFC_GOT_PRST))\n        return TICK_CLOSE;\n\n    if (!(conn->ifc_flags & IFC_SERVER)\n            && conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_END)\n        return TICK_CLOSE;\n\n    conn->ifc_flags |= IFC_TICK_CLOSE;\n\n    /* No reason to send anything that's been scheduled if connection is\n     * being closed immedately.  This also ensures that packet numbers\n     * sequence is always increasing.\n     */\n    lsquic_send_ctl_drop_scheduled(&conn->ifc_send_ctl);\n\n    if ((conn->ifc_flags & (IFC_TIMED_OUT|IFC_HSK_FAILED))\n                                    && conn->ifc_settings->es_silent_close)\n        return TICK_CLOSE;\n\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0,\n                                                    PNS_APP, CUR_NPATH(conn));\n    if (!packet_out)\n    {\n        LSQ_WARN(\"cannot allocate packet: %s\", strerror(errno));\n        return TICK_CLOSE;\n    }\n\n    assert(conn->ifc_flags & (IFC_ERROR|IFC_ABORTED|IFC_HSK_FAILED));\n    if (conn->ifc_error.u.err != 0)\n    {\n        conn_err = conn->ifc_error;\n        error_reason = conn->ifc_errmsg;\n    }\n    else if (conn->ifc_flags & IFC_ERROR)\n    {\n        conn_err = CONN_ERR(0, TEC_INTERNAL_ERROR);\n        error_reason = \"connection error\";\n    }\n    else if (conn->ifc_flags & IFC_ABORTED)\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = \"user aborted connection\";\n    }\n    else if (conn->ifc_flags & IFC_HSK_FAILED)\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = \"handshake failed\";\n    }\n    else\n    {\n        conn_err = CONN_ERR(0, TEC_NO_ERROR);\n        error_reason = NULL;\n    }\n\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    sz = conn->ifc_conn.cn_pf->pf_gen_connect_close_frame(\n                     packet_out->po_data + packet_out->po_data_sz,\n                     lsquic_packet_out_avail(packet_out), conn_err.app_error,\n                     conn_err.u.err, error_reason,\n                     error_reason ? strlen(error_reason) : 0);\n    if (sz < 0) {\n        LSQ_WARN(\"%s failed\", __func__);\n        return TICK_CLOSE;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_CONNECTION_CLOSE, packet_out->po_data_sz, sz))\n    {\n        LSQ_WARN(\"%s: adding frame to packet failed: %d\", __func__, errno);\n        return TICK_CLOSE;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_CONNECTION_CLOSE;\n    conn->ifc_mflags |= MF_CONN_CLOSE_PACK;\n    LSQ_DEBUG(\"generated CONNECTION_CLOSE frame in its own packet\");\n    return TICK_SEND|TICK_CLOSE;\n}\n\n\nstatic void\nprocess_streams_read_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream *stream;\n    int iters;\n    enum stream_q_flags q_flags, needs_service;\n    union prio_iter pi;\n    static const char *const labels[2] = { \"read-0\", \"read-1\", };\n\n    if (TAILQ_EMPTY(&conn->ifc_pub.read_streams))\n        return;\n\n    conn->ifc_pub.cp_flags &= ~CP_STREAM_UNBLOCKED;\n    iters = 0;\n    do\n    {\n        conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.read_streams),\n            TAILQ_LAST(&conn->ifc_pub.read_streams, lsquic_streams_tailq),\n            (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_read_stream),\n            &conn->ifc_pub, labels[iters], NULL, NULL);\n\n        needs_service = 0;\n        for (stream = conn->ifc_pii->pii_first(&pi); stream;\n                                        stream = conn->ifc_pii->pii_next(&pi))\n        {\n            q_flags = stream->sm_qflags & SMQF_SERVICE_FLAGS;\n            lsquic_stream_dispatch_read_events(stream);\n            needs_service |= q_flags ^ (stream->sm_qflags & SMQF_SERVICE_FLAGS);\n        }\n        conn->ifc_pii->pii_cleanup(&pi);\n\n        if (needs_service)\n            service_streams(conn);\n    }\n    while (iters++ == 0 && (conn->ifc_pub.cp_flags & CP_STREAM_UNBLOCKED));\n}\n\n\nstatic void\nprocess_crypto_stream_read_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **stream;\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    for (stream = conn->ifc_u.cli.crypto_streams; stream <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++stream)\n        if (*stream && (*stream)->sm_qflags & SMQF_WANT_READ)\n            lsquic_stream_dispatch_read_events(*stream);\n}\n\n\nstatic void\nprocess_crypto_stream_write_events (struct ietf_full_conn *conn)\n{\n    struct lsquic_stream **stream;\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    for (stream = conn->ifc_u.cli.crypto_streams; stream <\n            conn->ifc_u.cli.crypto_streams + sizeof(conn->ifc_u.cli.crypto_streams)\n                    / sizeof(conn->ifc_u.cli.crypto_streams[0]); ++stream)\n        if (*stream && (*stream)->sm_qflags & SMQF_WRITE_Q_FLAGS)\n            lsquic_stream_dispatch_write_events(*stream);\n}\n\n\nstatic void\nmaybe_conn_flush_special_streams (struct ietf_full_conn *conn)\n{\n    if (!(conn->ifc_flags & IFC_HTTP))\n        return;\n\n    struct lsquic_stream *const streams[] = {\n        conn->ifc_hcso.how_stream,\n        conn->ifc_qeh.qeh_enc_sm_out,\n        conn->ifc_qdh.qdh_dec_sm_out,\n    };\n    struct lsquic_stream *const *stream;\n\n    for (stream = streams; stream < streams + sizeof(streams)\n                                            / sizeof(streams[0]); ++stream)\n        if (*stream && lsquic_stream_has_data_to_flush(*stream))\n            (void) lsquic_stream_flush(*stream);\n}\n\n\nstatic int\nwrite_is_possible (struct ietf_full_conn *conn)\n{\n    const lsquic_packet_out_t *packet_out;\n\n    packet_out = lsquic_send_ctl_last_scheduled(&conn->ifc_send_ctl, PNS_APP,\n                                                        CUR_NPATH(conn), 0);\n    return (packet_out && lsquic_packet_out_avail(packet_out) > 10)\n        || lsquic_send_ctl_can_send(&conn->ifc_send_ctl);\n}\n\n\nstatic void\nprocess_streams_write_events (struct ietf_full_conn *conn, int high_prio)\n{\n    struct lsquic_stream *stream;\n    union prio_iter pi;\n\n    conn->ifc_pii->pii_init(&pi, TAILQ_FIRST(&conn->ifc_pub.write_streams),\n        TAILQ_LAST(&conn->ifc_pub.write_streams, lsquic_streams_tailq),\n        (uintptr_t) &TAILQ_NEXT((lsquic_stream_t *) NULL, next_write_stream),\n        &conn->ifc_pub,\n        high_prio ? \"write-high\" : \"write-low\", NULL, NULL);\n\n    if (high_prio)\n        conn->ifc_pii->pii_drop_non_high(&pi);\n    else\n        conn->ifc_pii->pii_drop_high(&pi);\n\n    for (stream = conn->ifc_pii->pii_first(&pi);\n                        stream && write_is_possible(conn);\n                                    stream = conn->ifc_pii->pii_next(&pi))\n        if (stream->sm_qflags & SMQF_WRITE_Q_FLAGS)\n            lsquic_stream_dispatch_write_events(stream);\n    conn->ifc_pii->pii_cleanup(&pi);\n\n    maybe_conn_flush_special_streams(conn);\n}\n\n\nstatic void\ngenerate_connection_close_packet (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    int sz;\n\n    /* FIXME Select PNS based on handshake status (possible on the client): if\n     * appropriate keys are not available, encryption will fail.\n     */\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0, PNS_APP,\n                                                                CUR_NPATH(conn));\n    if (!packet_out)\n    {\n        ABORT_ERROR(\"cannot allocate packet: %s\", strerror(errno));\n        return;\n    }\n\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    sz = conn->ifc_conn.cn_pf->pf_gen_connect_close_frame(\n                packet_out->po_data + packet_out->po_data_sz,\n                lsquic_packet_out_avail(packet_out), 0, TEC_NO_ERROR, NULL, 0);\n    if (sz < 0) {\n        ABORT_ERROR(\"generate_connection_close_packet failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                    QUIC_FRAME_CONNECTION_CLOSE, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_CONNECTION_CLOSE;\n    conn->ifc_mflags |= MF_CONN_CLOSE_PACK;\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID,\n            \"generated CONNECTION_CLOSE frame in its own packet\");\n    conn->ifc_send_flags &= ~SF_SEND_CONN_CLOSE;\n}\n\n\nstatic void\nlog_conn_flow_control (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"connection flow cap: wrote: %\"PRIu64\n        \"; max: %\"PRIu64, conn->ifc_pub.conn_cap.cc_sent,\n        conn->ifc_pub.conn_cap.cc_max);\n    LSQ_DEBUG(\"connection flow control window: read: %\"PRIu64\n        \"; max: %\"PRIu64, conn->ifc_pub.cfcw.cf_max_recv_off,\n        conn->ifc_pub.cfcw.cf_recv_off);\n}\n\n\nstatic void\ngenerate_ping_frame (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct lsquic_packet_out *packet_out;\n    int pns;\n    int sz;\n\n    if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        packet_out = get_writeable_packet(conn, 1);\n    else\n    {\n        conn->ifc_ping_period += HSK_PING_TIMEOUT;\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                            now + conn->ifc_ping_period);\n        if (iquic_esf_is_enc_level_ready(conn->ifc_conn.cn_enc_session,\n                                         ENC_LEV_HSK))\n            pns = PNS_HSK;\n        else\n            pns = PNS_INIT;\n        packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl, 0, pns,\n                                                    CUR_NPATH(conn));\n        if (packet_out)\n            lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n\n    }\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for PING frame\");\n        return;\n    }\n    sz = conn->ifc_conn.cn_pf->pf_gen_ping_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0) {\n        ABORT_ERROR(\"gen_ping_frame failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                            QUIC_FRAME_PING, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_PING;\n    LSQ_DEBUG(\"wrote PING frame\");\n    conn->ifc_send_flags &= ~SF_SEND_PING;\n    if (!(conn->ifc_flags & IFC_SERVER))\n        log_conn_flow_control(conn);\n}\n\n\nstatic void\ngenerate_handshake_done_frame (struct ietf_full_conn *conn,\n                                                        lsquic_time_t unused)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int sz;\n\n    need = conn->ifc_conn.cn_pf->pf_handshake_done_frame_size();\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return;\n    sz = conn->ifc_conn.cn_pf->pf_gen_handshake_done_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"generate_handshake_done_frame failed\");\n        return;\n    }\n\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_HANDSHAKE_DONE, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= QUIC_FTBIT_HANDSHAKE_DONE;\n    LSQ_DEBUG(\"generated HANDSHAKE_DONE frame\");\n    conn->ifc_send_flags &= ~SF_SEND_HANDSHAKE_DONE;\n}\n\n\nstatic void\ngenerate_ack_frequency_frame (struct ietf_full_conn *conn, lsquic_time_t unused)\n{\n    struct lsquic_packet_out *packet_out;\n    unsigned need;\n    int sz;\n    /* We tell the peer to ignore reordering because we skip packet numbers to\n     * detect optimistic ACK attacks.\n     */\n    const int ignore = 1;\n\n    need = conn->ifc_conn.cn_pf->pf_ack_frequency_frame_size(\n                        conn->ifc_ack_freq_seqno, conn->ifc_last_calc_pack_tol,\n                        conn->ifc_pub.max_peer_ack_usec);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n    {\n        LSQ_DEBUG(\"cannot get writeable packet for ACK_FREQUENCY frame\");\n        return;\n    }\n\n    sz = conn->ifc_conn.cn_pf->pf_gen_ack_frequency_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out),\n                            conn->ifc_ack_freq_seqno, conn->ifc_last_calc_pack_tol,\n                            conn->ifc_pub.max_peer_ack_usec, ignore);\n    if (sz < 0)\n    {\n        ABORT_ERROR(\"gen_ack_frequency_frame failed\");\n        return;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_ACK_FREQUENCY, packet_out->po_data_sz, sz))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    conn->ifc_last_pack_tol = conn->ifc_last_calc_pack_tol;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= QUIC_FTBIT_ACK_FREQUENCY;\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID,\n        \"Generated ACK_FREQUENCY(seqno: %u; pack_tol: %u; \"\n        \"upd: %u; ignore: %d)\", conn->ifc_ack_freq_seqno,\n        conn->ifc_last_pack_tol, conn->ifc_pub.max_peer_ack_usec, ignore);\n    LSQ_DEBUG(\"Generated ACK_FREQUENCY(seqno: %u; pack_tol: %u; \"\n        \"upd: %u; ignore: %d)\", conn->ifc_ack_freq_seqno,\n        conn->ifc_last_pack_tol, conn->ifc_pub.max_peer_ack_usec, ignore);\n    ++conn->ifc_ack_freq_seqno;\n    conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n#if LSQUIC_CONN_STATS\n    if (conn->ifc_last_pack_tol > conn->ifc_max_pack_tol_sent)\n        conn->ifc_max_pack_tol_sent = conn->ifc_last_pack_tol;\n    if (conn->ifc_last_pack_tol < conn->ifc_min_pack_tol_sent\n                                    || 0 == conn->ifc_min_pack_tol_sent)\n        conn->ifc_min_pack_tol_sent = conn->ifc_last_pack_tol;\n#endif\n}\n\n\nstatic void\nmaybe_pad_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_out *packet_out)\n{\n    unsigned short avail;\n\n    avail = lsquic_packet_out_avail(packet_out);\n    if (avail)\n    {\n        memset(packet_out->po_data + packet_out->po_data_sz, 0, avail);\n        lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, avail);\n        packet_out->po_frame_types |= QUIC_FTBIT_PADDING;\n        LSQ_DEBUG(\"added %hu-byte PADDING frame to packet %\"PRIu64, avail,\n                                                        packet_out->po_packno);\n    }\n}\n\n\nstatic void\ngenerate_path_chal_frame (struct ietf_full_conn *conn, lsquic_time_t now,\n                                                            unsigned path_id)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_path *copath;\n    unsigned need;\n    int w;\n    char hexbuf[ sizeof(copath->cop_path_chals[0]) * 2 + 1 ];\n\n    /* For now, we only support sending path challenges on a single path.\n     * This restriction may need to be lifted if the client is probing\n     * several paths at the same time.\n     */\n    if (!(conn->ifc_flags & IFC_SERVER))\n        assert(path_id == conn->ifc_mig_path_id);\n\n    copath = &conn->ifc_paths[path_id];\n    if (copath->cop_n_chals >= sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]))\n    {\n        /* path failure? it is non-fatal, keep trying */\n        memmove(&copath->cop_path_chals[0], &copath->cop_path_chals[1],\n            sizeof(copath->cop_path_chals) - sizeof(copath->cop_path_chals[0]));\n        copath->cop_n_chals = sizeof(copath->cop_path_chals)\n                                        / sizeof(copath->cop_path_chals[0]) - 1;\n    }\n\n    need = conn->ifc_conn.cn_pf->pf_path_chal_frame_size();\n    packet_out = get_writeable_packet_on_path(conn, need, &copath->cop_path, 1);\n    if (!packet_out)\n        return;\n\n    RAND_bytes((void *) &copath->cop_path_chals[copath->cop_n_chals],\n                                            sizeof(copath->cop_path_chals[0]));\n    w = conn->ifc_conn.cn_pf->pf_gen_path_chal_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            copath->cop_path_chals[copath->cop_n_chals]);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating PATH_CHALLENGE frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte PATH_CHALLENGE frame; challenge: %s\"\n        \", seq: %u\", w,\n        HEXSTR((unsigned char *) &copath->cop_path_chals[copath->cop_n_chals],\n            sizeof(copath->cop_path_chals[copath->cop_n_chals]), hexbuf),\n        copath->cop_n_chals);\n    ++copath->cop_n_chals;\n    EV_LOG_GENERATED_PATH_CHAL_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_PATH_CHALLENGE, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_PATH_CHALLENGE;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    packet_out->po_regen_sz += w;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << path_id);\n    /* Anti-amplification, only pad packet if allowed\n     *  (confirmed path or incoming packet >= 400 bytes). */\n    if (copath->cop_flags & COP_ALLOW_MTU_PADDING)\n        maybe_pad_packet(conn, packet_out);\n    /* Only retry for confirmed path */\n    if (copath->cop_flags & COP_VALIDATED)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PATH_CHAL + path_id,\n                    now + (INITIAL_CHAL_TIMEOUT << (copath->cop_n_chals - 1)));\n}\n\n\nstatic void\ngenerate_path_chal_0 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 0);\n}\n\n\nstatic void\ngenerate_path_chal_1 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 1);\n}\n\n\nstatic void\ngenerate_path_chal_2 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 2);\n}\n\n\nstatic void\ngenerate_path_chal_3 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_chal_frame(conn, now, 3);\n}\n\n\nstatic void\ngenerate_path_resp_frame (struct ietf_full_conn *conn, lsquic_time_t now,\n                                                            unsigned path_id)\n{\n    struct lsquic_packet_out *packet_out;\n    struct conn_path *copath;\n    unsigned need;\n    int w;\n\n    copath = &conn->ifc_paths[path_id];\n    need = conn->ifc_conn.cn_pf->pf_path_resp_frame_size();\n    packet_out = get_writeable_packet_on_path(conn, need, &copath->cop_path, 1);\n    if (!packet_out)\n        return;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_path_resp_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out),\n            copath->cop_inc_chal);\n    if (w < 0)\n    {\n        ABORT_ERROR(\"generating PATH_RESPONSE frame failed: %d\", errno);\n        return;\n    }\n    LSQ_DEBUG(\"generated %d-byte PATH_RESPONSE frame; response: %016\"PRIX64,\n        w, copath->cop_inc_chal);\n    EV_LOG_GENERATED_PATH_RESP_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,\n                        packet_out->po_data + packet_out->po_data_sz, w);\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_PATH_RESPONSE, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding frame to packet failed: %d\", errno);\n        return;\n    }\n    packet_out->po_frame_types |= QUIC_FTBIT_PATH_RESPONSE;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    maybe_pad_packet(conn, packet_out);\n    packet_out->po_regen_sz += w;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP << path_id);\n}\n\n\nstatic void\ngenerate_path_resp_0 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 0);\n}\n\n\nstatic void\ngenerate_path_resp_1 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 1);\n}\n\n\nstatic void\ngenerate_path_resp_2 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 2);\n}\n\n\nstatic void\ngenerate_path_resp_3 (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    generate_path_resp_frame(conn, now, 3);\n}\n\n\nstatic struct lsquic_packet_out *\nietf_full_conn_ci_next_packet_to_send (struct lsquic_conn *lconn,\n                                                const struct to_coal *to_coal)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_packet_out *packet_out;\n    const struct conn_path *cpath;\n\n    packet_out = lsquic_send_ctl_next_packet_to_send(&conn->ifc_send_ctl,\n                                                                    to_coal);\n    if (packet_out)\n    {\n        cpath = NPATH2CPATH(packet_out->po_path);\n        lsquic_packet_out_set_spin_bit(packet_out, cpath->cop_spin_bit);\n    }\n    return packet_out;\n}\n\n\nstatic struct lsquic_packet_out *\nietf_full_conn_ci_next_packet_to_send_pre_hsk (struct lsquic_conn *lconn,\n                                                const struct to_coal *to_coal)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct lsquic_packet_out *packet_out;\n\n    packet_out = ietf_full_conn_ci_next_packet_to_send(lconn, to_coal);\n    if (packet_out)\n        ++conn->ifc_u.cli.ifcli_packets_out;\n    return packet_out;\n}\n\n\nstatic lsquic_time_t\nietf_full_conn_ci_next_tick_time (struct lsquic_conn *lconn, unsigned *why)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_time_t alarm_time, pacer_time, now;\n    enum alarm_id al_id;\n\n    alarm_time = lsquic_alarmset_mintime(&conn->ifc_alset, &al_id);\n    pacer_time = lsquic_send_ctl_next_pacer_time(&conn->ifc_send_ctl);\n\n    if (pacer_time && LSQ_LOG_ENABLED(LSQ_LOG_DEBUG))\n    {\n        now = lsquic_time_now();\n        if (pacer_time < now)\n            LSQ_DEBUG(\"%s: pacer is %\"PRIu64\" usec in the past\", __func__,\n                                                            now - pacer_time);\n    }\n\n    if (alarm_time && pacer_time)\n    {\n        if (alarm_time < pacer_time)\n        {\n            *why = N_AEWS + al_id;\n            return alarm_time;\n        }\n        else\n        {\n            *why = AEW_PACER;\n            return pacer_time;\n        }\n    }\n    else if (alarm_time)\n    {\n        *why = N_AEWS + al_id;\n        return alarm_time;\n    }\n    else if (pacer_time)\n    {\n        *why = AEW_PACER;\n        return pacer_time;\n    }\n    else\n        return 0;\n}\n\n\nstatic ptrdiff_t\ncount_zero_bytes (const unsigned char *p, size_t len)\n{\n    const unsigned char *const end = p + len;\n    while (p < end && 0 == *p)\n        ++p;\n    return len - (end - p);\n}\n\n\nstatic unsigned\nprocess_padding_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    unsigned sz = (unsigned) count_zero_bytes(p, len);\n    EV_LOG_PADDING_FRAME_IN(LSQUIC_LOG_CONN_ID, sz);\n    return sz;\n}\n\n\nstatic void\nhandshake_confirmed (struct ietf_full_conn *conn)\n{\n    ignore_hsk(conn);\n    /* Even in ID-25, we wait for 1-RTT ACK on the server before dropping keys.\n     */\n    conn->ifc_conn.cn_esf.i->esfi_handshake_confirmed(\n                                        conn->ifc_conn.cn_enc_session);\n    if (!(conn->ifc_flags & (IFC_SERVER|IFC_MIGRA)))\n    {\n        conn->ifc_flags |= IFC_MIGRA;   /* Perform migration just once */\n        maybe_start_migration(conn);\n    }\n}\n\n\nstatic float\ncalc_target (lsquic_time_t srtt_ms)\n{\n    if (srtt_ms <= 5 * 1000)\n        return 2.5;\n    if (srtt_ms <= 10 * 1000)\n        return 2.0;\n    if (srtt_ms <= 15 * 1000)\n        return 1.6;\n    if (srtt_ms <= 20 * 1000)\n        return 1.4;\n    if (srtt_ms <= 30 * 1000)\n        return 1.3;\n    if (srtt_ms <= 40 * 1000)\n        return 1.2;\n    if (srtt_ms <= 50 * 1000)\n        return 1.1;\n    if (srtt_ms <= 60 * 1000)\n        return 1.0;\n    if (srtt_ms <= 70 * 1000)\n        return 0.9;\n    if (srtt_ms <= 80 * 1000)\n        return 0.8;\n    if (srtt_ms <= 100 * 1000)\n        return 0.7;\n    return 0.5;\n}\n\n\nstatic void\npacket_tolerance_alarm_expired (enum alarm_id al_id, void *ctx,\n                                    lsquic_time_t expiry, lsquic_time_t now)\n{\n    struct ietf_full_conn *const conn = ctx;\n    const float             Kp = conn->ifc_settings->es_ptpc_prop_gain,\n                            Ki = conn->ifc_settings->es_ptpc_int_gain,\n                    err_thresh = conn->ifc_settings->es_ptpc_err_thresh,\n                   err_divisor = conn->ifc_settings->es_ptpc_err_divisor;\n    const unsigned periodicity = conn->ifc_settings->es_ptpc_periodicity;\n    const unsigned max_packtol = conn->ifc_settings->es_ptpc_max_packtol;\n    float avg_acks_per_rtt, error, combined_error, normalized,\n            combined_error_abs, target, rtts;\n    double dt;\n    lsquic_time_t srtt, begin_t;\n\n    srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n\n    if (srtt == 0)\n        goto end;\n    if (0 == conn->ifc_pts.n_acks)\n        /* Don't reset last_sample and calculate average for both this and next\n         * period the next time around.\n         */\n        goto end;\n\n    if (conn->ifc_settings->es_ptpc_dyn_target)\n        target = calc_target(srtt);\n    else\n        target = conn->ifc_settings->es_ptpc_target;\n\n    dt = periodicity * (double) srtt / 1000000;\n\n    begin_t = conn->ifc_pts.last_sample ? conn->ifc_pts.last_sample\n                                                    : conn->ifc_created;\n    /*\n    LSQ_DEBUG(\"begin: %\"PRIu64\"; now: %\"PRIu64\"; SRTT: %\"PRIu64\"; acks: %u\",\n        begin_t, now, srtt, conn->ifc_pts.n_acks);\n    */\n    rtts = (float) (now - begin_t) / (float) srtt;\n    avg_acks_per_rtt = (float) conn->ifc_pts.n_acks / (float) rtts;\n    normalized = avg_acks_per_rtt * M_E / target;\n    error = logf(normalized) - 1;\n    conn->ifc_pts.integral_error += error * (float) dt;\n    combined_error = Kp * error + Ki * conn->ifc_pts.integral_error;\n    combined_error_abs = fabsf(combined_error);\n    conn->ifc_pts.last_sample = now;\n    if (combined_error_abs > err_thresh)\n    {\n        unsigned adj = combined_error_abs / err_divisor;\n        unsigned last_pack_tol = conn->ifc_last_pack_tol;\n        if (0 == last_pack_tol)\n        {\n            last_pack_tol = (unsigned)\n                lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist)\n                                                    / conn->ifc_pts.n_acks;\n            LSQ_DEBUG(\"packets sent: %\"PRIu64\"; ACKs received: %u; implied \"\n                \"tolerance: %u\",\n                lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist),\n                conn->ifc_pts.n_acks, last_pack_tol);\n            if (last_pack_tol < 2)\n                last_pack_tol = 2;\n            else if (last_pack_tol >= max_packtol)\n                last_pack_tol = max_packtol / 2;\n        }\n        if (combined_error > 0)\n        {\n            conn->ifc_last_calc_pack_tol = last_pack_tol + adj;\n            if (conn->ifc_last_calc_pack_tol >= max_packtol)\n            {\n                /* Clamp integral error when we can go no higher */\n                conn->ifc_pts.integral_error -= error * (float) dt;\n                conn->ifc_last_calc_pack_tol = max_packtol;\n            }\n        }\n        else\n        {\n            if (adj + 2 < last_pack_tol)\n                conn->ifc_last_calc_pack_tol = last_pack_tol - adj;\n            else\n                conn->ifc_last_calc_pack_tol = 2;\n            if (conn->ifc_last_calc_pack_tol == 2)\n            {\n                /* Clamp integral error when we can go no lower */\n                conn->ifc_pts.integral_error -= error * (float) dt;\n            }\n        }\n        if (conn->ifc_last_calc_pack_tol != conn->ifc_last_pack_tol)\n        {\n            LSQ_DEBUG(\"old packet tolerance target: %u, schedule ACK_FREQUENCY \"\n                \"%s to %u\", conn->ifc_last_pack_tol,\n                combined_error > 0 ? \"increase\" : \"decrease\",\n                conn->ifc_last_calc_pack_tol);\n            conn->ifc_send_flags |= SF_SEND_ACK_FREQUENCY;\n        }\n        else\n        {\n            LSQ_DEBUG(\"packet tolerance unchanged at %u\", conn->ifc_last_pack_tol);\n            conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n        }\n    }\n    else\n        conn->ifc_send_flags &= ~SF_SEND_ACK_FREQUENCY;\n    LSQ_DEBUG(\"avg ACKs per RTT: %.3f; normalized: %.3f; target: %.3f; error: %.3f; \"\n        \"p-error: %.3f, i-error: %.3f; Overall: %.3f; \"\n        \"packet tolerance: current: %u, last: %u\",\n        avg_acks_per_rtt, normalized, target, error, Kp * error,\n        conn->ifc_pts.integral_error, combined_error,\n        conn->ifc_last_calc_pack_tol, conn->ifc_last_pack_tol);\n    /* Until we have the first value, don't reset the counters */\n    if (conn->ifc_last_calc_pack_tol != 0)\n        conn->ifc_pts.n_acks = 0;\n\n  end:\n    if (lsquic_send_ctl_have_unacked_retx_data(&conn->ifc_send_ctl))\n    {\n        LSQ_DEBUG(\"set PACK_TOL alarm %\"PRIu64\" microseconds into the future\",\n            srtt * periodicity);\n        lsquic_alarmset_set(&conn->ifc_alset, al_id, now + srtt * periodicity);\n    }\n    else\n        LSQ_DEBUG(\"no unacked retx data: do not rearm the packet tolerance \"\n                                                                    \"alarm\");\n}\n\n\nstatic int\nprocess_ack (struct ietf_full_conn *conn, struct ack_info *acki,\n             lsquic_time_t received, lsquic_time_t now)\n{\n    enum packnum_space pns;\n    lsquic_packno_t packno;\n    int one_rtt_acked;\n\n    CONN_STATS(in.n_acks_proc, 1);\n    LSQ_DEBUG(\"Processing ACK\");\n    one_rtt_acked = lsquic_send_ctl_1rtt_acked(&conn->ifc_send_ctl);\n    if (0 == lsquic_send_ctl_got_ack(&conn->ifc_send_ctl, acki, received, now))\n    {\n        pns = acki->pns;\n        packno = lsquic_send_ctl_largest_ack2ed(&conn->ifc_send_ctl, pns);\n        /* It's OK to skip valid packno 0: the alternative is too expensive */\n        if (packno)\n            lsquic_rechist_stop_wait(&conn->ifc_rechist[ pns ], packno + 1);\n        /* ACK of 1-RTT packet indicates that handshake has been confirmed: */\n        if (!one_rtt_acked && lsquic_send_ctl_1rtt_acked(&conn->ifc_send_ctl))\n        {\n            if (!(conn->ifc_flags & IFC_IGNORE_INIT))\n                ignore_init(conn);\n            handshake_confirmed(conn);\n        }\n        return 0;\n    }\n    else\n    {\n        ABORT_ERROR(\"Received invalid ACK\");\n        return -1;\n    }\n}\n\n\nstatic unsigned\nprocess_path_challenge_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct conn_path *const path = &conn->ifc_paths[packet_in->pi_path_id];\n    int parsed_len;\n    char hexbuf[sizeof(path->cop_inc_chal) * 2 + 1];\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_path_chal_frame(p, len,\n        /* It's OK to overwrite incoming challenge, only reply to latest */\n                                                        &path->cop_inc_chal);\n    if (parsed_len > 0)\n    {\n        LSQ_DEBUG(\"received path challenge %s for path #%hhu\",\n            HEXSTR((unsigned char *) &path->cop_inc_chal,\n                sizeof(path->cop_inc_chal), hexbuf), packet_in->pi_path_id);\n        conn->ifc_send_flags |= SF_SEND_PATH_RESP << packet_in->pi_path_id;\n        return parsed_len;\n    }\n    else\n        return 0;\n}\n\n\n/* Why \"maybe?\"  Because it is possible that the peer did not provide us\n * enough CIDs and we had to reuse one.  See init_new_path().\n */\nstatic void\nmaybe_retire_dcid (struct ietf_full_conn *conn, const lsquic_cid_t *dcid)\n{\n    struct conn_path *copath;\n    struct dcid_elem **dce;\n    unsigned eqs;\n\n    eqs = 0;\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n        eqs += LSQUIC_CIDS_EQ(&copath->cop_path.np_dcid, dcid);\n\n    if (eqs > 1)\n    {\n        LSQ_INFOC(\"cannot retire %\"CID_FMT\", as it is used on more than one\"\n            \"path \", CID_BITS(dcid));\n        return;\n    }\n\n    for (dce = conn->ifc_dces; dce < DCES_END(conn); ++dce)\n        if (*dce && ((*dce)->de_flags & DE_ASSIGNED)\n                            && LSQUIC_CIDS_EQ(&(*dce)->de_cid, dcid))\n            break;\n\n    assert(dce < DCES_END(conn));\n    if (dce < DCES_END(conn))\n        retire_dcid(conn, dce);\n}\n\n\n/* Return true if the two paths differ only in peer port */\nstatic int\nonly_peer_port_changed (const struct network_path *old,\n                                                    struct network_path *new)\n{\n    const struct sockaddr *old_sa, *new_sa;\n\n    if (!lsquic_sockaddr_eq(NP_LOCAL_SA(old), NP_LOCAL_SA(new)))\n        return 0;\n\n    old_sa = NP_PEER_SA(old);\n    new_sa = NP_PEER_SA(new);\n    if (old_sa->sa_family == AF_INET)\n        return old_sa->sa_family == new_sa->sa_family\n            && ((struct sockaddr_in *) old_sa)->sin_addr.s_addr\n                            == ((struct sockaddr_in *) new_sa)->sin_addr.s_addr\n            && ((struct sockaddr_in *) old_sa)->sin_port\n                        != /* NE! */((struct sockaddr_in *) new_sa)->sin_port;\n    else\n        return old_sa->sa_family == new_sa->sa_family\n            && ((struct sockaddr_in6 *) old_sa)->sin6_port != /* NE! */\n                                ((struct sockaddr_in6 *) new_sa)->sin6_port\n            && 0 == memcmp(&((struct sockaddr_in6 *) old_sa)->sin6_addr,\n                        &((struct sockaddr_in6 *) new_sa)->sin6_addr,\n                        sizeof(((struct sockaddr_in6 *) new_sa)->sin6_addr));\n}\n\n\nstatic void\nswitch_path_to (struct ietf_full_conn *conn, unsigned char path_id)\n{\n    const unsigned char old_path_id = conn->ifc_cur_path_id;\n    const int keep_path_properties = conn->ifc_settings->es_optimistic_nat\n                    && only_peer_port_changed(CUR_NPATH(conn),\n                                    &conn->ifc_paths[path_id].cop_path);\n\n    assert(conn->ifc_cur_path_id != path_id);\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"switched paths\");\n    if (keep_path_properties)\n    {\n        conn->ifc_paths[path_id].cop_path.np_pack_size\n                                        = CUR_NPATH(conn)->np_pack_size;\n        LSQ_DEBUG(\"keep path properties: set MTU to %hu\",\n                        conn->ifc_paths[path_id].cop_path.np_pack_size);\n    }\n    lsquic_send_ctl_repath(&conn->ifc_send_ctl,\n        CUR_NPATH(conn), &conn->ifc_paths[path_id].cop_path,\n        keep_path_properties);\n    maybe_retire_dcid(conn, &CUR_NPATH(conn)->np_dcid);\n    conn->ifc_cur_path_id = path_id;\n    conn->ifc_pub.path = CUR_NPATH(conn);\n    conn->ifc_conn.cn_cur_cce_idx = CUR_CPATH(conn)->cop_cce_idx;\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << old_path_id);\n    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP << old_path_id);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_PATH_CHAL + old_path_id);\n    if (conn->ifc_flags & IFC_SERVER)\n        wipe_path(conn, old_path_id);\n}\n\n\nstatic unsigned\nprocess_path_response_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct conn_path *path;\n    int parsed_len;\n    unsigned i;\n    unsigned char path_id;\n    uint64_t path_resp;\n    char hexbuf[ sizeof(path_resp) * 2 + 1 ];\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_path_resp_frame(p, len,\n                                                                &path_resp);\n    if (parsed_len <= 0)\n        return 0;\n\n    LSQ_DEBUG(\"received path response: %s\",\n            HEXSTR((unsigned char *) &path_resp, sizeof(path_resp), hexbuf));\n\n    for (path = conn->ifc_paths; path < conn->ifc_paths\n                + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++path)\n    {\n        path_id = path - conn->ifc_paths;\n        if ((1 << path_id) & conn->ifc_used_paths)\n            for (i = 0; i < path->cop_n_chals; ++i)\n                if (path_resp == path->cop_path_chals[i])\n                    goto found;\n    }\n\n    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"received path response %s that does not correspond to any \"\n            \"challenge sent on this path\",\n            HEXSTR((unsigned char *) &path_resp, sizeof(path_resp), hexbuf));\n    return 0;\n\n  found:\n    if (path->cop_flags & COP_ALLOW_MTU_PADDING)\n    {\n        path->cop_flags |= (COP_VALIDATED | COP_VALIDATED_MTU);\n        conn->ifc_send_flags &= ~(SF_SEND_PATH_CHAL << path_id);\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_PATH_CHAL + path_id);\n    }\n    else\n    {\n        path->cop_flags |= (COP_VALIDATED | COP_ALLOW_MTU_PADDING);\n        conn->ifc_send_flags |= (SF_SEND_PATH_CHAL << path_id);\n    }\n    switch ((path_id != conn->ifc_cur_path_id) |\n                        (!!(path->cop_flags & COP_GOT_NONPROB) << 1))\n    {\n    case 3:\n        LSQ_INFO(\"path validated: switching from path #%hhu to path #%hhu\",\n            conn->ifc_cur_path_id, path_id);\n        switch_path_to(conn, path_id);\n        break;\n    case 1:\n        if (conn->ifc_flags & IFC_SERVER)\n            /* If you see this message in the log file, remember that\n             * COP_GOT_NONPROB is set after all frames in a packet have\n             * been processed.\n             */\n            LSQ_DEBUG(\"path #%hhu validated, but since no non-probing frames \"\n                \"have been received, delay switching to it\",\n                path_id);\n        else\n        {\n            LSQ_INFO(\"path validated: switching from path #%hhu to path #%hhu\",\n                conn->ifc_cur_path_id, path_id);\n            switch_path_to(conn, path_id);\n        }\n        break;\n    default:\n        LSQ_DEBUG(\"current path validated\");\n        break;\n    }\n\n    return parsed_len;\n}\n\n\nstatic lsquic_stream_t *\nfind_stream_by_id (struct ietf_full_conn *conn, lsquic_stream_id_t stream_id)\n{\n    struct lsquic_hash_elem *el;\n    el = lsquic_hash_find(conn->ifc_pub.all_streams, &stream_id,\n                                                            sizeof(stream_id));\n    if (el)\n        return lsquic_hashelem_getdata(el);\n    else\n        return NULL;\n}\n\n\nstatic void\nmaybe_schedule_ss_for_stream (struct ietf_full_conn *conn,\n                lsquic_stream_id_t stream_id, enum http_error_code error_code)\n{\n    struct stream_id_to_ss *sits;\n\n    if (conn_is_stream_closed(conn, stream_id))\n        return;\n\n    sits = malloc(sizeof(*sits));\n    if (!sits)\n        return;\n\n    sits->sits_stream_id = stream_id;\n    sits->sits_error_code = error_code;\n    STAILQ_INSERT_TAIL(&conn->ifc_stream_ids_to_ss, sits, sits_next);\n    conn->ifc_send_flags |= SF_SEND_STOP_SENDING;\n    conn_mark_stream_closed(conn, stream_id);\n}\n\n\nstruct buffered_priority_update\n{\n    struct lsquic_hash_elem     hash_el;\n    lsquic_stream_id_t          stream_id;\n    struct lsquic_ext_http_prio ehp;\n};\n\n\n#define MAX_CRITICAL_STREAM_ID 12\n/* This function is called to create incoming streams */\nstatic struct lsquic_stream *\nnew_stream (struct ietf_full_conn *conn, lsquic_stream_id_t stream_id,\n            enum stream_ctor_flags flags)\n{\n    const struct lsquic_stream_if *iface;\n    struct buffered_priority_update *bpu;\n    struct lsquic_hash_elem *el;\n    void *stream_ctx;\n    struct lsquic_stream *stream;\n    unsigned initial_window;\n    const int call_on_new = flags & SCF_CALL_ON_NEW;\n\n    flags &= ~SCF_CALL_ON_NEW;\n    flags |= SCF_DI_AUTOSWITCH|SCF_IETF;\n\n    if ((conn->ifc_flags & IFC_HTTP) && ((stream_id >> SD_SHIFT) & 1) == SD_UNI)\n    {\n        iface = unicla_if_ptr;\n        stream_ctx = conn;\n#if CLIENT_PUSH_SUPPORT\n        /* FIXME: This logic does not work for push streams.  Perhaps one way\n         * to address this is to reclassify them later?\n         */\n#endif\n        if (stream_id < MAX_CRITICAL_STREAM_ID)\n        {\n            flags |= SCF_CRITICAL;\n            ++conn->ifc_pub.n_special_streams;\n        }\n    }\n    else\n    {\n        iface = conn->ifc_enpub->enp_stream_if;\n        stream_ctx = conn->ifc_enpub->enp_stream_if_ctx;\n        if (conn->ifc_enpub->enp_settings.es_rw_once)\n            flags |= SCF_DISP_RW_ONCE;\n        if (conn->ifc_enpub->enp_settings.es_delay_onclose)\n            flags |= SCF_DELAY_ONCLOSE;\n        if (conn->ifc_flags & IFC_HTTP)\n        {\n            flags |= SCF_HTTP;\n            if (conn->ifc_pii == &ext_prio_iter_if)\n                flags |= SCF_HTTP_PRIO;\n        }\n    }\n\n    if (((stream_id >> SD_SHIFT) & 1) == SD_UNI)\n        initial_window = conn->ifc_enpub->enp_settings\n                                        .es_init_max_stream_data_uni;\n    else\n        initial_window = conn->ifc_enpub->enp_settings\n                                        .es_init_max_stream_data_bidi_remote;\n\n    stream = lsquic_stream_new(stream_id, &conn->ifc_pub,\n                               iface, stream_ctx, initial_window,\n                               conn->ifc_cfg.max_stream_send, flags);\n    if (stream)\n    {\n        if (conn->ifc_bpus)\n        {\n            el = lsquic_hash_find(conn->ifc_bpus, &stream->id,\n                                                        sizeof(stream->id));\n            if (el)\n            {\n                LSQ_DEBUG(\"apply buffered PRIORITY_UPDATE to stream %\"PRIu64,\n                                                                stream->id);\n                lsquic_hash_erase(conn->ifc_bpus, el);\n                bpu = lsquic_hashelem_getdata(el);\n                (void) lsquic_stream_set_http_prio(stream, &bpu->ehp);\n                free(bpu);\n            }\n        }\n        if (lsquic_hash_insert(conn->ifc_pub.all_streams, &stream->id,\n                            sizeof(stream->id), stream, &stream->sm_hash_el))\n        {\n            if (call_on_new)\n                lsquic_stream_call_on_new(stream);\n        }\n        else\n        {\n            lsquic_stream_destroy(stream);\n            stream = NULL;\n        }\n    }\n    return stream;\n}\n\n\nstatic int\nconn_is_send_only_stream (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (conn->ifc_flags & IFC_SERVER)\n        return sit == SIT_UNI_SERVER;\n    else\n        return sit == SIT_UNI_CLIENT;\n}\n\n\nstatic int\nconn_is_receive_only_stream (const struct ietf_full_conn *conn,\n                                                lsquic_stream_id_t stream_id)\n{\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (conn->ifc_flags & IFC_SERVER)\n        return sit == SIT_UNI_CLIENT;\n    else\n        return sit == SIT_UNI_SERVER;\n}\n\n\nstatic unsigned\nprocess_rst_stream_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t stream_id;\n    uint64_t offset, error_code;\n    lsquic_stream_t *stream;\n    int call_on_new;\n    const int parsed_len = conn->ifc_conn.cn_pf->pf_parse_rst_frame(p, len,\n                                            &stream_id, &offset, &error_code);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_RST_STREAM_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_id, offset,\n                                                                error_code);\n    LSQ_DEBUG(\"Got RST_STREAM; stream: %\"PRIu64\"; offset: 0x%\"PRIX64, stream_id,\n                                                                    offset);\n\n    if (conn_is_send_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received RESET_STREAM on send-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    call_on_new = 0;\n    stream = find_stream_by_id(conn, stream_id);\n    if (!stream)\n    {\n        if (conn_is_stream_closed(conn, stream_id))\n        {\n            LSQ_DEBUG(\"got reset frame for closed stream %\"PRIu64, stream_id);\n            return parsed_len;\n        }\n        if (!is_peer_initiated(conn, stream_id))\n        {\n            ABORT_ERROR(\"received reset for never-initiated stream %\"PRIu64,\n                                                                    stream_id);\n            return 0;\n        }\n\n        stream = new_stream(conn, stream_id, 0);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            return 0;\n        }\n        ++call_on_new;\n    }\n\n    if (0 != lsquic_stream_rst_in(stream, offset, error_code))\n    {\n        ABORT_ERROR(\"received invalid RST_STREAM\");\n        return 0;\n    }\n    if (call_on_new)\n        lsquic_stream_call_on_new(stream);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_stop_sending_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id, max_allowed;\n    uint64_t error_code;\n    int parsed_len, our_stream;\n    enum stream_state_sending sss;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stop_sending_frame(p, len,\n                                                    &stream_id, &error_code);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_STOP_SENDING_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_id, error_code);\n    LSQ_DEBUG(\"Got STOP_SENDING; stream: %\"PRIu64\"; error code: %\"PRIu64,\n                                                        stream_id, error_code);\n\n    if (conn_is_receive_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received STOP_SENDING on receive-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    our_stream = !is_peer_initiated(conn, stream_id);\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n    {\n        if (our_stream &&\n                    SSS_READY == (sss = lsquic_stream_sending_state(stream)))\n        {\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"stream %\"PRIu64\" is in \"\n                \"%s state: receipt of STOP_SENDING frame is a violation\",\n                stream_id, lsquic_sss2str[sss]);\n            return 0;\n        }\n        lsquic_stream_stop_sending_in(stream, error_code);\n    }\n    else if (conn_is_stream_closed(conn, stream_id))\n        LSQ_DEBUG(\"stream %\"PRIu64\" is closed: ignore STOP_SENDING frame\",\n            stream_id);\n    else if (our_stream)\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STOP_SENDING frame \"\n            \"on locally initiated stream that has not yet been opened\");\n        return 0;\n    }\n    else\n    {\n        max_allowed = conn->ifc_max_allowed_stream_id[stream_id & SIT_MASK];\n        if (stream_id >= max_allowed)\n        {\n            ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"incoming STOP_SENDING \"\n                \"for stream %\"PRIu64\" would exceed allowed max of %\"PRIu64,\n                stream_id, max_allowed);\n            return 0;\n        }\n        if (conn->ifc_flags & IFC_GOING_AWAY)\n        {\n            LSQ_DEBUG(\"going away: reject new incoming stream %\"PRIu64,\n                                                                    stream_id);\n            maybe_schedule_ss_for_stream(conn, stream_id, HEC_REQUEST_REJECTED);\n            return parsed_len;\n        }\n        stream = new_stream(conn, stream_id, 0);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            return 0;\n        }\n        lsquic_stream_stop_sending_in(stream, error_code);\n        if (!(conn->ifc_flags & IFC_HTTP))\n            lsquic_stream_call_on_new(stream);\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\ndiscard_crypto_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame stream_frame;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                &stream_frame);\n    if (parsed_len > 0)\n    {\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame\", parsed_len);\n        return (unsigned) parsed_len;\n    }\n    else\n        return 0;\n}\n\n\n/* In the server, we only wait for Finished frame */\nstatic unsigned\nprocess_crypto_frame_server (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame stream_frame;\n    enum enc_level enc_level;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                &stream_frame);\n    if (parsed_len < 0)\n        return 0;\n\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    EV_LOG_CRYPTO_FRAME_IN(LSQUIC_LOG_CONN_ID, &stream_frame, enc_level);\n    LSQ_DEBUG(\"Got CRYPTO frame for enc level #%u\", enc_level);\n    if (!(conn->ifc_flags & IFC_PROC_CRYPTO))\n    {\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame: handshake has been confirmed\",\n                                                                    parsed_len);\n        return (unsigned) parsed_len;\n    }\n    if (enc_level < ENC_LEV_HSK)\n    {   /* Must be dup */\n        LSQ_DEBUG(\"discard %d-byte CRYPTO frame on level %s\", parsed_len,\n                                                lsquic_enclev2str[enc_level]);\n        return (unsigned) parsed_len;\n    }\n\n    if (0 != conn->ifc_conn.cn_esf.i->esfi_data_in(\n                    conn->ifc_conn.cn_enc_session,\n                    lsquic_packet_in_enc_level(packet_in),\n                    stream_frame.data_frame.df_data,\n                    stream_frame.data_frame.df_size))\n    {\n        LSQ_DEBUG(\"feeding CRYPTO frame to enc session failed\");\n        return 0;\n    }\n\n    if (!conn->ifc_conn.cn_esf.i->esfi_in_init(conn->ifc_conn.cn_enc_session))\n    {\n        LSQ_DEBUG(\"handshake confirmed: send HANDSHAKE_DONE\");\n        conn->ifc_flags &= ~IFC_PROC_CRYPTO;\n        conn->ifc_send_flags |= SF_SEND_HANDSHAKE_DONE;\n\n        lsquic_alarmset_init_alarm(&conn->ifc_alset, AL_RET_CIDS,\n                                                ret_cids_alarm_expired, conn);\n        lsquic_alarmset_set(&conn->ifc_alset, AL_RET_CIDS,\n                                      lsquic_time_now() + RET_CID_TIMEOUT);\n    }\n\n    return (unsigned) parsed_len;\n}\n\n\nstatic unsigned\nprocess_crypto_frame_client (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame *stream_frame;\n    struct lsquic_stream *stream;\n    enum enc_level enc_level;\n    int parsed_len;\n\n    /* Ignore CRYPTO frames in server mode and in client mode after SSL object\n     * is gone.\n     */\n    if (!(conn->ifc_flags & IFC_PROC_CRYPTO))\n        return discard_crypto_frame(conn, packet_in, p, len);\n\n    stream_frame = lsquic_malo_get(conn->ifc_pub.mm->malo.stream_frame);\n    if (!stream_frame)\n    {\n        LSQ_WARN(\"could not allocate stream frame: %s\", strerror(errno));\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_crypto_frame(p, len,\n                                                                stream_frame);\n    if (parsed_len < 0) {\n        lsquic_malo_put(stream_frame);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                                                \"cannot decode CRYPTO frame\");\n        return 0;\n    }\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    EV_LOG_CRYPTO_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_frame, enc_level);\n    LSQ_DEBUG(\"Got CRYPTO frame for enc level #%u\", enc_level);\n    if ((conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n                                                && enc_level != ENC_LEV_APP)\n    {\n        LSQ_DEBUG(\"handshake complete: ignore CRYPTO frames in \"\n            \"non-forward-secure packets\");\n        return parsed_len;\n    }\n\n    if (conn->ifc_flags & IFC_CLOSING)\n    {\n        LSQ_DEBUG(\"Connection closing: ignore frame\");\n        lsquic_malo_put(stream_frame);\n        return parsed_len;\n    }\n\n    assert(!(conn->ifc_flags & IFC_SERVER));\n    if (conn->ifc_u.cli.crypto_streams[enc_level])\n        stream = conn->ifc_u.cli.crypto_streams[enc_level];\n    else\n    {\n        stream = lsquic_stream_new_crypto(enc_level, &conn->ifc_pub,\n                    &lsquic_cry_sm_if, conn->ifc_conn.cn_enc_session,\n                    SCF_IETF|SCF_DI_AUTOSWITCH|SCF_CALL_ON_NEW|SCF_CRITICAL);\n        if (!stream)\n        {\n            lsquic_malo_put(stream_frame);\n            ABORT_WARN(\"cannot create crypto stream for level %u\", enc_level);\n            return 0;\n        }\n        conn->ifc_u.cli.crypto_streams[enc_level] = stream;\n        (void) lsquic_stream_wantread(stream, 1);\n    }\n\n    stream_frame->packet_in = lsquic_packet_in_get(packet_in);\n    if (0 != lsquic_stream_frame_in(stream, stream_frame))\n    {\n        ABORT_ERROR(\"cannot insert stream frame\");\n        return 0;\n    }\n\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {   /* To enable decryption, process handshake stream as soon as its\n         * data frames are received.\n         *\n         * TODO: this does not work when packets are reordered.  A more\n         * flexible solution would defer packet decryption if handshake\n         * has not been completed yet.  Nevertheless, this is good enough\n         * for now.\n         */\n        lsquic_stream_dispatch_read_events(stream);\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_crypto_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    if (conn->ifc_flags & IFC_SERVER)\n        return process_crypto_frame_server(conn, packet_in, p, len);\n    else\n        return process_crypto_frame_client(conn, packet_in, p, len);\n}\n\n\nstatic unsigned\nprocess_stream_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct stream_frame *stream_frame;\n    struct lsquic_stream *stream;\n    int parsed_len;\n\n    stream_frame = lsquic_malo_get(conn->ifc_pub.mm->malo.stream_frame);\n    if (!stream_frame)\n    {\n        LSQ_WARN(\"could not allocate stream frame: %s\", strerror(errno));\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stream_frame(p, len,\n                                                                stream_frame);\n    if (parsed_len < 0) {\n        lsquic_malo_put(stream_frame);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                                                \"cannot decode STREAM frame\");\n        return 0;\n    }\n    EV_LOG_STREAM_FRAME_IN(LSQUIC_LOG_CONN_ID, stream_frame);\n    CONN_STATS(in.stream_frames, 1);\n    CONN_STATS(in.stream_data_sz, stream_frame->data_frame.df_size);\n\n    if (conn_is_send_only_stream(conn, stream_frame->stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STREAM frame \"\n            \"on send-only stream %\"PRIu64, stream_frame->stream_id);\n        return 0;\n    }\n\n    if ((conn->ifc_flags & (IFC_SERVER|IFC_HTTP)) == IFC_HTTP\n                    && SIT_BIDI_SERVER == (stream_frame->stream_id & SIT_MASK))\n    {\n        ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR, \"HTTP/3 server \"\n            \"is not allowed to initiate bidirectional streams (got \"\n            \"STREAM frame for stream %\"PRIu64, stream_frame->stream_id);\n        return 0;\n    }\n\n    if (conn->ifc_flags & IFC_CLOSING)\n    {\n        LSQ_DEBUG(\"Connection closing: ignore frame\");\n        lsquic_malo_put(stream_frame);\n        return parsed_len;\n    }\n\n    stream = find_stream_by_id(conn, stream_frame->stream_id);\n    if (!stream)\n    {\n        if (conn_is_stream_closed(conn, stream_frame->stream_id))\n        {\n            LSQ_DEBUG(\"drop frame for closed stream %\"PRIu64,\n                                                stream_frame->stream_id);\n            lsquic_malo_put(stream_frame);\n            return parsed_len;\n        }\n        if (is_peer_initiated(conn, stream_frame->stream_id))\n        {\n            const lsquic_stream_id_t max_allowed =\n                conn->ifc_max_allowed_stream_id[stream_frame->stream_id & SIT_MASK];\n            if (stream_frame->stream_id >= max_allowed)\n            {\n                ABORT_QUIETLY(0, TEC_STREAM_LIMIT_ERROR, \"incoming stream \"\n                    \"%\"PRIu64\" exceeds allowed max of %\"PRIu64,\n                    stream_frame->stream_id, max_allowed);\n                lsquic_malo_put(stream_frame);\n                return 0;\n            }\n            if (conn->ifc_flags & IFC_GOING_AWAY)\n            {\n                LSQ_DEBUG(\"going away: reject new incoming stream %\"PRIu64,\n                                                    stream_frame->stream_id);\n                maybe_schedule_ss_for_stream(conn, stream_frame->stream_id,\n                                                        HEC_REQUEST_REJECTED);\n                lsquic_malo_put(stream_frame);\n                return parsed_len;\n            }\n        }\n        else\n        {\n            ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received STREAM frame \"\n                                                \"for never-initiated stream\");\n            lsquic_malo_put(stream_frame);\n            return 0;\n        }\n        stream = new_stream(conn, stream_frame->stream_id, SCF_CALL_ON_NEW);\n        if (!stream)\n        {\n            ABORT_ERROR(\"cannot create new stream: %s\", strerror(errno));\n            lsquic_malo_put(stream_frame);\n            return 0;\n        }\n        if (SD_BIDI == ((stream_frame->stream_id >> SD_SHIFT) & 1)\n                && (!valid_stream_id(conn->ifc_max_req_id)\n                        || conn->ifc_max_req_id < stream_frame->stream_id))\n            conn->ifc_max_req_id = stream_frame->stream_id;\n    }\n\n    stream_frame->packet_in = lsquic_packet_in_get(packet_in);\n    if (0 != lsquic_stream_frame_in(stream, stream_frame))\n    {\n        ABORT_ERROR(\"cannot insert stream frame\");\n        return 0;\n    }\n\n    /* Don't wait for the regular on_read dispatch in order to save an\n     * unnecessary blocked/unblocked sequence.\n     */\n    if ((conn->ifc_flags & IFC_HTTP) && conn->ifc_qdh.qdh_enc_sm_in == stream)\n        lsquic_stream_dispatch_read_events(conn->ifc_qdh.qdh_enc_sm_in);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_ack_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct ack_info *new_acki;\n    enum packnum_space pns;\n    int parsed_len;\n    lsquic_time_t warn_time;\n\n    CONN_STATS(in.n_acks, 1);\n\n    if (conn->ifc_flags & IFC_HAVE_SAVED_ACK)\n        new_acki = conn->ifc_pub.mm->acki;\n    else\n        new_acki = &conn->ifc_ack;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_ack_frame(p, len, new_acki,\n                                                        conn->ifc_cfg.ack_exp);\n    if (parsed_len < 0)\n        goto err;\n\n    /* This code to throw out old ACKs is what keeps us compliant with this\n     * requirement:\n     *\n     * [draft-ietf-quic-transport-18] Section 13.3.2.\n     *\n     > Processing counts out of order can result in verification failure.\n     > An endpoint SHOULD NOT perform this verification if the ACK frame is\n     > received in a packet with packet number lower than a previously\n     > received ACK frame.  Verifying based on ACK frames that arrive out of\n     > order can result in disabling ECN unnecessarily.\n     */\n    pns = lsquic_hety2pns[ packet_in->pi_header_type ];\n    if (is_valid_packno(conn->ifc_max_ack_packno[pns]) &&\n                        packet_in->pi_packno <= conn->ifc_max_ack_packno[pns])\n    {\n        LSQ_DEBUG(\"Ignore old ack (max %\"PRIu64\")\",\n                                                conn->ifc_max_ack_packno[pns]);\n        return parsed_len;\n    }\n\n    EV_LOG_ACK_FRAME_IN(LSQUIC_LOG_CONN_ID, new_acki);\n    conn->ifc_max_ack_packno[pns] = packet_in->pi_packno;\n    new_acki->pns = pns;\n\n    ++conn->ifc_pts.n_acks;\n\n    /* Only cache ACKs for PNS_APP */\n    if (pns == PNS_APP && new_acki == &conn->ifc_ack)\n    {\n        LSQ_DEBUG(\"Saved ACK\");\n        conn->ifc_flags |= IFC_HAVE_SAVED_ACK;\n        conn->ifc_saved_ack_received = packet_in->pi_received;\n    }\n    else if (pns == PNS_APP)\n    {\n        if (0 == lsquic_merge_acks(&conn->ifc_ack, new_acki))\n        {\n            CONN_STATS(in.n_acks_merged, 1);\n            LSQ_DEBUG(\"merged into saved ACK, getting %s\",\n                (lsquic_acki2str(&conn->ifc_ack, conn->ifc_pub.mm->ack_str,\n                                MAX_ACKI_STR_SZ), conn->ifc_pub.mm->ack_str));\n        }\n        else\n        {\n            LSQ_DEBUG(\"could not merge new ACK into saved ACK\");\n            if (0 != process_ack(conn, &conn->ifc_ack, packet_in->pi_received,\n                                                        packet_in->pi_received))\n                goto err;\n            conn->ifc_ack = *new_acki;\n        }\n        conn->ifc_saved_ack_received = packet_in->pi_received;\n    }\n    else\n    {\n        if (0 != process_ack(conn, new_acki, packet_in->pi_received,\n                                                packet_in->pi_received))\n            goto err;\n    }\n\n    return parsed_len;\n\n  err:\n    warn_time = lsquic_time_now();\n    if (0 == conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL]\n        || conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL]\n                + WARNING_INTERVAL < warn_time)\n    {\n        conn->ifc_enpub->enp_last_warning[WT_ACKPARSE_FULL] = warn_time;\n        LSQ_WARN(\"Invalid ACK frame\");\n    }\n    return 0;\n}\n\n\nstatic unsigned\nprocess_ping_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{   /* This frame causes ACK frame to be queued, but nothing to do here;\n     * return the length of this frame.\n     */\n    EV_LOG_PING_FRAME_IN(LSQUIC_LOG_CONN_ID);\n    if (conn->ifc_flags & IFC_SERVER)\n        log_conn_flow_control(conn);\n\n    LSQ_DEBUG(\"received PING frame, update last progress to %\"PRIu64,\n                                            conn->ifc_pub.last_tick);\n    conn->ifc_pub.last_prog = conn->ifc_pub.last_tick;\n\n    return 1;\n}\n\n\nstatic int\nis_benign_transport_error_code (uint64_t error_code)\n{\n    switch (error_code)\n    {\n    case TEC_NO_ERROR:\n    case TEC_INTERNAL_ERROR:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\n\nstatic int\nis_benign_application_error_code (uint64_t error_code)\n{\n    switch (error_code)\n    {\n    case HEC_NO_ERROR:\n    case HEC_INTERNAL_ERROR:\n        return 1;\n    default:\n        return 0;\n    }\n}\n\n\nstatic unsigned\nprocess_connection_close_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t error_code;\n    uint16_t reason_len;\n    uint8_t reason_off;\n    int parsed_len, app_error;\n    const char *ua;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_connect_close_frame(p, len,\n                            &app_error, &error_code, &reason_len, &reason_off);\n    if (parsed_len < 0)\n        return 0;\n    EV_LOG_CONNECTION_CLOSE_FRAME_IN(LSQUIC_LOG_CONN_ID, error_code,\n                            (int) reason_len, (const char *) p + reason_off);\n    if (LSQ_LOG_ENABLED(LSQ_LOG_NOTICE)\n        && !(   (!app_error && is_benign_transport_error_code(error_code))\n              ||( app_error && is_benign_application_error_code(error_code))))\n    {\n        if (conn->ifc_flags & IFC_HTTP)\n        {\n            ua = lsquic_qdh_get_ua(&conn->ifc_qdh);\n            if (!ua)\n                ua = \"unknown peer\";\n        }\n        else\n            ua = \"non-HTTP/3 peer\";\n        LSQ_NOTICE(\"Received CONNECTION_CLOSE from <%s> with %s-level error \"\n            \"code %\"PRIu64\", reason: `%.*s'\", ua,\n            app_error ? \"application\" : \"transport\", error_code,\n            (int) reason_len, (const char *) p + reason_off);\n    }\n    else\n        LSQ_INFO(\"Received CONNECTION_CLOSE frame (%s-level code: %\"PRIu64\"; \"\n            \"reason: %.*s)\", app_error ? \"application\" : \"transport\",\n                error_code, (int) reason_len, (const char *) p + reason_off);\n    if (conn->ifc_enpub->enp_stream_if->on_conncloseframe_received)\n        conn->ifc_enpub->enp_stream_if->on_conncloseframe_received(\n            &conn->ifc_conn, app_error, error_code, (const char *) p + reason_off, reason_len);\n    conn->ifc_flags |= IFC_RECV_CLOSE|IFC_CLOSING;\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_data_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t max_data;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_data(p, len, &max_data);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX MAX_DATA frame; offset: %\"PRIu64,\n        max_data);\n    if (max_data > conn->ifc_pub.conn_cap.cc_max)\n    {\n        LSQ_DEBUG(\"max data goes from %\"PRIu64\" to %\"PRIu64,\n                                conn->ifc_pub.conn_cap.cc_max, max_data);\n        conn->ifc_pub.conn_cap.cc_max = max_data;\n    }\n    else\n        LSQ_DEBUG(\"newly supplied max data=%\"PRIu64\" is not larger than the \"\n            \"current value=%\"PRIu64\", ignoring\", max_data,\n                                conn->ifc_pub.conn_cap.cc_max);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_stream_data_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    uint64_t max_data;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_stream_data_frame(p, len,\n                                                            &stream_id, &max_data);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX MAX_STREAM_DATA frame; \"\n        \"stream_id: %\"PRIu64\"; offset: %\"PRIu64, stream_id, max_data);\n    if (conn_is_receive_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received MAX_STREAM_DATA on receive-only stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n        lsquic_stream_window_update(stream, max_data);\n    else if (conn_is_stream_closed(conn, stream_id))\n        LSQ_DEBUG(\"stream %\"PRIu64\" is closed: ignore MAX_STREAM_DATA frame\",\n                                                                    stream_id);\n    else\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR, \"received MAX_STREAM_DATA \"\n            \"frame on never-opened stream %\"PRIu64, stream_id);\n        return 0;\n    }\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_max_streams_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t max_stream_id;\n    enum stream_id_type sit;\n    enum stream_dir sd;\n    uint64_t max_streams;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_max_streams_frame(p, len,\n                                                            &sd, &max_streams);\n    if (parsed_len < 0)\n        return 0;\n\n    sit = gen_sit(conn->ifc_flags & IFC_SERVER, sd);\n    max_stream_id = max_streams << SIT_SHIFT;\n\n    if (max_stream_id > VINT_MAX_VALUE)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"MAX_STREAMS: max %s stream ID of %\"PRIu64\" exceeds maximum \"\n            \"stream ID\", sd == SD_BIDI ? \"bidi\" : \"uni\", max_stream_id);\n        return 0;\n    }\n\n    if (max_stream_id > conn->ifc_max_allowed_stream_id[sit])\n    {\n        LSQ_DEBUG(\"max %s stream ID updated from %\"PRIu64\" to %\"PRIu64,\n            sd == SD_BIDI ? \"bidi\" : \"uni\",\n            conn->ifc_max_allowed_stream_id[sit], max_stream_id);\n        conn->ifc_max_allowed_stream_id[sit] = max_stream_id;\n    }\n    else\n        LSQ_DEBUG(\"ignore old max %s streams value of %\"PRIu64,\n            sd == SD_BIDI ? \"bidi\" : \"uni\", max_streams);\n\n    return parsed_len;\n}\n\n\n/* Returns true if current DCID was retired.  In this case, it must be\n * replaced.\n */\nstatic int\nretire_dcids_prior_to (struct ietf_full_conn *conn, unsigned retire_prior_to)\n{\n    struct dcid_elem **el;\n    int update_cur_dcid = 0;\n#if LSQUIC_LOWEST_LOG_LEVEL >= LSQ_LOG_DEBUG\n    unsigned count = 0;\n#endif\n\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (*el && (*el)->de_seqno < retire_prior_to)\n        {\n            update_cur_dcid |= LSQUIC_CIDS_EQ(&(*el)->de_cid, CUR_DCID(conn));\n            retire_dcid(conn, el);\n#if LSQUIC_LOWEST_LOG_LEVEL >= LSQ_LOG_DEBUG\n            ++count;\n#endif\n        }\n\n    LSQ_DEBUG(\"retired %u DCID%s due to Retire Prior To=%u\", count,\n        count != 1 ? \"s\" : \"\", retire_prior_to);\n    return update_cur_dcid;\n}\n\n\nstatic int\ninsert_new_dcid (struct ietf_full_conn *conn, uint64_t seqno,\n    const lsquic_cid_t *cid, const unsigned char *token, int update_cur_dcid)\n{\n    struct dcid_elem **dce, **el;\n    char tokstr[IQUIC_SRESET_TOKEN_SZ * 2 + 1];\n\n    dce = NULL;\n    for (el = conn->ifc_dces; el < conn->ifc_dces + sizeof(conn->ifc_dces)\n                                            / sizeof(conn->ifc_dces[0]); ++el)\n        if (*el)\n        {\n            if ((*el)->de_seqno == seqno)\n            {\n                if (!LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))\n                {\n                    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                        \"NEW_CONNECTION_ID: already have CID seqno %\"PRIu64\n                        \" but with a different CID\", seqno);\n                    return -1;\n                }\n                else\n                {\n                    LSQ_DEBUG(\"Ignore duplicate CID seqno %\"PRIu64, seqno);\n                    return 0;\n                }\n            }\n            else if (LSQUIC_CIDS_EQ(&(*el)->de_cid, cid))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                    \"NEW_CONNECTION_ID: received the same CID with sequence \"\n                    \"numbers %u and %\"PRIu64, (*el)->de_seqno, seqno);\n                return -1;\n            }\n            else if (((*el)->de_flags & DE_SRST)\n                    && 0 == memcmp((*el)->de_srst, token,\n                                                    IQUIC_SRESET_TOKEN_SZ))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                    \"NEW_CONNECTION_ID: received second instance of reset \"\n                    \"token %s in seqno %\"PRIu64\", same as in seqno %u\",\n                    (lsquic_hexstr(token, IQUIC_SRESET_TOKEN_SZ, tokstr,\n                                                    sizeof(tokstr)), tokstr),\n                    seqno, (*el)->de_seqno);\n                return -1;\n            }\n        }\n        else if (!dce)\n            dce = el;\n\n    if (!dce)\n    {\n        ABORT_QUIETLY(0, TEC_CONNECTION_ID_LIMIT_ERROR,\n            \"NEW_CONNECTION_ID: received connection ID that is going over the \"\n            \"limit of %u CIDs\", MAX_IETF_CONN_DCIDS);\n        return -1;\n    }\n\n    *dce = lsquic_malo_get(conn->ifc_pub.mm->malo.dcid_elem);\n    if (*dce)\n    {\n        memset(*dce, 0, sizeof(**dce));\n        (*dce)->de_seqno = seqno;\n        (*dce)->de_cid = *cid;\n        memcpy((*dce)->de_srst, token, sizeof((*dce)->de_srst));\n        (*dce)->de_flags |= DE_SRST;\n        if (update_cur_dcid)\n        {\n            *CUR_DCID(conn) = *cid;\n            if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n                CUR_CPATH(conn)->cop_spin_bit = 0;\n        }\n    }\n    else\n        LSQ_WARN(\"cannot allocate dce to insert DCID seqno %\"PRIu64, seqno);\n\n    return 0;\n}\n\n\nstatic unsigned\nprocess_new_connection_id_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const unsigned char *token;\n    const char *action_str;\n    lsquic_cid_t cid;\n    uint64_t seqno, retire_prior_to;\n    int parsed_len, update_cur_dcid;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_new_conn_id(p, len,\n                                        &seqno, &retire_prior_to, &cid, &token);\n    if (parsed_len < 0)\n    {\n        if (parsed_len == -2)\n            ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n                \"NEW_CONNECTION_ID contains invalid CID length\");\n        return 0;\n    }\n\n    if (seqno > UINT32_MAX || retire_prior_to > UINT32_MAX)\n    {   /* It is wasteful to use 8-byte integers for these counters, so this\n         * is the guard here.  This will \"Never Happen.\"\n         */\n        LSQ_INFO(\"ignoring unreasonably high seqno=%\"PRIu64\" or Retire Prior \"\n            \"To=%\"PRIu64, seqno, retire_prior_to);\n        return parsed_len;\n    }\n\n    if (retire_prior_to > seqno)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"NEW_CONNECTION_ID: Retire Prior To=%\"PRIu64\" is larger then the \"\n            \"Sequence Number=%\"PRIu64, retire_prior_to, seqno);\n        return 0;\n    }\n\n    if (CUR_DCID(conn)->len == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"Received NEW_CONNECTION_ID \"\n            \"frame, but current DCID is zero-length\");\n        return 0;\n    }\n\n    if (seqno < conn->ifc_last_retire_prior_to)\n    {\n        retire_seqno(conn, seqno);\n        action_str = \"Ignored (seqno smaller than last retire_prior_to\";\n        goto end;\n    }\n\n    if (retire_prior_to > conn->ifc_last_retire_prior_to)\n    {\n        conn->ifc_last_retire_prior_to = retire_prior_to;\n        update_cur_dcid = retire_dcids_prior_to(conn, retire_prior_to);\n    }\n    else\n        update_cur_dcid = 0;\n\n    if (0 != insert_new_dcid(conn, seqno, &cid, token, update_cur_dcid))\n        return 0;\n    action_str = \"Saved\";\n\n  end:\n    LSQ_DEBUGC(\"Got new connection ID from peer: seq=%\"PRIu64\"; \"\n        \"cid: %\"CID_FMT\".  %s.\", seqno, CID_BITS(&cid), action_str);\n    return parsed_len;\n}\n\n\nstatic void\nretire_cid (struct ietf_full_conn *conn, struct conn_cid_elem *cce,\n                                                        lsquic_time_t now)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    lsquic_time_t drain_time;\n\n    drain_time = calc_drain_time(conn);\n    LSQ_DEBUGC(\"retiring CID %\"CID_FMT\"; seqno: %u; %s; drain time %\"PRIu64\n                \" usec\", CID_BITS(&cce->cce_cid), cce->cce_seqno,\n                (cce->cce_flags & CCE_SEQNO) ? \"\" : \"original\", drain_time);\n\n    if (cce->cce_flags & CCE_SEQNO)\n        --conn->ifc_active_cids_count;\n    lsquic_engine_retire_cid(conn->ifc_enpub, lconn, cce - lconn->cn_cces, now,\n                                                                    drain_time);\n    memset(cce, 0, sizeof(*cce));\n\n    if (can_issue_cids(conn)\n        && !(lsquic_alarmset_is_set(&conn->ifc_alset, AL_CID_THROT)))\n        maybe_get_rate_available_scid_slot(conn, now);\n}\n\n\nstatic unsigned\nprocess_retire_connection_id_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n    uint64_t seqno;\n    int parsed_len;\n\n    /* [draft-ietf-quic-transport-25] Section 19.16\n     *\n     * - Peer cannot retire zero-lenth CID. (MUST treat as PROTOCOL_VIOLATION)\n     * - Peer cannot retire CID with sequence number that has not been\n     *   allocated yet. (MUST treat as PROTOCOL_VIOLATION)\n     * - Peer cannot retire CID that matches the DCID in packet.\n     *   (MAY treat as PROTOCOL_VIOLATION)\n     */\n    if (conn->ifc_settings->es_scid_len == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire zero-length CID\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_retire_cid_frame(p, len,\n                                                                    &seqno);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"got RETIRE_CONNECTION_ID frame: \"\n                                                        \"seqno=%\"PRIu64, seqno);\n    if (seqno >= conn->ifc_scid_seqno)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire CID seqno=\"\n                        \"%\"PRIu64\" as it has not been allocated yet\", seqno);\n        return 0;\n    }\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if ((lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces))\n                && (cce->cce_flags & CCE_SEQNO)\n                && cce->cce_seqno == seqno))\n            break;\n    /* NOTE: https://github.com/litespeedtech/lsquic/issues/334\n    conn->ifc_active_cids_count -= seqno >= conn->ifc_first_active_cid_seqno;\n    */\n    if (cce < END_OF_CCES(lconn))\n    {\n        if (LSQUIC_CIDS_EQ(&cce->cce_cid, &packet_in->pi_dcid))\n        {\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, \"cannot retire CID \"\n                \"seqno=%\"PRIu64\", for it is used as DCID in the packet\", seqno);\n            return 0;\n        }\n        retire_cid(conn, cce, packet_in->pi_received);\n        if (lconn->cn_cur_cce_idx == cce - lconn->cn_cces)\n        {\n            cce = find_cce_by_cid(conn, &packet_in->pi_dcid);\n            if (cce)\n            {\n                cce->cce_flags |= CCE_USED;\n                lconn->cn_cur_cce_idx = cce - lconn->cn_cces;\n                LSQ_DEBUGC(\"current SCID was retired; set current SCID to \"\n                    \"%\"CID_FMT\" based on DCID in incoming packet\",\n                    CID_BITS(&packet_in->pi_dcid));\n            }\n            else\n                LSQ_WARN(\"current SCID was retired; no new SCID candidate\");\n                /* This could theoretically happen when zero-length CIDs were\n                 * used.  Currently, there should be no way lsquic could get\n                 * into this situation.\n                 */\n        }\n    }\n    else\n        LSQ_DEBUG(\"cannot retire CID seqno=%\"PRIu64\": not found\", seqno);\n    LOG_SCIDS(conn);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_new_token_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const unsigned char *token;\n    size_t token_sz;\n    char *token_str;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_new_token_frame(p, len, &token,\n                                                                    &token_sz);\n    if (parsed_len < 0)\n        return 0;\n\n    if (0 == token_sz)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR, \"received an empty \"\n            \"NEW_TOKEN frame\");\n        return 0;\n    }\n\n    if (conn->ifc_flags & IFC_SERVER)\n    {   /* [draft-ietf-quic-transport-34] Section 19.7 */\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                                    \"received unexpected NEW_TOKEN frame\");\n        return 0;\n    }\n\n    if (LSQ_LOG_ENABLED(LSQ_LOG_DEBUG)\n                            || LSQ_LOG_ENABLED_EXT(LSQ_LOG_DEBUG, LSQLM_EVENT))\n    {\n        token_str = malloc(token_sz * 2 + 1);\n        if (token_str)\n        {\n            lsquic_hexstr(token, token_sz, token_str, token_sz * 2 + 1);\n            LSQ_DEBUG(\"Got %zu-byte NEW_TOKEN %s\", token_sz, token_str);\n            EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"got NEW_TOKEN %s\",\n                                                                    token_str);\n            free(token_str);\n        }\n    }\n    if (conn->ifc_enpub->enp_stream_if->on_new_token)\n        conn->ifc_enpub->enp_stream_if->on_new_token(\n                        conn->ifc_enpub->enp_stream_if_ctx, token, token_sz);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_stream_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    struct lsquic_stream *stream;\n    lsquic_stream_id_t stream_id;\n    uint64_t peer_off;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_stream_blocked_frame(p,\n                                                len, &stream_id, &peer_off);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX STREAM_BLOCKED frame: stream \"\n        \"%\"PRIu64\"; offset %\"PRIu64, stream_id, peer_off);\n    LSQ_DEBUG(\"received STREAM_BLOCKED frame: stream %\"PRIu64\n                                    \"; offset %\"PRIu64, stream_id, peer_off);\n\n    if (conn_is_send_only_stream(conn, stream_id))\n    {\n        ABORT_QUIETLY(0, TEC_STREAM_STATE_ERROR,\n            \"received STREAM_BLOCKED frame on send-only stream %\"PRIu64,\n                                                                stream_id);\n        return 0;\n    }\n\n    stream = find_stream_by_id(conn, stream_id);\n    if (stream)\n        lsquic_stream_peer_blocked(stream, peer_off);\n    else\n        LSQ_DEBUG(\"stream %\"PRIu64\" not found - ignore STREAM_BLOCKED frame\",\n            stream_id);\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_streams_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    lsquic_stream_id_t max_stream_id;\n    uint64_t stream_limit;\n    enum stream_dir sd;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_streams_blocked_frame(p,\n                                                len, &sd, &stream_limit);\n    if (parsed_len < 0)\n        return 0;\n\n    max_stream_id = stream_limit << SIT_SHIFT;\n    if (max_stream_id > VINT_MAX_VALUE)\n    {\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR,\n            \"STREAMS_BLOCKED: max %s stream ID of %\"PRIu64\" exceeds maximum \"\n            \"stream ID\", sd == SD_BIDI ? \"bidi\" : \"uni\", max_stream_id);\n        return 0;\n    }\n\n    LSQ_DEBUG(\"received STREAMS_BLOCKED frame: limited to %\"PRIu64\n        \" %sdirectional stream%.*s\", stream_limit, sd == SD_UNI ? \"uni\" : \"bi\",\n        stream_limit != 1, \"s\");\n    /* We don't do anything with this information -- at least for now */\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_blocked_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t peer_off;\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_blocked_frame(p, len,\n                                                                &peer_off);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX BLOCKED frame: offset %\"PRIu64,\n                                                                    peer_off);\n    LSQ_DEBUG(\"received BLOCKED frame: offset %\"PRIu64, peer_off);\n\n    if (peer_off > conn->ifc_last_max_data_off_sent\n                                && !(conn->ifc_send_flags & SF_SEND_MAX_DATA))\n    {\n        conn->ifc_send_flags |= SF_SEND_MAX_DATA;\n        LSQ_DEBUG(\"marked to send MAX_DATA frame\");\n    }\n    else if (conn->ifc_send_flags & SF_SEND_MAX_DATA)\n        LSQ_DEBUG(\"MAX_STREAM_DATA frame is already scheduled\");\n    else\n        LSQ_DEBUG(\"MAX_DATA(%\"PRIu64\") has already been either \"\n            \"packetized or sent to peer\", conn->ifc_last_max_data_off_sent);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_handshake_done_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    int parsed_len;\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_handshake_done_frame(p, len);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX HANDSHAKE_DONE frame\");\n    LSQ_DEBUG(\"received HANDSHAKE_DONE frame\");\n\n    if (conn->ifc_flags & IFC_SERVER)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Client cannot send HANDSHAKE_DONE frame\");\n        return 0;\n    }\n\n    handshake_confirmed(conn);\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_ack_frequency_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    uint64_t seqno, pack_tol, upd_mad;\n    int parsed_len, ignore;\n\n    if (!conn->ifc_settings->es_delayed_acks\n        && !(conn->ifc_flags & IFC_DELAYED_ACKS))\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected ACK_FREQUENCY frame (not negotiated)\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_ack_frequency_frame(p, len,\n                                        &seqno, &pack_tol, &upd_mad, &ignore);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"RX ACK_FREQUENCY frame: (seqno: %\"PRIu64\"; \"\n        \"pack_tol: %\"PRIu64\"; upd: %\"PRIu64\"; ignore: %d)\", seqno,\n        pack_tol, upd_mad, ignore);\n    LSQ_DEBUG(\"RX ACK_FREQUENCY frame: (seqno: %\"PRIu64\"; pack_tol: %\"PRIu64\"; \"\n        \"upd: %\"PRIu64\"; ignore: %d)\", seqno, pack_tol, upd_mad,\n        ignore);\n\n    if (pack_tol == 0)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Packet Tolerance of zero is invalid\");\n        return 0;\n    }\n\n    if (upd_mad < TP_MIN_ACK_DELAY)\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Update Max Ack Delay value of %\"PRIu64\" usec is invalid, as it \"\n            \"is smaller than the advertised min_ack_delay of %u usec\",\n            upd_mad, TP_MIN_ACK_DELAY);\n        return 0;\n    }\n\n    if (conn->ifc_max_ack_freq_seqno > 0\n                                    && seqno <= conn->ifc_max_ack_freq_seqno)\n    {\n        LSQ_DEBUG(\"ignore old ACK_FREQUENCY frame\");\n        return parsed_len;\n    }\n    conn->ifc_max_ack_freq_seqno = seqno;\n\n    if (pack_tol < UINT_MAX)\n    {\n        LSQ_DEBUG(\"set packet tolerance to %\"PRIu64, pack_tol);\n        conn->ifc_max_retx_since_last_ack = pack_tol;\n    }\n\n    if (upd_mad != conn->ifc_max_ack_delay)\n    {\n        conn->ifc_max_ack_delay = upd_mad;\n        LSQ_DEBUG(\"set Max Ack Delay to new value of %\"PRIu64\" usec\",\n            conn->ifc_max_ack_delay);\n    }\n    else\n        LSQ_DEBUG(\"keep Max Ack Delay unchanged at %\"PRIu64\" usec\",\n            conn->ifc_max_ack_delay);\n\n    if (ignore)\n    {\n        conn->ifc_mflags |= MF_IGNORE_MISSING;\n        conn->ifc_flags &= ~IFC_ACK_HAD_MISS;\n    }\n    else\n        conn->ifc_mflags &= ~MF_IGNORE_MISSING;\n\n    return parsed_len;\n}\n\n\nstatic unsigned\nprocess_timestamp_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected TIMESTAMP frame (not negotiated)\");\n    return 0;\n}\n\n\nstatic unsigned\nprocess_datagram_frame (struct ietf_full_conn *conn,\n    struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    const void *data;\n    size_t data_sz;\n    int parsed_len;\n\n    if (!(conn->ifc_flags & IFC_DATAGRAMS))\n    {\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"Received unexpected DATAGRAM frame (not negotiated)\");\n        return 0;\n    }\n\n    parsed_len = conn->ifc_conn.cn_pf->pf_parse_datagram_frame(p, len,\n                                                            &data, &data_sz);\n    if (parsed_len < 0)\n        return 0;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"%zd-byte DATAGRAM\", data_sz);\n    LSQ_DEBUG(\"%zd-byte DATAGRAM\", data_sz);\n\n    conn->ifc_enpub->enp_stream_if->on_datagram(&conn->ifc_conn, data, data_sz);\n\n    return parsed_len;\n}\n\n\ntypedef unsigned (*process_frame_f)(\n    struct ietf_full_conn *, struct lsquic_packet_in *,\n    const unsigned char *p, size_t);\n\n\nstatic process_frame_f const process_frames[N_QUIC_FRAMES] =\n{\n    [QUIC_FRAME_PADDING]            =  process_padding_frame,\n    [QUIC_FRAME_RST_STREAM]         =  process_rst_stream_frame,\n    [QUIC_FRAME_CONNECTION_CLOSE]   =  process_connection_close_frame,\n    [QUIC_FRAME_MAX_DATA]           =  process_max_data_frame,\n    [QUIC_FRAME_MAX_STREAM_DATA]    =  process_max_stream_data_frame,\n    [QUIC_FRAME_MAX_STREAMS]        =  process_max_streams_frame,\n    [QUIC_FRAME_PING]               =  process_ping_frame,\n    [QUIC_FRAME_BLOCKED]            =  process_blocked_frame,\n    [QUIC_FRAME_STREAM_BLOCKED]     =  process_stream_blocked_frame,\n    [QUIC_FRAME_STREAMS_BLOCKED]    =  process_streams_blocked_frame,\n    [QUIC_FRAME_NEW_CONNECTION_ID]  =  process_new_connection_id_frame,\n    [QUIC_FRAME_NEW_TOKEN]          =  process_new_token_frame,\n    [QUIC_FRAME_STOP_SENDING]       =  process_stop_sending_frame,\n    [QUIC_FRAME_ACK]                =  process_ack_frame,\n    [QUIC_FRAME_PATH_CHALLENGE]     =  process_path_challenge_frame,\n    [QUIC_FRAME_PATH_RESPONSE]      =  process_path_response_frame,\n    [QUIC_FRAME_RETIRE_CONNECTION_ID] =  process_retire_connection_id_frame,\n    [QUIC_FRAME_STREAM]             =  process_stream_frame,\n    [QUIC_FRAME_CRYPTO]             =  process_crypto_frame,\n    [QUIC_FRAME_HANDSHAKE_DONE]     =  process_handshake_done_frame,\n    [QUIC_FRAME_ACK_FREQUENCY]      =  process_ack_frequency_frame,\n    [QUIC_FRAME_TIMESTAMP]          =  process_timestamp_frame,\n    [QUIC_FRAME_DATAGRAM]           =  process_datagram_frame,\n};\n\n\nstatic unsigned\nprocess_packet_frame (struct ietf_full_conn *conn,\n        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)\n{\n    enum enc_level enc_level;\n    enum quic_frame_type type;\n    char str[8 * 2 + 1];\n\n    enc_level = lsquic_packet_in_enc_level(packet_in);\n    type = conn->ifc_conn.cn_pf->pf_parse_frame_type(p, len);\n    if (lsquic_legal_frames_by_level[conn->ifc_conn.cn_version][enc_level]\n                                                                & (1 << type))\n    {\n        LSQ_DEBUG(\"about to process %s frame\", frame_type_2_str[type]);\n        packet_in->pi_frame_types |= 1 << type;\n        return process_frames[type](conn, packet_in, p, len);\n    }\n    else\n    {\n        LSQ_DEBUG(\"invalid frame %u (bytes: %s) at encryption level %s\",\n            type, HEXSTR(p, MIN(len, 8), str), lsquic_enclev2str[enc_level]);\n        ABORT_QUIETLY(0, TEC_FRAME_ENCODING_ERROR, \"invalid frame\");\n        return 0;\n    }\n}\n\n\nstatic struct dcid_elem *\nfind_unassigned_dcid (struct ietf_full_conn *conn)\n{\n    struct dcid_elem **dce;\n\n    for (dce = conn->ifc_dces; dce < DCES_END(conn); ++dce)\n        if (*dce && !((*dce)->de_flags & DE_ASSIGNED))\n            return *dce;\n\n    return NULL;\n}\n\n\nstatic struct conn_cid_elem *\nfind_cce_by_cid (struct ietf_full_conn *conn, const lsquic_cid_t *cid)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_cid_elem *cce;\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if ((lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces)))\n                                        && LSQUIC_CIDS_EQ(&cce->cce_cid, cid))\n            return cce;\n\n    return NULL;\n}\n\n\nstatic int\ninit_new_path (struct ietf_full_conn *conn, struct conn_path *path,\n                                                            int dcid_changed)\n{\n    struct dcid_elem *dce;\n\n    dce = find_unassigned_dcid(conn);\n    if (dce)\n    {\n        LSQ_DEBUGC(\"assigned new DCID %\"CID_FMT\" to new path %u\",\n                CID_BITS(&dce->de_cid), (unsigned) (path - conn->ifc_paths));\n        path->cop_path.np_dcid = dce->de_cid;\n        dce->de_flags |= DE_ASSIGNED;\n    }\n    else if (!dcid_changed || CUR_DCID(conn)->len == 0)\n    {\n        /* It is OK to reuse DCID if it is zero-length or ir the peer did not\n         * use a new DCID when its address changed.  See\n         * [draft-ietf-quic-transport-24] Section 9.5.\n         */\n        path->cop_path.np_dcid = CUR_NPATH(conn)->np_dcid;\n        LSQ_DEBUGC(\"assigned already-used DCID %\"CID_FMT\" to new path %u, \"\n            \"as incoming DCID did not change\",\n            CID_BITS(&path->cop_path.np_dcid),\n            (unsigned) (path - conn->ifc_paths));\n    }\n    else\n    {\n        LSQ_DEBUG(\"Don't have an unassigned DCID: cannot initialize path\");\n        return -1;\n    }\n\n    path->cop_path.np_pack_size\n                = calc_base_packet_size(conn, NP_IS_IPv6(&path->cop_path));\n\n    if (conn->ifc_max_udp_payload < path->cop_path.np_pack_size)\n        path->cop_path.np_pack_size = conn->ifc_max_udp_payload;\n\n    LSQ_DEBUG(\"initialized path %u\", (unsigned) (path - conn->ifc_paths));\n\n    return 0;\n}\n\n\nstatic int\non_new_or_unconfirmed_path (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct conn_path *const path = &conn->ifc_paths[packet_in->pi_path_id];\n    struct conn_cid_elem *cce;\n    int dcid_changed;\n    char cidbuf_[MAX_CID_LEN * 2 + 1];\n\n    /* An endpoint only changes the address that it sends packets to in\n     * response to the highest-numbered non-probing packet.  This ensures\n     * that an endpoint does not send packets to an old peer address in the\n     * case that it receives reordered packets.\n     *\n     * [draft-ietf-quic-transport-20], Section 9.3.\n     */\n    if (lsquic_packet_in_non_probing(packet_in)\n                        && packet_in->pi_packno > conn->ifc_max_non_probing)\n        path->cop_flags |= COP_GOT_NONPROB;\n\n    /* If we cannot find a SCID at this point, something is wrong. */\n    cce = find_cce_by_cid(conn, &packet_in->pi_dcid);\n    if (!cce)\n    {\n        ABORT_ERROR(\"DCID %\"CID_FMT\" not found on new path\",\n                                            CID_BITS(&packet_in->pi_dcid));\n        return -1;\n    }\n\n    dcid_changed = !(cce->cce_flags & CCE_USED);\n    if (!(path->cop_flags & COP_INITIALIZED))\n    {\n        LSQ_DEBUGC(\"current SCID: %\"CID_FMT, CID_BITS(CN_SCID(&conn->ifc_conn)));\n        LSQ_DEBUGC(\"packet in DCID: %\"CID_FMT\"; changed: %d\",\n                                    CID_BITS(&packet_in->pi_dcid), dcid_changed);\n        if (0 == init_new_path(conn, path, dcid_changed))\n        {\n            path->cop_flags |= COP_INITIALIZED;\n            if (packet_in->pi_data_sz >= IQUIC_MIN_INIT_PACKET_SZ / 3)\n                path->cop_flags |= COP_ALLOW_MTU_PADDING;\n        }\n        else\n            return -1;\n\n        conn->ifc_send_flags |= SF_SEND_PATH_CHAL << packet_in->pi_path_id;\n        LSQ_DEBUG(\"scheduled return path challenge on path %hhu\",\n                                                        packet_in->pi_path_id);\n    }\n    else if ((path->cop_flags & (COP_VALIDATED|COP_GOT_NONPROB))\n                                            == (COP_VALIDATED|COP_GOT_NONPROB))\n    {\n        assert(path->cop_flags & COP_INITIALIZED);\n        LSQ_DEBUG(\"received non-probing frame on validated path %hhu, \"\n            \"switch to it\", packet_in->pi_path_id);\n        switch_path_to(conn, packet_in->pi_path_id);\n    }\n\n    path->cop_cce_idx = cce - lconn->cn_cces;\n    cce->cce_flags |= CCE_USED;\n    LOG_SCIDS(conn);\n    return 0;\n}\n\n\nstatic void\nparse_regular_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    const unsigned char *p, *pend;\n    unsigned len;\n\n    p = packet_in->pi_data + packet_in->pi_header_sz;\n    pend = packet_in->pi_data + packet_in->pi_data_sz;\n\n    if (p < pend)\n        do\n        {\n            len = process_packet_frame(conn, packet_in, p, pend - p);\n            if (len > 0)\n                p += len;\n            else\n            {\n                ABORT_ERROR(\"Error parsing frame\");\n                break;\n            }\n        }\n        while (p < pend);\n    else\n        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n            \"packet %\"PRIu64\" has no frames\", packet_in->pi_packno);\n}\n\n\n/* From [draft-ietf-quic-transport-24] Section 13.2.1:\n *      \" An endpoint MUST NOT send a non-ack-eliciting packet in response\n *      \" to a non-ack-eliciting packet, even if there are packet gaps\n *      \" which precede the received packet.\n *\n * To ensure that we always send an ack-eliciting packet in this case, we\n * check that there are frames that are about to be written.\n */\nstatic int\nmany_in_and_will_write (struct ietf_full_conn *conn)\n{\n    return conn->ifc_n_slack_all > MAX_ANY_PACKETS_SINCE_LAST_ACK\n        && (conn->ifc_send_flags\n            || !TAILQ_EMPTY(&conn->ifc_pub.sending_streams)\n            || !TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n        ;\n}\n\n\nstatic void\nforce_queueing_ack_app (struct ietf_full_conn *conn)\n{\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n    lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n    conn->ifc_flags |= IFC_ACK_QUED_APP;\n    LSQ_DEBUG(\"force-queued ACK\");\n}\n\n\nenum was_missing {\n    /* Note that particular enum values matter for speed */\n    WM_NONE    = 0,\n    WM_MAX_GAP = 1, /* Newly arrived ackable packet introduced a gap in incoming\n                     * packet number sequence.\n                     */\n    WM_SMALLER = 2, /* Newly arrived ackable packet is smaller than previously\n                     * seen maximum number.\n                     */\n\n};\n\n\nstatic void\ntry_queueing_ack_app (struct ietf_full_conn *conn,\n                    enum was_missing was_missing, int ecn, lsquic_time_t now)\n{\n    lsquic_time_t srtt, ack_timeout;\n\n    if (conn->ifc_n_slack_akbl[PNS_APP] >= conn->ifc_max_retx_since_last_ack\n/* From [draft-ietf-quic-transport-29] Section 13.2.1:\n \" Similarly, packets marked with the ECN Congestion Experienced (CE)\n \" codepoint in the IP header SHOULD be acknowledged immediately, to\n \" reduce the peer's response time to congestion events.\n */\n            || (ecn == ECN_CE\n                    && lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n            || (was_missing == WM_MAX_GAP)\n            || ((conn->ifc_flags & IFC_ACK_HAD_MISS)\n                    && was_missing == WM_SMALLER\n                    && conn->ifc_n_slack_akbl[PNS_APP] > 0)\n            || many_in_and_will_write(conn))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_flags |= IFC_ACK_QUED_APP;\n        LSQ_DEBUG(\"%s ACK queued: ackable: %u; all: %u; had_miss: %d; \"\n            \"was_missing: %d\",\n            lsquic_pns2str[PNS_APP], conn->ifc_n_slack_akbl[PNS_APP],\n            conn->ifc_n_slack_all,\n            !!(conn->ifc_flags & IFC_ACK_HAD_MISS), (int) was_missing);\n    }\n    else if (conn->ifc_n_slack_akbl[PNS_APP] > 0)\n    {\n        if (!lsquic_alarmset_is_set(&conn->ifc_alset, AL_ACK_APP))\n        {\n            /* See https://github.com/quicwg/base-drafts/issues/3304 for more */\n            srtt = lsquic_rtt_stats_get_srtt(&conn->ifc_pub.rtt_stats);\n            if (srtt)\n                ack_timeout = MAX(1000, MIN(conn->ifc_max_ack_delay, srtt / 4));\n            else\n                ack_timeout = conn->ifc_max_ack_delay;\n            lsquic_alarmset_set(&conn->ifc_alset, AL_ACK_APP,\n                                                            now + ack_timeout);\n            LSQ_DEBUG(\"%s ACK alarm set to %\"PRIu64, lsquic_pns2str[PNS_APP],\n                                                            now + ack_timeout);\n        }\n        else\n            LSQ_DEBUG(\"%s ACK alarm already set to %\"PRIu64\" usec from now\",\n                lsquic_pns2str[PNS_APP],\n                conn->ifc_alset.as_expiry[AL_ACK_APP] - now);\n    }\n}\n\n\nstatic void\ntry_queueing_ack_init_or_hsk (struct ietf_full_conn *conn,\n                                                        enum packnum_space pns)\n{\n    if (conn->ifc_n_slack_akbl[pns] > 0)\n    {\n        conn->ifc_flags |= IFC_ACK_QUED_INIT << pns;\n        LSQ_DEBUG(\"%s ACK queued: ackable: %u\",\n            lsquic_pns2str[pns], conn->ifc_n_slack_akbl[pns]);\n    }\n}\n\n\nstatic int\nmaybe_queue_opp_ack (struct ietf_full_conn *conn)\n{\n    if (/* If there is at least one ackable packet */\n        conn->ifc_n_slack_akbl[PNS_APP] > 0\n        /* ...and there are things to write */\n        && (!TAILQ_EMPTY(&conn->ifc_pub.write_streams) || conn->ifc_send_flags)\n        /* ...and writing is possible */\n        && write_is_possible(conn))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_ACK_APP);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_flags |= IFC_ACK_QUED_APP;\n        LSQ_DEBUG(\"%s ACK queued opportunistically\", lsquic_pns2str[PNS_APP]);\n        return 1;\n    }\n    else\n        return 0;\n}\n\n\nstatic int\nverify_retry_packet (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    unsigned char *pseudo_packet;\n    size_t out_len, ad_len;\n    unsigned ret_ver;\n    int verified;\n\n    if (1 + CUR_DCID(conn)->len + packet_in->pi_data_sz > 0x1000)\n    {\n        /* Cover the theoretical possibility that we cannot fit the pseudo-\n         * packet and 16-byte decrypted output into 4 KB:\n         */\n        LSQ_INFO(\"%s: Retry packet is too long: %hu bytes\", __func__,\n                                                        packet_in->pi_data_sz);\n        return -1;\n    }\n\n    pseudo_packet = lsquic_mm_get_4k(conn->ifc_pub.mm);\n    if (!pseudo_packet)\n    {\n        LSQ_INFO(\"%s: cannot allocate memory\", __func__);\n        return -1;\n    }\n\n    pseudo_packet[0] = CUR_DCID(conn)->len;\n    memcpy(pseudo_packet + 1, CUR_DCID(conn)->idbuf, CUR_DCID(conn)->len);\n    memcpy(pseudo_packet + 1 + CUR_DCID(conn)->len, packet_in->pi_data,\n                                                    packet_in->pi_data_sz);\n\n    ret_ver = lsquic_version_2_retryver(conn->ifc_conn.cn_version);\n    out_len = 0;\n    ad_len = 1 + CUR_DCID(conn)->len + packet_in->pi_data_sz - 16;\n    verified = 1 == EVP_AEAD_CTX_open(\n                    &conn->ifc_enpub->enp_retry_aead_ctx[ret_ver],\n                    pseudo_packet + ad_len, &out_len, out_len,\n                    lsquic_retry_nonce_buf[ret_ver], IETF_RETRY_NONCE_SZ,\n                    pseudo_packet + ad_len, 16, pseudo_packet, ad_len)\n            && out_len == 0;\n\n    lsquic_mm_put_4k(conn->ifc_pub.mm, pseudo_packet);\n    return verified ? 0 : -1;\n}\n\n\nstatic int\nprocess_retry_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    lsquic_cid_t scid;\n\n    if (conn->ifc_flags & (IFC_SERVER|IFC_RETRIED))\n    {\n        /* [draft-ietf-quic-transport-24] Section 17.2.5:\n         \" After the client has received and processed an Initial or Retry\n         \" packet from the server, it MUST discard any subsequent Retry\n         \" packets that it receives.\n         */\n        LSQ_DEBUG(\"ignore Retry packet\");\n        return 0;\n    }\n\n    if (CUR_DCID(conn)->len == packet_in->pi_scid_len\n            && 0 == memcmp(CUR_DCID(conn)->idbuf,\n                    packet_in->pi_data + packet_in->pi_scid_off,\n                    packet_in->pi_scid_len))\n    {\n        /*\n         * [draft-ietf-quic-transport-24] Section 17.2.5:\n         \" A client MUST discard a Retry packet that contains a Source\n         \" Connection ID field that is identical to the Destination\n         \" Connection ID field of its Initial packet.\n         */\n        LSQ_DEBUG(\"server provided same SCID as ODCID: discard packet\");\n        return 0;\n    }\n\n    if (0 != verify_retry_packet(conn, packet_in))\n    {\n        LSQ_DEBUG(\"cannot verify retry packet: ignore it\");\n        return 0;\n    }\n\n    if (0 != lsquic_send_ctl_retry(&conn->ifc_send_ctl,\n                    packet_in->pi_data + packet_in->pi_token,\n                            packet_in->pi_token_size))\n        return -1;\n\n    lsquic_scid_from_packet_in(packet_in, &scid);\n    if (0 != conn->ifc_conn.cn_esf.i->esfi_reset_dcid(\n                    conn->ifc_conn.cn_enc_session, CUR_DCID(conn), &scid))\n        return -1;\n\n    *CUR_DCID(conn) = scid;\n    if (CUR_CPATH(conn)->cop_flags & COP_SPIN_BIT)\n        CUR_CPATH(conn)->cop_spin_bit = 0;\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_INIT);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_HSK);\n    lsquic_alarmset_unset(&conn->ifc_alset, AL_RETX_APP);\n\n    LSQ_INFO(\"Received a retry packet.  Will retry.\");\n    conn->ifc_flags |= IFC_RETRIED;\n    return 0;\n}\n\n\nstatic int\nis_stateless_reset (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    struct lsquic_hash_elem *el;\n\n    if (packet_in->pi_data_sz < IQUIC_MIN_SRST_SIZE)\n        return 0;\n\n    el = lsquic_hash_find(conn->ifc_enpub->enp_srst_hash,\n            packet_in->pi_data + packet_in->pi_data_sz - IQUIC_SRESET_TOKEN_SZ,\n            IQUIC_SRESET_TOKEN_SZ);\n    if (!el)\n        return 0;\n\n#ifndef NDEBUG\n    const struct lsquic_conn *reset_lconn;\n    reset_lconn = lsquic_hashelem_getdata(el);\n    assert(reset_lconn == &conn->ifc_conn);\n#endif\n    return 1;\n}\n\n\n/*\n * Sets the new current SCID if the DCID in the incoming packet:\n *  (1) was issued by this endpoint and\n *  (2) has not been used before.\n */\nstatic int\non_dcid_change (struct ietf_full_conn *conn, const lsquic_cid_t *dcid_in)\n{\n    struct lsquic_conn *const lconn = &conn->ifc_conn;  /* Shorthand */\n    struct conn_cid_elem *cce;\n\n    LSQ_DEBUGC(\"peer switched its DCID to %\"CID_FMT\n              \", attempt to switch own SCID\", CID_BITS(dcid_in));\n\n    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)\n        if (cce - lconn->cn_cces != lconn->cn_cur_cce_idx\n                && (lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces)))\n                    && LSQUIC_CIDS_EQ(&cce->cce_cid, dcid_in))\n            break;\n\n    if (cce >= END_OF_CCES(lconn))\n    {\n        ABORT_WARN(\"DCID not found\");\n        return -1;\n    }\n\n    if (cce->cce_flags & CCE_USED)\n    {\n        LSQ_DEBUGC(\"Current CID: %\"CID_FMT, CID_BITS(CN_SCID(lconn)));\n        LSQ_DEBUGC(\"DCID %\"CID_FMT\" has been used, not switching\",\n                                                            CID_BITS(dcid_in));\n        return 0;\n    }\n\n    cce->cce_flags |= CCE_USED;\n    lconn->cn_cur_cce_idx = cce - lconn->cn_cces;\n    LSQ_DEBUGC(\"%s: set SCID to %\"CID_FMT, __func__, CID_BITS(CN_SCID(lconn)));\n    LOG_SCIDS(conn);\n\n    return 0;\n}\n\n\nstatic void\nignore_init (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"henceforth, no Initial packets shall be sent or received\");\n    conn->ifc_flags |= IFC_IGNORE_INIT;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << PNS_INIT);\n    lsquic_send_ctl_empty_pns(&conn->ifc_send_ctl, PNS_INIT);\n    lsquic_rechist_cleanup(&conn->ifc_rechist[PNS_INIT]);\n    if (!(conn->ifc_flags & IFC_SERVER))\n    {\n        if (conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT])\n        {\n            lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT]);\n            conn->ifc_u.cli.crypto_streams[ENC_LEV_INIT] = NULL;\n        }\n        conn->ifc_conn.cn_if = ietf_full_conn_iface_ptr;\n    }\n}\n\n\nstatic void\nignore_hsk (struct ietf_full_conn *conn)\n{\n    LSQ_DEBUG(\"henceforth, no Handshake packets shall be sent or received\");\n    conn->ifc_flags |= IFC_IGNORE_HSK;\n    conn->ifc_flags &= ~(IFC_ACK_QUED_INIT << PNS_HSK);\n    lsquic_send_ctl_empty_pns(&conn->ifc_send_ctl, PNS_HSK);\n    lsquic_rechist_cleanup(&conn->ifc_rechist[PNS_HSK]);\n    if (!(conn->ifc_flags & IFC_SERVER))\n        if (conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK])\n        {\n            lsquic_stream_destroy(conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK]);\n            conn->ifc_u.cli.crypto_streams[ENC_LEV_HSK] = NULL;\n        }\n}\n\n\nstatic void\nrecord_dcid (struct ietf_full_conn *conn,\n                                    const struct lsquic_packet_in *packet_in)\n{\n    unsigned orig_cid_len;\n\n    orig_cid_len = CUR_DCID(conn)->len;\n    conn->ifc_flags |= IFC_DCID_SET;\n    lsquic_scid_from_packet_in(packet_in, CUR_DCID(conn));\n    LSQ_DEBUGC(\"set DCID to %\"CID_FMT, CID_BITS(CUR_DCID(conn)));\n    lsquic_send_ctl_cidlen_change(&conn->ifc_send_ctl, orig_cid_len,\n                                                        CUR_DCID(conn)->len);\n}\n\n\nstatic int\nholes_after (struct lsquic_rechist *rechist, lsquic_packno_t packno)\n{\n    const struct lsquic_packno_range *first_range;\n\n    first_range = lsquic_rechist_peek(rechist);\n    /* If it's not in the very first range, there is obviously a gap\n     * between it and the maximum packet number.  If the packet number\n     * in question preceeds the cutoff, we assume that there are no\n     * holes (as we simply have no information).\n     */\n    return first_range\n        && packno < first_range->low\n        && packno > lsquic_rechist_cutoff(rechist);\n}\n\n\nstatic int\nprocess_regular_packet (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    struct conn_path *cpath;\n    enum packnum_space pns;\n    enum received_st st;\n    enum dec_packin dec_packin;\n    enum was_missing was_missing;\n    int is_rechist_empty;\n    unsigned char saved_path_id;\n    int is_dcid_changed;\n\n    if (HETY_RETRY == packet_in->pi_header_type)\n        return process_retry_packet(conn, packet_in);\n\n    CONN_STATS(in.packets, 1);\n\n    pns = lsquic_hety2pns[ packet_in->pi_header_type ];\n    if ((pns == PNS_INIT && (conn->ifc_flags & IFC_IGNORE_INIT))\n                    || (pns == PNS_HSK  && (conn->ifc_flags & IFC_IGNORE_HSK)))\n    {\n        /* Don't bother decrypting */\n        LSQ_DEBUG(\"ignore %s packet\",\n            pns == PNS_INIT ? \"Initial\" : \"Handshake\");\n        EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"ignore %s packet\",\n                                                        lsquic_pns2str[pns]);\n        return 0;\n    }\n\n    /* If a client receives packets from an unknown server address, the client\n     * MUST discard these packets.\n     *      [draft-ietf-quic-transport-20], Section 9\n     */\n    if (packet_in->pi_path_id != conn->ifc_cur_path_id\n        && 0 == (conn->ifc_flags & IFC_SERVER)\n        && !(packet_in->pi_path_id == conn->ifc_mig_path_id\n                && migra_is_on(conn, conn->ifc_mig_path_id)))\n    {\n        /* The \"known server address\" is recorded in the current path. */\n        switch ((NP_IS_IPv6(CUR_NPATH(conn)) << 1) |\n                 NP_IS_IPv6(&conn->ifc_paths[packet_in->pi_path_id].cop_path))\n        {\n        case (1 << 1) | 1:  /* IPv6 */\n            if (lsquic_sockaddr_eq(NP_PEER_SA(CUR_NPATH(conn)), NP_PEER_SA(\n                        &conn->ifc_paths[packet_in->pi_path_id].cop_path)))\n                goto known_peer_addr;\n            break;\n        case (0 << 1) | 0:  /* IPv4 */\n            if (lsquic_sockaddr_eq(NP_PEER_SA(CUR_NPATH(conn)), NP_PEER_SA(\n                        &conn->ifc_paths[packet_in->pi_path_id].cop_path)))\n                goto known_peer_addr;\n            break;\n        }\n        LSQ_DEBUG(\"ignore packet from unknown server address\");\n        return 0;\n    }\n  known_peer_addr:\n\n    /* The packet is decrypted before receive history is updated.  This is\n     * done to make sure that a bad packet won't occupy a slot in receive\n     * history and subsequent good packet won't be marked as a duplicate.\n     */\n    if (0 == (packet_in->pi_flags & PI_DECRYPTED))\n    {\n        dec_packin = conn->ifc_conn.cn_esf_c->esf_decrypt_packet(\n                            conn->ifc_conn.cn_enc_session, conn->ifc_enpub,\n                            &conn->ifc_conn, packet_in);\n        switch (dec_packin)\n        {\n        case DECPI_BADCRYPT:\n        case DECPI_TOO_SHORT:\n            if (conn->ifc_enpub->enp_settings.es_honor_prst\n                /* In server mode, even if we do support stateless reset packets,\n                 * they are handled in lsquic_engine.c.  No need to have this\n                 * logic here.\n                 */\n                && !(conn->ifc_flags & IFC_SERVER)\n                                        && is_stateless_reset(conn, packet_in))\n            {\n                LSQ_INFO(\"received stateless reset packet: aborting connection\");\n                conn->ifc_flags |= IFC_GOT_PRST;\n                return -1;\n            }\n            else if (dec_packin == DECPI_BADCRYPT)\n            {\n                CONN_STATS(in.undec_packets, 1);\n                LSQ_INFO(\"could not decrypt packet (type %s)\",\n                                    lsquic_hety2str[packet_in->pi_header_type]);\n                return 0;\n            }\n            else\n            {\n                CONN_STATS(in.undec_packets, 1);\n                LSQ_INFO(\"packet is too short to be decrypted\");\n                return 0;\n            }\n        case DECPI_NOT_YET:\n            return 0;\n        case DECPI_NOMEM:\n            return 0;\n        case DECPI_VIOLATION:\n            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                                    \"decrypter reports protocol violation\");\n            return -1;\n        case DECPI_OK:\n            /* Receiving any other type of packet precludes subsequent retries.\n             * We only set it if decryption is successful.\n             */\n            conn->ifc_flags |= IFC_RETRIED;\n            break;\n        }\n    }\n\n    is_dcid_changed = !LSQUIC_CIDS_EQ(CN_SCID(&conn->ifc_conn),\n                                        &packet_in->pi_dcid);\n    if (pns == PNS_INIT)\n        conn->ifc_conn.cn_esf.i->esfi_set_iscid(conn->ifc_conn.cn_enc_session,\n                                                                    packet_in);\n    else\n    {\n        if (is_dcid_changed)\n        {\n            if (LSQUIC_CIDS_EQ(&conn->ifc_conn.cn_cces[0].cce_cid,\n                            &packet_in->pi_dcid)\n                && !(conn->ifc_conn.cn_cces[0].cce_flags & CCE_SEQNO))\n            {\n                ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION,\n                            \"protocol violation detected bad dcid\");\n                return -1;\n            }\n        }\n        if (pns == PNS_HSK)\n        {\n            if ((conn->ifc_flags & (IFC_SERVER | IFC_IGNORE_INIT)) == IFC_SERVER)\n                ignore_init(conn);\n            lsquic_send_ctl_maybe_calc_rough_rtt(&conn->ifc_send_ctl, pns - 1);\n        }\n    }\n    EV_LOG_PACKET_IN(LSQUIC_LOG_CONN_ID, packet_in);\n\n    is_rechist_empty = lsquic_rechist_is_empty(&conn->ifc_rechist[pns]);\n    st = lsquic_rechist_received(&conn->ifc_rechist[pns], packet_in->pi_packno,\n                                                    packet_in->pi_received);\n    switch (st) {\n    case REC_ST_OK:\n        if (!(conn->ifc_flags & (IFC_SERVER|IFC_DCID_SET)))\n            record_dcid(conn, packet_in);\n        saved_path_id = conn->ifc_cur_path_id;\n        parse_regular_packet(conn, packet_in);\n        if (saved_path_id == conn->ifc_cur_path_id)\n        {\n            if (conn->ifc_cur_path_id != packet_in->pi_path_id)\n            {\n                if (0 != on_new_or_unconfirmed_path(conn, packet_in))\n                {\n                    LSQ_DEBUG(\"path %hhu invalid, cancel any path response \"\n                        \"on it\", packet_in->pi_path_id);\n                    conn->ifc_send_flags &= ~(SF_SEND_PATH_RESP\n                                                    << packet_in->pi_path_id);\n                }\n            }\n            else if (is_dcid_changed\n                && !LSQUIC_CIDS_EQ(CN_SCID(&conn->ifc_conn),\n                                   &packet_in->pi_dcid))\n            {\n                if (0 != on_dcid_change(conn, &packet_in->pi_dcid))\n                    return -1;\n            }\n        }\n        if (lsquic_packet_in_non_probing(packet_in)\n                        && packet_in->pi_packno > conn->ifc_max_non_probing)\n            conn->ifc_max_non_probing = packet_in->pi_packno;\n        /* From [draft-ietf-quic-transport-30] Section 13.2.1:\n         *\n \" In order to assist loss detection at the sender, an endpoint SHOULD\n \" generate and send an ACK frame without delay when it receives an ack-\n \" eliciting packet either:\n \"\n \" *  when the received packet has a packet number less than another\n \"    ack-eliciting packet that has been received, or\n \"\n \" *  when the packet has a packet number larger than the highest-\n \"    numbered ack-eliciting packet that has been received and there are\n \"    missing packets between that packet and this packet.\n        *\n        */\n        if (packet_in->pi_frame_types & IQUIC_FRAME_ACKABLE_MASK)\n        {\n            if (PNS_APP == pns /* was_missing is only used in PNS_APP */)\n            {\n                if (packet_in->pi_packno > conn->ifc_max_ackable_packno_in)\n                {\n                    was_missing = (enum was_missing)    /* WM_MAX_GAP is 1 */\n                        !is_rechist_empty /* Don't count very first packno */\n                        && conn->ifc_max_ackable_packno_in + 1\n                                                    < packet_in->pi_packno\n                        && holes_after(&conn->ifc_rechist[PNS_APP],\n                            conn->ifc_max_ackable_packno_in);\n                    conn->ifc_max_ackable_packno_in = packet_in->pi_packno;\n                }\n                else\n                    was_missing = (enum was_missing)    /* WM_SMALLER is 2 */\n                    /* The check is necessary (rather setting was_missing to\n                     * WM_SMALLER) because we cannot guarantee that peer does\n                     * not have bugs.\n                     */\n                        ((packet_in->pi_packno\n                                    < conn->ifc_max_ackable_packno_in) << 1);\n            }\n            else\n                was_missing = WM_NONE;\n            ++conn->ifc_n_slack_akbl[pns];\n        }\n        else\n            was_missing = WM_NONE;\n        conn->ifc_n_slack_all += PNS_APP == pns;\n        if (0 == (conn->ifc_flags & (IFC_ACK_QUED_INIT << pns)))\n        {\n            if (PNS_APP == pns)\n                try_queueing_ack_app(conn, was_missing,\n                    lsquic_packet_in_ecn(packet_in), packet_in->pi_received);\n            else\n                try_queueing_ack_init_or_hsk(conn, pns);\n        }\n        conn->ifc_incoming_ecn <<= 1;\n        conn->ifc_incoming_ecn |=\n                            lsquic_packet_in_ecn(packet_in) != ECN_NOT_ECT;\n        ++conn->ifc_ecn_counts_in[pns][ lsquic_packet_in_ecn(packet_in) ];\n        if (PNS_APP == pns\n                && (cpath = &conn->ifc_paths[packet_in->pi_path_id],\n                                            cpath->cop_flags & COP_SPIN_BIT)\n                /* [draft-ietf-quic-transport-30] Section 17.3.1 talks about\n                 * how spin bit value is set.\n                 */\n                && (packet_in->pi_packno > cpath->cop_max_packno\n                    /* Zero means \"unset\", in which case any incoming packet\n                     * number will do.  On receipt of second packet numbered\n                     * zero, the rechist module will dup it and this code path\n                     * won't hit.\n                     */\n                    || cpath->cop_max_packno == 0))\n        {\n            cpath->cop_max_packno = packet_in->pi_packno;\n            if (conn->ifc_flags & IFC_SERVER)\n                cpath->cop_spin_bit = lsquic_packet_in_spin_bit(packet_in);\n            else\n                cpath->cop_spin_bit = !lsquic_packet_in_spin_bit(packet_in);\n        }\n        conn->ifc_pub.bytes_in += packet_in->pi_data_sz;\n        if ((conn->ifc_mflags & MF_VALIDATE_PATH) &&\n                (packet_in->pi_header_type == HETY_SHORT\n              || packet_in->pi_header_type == HETY_HANDSHAKE))\n        {\n            conn->ifc_mflags &= ~MF_VALIDATE_PATH;\n            lsquic_send_ctl_path_validated(&conn->ifc_send_ctl);\n        }\n        return 0;\n    case REC_ST_DUP:\n        CONN_STATS(in.dup_packets, 1);\n        LSQ_INFO(\"packet %\"PRIu64\" is a duplicate\", packet_in->pi_packno);\n        return 0;\n    default:\n        assert(0);\n        /* Fall through */\n    case REC_ST_ERR:\n        CONN_STATS(in.err_packets, 1);\n        LSQ_INFO(\"error processing packet %\"PRIu64, packet_in->pi_packno);\n        return -1;\n    }\n}\n\n\nstatic int\nverneg_ok (const struct ietf_full_conn *conn)\n{\n    enum lsquic_version ver;\n\n    ver = highest_bit_set(conn->ifc_u.cli.ifcli_ver_neg.vn_supp);\n    return (1 << ver) & LSQUIC_IETF_VERSIONS;\n}\n\n\nstatic void\nenable_ping_alarm_for_handshake (struct ietf_full_conn *conn)\n{\n    conn->ifc_ping_period = HSK_PING_TIMEOUT;\n    lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                        lsquic_time_now() + conn->ifc_ping_period);\n}\n\n\nstatic int\nswitch_version (struct ietf_full_conn *conn, enum lsquic_version version)\n{\n    conn->ifc_conn.cn_version = version;\n    return iquic_esfi_switch_version(conn->ifc_conn.cn_enc_session, NULL, 0);\n}\n\n\n/* This function is used by the client when version negotiation is not yet\n * complete.\n */\nstatic int\nprocess_incoming_packet_verneg (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    int s;\n    struct ver_iter vi;\n    lsquic_ver_tag_t ver_tag;\n    enum lsquic_version version;\n    unsigned versions;\n\n    if (lsquic_packet_in_is_verneg(packet_in))\n    {\n        LSQ_DEBUG(\"Processing version-negotiation packet\");\n\n        if (conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_START)\n        {\n            LSQ_DEBUG(\"ignore a likely duplicate version negotiation packet\");\n            return 0;\n        }\n\n        if (!(LSQUIC_CIDS_EQ(&conn->ifc_conn.cn_cid, &packet_in->pi_dcid)\n            && CUR_DCID(conn)->len == packet_in->pi_scid_len\n            && 0 == memcmp(CUR_DCID(conn)->idbuf, packet_in->pi_data\n                            + packet_in->pi_scid_off, packet_in->pi_scid_len)))\n        {\n            LSQ_DEBUG(\"SCID and DCID in verneg packet don't match what we \"\n                        \"sent: ignore\");\n            return 0;\n        }\n\n        versions = 0;\n        for (s = lsquic_packet_in_ver_first(packet_in, &vi, &ver_tag); s;\n                         s = lsquic_packet_in_ver_next(&vi, &ver_tag))\n        {\n            version = lsquic_tag2ver(ver_tag);\n            if (version < N_LSQVER)\n            {\n                versions |= 1 << version;\n                LSQ_DEBUG(\"server supports version %s\", lsquic_ver2str[version]);\n                EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,\n                                            \"supports\", lsquic_ver2str[version]);\n            }\n        }\n\n        /* [draft-ietf-quic-transport-28] Section 6.2:\n         \" A client MUST discard a Version Negotiation packet that lists the\n         \" QUIC version selected by the client.\n         */\n        if (versions & (1 << conn->ifc_u.cli.ifcli_ver_neg.vn_ver))\n        {\n            LSQ_DEBUG(\"server replied with version we sent, %s, ignore\",\n                        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver]);\n            return 0;\n        }\n\n        /* [draft-ietf-quic-transport-28] Section 6.2:\n         \" A client that supports only this version of QUIC MUST abandon the\n         \" current connection attempt if it receives a Version Negotiation\n         \" packet [...]\n         */\n        if (!verneg_ok(conn))\n        {\n            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,\n                \"version negotiation not permitted in this version of QUIC\");\n            return -1;\n        }\n\n        versions &= conn->ifc_u.cli.ifcli_ver_neg.vn_supp;\n        if (0 == versions)\n        {\n            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,\n                \"client does not support any of the server-specified versions\");\n            return -1;\n        }\n\n        set_versions(conn, versions, NULL);\n        conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_IN_PROGRESS;\n        lsquic_send_ctl_expire_all(&conn->ifc_send_ctl);\n        return 0;\n    }\n\n    if (packet_in->pi_version != conn->ifc_u.cli.ifcli_ver_neg.vn_ver)\n    {\n        if (!((1 << packet_in->pi_version)\n              & conn->ifc_u.cli.ifcli_ver_neg.vn_supp))\n        {\n            LSQ_DEBUG(\"server version doesn't match versions \"\n                        \"supported: ignore\");\n            return 0;\n        }\n        LSQ_DEBUG(\"version negociation: server switched version from %s to %s\",\n        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver],\n        lsquic_ver2str[packet_in->pi_version]);\n        switch_version(conn, packet_in->pi_version);\n    }\n    else\n        conn->ifc_conn.cn_version = conn->ifc_u.cli.ifcli_ver_neg.vn_ver;\n    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_tag);\n    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_END);\n    conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_END;\n    conn->ifc_u.cli.ifcli_ver_neg.vn_tag = NULL;\n    conn->ifc_conn.cn_flags |= LSCONN_VER_SET;\n    LSQ_DEBUG(\"end of version negotiation: agreed upon %s\",\n                    lsquic_ver2str[conn->ifc_conn.cn_version]);\n    EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,\n            \"agreed\", lsquic_ver2str[conn->ifc_conn.cn_version]);\n    conn->ifc_process_incoming_packet = process_regular_packet;\n\n    if (process_regular_packet(conn, packet_in) == 0)\n    {\n        enable_ping_alarm_for_handshake(conn);\n        return 0;\n    }\n    return -1;\n}\n\n\n/* This function is used after version negotiation is completed */\nstatic int\nprocess_incoming_packet_fast (struct ietf_full_conn *conn,\n                                        struct lsquic_packet_in *packet_in)\n{\n    return process_regular_packet(conn, packet_in);\n}\n\n\nstatic void\nset_earliest_idle_alarm (struct ietf_full_conn *conn, lsquic_time_t idle_conn_to)\n{\n    lsquic_time_t exp;\n\n    if (conn->ifc_pub.last_prog\n        && (assert(conn->ifc_mflags & MF_NOPROG_TIMEOUT),\n            exp = conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout,\n            exp < idle_conn_to))\n        idle_conn_to = exp;\n    if (idle_conn_to)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, idle_conn_to);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_in (struct lsquic_conn *lconn,\n                             struct lsquic_packet_in *packet_in)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    CONN_STATS(in.bytes, packet_in->pi_data_sz);\n    set_earliest_idle_alarm(conn, conn->ifc_idle_to\n                    ? packet_in->pi_received + conn->ifc_idle_to : 0);\n    if (0 == (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS))\n        if (0 != conn->ifc_process_incoming_packet(conn, packet_in))\n            conn->ifc_flags |= IFC_ERROR;\n}\n\n\nstatic void\nietf_full_conn_ci_packet_not_sent (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n#ifndef NDEBUG\n    if (packet_out->po_flags & PO_ENCRYPTED)\n        assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    lsquic_send_ctl_delayed_one(&conn->ifc_send_ctl, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_too_large (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n#ifndef NDEBUG\n    assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n\n    if (packet_out->po_flags & PO_MTU_PROBE)\n    {\n        LSQ_DEBUG(\"%zu-byte MTU probe in packet %\"PRIu64\" is too large\",\n            lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out),\n            packet_out->po_packno);\n        lsquic_send_ctl_mtu_not_sent(&conn->ifc_send_ctl, packet_out);\n        mtu_probe_too_large(conn, packet_out);\n    }\n    else\n        ABORT_WARN(\"non-MTU probe %zu-byte packet %\"PRIu64\" is too large\",\n            lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out),\n            packet_out->po_packno);\n\n    lsquic_packet_out_destroy(packet_out, conn->ifc_enpub,\n                                            packet_out->po_path->np_peer_ctx);\n}\n\n\n/* Calling of ignore_init() must be delayed until all batched packets have\n * been returned by the engine.\n */\nstatic void\npre_hsk_packet_sent_or_delayed (struct ietf_full_conn *conn,\n                               const struct lsquic_packet_out *packet_out)\n{\n#ifndef NDEBUG\n    if (packet_out->po_flags & PO_ENCRYPTED)\n        assert(packet_out->po_lflags & POL_HEADER_PROT);\n#endif\n    /* Once IFC_IGNORE_INIT is set, the pre-hsk wrapper is removed: */\n    assert(!(conn->ifc_flags & IFC_IGNORE_INIT));\n    --conn->ifc_u.cli.ifcli_packets_out;\n    if (PNS_HSK == lsquic_packet_out_pns(packet_out))\n        conn->ifc_u.cli.ifcli_flags |= IFCLI_HSK_SENT_OR_DEL;\n    if (0 == conn->ifc_u.cli.ifcli_packets_out\n                && (conn->ifc_u.cli.ifcli_flags & IFCLI_HSK_SENT_OR_DEL))\n        ignore_init(conn);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_not_sent_pre_hsk (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    ietf_full_conn_ci_packet_not_sent(lconn, packet_out);\n    pre_hsk_packet_sent_or_delayed(conn, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_packet_sent (struct lsquic_conn *lconn,\n                               struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    int s;\n\n    if (packet_out->po_frame_types & (IQUIC_FRAME_RETX_MASK | QUIC_FTBIT_ACK))\n        conn->ifc_n_cons_unretx = 0;\n    else\n        ++conn->ifc_n_cons_unretx;\n    s = lsquic_send_ctl_sent_packet(&conn->ifc_send_ctl, packet_out);\n    if (s != 0)\n        ABORT_ERROR(\"sent packet failed: %s\", strerror(errno));\n    /* Set blocked keep-alive for a [1,8] seconds */\n    if (packet_out->po_frame_types\n                            & (QUIC_FTBIT_BLOCKED|QUIC_FTBIT_STREAM_BLOCKED))\n        lsquic_alarmset_set(&conn->ifc_alset, AL_BLOCKED_KA,\n            packet_out->po_sent + (1 + (7 & lsquic_crand_get_nybble(\n                                conn->ifc_enpub->enp_crand))) * 1000000);\n    conn->ifc_pub.bytes_out += lsquic_packet_out_sent_sz(&conn->ifc_conn,\n                                                                packet_out);\n    CONN_STATS(out.packets, 1);\n    CONN_STATS(out.bytes, lsquic_packet_out_sent_sz(lconn, packet_out));\n}\n\n\nstatic void\nietf_full_conn_ci_packet_sent_pre_hsk (struct lsquic_conn *lconn,\n                                   struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    ietf_full_conn_ci_packet_sent(lconn, packet_out);\n    pre_hsk_packet_sent_or_delayed(conn, packet_out);\n}\n\n\nstatic void (*const send_funcs[N_SEND])(\n                            struct ietf_full_conn *, lsquic_time_t) =\n{\n    [SEND_NEW_CID]      = generate_new_cid_frames,\n    [SEND_RETIRE_CID]   = generate_retire_cid_frames,\n    [SEND_STREAMS_BLOCKED_UNI]  = generate_streams_blocked_uni_frame,\n    [SEND_STREAMS_BLOCKED_BIDI] = generate_streams_blocked_bidi_frame,\n    [SEND_MAX_STREAMS_UNI]  = generate_max_streams_uni_frame,\n    [SEND_MAX_STREAMS_BIDI] = generate_max_streams_bidi_frame,\n    [SEND_STOP_SENDING] = generate_stop_sending_frames,\n    [SEND_NEW_TOKEN]    = generate_new_token_frame,\n    [SEND_PATH_CHAL_PATH_0]    = generate_path_chal_0,\n    [SEND_PATH_CHAL_PATH_1]    = generate_path_chal_1,\n    [SEND_PATH_CHAL_PATH_2]    = generate_path_chal_2,\n    [SEND_PATH_CHAL_PATH_3]    = generate_path_chal_3,\n    [SEND_PATH_RESP_PATH_0]    = generate_path_resp_0,\n    [SEND_PATH_RESP_PATH_1]    = generate_path_resp_1,\n    [SEND_PATH_RESP_PATH_2]    = generate_path_resp_2,\n    [SEND_PATH_RESP_PATH_3]    = generate_path_resp_3,\n    [SEND_PING]                = generate_ping_frame,\n    [SEND_HANDSHAKE_DONE]      = generate_handshake_done_frame,\n    [SEND_ACK_FREQUENCY]       = generate_ack_frequency_frame,\n};\n\n\n/* List bits that have corresponding entries in send_funcs */\n#define SEND_WITH_FUNCS (SF_SEND_NEW_CID|SF_SEND_RETIRE_CID\\\n    |SF_SEND_STREAMS_BLOCKED_UNI|SF_SEND_STREAMS_BLOCKED_BIDI\\\n    |SF_SEND_MAX_STREAMS_UNI|SF_SEND_MAX_STREAMS_BIDI\\\n    |SF_SEND_PATH_CHAL_PATH_0|SF_SEND_PATH_CHAL_PATH_1\\\n    |SF_SEND_PATH_CHAL_PATH_2|SF_SEND_PATH_CHAL_PATH_3\\\n    |SF_SEND_PATH_RESP_PATH_0|SF_SEND_PATH_RESP_PATH_1\\\n    |SF_SEND_PATH_RESP_PATH_2|SF_SEND_PATH_RESP_PATH_3\\\n    |SF_SEND_PING|SF_SEND_HANDSHAKE_DONE\\\n    |SF_SEND_ACK_FREQUENCY\\\n    |SF_SEND_STOP_SENDING|SF_SEND_NEW_TOKEN)\n\n\n/* This should be called before lsquic_alarmset_ring_expired() */\nstatic void\nmaybe_set_noprogress_alarm (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    lsquic_time_t exp;\n\n    if (conn->ifc_mflags & MF_NOPROG_TIMEOUT)\n    {\n        if (conn->ifc_pub.last_tick)\n        {\n            exp = conn->ifc_pub.last_prog + conn->ifc_enpub->enp_noprog_timeout;\n            if (!lsquic_alarmset_is_set(&conn->ifc_alset, AL_IDLE)\n                                    || exp < conn->ifc_alset.as_expiry[AL_IDLE])\n                lsquic_alarmset_set(&conn->ifc_alset, AL_IDLE, exp);\n            conn->ifc_pub.last_tick = now;\n        }\n        else\n        {\n            conn->ifc_pub.last_tick = now;\n            conn->ifc_pub.last_prog = now;\n        }\n    }\n}\n\n\nstatic void\ncheck_or_schedule_mtu_probe (struct ietf_full_conn *conn, lsquic_time_t now)\n{\n    struct conn_path *const cpath = CUR_CPATH(conn);\n    struct dplpmtud_state *const ds = &cpath->cop_dplpmtud;\n    struct lsquic_packet_out *packet_out;\n    unsigned short saved_packet_sz, avail, mtu_ceiling, net_header_sz, probe_sz;\n    int sz;\n\n    if (ds->ds_flags & DS_PROBE_SENT)\n    {\n        assert(ds->ds_probe_sent + conn->ifc_enpub->enp_mtu_probe_timer < now);\n        LSQ_DEBUG(\"MTU probe of %hu bytes lost\", ds->ds_probed_size);\n        ds->ds_flags &= ~DS_PROBE_SENT;\n        conn->ifc_mflags |= MF_CHECK_MTU_PROBE;\n        if (ds->ds_probe_count >= 3)\n        {\n            LSQ_DEBUG(\"MTU probe of %hu bytes lost after %hhu tries\",\n                ds->ds_probed_size, ds->ds_probe_count);\n            ds->ds_failed_size = ds->ds_probed_size;\n            ds->ds_probe_count = 0;\n        }\n    }\n\n    assert(0 == ds->ds_probe_sent\n        || ds->ds_probe_sent + conn->ifc_enpub->enp_mtu_probe_timer < now);\n\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        || (conn->ifc_flags & IFC_CLOSING)\n        || ~0ull == lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist)\n        || lsquic_senhist_largest(&conn->ifc_send_ctl.sc_senhist) < 30\n        || lsquic_send_ctl_in_recovery(&conn->ifc_send_ctl)\n        || !lsquic_send_ctl_can_send_probe(&conn->ifc_send_ctl,\n                                                        &cpath->cop_path))\n    {\n        return;\n    }\n\n    if (ds->ds_failed_size)\n        mtu_ceiling = ds->ds_failed_size;\n    else if (conn->ifc_settings->es_max_plpmtu)\n        mtu_ceiling = conn->ifc_settings->es_max_plpmtu;\n    else\n    {\n        net_header_sz = TRANSPORT_OVERHEAD(NP_IS_IPv6(&cpath->cop_path));\n        mtu_ceiling = 1500 - net_header_sz;\n    }\n\n    if (conn->ifc_max_udp_payload < mtu_ceiling)\n    {\n        LSQ_DEBUG(\"cap MTU ceiling to peer's max_udp_payload_size TP of %hu \"\n            \"bytes\", conn->ifc_max_udp_payload);\n        mtu_ceiling = conn->ifc_max_udp_payload;\n    }\n\n    if (cpath->cop_path.np_pack_size >= mtu_ceiling\n        || (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling >= 0.99)\n    {\n        LSQ_DEBUG(\"stop MTU probing on path %hhu having achieved about \"\n            \"%.1f%% efficiency (detected MTU: %hu; failed MTU: %hu)\",\n            cpath->cop_path.np_path_id,\n            100. * (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling,\n            cpath->cop_path.np_pack_size, ds->ds_failed_size);\n        conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n        return;\n    }\n\n    LSQ_DEBUG(\"MTU ratio: %hu / %hu = %.4f\",\n        cpath->cop_path.np_pack_size, mtu_ceiling,\n        (float) cpath->cop_path.np_pack_size / (float) mtu_ceiling);\n\n    if (!ds->ds_failed_size && mtu_ceiling < 1500)\n        /* Try the largest ethernet MTU immediately */\n        probe_sz = mtu_ceiling;\n    else if (cpath->cop_path.np_pack_size * 2 >= mtu_ceiling)\n        /* Pick half-way point */\n        probe_sz = (mtu_ceiling + cpath->cop_path.np_pack_size) / 2;\n    else\n        probe_sz = cpath->cop_path.np_pack_size * 2;\n\n    /* XXX Changing np_pack_size is action at a distance */\n    saved_packet_sz = cpath->cop_path.np_pack_size;\n    cpath->cop_path.np_pack_size = probe_sz;\n    packet_out = lsquic_send_ctl_new_packet_out(&conn->ifc_send_ctl,\n                                                        0, PNS_APP, CUR_NPATH(conn));\n    if (!packet_out)\n        goto restore_packet_size;\n    sz = conn->ifc_conn.cn_pf->pf_gen_ping_frame(\n                            packet_out->po_data + packet_out->po_data_sz,\n                            lsquic_packet_out_avail(packet_out));\n    if (sz < 0) {\n        ABORT_ERROR(\"gen_ping_frame failed\");\n        goto restore_packet_size;\n    }\n    /* We don't record frame records for MTU probes as they are never\n     * resized, only discarded.\n     */\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, sz);\n    packet_out->po_frame_types |= 1 << QUIC_FRAME_PING;\n    avail = lsquic_packet_out_avail(packet_out);\n    if (avail)\n    {\n        memset(packet_out->po_data + packet_out->po_data_sz, 0, avail);\n        lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, avail);\n        packet_out->po_frame_types |= 1 << QUIC_FRAME_PADDING;\n    }\n    packet_out->po_flags |= PO_MTU_PROBE;\n    lsquic_send_ctl_scheduled_one(&conn->ifc_send_ctl, packet_out);\n    LSQ_DEBUG(\"generated MTU probe of %hu bytes in packet %\"PRIu64,\n                        cpath->cop_path.np_pack_size, packet_out->po_packno);\n#ifndef NDEBUG\n    ds->ds_probe_sent = now;\n#endif\n    ds->ds_probe_packno = packet_out->po_packno;\n    ds->ds_probed_size = probe_sz;\n    ds->ds_flags |= DS_PROBE_SENT;\n    ++ds->ds_probe_count;\n    conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n    assert(!lsquic_alarmset_is_set(&conn->ifc_alset, AL_MTU_PROBE));\n    lsquic_alarmset_set(&conn->ifc_alset, AL_MTU_PROBE,\n                                now + conn->ifc_enpub->enp_mtu_probe_timer);\n  restore_packet_size:\n    cpath->cop_path.np_pack_size = saved_packet_sz;\n}\n\n\nstatic void\nietf_full_conn_ci_mtu_probe_acked (struct lsquic_conn *lconn,\n                                   const struct lsquic_packet_out *packet_out)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct conn_path *cpath;\n    struct dplpmtud_state *ds;\n    unsigned char path_id;\n\n    path_id = packet_out->po_path->np_path_id;\n    cpath = &conn->ifc_paths[path_id];\n    ds = &cpath->cop_dplpmtud;\n    if (ds->ds_probe_packno != packet_out->po_packno)\n    {\n        LSQ_DEBUG(\"Acked MTU probe packet %\"PRIu64\" on path %hhu, but it is \"\n            \"old: discard\", packet_out->po_packno, path_id);\n        return;\n    }\n    ds->ds_flags &= ~DS_PROBE_SENT;\n    ds->ds_probe_count = 0;\n\n    cpath->cop_path.np_pack_size = lsquic_packet_out_sent_sz(&conn->ifc_conn,\n                                                                    packet_out);\n    LSQ_INFO(\"update path %hhu MTU to %hu bytes\", path_id,\n                                                cpath->cop_path.np_pack_size);\n    conn->ifc_mflags &= ~MF_CHECK_MTU_PROBE;\n    lsquic_alarmset_set(&conn->ifc_alset, AL_MTU_PROBE,\n                packet_out->po_sent + conn->ifc_enpub->enp_mtu_probe_timer);\n    LSQ_DEBUG(\"set alarm to %\"PRIu64\" usec \", packet_out->po_sent + conn->ifc_enpub->enp_mtu_probe_timer);\n}\n\n\nstatic void\nmtu_probe_too_large (struct ietf_full_conn *conn,\n                                const struct lsquic_packet_out *packet_out)\n{\n    struct conn_path *cpath;\n    unsigned char path_id;\n\n    path_id = packet_out->po_path->np_path_id;\n    cpath = &conn->ifc_paths[path_id];\n    cpath->cop_dplpmtud.ds_failed_size\n                    = lsquic_packet_out_sent_sz(&conn->ifc_conn, packet_out);\n}\n\n\nstatic void\nietf_full_conn_ci_retx_timeout (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    unsigned short pack_size;\n    struct conn_path *cpath;\n    int resize;\n\n    resize = 0;\n    for (cpath = conn->ifc_paths; cpath < conn->ifc_paths + N_PATHS; ++cpath)\n        if (cpath->cop_flags & COP_INITIALIZED)\n        {\n            pack_size = calc_base_packet_size(conn,\n                                                NP_IS_IPv6(&cpath->cop_path));\n            if (cpath->cop_path.np_pack_size > pack_size)\n            {\n                LSQ_DEBUG(\"RTO occurred: change packet size of path %hhu \"\n                    \"to %hu bytes\", cpath->cop_path.np_path_id, pack_size);\n                cpath->cop_path.np_pack_size = pack_size;\n                resize |= 1;\n            }\n        }\n\n    if (resize)\n        lsquic_send_ctl_resize(&conn->ifc_send_ctl);\n    else\n        LSQ_DEBUG(\"RTO occurred, but no MTUs to reset\");\n\n    if (lsquic_send_ctl_ecn_turned_on(&conn->ifc_send_ctl))\n    {\n        LSQ_INFO(\"RTO occurred, disable ECN\");\n        lsquic_send_ctl_disable_ecn(&conn->ifc_send_ctl);\n        if (lsquic_rechist_first(&conn->ifc_rechist[PNS_APP]))\n        {\n            LSQ_DEBUG(\"Send wrong ECN counts to peer so that it turns off \"\n                                                                \"ECN as well\");\n            memset(conn->ifc_ecn_counts_in[PNS_APP], 0,\n                                    sizeof(conn->ifc_ecn_counts_in[PNS_APP]));\n            conn->ifc_mflags |= MF_SEND_WRONG_COUNTS;\n            force_queueing_ack_app(conn);\n            conn->ifc_send_flags |= SF_SEND_PING;\n        }\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_early_data_failed (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    LSQ_DEBUG(\"early data failed\");\n    lsquic_send_ctl_stash_0rtt_packets(&conn->ifc_send_ctl);\n}\n\n\nstatic size_t\nietf_full_conn_ci_get_min_datagram_size (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return (size_t) conn->ifc_min_dg_sz;\n}\n\n\nstatic int\nietf_full_conn_ci_set_min_datagram_size (struct lsquic_conn *lconn,\n                                                            size_t new_size)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    const struct transport_params *const params =\n        lconn->cn_esf.i->esfi_get_peer_transport_params(lconn->cn_enc_session);\n\n    if (!(conn->ifc_flags & IFC_DATAGRAMS))\n    {\n        LSQ_WARN(\"datagrams are not enabled: cannot set minimum size\");\n        return -1;\n    }\n\n    if (new_size > USHRT_MAX)\n    {\n        LSQ_DEBUG(\"min datagram size cannot be larger than %hu\",\n                                                    (unsigned short) USHRT_MAX);\n        return -1;\n    }\n\n    if (new_size > params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE])\n    {\n        LSQ_DEBUG(\"maximum datagram frame size is %\"PRIu64\", cannot change it \"\n            \"to %zd\", params->tp_numerics[TPI_MAX_DATAGRAM_FRAME_SIZE],\n            new_size);\n        return -1;\n    }\n\n    conn->ifc_min_dg_sz = new_size;\n    LSQ_DEBUG(\"set minimum datagram size to %zd bytes\", new_size);\n    return 0;\n}\n\n\n/* Return true if datagram was written, false otherwise */\nstatic int\nwrite_datagram (struct ietf_full_conn *conn)\n{\n    struct lsquic_packet_out *packet_out;\n    size_t need;\n    int w;\n\n    need = conn->ifc_conn.cn_pf->pf_datagram_frame_size(conn->ifc_min_dg_sz);\n    packet_out = get_writeable_packet(conn, need);\n    if (!packet_out)\n        return 0;\n\n    w = conn->ifc_conn.cn_pf->pf_gen_datagram_frame(\n            packet_out->po_data + packet_out->po_data_sz,\n            lsquic_packet_out_avail(packet_out), conn->ifc_min_dg_sz,\n            conn->ifc_max_dg_sz,\n            conn->ifc_enpub->enp_stream_if->on_dg_write, &conn->ifc_conn);\n    if (w < 0)\n    {\n        LSQ_DEBUG(\"could not generate DATAGRAM frame\");\n        return 0;\n    }\n    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,\n                        QUIC_FRAME_DATAGRAM, packet_out->po_data_sz, w))\n    {\n        ABORT_ERROR(\"adding DATAGRAME frame to packet failed: %d\", errno);\n        return 0;\n    }\n    packet_out->po_regen_sz += w;\n    packet_out->po_frame_types |= QUIC_FTBIT_DATAGRAM;\n    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);\n    /* XXX The DATAGRAM frame should really be a regen.  Do it when we\n     * no longer require these frame types to be at the beginning of the\n     * packet.\n     */\n\n    return 1;\n}\n\n\nstatic enum tick_st\nietf_full_conn_ci_tick (struct lsquic_conn *lconn, lsquic_time_t now)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    int have_delayed_packets, s;\n    enum tick_st tick = 0;\n    unsigned n;\n\n#define CLOSE_IF_NECESSARY() do {                                       \\\n    if (conn->ifc_flags & IFC_IMMEDIATE_CLOSE_FLAGS)                    \\\n    {                                                                   \\\n        tick |= immediate_close(conn);                                  \\\n        goto close_end;                                                 \\\n    }                                                                   \\\n} while (0)\n\n#define RETURN_IF_OUT_OF_PACKETS() do {                                 \\\n    if (!lsquic_send_ctl_can_send(&conn->ifc_send_ctl))                 \\\n    {                                                                   \\\n        if (0 == lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))      \\\n        {                                                               \\\n            LSQ_DEBUG(\"used up packet allowance, quiet now (line %d)\",  \\\n                __LINE__);                                              \\\n            tick |= TICK_QUIET;                                         \\\n        }                                                               \\\n        else                                                            \\\n        {                                                               \\\n            LSQ_DEBUG(\"used up packet allowance, sending now (line %d)\",\\\n                __LINE__);                                              \\\n            tick |= TICK_SEND;                                          \\\n        }                                                               \\\n        goto end;                                                       \\\n    }                                                                   \\\n} while (0)\n\n    CONN_STATS(n_ticks, 1);\n\n    CLOSE_IF_NECESSARY();\n\n    if (conn->ifc_flags & IFC_HAVE_SAVED_ACK)\n    {\n        (void) /* If there is an error, we'll fail shortly */\n        process_ack(conn, &conn->ifc_ack, conn->ifc_saved_ack_received, now);\n        conn->ifc_flags &= ~IFC_HAVE_SAVED_ACK;\n    }\n\n    maybe_set_noprogress_alarm(conn, now);\n\n    lsquic_send_ctl_tick_in(&conn->ifc_send_ctl, now);\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 1);\n    CLOSE_IF_NECESSARY();\n\n    lsquic_alarmset_ring_expired(&conn->ifc_alset, now);\n    CLOSE_IF_NECESSARY();\n\n    /* To make things simple, only stream 1 is active until the handshake\n     * has been completed.  This will be adjusted in the future: the client\n     * does not want to wait if it has the server information.\n     */\n    if (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        process_streams_read_events(conn);\n    else\n        process_crypto_stream_read_events(conn);\n    CLOSE_IF_NECESSARY();\n\n    if (lsquic_send_ctl_pacer_blocked(&conn->ifc_send_ctl))\n        goto end_write;\n\n    if (conn->ifc_flags & IFC_FIRST_TICK)\n    {\n        conn->ifc_flags &= ~IFC_FIRST_TICK;\n        have_delayed_packets = 0;\n    }\n    else\n        /* If there are any scheduled packets at this point, it means that\n         * they were not sent during previous tick; in other words, they\n         * are delayed.  When there are delayed packets, the only packet\n         * we sometimes add is a packet with an ACK frame, and we add it\n         * to the *front* of the queue.\n         */\n        have_delayed_packets =\n            lsquic_send_ctl_maybe_squeeze_sched(&conn->ifc_send_ctl);\n\n    if (should_generate_ack(conn, IFC_ACK_QUEUED) ||\n                        (!have_delayed_packets && maybe_queue_opp_ack(conn)))\n    {\n        if (have_delayed_packets)\n            lsquic_send_ctl_reset_packnos(&conn->ifc_send_ctl);\n\n        n = generate_ack_frame(conn, now);\n        CLOSE_IF_NECESSARY();\n\n        if (have_delayed_packets && n)\n            lsquic_send_ctl_ack_to_front(&conn->ifc_send_ctl, n);\n    }\n\n    if (have_delayed_packets)\n    {\n        /* The reason for not adding the other frames below to the packet\n         * carrying ACK frame generated when there are delayed packets is\n         * so that if the ACK packet itself is delayed, it can be dropped\n         * and replaced by new ACK packet.  This way, we are never more\n         * than 1 packet over CWND.\n         */\n        tick |= TICK_SEND;\n        if (conn->ifc_flags & IFC_CLOSING)\n            goto end_write;\n        else\n            goto end;\n    }\n\n    /* Try to fit MAX_DATA before checking if we have run out of room.\n     * If it does not fit, it will be tried next time around.\n     */\n    if (lsquic_cfcw_fc_offsets_changed(&conn->ifc_pub.cfcw) ||\n                                (conn->ifc_send_flags & SF_SEND_MAX_DATA))\n    {\n        conn->ifc_send_flags |= SF_SEND_MAX_DATA;\n        generate_max_data_frame(conn);\n        CLOSE_IF_NECESSARY();\n    }\n\n    if (conn->ifc_send_flags & SEND_WITH_FUNCS)\n    {\n        enum send send;\n        for (send = 0; send < N_SEND; ++send)\n            if (conn->ifc_send_flags & (1 << send) & SEND_WITH_FUNCS)\n            {\n                send_funcs[send](conn, now);\n                CLOSE_IF_NECESSARY();\n            }\n    }\n\n    if (conn->ifc_mflags & MF_CHECK_MTU_PROBE)\n        check_or_schedule_mtu_probe(conn, now);\n\n    n = lsquic_send_ctl_reschedule_packets(&conn->ifc_send_ctl);\n    if (n > 0)\n        CLOSE_IF_NECESSARY();\n\n    if (conn->ifc_conn.cn_flags & LSCONN_SEND_BLOCKED)\n    {\n        RETURN_IF_OUT_OF_PACKETS();\n        if (generate_blocked_frame(conn))\n            conn->ifc_conn.cn_flags &= ~LSCONN_SEND_BLOCKED;\n    }\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.sending_streams))\n    {\n        process_streams_ready_to_send(conn);\n        CLOSE_IF_NECESSARY();\n    }\n\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 0);\n    if (!(conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {\n        s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl,\n                                                            BPT_HIGHEST_PRIO);\n        conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n        if (0 == s)\n            process_crypto_stream_write_events(conn);\n        if (!(conn->ifc_mflags & MF_DOING_0RTT))\n        {\n            lsquic_send_ctl_maybe_app_limited(&conn->ifc_send_ctl,\n                                                            CUR_NPATH(conn));\n            goto end_write;\n        }\n    }\n\n    maybe_conn_flush_special_streams(conn);\n\n    s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl, BPT_HIGHEST_PRIO);\n    conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n    if (!write_is_possible(conn))\n        goto end_write;\n\n    while ((conn->ifc_mflags & MF_WANT_DATAGRAM_WRITE) && write_datagram(conn))\n        if (!write_is_possible(conn))\n            goto end_write;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n    {\n        process_streams_write_events(conn, 1);\n        if (!write_is_possible(conn))\n            goto end_write;\n    }\n\n    s = lsquic_send_ctl_schedule_buffered(&conn->ifc_send_ctl, BPT_OTHER_PRIO);\n    conn->ifc_flags |= (s < 0) << IFC_BIT_ERROR;\n    if (!write_is_possible(conn))\n        goto end_write;\n\n    if (!TAILQ_EMPTY(&conn->ifc_pub.write_streams))\n        process_streams_write_events(conn, 0);\n\n    lsquic_send_ctl_maybe_app_limited(&conn->ifc_send_ctl, CUR_NPATH(conn));\n\n  end_write:\n    if ((conn->ifc_flags & IFC_CLOSING)\n        && ((conn->ifc_send_flags & SF_SEND_CONN_CLOSE)\n            || conn_ok_to_close(conn)))\n    {\n        LSQ_DEBUG(\"connection is OK to close\");\n        conn->ifc_flags |= IFC_TICK_CLOSE;\n        if (conn->ifc_flags & IFC_RECV_CLOSE)\n            tick |= TICK_CLOSE;\n        if (!(conn->ifc_mflags & MF_CONN_CLOSE_PACK)\n            /* Generate CONNECTION_CLOSE frame if:\n             *     ... this is a client and handshake was successful;\n             */\n            && (!(conn->ifc_flags & (IFC_SERVER|IFC_HSK_FAILED))\n                /* or: sent a GOAWAY frame;\n                 */\n                    || (conn->ifc_flags & IFC_GOAWAY_CLOSE)\n                /* or: we received CONNECTION_CLOSE and we are not a server\n                 * that chooses not to send CONNECTION_CLOSE responses.\n                 * From [draft-ietf-quic-transport-29]:\n                 \" An endpoint that receives a CONNECTION_CLOSE frame MAY send\n                 \" a single packet containing a CONNECTION_CLOSE frame before\n                 \" entering the draining state\n                 */\n                    || ((conn->ifc_flags & IFC_RECV_CLOSE)\n                            && !((conn->ifc_flags & IFC_SERVER)\n                                    && conn->ifc_settings->es_silent_close))\n                /* or: we have packets to send. */\n                    || 0 != lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))\n                )\n        {\n            RETURN_IF_OUT_OF_PACKETS();\n            generate_connection_close_packet(conn);\n            tick |= TICK_SEND|TICK_CLOSE;\n        }\n        else\n            tick |= TICK_CLOSE;\n\n        goto end;\n    }\n\n    if (0 == lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl))\n    {\n        if (conn->ifc_send_flags & SF_SEND_PING)\n        {\n            RETURN_IF_OUT_OF_PACKETS();\n            generate_ping_frame(conn, now);\n            CLOSE_IF_NECESSARY();\n            assert(lsquic_send_ctl_n_scheduled(&conn->ifc_send_ctl) != 0);\n        }\n        else\n        {\n            tick |= TICK_QUIET;\n            goto end;\n        }\n    }\n    else if (conn->ifc_ping_period\n            && (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE))\n    {\n        lsquic_alarmset_unset(&conn->ifc_alset, AL_PING);\n        lsquic_send_ctl_sanity_check(&conn->ifc_send_ctl);\n        conn->ifc_send_flags &= ~SF_SEND_PING;   /* It may have rung */\n    }\n\n    /* [draft-ietf-quic-transport-11] Section 7.9:\n     *\n     *     The PING frame can be used to keep a connection alive when an\n     *     application or application protocol wishes to prevent the connection\n     *     from timing out.  An application protocol SHOULD provide guidance\n     *     about the conditions under which generating a PING is recommended.\n     *     This guidance SHOULD indicate whether it is the client or the server\n     *     that is expected to send the PING.  Having both endpoints send PING\n     *     frames without coordination can produce an excessive number of\n     *     packets and poor performance.\n     */\n    if (conn->ifc_ping_period\n                        && lsquic_hash_count(conn->ifc_pub.all_streams) >\n                           conn->ifc_pub.n_special_streams)\n        lsquic_alarmset_set(&conn->ifc_alset, AL_PING,\n                                                now + conn->ifc_ping_period);\n\n    tick |= TICK_SEND;\n\n  end:\n    service_streams(conn);\n    CLOSE_IF_NECESSARY();\n\n  close_end:\n    lsquic_send_ctl_set_buffer_stream_packets(&conn->ifc_send_ctl, 1);\n    lsquic_send_ctl_tick_out(&conn->ifc_send_ctl);\n    return tick;\n}\n\n\nstatic enum LSQUIC_CONN_STATUS\nietf_full_conn_ci_status (struct lsquic_conn *lconn, char *errbuf, size_t bufsz)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    size_t n;\n\n    /* Test the common case first: */\n    if (!(conn->ifc_flags & (IFC_ERROR\n                            |IFC_TIMED_OUT\n                            |IFC_ABORTED\n                            |IFC_GOT_PRST\n                            |IFC_HSK_FAILED\n                            |IFC_CLOSING\n                            |IFC_GOING_AWAY)))\n    {\n        if (lconn->cn_flags & LSCONN_PEER_GOING_AWAY)\n            return LSCONN_ST_PEER_GOING_AWAY;\n        else if (lconn->cn_flags & LSCONN_HANDSHAKE_DONE)\n            return LSCONN_ST_CONNECTED;\n        else\n            return LSCONN_ST_HSK_IN_PROGRESS;\n    }\n\n    if (errbuf && bufsz)\n    {\n        if (conn->ifc_errmsg)\n        {\n            n = bufsz < MAX_ERRMSG ? bufsz : MAX_ERRMSG;\n            strncpy(errbuf, conn->ifc_errmsg, n);\n            errbuf[n - 1] = '\\0';\n        }\n        else\n            errbuf[0] = '\\0';\n    }\n\n    if (conn->ifc_flags & IFC_ERROR)\n    {\n        if (conn->ifc_flags & IFC_HSK_FAILED)\n            return LSCONN_ST_VERNEG_FAILURE;\n        else\n            return LSCONN_ST_ERROR;\n    }\n    if (conn->ifc_flags & IFC_TIMED_OUT)\n        return LSCONN_ST_TIMED_OUT;\n    if (conn->ifc_flags & IFC_ABORTED)\n        return LSCONN_ST_USER_ABORTED;\n    if (conn->ifc_flags & IFC_GOT_PRST)\n        return LSCONN_ST_RESET;\n    if (conn->ifc_flags & IFC_HSK_FAILED)\n        return LSCONN_ST_HSK_FAILURE;\n    if (conn->ifc_flags & IFC_CLOSING)\n        return LSCONN_ST_CLOSED;\n    assert(conn->ifc_flags & IFC_GOING_AWAY);\n    return LSCONN_ST_GOING_AWAY;\n}\n\n\nstatic void\nietf_full_conn_ci_stateless_reset (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    conn->ifc_flags |= IFC_GOT_PRST;\n    LSQ_INFO(\"stateless reset reported\");\n}\n\n\nstatic struct lsquic_engine *\nietf_full_conn_ci_get_engine (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return conn->ifc_enpub->enp_engine;\n}\n\n\nstatic unsigned\nietf_full_conn_ci_n_pending_streams (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    return conn->ifc_n_delayed_streams;\n}\n\n\nstatic unsigned\nietf_full_conn_ci_n_avail_streams (const struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    return avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_BIDI);\n}\n\n\nstatic int\nhandshake_done_or_doing_sess_resume (const struct ietf_full_conn *conn)\n{\n    return (conn->ifc_conn.cn_flags & LSCONN_HANDSHAKE_DONE)\n        || conn->ifc_conn.cn_esf_c->esf_is_sess_resume_enabled(\n                                                conn->ifc_conn.cn_enc_session);\n}\n\n\nstatic void\nietf_full_conn_ci_make_stream (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n\n    if (handshake_done_or_doing_sess_resume(conn)\n        && ietf_full_conn_ci_n_avail_streams(lconn) > 0)\n    {\n        if (0 != create_bidi_stream_out(conn))\n            ABORT_ERROR(\"could not create new stream: %s\", strerror(errno));\n    }\n    else if (either_side_going_away(conn))\n    {\n        (void) conn->ifc_enpub->enp_stream_if->on_new_stream(\n                                    conn->ifc_enpub->enp_stream_if_ctx, NULL);\n        LSQ_DEBUG(\"going away: no streams will be initiated\");\n    }\n    else\n    {\n        ++conn->ifc_n_delayed_streams;\n        LSQ_DEBUG(\"delayed stream creation.  Backlog size: %u\",\n                                                conn->ifc_n_delayed_streams);\n    }\n}\n\n\nstatic void\nietf_full_conn_ci_internal_error (struct lsquic_conn *lconn,\n                                                    const char *format, ...)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    LSQ_INFO(\"internal error reported\");\n    ABORT_QUIETLY(0, TEC_INTERNAL_ERROR, \"Internal error\");\n}\n\n\nstatic void\nietf_full_conn_ci_abort_error (struct lsquic_conn *lconn, int is_app,\n                                unsigned error_code, const char *fmt, ...)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    va_list ap;\n    const char *err_str, *percent;\n    char err_buf[0x100];\n\n    if (conn->ifc_error.u.err != 0)\n        return;\n    percent = strchr(fmt, '%');\n    if (percent)\n    {\n        va_start(ap, fmt);\n        vsnprintf(err_buf, sizeof(err_buf), fmt, ap);\n        va_end(ap);\n        err_str = err_buf;\n    }\n    else\n        err_str = fmt;\n    LSQ_INFO(\"abort error: is_app: %d; error code: %u; error str: %s\",\n        is_app, error_code, err_str);\n    ABORT_QUIETLY(is_app, error_code, \"%s\", err_str);\n}\n\n\nstatic int\npath_matches_local_sa (const struct network_path *path,\n                                            const struct sockaddr *local_sa)\n{\n    return lsquic_sockaddr_eq(NP_LOCAL_SA(path), local_sa);\n}\n\n\nstatic struct network_path *\nietf_full_conn_ci_get_path (struct lsquic_conn *lconn,\n                                                    const struct sockaddr *sa)\n{\n    struct ietf_full_conn *const conn = (struct ietf_full_conn *) lconn;\n    struct conn_path *copath;\n\n    if (NULL == sa || path_matches_local_sa(CUR_NPATH(conn), sa))\n        return CUR_NPATH(conn);\n\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n        if ((conn->ifc_used_paths & (1 << (copath - conn->ifc_paths)))\n                            && path_matches_local_sa(&copath->cop_path, sa))\n            return &copath->cop_path;\n\n    return CUR_NPATH(conn);\n}\n\n\nstatic int\npath_matches (const struct network_path *path,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    return local_sa->sa_family == NP_LOCAL_SA(path)->sa_family\n        && lsquic_sockaddr_eq(local_sa, NP_LOCAL_SA(path))\n        && lsquic_sockaddr_eq(peer_sa, NP_PEER_SA(path));\n}\n\n\nstatic void\nrecord_to_path (struct ietf_full_conn *conn, struct conn_path *copath, void *peer_ctx,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    struct network_path *path;\n    size_t len;\n    char path_str[2][INET6_ADDRSTRLEN + sizeof(\":65535\")];\n\n    LSQ_DEBUG(\"record path %d: (%s - %s)\", (int) (copath - conn->ifc_paths),\n                SA2STR(local_sa, path_str[0]), SA2STR(peer_sa, path_str[1]));\n    path = &copath->cop_path;\n    len = local_sa->sa_family == AF_INET ? sizeof(struct sockaddr_in)\n                                                : sizeof(struct sockaddr_in6);\n    memcpy(NP_LOCAL_SA(path), local_sa, len);\n    len = peer_sa->sa_family == AF_INET ? sizeof(struct sockaddr_in)\n                                            : sizeof(struct sockaddr_in6);\n    memcpy(NP_PEER_SA(path), peer_sa, len);\n    path->np_peer_ctx = peer_ctx;\n}\n\n\nstatic unsigned char\nietf_full_conn_ci_record_addrs (struct lsquic_conn *lconn, void *peer_ctx,\n            const struct sockaddr *local_sa, const struct sockaddr *peer_sa)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct network_path *path;\n    struct conn_path *copath, *first_unused, *first_unvalidated, *first_other,\n                                                                        *victim;\n\n    path = &conn->ifc_paths[conn->ifc_cur_path_id].cop_path;\n    if (path_matches(path, local_sa, peer_sa))\n    {\n        path->np_peer_ctx = peer_ctx;\n        return conn->ifc_cur_path_id;\n    }\n\n    first_unvalidated = NULL;\n    first_unused = NULL;\n    first_other = NULL;\n    for (copath = conn->ifc_paths; copath < conn->ifc_paths\n            + sizeof(conn->ifc_paths) / sizeof(conn->ifc_paths[0]); ++copath)\n    {\n        if (conn->ifc_used_paths & (1 << (copath - conn->ifc_paths)))\n        {\n            if (path_matches(&copath->cop_path, local_sa, peer_sa))\n            {\n                copath->cop_path.np_peer_ctx = peer_ctx;\n                return copath - conn->ifc_paths;\n            }\n            if (!first_unvalidated\n                            && (0 == (copath->cop_flags & COP_VALIDATED)))\n                first_unvalidated = copath;\n            else if (!first_other)\n                first_other = copath;\n        }\n        else if (!first_unused)\n            first_unused = copath;\n    }\n\n    if (first_unused)\n    {\n        record_to_path(conn, first_unused, peer_ctx, local_sa, peer_sa);\n        if (0 == conn->ifc_used_paths && !(conn->ifc_flags & IFC_SERVER))\n        {\n            /* First path is considered valid immediately */\n            first_unused->cop_flags |= COP_VALIDATED;\n            maybe_enable_spin(conn, first_unused);\n        }\n        LSQ_DEBUG(\"record new path ID %d\",\n                                    (int) (first_unused - conn->ifc_paths));\n        conn->ifc_used_paths |= 1 << (first_unused - conn->ifc_paths);\n        return first_unused - conn->ifc_paths;\n    }\n\n    if (first_unvalidated || first_other)\n    {\n        victim = first_unvalidated ? first_unvalidated : first_other;\n        record_to_path(conn, victim, peer_ctx, local_sa, peer_sa);\n        return victim - conn->ifc_paths;\n    }\n\n    return conn->ifc_cur_path_id;\n}\n\n\nstatic void\nietf_full_conn_ci_drop_crypto_streams (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    drop_crypto_streams(conn);\n}\n\n\nvoid\nietf_full_conn_ci_count_garbage (struct lsquic_conn *lconn, size_t garbage_sz)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n\n    conn->ifc_pub.bytes_in += garbage_sz;\n    LSQ_DEBUG(\"count %zd bytes of garbage, new value: %u bytes\", garbage_sz,\n        conn->ifc_pub.bytes_in);\n}\n\n\n#if LSQUIC_CONN_STATS\nstatic const struct conn_stats *\nietf_full_conn_ci_get_stats (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    return &conn->ifc_stats;\n}\n\n\n#include \"lsquic_cong_ctl.h\"\n\nstatic void\nietf_full_conn_ci_log_stats (struct lsquic_conn *lconn)\n{\n    struct ietf_full_conn *conn = (struct ietf_full_conn *) lconn;\n    struct batch_size_stats *const bs = &conn->ifc_enpub->enp_batch_size_stats;\n    struct conn_stats diff_stats;\n    uint64_t cwnd;\n    char cidstr[MAX_CID_LEN * 2 + 1];\n\n    if (!conn->ifc_last_stats)\n    {\n        conn->ifc_last_stats = calloc(1, sizeof(*conn->ifc_last_stats));\n        if (!conn->ifc_last_stats)\n            return;\n        LSQ_DEBUG(\"allocated last stats\");\n    }\n\n    cwnd = conn->ifc_send_ctl.sc_ci->cci_get_cwnd(\n                                            conn->ifc_send_ctl.sc_cong_ctl);\n    lsquic_conn_stats_diff(&conn->ifc_stats, conn->ifc_last_stats, &diff_stats);\n    lsquic_logger_log1(LSQ_LOG_NOTICE, LSQLM_CONN_STATS,\n        \"%s: ticks: %lu; cwnd: %\"PRIu64\"; conn flow: max: %\"PRIu64\n        \", avail: %\"PRIu64\"; packets: sent: %lu, lost: %lu, retx: %lu, rcvd: %lu\"\n        \"; batch: count: %u; min: %u; max: %u; avg: %.2f\",\n        (lsquic_cid2str(LSQUIC_LOG_CONN_ID, cidstr), cidstr),\n        diff_stats.n_ticks, cwnd,\n        conn->ifc_pub.conn_cap.cc_max,\n        lsquic_conn_cap_avail(&conn->ifc_pub.conn_cap),\n        diff_stats.out.packets, diff_stats.out.lost_packets,\n        diff_stats.out.retx_packets, diff_stats.in.packets,\n        bs->count, bs->min, bs->max, bs->avg);\n\n    *conn->ifc_last_stats = conn->ifc_stats;\n    memset(bs, 0, sizeof(*bs));\n}\n\n\n#endif\n\n\n#define IETF_FULL_CONN_FUNCS \\\n    .ci_abort                =  ietf_full_conn_ci_abort, \\\n    .ci_abort_error          =  ietf_full_conn_ci_abort_error, \\\n    .ci_ack_snapshot         =  ietf_full_conn_ci_ack_snapshot, \\\n    .ci_ack_rollback         =  ietf_full_conn_ci_ack_rollback, \\\n    .ci_retire_cid           =  ietf_full_conn_ci_retire_cid, \\\n    .ci_can_write_ack        =  ietf_full_conn_ci_can_write_ack, \\\n    .ci_cancel_pending_streams =  ietf_full_conn_ci_cancel_pending_streams, \\\n    .ci_client_call_on_new   =  ietf_full_conn_ci_client_call_on_new, \\\n    .ci_close                =  ietf_full_conn_ci_close, \\\n    .ci_count_garbage        =  ietf_full_conn_ci_count_garbage, \\\n    .ci_destroy              =  ietf_full_conn_ci_destroy, \\\n    .ci_drain_time           =  ietf_full_conn_ci_drain_time, \\\n    .ci_drop_crypto_streams  =  ietf_full_conn_ci_drop_crypto_streams, \\\n    .ci_early_data_failed    =  ietf_full_conn_ci_early_data_failed, \\\n    .ci_get_engine           =  ietf_full_conn_ci_get_engine, \\\n    .ci_get_min_datagram_size=  ietf_full_conn_ci_get_min_datagram_size, \\\n    .ci_get_path             =  ietf_full_conn_ci_get_path, \\\n    .ci_going_away           =  ietf_full_conn_ci_going_away, \\\n    .ci_hsk_done             =  ietf_full_conn_ci_hsk_done, \\\n    .ci_internal_error       =  ietf_full_conn_ci_internal_error, \\\n    .ci_is_push_enabled      =  ietf_full_conn_ci_is_push_enabled, \\\n    .ci_is_tickable          =  ietf_full_conn_ci_is_tickable, \\\n    .ci_make_stream          =  ietf_full_conn_ci_make_stream, \\\n    .ci_mtu_probe_acked      =  ietf_full_conn_ci_mtu_probe_acked, \\\n    .ci_n_avail_streams      =  ietf_full_conn_ci_n_avail_streams, \\\n    .ci_n_pending_streams    =  ietf_full_conn_ci_n_pending_streams, \\\n    .ci_next_tick_time       =  ietf_full_conn_ci_next_tick_time, \\\n    .ci_packet_in            =  ietf_full_conn_ci_packet_in, \\\n    .ci_push_stream          =  ietf_full_conn_ci_push_stream, \\\n    .ci_record_addrs         =  ietf_full_conn_ci_record_addrs, \\\n    .ci_report_live          =  ietf_full_conn_ci_report_live, \\\n    .ci_retx_timeout         =  ietf_full_conn_ci_retx_timeout, \\\n    .ci_set_min_datagram_size=  ietf_full_conn_ci_set_min_datagram_size, \\\n    .ci_status               =  ietf_full_conn_ci_status, \\\n    .ci_stateless_reset      =  ietf_full_conn_ci_stateless_reset, \\\n    .ci_tick                 =  ietf_full_conn_ci_tick, \\\n    .ci_tls_alert            =  ietf_full_conn_ci_tls_alert, \\\n    .ci_want_datagram_write  =  ietf_full_conn_ci_want_datagram_write, \\\n    .ci_write_ack            =  ietf_full_conn_ci_write_ack\n\nstatic const struct conn_iface ietf_full_conn_iface = {\n    IETF_FULL_CONN_FUNCS,\n    .ci_next_packet_to_send =  ietf_full_conn_ci_next_packet_to_send,\n    .ci_packet_not_sent     =  ietf_full_conn_ci_packet_not_sent,\n    .ci_packet_sent         =  ietf_full_conn_ci_packet_sent,\n    .ci_packet_too_large    =  ietf_full_conn_ci_packet_too_large,\n#if LSQUIC_CONN_STATS\n    .ci_get_stats           =  ietf_full_conn_ci_get_stats,\n    .ci_log_stats           =  ietf_full_conn_ci_log_stats,\n#endif\n};\nstatic const struct conn_iface *ietf_full_conn_iface_ptr =\n                                                &ietf_full_conn_iface;\n\nstatic const struct conn_iface ietf_full_conn_prehsk_iface = {\n    IETF_FULL_CONN_FUNCS,\n    .ci_next_packet_to_send =  ietf_full_conn_ci_next_packet_to_send_pre_hsk,\n    .ci_packet_not_sent     =  ietf_full_conn_ci_packet_not_sent_pre_hsk,\n    .ci_packet_sent         =  ietf_full_conn_ci_packet_sent_pre_hsk,\n#if LSQUIC_CONN_STATS\n    .ci_get_stats           =  ietf_full_conn_ci_get_stats,\n    .ci_log_stats           =  ietf_full_conn_ci_log_stats,\n#endif\n};\nstatic const struct conn_iface *ietf_full_conn_prehsk_iface_ptr =\n                                                &ietf_full_conn_prehsk_iface;\n\n\nstatic void\non_cancel_push_client (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received CANCEL_PUSH(%\"PRIu64\")\",\n                                                                    push_id);\n    if (conn->ifc_u.cli.ifcli_flags & IFCLI_PUSH_ENABLED)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH but push is \"\n                                                                \"not enabled\");\n        return;\n    }\n\n    if (push_id > conn->ifc_u.cli.ifcli_max_push_id)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH with ID=%\"PRIu64\n            \", which is greater than the maximum Push ID=%\"PRIu64, push_id,\n            conn->ifc_u.cli.ifcli_max_push_id);\n        return;\n    }\n\n#if CLIENT_PUSH_SUPPORT\n    LSQ_WARN(\"TODO: support for CANCEL_PUSH is not implemented\");\n#endif\n}\n\n\n/* Careful: this puts promise */\nstatic void\ncancel_push_promise (struct ietf_full_conn *conn, struct push_promise *promise)\n{\n    LSQ_DEBUG(\"cancel promise %\"PRIu64, promise->pp_id);\n    /* Remove promise from hash to prevent multiple cancellations */\n    lsquic_hash_erase(conn->ifc_pub.u.ietf.promises, &promise->pp_hash_id);\n    /* But let stream dtor free the promise object as sm_promise may yet\n     * be used by the stream in some ways.\n     */\n    /* TODO: drop lsquic_stream_shutdown_internal, use something else */\n    lsquic_stream_shutdown_internal(promise->pp_pushed_stream);\n    if (0 != lsquic_hcso_write_cancel_push(&conn->ifc_hcso, promise->pp_id))\n        ABORT_WARN(\"cannot write CANCEL_PUSH\");\n    lsquic_pp_put(promise, conn->ifc_pub.u.ietf.promises);\n}\n\n\nstatic void\non_cancel_push_server (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received CANCEL_PUSH(%\"PRIu64\")\",\n                                                                    push_id);\n    if (push_id >= conn->ifc_u.ser.ifser_next_push_id)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"received CANCEL_PUSH with ID=%\"PRIu64\n            \", which is greater than the maximum Push ID ever generated by \"\n            \"this connection\", push_id);\n        return;\n    }\n\n    el = lsquic_hash_find(conn->ifc_pub.u.ietf.promises, &push_id,\n                                                            sizeof(push_id));\n    if (!el)\n    {\n        LSQ_DEBUG(\"push promise %\"PRIu64\" not found\", push_id);\n        return;\n    }\n\n    promise = lsquic_hashelem_getdata(el);\n    cancel_push_promise(conn, promise);\n}\n\n\nstatic void\non_max_push_id_client (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"client does not expect the server \"\n        \"to send MAX_PUSH_ID frame\");\n}\n\n\nstatic void\non_max_push_id (void *ctx, uint64_t push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    if (!(conn->ifc_u.ser.ifser_flags & IFSER_MAX_PUSH_ID)\n                            || push_id > conn->ifc_u.ser.ifser_max_push_id)\n    {\n        conn->ifc_u.ser.ifser_max_push_id = push_id;\n        conn->ifc_u.ser.ifser_flags |= IFSER_MAX_PUSH_ID;\n        LSQ_DEBUG(\"set MAX_PUSH_ID to %\"PRIu64, push_id);\n    }\n    else if (push_id < conn->ifc_u.ser.ifser_max_push_id)\n        ABORT_QUIETLY(1, HEC_ID_ERROR, \"MAX_PUSH_ID reduced from \"\n            \"%\"PRIu64\" to %\"PRIu64, conn->ifc_u.ser.ifser_max_push_id, push_id);\n    else\n        LSQ_DEBUG(\"ignore repeated value of MAX_PUSH_ID=%\"PRIu64, push_id);\n}\n\n\nstatic void\non_settings_frame (void *ctx)\n{\n    struct ietf_full_conn *const conn = ctx;\n    unsigned dyn_table_size, max_risked_streams;\n\n    LSQ_DEBUG(\"SETTINGS frame\");\n    if (conn->ifc_flags & IFC_HAVE_PEER_SET)\n    {\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED,\n            \"second incoming SETTING frame on HTTP control stream\");\n        return;\n    }\n\n    conn->ifc_flags |= IFC_HAVE_PEER_SET;\n    dyn_table_size = MIN(conn->ifc_settings->es_qpack_enc_max_size,\n                                conn->ifc_peer_hq_settings.header_table_size);\n    max_risked_streams = MIN(conn->ifc_settings->es_qpack_enc_max_blocked,\n                            conn->ifc_peer_hq_settings.qpack_blocked_streams);\n    if (conn->ifc_settings->es_qpack_experiment == 2)\n        randomize_qpack_settings(conn, \"encoder\", &dyn_table_size,\n                                                        &max_risked_streams);\n    if (conn->ifc_qeh.qeh_exp_rec)\n    {\n        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_size\n                        = conn->ifc_peer_hq_settings.header_table_size;\n        conn->ifc_qeh.qeh_exp_rec->qer_used_max_size = dyn_table_size;\n        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_blocked\n                        = conn->ifc_peer_hq_settings.qpack_blocked_streams;\n        conn->ifc_qeh.qeh_exp_rec->qer_used_max_blocked = max_risked_streams;\n    }\n    if (0 != lsquic_qeh_settings(&conn->ifc_qeh,\n            conn->ifc_peer_hq_settings.header_table_size,\n            dyn_table_size, max_risked_streams, conn->ifc_flags & IFC_SERVER))\n        ABORT_WARN(\"could not initialize QPACK encoder handler\");\n    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)\n    {\n        if (0 != create_qenc_stream_out(conn))\n            ABORT_WARN(\"cannot create outgoing QPACK encoder stream\");\n    }\n    else\n    {\n        queue_streams_blocked_frame(conn, SD_UNI);\n        LSQ_DEBUG(\"cannot create QPACK encoder stream due to unidir limit\");\n    }\n    maybe_create_delayed_streams(conn);\n}\n\n\nstatic void\non_setting (void *ctx, uint64_t setting_id, uint64_t value)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    switch (setting_id)\n    {\n    case HQSID_QPACK_BLOCKED_STREAMS:\n        LSQ_DEBUG(\"Peer's SETTINGS_QPACK_BLOCKED_STREAMS=%\"PRIu64, value);\n        conn->ifc_peer_hq_settings.qpack_blocked_streams = value;\n        break;\n    case HQSID_QPACK_MAX_TABLE_CAPACITY:\n        LSQ_DEBUG(\"Peer's SETTINGS_QPACK_MAX_TABLE_CAPACITY=%\"PRIu64, value);\n        conn->ifc_peer_hq_settings.header_table_size = value;\n        break;\n    case HQSID_MAX_HEADER_LIST_SIZE:\n        LSQ_DEBUG(\"Peer's SETTINGS_MAX_HEADER_LIST_SIZE=%\"PRIu64\"; \"\n                                                        \"we ignore it\", value);\n        break;\n    default:\n        LSQ_DEBUG(\"received unknown SETTING 0x%\"PRIX64\"=0x%\"PRIX64\n                                        \"; ignore it\", setting_id, value);\n        break;\n    case 2: /* HTTP/2 SETTINGS_ENABLE_PUSH */\n    case 3: /* HTTP/2 SETTINGS_MAX_CONCURRENT_STREAMS */\n    case 4: /* HTTP/2 SETTINGS_INITIAL_WINDOW_SIZE */\n    case 5: /* HTTP/2 SETTINGS_MAX_FRAME_SIZE */\n        /* [draft-ietf-quic-http-30] Section 7.2.4.1 */\n        ABORT_QUIETLY(1, HEC_SETTINGS_ERROR, \"unexpected HTTP/2 setting \"\n            \"%\"PRIu64, setting_id);\n        break;\n    }\n}\n\n\nstatic void\non_goaway_server_27 (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED,\n                                    \"client should not send GOAWAY frames\");\n}\n\n\nstatic void\non_goaway_client_27 (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (sit != SIT_BIDI_CLIENT)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR,\n                            \"stream ID %\"PRIu64\" in GOAWAY frame\", stream_id);\n        return;\n    }\n\n    if (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY)\n    {\n        LSQ_DEBUG(\"ignore duplicate GOAWAY frame\");\n        return;\n    }\n\n    conn->ifc_conn.cn_flags |= LSCONN_PEER_GOING_AWAY;\n    LSQ_DEBUG(\"received GOAWAY frame, last good stream ID: %\"PRIu64, stream_id);\n    if (conn->ifc_enpub->enp_stream_if->on_goaway_received)\n        conn->ifc_enpub->enp_stream_if->on_goaway_received(&conn->ifc_conn);\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (stream->id > stream_id\n                            && (stream->id & SIT_MASK) == SIT_BIDI_CLIENT)\n        {\n            lsquic_stream_received_goaway(stream);\n        }\n    }\n}\n\n\nstatic void\non_goaway_client (void *ctx, uint64_t stream_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_stream *stream;\n    struct lsquic_hash_elem *el;\n    enum stream_id_type sit;\n\n    sit = stream_id & SIT_MASK;\n    if (sit != SIT_BIDI_CLIENT)\n    {\n        ABORT_QUIETLY(1, HEC_ID_ERROR,\n                            \"stream ID %\"PRIu64\" in GOAWAY frame\", stream_id);\n        return;\n    }\n\n    LSQ_DEBUG(\"received GOAWAY frame, last good stream ID: %\"PRIu64, stream_id);\n\n    if (conn->ifc_conn.cn_flags & LSCONN_PEER_GOING_AWAY)\n    {\n        if (stream_id == conn->ifc_u.cli.ifcli_min_goaway_stream_id)\n        {\n            LSQ_DEBUG(\"ignore duplicate GOAWAY frame\");\n            return;\n        }\n        if (stream_id > conn->ifc_u.cli.ifcli_min_goaway_stream_id)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR,\n                \"stream ID %\"PRIu64\" is larger than one already seen in a \"\n                \"previous GOAWAY frame, %\"PRIu64, stream_id,\n                conn->ifc_u.cli.ifcli_min_goaway_stream_id);\n            return;\n        }\n    }\n    else\n    {\n        conn->ifc_u.cli.ifcli_min_goaway_stream_id = stream_id;\n        conn->ifc_conn.cn_flags |= LSCONN_PEER_GOING_AWAY;\n        if (conn->ifc_enpub->enp_stream_if->on_goaway_received)\n            conn->ifc_enpub->enp_stream_if->on_goaway_received(&conn->ifc_conn);\n    }\n\n    for (el = lsquic_hash_first(conn->ifc_pub.all_streams); el;\n                             el = lsquic_hash_next(conn->ifc_pub.all_streams))\n    {\n        stream = lsquic_hashelem_getdata(el);\n        if (stream->id > stream_id\n                            && (stream->id & SIT_MASK) == SIT_BIDI_CLIENT)\n        {\n            lsquic_stream_received_goaway(stream);\n        }\n    }\n}\n\n\nstatic void\non_goaway_server (void *ctx, uint64_t max_push_id)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct push_promise *promise;\n    struct lsquic_hash_elem *el;\n\n    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, \"Received GOAWAY(%\"PRIu64\")\",\n                                                                max_push_id);\n    for (el = lsquic_hash_first(conn->ifc_pub.u.ietf.promises); el;\n                        el = lsquic_hash_next(conn->ifc_pub.u.ietf.promises))\n    {\n        promise = lsquic_hashelem_getdata(el);\n        if (promise->pp_id > max_push_id)\n            cancel_push_promise(conn, promise);\n    }\n}\n\n\nstatic void\non_priority_update_client (void *ctx, enum hq_frame_type frame_type,\n                                uint64_t id, const char *pfv, size_t pfv_sz)\n{\n    struct ietf_full_conn *const conn = ctx;\n\n    if (conn->ifc_pii == &ext_prio_iter_if)\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"Frame type %u is not \"\n            \"expected to be sent by the server\", (unsigned) frame_type);\n    /* else ignore */\n}\n\n\n/* This should not happen often, so do not bother to optimize memory. */\nstatic int\nbuffer_priority_update (struct ietf_full_conn *conn,\n        lsquic_stream_id_t stream_id, const struct lsquic_ext_http_prio *ehp)\n{\n    struct buffered_priority_update *bpu;\n    struct lsquic_hash_elem *el;\n\n    if (!conn->ifc_bpus)\n    {\n        conn->ifc_bpus = lsquic_hash_create();\n        if (!conn->ifc_bpus)\n        {\n            ABORT_ERROR(\"cannot allocate BPUs hash\");\n            return -1;\n        }\n        goto insert_new;\n    }\n\n    el = lsquic_hash_find(conn->ifc_bpus, &stream_id, sizeof(stream_id));\n    if (el)\n    {\n        bpu = lsquic_hashelem_getdata(el);\n        bpu->ehp = *ehp;\n        return 0;\n    }\n\n  insert_new:\n    bpu = malloc(sizeof(*bpu));\n    if (!bpu)\n    {\n        ABORT_ERROR(\"cannot allocate BPU\");\n        return -1;\n    }\n\n    bpu->hash_el.qhe_flags = 0;\n    bpu->stream_id = stream_id;\n    bpu->ehp = *ehp;\n    if (!lsquic_hash_insert(conn->ifc_bpus, &bpu->stream_id,\n                                sizeof(bpu->stream_id), bpu, &bpu->hash_el))\n    {\n        free(bpu);\n        ABORT_ERROR(\"cannot insert BPU\");\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic void\non_priority_update_server (void *ctx, enum hq_frame_type frame_type,\n                                uint64_t id, const char *pfv, size_t pfv_sz)\n{\n    struct ietf_full_conn *const conn = ctx;\n    struct lsquic_hash_elem *el;\n    struct push_promise *promise;\n    struct lsquic_stream *stream;\n    enum stream_id_type sit;\n    struct lsquic_ext_http_prio ehp;\n\n    if (conn->ifc_pii != &ext_prio_iter_if)\n    {\n        LSQ_DEBUG(\"Ignore PRIORITY_UPDATE frame\");\n        return;\n    }\n\n    if (frame_type == HQFT_PRIORITY_UPDATE_STREAM)\n    {\n        sit = id & SIT_MASK;\n        if (sit != SIT_BIDI_CLIENT)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"PRIORITY_UPDATE for non-request \"\n                \"stream\");\n            return;\n        }\n        if (id >= conn->ifc_max_allowed_stream_id[sit])\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"PRIORITY_UPDATE for non-existing \"\n                \"stream %\"PRIu64\" exceeds allowed max of %\"PRIu64,\n                id, conn->ifc_max_allowed_stream_id[sit]);\n            return;\n        }\n        stream = find_stream_by_id(conn, id);\n        if (!stream && conn_is_stream_closed(conn, id))\n        {\n            LSQ_DEBUG(\"stream %\"PRIu64\" closed, ignore PRIORITY_UPDATE\", id);\n            return;\n        }\n    }\n    else\n    {\n        if (id >= conn->ifc_u.ser.ifser_next_push_id)\n        {\n            ABORT_QUIETLY(1, HEC_ID_ERROR, \"received PRIORITY_UPDATE with \"\n                \"ID=%\"PRIu64\", which is greater than the maximum Push ID \"\n                \"ever generated by this connection\", id);\n            return;\n        }\n        el = lsquic_hash_find(conn->ifc_pub.u.ietf.promises, &id, sizeof(id));\n        if (!el)\n        {\n            LSQ_DEBUG(\"push promise %\"PRIu64\" not found, ignore \"\n                                                    \"PRIORITY_UPDATE\", id);\n            return;\n        }\n        promise = lsquic_hashelem_getdata(el);\n        stream = promise->pp_pushed_stream;\n        assert(stream);\n    }\n\n    ehp = (struct lsquic_ext_http_prio) {\n        .urgency     = LSQUIC_DEF_HTTP_URGENCY,\n        .incremental = LSQUIC_DEF_HTTP_INCREMENTAL,\n    };\n    if (pfv_sz)\n    {\n        switch (lsquic_http_parse_pfv(pfv, pfv_sz, NULL, &ehp,\n                                    (char *) conn->ifc_pub.mm->acki,\n                                    sizeof(*conn->ifc_pub.mm->acki)))\n        {\n        case 0:\n            LSQ_DEBUG(\"Parsed PFV `%.*s' correctly\", (int) pfv_sz, pfv);\n            break;\n        case -2:    /* Out of memory, ignore */\n            LSQ_INFO(\"Ignore PFV `%.*s': out of memory\", (int) pfv_sz, pfv);\n            return;\n        default:\n            LSQ_INFO(\"connection error due to invalid PFV `%.*s'\",\n                                                        (int) pfv_sz, pfv);\n            /* From the draft (between versions 1 and 2):\n             \" Failure to parse the Priority Field Value MUST be treated\n             \" as a connection error of type FRAME_ENCODING_ERROR.\n             */\n            ABORT_QUIETLY(1, HEC_FRAME_ERROR, \"cannot parse Priority Field \"\n                \"Value in PRIORITY_UPDATE frame\");\n            return;\n        }\n    }\n    else\n        { /* Empty PFV means \"use defaults\" */ }\n\n    if (stream)\n        (void) lsquic_stream_set_http_prio(stream, &ehp);\n    else\n    {\n        assert(frame_type == HQFT_PRIORITY_UPDATE_STREAM);\n        if (0 == buffer_priority_update(conn, id, &ehp))\n            LSQ_INFO(\"buffered priority update for stream %\"PRIu64\"; \"\n                \"urgency: %hhu, incremental: %hhd\", id, ehp.urgency,\n                ehp.incremental);\n    }\n}\n\n\nstatic void\non_frame_error (void *ctx, unsigned code, uint64_t frame_type)\n{\n    struct ietf_full_conn *const conn = ctx;\n    if (code == HEC_MISSING_SETTINGS)\n        ABORT_QUIETLY(1, code, \"The first control frame is not SETTINGS, \"\n                     \"got frame type %\"PRIu64, frame_type);\n    else\n        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED, \"Frame type %\"PRIu64\" is not \"\n            \"allowed on the control stream\", frame_type);\n}\n\n\nstatic const struct hcsi_callbacks hcsi_callbacks_server_27 =\n{\n    .on_cancel_push         = on_cancel_push_server,\n    .on_max_push_id         = on_max_push_id,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_server_27,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_server,\n};\n\nstatic const struct hcsi_callbacks hcsi_callbacks_client_27 =\n{\n    .on_cancel_push         = on_cancel_push_client,\n    .on_max_push_id         = on_max_push_id_client,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_client_27,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_client,\n};\n\n\nstatic const struct hcsi_callbacks hcsi_callbacks_server_29 =\n{\n    .on_cancel_push         = on_cancel_push_server,\n    .on_max_push_id         = on_max_push_id,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_server,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_server,\n};\n\nstatic const struct hcsi_callbacks hcsi_callbacks_client_29 =\n{\n    .on_cancel_push         = on_cancel_push_client,\n    .on_max_push_id         = on_max_push_id_client,\n    .on_settings_frame      = on_settings_frame,\n    .on_setting             = on_setting,\n    .on_goaway              = on_goaway_client,\n    .on_frame_error         = on_frame_error,\n    .on_priority_update     = on_priority_update_client,\n};\n\n\nstatic lsquic_stream_ctx_t *\nhcsi_on_new (void *stream_if_ctx, struct lsquic_stream *stream)\n{\n    struct ietf_full_conn *const conn = (void *) stream_if_ctx;\n    const struct hcsi_callbacks *callbacks;\n\n    conn->ifc_mflags |= MF_HAVE_HCSI;\n\n    switch ((!!(conn->ifc_flags & IFC_SERVER) << 8) | conn->ifc_conn.cn_version)\n    {\n        case (0 << 8) | LSQVER_ID27:\n            callbacks = &hcsi_callbacks_client_27;\n            break;\n        case (1 << 8) | LSQVER_ID27:\n            callbacks = &hcsi_callbacks_server_27;\n            break;\n        case (0 << 8) | LSQVER_ID29:\n        case (0 << 8) | LSQVER_I001:\n        case (0 << 8) | LSQVER_I002:\n            callbacks = &hcsi_callbacks_client_29;\n            break;\n        default:\n            assert(0);\n            /* fallthru */\n        case (1 << 8) | LSQVER_ID29:\n        case (1 << 8) | LSQVER_I001:\n        case (1 << 8) | LSQVER_I002:\n            callbacks = &hcsi_callbacks_server_29;\n            break;\n    }\n    lsquic_hcsi_reader_init(&conn->ifc_hcsi.reader, &conn->ifc_conn,\n                                                            callbacks, conn);\n    lsquic_stream_wantread(stream, 1);\n    return stream_if_ctx;\n}\n\n\nstruct feed_hcsi_ctx\n{\n    struct ietf_full_conn *conn;\n    int                    s;\n};\n\n\nstatic size_t\nfeed_hcsi_reader (void *ctx, const unsigned char *buf, size_t bufsz, int fin)\n{\n    struct feed_hcsi_ctx *feed_ctx = ctx;\n    struct ietf_full_conn *conn = feed_ctx->conn;\n\n    feed_ctx->s = lsquic_hcsi_reader_feed(&conn->ifc_hcsi.reader, buf, bufsz);\n    return bufsz;\n}\n\n\nstatic void\nhcsi_on_read (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    struct ietf_full_conn *const conn = (void *) ctx;\n    struct lsquic_conn *const lconn = &conn->ifc_conn;\n    struct feed_hcsi_ctx feed_ctx = { conn, 0, };\n    ssize_t nread;\n\n    nread = lsquic_stream_readf(stream, feed_hcsi_reader, &feed_ctx);\n    LSQ_DEBUG(\"fed %zd bytes to HTTP control stream reader, status=%d\",\n        nread, feed_ctx.s);\n    if (nread < 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        ABORT_WARN(\"error reading from HTTP control stream\");\n    }\n    else if (nread == 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        LSQ_INFO(\"control stream closed by peer: abort connection\");\n        lconn->cn_if->ci_abort_error(lconn, 1,\n            HEC_CLOSED_CRITICAL_STREAM, \"control stream closed\");\n    }\n    else if (feed_ctx.s != 0)\n    {\n        lsquic_stream_wantread(stream, 0);\n        ABORT_WARN(\"error processing HTTP control stream\");\n    }\n}\n\n\nstatic void\nhcsi_on_write (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    assert(0);\n}\n\n\nstatic void\nhcsi_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n}\n\n\nstatic const struct lsquic_stream_if hcsi_if =\n{\n    .on_new_stream  = hcsi_on_new,\n    .on_read        = hcsi_on_read,\n    .on_write       = hcsi_on_write,\n    .on_close       = hcsi_on_close,\n};\n\n\nstatic void\napply_uni_stream_class (struct ietf_full_conn *conn,\n                            struct lsquic_stream *stream, uint64_t stream_type)\n{\n    switch (stream_type)\n    {\n    case HQUST_CONTROL:\n        if (!(conn->ifc_mflags & MF_HAVE_HCSI))\n        {\n            LSQ_DEBUG(\"Incoming HTTP control stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, &hcsi_if, conn);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Attempt to create second control stream\");\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_QPACK_ENC:\n        if (!lsquic_qdh_has_enc_stream(&conn->ifc_qdh))\n        {\n            LSQ_DEBUG(\"Incoming QPACK encoder stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, lsquic_qdh_enc_sm_in_if,\n                                                            &conn->ifc_qdh);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Incoming QPACK encoder stream %\"PRIu64\" already exists: \"\n                \"cannot create second stream %\"PRIu64,\n                conn->ifc_qdh.qdh_enc_sm_in->id, stream->id);\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_QPACK_DEC:\n        if (!lsquic_qeh_has_dec_stream(&conn->ifc_qeh))\n        {\n            LSQ_DEBUG(\"Incoming QPACK decoder stream ID: %\"PRIu64,\n                                                            stream->id);\n            lsquic_stream_set_stream_if(stream, lsquic_qeh_dec_sm_in_if,\n                                                            &conn->ifc_qeh);\n        }\n        else\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"Incoming QPACK decoder stream %\"PRIu64\" already exists: \"\n                \"cannot create second stream %\"PRIu64,\n                conn->ifc_qeh.qeh_dec_sm_in->id, stream->id);\n            lsquic_stream_close(stream);\n        }\n        break;\n    case HQUST_PUSH:\n        if (conn->ifc_flags & IFC_SERVER)\n        {\n            ABORT_QUIETLY(1, HEC_STREAM_CREATION_ERROR,\n                \"clients can't open push streams\");\n        }\n        else\n        {\n            LSQ_DEBUG(\"Refuse push stream %\"PRIu64, stream->id);\n            maybe_schedule_ss_for_stream(conn, stream->id,\n                                                        HEC_REQUEST_CANCELLED);\n        }\n        lsquic_stream_close(stream);\n        break;\n    default:\n        LSQ_DEBUG(\"unknown unidirectional stream %\"PRIu64 \" of type %\"PRIu64\n            \", will send STOP_SENDING and close\", stream->id, stream_type);\n        /* XXX This approach may be risky, as it assumes that the peer updates\n         * its flow control window correctly.  The safe way to do it is to\n         * create a stream and wait for RESET_STREAM frame.  This is not an\n         * issue in the normal case, as the server does not allow the peer to\n         * create more than 3 unidirectional streams.\n         */\n        maybe_schedule_ss_for_stream(conn, stream->id,\n                                                    HEC_STREAM_CREATION_ERROR);\n        lsquic_stream_close(stream);\n        break;\n    }\n}\n\n\nstatic lsquic_stream_ctx_t *\nunicla_on_new (void *stream_if_ctx, struct lsquic_stream *stream)\n{\n    lsquic_stream_wantread(stream, 1);\n    stream->sm_uni_type_state.pos = 0;\n    return stream_if_ctx;\n}\n\n\nstruct unicla_ctx\n{\n    struct varint_read_state               *state;\n    enum { UC_MORE, UC_ERROR, UC_DONE, }    status;\n};\n\n\nstatic const char *const unicla_stat2str[] = {\n    [UC_ERROR] = \"UC_ERROR\", [UC_MORE] = \"UC_MORE\", [UC_DONE] = \"UC_DONE\",\n};\n\n\nstatic size_t\nunicla_readf (void *ctx, const unsigned char *begin, size_t sz, int fin)\n{\n    struct unicla_ctx *const unicla_ctx = ctx;\n    const unsigned char *buf = begin;\n    int s;\n\n    switch (unicla_ctx->status)\n    {\n    case UC_MORE:\n        s = lsquic_varint_read_nb(&buf, begin + sz, unicla_ctx->state);\n        if (s == 0)\n            unicla_ctx->status = UC_DONE;\n        else if (fin)\n            unicla_ctx->status = UC_ERROR;\n        return buf - begin;\n    case UC_DONE:\n        return 0;\n    default:\n        return sz;\n    }\n}\n\n\nstatic void\nunicla_on_read (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    struct ietf_full_conn *const conn = (void *) ctx;\n    struct unicla_ctx unicla_ctx = { .state = &stream->sm_uni_type_state,\n                                     .status = UC_MORE, };\n    ssize_t nr;\n\n    nr = lsquic_stream_readf(stream, unicla_readf, &unicla_ctx);\n    LSQ_DEBUG(\"unistream classifier read %zd byte%.*s, status: %s\", nr,\n                            nr != 1, \"s\", unicla_stat2str[unicla_ctx.status]);\n    if (nr > 0)\n    {\n        if (unicla_ctx.status == UC_DONE)\n            apply_uni_stream_class(conn, stream, unicla_ctx.state->val);\n        else if (unicla_ctx.status == UC_ERROR)\n            goto unexpected_fin;\n        /* else: do nothing */\n    }\n    else if (nr < 0) /* This should never happen */\n    {\n        LSQ_WARN(\"unicla: cannot read from stream %\"PRIu64, stream->id);\n        lsquic_stream_close(stream);\n    }\n    else\n    {\n  unexpected_fin:\n        LSQ_INFO(\"unicla: unexpected FIN while reading stream type from \"\n                                                \"stream %\"PRIu64, stream->id);\n        lsquic_stream_close(stream);\n    }\n}\n\n\nstatic void\nunicla_on_write (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n    assert(0);\n}\n\n\nstatic void\nunicla_on_close (struct lsquic_stream *stream, lsquic_stream_ctx_t *ctx)\n{\n}\n\n\nstatic const struct lsquic_stream_if unicla_if =\n{\n    .on_new_stream  = unicla_on_new,\n    .on_read        = unicla_on_read,\n    .on_write       = unicla_on_write,\n    .on_close       = unicla_on_close,\n};\n\n\nstatic const struct lsquic_stream_if *unicla_if_ptr = &unicla_if;\n\ntypedef char dcid_elem_fits_in_128_bytes[sizeof(struct dcid_elem) <= 128 ? 1 : - 1];\n\n"], "filenames": ["src/liblsquic/lsquic_full_conn_ietf.c"], "buggy_code_start_loc": [7286], "buggy_code_end_loc": [7549], "fixing_code_start_loc": [7286], "fixing_code_end_loc": [7552], "type": "NVD-CWE-noinfo", "message": "In LiteSpeed QUIC (LSQUIC) Library before 4.0.4, DCID validation is mishandled.", "other": {"cve": {"id": "CVE-2024-25678", "sourceIdentifier": "cve@mitre.org", "published": "2024-02-09T10:15:08.683", "lastModified": "2024-02-15T18:45:09.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LiteSpeed QUIC (LSQUIC) Library before 4.0.4, DCID validation is mishandled."}, {"lang": "es", "value": "En LiteSpeed QUIC (LSQUIC) Library anterior a 4.0.4, la validaci\u00f3n de DCID se maneja mal."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:litespeedtech:lsquic:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.0.4", "matchCriteriaId": "B8AAE561-2B4E-4285-B015-0565356BC3B3"}]}]}], "references": [{"url": "https://github.com/litespeedtech/lsquic/commit/515f453556c99d27c4dddb5424898dc1a5537708", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/litespeedtech/lsquic/releases/tag/v4.0.4", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.rfc-editor.org/rfc/rfc9001", "source": "cve@mitre.org", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/litespeedtech/lsquic/commit/515f453556c99d27c4dddb5424898dc1a5537708"}}