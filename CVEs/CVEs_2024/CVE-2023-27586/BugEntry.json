{"buggy_code": ["\"\"\"\nCommand-line interface to CairoSVG.\n\n\"\"\"\n\nimport argparse\nimport os\nimport sys\n\nfrom . import SURFACES, VERSION\n\n\ndef main(argv=None, stdout=None, stdin=None):\n    \"\"\"Entry-point of the executable.\"\"\"\n    # Get command-line options\n    parser = argparse.ArgumentParser(\n        description='Convert SVG files to other formats')\n    parser.add_argument('input', default='-', help='input filename or URL')\n    parser.add_argument(\n        '-v', '--version', action='version', version=VERSION)\n    parser.add_argument(\n        '-f', '--format', help='output format',\n        choices=sorted([surface.lower() for surface in SURFACES]))\n    parser.add_argument(\n        '-d', '--dpi', default=96, type=float,\n        help='ratio between 1 inch and 1 pixel')\n    parser.add_argument(\n        '-W', '--width', default=None, type=float,\n        help='width of the parent container in pixels')\n    parser.add_argument(\n        '-H', '--height', default=None, type=float,\n        help='height of the parent container in pixels')\n    parser.add_argument(\n        '-s', '--scale', default=1, type=float, help='output scaling factor')\n    parser.add_argument(\n        '-b', '--background', metavar='COLOR', help='output background color')\n    parser.add_argument(\n        '-n', '--negate-colors', action='store_true',\n        help='replace every vector color with its complement')\n    parser.add_argument(\n        '-i', '--invert-images', action='store_true',\n        help='replace every raster pixel with its complementary color')\n    parser.add_argument(\n        '-u', '--unsafe', action='store_true',\n        help='resolve XML entities and allow very large files '\n             '(WARNING: vulnerable to XXE attacks and various DoS)')\n    parser.add_argument(\n        '--output-width', default=None, type=float,\n        help='desired output width in pixels')\n    parser.add_argument(\n        '--output-height', default=None, type=float,\n        help='desired output height in pixels')\n\n    parser.add_argument('-o', '--output', default='-', help='output filename')\n\n    options = parser.parse_args(argv)\n    kwargs = {\n        'parent_width': options.width, 'parent_height': options.height,\n        'dpi': options.dpi, 'scale': options.scale, 'unsafe': options.unsafe,\n        'background_color': options.background,\n        'negate_colors': options.negate_colors,\n        'invert_images': options.invert_images,\n        'output_width': options.output_width,\n        'output_height': options.output_height}\n    stdin = stdin or sys.stdin\n    stdout = stdout or sys.stdout\n    kwargs['write_to'] = (\n        stdout.buffer if options.output == '-' else options.output)\n    if options.input == '-':\n        kwargs['file_obj'] = stdin.buffer\n    else:\n        kwargs['url'] = options.input\n    output_format = (\n        options.format or\n        os.path.splitext(options.output)[1].lstrip('.') or\n        'pdf').upper()\n\n    SURFACES[output_format.upper()].convert(**kwargs)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    main()\n", "\"\"\"\nSVG Parser.\n\n\"\"\"\n\nimport gzip\nimport re\nfrom urllib.parse import urlunparse\nfrom xml.etree.ElementTree import Element\n\nimport cssselect2\nfrom defusedxml import ElementTree\n\nfrom . import css\nfrom .features import match_features\nfrom .helpers import flatten, pop_rotation, rotations\nfrom .url import fetch, parse_url, read_url\n\n# 'display' is actually inherited but handled differently because some markers\n# are part of a none-displaying group (see test painting-marker-07-f.svg)\nNOT_INHERITED_ATTRIBUTES = frozenset((\n    'clip',\n    'clip-path',\n    'display',\n    'filter',\n    'height',\n    'id',\n    'mask',\n    'opacity',\n    'overflow',\n    'rotate',\n    'stop-color',\n    'stop-opacity',\n    'style',\n    'transform',\n    'transform-origin',\n    'viewBox',\n    'width',\n    'x',\n    'y',\n    'dx',\n    'dy',\n    '{http://www.w3.org/1999/xlink}href',\n    'href',\n))\n\nCOLOR_ATTRIBUTES = frozenset((\n    'fill',\n    'flood-color',\n    'lighting-color',\n    'stop-color',\n    'stroke',\n))\n\n\ndef handle_white_spaces(string, preserve):\n    \"\"\"Handle white spaces in text nodes.\n\n    See http://www.w3.org/TR/SVG/text.html#WhiteSpace\n\n    \"\"\"\n    if not string:\n        return ''\n    if preserve:\n        return re.sub('[\\n\\r\\t]', ' ', string)\n    else:\n        string = re.sub('[\\n\\r]', '', string)\n        string = re.sub('\\t', ' ', string)\n        return re.sub(' +', ' ', string)\n\n\ndef normalize_style_declaration(name, value):\n    \"\"\"Normalize style declaration consisting of name/value pair.\n\n    Names are always case insensitive, make all lowercase.\n    Values are case insensitive in most cases. Adapt for 'specials':\n        id - case sensitive identifier\n        class - case sensitive identifier(s)\n        font-family - case sensitive name(s)\n        font - shorthand in which font-family is case sensitive\n        any declaration with url in value - url is case sensitive\n\n    \"\"\"\n    name = name.strip().lower()\n    value = value.strip()\n    if name in CASE_SENSITIVE_STYLE_METHODS:\n        value = CASE_SENSITIVE_STYLE_METHODS[name](value)\n    else:\n        value = value.lower()\n\n    return name, value\n\n\ndef normalize_noop_style_declaration(value):\n    \"\"\"No-operation for normalization where value is case sensitive.\n\n    This is actually the exception to the rule. Normally value will be made\n    lowercase (see normalize_style_declaration above).\n\n    \"\"\"\n    return value\n\n\ndef normalize_url_style_declaration(value):\n    \"\"\"Normalize style declaration, but keep URL's as-is.\n\n    Lowercase everything except for the URL.\n\n    \"\"\"\n    regex_style = re.compile(r\"\"\"\n        (.*?)                               # non-URL part (will be normalized)\n        (?:\n            url\\(\\s*                        # url(<whitespace>\n                (?:\n                      \"(?:\\\\.|[^\"])*\"       # \"<url>\"\n                    | \\'(?:\\\\.|[^\\'])*\\'    # '<url>'\n                    | (?:\\\\.|[^\\)])*        # <url>\n                )\n            \\s*\\)                           # <whitespace>)\n            |$\n        )\n    \"\"\", re.IGNORECASE | re.VERBOSE)\n    for match in regex_style.finditer(value):\n        value_start = value[:match.start()] if match.start() > 0 else ''\n        normalized_value = match.group(1).lower()\n        value_end = value[match.start() + len(normalized_value):]\n        value = value_start + normalized_value + value_end\n    return value\n\n\ndef normalize_font_style_declaration(value):\n    \"\"\"Make first part of font style declaration lowercase (case insensitive).\n\n    Lowercase first part of declaration. Only the font name is case sensitive.\n    The font name is at the end of the declaration and can be 'recognized'\n    by being preceded by a size or line height. There can actually be multiple\n    names. So the first part is 'calculated' by selecting everything up to and\n    including the last valid token followed by a size or line height (both\n    starting with a number). A valid token is either a size/length or an\n    identifier.\n\n    See http://www.w3.org/TR/css-fonts-3/#font-prop\n\n    \"\"\"\n    return re.sub(r\"\"\"\n        ^(\n            (\\d[^\\s,]*|\\w[^\\s,]*)   # <size>, <length> or <identifier>\n            (\\s+|\\s*,\\s*)           # <whitespace> and/or comma\n        )*                          # Repeat until last\n        \\d[^\\s,]*                   # <size> or <line-height>\n    \"\"\", lambda match: match.group().lower(), value, 0, re.VERBOSE)\n\n\nclass Node(dict):\n    \"\"\"SVG node with dict-like properties and children.\"\"\"\n\n    def __init__(self, element, style, url_fetcher, parent=None,\n                 parent_children=False, url=None, unsafe=False):\n        \"\"\"Create the Node from ElementTree ``node``, with ``parent`` Node.\"\"\"\n        super().__init__()\n        self.children = ()\n\n        self.root = False\n\n        node = element.etree_element\n        self.element = element\n        self.style = style\n        self.tag = (\n            element.local_name\n            if element.namespace_url in ('', 'http://www.w3.org/2000/svg') else\n            '{%s}%s' % (element.namespace_url, element.local_name))\n        self.text = node.text\n        self.url_fetcher = url_fetcher\n        self.unsafe = unsafe\n\n        # Only set xml_tree if it's not been set before (ie. if node is a tree)\n        self.xml_tree = getattr(self, 'xml_tree', node)\n\n        # Inherits from parent properties\n        if parent is not None:\n            self.update([\n                (attribute, parent[attribute]) for attribute in parent\n                if attribute not in NOT_INHERITED_ATTRIBUTES])\n            self.url = url or parent.url\n            self.parent = parent\n        else:\n            self.url = getattr(self, 'url', None)\n            self.parent = getattr(self, 'parent', None)\n\n        self.update(self.xml_tree.attrib)\n\n        # Apply CSS rules\n        style_attr = node.get('style')\n        if style_attr:\n            normal_attr, important_attr = css.parse_declarations(style_attr)\n        else:\n            normal_attr = []\n            important_attr = []\n        normal_matcher, important_matcher = style\n        normal = [rule[-1] for rule in normal_matcher.match(element)]\n        important = [rule[-1] for rule in important_matcher.match(element)]\n        for declaration_lists in (\n                normal, [normal_attr], important, [important_attr]):\n            for declarations in declaration_lists:\n                for name, value in declarations:\n                    self[name] = value.strip()\n\n        # Replace currentColor by a real color value\n        for attribute in COLOR_ATTRIBUTES:\n            if self.get(attribute) == 'currentColor':\n                self[attribute] = self.get('color', 'black')\n\n        # Replace inherit by the parent value\n        for attribute in [\n                attribute for attribute in self\n                if self[attribute] == 'inherit']:\n            if parent is not None and attribute in parent:\n                self[attribute] = parent.get(attribute)\n            else:\n                del self[attribute]\n\n        # Manage text by creating children\n        if self.tag in ('text', 'textPath', 'a'):\n            self.children, _ = self.text_children(\n                element, trailing_space=True, text_root=True)\n\n        if parent_children:\n            self.children = [\n                Node(child.element, style, self.url_fetcher, parent=self,\n                     unsafe=self.unsafe)\n                for child in parent.children]\n        elif not self.children:\n            self.children = []\n            for child in element.iter_children():\n                if match_features(child.etree_element):\n                    self.children.append(\n                        Node(child, style, self.url_fetcher, parent=self,\n                             unsafe=self.unsafe))\n                    if self.tag == 'switch':\n                        break\n\n    def fetch_url(self, url, resource_type):\n        return read_url(url, self.url_fetcher, resource_type)\n\n    def text_children(self, element, trailing_space, text_root=False):\n        \"\"\"Create children and return them.\"\"\"\n        children = []\n        space = '{http://www.w3.org/XML/1998/namespace}space'\n        preserve = self.get(space) == 'preserve'\n        self.text = handle_white_spaces(element.etree_element.text, preserve)\n        if trailing_space and not preserve:\n            self.text = self.text.lstrip(' ')\n        original_rotate = rotations(self)\n        rotate = list(original_rotate)\n        if original_rotate:\n            pop_rotation(self, original_rotate, rotate)\n        if self.text:\n            trailing_space = self.text.endswith(' ')\n        for child_element in element.iter_children():\n            child = child_element.etree_element\n            if child.tag in ('{http://www.w3.org/2000/svg}tref', 'tref'):\n                href = child.get(\n                    '{http://www.w3.org/1999/xlink}href', child.get('href'))\n                url = parse_url(href).geturl()\n                child_tree = Tree(\n                    url=url, url_fetcher=self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n                child_tree.clear()\n                child_tree.update(self)\n                child_node = Node(\n                    child_element, self.style, self.url_fetcher,\n                    parent=child_tree, parent_children=True,\n                    unsafe=self.unsafe)\n                child_node.tag = 'tspan'\n                # Retrieve the referenced node and get its flattened text\n                # and remove the node children.\n                child = child_tree.xml_tree\n                child.text = flatten(child)\n                child_element = cssselect2.ElementWrapper.from_xml_root(child)\n            else:\n                child_node = Node(\n                    child_element, self.style, self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n            child_preserve = child_node.get(space) == 'preserve'\n            child_node.text = handle_white_spaces(child.text, child_preserve)\n            child_node.children, trailing_space = child_node.text_children(\n                child_element, trailing_space)\n            trailing_space = child_node.text.endswith(' ')\n            if original_rotate and 'rotate' not in child_node:\n                pop_rotation(child_node, original_rotate, rotate)\n            children.append(child_node)\n            if child.tail:\n                anonymous_etree = Element('{http://www.w3.org/2000/svg}tspan')\n                anonymous = Node(\n                    cssselect2.ElementWrapper.from_xml_root(anonymous_etree),\n                    self.style, self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n                anonymous.text = handle_white_spaces(child.tail, preserve)\n                if original_rotate:\n                    pop_rotation(anonymous, original_rotate, rotate)\n                if trailing_space and not preserve:\n                    anonymous.text = anonymous.text.lstrip(' ')\n                if anonymous.text:\n                    trailing_space = anonymous.text.endswith(' ')\n                children.append(anonymous)\n\n        if text_root and not children and not preserve:\n            self.text = self.text.rstrip(' ')\n\n        return children, trailing_space\n\n    def get_href(self):\n        return self.get('{http://www.w3.org/1999/xlink}href', self.get('href'))\n\n\nclass Tree(Node):\n    \"\"\"SVG tree.\"\"\"\n    def __new__(cls, **kwargs):\n        tree_cache = kwargs.get('tree_cache')\n        if tree_cache and kwargs.get('url'):\n            parsed_url = parse_url(kwargs['url'])\n            element_id = parsed_url.fragment\n            parent = kwargs.get('parent')\n            unsafe = kwargs.get('unsafe')\n            if any(parsed_url[:-1]):\n                url = urlunparse(parsed_url[:-1] + ('',))\n            elif parent:\n                url = parent.url\n            else:\n                url = None\n            if url and (url, element_id) in tree_cache:\n                cached_tree = tree_cache[(url, element_id)]\n                new_tree = Node(\n                    cached_tree.element, cached_tree.style,\n                    cached_tree.url_fetcher, parent, unsafe=unsafe)\n                new_tree.xml_tree = cached_tree.xml_tree\n                new_tree.url = url\n                new_tree.tag = cached_tree.tag\n                new_tree.root = True\n                return new_tree\n        return super().__new__(cls)\n\n    def __init__(self, **kwargs):\n        \"\"\"Create the Tree from SVG ``text``.\"\"\"\n        bytestring = kwargs.get('bytestring')\n        file_obj = kwargs.get('file_obj')\n        url = kwargs.get('url')\n        unsafe = kwargs.get('unsafe')\n        parent = kwargs.get('parent')\n        parent_children = kwargs.get('parent_children')\n        tree_cache = kwargs.get('tree_cache')\n        element_id = None\n\n        self.url_fetcher = kwargs.get('url_fetcher', fetch)\n\n        if bytestring is not None:\n            self.url = url\n        elif file_obj is not None:\n            bytestring = file_obj.read()\n            self.url = getattr(file_obj, 'name', None)\n            if self.url == '<stdin>':\n                self.url = None\n        elif url is not None:\n            parent_url = parent.url if parent else None\n            parsed_url = parse_url(url, parent_url)\n            if parsed_url.fragment:\n                self.url = urlunparse(parsed_url[:-1] + ('',))\n                element_id = parsed_url.fragment\n            else:\n                self.url = parsed_url.geturl()\n                element_id = None\n            self.url = self.url or None\n        else:\n            raise TypeError(\n                'No input. Use one of bytestring, file_obj or url.')\n        self_is_parent = (\n            (parent and self.url == parent.url) or\n            (url and url.startswith('#') and not self.url))\n        if self_is_parent:\n            root_parent = parent\n            while root_parent.parent is not None:\n                root_parent = root_parent.parent\n            tree = root_parent.xml_tree\n        else:\n            if not bytestring:\n                bytestring = self.fetch_url(\n                    parse_url(self.url), 'image/svg+xml')\n            if len(bytestring) >= 2 and bytestring[:2] == b'\\x1f\\x8b':\n                bytestring = gzip.decompress(bytestring)\n            tree = ElementTree.fromstring(\n                bytestring, forbid_entities=not unsafe,\n                forbid_external=not unsafe)\n        self.xml_tree = tree\n        root = cssselect2.ElementWrapper.from_xml_root(tree)\n        style = parent.style if parent else css.parse_stylesheets(self, url)\n        if element_id:\n            for element in root.iter_subtree():\n                if element.id == element_id:\n                    root = element\n                    self.xml_tree = element.etree_element\n                    break\n            else:\n                raise TypeError(\n                    'No tag with id=\"{}\" found.'.format(element_id))\n        super().__init__(\n            root, style, self.url_fetcher, parent, parent_children, self.url,\n            unsafe)\n        self.root = True\n        if tree_cache is not None and self.url:\n            tree_cache[(self.url, self.get('id'))] = self\n\n\nCASE_SENSITIVE_STYLE_METHODS = {\n    'id': normalize_noop_style_declaration,\n    'class': normalize_noop_style_declaration,\n    'font-family': normalize_noop_style_declaration,\n    'font': normalize_font_style_declaration,\n    'clip-path': normalize_url_style_declaration,\n    'color-profile': normalize_url_style_declaration,\n    'cursor': normalize_url_style_declaration,\n    'fill': normalize_url_style_declaration,\n    'filter': normalize_url_style_declaration,\n    'marker-start': normalize_url_style_declaration,\n    'marker-mid': normalize_url_style_declaration,\n    'marker-end': normalize_url_style_declaration,\n    'mask': normalize_url_style_declaration,\n    'stroke': normalize_url_style_declaration,\n}\n", "\"\"\"\nCairo surface creators.\n\n\"\"\"\n\nimport copy\nimport io\n\nimport cairocffi as cairo\n\nfrom .colors import color, negate_color\nfrom .defs import (\n    apply_filter_after_painting, apply_filter_before_painting, clip_path,\n    filter_, gradient_or_pattern, linear_gradient, marker, mask, paint_mask,\n    parse_all_defs, pattern, prepare_filter, radial_gradient, use)\nfrom .helpers import (\n    UNITS, PointError, clip_rect, node_format, normalize, paint,\n    preserve_ratio, size, transform)\nfrom .image import image, invert_image\nfrom .parser import Tree\nfrom .path import draw_markers, path\nfrom .shapes import circle, ellipse, line, polygon, polyline, rect\nfrom .svg import svg\nfrom .text import text\nfrom .url import parse_url\n\nSHAPE_ANTIALIAS = {\n    'optimizeSpeed': cairo.ANTIALIAS_FAST,\n    'crispEdges': cairo.ANTIALIAS_NONE,\n    'geometricPrecision': cairo.ANTIALIAS_BEST,\n}\n\nTEXT_ANTIALIAS = {\n    'crispEdges': cairo.ANTIALIAS_NONE,\n    'optimizeSpeed': cairo.ANTIALIAS_FAST,\n    'optimizeLegibility': cairo.ANTIALIAS_GOOD,\n    'geometricPrecision': cairo.ANTIALIAS_BEST,\n}\n\nTEXT_HINT_STYLE = {\n    'geometricPrecision': cairo.HINT_STYLE_NONE,\n    'optimizeLegibility': cairo.HINT_STYLE_FULL,\n}\n\nTEXT_HINT_METRICS = {\n    'geometricPrecision': cairo.HINT_METRICS_OFF,\n    'optimizeLegibility': cairo.HINT_METRICS_ON,\n}\n\nTAGS = {\n    'a': text,\n    'circle': circle,\n    'clipPath': clip_path,\n    'ellipse': ellipse,\n    'filter': filter_,\n    'image': image,\n    'line': line,\n    'linearGradient': linear_gradient,\n    'marker': marker,\n    'mask': mask,\n    'path': path,\n    'pattern': pattern,\n    'polyline': polyline,\n    'polygon': polygon,\n    'radialGradient': radial_gradient,\n    'rect': rect,\n    'svg': svg,\n    'text': text,\n    'textPath': text,\n    'tspan': text,\n    'use': use,\n}\n\nPATH_TAGS = frozenset((\n    'circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'))\n\nINVISIBLE_TAGS = frozenset((\n    'clipPath', 'filter', 'linearGradient', 'marker', 'mask', 'pattern',\n    'radialGradient', 'symbol'))\n\n\nclass Surface(object):\n    \"\"\"Abstract base class for CairoSVG surfaces.\n\n    The ``width`` and ``height`` attributes are in device units (pixels for\n    PNG, else points).\n\n    The ``context_width`` and ``context_height`` attributes are in user units\n    (i.e. in pixels), they represent the size of the active viewport.\n\n    \"\"\"\n\n    # Subclasses must either define this or override _create_surface()\n    surface_class = None\n\n    @classmethod\n    def convert(cls, bytestring=None, *, file_obj=None, url=None, dpi=96,\n                parent_width=None, parent_height=None, scale=1, unsafe=False,\n                background_color=None, negate_colors=False,\n                invert_images=False, write_to=None, output_width=None,\n                output_height=None, **kwargs):\n        \"\"\"Convert an SVG document to the format for this class.\n\n        Specify the input by passing one of these:\n\n        :param bytestring: The SVG source as a byte-string.\n        :param file_obj: A file-like object.\n        :param url: A filename.\n\n        Give some options:\n\n        :param dpi: The ratio between 1 inch and 1 pixel.\n        :param parent_width: The width of the parent container in pixels.\n        :param parent_height: The height of the parent container in pixels.\n        :param scale: The ouptut scaling factor.\n        :param unsafe: A boolean allowing XML entities and very large files\n                       (WARNING: vulnerable to XXE attacks and various DoS).\n\n        Specifiy the output with:\n\n        :param write_to: The filename of file-like object where to write the\n                         output. If None or not provided, return a byte string.\n\n        Only ``bytestring`` can be passed as a positional argument, other\n        parameters are keyword-only.\n\n        \"\"\"\n        tree = Tree(\n            bytestring=bytestring, file_obj=file_obj, url=url, unsafe=unsafe,\n            **kwargs)\n        output = write_to or io.BytesIO()\n        instance = cls(\n            tree, output, dpi, None, parent_width, parent_height, scale,\n            output_width, output_height, background_color,\n            map_rgba=negate_color if negate_colors else None,\n            map_image=invert_image if invert_images else None)\n        instance.finish()\n        if write_to is None:\n            return output.getvalue()\n\n    def __init__(self, tree, output, dpi, parent_surface=None,\n                 parent_width=None, parent_height=None,\n                 scale=1, output_width=None, output_height=None,\n                 background_color=None, map_rgba=None, map_image=None):\n        \"\"\"Create the surface from a filename or a file-like object.\n\n        The rendered content is written to ``output`` which can be a filename,\n        a file-like object, ``None`` (render in memory but do not write\n        anything) or the built-in ``bytes`` as a marker.\n\n        Call the ``.finish()`` method to make sure that the output is\n        actually written.\n\n        \"\"\"\n        self.cairo = None\n        self.context_width, self.context_height = parent_width, parent_height\n        self.cursor_position = [0, 0]\n        self.cursor_d_position = [0, 0]\n        self.text_path_width = 0\n        self.tree_cache = {(tree.url, tree.get('id')): tree}\n        if parent_surface:\n            self.markers = parent_surface.markers\n            self.gradients = parent_surface.gradients\n            self.patterns = parent_surface.patterns\n            self.masks = parent_surface.masks\n            self.paths = parent_surface.paths\n            self.filters = parent_surface.filters\n            self.images = parent_surface.images\n        else:\n            self.markers = {}\n            self.gradients = {}\n            self.patterns = {}\n            self.masks = {}\n            self.paths = {}\n            self.filters = {}\n            self.images = {}\n        self._old_parent_node = self.parent_node = None\n        self.output = output\n        self.dpi = dpi\n        self.font_size = size(self, '12pt')\n        self.stroke_and_fill = True\n        width, height, viewbox = node_format(self, tree)\n        if viewbox is None:\n            viewbox = (0, 0, width, height)\n\n        if output_width and output_height:\n            width, height = output_width, output_height\n        elif output_width:\n            if width:\n                # Keep the aspect ratio\n                height *= output_width / width\n            width = output_width\n        elif output_height:\n            if height:\n                # Keep the aspect ratio\n                width *= output_height / height\n            height = output_height\n        else:\n            width *= scale\n            height *= scale\n\n        # Actual surface dimensions: may be rounded on raster surfaces types\n        self.cairo, self.width, self.height = self._create_surface(\n            width * self.device_units_per_user_units,\n            height * self.device_units_per_user_units)\n\n        if 0 in (self.width, self.height):\n            raise ValueError('The SVG size is undefined')\n\n        self.context = cairo.Context(self.cairo)\n        # We must scale the context as the surface size is using physical units\n        self.context.scale(\n            self.device_units_per_user_units, self.device_units_per_user_units)\n        # Initial, non-rounded dimensions\n        self.set_context_size(width, height, viewbox, tree)\n        self.context.move_to(0, 0)\n\n        if background_color:\n            self.context.set_source_rgba(*color(background_color))\n            self.context.paint()\n\n        self.map_rgba = map_rgba\n        self.map_image = map_image\n        self.draw(tree)\n\n    @property\n    def points_per_pixel(self):\n        \"\"\"Surface resolution.\"\"\"\n        return 1 / (self.dpi * UNITS['pt'])\n\n    @property\n    def device_units_per_user_units(self):\n        \"\"\"Ratio between Cairo device units and user units.\n\n        Device units are points for everything but PNG, and pixels for\n        PNG. User units are pixels.\n\n        \"\"\"\n        return self.points_per_pixel\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        cairo_surface = self.surface_class(self.output, width, height)\n        return cairo_surface, width, height\n\n    def set_context_size(self, width, height, viewbox, tree):\n        \"\"\"Set the Cairo context size, set the SVG viewport size.\"\"\"\n        if viewbox:\n            rect_x, rect_y = viewbox[0:2]\n            tree.image_width = viewbox[2]\n            tree.image_height = viewbox[3]\n        else:\n            rect_x, rect_y = 0, 0\n            tree.image_width = width\n            tree.image_height = height\n\n        scale_x, scale_y, translate_x, translate_y = preserve_ratio(\n            self, tree, width, height)\n        rect_x, rect_y = rect_x * scale_x, rect_y * scale_y\n        rect_width, rect_height = width, height\n        self.context.translate(*self.context.get_current_point())\n        self.context.translate(-rect_x, -rect_y)\n        if tree.get('overflow', 'hidden') != 'visible':\n            self.context.rectangle(rect_x, rect_y, rect_width, rect_height)\n            self.context.clip()\n        self.context.scale(scale_x, scale_y)\n        self.context.translate(translate_x, translate_y)\n        self.context_width = rect_width / scale_x\n        self.context_height = rect_height / scale_y\n\n    def finish(self):\n        \"\"\"Read the surface content.\"\"\"\n        self.cairo.finish()\n\n    def map_color(self, string, opacity=1):\n        \"\"\"Parse a color ``string`` and apply ``map_rgba`` function to it.\"\"\"\n        rgba = color(string, opacity)\n        return self.map_rgba(rgba) if self.map_rgba else rgba\n\n    def draw(self, node):\n        \"\"\"Draw ``node`` and its children.\"\"\"\n\n        # Parse definitions first\n        if node.tag == 'svg':\n            parse_all_defs(self, node)\n\n        # Do not draw defs\n        if node.tag == 'defs':\n            return\n\n        # Do not draw elements with width or height of 0\n        if (('width' in node and size(self, node['width']) == 0) or\n                ('height' in node and size(self, node['height']) == 0)):\n            return\n\n        # Save context and related attributes\n        old_parent_node = self.parent_node\n        old_font_size = self.font_size\n        old_context_size = self.context_width, self.context_height\n        self.parent_node = node\n\n        if \"font\" in node:\n            font = parse_font(node[\"font\"])\n            for att in font:\n                if att not in node:\n                    node[att] = font[att]\n\n        self.font_size = size(self, node.get('font-size', '12pt'))\n        self.context.save()\n\n        # Apply transformations\n        transform(\n            self, node.get('transform'),\n            transform_origin=node.get('transform-origin'))\n\n        # Find and prepare opacity, masks and filters\n        mask = parse_url(node.get('mask')).fragment\n        filter_ = parse_url(node.get('filter')).fragment\n        opacity = float(node.get('opacity', 1))\n\n        if filter_:\n            prepare_filter(self, node, filter_)\n\n        if filter_ or mask or (opacity < 1 and node.children):\n            self.context.push_group()\n\n        # Move to (node.x, node.y)\n        self.context.move_to(\n            size(self, node.get('x'), 'x'),\n            size(self, node.get('y'), 'y'))\n\n        # Set node's drawing informations if the ``node.tag`` method exists\n        line_cap = node.get('stroke-linecap')\n        if line_cap == 'square':\n            self.context.set_line_cap(cairo.LINE_CAP_SQUARE)\n        if line_cap == 'round':\n            self.context.set_line_cap(cairo.LINE_CAP_ROUND)\n\n        join_cap = node.get('stroke-linejoin')\n        if join_cap == 'round':\n            self.context.set_line_join(cairo.LINE_JOIN_ROUND)\n        if join_cap == 'bevel':\n            self.context.set_line_join(cairo.LINE_JOIN_BEVEL)\n\n        dash_array = normalize(node.get('stroke-dasharray', '')).split()\n        if dash_array:\n            dashes = [size(self, dash) for dash in dash_array]\n            if sum(dashes):\n                offset = size(self, node.get('stroke-dashoffset'))\n                self.context.set_dash(dashes, offset)\n\n        miter_limit = float(node.get('stroke-miterlimit', 4))\n        self.context.set_miter_limit(miter_limit)\n\n        # Clip\n        rect_values = clip_rect(node.get('clip'))\n        if len(rect_values) == 4:\n            top = size(self, rect_values[0], 'y')\n            right = size(self, rect_values[1], 'x')\n            bottom = size(self, rect_values[2], 'y')\n            left = size(self, rect_values[3], 'x')\n            x = size(self, node.get('x'), 'x')\n            y = size(self, node.get('y'), 'y')\n            width = size(self, node.get('width'), 'x')\n            height = size(self, node.get('height'), 'y')\n            self.context.save()\n            self.context.translate(x, y)\n            self.context.rectangle(\n                left, top, width - left - right, height - top - bottom)\n            self.context.restore()\n            self.context.clip()\n        clip_path = parse_url(node.get('clip-path')).fragment\n        if clip_path:\n            path = self.paths.get(clip_path)\n            if path:\n                self.context.save()\n                if path.get('clipPathUnits') == 'objectBoundingBox':\n                    x = size(self, node.get('x'), 'x')\n                    y = size(self, node.get('y'), 'y')\n                    width = size(self, node.get('width'), 'x')\n                    height = size(self, node.get('height'), 'y')\n                    self.context.translate(x, y)\n                    self.context.scale(width, height)\n                path.tag = 'g'\n                self.stroke_and_fill = False\n                self.draw(path)\n                self.stroke_and_fill = True\n                self.context.restore()\n                # TODO: fill rules are not handled by cairo for clips\n                # if node.get('clip-rule') == 'evenodd':\n                #     self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n                self.context.clip()\n                self.context.set_fill_rule(cairo.FILL_RULE_WINDING)\n\n        save_cursor = copy.deepcopy(\n            (self.cursor_position, self.cursor_d_position,\n             self.text_path_width))\n\n        # Only draw known tags\n        if node.tag in TAGS:\n            try:\n                TAGS[node.tag](self, node)\n            except PointError:\n                # Error in point parsing, do nothing\n                pass\n\n        # Get stroke and fill opacity\n        stroke_opacity = float(node.get('stroke-opacity', 1))\n        fill_opacity = float(node.get('fill-opacity', 1))\n        if opacity < 1 and not node.children:\n            stroke_opacity *= opacity\n            fill_opacity *= opacity\n\n        # Manage display and visibility\n        display = node.get('display', 'inline') != 'none'\n        visible = display and (node.get('visibility', 'visible') != 'hidden')\n\n        # Set font rendering properties\n        self.context.set_antialias(SHAPE_ANTIALIAS.get(\n            node.get('shape-rendering'), cairo.ANTIALIAS_DEFAULT))\n\n        font_options = self.context.get_font_options()\n        font_options.set_antialias(TEXT_ANTIALIAS.get(\n            node.get('text-rendering'), cairo.ANTIALIAS_DEFAULT))\n        font_options.set_hint_style(TEXT_HINT_STYLE.get(\n            node.get('text-rendering'), cairo.HINT_STYLE_DEFAULT))\n        font_options.set_hint_metrics(TEXT_HINT_METRICS.get(\n            node.get('text-rendering'), cairo.HINT_METRICS_DEFAULT))\n        self.context.set_font_options(font_options)\n\n        # Fill and stroke\n        if self.stroke_and_fill and visible and node.tag in TAGS:\n            # Fill\n            self.context.save()\n            paint_source, paint_color = paint(node.get('fill', 'black'))\n            if not gradient_or_pattern(self, node, paint_source, fill_opacity):\n                if node.get('fill-rule') == 'evenodd':\n                    self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n                self.context.set_source_rgba(\n                    *self.map_color(paint_color, fill_opacity))\n            if TAGS[node.tag] == text:\n                self.cursor_position = save_cursor[0]\n                self.cursor_d_position = save_cursor[1]\n                self.text_path_width = save_cursor[2]\n                text(self, node, draw_as_text=True)\n            else:\n                self.context.fill_preserve()\n            self.context.restore()\n\n            # Stroke\n            self.context.save()\n            self.context.set_line_width(\n                size(self, node.get('stroke-width', '1')))\n            paint_source, paint_color = paint(node.get('stroke'))\n            if not gradient_or_pattern(\n                    self, node, paint_source, stroke_opacity):\n                self.context.set_source_rgba(\n                    *self.map_color(paint_color, stroke_opacity))\n            self.context.stroke()\n            self.context.restore()\n        elif not visible:\n            self.context.new_path()\n\n        # Draw path markers\n        draw_markers(self, node)\n\n        # Draw children\n        if display and node.tag not in INVISIBLE_TAGS:\n            for child in node.children:\n                self.draw(child)\n\n        # Apply filter, mask and opacity\n        if filter_ or mask or (opacity < 1 and node.children):\n            self.context.pop_group_to_source()\n            if filter_:\n                apply_filter_before_painting(self, node, filter_)\n            if mask in self.masks:\n                paint_mask(self, node, mask, opacity)\n            else:\n                self.context.paint_with_alpha(opacity)\n            if filter_:\n                apply_filter_after_painting(self, node, filter_)\n\n        # Clean cursor's position after 'text' tags\n        if node.tag == 'text':\n            self.cursor_position = [0, 0]\n            self.cursor_d_position = [0, 0]\n            self.text_path_width = 0\n\n        self.context.restore()\n        self.parent_node = old_parent_node\n        self.font_size = old_font_size\n        self.context_width, self.context_height = old_context_size\n\n\nclass PDFSurface(Surface):\n    \"\"\"A surface that writes in PDF format.\"\"\"\n    surface_class = cairo.PDFSurface\n\n\nclass PSSurface(Surface):\n    \"\"\"A surface that writes in PostScript format.\"\"\"\n    surface_class = cairo.PSSurface\n\n\nclass EPSSurface(Surface):\n    \"\"\"A surface that writes in Encapsulated PostScript format.\"\"\"\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        cairo_surface = cairo.PSSurface(self.output, width, height)\n        cairo_surface.set_eps(True)\n        return cairo_surface, width, height\n\n\nclass PNGSurface(Surface):\n    \"\"\"A surface that writes in PNG format.\"\"\"\n    device_units_per_user_units = 1\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        width = int(width)\n        height = int(height)\n        cairo_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        return cairo_surface, width, height\n\n    def finish(self):\n        \"\"\"Read the PNG surface content.\"\"\"\n        if self.output is not None:\n            self.cairo.write_to_png(self.output)\n        return super().finish()\n\n\nclass SVGSurface(Surface):\n    \"\"\"A surface that writes in SVG format.\n\n    It may seem pointless to render SVG to SVG, but this can be used\n    with ``output=None`` to get a vector-based single page cairo surface.\n\n    \"\"\"\n    surface_class = cairo.SVGSurface\n\n\ndef parse_font(value):\n    ret = {\"font-family\": \"\", \"font-size\": \"\", \"font-style\": \"normal\",\n           \"font-variant\": \"normal\", \"font-weight\": \"normal\",\n           \"line-height\": \"normal\"}\n\n    font_styles = [\"italic\", \"oblique\"]\n    font_variants = [\"small-caps\"]\n    font_weights = [\"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\",\n                    \"500\", \"600\", \"700\", \"800\", \"900\"]\n\n    for element in value.split():\n        if element == \"normal\":\n            continue\n        elif ret[\"font-family\"]:\n            ret[\"font-family\"] += \" \" + element\n        elif element in font_styles:\n            ret[\"font-style\"] = element\n        elif element in font_variants:\n            ret[\"font-variant\"] = element\n        elif element in font_weights:\n            ret[\"font-weight\"] = element\n        else:\n            if not ret[\"font-size\"]:\n                parts = element.split(\"/\")\n                ret[\"font-size\"] = parts[0]\n                if len(parts) > 1:\n                    ret[\"line-height\"] = parts[1]\n                continue\n            else:\n                ret[\"font-family\"] = element\n\n    return ret\n"], "fixing_code": ["\"\"\"\nCommand-line interface to CairoSVG.\n\n\"\"\"\n\nimport argparse\nimport os\nimport sys\n\nfrom . import SURFACES, VERSION\n\n\ndef main(argv=None, stdout=None, stdin=None):\n    \"\"\"Entry-point of the executable.\"\"\"\n    # Get command-line options\n    parser = argparse.ArgumentParser(\n        description='Convert SVG files to other formats')\n    parser.add_argument('input', default='-', help='input filename or URL')\n    parser.add_argument(\n        '-v', '--version', action='version', version=VERSION)\n    parser.add_argument(\n        '-f', '--format', help='output format',\n        choices=sorted([surface.lower() for surface in SURFACES]))\n    parser.add_argument(\n        '-d', '--dpi', default=96, type=float,\n        help='ratio between 1 inch and 1 pixel')\n    parser.add_argument(\n        '-W', '--width', default=None, type=float,\n        help='width of the parent container in pixels')\n    parser.add_argument(\n        '-H', '--height', default=None, type=float,\n        help='height of the parent container in pixels')\n    parser.add_argument(\n        '-s', '--scale', default=1, type=float, help='output scaling factor')\n    parser.add_argument(\n        '-b', '--background', metavar='COLOR', help='output background color')\n    parser.add_argument(\n        '-n', '--negate-colors', action='store_true',\n        help='replace every vector color with its complement')\n    parser.add_argument(\n        '-i', '--invert-images', action='store_true',\n        help='replace every raster pixel with its complementary color')\n    parser.add_argument(\n        '-u', '--unsafe', action='store_true',\n        help='fetch external files, resolve XML entities and allow very large '\n             'files (WARNING: vulnerable to XXE attacks and various DoS)')\n    parser.add_argument(\n        '--output-width', default=None, type=float,\n        help='desired output width in pixels')\n    parser.add_argument(\n        '--output-height', default=None, type=float,\n        help='desired output height in pixels')\n\n    parser.add_argument('-o', '--output', default='-', help='output filename')\n\n    options = parser.parse_args(argv)\n    kwargs = {\n        'parent_width': options.width, 'parent_height': options.height,\n        'dpi': options.dpi, 'scale': options.scale, 'unsafe': options.unsafe,\n        'background_color': options.background,\n        'negate_colors': options.negate_colors,\n        'invert_images': options.invert_images,\n        'output_width': options.output_width,\n        'output_height': options.output_height}\n    stdin = stdin or sys.stdin\n    stdout = stdout or sys.stdout\n    kwargs['write_to'] = (\n        stdout.buffer if options.output == '-' else options.output)\n    if options.input == '-':\n        kwargs['file_obj'] = stdin.buffer\n    else:\n        kwargs['url'] = options.input\n    output_format = (\n        options.format or\n        os.path.splitext(options.output)[1].lstrip('.') or\n        'pdf').upper()\n\n    SURFACES[output_format.upper()].convert(**kwargs)\n\n\nif __name__ == '__main__':  # pragma: no cover\n    main()\n", "\"\"\"\nSVG Parser.\n\n\"\"\"\n\nimport gzip\nimport re\nfrom urllib.parse import urlunparse\nfrom xml.etree.ElementTree import Element\n\nimport cssselect2\nfrom defusedxml import ElementTree\n\nfrom . import css\nfrom .features import match_features\nfrom .helpers import flatten, pop_rotation, rotations\nfrom .url import fetch, parse_url, read_url\n\n# 'display' is actually inherited but handled differently because some markers\n# are part of a none-displaying group (see test painting-marker-07-f.svg)\nNOT_INHERITED_ATTRIBUTES = frozenset((\n    'clip',\n    'clip-path',\n    'display',\n    'filter',\n    'height',\n    'id',\n    'mask',\n    'opacity',\n    'overflow',\n    'rotate',\n    'stop-color',\n    'stop-opacity',\n    'style',\n    'transform',\n    'transform-origin',\n    'viewBox',\n    'width',\n    'x',\n    'y',\n    'dx',\n    'dy',\n    '{http://www.w3.org/1999/xlink}href',\n    'href',\n))\n\nCOLOR_ATTRIBUTES = frozenset((\n    'fill',\n    'flood-color',\n    'lighting-color',\n    'stop-color',\n    'stroke',\n))\n\n\ndef handle_white_spaces(string, preserve):\n    \"\"\"Handle white spaces in text nodes.\n\n    See http://www.w3.org/TR/SVG/text.html#WhiteSpace\n\n    \"\"\"\n    if not string:\n        return ''\n    if preserve:\n        return re.sub('[\\n\\r\\t]', ' ', string)\n    else:\n        string = re.sub('[\\n\\r]', '', string)\n        string = re.sub('\\t', ' ', string)\n        return re.sub(' +', ' ', string)\n\n\ndef normalize_style_declaration(name, value):\n    \"\"\"Normalize style declaration consisting of name/value pair.\n\n    Names are always case insensitive, make all lowercase.\n    Values are case insensitive in most cases. Adapt for 'specials':\n        id - case sensitive identifier\n        class - case sensitive identifier(s)\n        font-family - case sensitive name(s)\n        font - shorthand in which font-family is case sensitive\n        any declaration with url in value - url is case sensitive\n\n    \"\"\"\n    name = name.strip().lower()\n    value = value.strip()\n    if name in CASE_SENSITIVE_STYLE_METHODS:\n        value = CASE_SENSITIVE_STYLE_METHODS[name](value)\n    else:\n        value = value.lower()\n\n    return name, value\n\n\ndef normalize_noop_style_declaration(value):\n    \"\"\"No-operation for normalization where value is case sensitive.\n\n    This is actually the exception to the rule. Normally value will be made\n    lowercase (see normalize_style_declaration above).\n\n    \"\"\"\n    return value\n\n\ndef normalize_url_style_declaration(value):\n    \"\"\"Normalize style declaration, but keep URL's as-is.\n\n    Lowercase everything except for the URL.\n\n    \"\"\"\n    regex_style = re.compile(r\"\"\"\n        (.*?)                               # non-URL part (will be normalized)\n        (?:\n            url\\(\\s*                        # url(<whitespace>\n                (?:\n                      \"(?:\\\\.|[^\"])*\"       # \"<url>\"\n                    | \\'(?:\\\\.|[^\\'])*\\'    # '<url>'\n                    | (?:\\\\.|[^\\)])*        # <url>\n                )\n            \\s*\\)                           # <whitespace>)\n            |$\n        )\n    \"\"\", re.IGNORECASE | re.VERBOSE)\n    for match in regex_style.finditer(value):\n        value_start = value[:match.start()] if match.start() > 0 else ''\n        normalized_value = match.group(1).lower()\n        value_end = value[match.start() + len(normalized_value):]\n        value = value_start + normalized_value + value_end\n    return value\n\n\ndef normalize_font_style_declaration(value):\n    \"\"\"Make first part of font style declaration lowercase (case insensitive).\n\n    Lowercase first part of declaration. Only the font name is case sensitive.\n    The font name is at the end of the declaration and can be 'recognized'\n    by being preceded by a size or line height. There can actually be multiple\n    names. So the first part is 'calculated' by selecting everything up to and\n    including the last valid token followed by a size or line height (both\n    starting with a number). A valid token is either a size/length or an\n    identifier.\n\n    See http://www.w3.org/TR/css-fonts-3/#font-prop\n\n    \"\"\"\n    return re.sub(r\"\"\"\n        ^(\n            (\\d[^\\s,]*|\\w[^\\s,]*)   # <size>, <length> or <identifier>\n            (\\s+|\\s*,\\s*)           # <whitespace> and/or comma\n        )*                          # Repeat until last\n        \\d[^\\s,]*                   # <size> or <line-height>\n    \"\"\", lambda match: match.group().lower(), value, 0, re.VERBOSE)\n\n\nclass Node(dict):\n    \"\"\"SVG node with dict-like properties and children.\"\"\"\n\n    def __init__(self, element, style, url_fetcher, parent=None,\n                 parent_children=False, url=None, unsafe=False):\n        \"\"\"Create the Node from ElementTree ``node``, with ``parent`` Node.\"\"\"\n        super().__init__()\n        self.children = ()\n\n        self.root = False\n\n        node = element.etree_element\n        self.element = element\n        self.style = style\n        self.tag = (\n            element.local_name\n            if element.namespace_url in ('', 'http://www.w3.org/2000/svg') else\n            '{%s}%s' % (element.namespace_url, element.local_name))\n        self.text = node.text\n        self.url_fetcher = url_fetcher\n        self.unsafe = unsafe\n\n        # Only set xml_tree if it's not been set before (ie. if node is a tree)\n        self.xml_tree = getattr(self, 'xml_tree', node)\n\n        # Inherits from parent properties\n        if parent is not None:\n            self.update([\n                (attribute, parent[attribute]) for attribute in parent\n                if attribute not in NOT_INHERITED_ATTRIBUTES])\n            self.url = url or parent.url\n            self.parent = parent\n        else:\n            self.url = getattr(self, 'url', None)\n            self.parent = getattr(self, 'parent', None)\n\n        self.update(self.xml_tree.attrib)\n\n        # Apply CSS rules\n        style_attr = node.get('style')\n        if style_attr:\n            normal_attr, important_attr = css.parse_declarations(style_attr)\n        else:\n            normal_attr = []\n            important_attr = []\n        normal_matcher, important_matcher = style\n        normal = [rule[-1] for rule in normal_matcher.match(element)]\n        important = [rule[-1] for rule in important_matcher.match(element)]\n        for declaration_lists in (\n                normal, [normal_attr], important, [important_attr]):\n            for declarations in declaration_lists:\n                for name, value in declarations:\n                    self[name] = value.strip()\n\n        # Replace currentColor by a real color value\n        for attribute in COLOR_ATTRIBUTES:\n            if self.get(attribute) == 'currentColor':\n                self[attribute] = self.get('color', 'black')\n\n        # Replace inherit by the parent value\n        for attribute in [\n                attribute for attribute in self\n                if self[attribute] == 'inherit']:\n            if parent is not None and attribute in parent:\n                self[attribute] = parent.get(attribute)\n            else:\n                del self[attribute]\n\n        # Manage text by creating children\n        if self.tag in ('text', 'textPath', 'a'):\n            self.children, _ = self.text_children(\n                element, trailing_space=True, text_root=True)\n\n        if parent_children:\n            self.children = [\n                Node(child.element, style, self.url_fetcher, parent=self,\n                     unsafe=self.unsafe)\n                for child in parent.children]\n        elif not self.children:\n            self.children = []\n            for child in element.iter_children():\n                if match_features(child.etree_element):\n                    self.children.append(\n                        Node(child, style, self.url_fetcher, parent=self,\n                             unsafe=self.unsafe))\n                    if self.tag == 'switch':\n                        break\n\n    def fetch_url(self, url, resource_type):\n        return read_url(url, self.url_fetcher, resource_type)\n\n    def text_children(self, element, trailing_space, text_root=False):\n        \"\"\"Create children and return them.\"\"\"\n        children = []\n        space = '{http://www.w3.org/XML/1998/namespace}space'\n        preserve = self.get(space) == 'preserve'\n        self.text = handle_white_spaces(element.etree_element.text, preserve)\n        if trailing_space and not preserve:\n            self.text = self.text.lstrip(' ')\n        original_rotate = rotations(self)\n        rotate = list(original_rotate)\n        if original_rotate:\n            pop_rotation(self, original_rotate, rotate)\n        if self.text:\n            trailing_space = self.text.endswith(' ')\n        for child_element in element.iter_children():\n            child = child_element.etree_element\n            if child.tag in ('{http://www.w3.org/2000/svg}tref', 'tref'):\n                href = child.get(\n                    '{http://www.w3.org/1999/xlink}href', child.get('href'))\n                url = parse_url(href).geturl()\n                child_tree = Tree(\n                    url=url, url_fetcher=self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n                child_tree.clear()\n                child_tree.update(self)\n                child_node = Node(\n                    child_element, self.style, self.url_fetcher,\n                    parent=child_tree, parent_children=True,\n                    unsafe=self.unsafe)\n                child_node.tag = 'tspan'\n                # Retrieve the referenced node and get its flattened text\n                # and remove the node children.\n                child = child_tree.xml_tree\n                child.text = flatten(child)\n                child_element = cssselect2.ElementWrapper.from_xml_root(child)\n            else:\n                child_node = Node(\n                    child_element, self.style, self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n            child_preserve = child_node.get(space) == 'preserve'\n            child_node.text = handle_white_spaces(child.text, child_preserve)\n            child_node.children, trailing_space = child_node.text_children(\n                child_element, trailing_space)\n            trailing_space = child_node.text.endswith(' ')\n            if original_rotate and 'rotate' not in child_node:\n                pop_rotation(child_node, original_rotate, rotate)\n            children.append(child_node)\n            if child.tail:\n                anonymous_etree = Element('{http://www.w3.org/2000/svg}tspan')\n                anonymous = Node(\n                    cssselect2.ElementWrapper.from_xml_root(anonymous_etree),\n                    self.style, self.url_fetcher, parent=self,\n                    unsafe=self.unsafe)\n                anonymous.text = handle_white_spaces(child.tail, preserve)\n                if original_rotate:\n                    pop_rotation(anonymous, original_rotate, rotate)\n                if trailing_space and not preserve:\n                    anonymous.text = anonymous.text.lstrip(' ')\n                if anonymous.text:\n                    trailing_space = anonymous.text.endswith(' ')\n                children.append(anonymous)\n\n        if text_root and not children and not preserve:\n            self.text = self.text.rstrip(' ')\n\n        return children, trailing_space\n\n    def get_href(self):\n        return self.get('{http://www.w3.org/1999/xlink}href', self.get('href'))\n\n\nclass Tree(Node):\n    \"\"\"SVG tree.\"\"\"\n    def __new__(cls, **kwargs):\n        tree_cache = kwargs.get('tree_cache')\n        if tree_cache and kwargs.get('url'):\n            parsed_url = parse_url(kwargs['url'])\n            element_id = parsed_url.fragment\n            parent = kwargs.get('parent')\n            unsafe = kwargs.get('unsafe')\n            if any(parsed_url[:-1]):\n                url = urlunparse(parsed_url[:-1] + ('',))\n            elif parent:\n                url = parent.url\n            else:\n                url = None\n            if url and (url, element_id) in tree_cache:\n                cached_tree = tree_cache[(url, element_id)]\n                new_tree = Node(\n                    cached_tree.element, cached_tree.style,\n                    cached_tree.url_fetcher, parent, unsafe=unsafe)\n                new_tree.xml_tree = cached_tree.xml_tree\n                new_tree.url = url\n                new_tree.tag = cached_tree.tag\n                new_tree.root = True\n                return new_tree\n        return super().__new__(cls)\n\n    def __init__(self, **kwargs):\n        \"\"\"Create the Tree from SVG ``text``.\"\"\"\n        bytestring = kwargs.get('bytestring')\n        file_obj = kwargs.get('file_obj')\n        url = kwargs.get('url')\n        unsafe = kwargs.get('unsafe')\n        parent = kwargs.get('parent')\n        parent_children = kwargs.get('parent_children')\n        tree_cache = kwargs.get('tree_cache')\n        element_id = None\n\n        self.url_fetcher = kwargs.get('url_fetcher', fetch)\n\n        if bytestring is not None:\n            self.url = url\n        elif file_obj is not None:\n            bytestring = file_obj.read()\n            self.url = getattr(file_obj, 'name', None)\n            if self.url == '<stdin>':\n                self.url = None\n        elif url is not None:\n            parent_url = parent.url if parent else None\n            parsed_url = parse_url(url, parent_url)\n            if parsed_url.fragment:\n                self.url = urlunparse(parsed_url[:-1] + ('',))\n                element_id = parsed_url.fragment\n            else:\n                self.url = parsed_url.geturl()\n                element_id = None\n            self.url = self.url or None\n        else:\n            raise TypeError(\n                'No input. Use one of bytestring, file_obj or url.')\n        self_is_parent = (\n            (parent and self.url == parent.url) or\n            (url and url.startswith('#') and not self.url))\n        if self_is_parent:\n            root_parent = parent\n            while root_parent.parent is not None:\n                root_parent = root_parent.parent\n            tree = root_parent.xml_tree\n        else:\n            if not bytestring:\n                bytestring = self.fetch_url(\n                    parse_url(self.url), 'image/svg+xml')\n            if len(bytestring) >= 2 and bytestring[:2] == b'\\x1f\\x8b':\n                bytestring = gzip.decompress(bytestring)\n            tree = ElementTree.fromstring(\n                bytestring, forbid_entities=not unsafe,\n                forbid_external=not unsafe)\n\n        # Don\u2019t allow fetching external files unless explicitly asked for\n        if 'url_fetcher' not in kwargs and not unsafe:\n            self.url_fetcher = (\n                lambda *args, **kwargs: b'<svg width=\"1\" height=\"1\"></svg>')\n\n        self.xml_tree = tree\n        root = cssselect2.ElementWrapper.from_xml_root(tree)\n        style = parent.style if parent else css.parse_stylesheets(self, url)\n        if element_id:\n            for element in root.iter_subtree():\n                if element.id == element_id:\n                    root = element\n                    self.xml_tree = element.etree_element\n                    break\n            else:\n                raise TypeError(\n                    'No tag with id=\"{}\" found.'.format(element_id))\n        super().__init__(\n            root, style, self.url_fetcher, parent, parent_children, self.url,\n            unsafe)\n        self.root = True\n        if tree_cache is not None and self.url:\n            tree_cache[(self.url, self.get('id'))] = self\n\n\nCASE_SENSITIVE_STYLE_METHODS = {\n    'id': normalize_noop_style_declaration,\n    'class': normalize_noop_style_declaration,\n    'font-family': normalize_noop_style_declaration,\n    'font': normalize_font_style_declaration,\n    'clip-path': normalize_url_style_declaration,\n    'color-profile': normalize_url_style_declaration,\n    'cursor': normalize_url_style_declaration,\n    'fill': normalize_url_style_declaration,\n    'filter': normalize_url_style_declaration,\n    'marker-start': normalize_url_style_declaration,\n    'marker-mid': normalize_url_style_declaration,\n    'marker-end': normalize_url_style_declaration,\n    'mask': normalize_url_style_declaration,\n    'stroke': normalize_url_style_declaration,\n}\n", "\"\"\"\nCairo surface creators.\n\n\"\"\"\n\nimport copy\nimport io\n\nimport cairocffi as cairo\n\nfrom .colors import color, negate_color\nfrom .defs import (\n    apply_filter_after_painting, apply_filter_before_painting, clip_path,\n    filter_, gradient_or_pattern, linear_gradient, marker, mask, paint_mask,\n    parse_all_defs, pattern, prepare_filter, radial_gradient, use)\nfrom .helpers import (\n    UNITS, PointError, clip_rect, node_format, normalize, paint,\n    preserve_ratio, size, transform)\nfrom .image import image, invert_image\nfrom .parser import Tree\nfrom .path import draw_markers, path\nfrom .shapes import circle, ellipse, line, polygon, polyline, rect\nfrom .svg import svg\nfrom .text import text\nfrom .url import parse_url\n\nSHAPE_ANTIALIAS = {\n    'optimizeSpeed': cairo.ANTIALIAS_FAST,\n    'crispEdges': cairo.ANTIALIAS_NONE,\n    'geometricPrecision': cairo.ANTIALIAS_BEST,\n}\n\nTEXT_ANTIALIAS = {\n    'crispEdges': cairo.ANTIALIAS_NONE,\n    'optimizeSpeed': cairo.ANTIALIAS_FAST,\n    'optimizeLegibility': cairo.ANTIALIAS_GOOD,\n    'geometricPrecision': cairo.ANTIALIAS_BEST,\n}\n\nTEXT_HINT_STYLE = {\n    'geometricPrecision': cairo.HINT_STYLE_NONE,\n    'optimizeLegibility': cairo.HINT_STYLE_FULL,\n}\n\nTEXT_HINT_METRICS = {\n    'geometricPrecision': cairo.HINT_METRICS_OFF,\n    'optimizeLegibility': cairo.HINT_METRICS_ON,\n}\n\nTAGS = {\n    'a': text,\n    'circle': circle,\n    'clipPath': clip_path,\n    'ellipse': ellipse,\n    'filter': filter_,\n    'image': image,\n    'line': line,\n    'linearGradient': linear_gradient,\n    'marker': marker,\n    'mask': mask,\n    'path': path,\n    'pattern': pattern,\n    'polyline': polyline,\n    'polygon': polygon,\n    'radialGradient': radial_gradient,\n    'rect': rect,\n    'svg': svg,\n    'text': text,\n    'textPath': text,\n    'tspan': text,\n    'use': use,\n}\n\nPATH_TAGS = frozenset((\n    'circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'))\n\nINVISIBLE_TAGS = frozenset((\n    'clipPath', 'filter', 'linearGradient', 'marker', 'mask', 'pattern',\n    'radialGradient', 'symbol'))\n\n\nclass Surface(object):\n    \"\"\"Abstract base class for CairoSVG surfaces.\n\n    The ``width`` and ``height`` attributes are in device units (pixels for\n    PNG, else points).\n\n    The ``context_width`` and ``context_height`` attributes are in user units\n    (i.e. in pixels), they represent the size of the active viewport.\n\n    \"\"\"\n\n    # Subclasses must either define this or override _create_surface()\n    surface_class = None\n\n    @classmethod\n    def convert(cls, bytestring=None, *, file_obj=None, url=None, dpi=96,\n                parent_width=None, parent_height=None, scale=1, unsafe=False,\n                background_color=None, negate_colors=False,\n                invert_images=False, write_to=None, output_width=None,\n                output_height=None, **kwargs):\n        \"\"\"Convert an SVG document to the format for this class.\n\n        Specify the input by passing one of these:\n\n        :param bytestring: The SVG source as a byte-string.\n        :param file_obj: A file-like object.\n        :param url: A filename.\n\n        Give some options:\n\n        :param dpi: The ratio between 1 inch and 1 pixel.\n        :param parent_width: The width of the parent container in pixels.\n        :param parent_height: The height of the parent container in pixels.\n        :param scale: The ouptut scaling factor.\n        :param unsafe: A boolean allowing external file access, XML entities\n                       and very large files\n                       (WARNING: vulnerable to XXE attacks and various DoS).\n\n        Specifiy the output with:\n\n        :param write_to: The filename of file-like object where to write the\n                         output. If None or not provided, return a byte string.\n\n        Only ``bytestring`` can be passed as a positional argument, other\n        parameters are keyword-only.\n\n        \"\"\"\n        tree = Tree(\n            bytestring=bytestring, file_obj=file_obj, url=url, unsafe=unsafe,\n            **kwargs)\n        output = write_to or io.BytesIO()\n        instance = cls(\n            tree, output, dpi, None, parent_width, parent_height, scale,\n            output_width, output_height, background_color,\n            map_rgba=negate_color if negate_colors else None,\n            map_image=invert_image if invert_images else None)\n        instance.finish()\n        if write_to is None:\n            return output.getvalue()\n\n    def __init__(self, tree, output, dpi, parent_surface=None,\n                 parent_width=None, parent_height=None,\n                 scale=1, output_width=None, output_height=None,\n                 background_color=None, map_rgba=None, map_image=None):\n        \"\"\"Create the surface from a filename or a file-like object.\n\n        The rendered content is written to ``output`` which can be a filename,\n        a file-like object, ``None`` (render in memory but do not write\n        anything) or the built-in ``bytes`` as a marker.\n\n        Call the ``.finish()`` method to make sure that the output is\n        actually written.\n\n        \"\"\"\n        self.cairo = None\n        self.context_width, self.context_height = parent_width, parent_height\n        self.cursor_position = [0, 0]\n        self.cursor_d_position = [0, 0]\n        self.text_path_width = 0\n        self.tree_cache = {(tree.url, tree.get('id')): tree}\n        if parent_surface:\n            self.markers = parent_surface.markers\n            self.gradients = parent_surface.gradients\n            self.patterns = parent_surface.patterns\n            self.masks = parent_surface.masks\n            self.paths = parent_surface.paths\n            self.filters = parent_surface.filters\n            self.images = parent_surface.images\n        else:\n            self.markers = {}\n            self.gradients = {}\n            self.patterns = {}\n            self.masks = {}\n            self.paths = {}\n            self.filters = {}\n            self.images = {}\n        self._old_parent_node = self.parent_node = None\n        self.output = output\n        self.dpi = dpi\n        self.font_size = size(self, '12pt')\n        self.stroke_and_fill = True\n        width, height, viewbox = node_format(self, tree)\n        if viewbox is None:\n            viewbox = (0, 0, width, height)\n\n        if output_width and output_height:\n            width, height = output_width, output_height\n        elif output_width:\n            if width:\n                # Keep the aspect ratio\n                height *= output_width / width\n            width = output_width\n        elif output_height:\n            if height:\n                # Keep the aspect ratio\n                width *= output_height / height\n            height = output_height\n        else:\n            width *= scale\n            height *= scale\n\n        # Actual surface dimensions: may be rounded on raster surfaces types\n        self.cairo, self.width, self.height = self._create_surface(\n            width * self.device_units_per_user_units,\n            height * self.device_units_per_user_units)\n\n        if 0 in (self.width, self.height):\n            raise ValueError('The SVG size is undefined')\n\n        self.context = cairo.Context(self.cairo)\n        # We must scale the context as the surface size is using physical units\n        self.context.scale(\n            self.device_units_per_user_units, self.device_units_per_user_units)\n        # Initial, non-rounded dimensions\n        self.set_context_size(width, height, viewbox, tree)\n        self.context.move_to(0, 0)\n\n        if background_color:\n            self.context.set_source_rgba(*color(background_color))\n            self.context.paint()\n\n        self.map_rgba = map_rgba\n        self.map_image = map_image\n        self.draw(tree)\n\n    @property\n    def points_per_pixel(self):\n        \"\"\"Surface resolution.\"\"\"\n        return 1 / (self.dpi * UNITS['pt'])\n\n    @property\n    def device_units_per_user_units(self):\n        \"\"\"Ratio between Cairo device units and user units.\n\n        Device units are points for everything but PNG, and pixels for\n        PNG. User units are pixels.\n\n        \"\"\"\n        return self.points_per_pixel\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        cairo_surface = self.surface_class(self.output, width, height)\n        return cairo_surface, width, height\n\n    def set_context_size(self, width, height, viewbox, tree):\n        \"\"\"Set the Cairo context size, set the SVG viewport size.\"\"\"\n        if viewbox:\n            rect_x, rect_y = viewbox[0:2]\n            tree.image_width = viewbox[2]\n            tree.image_height = viewbox[3]\n        else:\n            rect_x, rect_y = 0, 0\n            tree.image_width = width\n            tree.image_height = height\n\n        scale_x, scale_y, translate_x, translate_y = preserve_ratio(\n            self, tree, width, height)\n        rect_x, rect_y = rect_x * scale_x, rect_y * scale_y\n        rect_width, rect_height = width, height\n        self.context.translate(*self.context.get_current_point())\n        self.context.translate(-rect_x, -rect_y)\n        if tree.get('overflow', 'hidden') != 'visible':\n            self.context.rectangle(rect_x, rect_y, rect_width, rect_height)\n            self.context.clip()\n        self.context.scale(scale_x, scale_y)\n        self.context.translate(translate_x, translate_y)\n        self.context_width = rect_width / scale_x\n        self.context_height = rect_height / scale_y\n\n    def finish(self):\n        \"\"\"Read the surface content.\"\"\"\n        self.cairo.finish()\n\n    def map_color(self, string, opacity=1):\n        \"\"\"Parse a color ``string`` and apply ``map_rgba`` function to it.\"\"\"\n        rgba = color(string, opacity)\n        return self.map_rgba(rgba) if self.map_rgba else rgba\n\n    def draw(self, node):\n        \"\"\"Draw ``node`` and its children.\"\"\"\n\n        # Parse definitions first\n        if node.tag == 'svg':\n            parse_all_defs(self, node)\n\n        # Do not draw defs\n        if node.tag == 'defs':\n            return\n\n        # Do not draw elements with width or height of 0\n        if (('width' in node and size(self, node['width']) == 0) or\n                ('height' in node and size(self, node['height']) == 0)):\n            return\n\n        # Save context and related attributes\n        old_parent_node = self.parent_node\n        old_font_size = self.font_size\n        old_context_size = self.context_width, self.context_height\n        self.parent_node = node\n\n        if \"font\" in node:\n            font = parse_font(node[\"font\"])\n            for att in font:\n                if att not in node:\n                    node[att] = font[att]\n\n        self.font_size = size(self, node.get('font-size', '12pt'))\n        self.context.save()\n\n        # Apply transformations\n        transform(\n            self, node.get('transform'),\n            transform_origin=node.get('transform-origin'))\n\n        # Find and prepare opacity, masks and filters\n        mask = parse_url(node.get('mask')).fragment\n        filter_ = parse_url(node.get('filter')).fragment\n        opacity = float(node.get('opacity', 1))\n\n        if filter_:\n            prepare_filter(self, node, filter_)\n\n        if filter_ or mask or (opacity < 1 and node.children):\n            self.context.push_group()\n\n        # Move to (node.x, node.y)\n        self.context.move_to(\n            size(self, node.get('x'), 'x'),\n            size(self, node.get('y'), 'y'))\n\n        # Set node's drawing informations if the ``node.tag`` method exists\n        line_cap = node.get('stroke-linecap')\n        if line_cap == 'square':\n            self.context.set_line_cap(cairo.LINE_CAP_SQUARE)\n        if line_cap == 'round':\n            self.context.set_line_cap(cairo.LINE_CAP_ROUND)\n\n        join_cap = node.get('stroke-linejoin')\n        if join_cap == 'round':\n            self.context.set_line_join(cairo.LINE_JOIN_ROUND)\n        if join_cap == 'bevel':\n            self.context.set_line_join(cairo.LINE_JOIN_BEVEL)\n\n        dash_array = normalize(node.get('stroke-dasharray', '')).split()\n        if dash_array:\n            dashes = [size(self, dash) for dash in dash_array]\n            if sum(dashes):\n                offset = size(self, node.get('stroke-dashoffset'))\n                self.context.set_dash(dashes, offset)\n\n        miter_limit = float(node.get('stroke-miterlimit', 4))\n        self.context.set_miter_limit(miter_limit)\n\n        # Clip\n        rect_values = clip_rect(node.get('clip'))\n        if len(rect_values) == 4:\n            top = size(self, rect_values[0], 'y')\n            right = size(self, rect_values[1], 'x')\n            bottom = size(self, rect_values[2], 'y')\n            left = size(self, rect_values[3], 'x')\n            x = size(self, node.get('x'), 'x')\n            y = size(self, node.get('y'), 'y')\n            width = size(self, node.get('width'), 'x')\n            height = size(self, node.get('height'), 'y')\n            self.context.save()\n            self.context.translate(x, y)\n            self.context.rectangle(\n                left, top, width - left - right, height - top - bottom)\n            self.context.restore()\n            self.context.clip()\n        clip_path = parse_url(node.get('clip-path')).fragment\n        if clip_path:\n            path = self.paths.get(clip_path)\n            if path:\n                self.context.save()\n                if path.get('clipPathUnits') == 'objectBoundingBox':\n                    x = size(self, node.get('x'), 'x')\n                    y = size(self, node.get('y'), 'y')\n                    width = size(self, node.get('width'), 'x')\n                    height = size(self, node.get('height'), 'y')\n                    self.context.translate(x, y)\n                    self.context.scale(width, height)\n                path.tag = 'g'\n                self.stroke_and_fill = False\n                self.draw(path)\n                self.stroke_and_fill = True\n                self.context.restore()\n                # TODO: fill rules are not handled by cairo for clips\n                # if node.get('clip-rule') == 'evenodd':\n                #     self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n                self.context.clip()\n                self.context.set_fill_rule(cairo.FILL_RULE_WINDING)\n\n        save_cursor = copy.deepcopy(\n            (self.cursor_position, self.cursor_d_position,\n             self.text_path_width))\n\n        # Only draw known tags\n        if node.tag in TAGS:\n            try:\n                TAGS[node.tag](self, node)\n            except PointError:\n                # Error in point parsing, do nothing\n                pass\n\n        # Get stroke and fill opacity\n        stroke_opacity = float(node.get('stroke-opacity', 1))\n        fill_opacity = float(node.get('fill-opacity', 1))\n        if opacity < 1 and not node.children:\n            stroke_opacity *= opacity\n            fill_opacity *= opacity\n\n        # Manage display and visibility\n        display = node.get('display', 'inline') != 'none'\n        visible = display and (node.get('visibility', 'visible') != 'hidden')\n\n        # Set font rendering properties\n        self.context.set_antialias(SHAPE_ANTIALIAS.get(\n            node.get('shape-rendering'), cairo.ANTIALIAS_DEFAULT))\n\n        font_options = self.context.get_font_options()\n        font_options.set_antialias(TEXT_ANTIALIAS.get(\n            node.get('text-rendering'), cairo.ANTIALIAS_DEFAULT))\n        font_options.set_hint_style(TEXT_HINT_STYLE.get(\n            node.get('text-rendering'), cairo.HINT_STYLE_DEFAULT))\n        font_options.set_hint_metrics(TEXT_HINT_METRICS.get(\n            node.get('text-rendering'), cairo.HINT_METRICS_DEFAULT))\n        self.context.set_font_options(font_options)\n\n        # Fill and stroke\n        if self.stroke_and_fill and visible and node.tag in TAGS:\n            # Fill\n            self.context.save()\n            paint_source, paint_color = paint(node.get('fill', 'black'))\n            if not gradient_or_pattern(self, node, paint_source, fill_opacity):\n                if node.get('fill-rule') == 'evenodd':\n                    self.context.set_fill_rule(cairo.FILL_RULE_EVEN_ODD)\n                self.context.set_source_rgba(\n                    *self.map_color(paint_color, fill_opacity))\n            if TAGS[node.tag] == text:\n                self.cursor_position = save_cursor[0]\n                self.cursor_d_position = save_cursor[1]\n                self.text_path_width = save_cursor[2]\n                text(self, node, draw_as_text=True)\n            else:\n                self.context.fill_preserve()\n            self.context.restore()\n\n            # Stroke\n            self.context.save()\n            self.context.set_line_width(\n                size(self, node.get('stroke-width', '1')))\n            paint_source, paint_color = paint(node.get('stroke'))\n            if not gradient_or_pattern(\n                    self, node, paint_source, stroke_opacity):\n                self.context.set_source_rgba(\n                    *self.map_color(paint_color, stroke_opacity))\n            self.context.stroke()\n            self.context.restore()\n        elif not visible:\n            self.context.new_path()\n\n        # Draw path markers\n        draw_markers(self, node)\n\n        # Draw children\n        if display and node.tag not in INVISIBLE_TAGS:\n            for child in node.children:\n                self.draw(child)\n\n        # Apply filter, mask and opacity\n        if filter_ or mask or (opacity < 1 and node.children):\n            self.context.pop_group_to_source()\n            if filter_:\n                apply_filter_before_painting(self, node, filter_)\n            if mask in self.masks:\n                paint_mask(self, node, mask, opacity)\n            else:\n                self.context.paint_with_alpha(opacity)\n            if filter_:\n                apply_filter_after_painting(self, node, filter_)\n\n        # Clean cursor's position after 'text' tags\n        if node.tag == 'text':\n            self.cursor_position = [0, 0]\n            self.cursor_d_position = [0, 0]\n            self.text_path_width = 0\n\n        self.context.restore()\n        self.parent_node = old_parent_node\n        self.font_size = old_font_size\n        self.context_width, self.context_height = old_context_size\n\n\nclass PDFSurface(Surface):\n    \"\"\"A surface that writes in PDF format.\"\"\"\n    surface_class = cairo.PDFSurface\n\n\nclass PSSurface(Surface):\n    \"\"\"A surface that writes in PostScript format.\"\"\"\n    surface_class = cairo.PSSurface\n\n\nclass EPSSurface(Surface):\n    \"\"\"A surface that writes in Encapsulated PostScript format.\"\"\"\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        cairo_surface = cairo.PSSurface(self.output, width, height)\n        cairo_surface.set_eps(True)\n        return cairo_surface, width, height\n\n\nclass PNGSurface(Surface):\n    \"\"\"A surface that writes in PNG format.\"\"\"\n    device_units_per_user_units = 1\n\n    def _create_surface(self, width, height):\n        \"\"\"Create and return ``(cairo_surface, width, height)``.\"\"\"\n        width = int(width)\n        height = int(height)\n        cairo_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n        return cairo_surface, width, height\n\n    def finish(self):\n        \"\"\"Read the PNG surface content.\"\"\"\n        if self.output is not None:\n            self.cairo.write_to_png(self.output)\n        return super().finish()\n\n\nclass SVGSurface(Surface):\n    \"\"\"A surface that writes in SVG format.\n\n    It may seem pointless to render SVG to SVG, but this can be used\n    with ``output=None`` to get a vector-based single page cairo surface.\n\n    \"\"\"\n    surface_class = cairo.SVGSurface\n\n\ndef parse_font(value):\n    ret = {\"font-family\": \"\", \"font-size\": \"\", \"font-style\": \"normal\",\n           \"font-variant\": \"normal\", \"font-weight\": \"normal\",\n           \"line-height\": \"normal\"}\n\n    font_styles = [\"italic\", \"oblique\"]\n    font_variants = [\"small-caps\"]\n    font_weights = [\"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\",\n                    \"500\", \"600\", \"700\", \"800\", \"900\"]\n\n    for element in value.split():\n        if element == \"normal\":\n            continue\n        elif ret[\"font-family\"]:\n            ret[\"font-family\"] += \" \" + element\n        elif element in font_styles:\n            ret[\"font-style\"] = element\n        elif element in font_variants:\n            ret[\"font-variant\"] = element\n        elif element in font_weights:\n            ret[\"font-weight\"] = element\n        else:\n            if not ret[\"font-size\"]:\n                parts = element.split(\"/\")\n                ret[\"font-size\"] = parts[0]\n                if len(parts) > 1:\n                    ret[\"line-height\"] = parts[1]\n                continue\n            else:\n                ret[\"font-family\"] = element\n\n    return ret\n"], "filenames": ["cairosvg/__main__.py", "cairosvg/parser.py", "cairosvg/surface.py"], "buggy_code_start_loc": [45, 392, 116], "buggy_code_end_loc": [47, 392, 117], "fixing_code_start_loc": [45, 393, 116], "fixing_code_end_loc": [47, 399, 118], "type": "CWE-918", "message": "CairoSVG is an SVG converter based on Cairo, a 2D graphics library. Prior to version 2.7.0, Cairo can send requests to external hosts when processing SVG files. A malicious actor could send a specially crafted SVG file that allows them to perform a server-side request forgery or denial of service. Version 2.7.0 disables CairoSVG's ability to access other files online by default.", "other": {"cve": {"id": "CVE-2023-27586", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-20T16:15:13.197", "lastModified": "2023-03-23T18:23:58.923", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CairoSVG is an SVG converter based on Cairo, a 2D graphics library. Prior to version 2.7.0, Cairo can send requests to external hosts when processing SVG files. A malicious actor could send a specially crafted SVG file that allows them to perform a server-side request forgery or denial of service. Version 2.7.0 disables CairoSVG's ability to access other files online by default."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.3}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:courtbouillon:cairosvg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.0", "matchCriteriaId": "49569D87-C5E0-449A-8DD0-D28D273E9FA6"}]}]}], "references": [{"url": "https://github.com/Kozea/CairoSVG/commit/12d31c653c0254fa9d9853f66b04ea46e7397255", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Kozea/CairoSVG/commit/33007d4af9195e2bfb2ff9af064c4c2d8e4b2b53", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Kozea/CairoSVG/releases/tag/2.7.0", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/Kozea/CairoSVG/security/advisories/GHSA-rwmf-w63j-p7gv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Kozea/CairoSVG/commit/12d31c653c0254fa9d9853f66b04ea46e7397255"}}