{"buggy_code": ["/*\n * Microsoft Advanced Streaming Format demuxer\n * Copyright (c) 2014 Alexandra H\u00e1jkov\u00e1\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/time_internal.h\"\n\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"avlanguage.h\"\n#include \"id3v2.h\"\n#include \"internal.h\"\n#include \"riff.h\"\n#include \"asf.h\"\n#include \"asfcrypt.h\"\n\n#define ASF_BOOL                              0x2\n#define ASF_WORD                              0x5\n#define ASF_GUID                              0x6\n#define ASF_DWORD                             0x3\n#define ASF_QWORD                             0x4\n#define ASF_UNICODE                           0x0\n#define ASF_FLAG_BROADCAST                    0x1\n#define ASF_BYTE_ARRAY                        0x1\n#define ASF_TYPE_AUDIO                        0x2\n#define ASF_TYPE_VIDEO                        0x1\n#define ASF_STREAM_NUM                        0x7F\n#define ASF_MAX_STREAMS                       128\n#define BMP_HEADER_SIZE                       40\n#define ASF_NUM_OF_PAYLOADS                   0x3F\n#define ASF_ERROR_CORRECTION_LENGTH_TYPE      0x60\n#define ASF_PACKET_ERROR_CORRECTION_DATA_SIZE 0x2\n\ntypedef struct GUIDParseTable {\n    const char *name;\n    ff_asf_guid guid;\n    int (*read_object)(AVFormatContext *, const struct GUIDParseTable *);\n    int is_subobject;\n} GUIDParseTable;\n\ntypedef struct ASFPacket {\n    AVPacket avpkt;\n    int64_t dts;\n    uint32_t frame_num; // ASF payloads with the same number are parts of the same frame\n    int flags;\n    int data_size;\n    int duration;\n    int size_left;\n    uint8_t stream_index;\n} ASFPacket;\n\ntypedef struct ASFStream {\n    uint8_t stream_index; // from packet header\n    int index;  // stream index in AVFormatContext, set in asf_read_stream_properties\n    int type;\n    int indexed; // added index entries from the Simple Index Object or not\n    int8_t span;   // for deinterleaving\n    uint16_t virtual_pkt_len;\n    uint16_t virtual_chunk_len;\n    int16_t lang_idx;\n    ASFPacket pkt;\n} ASFStream;\n\ntypedef struct ASFStreamData{\n    char langs[32];\n    AVDictionary *asf_met; // for storing per-stream metadata\n    AVRational aspect_ratio;\n} ASFStreamData;\n\ntypedef struct ASFContext {\n    int data_reached;\n    int is_simple_index; // is simple index present or not 1/0\n    int is_header;\n\n    uint64_t preroll;\n    uint64_t nb_packets; // ASF packets\n    uint32_t packet_size;\n    int64_t send_time;\n    int duration;\n\n    uint32_t b_flags;    // flags with broadcast flag\n    uint32_t prop_flags; // file properties object flags\n\n    uint64_t data_size; // data object size\n    uint64_t unknown_size; // size of the unknown object\n\n    int64_t offset; // offset of the current object\n\n    int64_t data_offset;\n    int64_t first_packet_offset; // packet offset\n    int64_t unknown_offset;   // for top level header objects or subobjects without specified behavior\n\n    // ASF file must not contain more than 128 streams according to the specification\n    ASFStream *asf_st[ASF_MAX_STREAMS];\n    ASFStreamData asf_sd[ASF_MAX_STREAMS];\n    int nb_streams;\n\n    int stream_index; // from packet header, for the subpayload case\n\n    // packet parameters\n    uint64_t sub_header_offset; // offset of subpayload header\n    int64_t sub_dts;\n    uint8_t dts_delta; // for subpayloads\n    uint32_t packet_size_internal; // packet size stored inside ASFPacket, can be 0\n    int64_t packet_offset; // offset of the current packet inside Data Object\n    uint32_t pad_len; // padding after payload\n    uint32_t rep_data_len;\n\n    // packet state\n    uint64_t sub_left;  // subpayloads left or not\n    unsigned int nb_sub; // number of subpayloads read so far from the current ASF packet\n    uint16_t mult_sub_len; // total length of subpayloads array inside multiple payload\n    uint64_t nb_mult_left; // multiple payloads left\n    int return_subpayload;\n    enum {\n        PARSE_PACKET_HEADER,\n        READ_SINGLE,\n        READ_MULTI,\n        READ_MULTI_SUB\n    } state;\n} ASFContext;\n\nstatic int detect_unknown_subobject(AVFormatContext *s, int64_t offset, int64_t size);\nstatic const GUIDParseTable *find_guid(ff_asf_guid guid);\n\nstatic int asf_probe(AVProbeData *pd)\n{\n    /* check file header */\n    if (!ff_guidcmp(pd->buf, &ff_asf_header))\n        return AVPROBE_SCORE_MAX/2;\n    else\n        return 0;\n}\n\nstatic void swap_guid(ff_asf_guid guid)\n{\n    FFSWAP(unsigned char, guid[0], guid[3]);\n    FFSWAP(unsigned char, guid[1], guid[2]);\n    FFSWAP(unsigned char, guid[4], guid[5]);\n    FFSWAP(unsigned char, guid[6], guid[7]);\n}\n\nstatic void align_position(AVIOContext *pb,  int64_t offset, uint64_t size)\n{\n    if (size < INT64_MAX - offset && avio_tell(pb) != offset + size)\n        avio_seek(pb, offset + size, SEEK_SET);\n}\n\nstatic int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int ret;\n\n    if (size > INT64_MAX)\n        return AVERROR_INVALIDDATA;\n\n    if (asf->is_header)\n        asf->unknown_size = size;\n    asf->is_header = 0;\n    if (!g->is_subobject) {\n        if (!(ret = strcmp(g->name, \"Header Extension\")))\n            avio_skip(pb, 22); // skip reserved fields and Data Size\n        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,\n                                            asf->unknown_size)) < 0)\n            return ret;\n    } else {\n        if (size < 24) {\n            av_log(s, AV_LOG_ERROR, \"Too small size %\"PRIu64\" (< 24).\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        avio_skip(pb, size - 24);\n    }\n\n    return 0;\n}\n\nstatic int get_asf_string(AVIOContext *pb, int maxlen, char *buf, int buflen)\n{\n    char *q = buf;\n    int ret = 0;\n    if (buflen <= 0)\n        return AVERROR(EINVAL);\n    while (ret + 1 < maxlen) {\n        uint8_t tmp;\n        uint32_t ch;\n        GET_UTF16(ch, (ret += 2) <= maxlen ? avio_rl16(pb) : 0, break;);\n        PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\n    }\n    *q = 0;\n\n    return ret;\n}\n\nstatic int asf_read_marker(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int i, nb_markers, ret;\n    size_t len;\n    char name[1024];\n\n    avio_skip(pb, 8);\n    avio_skip(pb, 8); // skip reserved GUID\n    nb_markers = avio_rl32(pb);\n    avio_skip(pb, 2); // skip reserved field\n    len = avio_rl16(pb);\n    for (i = 0; i < len; i++)\n        avio_skip(pb, 1);\n\n    for (i = 0; i < nb_markers; i++) {\n        int64_t pts;\n\n        avio_skip(pb, 8);\n        pts = avio_rl64(pb);\n        pts -= asf->preroll * 10000;\n        avio_skip(pb, 2); // entry length\n        avio_skip(pb, 4); // send time\n        avio_skip(pb, 4); // flags\n        len = avio_rl32(pb);\n\n        if ((ret = avio_get_str16le(pb, len, name,\n                                    sizeof(name))) < len)\n            avio_skip(pb, len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pts,\n                           AV_NOPTS_VALUE, name);\n    }\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic int asf_read_metadata(AVFormatContext *s, const char *title, uint16_t len,\n                             unsigned char *ch, uint16_t buflen)\n{\n    AVIOContext *pb = s->pb;\n\n    avio_get_str16le(pb, len, ch, buflen);\n    if (ch[0]) {\n        if (av_dict_set(&s->metadata, title, ch, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n\n    return 0;\n}\n\nstatic int asf_read_value(AVFormatContext *s, const uint8_t *name,\n                          uint16_t val_len, int type, AVDictionary **met)\n{\n    int ret;\n    uint8_t *value;\n    uint16_t buflen = 2 * val_len + 1;\n    AVIOContext *pb = s->pb;\n\n    value = av_malloc(buflen);\n    if (!value)\n        return AVERROR(ENOMEM);\n    if (type == ASF_UNICODE) {\n        // get_asf_string reads UTF-16 and converts it to UTF-8 which needs longer buffer\n        if ((ret = get_asf_string(pb, val_len, value, buflen)) < 0)\n            goto failed;\n        if (av_dict_set(met, name, value, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    } else {\n        char buf[256];\n        if (val_len > sizeof(buf)) {\n            ret = AVERROR_INVALIDDATA;\n            goto failed;\n        }\n        if ((ret = avio_read(pb, value, val_len)) < 0)\n            goto failed;\n        if (ret < 2 * val_len)\n            value[ret] = '\\0';\n        else\n            value[2 * val_len - 1] = '\\0';\n        snprintf(buf, sizeof(buf), \"%s\", value);\n        if (av_dict_set(met, name, buf, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n    av_freep(&value);\n\n    return 0;\n\nfailed:\n    av_freep(&value);\n    return ret;\n}\nstatic int asf_read_generic_value(AVIOContext *pb, int type, uint64_t *value)\n{\n\n    switch (type) {\n    case ASF_BOOL:\n        *value = avio_rl16(pb);\n        break;\n    case ASF_DWORD:\n        *value = avio_rl32(pb);\n        break;\n    case ASF_QWORD:\n        *value = avio_rl64(pb);\n        break;\n    case ASF_WORD:\n        *value = avio_rl16(pb);\n        break;\n    default:\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int asf_set_metadata(AVFormatContext *s, const uint8_t *name,\n                            int type, AVDictionary **met)\n{\n    AVIOContext *pb = s->pb;\n    uint64_t value;\n    char buf[32];\n    int ret;\n\n    ret = asf_read_generic_value(pb, type, &value);\n    if (ret < 0)\n        return ret;\n\n    snprintf(buf, sizeof(buf), \"%\"PRIu64, value);\n    if (av_dict_set(met, name, buf, 0) < 0)\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    return 0;\n}\n\n/* MSDN claims that this should be \"compatible with the ID3 frame, APIC\",\n * but in reality this is only loosely similar */\nstatic int asf_read_picture(AVFormatContext *s, int len)\n{\n    ASFContext *asf       = s->priv_data;\n    AVPacket pkt          = { 0 };\n    const CodecMime *mime = ff_id3v2_mime_tags;\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n    char mimetype[64];\n    uint8_t  *desc = NULL;\n    AVStream   *st = NULL;\n    int ret, type, picsize, desc_len;\n    ASFStream *asf_st;\n\n    /* type + picsize + mime + desc */\n    if (len < 1 + 4 + 2 + 2) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture type */\n    type = avio_r8(s->pb);\n    len--;\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n        type = 0;\n    }\n\n    /* picture data size */\n    picsize = avio_rl32(s->pb);\n    len    -= 4;\n\n    /* picture MIME type */\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n    while (mime->id != AV_CODEC_ID_NONE) {\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n            id = mime->id;\n            break;\n        }\n        mime++;\n    }\n    if (id == AV_CODEC_ID_NONE) {\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n               mimetype);\n        return 0;\n    }\n\n    if (picsize >= len) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n               picsize, len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture description */\n    desc_len = (len - picsize) * 2 + 1;\n    desc     = av_malloc(desc_len);\n    if (!desc)\n        return AVERROR(ENOMEM);\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n    if (ret < 0)\n        goto fail;\n\n    st  = avformat_new_stream(s, NULL);\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n    asf_st = asf->asf_st[asf->nb_streams];\n    if (!asf_st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n    st->codecpar->codec_type      = asf_st->type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id        = id;\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = asf_st->index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    asf->nb_streams++;\n\n    if (*desc) {\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    } else\n        av_freep(&desc);\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    return 0;\n\nfail:\n    av_freep(&desc);\n    av_packet_unref(&pkt);\n    return ret;\n}\n\nstatic void get_id3_tag(AVFormatContext *s, int len)\n{\n    ID3v2ExtraMeta *id3v2_extra_meta = NULL;\n\n    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, len);\n    if (id3v2_extra_meta) {\n        ff_id3v2_parse_apic(s, &id3v2_extra_meta);\n        ff_id3v2_parse_chapters(s, &id3v2_extra_meta);\n    }\n    ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n}\n\nstatic int process_metadata(AVFormatContext *s, const uint8_t *name, uint16_t name_len,\n                            uint16_t val_len, uint16_t type, AVDictionary **met)\n{\n    int ret;\n    ff_asf_guid guid;\n\n    if (val_len) {\n        switch (type) {\n        case ASF_UNICODE:\n            asf_read_value(s, name, val_len, type, met);\n            break;\n        case ASF_BYTE_ARRAY:\n            if (!strcmp(name, \"WM/Picture\")) // handle cover art\n                asf_read_picture(s, val_len);\n            else if (!strcmp(name, \"ID3\")) // handle ID3 tag\n                get_id3_tag(s, val_len);\n            else\n                asf_read_value(s, name, val_len, type, met);\n            break;\n        case ASF_GUID:\n            ff_get_guid(s->pb, &guid);\n            break;\n        default:\n            if ((ret = asf_set_metadata(s, name, type, met)) < 0)\n                return ret;\n            break;\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf  = s->priv_data;\n    AVIOContext *pb  = s->pb;\n    uint64_t size    = avio_rl64(pb);\n    uint16_t nb_desc = avio_rl16(pb);\n    int i, ret;\n\n    for (i = 0; i < nb_desc; i++) {\n        uint16_t name_len, type, val_len;\n        uint8_t *name = NULL;\n\n        name_len = avio_rl16(pb);\n        if (!name_len)\n            return AVERROR_INVALIDDATA;\n        name = av_malloc(name_len);\n        if (!name)\n            return AVERROR(ENOMEM);\n        avio_get_str16le(pb, name_len, name,\n                         name_len);\n        type    = avio_rl16(pb);\n        // BOOL values are 16 bits long in the Metadata Object\n        // but 32 bits long in the Extended Content Description Object\n        if (type == ASF_BOOL)\n            type = ASF_DWORD;\n        val_len = avio_rl16(pb);\n\n        ret = process_metadata(s, name, name_len, val_len, type, &s->metadata);\n        av_freep(&name);\n        if (ret < 0)\n            return ret;\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic AVStream *find_stream(AVFormatContext *s, uint16_t st_num)\n{\n    AVStream *st = NULL;\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (asf->asf_st[i]->stream_index == st_num) {\n            st = s->streams[asf->asf_st[i]->index];\n            break;\n        }\n    }\n\n    return st;\n}\n\nstatic int asf_store_aspect_ratio(AVFormatContext *s, uint8_t st_num, uint8_t *name, int type)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    uint64_t value = 0;\n    int ret;\n\n    ret = asf_read_generic_value(pb, type, &value);\n    if (ret < 0)\n        return ret;\n\n    if (st_num < ASF_MAX_STREAMS) {\n        if (!strcmp(name, \"AspectRatioX\"))\n            asf->asf_sd[st_num].aspect_ratio.num = value;\n        else\n            asf->asf_sd[st_num].aspect_ratio.den = value;\n    }\n    return 0;\n}\n\nstatic int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    uint64_t size     = avio_rl64(pb);\n    uint16_t nb_recs  = avio_rl16(pb); // number of records in the Description Records list\n    int i, ret;\n\n    for (i = 0; i < nb_recs; i++) {\n        uint16_t name_len, buflen, type, val_len, st_num;\n        uint8_t *name = NULL;\n\n        avio_skip(pb, 2); // skip reserved field\n        st_num   = avio_rl16(pb);\n        name_len = avio_rl16(pb);\n        buflen   = 2 * name_len + 1;\n        if (!name_len)\n            break;\n        type     = avio_rl16(pb);\n        val_len  = avio_rl32(pb);\n        name     = av_malloc(buflen);\n        if (!name)\n            return AVERROR(ENOMEM);\n        avio_get_str16le(pb, name_len, name,\n                         buflen);\n        if (!strcmp(name, \"AspectRatioX\") || !strcmp(name, \"AspectRatioY\")) {\n            ret = asf_store_aspect_ratio(s, st_num, name, type);\n            if (ret < 0) {\n                av_freep(&name);\n                break;\n            }\n        } else {\n            if (st_num < ASF_MAX_STREAMS) {\n                if ((ret = process_metadata(s, name, name_len, val_len, type,\n                                            &asf->asf_sd[st_num].asf_met)) < 0) {\n                    av_freep(&name);\n                    break;\n                }\n            }\n        }\n        av_freep(&name);\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic int asf_read_content_desc(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int i;\n    static const char *const titles[] =\n    { \"Title\", \"Author\", \"Copyright\", \"Description\", \"Rate\" };\n    uint16_t len[5], buflen[5] = { 0 };\n    uint8_t *ch;\n    uint64_t size = avio_rl64(pb);\n\n    for (i = 0; i < 5; i++) {\n        len[i]  = avio_rl16(pb);\n        // utf8 string should be <= 2 * utf16 string, extra byte for the terminator\n        buflen[i]  = 2 * len[i] + 1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        ch = av_malloc(buflen[i]);\n        if (!ch)\n            return(AVERROR(ENOMEM));\n        asf_read_metadata(s, titles[i], len[i], ch, buflen[i]);\n        av_freep(&ch);\n    }\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic int asf_read_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    time_t creation_time;\n\n    avio_rl64(pb); // read object size\n    avio_skip(pb, 16); // skip File ID\n    avio_skip(pb, 8);  // skip File size\n    creation_time = avio_rl64(pb);\n    if (!(asf->b_flags & ASF_FLAG_BROADCAST)) {\n        struct tm tmbuf;\n        struct tm *tm;\n        char buf[64];\n\n        // creation date is in 100 ns units from 1 Jan 1601, conversion to s\n        creation_time /= 10000000;\n        // there are 11644473600 seconds between 1 Jan 1601 and 1 Jan 1970\n        creation_time -= 11644473600;\n        tm = gmtime_r(&creation_time, &tmbuf);\n        if (tm) {\n            if (!strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n                buf[0] = '\\0';\n        } else\n            buf[0] = '\\0';\n        if (buf[0]) {\n            if (av_dict_set(&s->metadata, \"creation_time\", buf, 0) < 0)\n                av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n        }\n    }\n    asf->nb_packets  = avio_rl64(pb);\n    asf->duration    = avio_rl64(pb) / 10000; // stream duration\n    avio_skip(pb, 8); // skip send duration\n    asf->preroll     = avio_rl64(pb);\n    asf->duration   -= asf->preroll;\n    asf->b_flags     = avio_rl32(pb);\n    avio_skip(pb, 4); // skip minimal packet size\n    asf->packet_size  = avio_rl32(pb);\n    avio_skip(pb, 4); // skip max_bitrate\n\n    return 0;\n}\n\nstatic int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; // ASF-specific Format Data size\n    uint32_t size_bmp; // BMP_HEADER-specific Format Data size\n    unsigned int tag;\n\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); // skip reserved flags\n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n\n    if (size_bmp > BMP_HEADER_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic int asf_read_stream_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size;\n    uint32_t err_data_len, ts_data_len; // type specific data length\n    uint16_t flags;\n    ff_asf_guid stream_type;\n    enum AVMediaType type;\n    int i, ret;\n    uint8_t stream_index;\n    AVStream *st;\n    ASFStream *asf_st;\n\n    // ASF file must not contain more than 128 streams according to the specification\n    if (asf->nb_streams >= ASF_MAX_STREAMS)\n        return AVERROR_INVALIDDATA;\n\n    size = avio_rl64(pb);\n    ff_get_guid(pb, &stream_type);\n    if (!ff_guidcmp(&stream_type, &ff_asf_audio_stream))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_video_stream))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_jfif_media))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_command_stream))\n        type = AVMEDIA_TYPE_DATA;\n    else if (!ff_guidcmp(&stream_type,\n                         &ff_asf_ext_stream_embed_stream_header))\n        type = AVMEDIA_TYPE_UNKNOWN;\n    else\n        return AVERROR_INVALIDDATA;\n\n    ff_get_guid(pb, &stream_type); // error correction type\n    avio_skip(pb, 8); // skip the time offset\n    ts_data_len      = avio_rl32(pb);\n    err_data_len     = avio_rl32(pb);\n    flags            = avio_rl16(pb); // bit 15 - Encrypted Content\n\n    stream_index = flags & ASF_STREAM_NUM;\n    for (i = 0; i < asf->nb_streams; i++)\n        if (stream_index == asf->asf_st[i]->stream_index) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Duplicate stream found, this stream will be ignored.\\n\");\n            align_position(pb, asf->offset, size);\n            return 0;\n        }\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    avpriv_set_pts_info(st, 32, 1, 1000); // pts should be dword, in milliseconds\n    st->codecpar->codec_type = type;\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n    if (!asf->asf_st[asf->nb_streams])\n        return AVERROR(ENOMEM);\n    asf_st                       = asf->asf_st[asf->nb_streams];\n    asf->nb_streams++;\n    asf_st->stream_index         = stream_index;\n    asf_st->index                = st->index;\n    asf_st->indexed              = 0;\n    st->id                       = flags & ASF_STREAM_NUM;\n    av_init_packet(&asf_st->pkt.avpkt);\n    asf_st->pkt.data_size        = 0;\n    avio_skip(pb, 4); // skip reserved field\n\n    switch (type) {\n    case AVMEDIA_TYPE_AUDIO:\n        asf_st->type = AVMEDIA_TYPE_AUDIO;\n        if ((ret = ff_get_wav_header(s, pb, st->codecpar, ts_data_len, 0)) < 0)\n            return ret;\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        asf_st->type = AVMEDIA_TYPE_VIDEO;\n        if ((ret = parse_video_info(pb, st)) < 0)\n            return ret;\n        break;\n    default:\n        avio_skip(pb, ts_data_len);\n        break;\n    }\n\n    if (err_data_len) {\n        if (type == AVMEDIA_TYPE_AUDIO) {\n            uint8_t span = avio_r8(pb);\n            if (span > 1) {\n                asf_st->span              = span;\n                asf_st->virtual_pkt_len   = avio_rl16(pb);\n                asf_st->virtual_chunk_len = avio_rl16(pb);\n                if (!asf_st->virtual_chunk_len || !asf_st->virtual_pkt_len)\n                    return AVERROR_INVALIDDATA;\n                avio_skip(pb, err_data_len - 5);\n            } else\n                avio_skip(pb, err_data_len - 1);\n        } else\n            avio_skip(pb, err_data_len);\n    }\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic void set_language(AVFormatContext *s, const char *rfc1766, AVDictionary **met)\n{\n    // language abbr should contain at least 2 chars\n    if (rfc1766 && strlen(rfc1766) > 1) {\n        const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\\0' }; // ignore country code if any\n        const char *iso6392       = ff_convert_lang_to(primary_tag,\n                                                       AV_LANG_ISO639_2_BIBL);\n        if (iso6392)\n            if (av_dict_set(met, \"language\", iso6392, 0) < 0)\n                av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n}\n\nstatic int asf_read_ext_stream_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st    = NULL;\n    ff_asf_guid guid;\n    uint16_t nb_st_name, nb_pay_exts, st_num, lang_idx;\n    int i, ret;\n    uint32_t bitrate;\n    uint64_t start_time, end_time, time_per_frame;\n    uint64_t size = avio_rl64(pb);\n\n    start_time = avio_rl64(pb);\n    end_time   = avio_rl64(pb);\n    bitrate    = avio_rl32(pb);\n    avio_skip(pb, 28); // skip some unused values\n    st_num     = avio_rl16(pb);\n    st_num    &= ASF_STREAM_NUM;\n    lang_idx   = avio_rl16(pb); // Stream Language ID Index\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (st_num == asf->asf_st[i]->stream_index) {\n            st                       = s->streams[asf->asf_st[i]->index];\n            asf->asf_st[i]->lang_idx = lang_idx;\n            break;\n        }\n    }\n    time_per_frame = avio_rl64(pb); // average time per frame\n    if (st) {\n        st->start_time           = start_time;\n        st->duration             = end_time - start_time;\n        st->codecpar->bit_rate   = bitrate;\n        st->avg_frame_rate.num   = 10000000;\n        st->avg_frame_rate.den   = time_per_frame;\n    }\n    nb_st_name = avio_rl16(pb);\n    nb_pay_exts   = avio_rl16(pb);\n    for (i = 0; i < nb_st_name; i++) {\n        uint16_t len;\n\n        avio_rl16(pb); // Language ID Index\n        len = avio_rl16(pb);\n        avio_skip(pb, len);\n    }\n\n    for (i = 0; i < nb_pay_exts; i++) {\n        uint32_t len;\n        avio_skip(pb, 16); // Extension System ID\n        avio_skip(pb, 2);  // Extension Data Size\n        len = avio_rl32(pb);\n        avio_skip(pb, len);\n    }\n\n    if ((ret = ff_get_guid(pb, &guid)) < 0) {\n        align_position(pb, asf->offset, size);\n\n        return 0;\n    }\n\n    g = find_guid(guid);\n    if (g && !(strcmp(g->name, \"Stream Properties\"))) {\n        if ((ret = g->read_object(s, g)) < 0)\n            return ret;\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic int asf_read_language_list(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    int i, ret;\n    uint64_t size     = avio_rl64(pb);\n    uint16_t nb_langs = avio_rl16(pb);\n\n    if (nb_langs < ASF_MAX_STREAMS) {\n        for (i = 0; i < nb_langs; i++) {\n            size_t len;\n            len = avio_r8(pb);\n            if (!len)\n                len = 6;\n            if ((ret = get_asf_string(pb, len, asf->asf_sd[i].langs,\n                                      sizeof(asf->asf_sd[i].langs))) < 0) {\n                return ret;\n            }\n        }\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\n// returns data object offset when reading this object for the first time\nstatic int asf_read_data(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = asf->data_size = avio_rl64(pb);\n    int i;\n\n    if (!asf->data_reached) {\n        asf->data_reached       = 1;\n        asf->data_offset        = asf->offset;\n    }\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (!(asf->b_flags & ASF_FLAG_BROADCAST))\n            s->streams[i]->duration = asf->duration;\n    }\n    asf->nb_mult_left           = 0;\n    asf->sub_left               = 0;\n    asf->state                  = PARSE_PACKET_HEADER;\n    asf->return_subpayload      = 0;\n    asf->packet_size_internal   = 0;\n    avio_skip(pb, 16); // skip File ID\n    size = avio_rl64(pb); // Total Data Packets\n    if (size != asf->nb_packets)\n        av_log(s, AV_LOG_WARNING,\n               \"Number of Packets from File Properties Object is not equal to Total\"\n               \"Datapackets value! num of packets %\"PRIu64\" total num %\"PRIu64\".\\n\",\n               size, asf->nb_packets);\n    avio_skip(pb, 2); // skip reserved field\n    asf->first_packet_offset = avio_tell(pb);\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !(asf->b_flags & ASF_FLAG_BROADCAST))\n        align_position(pb, asf->offset, asf->data_size);\n\n    return 0;\n}\n\nstatic int asf_read_simple_index(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st    = NULL;\n    uint64_t interval; // index entry time interval in 100 ns units, usually it's 1s\n    uint32_t pkt_num, nb_entries;\n    int32_t prev_pkt_num = -1;\n    int i;\n    int64_t offset;\n    uint64_t size = avio_rl64(pb);\n\n    // simple index objects should be ordered by stream number, this loop tries to find\n    // the first not indexed video stream\n    for (i = 0; i < asf->nb_streams; i++) {\n        if ((asf->asf_st[i]->type == AVMEDIA_TYPE_VIDEO) && !asf->asf_st[i]->indexed) {\n            asf->asf_st[i]->indexed = 1;\n            st = s->streams[asf->asf_st[i]->index];\n            break;\n        }\n    }\n    if (!st) {\n        avio_skip(pb, size - 24); // if there's no video stream, skip index object\n        return 0;\n    }\n    avio_skip(pb, 16); // skip File ID\n    interval = avio_rl64(pb);\n    avio_skip(pb, 4);\n    nb_entries = avio_rl32(pb);\n    for (i = 0; i < nb_entries; i++) {\n        pkt_num = avio_rl32(pb);\n        offset = avio_skip(pb, 2);\n        if (offset < 0) {\n            av_log(s, AV_LOG_ERROR, \"Skipping failed in asf_read_simple_index.\\n\");\n            return offset;\n        }\n        if (prev_pkt_num != pkt_num) {\n            av_add_index_entry(st, asf->first_packet_offset + asf->packet_size *\n                               pkt_num, av_rescale(interval, i, 10000),\n                               asf->packet_size, 0, AVINDEX_KEYFRAME);\n            prev_pkt_num = pkt_num;\n        }\n    }\n    asf->is_simple_index = 1;\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic const GUIDParseTable gdef[] = {\n    { \"Data\",                         { 0x75, 0xB2, 0x26, 0x36, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_data, 1 },\n    { \"Simple Index\",                 { 0x33, 0x00, 0x08, 0x90, 0xE5, 0xB1, 0x11, 0xCF, 0x89, 0xF4, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xCB }, asf_read_simple_index, 1 },\n    { \"Content Description\",          { 0x75, 0xB2, 0x26, 0x33, 0x66 ,0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_content_desc, 1 },\n    { \"Extended Content Description\", { 0xD2, 0xD0, 0xA4, 0x40, 0xE3, 0x07, 0x11, 0xD2, 0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5e, 0xA8, 0x50 }, asf_read_ext_content, 1 },\n    { \"Stream Bitrate Properties\",    { 0x7B, 0xF8, 0x75, 0xCE, 0x46, 0x8D, 0x11, 0xD1, 0x8D, 0x82, 0x00, 0x60, 0x97, 0xC9, 0xA2, 0xB2 }, asf_read_unknown, 1 },\n    { \"File Properties\",              { 0x8C, 0xAB, 0xDC, 0xA1, 0xA9, 0x47, 0x11, 0xCF, 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_properties, 1 },\n    { \"Header Extension\",             { 0x5F, 0xBF, 0x03, 0xB5, 0xA9, 0x2E, 0x11, 0xCF, 0x8E, 0xE3, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_unknown, 0 },\n    { \"Stream Properties\",            { 0xB7, 0xDC, 0x07, 0x91, 0xA9, 0xB7, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_stream_properties, 1 },\n    { \"Codec List\",                   { 0x86, 0xD1, 0x52, 0x40, 0x31, 0x1D, 0x11, 0xD0, 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6 }, asf_read_unknown, 1 },\n    { \"Marker\",                       { 0xF4, 0x87, 0xCD, 0x01, 0xA9, 0x51, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_marker, 1 },\n    { \"Script Command\",               { 0x1E, 0xFB, 0x1A, 0x30, 0x0B, 0x62, 0x11, 0xD0, 0xA3, 0x9B, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6 }, asf_read_unknown, 1 },\n    { \"Language List\",                { 0x7C, 0x43, 0x46, 0xa9, 0xef, 0xe0, 0x4B, 0xFC, 0xB2, 0x29, 0x39, 0x3e, 0xde, 0x41, 0x5c, 0x85 }, asf_read_language_list, 1},\n    { \"Padding\",                      { 0x18, 0x06, 0xD4, 0x74, 0xCA, 0xDF, 0x45, 0x09, 0xA4, 0xBA, 0x9A, 0xAB, 0xCB, 0x96, 0xAA, 0xE8 }, asf_read_unknown, 1 },\n    { \"DRMv1 Header\",                 { 0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"DRMv2 Header\",                 { 0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9c }, asf_read_unknown, 1 },\n    { \"Index\",                        { 0xD6, 0xE2, 0x29, 0xD3, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Media Object Index\",           { 0xFE, 0xB1, 0x03, 0xF8, 0x12, 0xAD, 0x4C, 0x64, 0x84, 0x0F, 0x2A, 0x1D, 0x2F, 0x7A, 0xD4, 0x8C }, asf_read_unknown, 1 },\n    { \"Timecode Index\",               { 0x3C, 0xB7, 0x3F, 0xD0, 0x0C, 0x4A, 0x48, 0x03, 0x95, 0x3D, 0xED, 0xF7, 0xB6, 0x22, 0x8F, 0x0C }, asf_read_unknown, 0 },\n    { \"Bitrate_Mutual_Exclusion\",     { 0xD6, 0xE2, 0x29, 0xDC, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Error Correction\",             { 0x75, 0xB2, 0x26, 0x35, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_unknown, 1 },\n    { \"Content Branding\",             { 0x22, 0x11, 0xB3, 0xFA, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Content Encryption\",           { 0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Extended Content Encryption\",  { 0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9C }, asf_read_unknown, 1 },\n    { \"Digital Signature\",            { 0x22, 0x11, 0xB3, 0xFC, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Extended Stream Properties\",   { 0x14, 0xE6, 0xA5, 0xCB, 0xC6, 0x72, 0x43, 0x32, 0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A }, asf_read_ext_stream_properties, 1 },\n    { \"Advanced Mutual Exclusion\",    { 0xA0, 0x86, 0x49, 0xCF, 0x47, 0x75, 0x46, 0x70, 0x8A, 0x16, 0x6E, 0x35, 0x35, 0x75, 0x66, 0xCD }, asf_read_unknown, 1 },\n    { \"Group Mutual Exclusion\",       { 0xD1, 0x46, 0x5A, 0x40, 0x5A, 0x79, 0x43, 0x38, 0xB7, 0x1B, 0xE3, 0x6B, 0x8F, 0xD6, 0xC2, 0x49 }, asf_read_unknown, 1},\n    { \"Stream Prioritization\",        { 0xD4, 0xFE, 0xD1, 0x5B, 0x88, 0xD3, 0x45, 0x4F, 0x81, 0xF0, 0xED, 0x5C, 0x45, 0x99, 0x9E, 0x24 }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Object\",     { 0xA6, 0x96, 0x09, 0xE6, 0x51, 0x7B, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Metadata\",                     { 0xC5, 0xF8, 0xCB, 0xEA, 0x5B, 0xAF, 0x48, 0x77, 0x84, 0x67, 0xAA, 0x8C, 0x44, 0xFA, 0x4C, 0xCA }, asf_read_metadata_obj, 1 },\n    { \"Metadata Library\",             { 0x44, 0x23, 0x1C, 0x94, 0x94, 0x98, 0x49, 0xD1, 0xA1, 0x41, 0x1D, 0x13, 0x4E, 0x45, 0x70, 0x54 }, asf_read_metadata_obj, 1 },\n    { \"Audio Spread\",                 { 0xBF, 0xC3, 0xCD, 0x50, 0x61, 0x8F, 0x11, 0xCF, 0x8B, 0xB2, 0x00, 0xAA, 0x00, 0xB4, 0xE2, 0x20 }, asf_read_unknown, 1 },\n    { \"Index Parameters\",             { 0xD6, 0xE2, 0x29, 0xDF, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Content Encryption System Windows Media DRM Network Devices\",\n                                      { 0x7A, 0x07, 0x9B, 0xB6, 0xDA, 0XA4, 0x4e, 0x12, 0xA5, 0xCA, 0x91, 0xD3, 0x8D, 0xC1, 0x1A, 0x8D }, asf_read_unknown, 1 },\n    { \"Mutex Language\",               { 0xD6, 0xE2, 0x2A, 0x00, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Mutex Bitrate\",                { 0xD6, 0xE2, 0x2A, 0x01, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Mutex Unknown\",                { 0xD6, 0xE2, 0x2A, 0x02, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Exclusive\",  { 0xAF, 0x60, 0x60, 0xAA, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Partial\",    { 0xAF, 0x60, 0x60, 0xAB, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Payload Extension System Timecode\", { 0x39, 0x95, 0x95, 0xEC, 0x86, 0x67, 0x4E, 0x2D, 0x8F, 0xDB, 0x98, 0x81, 0x4C, 0xE7, 0x6C, 0x1E }, asf_read_unknown, 1 },\n    { \"Payload Extension System File Name\", { 0xE1, 0x65, 0xEC, 0x0E, 0x19, 0xED, 0x45, 0xD7, 0xB4, 0xA7, 0x25, 0xCB, 0xD1, 0xE2, 0x8E, 0x9B }, asf_read_unknown, 1 },\n    { \"Payload Extension System Content Type\", { 0xD5, 0x90, 0xDC, 0x20, 0x07, 0xBC, 0x43, 0x6C, 0x9C, 0xF7, 0xF3, 0xBB, 0xFB, 0xF1, 0xA4, 0xDC }, asf_read_unknown, 1 },\n    { \"Payload Extension System Pixel Aspect Ratio\", { 0x1, 0x1E, 0xE5, 0x54, 0xF9, 0xEA, 0x4B, 0xC8, 0x82, 0x1A, 0x37, 0x6B, 0x74, 0xE4, 0xC4, 0xB8 }, asf_read_unknown, 1 },\n    { \"Payload Extension System Sample Duration\", { 0xC6, 0xBD, 0x94, 0x50, 0x86, 0x7F, 0x49, 0x07, 0x83, 0xA3, 0xC7, 0x79, 0x21, 0xB7, 0x33, 0xAD }, asf_read_unknown, 1 },\n    { \"Payload Extension System Encryption Sample ID\", { 0x66, 0x98, 0xB8, 0x4E, 0x0A, 0xFA, 0x43, 0x30, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D }, asf_read_unknown, 1 },\n    { \"Payload Extension System Degradable JPEG\", { 0x00, 0xE1, 0xAF, 0x06, 0x7B, 0xEC, 0x11, 0xD1, 0xA5, 0x82, 0x00, 0xC0, 0x4F, 0xC2, 0x9C, 0xFB }, asf_read_unknown, 1 },\n};\n\n#define READ_LEN(flag, name, len)            \\\n    do {                                     \\\n        if ((flag) == name ## IS_BYTE)       \\\n            len = avio_r8(pb);               \\\n        else if ((flag) == name ## IS_WORD)  \\\n            len = avio_rl16(pb);             \\\n        else if ((flag) == name ## IS_DWORD) \\\n            len = avio_rl32(pb);             \\\n        else                                 \\\n            len = 0;                         \\\n    } while(0)\n\nstatic int asf_read_subpayload(AVFormatContext *s, AVPacket *pkt, int is_header)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint8_t sub_len;\n    int ret, i;\n\n    if (is_header) {\n        asf->dts_delta = avio_r8(pb);\n        if (asf->nb_mult_left) {\n            asf->mult_sub_len = avio_rl16(pb); // total\n        }\n        asf->sub_header_offset = avio_tell(pb);\n        asf->nb_sub = 0;\n        asf->sub_left = 1;\n    }\n    sub_len = avio_r8(pb);\n    if ((ret = av_get_packet(pb, pkt, sub_len)) < 0) // each subpayload is entire frame\n        return ret;\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (asf->stream_index == asf->asf_st[i]->stream_index) {\n            pkt->stream_index  = asf->asf_st[i]->index;\n            break;\n        }\n    }\n    asf->return_subpayload = 1;\n    if (!sub_len)\n        asf->return_subpayload = 0;\n\n    if (sub_len)\n        asf->nb_sub++;\n    pkt->dts = asf->sub_dts + (asf->nb_sub - 1) * asf->dts_delta - asf->preroll;\n    if (asf->nb_mult_left && (avio_tell(pb) >=\n                              (asf->sub_header_offset + asf->mult_sub_len))) {\n        asf->sub_left = 0;\n        asf->nb_mult_left--;\n    }\n    if (avio_tell(pb) >= asf->packet_offset + asf->packet_size - asf->pad_len) {\n        asf->sub_left = 0;\n        if (!asf->nb_mult_left) {\n            avio_skip(pb, asf->pad_len);\n            if (avio_tell(pb) != asf->packet_offset + asf->packet_size) {\n                if (!asf->packet_size)\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_WARNING,\n                       \"Position %\"PRId64\" wrong, should be %\"PRId64\"\\n\",\n                       avio_tell(pb), asf->packet_offset + asf->packet_size);\n                avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void reset_packet(ASFPacket *asf_pkt)\n{\n    asf_pkt->size_left = 0;\n    asf_pkt->data_size = 0;\n    asf_pkt->duration  = 0;\n    asf_pkt->flags     = 0;\n    asf_pkt->dts       = 0;\n    asf_pkt->duration  = 0;\n    av_packet_unref(&asf_pkt->avpkt);\n    av_init_packet(&asf_pkt->avpkt);\n}\n\nstatic int asf_read_replicated_data(AVFormatContext *s, ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, data_size;\n\n    if (!asf_pkt->data_size) {\n        data_size = avio_rl32(pb); // read media object size\n        if (data_size <= 0)\n            return AVERROR_INVALIDDATA;\n        if ((ret = av_new_packet(&asf_pkt->avpkt, data_size)) < 0)\n            return ret;\n        asf_pkt->data_size = asf_pkt->size_left = data_size;\n    } else\n        avio_skip(pb, 4); // reading of media object size is already done\n    asf_pkt->dts = avio_rl32(pb); // read presentation time\n    if (asf->rep_data_len && (asf->rep_data_len >= 8))\n        avio_skip(pb, asf->rep_data_len - 8); // skip replicated data\n\n    return 0;\n}\n\nstatic int asf_read_multiple_payload(AVFormatContext *s, AVPacket *pkt,\n                                 ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint16_t pay_len;\n    unsigned char *p;\n    int ret;\n    int skip = 0;\n\n    // if replicated length is 1, subpayloads are present\n    if (asf->rep_data_len == 1) {\n        asf->sub_left = 1;\n        asf->state = READ_MULTI_SUB;\n        pkt->flags = asf_pkt->flags;\n        if ((ret = asf_read_subpayload(s, pkt, 1)) < 0)\n            return ret;\n    } else {\n        if (asf->rep_data_len)\n            if ((ret = asf_read_replicated_data(s, asf_pkt)) < 0)\n                return ret;\n        pay_len = avio_rl16(pb); // payload length should be WORD\n        if (pay_len > asf->packet_size) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Error: invalid data packet size, pay_len %\"PRIu16\", \"\n                   \"asf->packet_size %\"PRIu32\", offset %\"PRId64\".\\n\",\n                   pay_len, asf->packet_size, avio_tell(pb));\n            return AVERROR_INVALIDDATA;\n        }\n        p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;\n        if (pay_len > asf_pkt->size_left) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Error: invalid buffer size, pay_len %d, data size left %d.\\n\",\n            pay_len, asf_pkt->size_left);\n            skip = pay_len - asf_pkt->size_left;\n            pay_len = asf_pkt->size_left;\n        }\n        if (asf_pkt->size_left <= 0)\n            return AVERROR_INVALIDDATA;\n        if ((ret = avio_read(pb, p, pay_len)) < 0)\n            return ret;\n        if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, p, ret);\n        avio_skip(pb, skip);\n        asf_pkt->size_left -= pay_len;\n        asf->nb_mult_left--;\n    }\n\n    return 0;\n}\n\nstatic int asf_read_single_payload(AVFormatContext *s, ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t  offset;\n    uint64_t size;\n    unsigned char *p;\n    int ret, data_size;\n\n    if (!asf_pkt->data_size) {\n        data_size = avio_rl32(pb); // read media object size\n        if (data_size <= 0)\n            return AVERROR_EOF;\n        if ((ret = av_new_packet(&asf_pkt->avpkt, data_size)) < 0)\n            return ret;\n        asf_pkt->data_size = asf_pkt->size_left = data_size;\n    } else\n        avio_skip(pb, 4); // skip media object size\n    asf_pkt->dts = avio_rl32(pb); // read presentation time\n    if (asf->rep_data_len >= 8)\n        avio_skip(pb, asf->rep_data_len - 8); // skip replicated data\n    offset = avio_tell(pb);\n\n    // size of the payload - size of the packet without header and padding\n    if (asf->packet_size_internal)\n        size = asf->packet_size_internal - offset + asf->packet_offset - asf->pad_len;\n    else\n        size = asf->packet_size - offset + asf->packet_offset - asf->pad_len;\n    if (size > asf->packet_size) {\n        av_log(s, AV_LOG_ERROR,\n               \"Error: invalid data packet size, offset %\"PRId64\".\\n\",\n               avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;\n    if (size > asf_pkt->size_left || asf_pkt->size_left <= 0)\n        return AVERROR_INVALIDDATA;\n    if (asf_pkt->size_left > size)\n        asf_pkt->size_left -= size;\n    else\n        asf_pkt->size_left = 0;\n    if ((ret = avio_read(pb, p, size)) < 0)\n        return ret;\n    if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, p, ret);\n    if (asf->packet_size_internal)\n        avio_skip(pb, asf->packet_size - asf->packet_size_internal);\n    avio_skip(pb, asf->pad_len); // skip padding\n\n    return 0;\n}\n\nstatic int asf_read_payload(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, i;\n    ASFPacket *asf_pkt = NULL;\n\n    if (!asf->sub_left) {\n        uint32_t off_len, media_len;\n        uint8_t stream_num;\n\n        stream_num = avio_r8(pb);\n        asf->stream_index = stream_num & ASF_STREAM_NUM;\n        for (i = 0; i < asf->nb_streams; i++) {\n            if (asf->stream_index == asf->asf_st[i]->stream_index) {\n                asf_pkt               = &asf->asf_st[i]->pkt;\n                asf_pkt->stream_index = asf->asf_st[i]->index;\n                break;\n            }\n        }\n        if (!asf_pkt) {\n            if (asf->packet_offset + asf->packet_size <= asf->data_offset + asf->data_size) {\n                if (!asf->packet_size) {\n                    av_log(s, AV_LOG_ERROR, \"Invalid packet size 0.\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n                av_log(s, AV_LOG_WARNING, \"Skipping the stream with the invalid stream index %d.\\n\",\n                       asf->stream_index);\n                return AVERROR(EAGAIN);\n            } else\n                return AVERROR_INVALIDDATA;\n        }\n\n        if (stream_num >> 7)\n            asf_pkt->flags |= AV_PKT_FLAG_KEY;\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_, media_len);\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_, off_len);\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_REPLICATED_DATA_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_, asf->rep_data_len);\n        if (asf_pkt->size_left && (asf_pkt->frame_num != media_len)) {\n            av_log(s, AV_LOG_WARNING, \"Unfinished frame will be ignored\\n\");\n            reset_packet(asf_pkt);\n        }\n        asf_pkt->frame_num = media_len;\n        asf->sub_dts = off_len;\n        if (asf->nb_mult_left) {\n            if ((ret = asf_read_multiple_payload(s, pkt, asf_pkt)) < 0)\n                return ret;\n        } else if (asf->rep_data_len == 1) {\n            asf->sub_left = 1;\n            asf->state    = READ_SINGLE;\n            pkt->flags    = asf_pkt->flags;\n            if ((ret = asf_read_subpayload(s, pkt, 1)) < 0)\n                return ret;\n        } else {\n            if ((ret = asf_read_single_payload(s, asf_pkt)) < 0)\n                return ret;\n        }\n    } else {\n        for (i = 0; i <= asf->nb_streams; i++) {\n            if (asf->stream_index == asf->asf_st[i]->stream_index) {\n                asf_pkt = &asf->asf_st[i]->pkt;\n                break;\n            }\n        }\n        if (!asf_pkt)\n            return AVERROR_INVALIDDATA;\n        pkt->flags         = asf_pkt->flags;\n        pkt->dts           = asf_pkt->dts;\n        pkt->stream_index  = asf->asf_st[i]->index;\n        if ((ret = asf_read_subpayload(s, pkt, 0)) < 0) // read subpayload without its header\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int asf_read_packet_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size;\n    uint32_t av_unused seq;\n    unsigned char error_flags, len_flags, pay_flags;\n\n    asf->packet_offset = avio_tell(pb);\n    error_flags = avio_r8(pb); // read Error Correction Flags\n    if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {\n        if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {\n            size = error_flags & ASF_PACKET_ERROR_CORRECTION_DATA_SIZE;\n            avio_skip(pb, size);\n        }\n        len_flags       = avio_r8(pb);\n    } else\n        len_flags = error_flags;\n    asf->prop_flags = avio_r8(pb);\n    READ_LEN(len_flags & ASF_PPI_MASK_PACKET_LENGTH_FIELD_SIZE,\n             ASF_PPI_FLAG_PACKET_LENGTH_FIELD_, asf->packet_size_internal);\n    READ_LEN(len_flags & ASF_PPI_MASK_SEQUENCE_FIELD_SIZE,\n             ASF_PPI_FLAG_SEQUENCE_FIELD_, seq);\n    READ_LEN(len_flags & ASF_PPI_MASK_PADDING_LENGTH_FIELD_SIZE,\n             ASF_PPI_FLAG_PADDING_LENGTH_FIELD_, asf->pad_len );\n    asf->send_time = avio_rl32(pb); // send time\n    avio_skip(pb, 2); // skip duration\n    if (len_flags & ASF_PPI_FLAG_MULTIPLE_PAYLOADS_PRESENT) { // Multiple Payloads present\n        pay_flags = avio_r8(pb);\n        asf->nb_mult_left = (pay_flags & ASF_NUM_OF_PAYLOADS);\n    }\n\n    return 0;\n}\n\nstatic int asf_deinterleave(AVFormatContext *s, ASFPacket *asf_pkt, int st_num)\n{\n    ASFContext *asf    = s->priv_data;\n    ASFStream *asf_st  = asf->asf_st[st_num];\n    unsigned char *p   = asf_pkt->avpkt.data;\n    uint16_t pkt_len   = asf->asf_st[st_num]->virtual_pkt_len;\n    uint16_t chunk_len = asf->asf_st[st_num]->virtual_chunk_len;\n    int nchunks        = pkt_len / chunk_len;\n    AVPacket pkt;\n    int pos = 0, j, l, ret;\n\n\n    if ((ret = av_new_packet(&pkt, asf_pkt->data_size)) < 0)\n        return ret;\n\n    while (asf_pkt->data_size >= asf_st->span * pkt_len + pos) {\n        if (pos >= asf_pkt->data_size) {\n            break;\n        }\n        for (l = 0; l < pkt_len; l++) {\n            if (pos >= asf_pkt->data_size) {\n                break;\n            }\n            for (j = 0; j < asf_st->span; j++) {\n                if ((pos + chunk_len) >= asf_pkt->data_size)\n                    break;\n                memcpy(pkt.data + pos,\n                       p + (j * nchunks + l) * chunk_len,\n                       chunk_len);\n                pos += chunk_len;\n            }\n        }\n        p += asf_st->span * pkt_len;\n        if (p > asf_pkt->avpkt.data + asf_pkt->data_size)\n            break;\n    }\n    av_packet_unref(&asf_pkt->avpkt);\n    asf_pkt->avpkt = pkt;\n\n    return 0;\n}\n\nstatic int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, i;\n\n    if ((avio_tell(pb) >= asf->data_offset + asf->data_size) &&\n        !(asf->b_flags & ASF_FLAG_BROADCAST))\n        return AVERROR_EOF;\n    while (!pb->eof_reached) {\n        if (asf->state == PARSE_PACKET_HEADER) {\n            asf_read_packet_header(s);\n            if (pb->eof_reached)\n                break;\n            if (!asf->nb_mult_left)\n                asf->state = READ_SINGLE;\n            else\n                asf->state = READ_MULTI;\n        }\n        ret = asf_read_payload(s, pkt);\n        if (ret == AVERROR(EAGAIN)) {\n            asf->state = PARSE_PACKET_HEADER;\n            continue;\n        }\n        else if (ret < 0)\n            return ret;\n\n        switch (asf->state) {\n        case READ_SINGLE:\n            if (!asf->sub_left)\n                asf->state = PARSE_PACKET_HEADER;\n            break;\n        case READ_MULTI_SUB:\n            if (!asf->sub_left && !asf->nb_mult_left) {\n                asf->state = PARSE_PACKET_HEADER;\n                if (!asf->return_subpayload &&\n                    (avio_tell(pb) <= asf->packet_offset +\n                     asf->packet_size - asf->pad_len))\n                    avio_skip(pb, asf->pad_len); // skip padding\n                if (asf->packet_offset + asf->packet_size > avio_tell(pb))\n                    avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            } else if (!asf->sub_left)\n                asf->state = READ_MULTI;\n            break;\n        case READ_MULTI:\n            if (!asf->nb_mult_left) {\n                asf->state = PARSE_PACKET_HEADER;\n                if (!asf->return_subpayload &&\n                    (avio_tell(pb) <= asf->packet_offset +\n                     asf->packet_size - asf->pad_len))\n                    avio_skip(pb, asf->pad_len); // skip padding\n                if (asf->packet_offset + asf->packet_size > avio_tell(pb))\n                    avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            }\n            break;\n        }\n        if (asf->return_subpayload) {\n            asf->return_subpayload = 0;\n            return 0;\n        }\n        for (i = 0; i < asf->nb_streams; i++) {\n            ASFPacket *asf_pkt = &asf->asf_st[i]->pkt;\n            if (asf_pkt && !asf_pkt->size_left && asf_pkt->data_size) {\n                if (asf->asf_st[i]->span > 1 &&\n                    asf->asf_st[i]->type == AVMEDIA_TYPE_AUDIO)\n                    if ((ret = asf_deinterleave(s, asf_pkt, i)) < 0)\n                        return ret;\n                av_packet_move_ref(pkt, &asf_pkt->avpkt);\n                pkt->stream_index  = asf->asf_st[i]->index;\n                pkt->flags         = asf_pkt->flags;\n                pkt->dts           = asf_pkt->dts - asf->preroll;\n                asf_pkt->data_size = 0;\n                asf_pkt->frame_num = 0;\n                return 0;\n            }\n        }\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int asf_read_close(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < ASF_MAX_STREAMS; i++) {\n        av_dict_free(&asf->asf_sd[i].asf_met);\n        if (i < asf->nb_streams) {\n            av_packet_unref(&asf->asf_st[i]->pkt.avpkt);\n            av_freep(&asf->asf_st[i]);\n        }\n    }\n\n    asf->nb_streams = 0;\n    return 0;\n}\n\nstatic void reset_packet_state(AVFormatContext *s)\n{\n    ASFContext *asf        = s->priv_data;\n    int i;\n\n    asf->state             = PARSE_PACKET_HEADER;\n    asf->offset            = 0;\n    asf->return_subpayload = 0;\n    asf->sub_left          = 0;\n    asf->sub_header_offset = 0;\n    asf->packet_offset     = asf->first_packet_offset;\n    asf->pad_len           = 0;\n    asf->rep_data_len      = 0;\n    asf->dts_delta         = 0;\n    asf->mult_sub_len      = 0;\n    asf->nb_mult_left      = 0;\n    asf->nb_sub            = 0;\n    asf->prop_flags        = 0;\n    asf->sub_dts           = 0;\n    for (i = 0; i < asf->nb_streams; i++) {\n        ASFPacket *pkt = &asf->asf_st[i]->pkt;\n        pkt->size_left = 0;\n        pkt->data_size = 0;\n        pkt->duration  = 0;\n        pkt->flags     = 0;\n        pkt->dts       = 0;\n        pkt->duration  = 0;\n        av_packet_unref(&pkt->avpkt);\n        av_init_packet(&pkt->avpkt);\n    }\n}\n\n/*\n * Find a timestamp for the requested position within the payload\n * where the pos (position) is the offset inside the Data Object.\n * When position is not on the packet boundary, asf_read_timestamp tries\n * to find the closest packet offset after this position. If this packet\n * is a key frame, this packet timestamp is read and an index entry is created\n * for the packet. If this packet belongs to the requested stream,\n * asf_read_timestamp upgrades pos to the packet beginning offset and\n * returns this packet's dts. So returned dts is the dts of the first key frame with\n * matching stream number after given position.\n */\nstatic int64_t asf_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos, int64_t pos_limit)\n{\n    ASFContext *asf = s->priv_data;\n    int64_t pkt_pos = *pos, pkt_offset, dts = AV_NOPTS_VALUE, data_end;\n    AVPacket pkt;\n    int n;\n\n    data_end = asf->data_offset + asf->data_size;\n\n    n = (pkt_pos - asf->first_packet_offset + asf->packet_size - 1) /\n        asf->packet_size;\n    n = av_clip(n, 0, ((data_end - asf->first_packet_offset) / asf->packet_size - 1));\n    pkt_pos = asf->first_packet_offset +  n * asf->packet_size;\n\n    avio_seek(s->pb, pkt_pos, SEEK_SET);\n    pkt_offset = pkt_pos;\n\n    reset_packet_state(s);\n    while (avio_tell(s->pb) < data_end) {\n\n        int i, ret, st_found;\n\n        av_init_packet(&pkt);\n        pkt_offset = avio_tell(s->pb);\n        if ((ret = asf_read_packet(s, &pkt)) < 0) {\n            dts = AV_NOPTS_VALUE;\n            return ret;\n        }\n        // ASFPacket may contain fragments of packets belonging to different streams,\n        // pkt_offset is the offset of the first fragment within it.\n        if ((pkt_offset >= (pkt_pos + asf->packet_size)))\n            pkt_pos += asf->packet_size;\n        for (i = 0; i < asf->nb_streams; i++) {\n            ASFStream *st = asf->asf_st[i];\n\n            st_found = 0;\n            if (pkt.flags & AV_PKT_FLAG_KEY) {\n                dts = pkt.dts;\n                if (dts) {\n                    av_add_index_entry(s->streams[pkt.stream_index], pkt_pos,\n                                       dts, pkt.size, 0, AVINDEX_KEYFRAME);\n                    if (stream_index == st->index) {\n                        st_found = 1;\n                        break;\n                    }\n                }\n            }\n        }\n        if (st_found)\n            break;\n        av_packet_unref(&pkt);\n    }\n    *pos = pkt_pos;\n\n    av_packet_unref(&pkt);\n    return dts;\n}\n\nstatic int asf_read_seek(AVFormatContext *s, int stream_index,\n                         int64_t timestamp, int flags)\n{\n    ASFContext *asf = s->priv_data;\n    int idx, ret;\n\n    if (s->streams[stream_index]->nb_index_entries && asf->is_simple_index) {\n        idx = av_index_search_timestamp(s->streams[stream_index], timestamp, flags);\n        if (idx < 0 || idx >= s->streams[stream_index]->nb_index_entries)\n            return AVERROR_INVALIDDATA;\n        avio_seek(s->pb, s->streams[stream_index]->index_entries[idx].pos, SEEK_SET);\n    } else {\n        if ((ret = ff_seek_frame_binary(s, stream_index, timestamp, flags)) < 0)\n            return ret;\n    }\n\n    reset_packet_state(s);\n\n    return 0;\n}\n\nstatic const GUIDParseTable *find_guid(ff_asf_guid guid)\n{\n    int j, ret;\n    const GUIDParseTable *g;\n\n    swap_guid(guid);\n    g = gdef;\n    for (j = 0; j < FF_ARRAY_ELEMS(gdef); j++) {\n        if (!(ret = memcmp(guid, g->guid, sizeof(g->guid))))\n            return g;\n        g++;\n    }\n\n    return NULL;\n}\n\nstatic int detect_unknown_subobject(AVFormatContext *s, int64_t offset, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    const GUIDParseTable *g = NULL;\n    ff_asf_guid guid;\n    int ret;\n\n    while (avio_tell(pb) <= offset + size) {\n        if (avio_tell(pb) == asf->offset)\n            break;\n        asf->offset = avio_tell(pb);\n        if ((ret = ff_get_guid(pb, &guid)) < 0)\n            return ret;\n        g = find_guid(guid);\n        if (g) {\n            if ((ret = g->read_object(s, g)) < 0)\n                return ret;\n        } else {\n            GUIDParseTable g2;\n\n            g2.name         = \"Unknown\";\n            g2.is_subobject = 1;\n            asf_read_unknown(s, &g2);\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_header(AVFormatContext *s)\n{\n    ASFContext *asf         = s->priv_data;\n    AVIOContext *pb         = s->pb;\n    const GUIDParseTable *g = NULL;\n    ff_asf_guid guid;\n    int i, ret;\n    uint64_t size;\n\n    asf->preroll         = 0;\n    asf->is_simple_index = 0;\n    ff_get_guid(pb, &guid);\n    if (ff_guidcmp(&guid, &ff_asf_header))\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8); // skip header object size\n    avio_skip(pb, 6); // skip number of header objects and 2 reserved bytes\n    asf->data_reached = 0;\n\n    /* 1  is here instead of pb->eof_reached because (when not streaming), Data are skipped\n     * for the first time,\n     * Index object is processed and got eof and then seeking back to the Data is performed.\n     */\n    while (1) {\n        // for the cases when object size is invalid\n        if (avio_tell(pb) == asf->offset)\n            break;\n        asf->offset = avio_tell(pb);\n        if ((ret = ff_get_guid(pb, &guid)) < 0) {\n            if (ret == AVERROR_EOF && asf->data_reached)\n                break;\n            else\n                goto failed;\n        }\n        g = find_guid(guid);\n        if (g) {\n            asf->unknown_offset = asf->offset;\n            asf->is_header = 1;\n            if ((ret = g->read_object(s, g)) < 0)\n                goto failed;\n        } else {\n            size = avio_rl64(pb);\n            align_position(pb, asf->offset, size);\n        }\n        if (asf->data_reached &&\n            (!(pb->seekable & AVIO_SEEKABLE_NORMAL) ||\n             (asf->b_flags & ASF_FLAG_BROADCAST)))\n            break;\n    }\n\n    if (!asf->data_reached) {\n        av_log(s, AV_LOG_ERROR, \"Data Object was not found.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto failed;\n    }\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        avio_seek(pb, asf->first_packet_offset, SEEK_SET);\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        const char *rfc1766 = asf->asf_sd[asf->asf_st[i]->lang_idx].langs;\n        AVStream *st        = s->streams[asf->asf_st[i]->index];\n        set_language(s, rfc1766, &st->metadata);\n    }\n\n    for (i = 0; i < ASF_MAX_STREAMS; i++) {\n        AVStream *st = NULL;\n\n        st = find_stream(s, i);\n        if (st) {\n            av_dict_copy(&st->metadata, asf->asf_sd[i].asf_met, AV_DICT_IGNORE_SUFFIX);\n            if (asf->asf_sd[i].aspect_ratio.num > 0 && asf->asf_sd[i].aspect_ratio.den > 0) {\n                st->sample_aspect_ratio.num = asf->asf_sd[i].aspect_ratio.num;\n                st->sample_aspect_ratio.den = asf->asf_sd[i].aspect_ratio.den;\n            }\n        }\n    }\n\n    return 0;\n\nfailed:\n    asf_read_close(s);\n    return ret;\n}\n\nAVInputFormat ff_asf_o_demuxer = {\n    .name           = \"asf_o\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"ASF (Advanced / Active Streaming Format)\"),\n    .priv_data_size = sizeof(ASFContext),\n    .read_probe     = asf_probe,\n    .read_header    = asf_read_header,\n    .read_packet    = asf_read_packet,\n    .read_close     = asf_read_close,\n    .read_timestamp = asf_read_timestamp,\n    .read_seek      = asf_read_seek,\n    .flags          = AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH,\n};\n"], "fixing_code": ["/*\n * Microsoft Advanced Streaming Format demuxer\n * Copyright (c) 2014 Alexandra H\u00e1jkov\u00e1\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/bswap.h\"\n#include \"libavutil/common.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/time_internal.h\"\n\n#include \"avformat.h\"\n#include \"avio_internal.h\"\n#include \"avlanguage.h\"\n#include \"id3v2.h\"\n#include \"internal.h\"\n#include \"riff.h\"\n#include \"asf.h\"\n#include \"asfcrypt.h\"\n\n#define ASF_BOOL                              0x2\n#define ASF_WORD                              0x5\n#define ASF_GUID                              0x6\n#define ASF_DWORD                             0x3\n#define ASF_QWORD                             0x4\n#define ASF_UNICODE                           0x0\n#define ASF_FLAG_BROADCAST                    0x1\n#define ASF_BYTE_ARRAY                        0x1\n#define ASF_TYPE_AUDIO                        0x2\n#define ASF_TYPE_VIDEO                        0x1\n#define ASF_STREAM_NUM                        0x7F\n#define ASF_MAX_STREAMS                       128\n#define BMP_HEADER_SIZE                       40\n#define ASF_NUM_OF_PAYLOADS                   0x3F\n#define ASF_ERROR_CORRECTION_LENGTH_TYPE      0x60\n#define ASF_PACKET_ERROR_CORRECTION_DATA_SIZE 0x2\n\ntypedef struct GUIDParseTable {\n    const char *name;\n    ff_asf_guid guid;\n    int (*read_object)(AVFormatContext *, const struct GUIDParseTable *);\n    int is_subobject;\n} GUIDParseTable;\n\ntypedef struct ASFPacket {\n    AVPacket avpkt;\n    int64_t dts;\n    uint32_t frame_num; // ASF payloads with the same number are parts of the same frame\n    int flags;\n    int data_size;\n    int duration;\n    int size_left;\n    uint8_t stream_index;\n} ASFPacket;\n\ntypedef struct ASFStream {\n    uint8_t stream_index; // from packet header\n    int index;  // stream index in AVFormatContext, set in asf_read_stream_properties\n    int type;\n    int indexed; // added index entries from the Simple Index Object or not\n    int8_t span;   // for deinterleaving\n    uint16_t virtual_pkt_len;\n    uint16_t virtual_chunk_len;\n    int16_t lang_idx;\n    ASFPacket pkt;\n} ASFStream;\n\ntypedef struct ASFStreamData{\n    char langs[32];\n    AVDictionary *asf_met; // for storing per-stream metadata\n    AVRational aspect_ratio;\n} ASFStreamData;\n\ntypedef struct ASFContext {\n    int data_reached;\n    int is_simple_index; // is simple index present or not 1/0\n    int is_header;\n\n    uint64_t preroll;\n    uint64_t nb_packets; // ASF packets\n    uint32_t packet_size;\n    int64_t send_time;\n    int duration;\n\n    uint32_t b_flags;    // flags with broadcast flag\n    uint32_t prop_flags; // file properties object flags\n\n    uint64_t data_size; // data object size\n    uint64_t unknown_size; // size of the unknown object\n\n    int64_t offset; // offset of the current object\n\n    int64_t data_offset;\n    int64_t first_packet_offset; // packet offset\n    int64_t unknown_offset;   // for top level header objects or subobjects without specified behavior\n\n    // ASF file must not contain more than 128 streams according to the specification\n    ASFStream *asf_st[ASF_MAX_STREAMS];\n    ASFStreamData asf_sd[ASF_MAX_STREAMS];\n    int nb_streams;\n\n    int stream_index; // from packet header, for the subpayload case\n\n    // packet parameters\n    uint64_t sub_header_offset; // offset of subpayload header\n    int64_t sub_dts;\n    uint8_t dts_delta; // for subpayloads\n    uint32_t packet_size_internal; // packet size stored inside ASFPacket, can be 0\n    int64_t packet_offset; // offset of the current packet inside Data Object\n    uint32_t pad_len; // padding after payload\n    uint32_t rep_data_len;\n\n    // packet state\n    uint64_t sub_left;  // subpayloads left or not\n    unsigned int nb_sub; // number of subpayloads read so far from the current ASF packet\n    uint16_t mult_sub_len; // total length of subpayloads array inside multiple payload\n    uint64_t nb_mult_left; // multiple payloads left\n    int return_subpayload;\n    enum {\n        PARSE_PACKET_HEADER,\n        READ_SINGLE,\n        READ_MULTI,\n        READ_MULTI_SUB\n    } state;\n} ASFContext;\n\nstatic int detect_unknown_subobject(AVFormatContext *s, int64_t offset, int64_t size);\nstatic const GUIDParseTable *find_guid(ff_asf_guid guid);\n\nstatic int asf_probe(AVProbeData *pd)\n{\n    /* check file header */\n    if (!ff_guidcmp(pd->buf, &ff_asf_header))\n        return AVPROBE_SCORE_MAX/2;\n    else\n        return 0;\n}\n\nstatic void swap_guid(ff_asf_guid guid)\n{\n    FFSWAP(unsigned char, guid[0], guid[3]);\n    FFSWAP(unsigned char, guid[1], guid[2]);\n    FFSWAP(unsigned char, guid[4], guid[5]);\n    FFSWAP(unsigned char, guid[6], guid[7]);\n}\n\nstatic void align_position(AVIOContext *pb,  int64_t offset, uint64_t size)\n{\n    if (size < INT64_MAX - offset && avio_tell(pb) != offset + size)\n        avio_seek(pb, offset + size, SEEK_SET);\n}\n\nstatic int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int ret;\n\n    if (size > INT64_MAX)\n        return AVERROR_INVALIDDATA;\n\n    if (asf->is_header)\n        asf->unknown_size = size;\n    asf->is_header = 0;\n    if (!g->is_subobject) {\n        if (!(ret = strcmp(g->name, \"Header Extension\")))\n            avio_skip(pb, 22); // skip reserved fields and Data Size\n        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,\n                                            asf->unknown_size)) < 0)\n            return ret;\n    } else {\n        if (size < 24) {\n            av_log(s, AV_LOG_ERROR, \"Too small size %\"PRIu64\" (< 24).\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        avio_skip(pb, size - 24);\n    }\n\n    return 0;\n}\n\nstatic int get_asf_string(AVIOContext *pb, int maxlen, char *buf, int buflen)\n{\n    char *q = buf;\n    int ret = 0;\n    if (buflen <= 0)\n        return AVERROR(EINVAL);\n    while (ret + 1 < maxlen) {\n        uint8_t tmp;\n        uint32_t ch;\n        GET_UTF16(ch, (ret += 2) <= maxlen ? avio_rl16(pb) : 0, break;);\n        PUT_UTF8(ch, tmp, if (q - buf < buflen - 1) *q++ = tmp;)\n    }\n    *q = 0;\n\n    return ret;\n}\n\nstatic int asf_read_marker(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = avio_rl64(pb);\n    int i, nb_markers, ret;\n    size_t len;\n    char name[1024];\n\n    avio_skip(pb, 8);\n    avio_skip(pb, 8); // skip reserved GUID\n    nb_markers = avio_rl32(pb);\n    avio_skip(pb, 2); // skip reserved field\n    len = avio_rl16(pb);\n    for (i = 0; i < len; i++)\n        avio_skip(pb, 1);\n\n    for (i = 0; i < nb_markers; i++) {\n        int64_t pts;\n\n        avio_skip(pb, 8);\n        pts = avio_rl64(pb);\n        pts -= asf->preroll * 10000;\n        avio_skip(pb, 2); // entry length\n        avio_skip(pb, 4); // send time\n        avio_skip(pb, 4); // flags\n        len = avio_rl32(pb);\n\n        if ((ret = avio_get_str16le(pb, len, name,\n                                    sizeof(name))) < len)\n            avio_skip(pb, len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pts,\n                           AV_NOPTS_VALUE, name);\n    }\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic int asf_read_metadata(AVFormatContext *s, const char *title, uint16_t len,\n                             unsigned char *ch, uint16_t buflen)\n{\n    AVIOContext *pb = s->pb;\n\n    avio_get_str16le(pb, len, ch, buflen);\n    if (ch[0]) {\n        if (av_dict_set(&s->metadata, title, ch, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n\n    return 0;\n}\n\nstatic int asf_read_value(AVFormatContext *s, const uint8_t *name,\n                          uint16_t val_len, int type, AVDictionary **met)\n{\n    int ret;\n    uint8_t *value;\n    uint16_t buflen = 2 * val_len + 1;\n    AVIOContext *pb = s->pb;\n\n    value = av_malloc(buflen);\n    if (!value)\n        return AVERROR(ENOMEM);\n    if (type == ASF_UNICODE) {\n        // get_asf_string reads UTF-16 and converts it to UTF-8 which needs longer buffer\n        if ((ret = get_asf_string(pb, val_len, value, buflen)) < 0)\n            goto failed;\n        if (av_dict_set(met, name, value, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    } else {\n        char buf[256];\n        if (val_len > sizeof(buf)) {\n            ret = AVERROR_INVALIDDATA;\n            goto failed;\n        }\n        if ((ret = avio_read(pb, value, val_len)) < 0)\n            goto failed;\n        if (ret < 2 * val_len)\n            value[ret] = '\\0';\n        else\n            value[2 * val_len - 1] = '\\0';\n        snprintf(buf, sizeof(buf), \"%s\", value);\n        if (av_dict_set(met, name, buf, 0) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n    av_freep(&value);\n\n    return 0;\n\nfailed:\n    av_freep(&value);\n    return ret;\n}\nstatic int asf_read_generic_value(AVIOContext *pb, int type, uint64_t *value)\n{\n\n    switch (type) {\n    case ASF_BOOL:\n        *value = avio_rl16(pb);\n        break;\n    case ASF_DWORD:\n        *value = avio_rl32(pb);\n        break;\n    case ASF_QWORD:\n        *value = avio_rl64(pb);\n        break;\n    case ASF_WORD:\n        *value = avio_rl16(pb);\n        break;\n    default:\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int asf_set_metadata(AVFormatContext *s, const uint8_t *name,\n                            int type, AVDictionary **met)\n{\n    AVIOContext *pb = s->pb;\n    uint64_t value;\n    char buf[32];\n    int ret;\n\n    ret = asf_read_generic_value(pb, type, &value);\n    if (ret < 0)\n        return ret;\n\n    snprintf(buf, sizeof(buf), \"%\"PRIu64, value);\n    if (av_dict_set(met, name, buf, 0) < 0)\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    return 0;\n}\n\n/* MSDN claims that this should be \"compatible with the ID3 frame, APIC\",\n * but in reality this is only loosely similar */\nstatic int asf_read_picture(AVFormatContext *s, int len)\n{\n    ASFContext *asf       = s->priv_data;\n    AVPacket pkt          = { 0 };\n    const CodecMime *mime = ff_id3v2_mime_tags;\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n    char mimetype[64];\n    uint8_t  *desc = NULL;\n    AVStream   *st = NULL;\n    int ret, type, picsize, desc_len;\n    ASFStream *asf_st;\n\n    /* type + picsize + mime + desc */\n    if (len < 1 + 4 + 2 + 2) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture type */\n    type = avio_r8(s->pb);\n    len--;\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n        type = 0;\n    }\n\n    /* picture data size */\n    picsize = avio_rl32(s->pb);\n    len    -= 4;\n\n    /* picture MIME type */\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n    while (mime->id != AV_CODEC_ID_NONE) {\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n            id = mime->id;\n            break;\n        }\n        mime++;\n    }\n    if (id == AV_CODEC_ID_NONE) {\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n               mimetype);\n        return 0;\n    }\n\n    if (picsize >= len) {\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n               picsize, len);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* picture description */\n    desc_len = (len - picsize) * 2 + 1;\n    desc     = av_malloc(desc_len);\n    if (!desc)\n        return AVERROR(ENOMEM);\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n    if (ret < 0)\n        goto fail;\n\n    st  = avformat_new_stream(s, NULL);\n    if (!st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n    asf_st = asf->asf_st[asf->nb_streams];\n    if (!asf_st) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n    st->codecpar->codec_type      = asf_st->type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id        = id;\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = asf_st->index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    asf->nb_streams++;\n\n    if (*desc) {\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    } else\n        av_freep(&desc);\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    return 0;\n\nfail:\n    av_freep(&desc);\n    av_packet_unref(&pkt);\n    return ret;\n}\n\nstatic void get_id3_tag(AVFormatContext *s, int len)\n{\n    ID3v2ExtraMeta *id3v2_extra_meta = NULL;\n\n    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta, len);\n    if (id3v2_extra_meta) {\n        ff_id3v2_parse_apic(s, &id3v2_extra_meta);\n        ff_id3v2_parse_chapters(s, &id3v2_extra_meta);\n    }\n    ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n}\n\nstatic int process_metadata(AVFormatContext *s, const uint8_t *name, uint16_t name_len,\n                            uint16_t val_len, uint16_t type, AVDictionary **met)\n{\n    int ret;\n    ff_asf_guid guid;\n\n    if (val_len) {\n        switch (type) {\n        case ASF_UNICODE:\n            asf_read_value(s, name, val_len, type, met);\n            break;\n        case ASF_BYTE_ARRAY:\n            if (!strcmp(name, \"WM/Picture\")) // handle cover art\n                asf_read_picture(s, val_len);\n            else if (!strcmp(name, \"ID3\")) // handle ID3 tag\n                get_id3_tag(s, val_len);\n            else\n                asf_read_value(s, name, val_len, type, met);\n            break;\n        case ASF_GUID:\n            ff_get_guid(s->pb, &guid);\n            break;\n        default:\n            if ((ret = asf_set_metadata(s, name, type, met)) < 0)\n                return ret;\n            break;\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf  = s->priv_data;\n    AVIOContext *pb  = s->pb;\n    uint64_t size    = avio_rl64(pb);\n    uint16_t nb_desc = avio_rl16(pb);\n    int i, ret;\n\n    for (i = 0; i < nb_desc; i++) {\n        uint16_t name_len, type, val_len;\n        uint8_t *name = NULL;\n\n        name_len = avio_rl16(pb);\n        if (!name_len)\n            return AVERROR_INVALIDDATA;\n        name = av_malloc(name_len);\n        if (!name)\n            return AVERROR(ENOMEM);\n        avio_get_str16le(pb, name_len, name,\n                         name_len);\n        type    = avio_rl16(pb);\n        // BOOL values are 16 bits long in the Metadata Object\n        // but 32 bits long in the Extended Content Description Object\n        if (type == ASF_BOOL)\n            type = ASF_DWORD;\n        val_len = avio_rl16(pb);\n\n        ret = process_metadata(s, name, name_len, val_len, type, &s->metadata);\n        av_freep(&name);\n        if (ret < 0)\n            return ret;\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic AVStream *find_stream(AVFormatContext *s, uint16_t st_num)\n{\n    AVStream *st = NULL;\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (asf->asf_st[i]->stream_index == st_num) {\n            st = s->streams[asf->asf_st[i]->index];\n            break;\n        }\n    }\n\n    return st;\n}\n\nstatic int asf_store_aspect_ratio(AVFormatContext *s, uint8_t st_num, uint8_t *name, int type)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    uint64_t value = 0;\n    int ret;\n\n    ret = asf_read_generic_value(pb, type, &value);\n    if (ret < 0)\n        return ret;\n\n    if (st_num < ASF_MAX_STREAMS) {\n        if (!strcmp(name, \"AspectRatioX\"))\n            asf->asf_sd[st_num].aspect_ratio.num = value;\n        else\n            asf->asf_sd[st_num].aspect_ratio.den = value;\n    }\n    return 0;\n}\n\nstatic int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    uint64_t size     = avio_rl64(pb);\n    uint16_t nb_recs  = avio_rl16(pb); // number of records in the Description Records list\n    int i, ret;\n\n    for (i = 0; i < nb_recs; i++) {\n        uint16_t name_len, buflen, type, val_len, st_num;\n        uint8_t *name = NULL;\n\n        avio_skip(pb, 2); // skip reserved field\n        st_num   = avio_rl16(pb);\n        name_len = avio_rl16(pb);\n        buflen   = 2 * name_len + 1;\n        if (!name_len)\n            break;\n        type     = avio_rl16(pb);\n        val_len  = avio_rl32(pb);\n        name     = av_malloc(buflen);\n        if (!name)\n            return AVERROR(ENOMEM);\n        avio_get_str16le(pb, name_len, name,\n                         buflen);\n        if (!strcmp(name, \"AspectRatioX\") || !strcmp(name, \"AspectRatioY\")) {\n            ret = asf_store_aspect_ratio(s, st_num, name, type);\n            if (ret < 0) {\n                av_freep(&name);\n                break;\n            }\n        } else {\n            if (st_num < ASF_MAX_STREAMS) {\n                if ((ret = process_metadata(s, name, name_len, val_len, type,\n                                            &asf->asf_sd[st_num].asf_met)) < 0) {\n                    av_freep(&name);\n                    break;\n                }\n            }\n        }\n        av_freep(&name);\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic int asf_read_content_desc(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int i;\n    static const char *const titles[] =\n    { \"Title\", \"Author\", \"Copyright\", \"Description\", \"Rate\" };\n    uint16_t len[5], buflen[5] = { 0 };\n    uint8_t *ch;\n    uint64_t size = avio_rl64(pb);\n\n    for (i = 0; i < 5; i++) {\n        len[i]  = avio_rl16(pb);\n        // utf8 string should be <= 2 * utf16 string, extra byte for the terminator\n        buflen[i]  = 2 * len[i] + 1;\n    }\n\n    for (i = 0; i < 5; i++) {\n        ch = av_malloc(buflen[i]);\n        if (!ch)\n            return(AVERROR(ENOMEM));\n        asf_read_metadata(s, titles[i], len[i], ch, buflen[i]);\n        av_freep(&ch);\n    }\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic int asf_read_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    time_t creation_time;\n\n    avio_rl64(pb); // read object size\n    avio_skip(pb, 16); // skip File ID\n    avio_skip(pb, 8);  // skip File size\n    creation_time = avio_rl64(pb);\n    if (!(asf->b_flags & ASF_FLAG_BROADCAST)) {\n        struct tm tmbuf;\n        struct tm *tm;\n        char buf[64];\n\n        // creation date is in 100 ns units from 1 Jan 1601, conversion to s\n        creation_time /= 10000000;\n        // there are 11644473600 seconds between 1 Jan 1601 and 1 Jan 1970\n        creation_time -= 11644473600;\n        tm = gmtime_r(&creation_time, &tmbuf);\n        if (tm) {\n            if (!strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n                buf[0] = '\\0';\n        } else\n            buf[0] = '\\0';\n        if (buf[0]) {\n            if (av_dict_set(&s->metadata, \"creation_time\", buf, 0) < 0)\n                av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n        }\n    }\n    asf->nb_packets  = avio_rl64(pb);\n    asf->duration    = avio_rl64(pb) / 10000; // stream duration\n    avio_skip(pb, 8); // skip send duration\n    asf->preroll     = avio_rl64(pb);\n    asf->duration   -= asf->preroll;\n    asf->b_flags     = avio_rl32(pb);\n    avio_skip(pb, 4); // skip minimal packet size\n    asf->packet_size  = avio_rl32(pb);\n    avio_skip(pb, 4); // skip max_bitrate\n\n    return 0;\n}\n\nstatic int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; // ASF-specific Format Data size\n    uint32_t size_bmp; // BMP_HEADER-specific Format Data size\n    unsigned int tag;\n\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); // skip reserved flags\n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n\n    if (size_bmp > BMP_HEADER_SIZE &&\n        size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}\n\nstatic int asf_read_stream_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size;\n    uint32_t err_data_len, ts_data_len; // type specific data length\n    uint16_t flags;\n    ff_asf_guid stream_type;\n    enum AVMediaType type;\n    int i, ret;\n    uint8_t stream_index;\n    AVStream *st;\n    ASFStream *asf_st;\n\n    // ASF file must not contain more than 128 streams according to the specification\n    if (asf->nb_streams >= ASF_MAX_STREAMS)\n        return AVERROR_INVALIDDATA;\n\n    size = avio_rl64(pb);\n    ff_get_guid(pb, &stream_type);\n    if (!ff_guidcmp(&stream_type, &ff_asf_audio_stream))\n        type = AVMEDIA_TYPE_AUDIO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_video_stream))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_jfif_media))\n        type = AVMEDIA_TYPE_VIDEO;\n    else if (!ff_guidcmp(&stream_type, &ff_asf_command_stream))\n        type = AVMEDIA_TYPE_DATA;\n    else if (!ff_guidcmp(&stream_type,\n                         &ff_asf_ext_stream_embed_stream_header))\n        type = AVMEDIA_TYPE_UNKNOWN;\n    else\n        return AVERROR_INVALIDDATA;\n\n    ff_get_guid(pb, &stream_type); // error correction type\n    avio_skip(pb, 8); // skip the time offset\n    ts_data_len      = avio_rl32(pb);\n    err_data_len     = avio_rl32(pb);\n    flags            = avio_rl16(pb); // bit 15 - Encrypted Content\n\n    stream_index = flags & ASF_STREAM_NUM;\n    for (i = 0; i < asf->nb_streams; i++)\n        if (stream_index == asf->asf_st[i]->stream_index) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Duplicate stream found, this stream will be ignored.\\n\");\n            align_position(pb, asf->offset, size);\n            return 0;\n        }\n\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    avpriv_set_pts_info(st, 32, 1, 1000); // pts should be dword, in milliseconds\n    st->codecpar->codec_type = type;\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n    if (!asf->asf_st[asf->nb_streams])\n        return AVERROR(ENOMEM);\n    asf_st                       = asf->asf_st[asf->nb_streams];\n    asf->nb_streams++;\n    asf_st->stream_index         = stream_index;\n    asf_st->index                = st->index;\n    asf_st->indexed              = 0;\n    st->id                       = flags & ASF_STREAM_NUM;\n    av_init_packet(&asf_st->pkt.avpkt);\n    asf_st->pkt.data_size        = 0;\n    avio_skip(pb, 4); // skip reserved field\n\n    switch (type) {\n    case AVMEDIA_TYPE_AUDIO:\n        asf_st->type = AVMEDIA_TYPE_AUDIO;\n        if ((ret = ff_get_wav_header(s, pb, st->codecpar, ts_data_len, 0)) < 0)\n            return ret;\n        break;\n    case AVMEDIA_TYPE_VIDEO:\n        asf_st->type = AVMEDIA_TYPE_VIDEO;\n        if ((ret = parse_video_info(pb, st)) < 0)\n            return ret;\n        break;\n    default:\n        avio_skip(pb, ts_data_len);\n        break;\n    }\n\n    if (err_data_len) {\n        if (type == AVMEDIA_TYPE_AUDIO) {\n            uint8_t span = avio_r8(pb);\n            if (span > 1) {\n                asf_st->span              = span;\n                asf_st->virtual_pkt_len   = avio_rl16(pb);\n                asf_st->virtual_chunk_len = avio_rl16(pb);\n                if (!asf_st->virtual_chunk_len || !asf_st->virtual_pkt_len)\n                    return AVERROR_INVALIDDATA;\n                avio_skip(pb, err_data_len - 5);\n            } else\n                avio_skip(pb, err_data_len - 1);\n        } else\n            avio_skip(pb, err_data_len);\n    }\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic void set_language(AVFormatContext *s, const char *rfc1766, AVDictionary **met)\n{\n    // language abbr should contain at least 2 chars\n    if (rfc1766 && strlen(rfc1766) > 1) {\n        const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\\0' }; // ignore country code if any\n        const char *iso6392       = ff_convert_lang_to(primary_tag,\n                                                       AV_LANG_ISO639_2_BIBL);\n        if (iso6392)\n            if (av_dict_set(met, \"language\", iso6392, 0) < 0)\n                av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n    }\n}\n\nstatic int asf_read_ext_stream_properties(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st    = NULL;\n    ff_asf_guid guid;\n    uint16_t nb_st_name, nb_pay_exts, st_num, lang_idx;\n    int i, ret;\n    uint32_t bitrate;\n    uint64_t start_time, end_time, time_per_frame;\n    uint64_t size = avio_rl64(pb);\n\n    start_time = avio_rl64(pb);\n    end_time   = avio_rl64(pb);\n    bitrate    = avio_rl32(pb);\n    avio_skip(pb, 28); // skip some unused values\n    st_num     = avio_rl16(pb);\n    st_num    &= ASF_STREAM_NUM;\n    lang_idx   = avio_rl16(pb); // Stream Language ID Index\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (st_num == asf->asf_st[i]->stream_index) {\n            st                       = s->streams[asf->asf_st[i]->index];\n            asf->asf_st[i]->lang_idx = lang_idx;\n            break;\n        }\n    }\n    time_per_frame = avio_rl64(pb); // average time per frame\n    if (st) {\n        st->start_time           = start_time;\n        st->duration             = end_time - start_time;\n        st->codecpar->bit_rate   = bitrate;\n        st->avg_frame_rate.num   = 10000000;\n        st->avg_frame_rate.den   = time_per_frame;\n    }\n    nb_st_name = avio_rl16(pb);\n    nb_pay_exts   = avio_rl16(pb);\n    for (i = 0; i < nb_st_name; i++) {\n        uint16_t len;\n\n        avio_rl16(pb); // Language ID Index\n        len = avio_rl16(pb);\n        avio_skip(pb, len);\n    }\n\n    for (i = 0; i < nb_pay_exts; i++) {\n        uint32_t len;\n        avio_skip(pb, 16); // Extension System ID\n        avio_skip(pb, 2);  // Extension Data Size\n        len = avio_rl32(pb);\n        avio_skip(pb, len);\n    }\n\n    if ((ret = ff_get_guid(pb, &guid)) < 0) {\n        align_position(pb, asf->offset, size);\n\n        return 0;\n    }\n\n    g = find_guid(guid);\n    if (g && !(strcmp(g->name, \"Stream Properties\"))) {\n        if ((ret = g->read_object(s, g)) < 0)\n            return ret;\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\nstatic int asf_read_language_list(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf   = s->priv_data;\n    AVIOContext *pb   = s->pb;\n    int i, ret;\n    uint64_t size     = avio_rl64(pb);\n    uint16_t nb_langs = avio_rl16(pb);\n\n    if (nb_langs < ASF_MAX_STREAMS) {\n        for (i = 0; i < nb_langs; i++) {\n            size_t len;\n            len = avio_r8(pb);\n            if (!len)\n                len = 6;\n            if ((ret = get_asf_string(pb, len, asf->asf_sd[i].langs,\n                                      sizeof(asf->asf_sd[i].langs))) < 0) {\n                return ret;\n            }\n        }\n    }\n\n    align_position(pb, asf->offset, size);\n    return 0;\n}\n\n// returns data object offset when reading this object for the first time\nstatic int asf_read_data(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size   = asf->data_size = avio_rl64(pb);\n    int i;\n\n    if (!asf->data_reached) {\n        asf->data_reached       = 1;\n        asf->data_offset        = asf->offset;\n    }\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (!(asf->b_flags & ASF_FLAG_BROADCAST))\n            s->streams[i]->duration = asf->duration;\n    }\n    asf->nb_mult_left           = 0;\n    asf->sub_left               = 0;\n    asf->state                  = PARSE_PACKET_HEADER;\n    asf->return_subpayload      = 0;\n    asf->packet_size_internal   = 0;\n    avio_skip(pb, 16); // skip File ID\n    size = avio_rl64(pb); // Total Data Packets\n    if (size != asf->nb_packets)\n        av_log(s, AV_LOG_WARNING,\n               \"Number of Packets from File Properties Object is not equal to Total\"\n               \"Datapackets value! num of packets %\"PRIu64\" total num %\"PRIu64\".\\n\",\n               size, asf->nb_packets);\n    avio_skip(pb, 2); // skip reserved field\n    asf->first_packet_offset = avio_tell(pb);\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !(asf->b_flags & ASF_FLAG_BROADCAST))\n        align_position(pb, asf->offset, asf->data_size);\n\n    return 0;\n}\n\nstatic int asf_read_simple_index(AVFormatContext *s, const GUIDParseTable *g)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st    = NULL;\n    uint64_t interval; // index entry time interval in 100 ns units, usually it's 1s\n    uint32_t pkt_num, nb_entries;\n    int32_t prev_pkt_num = -1;\n    int i;\n    int64_t offset;\n    uint64_t size = avio_rl64(pb);\n\n    // simple index objects should be ordered by stream number, this loop tries to find\n    // the first not indexed video stream\n    for (i = 0; i < asf->nb_streams; i++) {\n        if ((asf->asf_st[i]->type == AVMEDIA_TYPE_VIDEO) && !asf->asf_st[i]->indexed) {\n            asf->asf_st[i]->indexed = 1;\n            st = s->streams[asf->asf_st[i]->index];\n            break;\n        }\n    }\n    if (!st) {\n        avio_skip(pb, size - 24); // if there's no video stream, skip index object\n        return 0;\n    }\n    avio_skip(pb, 16); // skip File ID\n    interval = avio_rl64(pb);\n    avio_skip(pb, 4);\n    nb_entries = avio_rl32(pb);\n    for (i = 0; i < nb_entries; i++) {\n        pkt_num = avio_rl32(pb);\n        offset = avio_skip(pb, 2);\n        if (offset < 0) {\n            av_log(s, AV_LOG_ERROR, \"Skipping failed in asf_read_simple_index.\\n\");\n            return offset;\n        }\n        if (prev_pkt_num != pkt_num) {\n            av_add_index_entry(st, asf->first_packet_offset + asf->packet_size *\n                               pkt_num, av_rescale(interval, i, 10000),\n                               asf->packet_size, 0, AVINDEX_KEYFRAME);\n            prev_pkt_num = pkt_num;\n        }\n    }\n    asf->is_simple_index = 1;\n    align_position(pb, asf->offset, size);\n\n    return 0;\n}\n\nstatic const GUIDParseTable gdef[] = {\n    { \"Data\",                         { 0x75, 0xB2, 0x26, 0x36, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_data, 1 },\n    { \"Simple Index\",                 { 0x33, 0x00, 0x08, 0x90, 0xE5, 0xB1, 0x11, 0xCF, 0x89, 0xF4, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xCB }, asf_read_simple_index, 1 },\n    { \"Content Description\",          { 0x75, 0xB2, 0x26, 0x33, 0x66 ,0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_content_desc, 1 },\n    { \"Extended Content Description\", { 0xD2, 0xD0, 0xA4, 0x40, 0xE3, 0x07, 0x11, 0xD2, 0x97, 0xF0, 0x00, 0xA0, 0xC9, 0x5e, 0xA8, 0x50 }, asf_read_ext_content, 1 },\n    { \"Stream Bitrate Properties\",    { 0x7B, 0xF8, 0x75, 0xCE, 0x46, 0x8D, 0x11, 0xD1, 0x8D, 0x82, 0x00, 0x60, 0x97, 0xC9, 0xA2, 0xB2 }, asf_read_unknown, 1 },\n    { \"File Properties\",              { 0x8C, 0xAB, 0xDC, 0xA1, 0xA9, 0x47, 0x11, 0xCF, 0x8E, 0xE4, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_properties, 1 },\n    { \"Header Extension\",             { 0x5F, 0xBF, 0x03, 0xB5, 0xA9, 0x2E, 0x11, 0xCF, 0x8E, 0xE3, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_unknown, 0 },\n    { \"Stream Properties\",            { 0xB7, 0xDC, 0x07, 0x91, 0xA9, 0xB7, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_stream_properties, 1 },\n    { \"Codec List\",                   { 0x86, 0xD1, 0x52, 0x40, 0x31, 0x1D, 0x11, 0xD0, 0xA3, 0xA4, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6 }, asf_read_unknown, 1 },\n    { \"Marker\",                       { 0xF4, 0x87, 0xCD, 0x01, 0xA9, 0x51, 0x11, 0xCF, 0x8E, 0xE6, 0x00, 0xC0, 0x0C, 0x20, 0x53, 0x65 }, asf_read_marker, 1 },\n    { \"Script Command\",               { 0x1E, 0xFB, 0x1A, 0x30, 0x0B, 0x62, 0x11, 0xD0, 0xA3, 0x9B, 0x00, 0xA0, 0xC9, 0x03, 0x48, 0xF6 }, asf_read_unknown, 1 },\n    { \"Language List\",                { 0x7C, 0x43, 0x46, 0xa9, 0xef, 0xe0, 0x4B, 0xFC, 0xB2, 0x29, 0x39, 0x3e, 0xde, 0x41, 0x5c, 0x85 }, asf_read_language_list, 1},\n    { \"Padding\",                      { 0x18, 0x06, 0xD4, 0x74, 0xCA, 0xDF, 0x45, 0x09, 0xA4, 0xBA, 0x9A, 0xAB, 0xCB, 0x96, 0xAA, 0xE8 }, asf_read_unknown, 1 },\n    { \"DRMv1 Header\",                 { 0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"DRMv2 Header\",                 { 0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9c }, asf_read_unknown, 1 },\n    { \"Index\",                        { 0xD6, 0xE2, 0x29, 0xD3, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Media Object Index\",           { 0xFE, 0xB1, 0x03, 0xF8, 0x12, 0xAD, 0x4C, 0x64, 0x84, 0x0F, 0x2A, 0x1D, 0x2F, 0x7A, 0xD4, 0x8C }, asf_read_unknown, 1 },\n    { \"Timecode Index\",               { 0x3C, 0xB7, 0x3F, 0xD0, 0x0C, 0x4A, 0x48, 0x03, 0x95, 0x3D, 0xED, 0xF7, 0xB6, 0x22, 0x8F, 0x0C }, asf_read_unknown, 0 },\n    { \"Bitrate_Mutual_Exclusion\",     { 0xD6, 0xE2, 0x29, 0xDC, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Error Correction\",             { 0x75, 0xB2, 0x26, 0x35, 0x66, 0x8E, 0x11, 0xCF, 0xA6, 0xD9, 0x00, 0xAA, 0x00, 0x62, 0xCE, 0x6C }, asf_read_unknown, 1 },\n    { \"Content Branding\",             { 0x22, 0x11, 0xB3, 0xFA, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Content Encryption\",           { 0x22, 0x11, 0xB3, 0xFB, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Extended Content Encryption\",  { 0x29, 0x8A, 0xE6, 0x14, 0x26, 0x22, 0x4C, 0x17, 0xB9, 0x35, 0xDA, 0xE0, 0x7E, 0xE9, 0x28, 0x9C }, asf_read_unknown, 1 },\n    { \"Digital Signature\",            { 0x22, 0x11, 0xB3, 0xFC, 0xBD, 0x23, 0x11, 0xD2, 0xB4, 0xB7, 0x00, 0xA0, 0xC9, 0x55, 0xFC, 0x6E }, asf_read_unknown, 1 },\n    { \"Extended Stream Properties\",   { 0x14, 0xE6, 0xA5, 0xCB, 0xC6, 0x72, 0x43, 0x32, 0x83, 0x99, 0xA9, 0x69, 0x52, 0x06, 0x5B, 0x5A }, asf_read_ext_stream_properties, 1 },\n    { \"Advanced Mutual Exclusion\",    { 0xA0, 0x86, 0x49, 0xCF, 0x47, 0x75, 0x46, 0x70, 0x8A, 0x16, 0x6E, 0x35, 0x35, 0x75, 0x66, 0xCD }, asf_read_unknown, 1 },\n    { \"Group Mutual Exclusion\",       { 0xD1, 0x46, 0x5A, 0x40, 0x5A, 0x79, 0x43, 0x38, 0xB7, 0x1B, 0xE3, 0x6B, 0x8F, 0xD6, 0xC2, 0x49 }, asf_read_unknown, 1},\n    { \"Stream Prioritization\",        { 0xD4, 0xFE, 0xD1, 0x5B, 0x88, 0xD3, 0x45, 0x4F, 0x81, 0xF0, 0xED, 0x5C, 0x45, 0x99, 0x9E, 0x24 }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Object\",     { 0xA6, 0x96, 0x09, 0xE6, 0x51, 0x7B, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Metadata\",                     { 0xC5, 0xF8, 0xCB, 0xEA, 0x5B, 0xAF, 0x48, 0x77, 0x84, 0x67, 0xAA, 0x8C, 0x44, 0xFA, 0x4C, 0xCA }, asf_read_metadata_obj, 1 },\n    { \"Metadata Library\",             { 0x44, 0x23, 0x1C, 0x94, 0x94, 0x98, 0x49, 0xD1, 0xA1, 0x41, 0x1D, 0x13, 0x4E, 0x45, 0x70, 0x54 }, asf_read_metadata_obj, 1 },\n    { \"Audio Spread\",                 { 0xBF, 0xC3, 0xCD, 0x50, 0x61, 0x8F, 0x11, 0xCF, 0x8B, 0xB2, 0x00, 0xAA, 0x00, 0xB4, 0xE2, 0x20 }, asf_read_unknown, 1 },\n    { \"Index Parameters\",             { 0xD6, 0xE2, 0x29, 0xDF, 0x35, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Content Encryption System Windows Media DRM Network Devices\",\n                                      { 0x7A, 0x07, 0x9B, 0xB6, 0xDA, 0XA4, 0x4e, 0x12, 0xA5, 0xCA, 0x91, 0xD3, 0x8D, 0xC1, 0x1A, 0x8D }, asf_read_unknown, 1 },\n    { \"Mutex Language\",               { 0xD6, 0xE2, 0x2A, 0x00, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Mutex Bitrate\",                { 0xD6, 0xE2, 0x2A, 0x01, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Mutex Unknown\",                { 0xD6, 0xE2, 0x2A, 0x02, 0x25, 0xDA, 0x11, 0xD1, 0x90, 0x34, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0xBE }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Exclusive\",  { 0xAF, 0x60, 0x60, 0xAA, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Bandwidth Sharing Partial\",    { 0xAF, 0x60, 0x60, 0xAB, 0x51, 0x97, 0x11, 0xD2, 0xB6, 0xAF, 0x00, 0xC0, 0x4F, 0xD9, 0x08, 0xE9 }, asf_read_unknown, 1 },\n    { \"Payload Extension System Timecode\", { 0x39, 0x95, 0x95, 0xEC, 0x86, 0x67, 0x4E, 0x2D, 0x8F, 0xDB, 0x98, 0x81, 0x4C, 0xE7, 0x6C, 0x1E }, asf_read_unknown, 1 },\n    { \"Payload Extension System File Name\", { 0xE1, 0x65, 0xEC, 0x0E, 0x19, 0xED, 0x45, 0xD7, 0xB4, 0xA7, 0x25, 0xCB, 0xD1, 0xE2, 0x8E, 0x9B }, asf_read_unknown, 1 },\n    { \"Payload Extension System Content Type\", { 0xD5, 0x90, 0xDC, 0x20, 0x07, 0xBC, 0x43, 0x6C, 0x9C, 0xF7, 0xF3, 0xBB, 0xFB, 0xF1, 0xA4, 0xDC }, asf_read_unknown, 1 },\n    { \"Payload Extension System Pixel Aspect Ratio\", { 0x1, 0x1E, 0xE5, 0x54, 0xF9, 0xEA, 0x4B, 0xC8, 0x82, 0x1A, 0x37, 0x6B, 0x74, 0xE4, 0xC4, 0xB8 }, asf_read_unknown, 1 },\n    { \"Payload Extension System Sample Duration\", { 0xC6, 0xBD, 0x94, 0x50, 0x86, 0x7F, 0x49, 0x07, 0x83, 0xA3, 0xC7, 0x79, 0x21, 0xB7, 0x33, 0xAD }, asf_read_unknown, 1 },\n    { \"Payload Extension System Encryption Sample ID\", { 0x66, 0x98, 0xB8, 0x4E, 0x0A, 0xFA, 0x43, 0x30, 0xAE, 0xB2, 0x1C, 0x0A, 0x98, 0xD7, 0xA4, 0x4D }, asf_read_unknown, 1 },\n    { \"Payload Extension System Degradable JPEG\", { 0x00, 0xE1, 0xAF, 0x06, 0x7B, 0xEC, 0x11, 0xD1, 0xA5, 0x82, 0x00, 0xC0, 0x4F, 0xC2, 0x9C, 0xFB }, asf_read_unknown, 1 },\n};\n\n#define READ_LEN(flag, name, len)            \\\n    do {                                     \\\n        if ((flag) == name ## IS_BYTE)       \\\n            len = avio_r8(pb);               \\\n        else if ((flag) == name ## IS_WORD)  \\\n            len = avio_rl16(pb);             \\\n        else if ((flag) == name ## IS_DWORD) \\\n            len = avio_rl32(pb);             \\\n        else                                 \\\n            len = 0;                         \\\n    } while(0)\n\nstatic int asf_read_subpayload(AVFormatContext *s, AVPacket *pkt, int is_header)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint8_t sub_len;\n    int ret, i;\n\n    if (is_header) {\n        asf->dts_delta = avio_r8(pb);\n        if (asf->nb_mult_left) {\n            asf->mult_sub_len = avio_rl16(pb); // total\n        }\n        asf->sub_header_offset = avio_tell(pb);\n        asf->nb_sub = 0;\n        asf->sub_left = 1;\n    }\n    sub_len = avio_r8(pb);\n    if ((ret = av_get_packet(pb, pkt, sub_len)) < 0) // each subpayload is entire frame\n        return ret;\n    for (i = 0; i < asf->nb_streams; i++) {\n        if (asf->stream_index == asf->asf_st[i]->stream_index) {\n            pkt->stream_index  = asf->asf_st[i]->index;\n            break;\n        }\n    }\n    asf->return_subpayload = 1;\n    if (!sub_len)\n        asf->return_subpayload = 0;\n\n    if (sub_len)\n        asf->nb_sub++;\n    pkt->dts = asf->sub_dts + (asf->nb_sub - 1) * asf->dts_delta - asf->preroll;\n    if (asf->nb_mult_left && (avio_tell(pb) >=\n                              (asf->sub_header_offset + asf->mult_sub_len))) {\n        asf->sub_left = 0;\n        asf->nb_mult_left--;\n    }\n    if (avio_tell(pb) >= asf->packet_offset + asf->packet_size - asf->pad_len) {\n        asf->sub_left = 0;\n        if (!asf->nb_mult_left) {\n            avio_skip(pb, asf->pad_len);\n            if (avio_tell(pb) != asf->packet_offset + asf->packet_size) {\n                if (!asf->packet_size)\n                    return AVERROR_INVALIDDATA;\n                av_log(s, AV_LOG_WARNING,\n                       \"Position %\"PRId64\" wrong, should be %\"PRId64\"\\n\",\n                       avio_tell(pb), asf->packet_offset + asf->packet_size);\n                avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic void reset_packet(ASFPacket *asf_pkt)\n{\n    asf_pkt->size_left = 0;\n    asf_pkt->data_size = 0;\n    asf_pkt->duration  = 0;\n    asf_pkt->flags     = 0;\n    asf_pkt->dts       = 0;\n    asf_pkt->duration  = 0;\n    av_packet_unref(&asf_pkt->avpkt);\n    av_init_packet(&asf_pkt->avpkt);\n}\n\nstatic int asf_read_replicated_data(AVFormatContext *s, ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, data_size;\n\n    if (!asf_pkt->data_size) {\n        data_size = avio_rl32(pb); // read media object size\n        if (data_size <= 0)\n            return AVERROR_INVALIDDATA;\n        if ((ret = av_new_packet(&asf_pkt->avpkt, data_size)) < 0)\n            return ret;\n        asf_pkt->data_size = asf_pkt->size_left = data_size;\n    } else\n        avio_skip(pb, 4); // reading of media object size is already done\n    asf_pkt->dts = avio_rl32(pb); // read presentation time\n    if (asf->rep_data_len && (asf->rep_data_len >= 8))\n        avio_skip(pb, asf->rep_data_len - 8); // skip replicated data\n\n    return 0;\n}\n\nstatic int asf_read_multiple_payload(AVFormatContext *s, AVPacket *pkt,\n                                 ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint16_t pay_len;\n    unsigned char *p;\n    int ret;\n    int skip = 0;\n\n    // if replicated length is 1, subpayloads are present\n    if (asf->rep_data_len == 1) {\n        asf->sub_left = 1;\n        asf->state = READ_MULTI_SUB;\n        pkt->flags = asf_pkt->flags;\n        if ((ret = asf_read_subpayload(s, pkt, 1)) < 0)\n            return ret;\n    } else {\n        if (asf->rep_data_len)\n            if ((ret = asf_read_replicated_data(s, asf_pkt)) < 0)\n                return ret;\n        pay_len = avio_rl16(pb); // payload length should be WORD\n        if (pay_len > asf->packet_size) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Error: invalid data packet size, pay_len %\"PRIu16\", \"\n                   \"asf->packet_size %\"PRIu32\", offset %\"PRId64\".\\n\",\n                   pay_len, asf->packet_size, avio_tell(pb));\n            return AVERROR_INVALIDDATA;\n        }\n        p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;\n        if (pay_len > asf_pkt->size_left) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Error: invalid buffer size, pay_len %d, data size left %d.\\n\",\n            pay_len, asf_pkt->size_left);\n            skip = pay_len - asf_pkt->size_left;\n            pay_len = asf_pkt->size_left;\n        }\n        if (asf_pkt->size_left <= 0)\n            return AVERROR_INVALIDDATA;\n        if ((ret = avio_read(pb, p, pay_len)) < 0)\n            return ret;\n        if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, p, ret);\n        avio_skip(pb, skip);\n        asf_pkt->size_left -= pay_len;\n        asf->nb_mult_left--;\n    }\n\n    return 0;\n}\n\nstatic int asf_read_single_payload(AVFormatContext *s, ASFPacket *asf_pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t  offset;\n    uint64_t size;\n    unsigned char *p;\n    int ret, data_size;\n\n    if (!asf_pkt->data_size) {\n        data_size = avio_rl32(pb); // read media object size\n        if (data_size <= 0)\n            return AVERROR_EOF;\n        if ((ret = av_new_packet(&asf_pkt->avpkt, data_size)) < 0)\n            return ret;\n        asf_pkt->data_size = asf_pkt->size_left = data_size;\n    } else\n        avio_skip(pb, 4); // skip media object size\n    asf_pkt->dts = avio_rl32(pb); // read presentation time\n    if (asf->rep_data_len >= 8)\n        avio_skip(pb, asf->rep_data_len - 8); // skip replicated data\n    offset = avio_tell(pb);\n\n    // size of the payload - size of the packet without header and padding\n    if (asf->packet_size_internal)\n        size = asf->packet_size_internal - offset + asf->packet_offset - asf->pad_len;\n    else\n        size = asf->packet_size - offset + asf->packet_offset - asf->pad_len;\n    if (size > asf->packet_size) {\n        av_log(s, AV_LOG_ERROR,\n               \"Error: invalid data packet size, offset %\"PRId64\".\\n\",\n               avio_tell(pb));\n        return AVERROR_INVALIDDATA;\n    }\n    p = asf_pkt->avpkt.data + asf_pkt->data_size - asf_pkt->size_left;\n    if (size > asf_pkt->size_left || asf_pkt->size_left <= 0)\n        return AVERROR_INVALIDDATA;\n    if (asf_pkt->size_left > size)\n        asf_pkt->size_left -= size;\n    else\n        asf_pkt->size_left = 0;\n    if ((ret = avio_read(pb, p, size)) < 0)\n        return ret;\n    if (s->key && s->keylen == 20)\n            ff_asfcrypt_dec(s->key, p, ret);\n    if (asf->packet_size_internal)\n        avio_skip(pb, asf->packet_size - asf->packet_size_internal);\n    avio_skip(pb, asf->pad_len); // skip padding\n\n    return 0;\n}\n\nstatic int asf_read_payload(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, i;\n    ASFPacket *asf_pkt = NULL;\n\n    if (!asf->sub_left) {\n        uint32_t off_len, media_len;\n        uint8_t stream_num;\n\n        stream_num = avio_r8(pb);\n        asf->stream_index = stream_num & ASF_STREAM_NUM;\n        for (i = 0; i < asf->nb_streams; i++) {\n            if (asf->stream_index == asf->asf_st[i]->stream_index) {\n                asf_pkt               = &asf->asf_st[i]->pkt;\n                asf_pkt->stream_index = asf->asf_st[i]->index;\n                break;\n            }\n        }\n        if (!asf_pkt) {\n            if (asf->packet_offset + asf->packet_size <= asf->data_offset + asf->data_size) {\n                if (!asf->packet_size) {\n                    av_log(s, AV_LOG_ERROR, \"Invalid packet size 0.\\n\");\n                    return AVERROR_INVALIDDATA;\n                }\n                avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n                av_log(s, AV_LOG_WARNING, \"Skipping the stream with the invalid stream index %d.\\n\",\n                       asf->stream_index);\n                return AVERROR(EAGAIN);\n            } else\n                return AVERROR_INVALIDDATA;\n        }\n\n        if (stream_num >> 7)\n            asf_pkt->flags |= AV_PKT_FLAG_KEY;\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_MEDIA_OBJECT_NUMBER_LENGTH_FIELD_, media_len);\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_OFFSET_INTO_MEDIA_OBJECT_LENGTH_FIELD_, off_len);\n        READ_LEN(asf->prop_flags & ASF_PL_MASK_REPLICATED_DATA_LENGTH_FIELD_SIZE,\n                 ASF_PL_FLAG_REPLICATED_DATA_LENGTH_FIELD_, asf->rep_data_len);\n        if (asf_pkt->size_left && (asf_pkt->frame_num != media_len)) {\n            av_log(s, AV_LOG_WARNING, \"Unfinished frame will be ignored\\n\");\n            reset_packet(asf_pkt);\n        }\n        asf_pkt->frame_num = media_len;\n        asf->sub_dts = off_len;\n        if (asf->nb_mult_left) {\n            if ((ret = asf_read_multiple_payload(s, pkt, asf_pkt)) < 0)\n                return ret;\n        } else if (asf->rep_data_len == 1) {\n            asf->sub_left = 1;\n            asf->state    = READ_SINGLE;\n            pkt->flags    = asf_pkt->flags;\n            if ((ret = asf_read_subpayload(s, pkt, 1)) < 0)\n                return ret;\n        } else {\n            if ((ret = asf_read_single_payload(s, asf_pkt)) < 0)\n                return ret;\n        }\n    } else {\n        for (i = 0; i <= asf->nb_streams; i++) {\n            if (asf->stream_index == asf->asf_st[i]->stream_index) {\n                asf_pkt = &asf->asf_st[i]->pkt;\n                break;\n            }\n        }\n        if (!asf_pkt)\n            return AVERROR_INVALIDDATA;\n        pkt->flags         = asf_pkt->flags;\n        pkt->dts           = asf_pkt->dts;\n        pkt->stream_index  = asf->asf_st[i]->index;\n        if ((ret = asf_read_subpayload(s, pkt, 0)) < 0) // read subpayload without its header\n            return ret;\n    }\n\n    return 0;\n}\n\nstatic int asf_read_packet_header(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    uint64_t size;\n    uint32_t av_unused seq;\n    unsigned char error_flags, len_flags, pay_flags;\n\n    asf->packet_offset = avio_tell(pb);\n    error_flags = avio_r8(pb); // read Error Correction Flags\n    if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {\n        if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {\n            size = error_flags & ASF_PACKET_ERROR_CORRECTION_DATA_SIZE;\n            avio_skip(pb, size);\n        }\n        len_flags       = avio_r8(pb);\n    } else\n        len_flags = error_flags;\n    asf->prop_flags = avio_r8(pb);\n    READ_LEN(len_flags & ASF_PPI_MASK_PACKET_LENGTH_FIELD_SIZE,\n             ASF_PPI_FLAG_PACKET_LENGTH_FIELD_, asf->packet_size_internal);\n    READ_LEN(len_flags & ASF_PPI_MASK_SEQUENCE_FIELD_SIZE,\n             ASF_PPI_FLAG_SEQUENCE_FIELD_, seq);\n    READ_LEN(len_flags & ASF_PPI_MASK_PADDING_LENGTH_FIELD_SIZE,\n             ASF_PPI_FLAG_PADDING_LENGTH_FIELD_, asf->pad_len );\n    asf->send_time = avio_rl32(pb); // send time\n    avio_skip(pb, 2); // skip duration\n    if (len_flags & ASF_PPI_FLAG_MULTIPLE_PAYLOADS_PRESENT) { // Multiple Payloads present\n        pay_flags = avio_r8(pb);\n        asf->nb_mult_left = (pay_flags & ASF_NUM_OF_PAYLOADS);\n    }\n\n    return 0;\n}\n\nstatic int asf_deinterleave(AVFormatContext *s, ASFPacket *asf_pkt, int st_num)\n{\n    ASFContext *asf    = s->priv_data;\n    ASFStream *asf_st  = asf->asf_st[st_num];\n    unsigned char *p   = asf_pkt->avpkt.data;\n    uint16_t pkt_len   = asf->asf_st[st_num]->virtual_pkt_len;\n    uint16_t chunk_len = asf->asf_st[st_num]->virtual_chunk_len;\n    int nchunks        = pkt_len / chunk_len;\n    AVPacket pkt;\n    int pos = 0, j, l, ret;\n\n\n    if ((ret = av_new_packet(&pkt, asf_pkt->data_size)) < 0)\n        return ret;\n\n    while (asf_pkt->data_size >= asf_st->span * pkt_len + pos) {\n        if (pos >= asf_pkt->data_size) {\n            break;\n        }\n        for (l = 0; l < pkt_len; l++) {\n            if (pos >= asf_pkt->data_size) {\n                break;\n            }\n            for (j = 0; j < asf_st->span; j++) {\n                if ((pos + chunk_len) >= asf_pkt->data_size)\n                    break;\n                memcpy(pkt.data + pos,\n                       p + (j * nchunks + l) * chunk_len,\n                       chunk_len);\n                pos += chunk_len;\n            }\n        }\n        p += asf_st->span * pkt_len;\n        if (p > asf_pkt->avpkt.data + asf_pkt->data_size)\n            break;\n    }\n    av_packet_unref(&asf_pkt->avpkt);\n    asf_pkt->avpkt = pkt;\n\n    return 0;\n}\n\nstatic int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret, i;\n\n    if ((avio_tell(pb) >= asf->data_offset + asf->data_size) &&\n        !(asf->b_flags & ASF_FLAG_BROADCAST))\n        return AVERROR_EOF;\n    while (!pb->eof_reached) {\n        if (asf->state == PARSE_PACKET_HEADER) {\n            asf_read_packet_header(s);\n            if (pb->eof_reached)\n                break;\n            if (!asf->nb_mult_left)\n                asf->state = READ_SINGLE;\n            else\n                asf->state = READ_MULTI;\n        }\n        ret = asf_read_payload(s, pkt);\n        if (ret == AVERROR(EAGAIN)) {\n            asf->state = PARSE_PACKET_HEADER;\n            continue;\n        }\n        else if (ret < 0)\n            return ret;\n\n        switch (asf->state) {\n        case READ_SINGLE:\n            if (!asf->sub_left)\n                asf->state = PARSE_PACKET_HEADER;\n            break;\n        case READ_MULTI_SUB:\n            if (!asf->sub_left && !asf->nb_mult_left) {\n                asf->state = PARSE_PACKET_HEADER;\n                if (!asf->return_subpayload &&\n                    (avio_tell(pb) <= asf->packet_offset +\n                     asf->packet_size - asf->pad_len))\n                    avio_skip(pb, asf->pad_len); // skip padding\n                if (asf->packet_offset + asf->packet_size > avio_tell(pb))\n                    avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            } else if (!asf->sub_left)\n                asf->state = READ_MULTI;\n            break;\n        case READ_MULTI:\n            if (!asf->nb_mult_left) {\n                asf->state = PARSE_PACKET_HEADER;\n                if (!asf->return_subpayload &&\n                    (avio_tell(pb) <= asf->packet_offset +\n                     asf->packet_size - asf->pad_len))\n                    avio_skip(pb, asf->pad_len); // skip padding\n                if (asf->packet_offset + asf->packet_size > avio_tell(pb))\n                    avio_seek(pb, asf->packet_offset + asf->packet_size, SEEK_SET);\n            }\n            break;\n        }\n        if (asf->return_subpayload) {\n            asf->return_subpayload = 0;\n            return 0;\n        }\n        for (i = 0; i < asf->nb_streams; i++) {\n            ASFPacket *asf_pkt = &asf->asf_st[i]->pkt;\n            if (asf_pkt && !asf_pkt->size_left && asf_pkt->data_size) {\n                if (asf->asf_st[i]->span > 1 &&\n                    asf->asf_st[i]->type == AVMEDIA_TYPE_AUDIO)\n                    if ((ret = asf_deinterleave(s, asf_pkt, i)) < 0)\n                        return ret;\n                av_packet_move_ref(pkt, &asf_pkt->avpkt);\n                pkt->stream_index  = asf->asf_st[i]->index;\n                pkt->flags         = asf_pkt->flags;\n                pkt->dts           = asf_pkt->dts - asf->preroll;\n                asf_pkt->data_size = 0;\n                asf_pkt->frame_num = 0;\n                return 0;\n            }\n        }\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int asf_read_close(AVFormatContext *s)\n{\n    ASFContext *asf = s->priv_data;\n    int i;\n\n    for (i = 0; i < ASF_MAX_STREAMS; i++) {\n        av_dict_free(&asf->asf_sd[i].asf_met);\n        if (i < asf->nb_streams) {\n            av_packet_unref(&asf->asf_st[i]->pkt.avpkt);\n            av_freep(&asf->asf_st[i]);\n        }\n    }\n\n    asf->nb_streams = 0;\n    return 0;\n}\n\nstatic void reset_packet_state(AVFormatContext *s)\n{\n    ASFContext *asf        = s->priv_data;\n    int i;\n\n    asf->state             = PARSE_PACKET_HEADER;\n    asf->offset            = 0;\n    asf->return_subpayload = 0;\n    asf->sub_left          = 0;\n    asf->sub_header_offset = 0;\n    asf->packet_offset     = asf->first_packet_offset;\n    asf->pad_len           = 0;\n    asf->rep_data_len      = 0;\n    asf->dts_delta         = 0;\n    asf->mult_sub_len      = 0;\n    asf->nb_mult_left      = 0;\n    asf->nb_sub            = 0;\n    asf->prop_flags        = 0;\n    asf->sub_dts           = 0;\n    for (i = 0; i < asf->nb_streams; i++) {\n        ASFPacket *pkt = &asf->asf_st[i]->pkt;\n        pkt->size_left = 0;\n        pkt->data_size = 0;\n        pkt->duration  = 0;\n        pkt->flags     = 0;\n        pkt->dts       = 0;\n        pkt->duration  = 0;\n        av_packet_unref(&pkt->avpkt);\n        av_init_packet(&pkt->avpkt);\n    }\n}\n\n/*\n * Find a timestamp for the requested position within the payload\n * where the pos (position) is the offset inside the Data Object.\n * When position is not on the packet boundary, asf_read_timestamp tries\n * to find the closest packet offset after this position. If this packet\n * is a key frame, this packet timestamp is read and an index entry is created\n * for the packet. If this packet belongs to the requested stream,\n * asf_read_timestamp upgrades pos to the packet beginning offset and\n * returns this packet's dts. So returned dts is the dts of the first key frame with\n * matching stream number after given position.\n */\nstatic int64_t asf_read_timestamp(AVFormatContext *s, int stream_index,\n                                  int64_t *pos, int64_t pos_limit)\n{\n    ASFContext *asf = s->priv_data;\n    int64_t pkt_pos = *pos, pkt_offset, dts = AV_NOPTS_VALUE, data_end;\n    AVPacket pkt;\n    int n;\n\n    data_end = asf->data_offset + asf->data_size;\n\n    n = (pkt_pos - asf->first_packet_offset + asf->packet_size - 1) /\n        asf->packet_size;\n    n = av_clip(n, 0, ((data_end - asf->first_packet_offset) / asf->packet_size - 1));\n    pkt_pos = asf->first_packet_offset +  n * asf->packet_size;\n\n    avio_seek(s->pb, pkt_pos, SEEK_SET);\n    pkt_offset = pkt_pos;\n\n    reset_packet_state(s);\n    while (avio_tell(s->pb) < data_end) {\n\n        int i, ret, st_found;\n\n        av_init_packet(&pkt);\n        pkt_offset = avio_tell(s->pb);\n        if ((ret = asf_read_packet(s, &pkt)) < 0) {\n            dts = AV_NOPTS_VALUE;\n            return ret;\n        }\n        // ASFPacket may contain fragments of packets belonging to different streams,\n        // pkt_offset is the offset of the first fragment within it.\n        if ((pkt_offset >= (pkt_pos + asf->packet_size)))\n            pkt_pos += asf->packet_size;\n        for (i = 0; i < asf->nb_streams; i++) {\n            ASFStream *st = asf->asf_st[i];\n\n            st_found = 0;\n            if (pkt.flags & AV_PKT_FLAG_KEY) {\n                dts = pkt.dts;\n                if (dts) {\n                    av_add_index_entry(s->streams[pkt.stream_index], pkt_pos,\n                                       dts, pkt.size, 0, AVINDEX_KEYFRAME);\n                    if (stream_index == st->index) {\n                        st_found = 1;\n                        break;\n                    }\n                }\n            }\n        }\n        if (st_found)\n            break;\n        av_packet_unref(&pkt);\n    }\n    *pos = pkt_pos;\n\n    av_packet_unref(&pkt);\n    return dts;\n}\n\nstatic int asf_read_seek(AVFormatContext *s, int stream_index,\n                         int64_t timestamp, int flags)\n{\n    ASFContext *asf = s->priv_data;\n    int idx, ret;\n\n    if (s->streams[stream_index]->nb_index_entries && asf->is_simple_index) {\n        idx = av_index_search_timestamp(s->streams[stream_index], timestamp, flags);\n        if (idx < 0 || idx >= s->streams[stream_index]->nb_index_entries)\n            return AVERROR_INVALIDDATA;\n        avio_seek(s->pb, s->streams[stream_index]->index_entries[idx].pos, SEEK_SET);\n    } else {\n        if ((ret = ff_seek_frame_binary(s, stream_index, timestamp, flags)) < 0)\n            return ret;\n    }\n\n    reset_packet_state(s);\n\n    return 0;\n}\n\nstatic const GUIDParseTable *find_guid(ff_asf_guid guid)\n{\n    int j, ret;\n    const GUIDParseTable *g;\n\n    swap_guid(guid);\n    g = gdef;\n    for (j = 0; j < FF_ARRAY_ELEMS(gdef); j++) {\n        if (!(ret = memcmp(guid, g->guid, sizeof(g->guid))))\n            return g;\n        g++;\n    }\n\n    return NULL;\n}\n\nstatic int detect_unknown_subobject(AVFormatContext *s, int64_t offset, int64_t size)\n{\n    ASFContext *asf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    const GUIDParseTable *g = NULL;\n    ff_asf_guid guid;\n    int ret;\n\n    while (avio_tell(pb) <= offset + size) {\n        if (avio_tell(pb) == asf->offset)\n            break;\n        asf->offset = avio_tell(pb);\n        if ((ret = ff_get_guid(pb, &guid)) < 0)\n            return ret;\n        g = find_guid(guid);\n        if (g) {\n            if ((ret = g->read_object(s, g)) < 0)\n                return ret;\n        } else {\n            GUIDParseTable g2;\n\n            g2.name         = \"Unknown\";\n            g2.is_subobject = 1;\n            asf_read_unknown(s, &g2);\n        }\n    }\n\n    return 0;\n}\n\nstatic int asf_read_header(AVFormatContext *s)\n{\n    ASFContext *asf         = s->priv_data;\n    AVIOContext *pb         = s->pb;\n    const GUIDParseTable *g = NULL;\n    ff_asf_guid guid;\n    int i, ret;\n    uint64_t size;\n\n    asf->preroll         = 0;\n    asf->is_simple_index = 0;\n    ff_get_guid(pb, &guid);\n    if (ff_guidcmp(&guid, &ff_asf_header))\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, 8); // skip header object size\n    avio_skip(pb, 6); // skip number of header objects and 2 reserved bytes\n    asf->data_reached = 0;\n\n    /* 1  is here instead of pb->eof_reached because (when not streaming), Data are skipped\n     * for the first time,\n     * Index object is processed and got eof and then seeking back to the Data is performed.\n     */\n    while (1) {\n        // for the cases when object size is invalid\n        if (avio_tell(pb) == asf->offset)\n            break;\n        asf->offset = avio_tell(pb);\n        if ((ret = ff_get_guid(pb, &guid)) < 0) {\n            if (ret == AVERROR_EOF && asf->data_reached)\n                break;\n            else\n                goto failed;\n        }\n        g = find_guid(guid);\n        if (g) {\n            asf->unknown_offset = asf->offset;\n            asf->is_header = 1;\n            if ((ret = g->read_object(s, g)) < 0)\n                goto failed;\n        } else {\n            size = avio_rl64(pb);\n            align_position(pb, asf->offset, size);\n        }\n        if (asf->data_reached &&\n            (!(pb->seekable & AVIO_SEEKABLE_NORMAL) ||\n             (asf->b_flags & ASF_FLAG_BROADCAST)))\n            break;\n    }\n\n    if (!asf->data_reached) {\n        av_log(s, AV_LOG_ERROR, \"Data Object was not found.\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto failed;\n    }\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        avio_seek(pb, asf->first_packet_offset, SEEK_SET);\n\n    for (i = 0; i < asf->nb_streams; i++) {\n        const char *rfc1766 = asf->asf_sd[asf->asf_st[i]->lang_idx].langs;\n        AVStream *st        = s->streams[asf->asf_st[i]->index];\n        set_language(s, rfc1766, &st->metadata);\n    }\n\n    for (i = 0; i < ASF_MAX_STREAMS; i++) {\n        AVStream *st = NULL;\n\n        st = find_stream(s, i);\n        if (st) {\n            av_dict_copy(&st->metadata, asf->asf_sd[i].asf_met, AV_DICT_IGNORE_SUFFIX);\n            if (asf->asf_sd[i].aspect_ratio.num > 0 && asf->asf_sd[i].aspect_ratio.den > 0) {\n                st->sample_aspect_ratio.num = asf->asf_sd[i].aspect_ratio.num;\n                st->sample_aspect_ratio.den = asf->asf_sd[i].aspect_ratio.den;\n            }\n        }\n    }\n\n    return 0;\n\nfailed:\n    asf_read_close(s);\n    return ret;\n}\n\nAVInputFormat ff_asf_o_demuxer = {\n    .name           = \"asf_o\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"ASF (Advanced / Active Streaming Format)\"),\n    .priv_data_size = sizeof(ASFContext),\n    .read_probe     = asf_probe,\n    .read_header    = asf_read_header,\n    .read_packet    = asf_read_packet,\n    .read_close     = asf_read_close,\n    .read_timestamp = asf_read_timestamp,\n    .read_seek      = asf_read_seek,\n    .flags          = AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH,\n};\n"], "filenames": ["libavformat/asfdec_o.c"], "buggy_code_start_loc": [709], "buggy_code_end_loc": [710], "fixing_code_start_loc": [709], "fixing_code_end_loc": [711], "type": "CWE-119", "message": "FFmpeg before commit 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 contains a Buffer Overflow vulnerability in asf_o format demuxer that can result in heap-buffer-overflow that may result in remote code execution. This attack appears to be exploitable via specially crafted ASF file that has to be provided as input to FFmpeg. This vulnerability appears to have been fixed in 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 and later.", "other": {"cve": {"id": "CVE-2018-1999011", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-23T15:29:00.347", "lastModified": "2019-05-23T11:29:01.503", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FFmpeg before commit 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 contains a Buffer Overflow vulnerability in asf_o format demuxer that can result in heap-buffer-overflow that may result in remote code execution. This attack appears to be exploitable via specially crafted ASF file that has to be provided as input to FFmpeg. This vulnerability appears to have been fixed in 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 and later."}, {"lang": "es", "value": "FFmpeg antes del commit con ID 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 contiene una vulnerabilidad de desbordamiento de b\u00fafer en el demuxer de formato asf_o que puede resultar en la ejecuci\u00f3n remota de c\u00f3digo. Este ataque parece ser explotable mediante un archivo ASF especialmente manipulado que debe proporcionarse como entrada a FFmpeg. La vulnerabilidad parece haber sido solucionada en 2b46ebdbff1d8dec7a3d8ea280a612b91a582869 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.0.1", "matchCriteriaId": "9B915B68-D7F0-4B61-9DA0-000EE6AE9A51"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104896", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/2b46ebdbff1d8dec7a3d8ea280a612b91a582869", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/May/60", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4449", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2b46ebdbff1d8dec7a3d8ea280a612b91a582869"}}