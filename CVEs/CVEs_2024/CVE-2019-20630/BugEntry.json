{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\n *  This file is part of GPAC / MPEG2-TS sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/mpegts.h>\n\n\n#ifndef GPAC_DISABLE_MPEG2TS\n\n#include <string.h>\n#include <gpac/constants.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/download.h>\n\n\n#ifndef GPAC_DISABLE_STREAMING\n#include <gpac/internal/ietf_dev.h>\n#endif\n\n\n#ifdef GPAC_CONFIG_LINUX\n#include <unistd.h>\n#endif\n\n#ifdef GPAC_ENABLE_MPE\n#include <gpac/dvb_mpe.h>\n#endif\n\n#ifdef GPAC_ENABLE_DSMCC\n#include <gpac/ait.h>\n#endif\n\n#define DEBUG_TS_PACKET 0\n\nGF_EXPORT\nconst char *gf_m2ts_get_stream_name(u32 streamType)\n{\n\tswitch (streamType) {\n\tcase GF_M2TS_VIDEO_MPEG1:\n\t\treturn \"MPEG-1 Video\";\n\tcase GF_M2TS_VIDEO_MPEG2:\n\t\treturn \"MPEG-2 Video\";\n\tcase GF_M2TS_AUDIO_MPEG1:\n\t\treturn \"MPEG-1 Audio\";\n\tcase GF_M2TS_AUDIO_MPEG2:\n\t\treturn \"MPEG-2 Audio\";\n\tcase GF_M2TS_PRIVATE_SECTION:\n\t\treturn \"Private Section\";\n\tcase GF_M2TS_PRIVATE_DATA:\n\t\treturn \"Private Data\";\n\tcase GF_M2TS_AUDIO_AAC:\n\t\treturn \"AAC Audio\";\n\tcase GF_M2TS_VIDEO_MPEG4:\n\t\treturn \"MPEG-4 Video\";\n\tcase GF_M2TS_VIDEO_H264:\n\t\treturn \"MPEG-4/H264 Video\";\n\tcase GF_M2TS_VIDEO_SVC:\n\t\treturn \"H264-SVC Video\";\n\tcase GF_M2TS_VIDEO_HEVC:\n\t\treturn \"HEVC Video\";\n\tcase GF_M2TS_VIDEO_SHVC:\n\t\treturn \"SHVC Video\";\n\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\treturn \"SHVC Video Temporal Sublayer\";\n\tcase GF_M2TS_VIDEO_MHVC:\n\t\treturn \"MHVC Video\";\n\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\treturn \"MHVC Video Temporal Sublayer\";\n\n\tcase GF_M2TS_AUDIO_AC3:\n\t\treturn \"Dolby AC3 Audio\";\n\tcase GF_M2TS_AUDIO_DTS:\n\t\treturn \"Dolby DTS Audio\";\n\tcase GF_M2TS_SUBTITLE_DVB:\n\t\treturn \"DVB Subtitle\";\n\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\treturn \"MPEG-4 SL (PES)\";\n\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\treturn \"MPEG-4 SL (Section)\";\n\tcase GF_M2TS_MPE_SECTIONS:\n\t\treturn \"MPE (Section)\";\n\n\tcase GF_M2TS_METADATA_PES:\n\t\treturn \"Metadata (PES)\";\n\tcase GF_M2TS_METADATA_ID3_HLS:\n\t\treturn \"ID3/HLS Metadata (PES)\";\n\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n\nstatic u32 gf_m2ts_reframe_default(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tGF_M2TS_PES_PCK pck;\n\tpck.flags = 0;\n\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\tif (!same_pts) pck.flags |= GF_M2TS_PES_PCK_AU_START;\n\tpck.DTS = pes->DTS;\n\tpck.PTS = pes->PTS;\n\tpck.data = (char *)data;\n\tpck.data_len = data_len;\n\tpck.stream = pes;\n\tts->on_event(ts, GF_M2TS_EVT_PES_PCK, &pck);\n\t/*we consumed all data*/\n\treturn 0;\n}\n\nstatic u32 gf_m2ts_reframe_reset(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tif (pes->pck_data) {\n\t\tgf_free(pes->pck_data);\n\t\tpes->pck_data = NULL;\n\t}\n\tpes->pck_data_len = pes->pck_alloc_len = 0;\n\tif (pes->prev_data) {\n\t\tgf_free(pes->prev_data);\n\t\tpes->prev_data = NULL;\n\t}\n\tpes->prev_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->prev_PTS = 0;\n\tpes->reframe = NULL;\n\tpes->cc = -1;\n\tpes->temi_tc_desc_len = 0;\n\treturn 0;\n}\n\nstatic void add_text(char **buffer, u32 *size, u32 *pos, char *msg, u32 msg_len)\n{\n\tif (!msg || !buffer) return;\n\n\tif (*pos+msg_len>*size) {\n\t\t*size = *pos+msg_len-*size+256;\n\t\t*buffer = (char *)gf_realloc(*buffer, *size);\n\t}\n\tstrncpy((*buffer)+(*pos), msg, msg_len);\n\t*pos += msg_len;\n}\n\nstatic GF_Err id3_parse_tag(char *data, u32 length, char **output, u32 *output_size, u32 *output_pos)\n{\n\tGF_BitStream *bs;\n\tu32 pos;\n\n\tif ((data[0] != 'I') || (data[1] != 'D') || (data[2] != '3'))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tbs = gf_bs_new(data, length, GF_BITSTREAM_READ);\n\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\t/*u8 ext_hdr = */ gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\tpos = (u32) gf_bs_get_position(bs);\n\tif (size != length-pos)\n\t\tsize = length-pos;\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\t\tsize -= 10;\n\n\t\t//TODO, handle more ID3 tags ?\n\t\tif (ftag==ID3V2_FRAME_TXXX) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(bs);\n\t\t\tchar *text = data+pos;\n\t\t\tadd_text(output, output_size, output_pos, text, fsize);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] ID3 tag not handled, patch welcome\\n\", gf_4cc_to_str(ftag) ) );\n\t\t}\n\t\tgf_bs_skip_bytes(bs, fsize);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nstatic u32 gf_m2ts_reframe_id3_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tchar frame_header[256];\n\tchar *output_text = NULL;\n\tu32 output_len = 0;\n\tu32 pos = 0;\n\tGF_M2TS_PES_PCK pck;\n\tpck.flags = 0;\n\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\tif (!same_pts) pck.flags |= GF_M2TS_PES_PCK_AU_START;\n\tpck.DTS = pes->DTS;\n\tpck.PTS = pes->PTS;\n\tsprintf(frame_header, LLU\" --> NEXT\\n\", pes->PTS);\n\tadd_text(&output_text, &output_len, &pos, frame_header, (u32)strlen(frame_header));\n\tid3_parse_tag((char *)data, data_len, &output_text, &output_len, &pos);\n\tadd_text(&output_text, &output_len, &pos, \"\\n\\n\", 2);\n\tpck.data = (char *)output_text;\n\tpck.data_len = pos;\n\tpck.stream = pes;\n\tts->on_event(ts, GF_M2TS_EVT_PES_PCK, &pck);\n\tgf_free(output_text);\n\t/*we consumed all data*/\n\treturn 0;\n}\n\nstatic u32 gf_m2ts_sync(GF_M2TS_Demuxer *ts, char *data, u32 size, Bool simple_check)\n{\n\tu32 i=0;\n\t/*if first byte is sync assume we're sync*/\n\tif (simple_check && (data[i]==0x47)) return 0;\n\n\twhile (i < size) {\n\t\tif (i+192 >= size) return size;\n\t\tif ((data[i]==0x47) && (data[i+188]==0x47))\n\t\t\tbreak;\n\t\tif (i+192 >= size) return size;\n\t\tif ((data[i]==0x47) && (data[i+192]==0x47)) {\n\t\t\tts->prefix_present = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] re-sync skipped %d bytes\\n\", i) );\n\t}\n\treturn i;\n}\n\nGF_EXPORT\nBool gf_m2ts_crc32_check(u8 *data, u32 len)\n{\n\tu32 crc = gf_crc_32(data, len);\n\tu32 crc_val = GF_4CC((u8) data[len], (u8) data[len+1], (u8) data[len+2], (u8) data[len+3]);\n\treturn (crc==crc_val) ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic GF_M2TS_SectionFilter *gf_m2ts_section_filter_new(gf_m2ts_section_callback process_section_callback, Bool process_individual)\n{\n\tGF_M2TS_SectionFilter *sec;\n\tGF_SAFEALLOC(sec, GF_M2TS_SectionFilter);\n\tif (!sec) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] gf_m2ts_section_filter_new : OUT OF MEMORY\\n\"));\n\t\treturn NULL;\n\t}\n\tsec->cc = -1;\n\tsec->process_section = process_section_callback;\n\tsec->process_individual = process_individual;\n\treturn sec;\n}\n\nstatic void gf_m2ts_reset_sections(GF_List *sections)\n{\n\tu32 count;\n\tGF_M2TS_Section *section;\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Deleting sections\\n\"));\n\n\tcount = gf_list_count(sections);\n\twhile (count) {\n\t\tsection = gf_list_get(sections, 0);\n\t\tgf_list_rem(sections, 0);\n\t\tif (section->data) gf_free(section->data);\n\t\tgf_free(section);\n\t\tcount--;\n\t}\n}\n\nstatic void gf_m2ts_section_filter_reset(GF_M2TS_SectionFilter *sf)\n{\n\tif (sf->section) {\n\t\tgf_free(sf->section);\n\t\tsf->section = NULL;\n\t}\n\twhile (sf->table) {\n\t\tGF_M2TS_Table *t = sf->table;\n\t\tsf->table = t->next;\n\t\tgf_m2ts_reset_sections(t->sections);\n\t\tgf_list_del(t->sections);\n\t\tgf_free(t);\n\t}\n\tsf->cc = -1;\n\tsf->length = sf->received = 0;\n\tsf->demux_restarted = 1;\n\n}\nstatic void gf_m2ts_section_filter_del(GF_M2TS_SectionFilter *sf)\n{\n\tgf_m2ts_section_filter_reset(sf);\n\tgf_free(sf);\n}\n\n\nstatic void gf_m2ts_metadata_descriptor_del(GF_M2TS_MetadataDescriptor *metad)\n{\n\tif (metad) {\n\t\tif (metad->service_id_record) gf_free(metad->service_id_record);\n\t\tif (metad->decoder_config) gf_free(metad->decoder_config);\n\t\tif (metad->decoder_config_id) gf_free(metad->decoder_config_id);\n\t\tgf_free(metad);\n\t}\n}\n\nGF_EXPORT\nvoid gf_m2ts_es_del(GF_M2TS_ES *es, GF_M2TS_Demuxer *ts)\n{\n\tgf_list_del_item(es->program->streams, es);\n\n\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\tif (ses->sec) gf_m2ts_section_filter_del(ses->sec);\n\n#ifdef GPAC_ENABLE_MPE\n\t\tif (es->flags & GF_M2TS_ES_IS_MPE)\n\t\t\tgf_dvb_mpe_section_del(es);\n#endif\n\n\t} else if (es->pid!=es->program->pmt_pid) {\n\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\n\t\tif ((pes->flags & GF_M2TS_INHERIT_PCR) && ts->ess[es->program->pcr_pid]==es)\n\t\t\tts->ess[es->program->pcr_pid] = NULL;\n\n\t\tif (pes->pck_data) gf_free(pes->pck_data);\n\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\tif (pes->buf) gf_free(pes->buf);\n\t\tif (pes->reassemble_buf) gf_free(pes->reassemble_buf);\n\t\tif (pes->temi_tc_desc) gf_free(pes->temi_tc_desc);\n\n\t\tif (pes->metadata_descriptor) gf_m2ts_metadata_descriptor_del(pes->metadata_descriptor);\n\n\t}\n\tif (es->slcfg) gf_free(es->slcfg);\n\tgf_free(es);\n}\n\nstatic void gf_m2ts_reset_sdt(GF_M2TS_Demuxer *ts)\n{\n\twhile (gf_list_count(ts->SDTs)) {\n\t\tGF_M2TS_SDT *sdt = (GF_M2TS_SDT *)gf_list_last(ts->SDTs);\n\t\tgf_list_rem_last(ts->SDTs);\n\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\tif (sdt->service) gf_free(sdt->service);\n\t\tgf_free(sdt);\n\t}\n}\n\nGF_EXPORT\nGF_M2TS_SDT *gf_m2ts_get_sdt_info(GF_M2TS_Demuxer *ts, u32 program_id)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(ts->SDTs); i++) {\n\t\tGF_M2TS_SDT *sdt = (GF_M2TS_SDT *)gf_list_get(ts->SDTs, i);\n\t\tif (sdt->service_id==program_id) return sdt;\n\t}\n\treturn NULL;\n}\n\nstatic void gf_m2ts_section_complete(GF_M2TS_Demuxer *ts, GF_M2TS_SectionFilter *sec, GF_M2TS_SECTION_ES *ses)\n{\n\t//seek mode, only process PAT and PMT\n\tif (ts->seek_mode && (sec->section[0] != GF_M2TS_TABLE_ID_PAT) && (sec->section[0] != GF_M2TS_TABLE_ID_PMT)) {\n\t\t/*clean-up (including broken sections)*/\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->section = NULL;\n\t\tsec->length = sec->received = 0;\n\t\treturn;\n\t}\n\n\tif (!sec->process_section) {\n\t\tif ((ts->on_event && (sec->section[0]==GF_M2TS_TABLE_ID_AIT)) ) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\t//ts->on_event(ts, GF_M2TS_EVT_AIT_FOUND, &pck);\n\t\t\ton_ait_section(ts, GF_M2TS_EVT_AIT_FOUND, &pck);\n#endif\n\t\t} else if ((ts->on_event && (sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_ENCAPSULATED_DATA\t|| sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_UN_MESSAGE ||\n\t\t                             sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_DOWNLOAD_DATA_MESSAGE || sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_STREAM_DESCRIPTION || sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_PRIVATE)) ) {\n\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\ton_dsmcc_section(ts,GF_M2TS_EVT_DSMCC_FOUND,&pck);\n\t\t\t//ts->on_event(ts, GF_M2TS_EVT_DSMCC_FOUND, &pck);\n#endif\n\t\t}\n#ifdef GPAC_ENABLE_MPE\n\t\telse if (ts->on_mpe_event && ((ses && (ses->flags & GF_M2TS_EVT_DVB_MPE)) || (sec->section[0]==GF_M2TS_TABLE_ID_INT)) ) {\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\tts->on_mpe_event(ts, GF_M2TS_EVT_DVB_MPE, &pck);\n\t\t}\n#endif\n\t\telse if (ts->on_event) {\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\tts->on_event(ts, GF_M2TS_EVT_DVB_GENERAL, &pck);\n\t\t}\n\t} else {\n\t\tBool has_syntax_indicator;\n\t\tu8 table_id;\n\t\tu16 extended_table_id;\n\t\tu32 status, section_start, i;\n\t\tGF_M2TS_Table *t, *prev_t;\n\t\tunsigned char *data;\n\t\tBool section_valid = 0;\n\n\t\tstatus = 0;\n\t\t/*parse header*/\n\t\tdata = (u8 *)sec->section;\n\n\t\t/*look for proper table*/\n\t\ttable_id = data[0];\n\n\t\tif (ts->on_event) {\n\t\t\tswitch (table_id) {\n\t\t\tcase GF_M2TS_TABLE_ID_PAT:\n\t\t\tcase GF_M2TS_TABLE_ID_SDT_ACTUAL:\n\t\t\tcase GF_M2TS_TABLE_ID_PMT:\n\t\t\tcase GF_M2TS_TABLE_ID_NIT_ACTUAL:\n\t\t\tcase GF_M2TS_TABLE_ID_TDT:\n\t\t\tcase GF_M2TS_TABLE_ID_TOT:\n\t\t\t{\n\t\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\t\tpck.data_len = sec->length;\n\t\t\t\tpck.data = sec->section;\n\t\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\t\tts->on_event(ts, GF_M2TS_EVT_DVB_GENERAL, &pck);\n\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thas_syntax_indicator = (data[1] & 0x80) ? 1 : 0;\n\t\tif (has_syntax_indicator) {\n\t\t\textended_table_id = (data[3]<<8) | data[4];\n\t\t} else {\n\t\t\textended_table_id = 0;\n\t\t}\n\n\t\tprev_t = NULL;\n\t\tt = sec->table;\n\t\twhile (t) {\n\t\t\tif ((t->table_id==table_id) && (t->ex_table_id == extended_table_id)) break;\n\t\t\tprev_t = t;\n\t\t\tt = t->next;\n\t\t}\n\n\t\t/*create table*/\n\t\tif (!t) {\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Table);\n\t\t\tif (!t) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc table %d %d\\n\", table_id, extended_table_id));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Creating table %d %d\\n\", table_id, extended_table_id));\n\t\t\tt->table_id = table_id;\n\t\t\tt->ex_table_id = extended_table_id;\n\t\t\tt->last_version_number = 0xFF;\n\t\t\tt->sections = gf_list_new();\n\t\t\tif (prev_t) prev_t->next = t;\n\t\t\telse sec->table = t;\n\t\t}\n\n\t\tif (has_syntax_indicator) {\n\t\t\tif (sec->length < 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted section length %d less than CRC \\n\", sec->length));\n\t\t\t} else {\n\t\t\t\t/*remove crc32*/\n\t\t\t\tsec->length -= 4;\n\t\t\t\tif (gf_m2ts_crc32_check((char *)data, sec->length)) {\n\t\t\t\t\ts32 cur_sec_num;\n\t\t\t\t\tt->version_number = (data[5] >> 1) & 0x1f;\n\t\t\t\t\tif (t->last_section_number && t->section_number && (t->version_number != t->last_version_number)) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] table transmission interrupted: previous table (v=%d) %d/%d sections - new table (v=%d) %d/%d sections\\n\", t->last_version_number, t->section_number, t->last_section_number, t->version_number, data[6] + 1, data[7] + 1) );\n\t\t\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t\t\t\tt->section_number = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tt->current_next_indicator = (data[5] & 0x1) ? 1 : 0;\n\t\t\t\t\t/*add one to section numbers to detect if we missed or not the first section in the table*/\n\t\t\t\t\tcur_sec_num = data[6] + 1;\n\t\t\t\t\tt->last_section_number = data[7] + 1;\n\t\t\t\t\tsection_start = 8;\n\t\t\t\t\t/*we missed something*/\n\t\t\t\t\tif (!sec->process_individual && t->section_number + 1 != cur_sec_num) {\n\t\t\t\t\t\t/* TODO - Check how to handle sections when the first complete section does\n\t\t\t\t\t\t   not have its sec num 0 */\n\t\t\t\t\t\tsection_valid = 0;\n\t\t\t\t\t\tif (t->is_init) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted table (lost section %d)\\n\", cur_sec_num ? cur_sec_num-1 : 31) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsection_valid = 1;\n\t\t\t\t\t\tt->section_number = cur_sec_num;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted section (CRC32 failed)\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsection_valid = 1;\n\t\t\tsection_start = 3;\n\t\t}\n\t\t/*process section*/\n\t\tif (section_valid) {\n\t\t\tGF_M2TS_Section *section;\n\n\t\t\tGF_SAFEALLOC(section, GF_M2TS_Section);\n\t\t\tif (!section) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create section\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsection->data_size = sec->length - section_start;\n\t\t\tsection->data = (unsigned char*)gf_malloc(sizeof(unsigned char)*section->data_size);\n\t\t\tmemcpy(section->data, sec->section + section_start, sizeof(unsigned char)*section->data_size);\n\t\t\tgf_list_add(t->sections, section);\n\n\t\t\tif (t->section_number == 1) {\n\t\t\t\tstatus |= GF_M2TS_TABLE_START;\n\t\t\t\tif (t->last_version_number == t->version_number) {\n\t\t\t\t\tt->is_repeat = 1;\n\t\t\t\t} else {\n\t\t\t\t\tt->is_repeat = 0;\n\t\t\t\t}\n\t\t\t\t/*only update version number in the first section of the table*/\n\t\t\t\tt->last_version_number = t->version_number;\n\t\t\t}\n\n\t\t\tif (t->is_init) {\n\t\t\t\tif (t->is_repeat) {\n\t\t\t\t\tstatus |=  GF_M2TS_TABLE_REPEAT;\n\t\t\t\t} else {\n\t\t\t\t\tstatus |=  GF_M2TS_TABLE_UPDATE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus |=  GF_M2TS_TABLE_FOUND;\n\t\t\t}\n\n\t\t\tif (t->last_section_number == t->section_number) {\n\t\t\t\tu32 table_size;\n\n\t\t\t\tstatus |= GF_M2TS_TABLE_END;\n\n\t\t\t\ttable_size = 0;\n\t\t\t\tfor (i=0; i<gf_list_count(t->sections); i++) {\n\t\t\t\t\tGF_M2TS_Section *section = gf_list_get(t->sections, i);\n\t\t\t\t\ttable_size += section->data_size;\n\t\t\t\t}\n\t\t\t\tif (t->is_repeat) {\n\t\t\t\t\tif (t->table_size != table_size) {\n\t\t\t\t\t\tstatus |= GF_M2TS_TABLE_UPDATE;\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Repeated section found with different sizes (old table %d bytes, new table %d bytes)\\n\", t->table_size, table_size) );\n\n\t\t\t\t\t\tt->table_size = table_size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tt->table_size = table_size;\n\t\t\t\t}\n\n\t\t\t\tt->is_init = 1;\n\t\t\t\t/*reset section number*/\n\t\t\t\tt->section_number = 0;\n\n\t\t\t\tt->is_repeat = 0;\n\n\t\t\t}\n\n\t\t\tif (sec->process_individual) {\n\t\t\t\t/*send each section of the table and not the aggregated table*/\n\t\t\t\tif (sec->process_section)\n\t\t\t\t\tsec->process_section(ts, ses, t->sections, t->table_id, t->ex_table_id, t->version_number, (u8) (t->last_section_number - 1), status);\n\n\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t} else {\n\t\t\t\tif (status&GF_M2TS_TABLE_END) {\n\t\t\t\t\tif (sec->process_section)\n\t\t\t\t\t\tsec->process_section(ts, ses, t->sections, t->table_id, t->ex_table_id, t->version_number, (u8) (t->last_section_number - 1), status);\n\n\t\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tsec->cc = -1;\n\t\t\tt->section_number = 0;\n\t\t}\n\t}\n\t/*clean-up (including broken sections)*/\n\tif (sec->section) gf_free(sec->section);\n\tsec->section = NULL;\n\tsec->length = sec->received = 0;\n}\n\nstatic Bool gf_m2ts_is_long_section(u8 table_id)\n{\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_MPEG4_BIFS:\n\tcase GF_M2TS_TABLE_ID_MPEG4_OD:\n\tcase GF_M2TS_TABLE_ID_INT:\n\tcase GF_M2TS_TABLE_ID_EIT_ACTUAL_PF:\n\tcase GF_M2TS_TABLE_ID_EIT_OTHER_PF:\n\tcase GF_M2TS_TABLE_ID_ST:\n\tcase GF_M2TS_TABLE_ID_SIT:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_PRIVATE:\n\tcase GF_M2TS_TABLE_ID_MPE_FEC:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_DOWNLOAD_DATA_MESSAGE:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_UN_MESSAGE:\n\t\treturn 1;\n\tdefault:\n\t\tif (table_id >= GF_M2TS_TABLE_ID_EIT_SCHEDULE_MIN && table_id <= GF_M2TS_TABLE_ID_EIT_SCHEDULE_MAX)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\nstatic u32 gf_m2ts_get_section_length(char byte0, char byte1, char byte2)\n{\n\tu32 length;\n\tif (gf_m2ts_is_long_section(byte0)) {\n\t\tlength = 3 + ( ((((u32)byte1)<<8) | (byte2&0xff)) & 0xfff );\n\t} else {\n\t\tlength = 3 + ( ((((u32)byte1)<<8) | (byte2&0xff)) & 0x3ff );\n\t}\n\treturn length;\n}\n\nstatic void gf_m2ts_gather_section(GF_M2TS_Demuxer *ts, GF_M2TS_SectionFilter *sec, GF_M2TS_SECTION_ES *ses, GF_M2TS_Header *hdr, unsigned char *data, u32 data_size)\n{\n\tu32 payload_size = data_size;\n\tu8 expect_cc = (sec->cc<0) ? hdr->continuity_counter : (sec->cc + 1) & 0xf;\n\tBool disc = (expect_cc == hdr->continuity_counter) ? 0 : 1;\n\tsec->cc = expect_cc;\n\n\t/*may happen if hdr->adaptation_field=2 no payload in TS packet*/\n\tif (!data_size) return;\n\n\tif (hdr->payload_start) {\n\t\tu32 ptr_field;\n\n\t\tptr_field = data[0];\n\t\tif (ptr_field+1>data_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid section start (@ptr_field=%d, @data_size=%d)\\n\", ptr_field, data_size) );\n\t\t\treturn;\n\t\t}\n\n\t\t/*end of previous section*/\n\t\tif (!sec->length && sec->received) {\n\t\t\t/* the length of the section could not be determined from the previous TS packet because we had only 1 or 2 bytes */\n\t\t\tif (sec->received == 1)\n\t\t\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], data[1], data[2]);\n\t\t\telse /* (sec->received == 2)  */\n\t\t\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], sec->section[1], data[1]);\n\t\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*sec->length);\n\t\t}\n\n\t\tif (sec->length && sec->received + ptr_field >= sec->length) {\n\t\t\tu32 len = sec->length - sec->received;\n\t\t\tmemcpy(sec->section + sec->received, data+1, sizeof(char)*len);\n\t\t\tsec->received += len;\n\t\t\tif (ptr_field > len)\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid pointer field (@ptr_field=%d, @remaining=%d)\\n\", ptr_field, len) );\n\t\t\tgf_m2ts_section_complete(ts, sec, ses);\n\t\t}\n\t\tdata += ptr_field+1;\n\t\tdata_size -= ptr_field+1;\n\t\tpayload_size -= ptr_field+1;\n\naggregated_section:\n\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->length = sec->received = 0;\n\t\tsec->section = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tmemcpy(sec->section, data, sizeof(char)*data_size);\n\t\tsec->received = data_size;\n\t} else if (disc) {\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->section = NULL;\n\t\tsec->received = sec->length = 0;\n\t\treturn;\n\t} else if (!sec->section) {\n\t\treturn;\n\t} else {\n\t\tif (sec->length && sec->received+data_size > sec->length)\n\t\t\tdata_size = sec->length - sec->received;\n\n\t\tif (sec->length) {\n\t\t\tmemcpy(sec->section + sec->received, data, sizeof(char)*data_size);\n\t\t} else {\n\t\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*(sec->received+data_size));\n\t\t\tmemcpy(sec->section + sec->received, data, sizeof(char)*data_size);\n\t\t}\n\t\tsec->received += data_size;\n\t}\n\t/*alloc final buffer*/\n\tif (!sec->length && (sec->received >= 3)) {\n\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], sec->section[1], sec->section[2]);\n\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*sec->length);\n\n\t\tif (sec->received > sec->length) {\n\t\t\tdata_size -= sec->received - sec->length;\n\t\t\tsec->received = sec->length;\n\t\t}\n\t}\n\tif (!sec->length || sec->received < sec->length) return;\n\n\t/*OK done*/\n\tgf_m2ts_section_complete(ts, sec, ses);\n\n\tif (payload_size > data_size) {\n\t\tdata += data_size;\n\t\t/* detect padding after previous section */\n\t\tif (data[0] != 0xFF) {\n\t\t\tdata_size = payload_size - data_size;\n\t\t\tpayload_size = data_size;\n\t\t\tgoto aggregated_section;\n\t\t}\n\t}\n}\n\nstatic void gf_m2ts_process_sdt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 pos, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SDT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tif (table_id != GF_M2TS_TABLE_ID_SDT_ACTUAL) {\n\t\treturn;\n\t}\n\n\tgf_m2ts_reset_sdt(ts);\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SDT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t//orig_net_id = (data[0] << 8) | data[1];\n\tpos = 3;\n\twhile (pos < data_size) {\n\t\tGF_M2TS_SDT *sdt;\n\t\tu32 descs_size, d_pos, ulen;\n\n\t\tGF_SAFEALLOC(sdt, GF_M2TS_SDT);\n\t\tif (!sdt) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create SDT\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tgf_list_add(ts->SDTs, sdt);\n\n\t\tsdt->service_id = (data[pos]<<8) + data[pos+1];\n\t\tsdt->EIT_schedule = (data[pos+2] & 0x2) ? 1 : 0;\n\t\tsdt->EIT_present_following = (data[pos+2] & 0x1);\n\t\tsdt->running_status = (data[pos+3]>>5) & 0x7;\n\t\tsdt->free_CA_mode = (data[pos+3]>>4) & 0x1;\n\t\tdescs_size = ((data[pos+3]&0xf)<<8) | data[pos+4];\n\t\tpos += 5;\n\n\t\td_pos = 0;\n\t\twhile (d_pos < descs_size) {\n\t\t\tu8 d_tag = data[pos+d_pos];\n\t\t\tu8 d_len = data[pos+d_pos+1];\n\n\t\t\tswitch (d_tag) {\n\t\t\tcase GF_M2TS_DVB_SERVICE_DESCRIPTOR:\n\t\t\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\t\t\tsdt->provider = NULL;\n\t\t\t\tif (sdt->service) gf_free(sdt->service);\n\t\t\t\tsdt->service = NULL;\n\n\t\t\t\td_pos+=2;\n\t\t\t\tsdt->service_type = data[pos+d_pos];\n\t\t\t\tulen = data[pos+d_pos+1];\n\t\t\t\td_pos += 2;\n\t\t\t\tsdt->provider = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->provider, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->provider[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\n\t\t\t\tulen = data[pos+d_pos];\n\t\t\t\td_pos += 1;\n\t\t\t\tsdt->service = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->service, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->service[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) not supported\\n\", d_tag));\n\t\t\t\td_pos += d_len;\n\t\t\t\tif (d_len == 0) d_pos = descs_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpos += descs_size;\n\t}\n\tevt_type = GF_M2TS_EVT_SDT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nstatic void gf_m2ts_process_mpeg4section(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_SL_PCK sl_pck;\n\tu32 nb_sections, i;\n\tGF_M2TS_Section *section;\n\n\t/*skip if already received*/\n\tif (status & GF_M2TS_TABLE_REPEAT)\n\t\tif (!(es->flags & GF_M2TS_ES_SEND_REPEATED_SECTIONS))\n\t\t\treturn;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Sections for PID %d\\n\", es->pid) );\n\t/*send all sections (eg SL-packets)*/\n\tnb_sections = gf_list_count(sections);\n\tfor (i=0; i<nb_sections; i++) {\n\t\tsection = (GF_M2TS_Section *)gf_list_get(sections, i);\n\t\tsl_pck.data = (char *)section->data;\n\t\tsl_pck.data_len = section->data_size;\n\t\tsl_pck.stream = (GF_M2TS_ES *)es;\n\t\tsl_pck.version_number = version_number;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t}\n}\n\nstatic void gf_m2ts_process_nit(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *nit_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] NIT table processing (not yet implemented)\"));\n}\n\n\n\n\nstatic void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt_tot_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tunsigned char *data;\n\tu32 data_size, nb_sections;\n\tu32 date, yp, mp, k;\n\tGF_M2TS_Section *section;\n\tGF_M2TS_TDT_TOT *time_table;\n\tconst char *table_name;\n\n\t/*wait for the last section */\n\tif ( !(status & GF_M2TS_TABLE_END) )\n\t\treturn;\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\ttable_name = \"TDT\";\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n\t\ttable_name = \"TOT\";\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Unimplemented table_id %u for PID %u\\n\", table_id, GF_M2TS_PID_TDT_TOT_ST));\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] %s on multiple sections not supported\\n\", table_name));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t/*TOT only contains 40 bits of UTC_time; TDT add descriptors and a CRC*/\n\tif ((table_id==GF_M2TS_TABLE_ID_TDT) && (data_size != 5)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Corrupted TDT size\\n\", table_name));\n\t}\n\tGF_SAFEALLOC(time_table, GF_M2TS_TDT_TOT);\n\tif (!time_table) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc DVB time table\\n\"));\n\t\treturn;\n\t}\n\n\t/*UTC_time - see annex C of DVB-SI ETSI EN 300468*/\n/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)\nSee annex C of DVB-SI ETSI EN 300468 */\n\tdate = data[0]*256 + data[1];\n\typ = (u32)((date - 15078.2)/365.25);\n\tmp = (u32)((date - 14956.1 - (u32)(yp * 365.25))/30.6001);\n\ttime_table->day = (u32)(date - 14956 - (u32)(yp * 365.25) - (u32)(mp * 30.6001));\n\tif (mp == 14 || mp == 15) k = 1;\n\telse k = 0;\n\ttime_table->year = yp + k + 1900;\n\ttime_table->month = mp - 1 - k*12;\n\n\ttime_table->hour   = 10*((data[2]&0xf0)>>4) + (data[2]&0x0f);\n\ttime_table->minute = 10*((data[3]&0xf0)>>4) + (data[3]&0x0f);\n\ttime_table->second = 10*((data[4]&0xf0)>>4) + (data[4]&0x0f);\n\tassert(time_table->hour<24 && time_table->minute<60 && time_table->second<60);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream UTC time is %u/%02u/%02u %02u:%02u:%02u\\n\", time_table->year, time_table->month, time_table->day, time_table->hour, time_table->minute, time_table->second));\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\t\tts->TDT_time = time_table;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TDT, time_table);\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n#if 0\n\t{\n\t\tu32 pos, loop_len;\n\t\tloop_len = ((data[5]&0x0f) << 8) | (data[6] & 0xff);\n\t\tdata += 7;\n\t\tpos = 0;\n\t\twhile (pos < loop_len) {\n\t\t\tu8 tag = data[pos];\n\t\t\tpos += 2;\n\t\t\tif (tag == GF_M2TS_DVB_LOCAL_TIME_OFFSET_DESCRIPTOR) {\n\t\t\t\tchar tmp_time[10];\n\t\t\t\tu16 offset_hours, offset_minutes;\n\t\t\t\tnow->country_code[0] = data[pos];\n\t\t\t\tnow->country_code[1] = data[pos+1];\n\t\t\t\tnow->country_code[2] = data[pos+2];\n\t\t\t\tnow->country_region_id = data[pos+3]>>2;\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+4]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+5]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->local_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->local_time_offset_seconds *= -1;\n\n\t\t\t\tdvb_decode_mjd_to_unix_time(data+pos+6, &now->unix_next_toc);\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+11]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+12]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->next_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->next_time_offset_seconds *= -1;\n\t\t\t\tpos+= 13;\n\t\t\t}\n\t\t}\n\t\t/*TODO: check lengths are ok*/\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\t}\n#endif\n\t/*check CRC32*/\n\tif (ts->tdt_tot->length<4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (less than 4 bytes but CRC32 should be present\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (!gf_m2ts_crc32_check(ts->tdt_tot->section, ts->tdt_tot->length-4)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (CRC32 failed)\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tts->TDT_time = time_table;\n\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tgoto error_exit;\n\t}\n\n\treturn; /*success*/\n\nerror_exit:\n\tgf_free(time_table);\n\treturn;\n}\n\nstatic GF_M2TS_MetadataPointerDescriptor *gf_m2ts_read_metadata_pointer_descriptor(GF_BitStream *bs, u32 length)\n{\n\tu32 size;\n\tGF_M2TS_MetadataPointerDescriptor *d;\n\tGF_SAFEALLOC(d, GF_M2TS_MetadataPointerDescriptor);\n\tif (!d) return NULL;\n\td->application_format = gf_bs_read_u16(bs);\n\tsize = 2;\n\tif (d->application_format == 0xFFFF) {\n\t\td->application_format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->format = gf_bs_read_u8(bs);\n\tsize += 1;\n\tif (d->format == 0xFF) {\n\t\td->format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->service_id = gf_bs_read_u8(bs);\n\td->locator_record_flag = (gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE);\n\td->carriage_flag = (enum metadata_carriage)gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 5); /*reserved */\n\tsize += 2;\n\tif (d->locator_record_flag) {\n\t\td->locator_length = gf_bs_read_u8(bs);\n\t\td->locator_data = (char *)gf_malloc(d->locator_length);\n\t\tsize += 1 + d->locator_length;\n\t\tgf_bs_read_data(bs, d->locator_data, d->locator_length);\n\t}\n\tif (d->carriage_flag != 3) {\n\t\td->program_number = gf_bs_read_u16(bs);\n\t\tsize += 2;\n\t}\n\tif (d->carriage_flag == 1) {\n\t\td->ts_location = gf_bs_read_u16(bs);\n\t\td->ts_id = gf_bs_read_u16(bs);\n\t\tsize += 4;\n\t}\n\tif (length-size > 0) {\n\t\td->data_size = length-size;\n\t\td->data = (char *)gf_malloc(d->data_size);\n\t\tgf_bs_read_data(bs, d->data, d->data_size);\n\t}\n\treturn d;\n}\n\nstatic void gf_m2ts_metadata_pointer_descriptor_del(GF_M2TS_MetadataPointerDescriptor *metapd)\n{\n\tif (metapd) {\n\t\tif (metapd->locator_data) gf_free(metapd->locator_data);\n\t\tif (metapd->data) gf_free(metapd->data);\n\t\tgf_free(metapd);\n\t}\n}\n\nstatic GF_M2TS_MetadataDescriptor *gf_m2ts_read_metadata_descriptor(GF_BitStream *bs, u32 length)\n{\n\tu32 size;\n\tGF_M2TS_MetadataDescriptor *d;\n\tGF_SAFEALLOC(d, GF_M2TS_MetadataDescriptor);\n\tif (!d) return NULL;\n\td->application_format = gf_bs_read_u16(bs);\n\tsize = 2;\n\tif (d->application_format == 0xFFFF) {\n\t\td->application_format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->format = gf_bs_read_u8(bs);\n\tsize += 1;\n\tif (d->format == 0xFF) {\n\t\td->format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->service_id = gf_bs_read_u8(bs);\n\td->decoder_config_flags = gf_bs_read_int(bs, 3);\n\td->dsmcc_flag = (gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE);\n\tgf_bs_read_int(bs, 4); /* reserved */\n\tsize += 2;\n\tif (d->dsmcc_flag) {\n\t\td->service_id_record_length = gf_bs_read_u8(bs);\n\t\td->service_id_record = (char *)gf_malloc(d->service_id_record_length);\n\t\tsize += 1 + d->service_id_record_length;\n\t\tgf_bs_read_data(bs, d->service_id_record, d->service_id_record_length);\n\t}\n\tif (d->decoder_config_flags == 1) {\n\t\td->decoder_config_length = gf_bs_read_u8(bs);\n\t\td->decoder_config = (char *)gf_malloc(d->decoder_config_length);\n\t\tsize += 1 + d->decoder_config_length;\n\t\tgf_bs_read_data(bs, d->decoder_config, d->decoder_config_length);\n\t}\n\tif (d->decoder_config_flags == 3) {\n\t\td->decoder_config_id_length = gf_bs_read_u8(bs);\n\t\td->decoder_config_id = (char *)gf_malloc(d->decoder_config_id_length);\n\t\tsize += 1 + d->decoder_config_id_length;\n\t\tgf_bs_read_data(bs, d->decoder_config_id, d->decoder_config_id_length);\n\t}\n\tif (d->decoder_config_flags == 4) {\n\t\td->decoder_config_service_id = gf_bs_read_u8(bs);\n\t\tsize++;\n\t}\n\treturn d;\n}\n\n\nstatic void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 info_length, pos, desc_len, evt_type, nb_es,i;\n\tu32 nb_sections;\n\tu32 data_size;\n\tu32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\tGF_Err e = GF_OK;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\tnb_es = 0;\n\n\t/*skip if already received but no update detected (eg same data) */\n\tif ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t\treturn;\n\t}\n\n\tif (pmt->sec->demux_restarted) {\n\t\tpmt->sec->demux_restarted = 0;\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {\n\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\tpmt->program->metadata_pointer_descriptor = metapd;\n\t\t\t\t} else {\n\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\tgf_m2ts_metadata_pointer_descriptor_del(metapd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));\n\t\t\t}\n\t\t\tfirst_loop_len += 2 + len;\n\t\t}\n\t}\n\tif (data_size <= 4 + info_length) return;\n\tdata += 4 + info_length;\n\tdata_size -= 4 + info_length;\n\tpos = 0;\n\n\t/* count de number of program related PMT received */\n\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\tGF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\tif(prog->pmt_pid == pmt->pid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;\n\twhile (pos<data_size) {\n\t\tGF_M2TS_PES *pes = NULL;\n\t\tGF_M2TS_SECTION_ES *ses = NULL;\n\t\tGF_M2TS_ES *es = NULL;\n\t\tBool inherit_pcr = 0;\n\t\tu32 pid, stream_type, reg_desc_format;\n\n\t\tif (pos + 5 > data_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT! size %d but position %d and need at least 5 bytes to declare es\\n\", data_size, pos));\n\t\t\tbreak;\n\t\t}\n\n\t\tstream_type = data[0];\n\t\tpid = ((data[1] & 0x1f) << 8) | data[2];\n\t\tdesc_len = ((data[3] & 0xf) << 8) | data[4];\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));\n\t\tswitch (stream_type) {\n\n\t\t/* PES */\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_DCII:\n\t\tcase GF_M2TS_VIDEO_MPEG4:\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_MVCD:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\tinherit_pcr = 1;\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_DTS:\n\t\tcase GF_M2TS_MHAS_MAIN:\n\t\tcase GF_M2TS_MHAS_AUX:\n\t\tcase GF_M2TS_SUBTITLE_DVB:\n\t\tcase GF_M2TS_METADATA_PES:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tif (inherit_pcr)\n\t\t\t\tpes->flags |= GF_M2TS_INHERIT_PCR;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\t/* Sections */\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\t/* carriage of ISO_IEC_14496 data in sections */\n\t\t\tif (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {\n\t\t\t\t/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost\n\t\t\t\tone SL packet in the AU so we must wait for the complete section again*/\n\t\t\t\tses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);\n\t\t\t\t/*create OD container*/\n\t\t\t\tif (!pmt->program->additional_ods) {\n\t\t\t\t\tpmt->program->additional_ods = gf_list_new();\n\t\t\t\t\tts->has_4on2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_13818_6_ANNEX_A:\n\t\tcase GF_M2TS_13818_6_ANNEX_B:\n\t\tcase GF_M2TS_13818_6_ANNEX_C:\n\t\tcase GF_M2TS_13818_6_ANNEX_D:\n\t\tcase GF_M2TS_PRIVATE_SECTION:\n\t\tcase GF_M2TS_QUALITY_SEC:\n\t\tcase GF_M2TS_MORE_SEC:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\tes->pid = pid;\n\t\t\tes->service_id = pmt->program->number;\n\t\t\tif (stream_type == GF_M2TS_PRIVATE_SECTION) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_QUALITY_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_MORE_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));\n\t\t\t}\n\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t//ses->sec->service_id = pmt->program->number;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_MPE_SECTIONS:\n\t\t\tif (! ts->prefix_present) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));\n#ifdef GPAC_ENABLE_MPE\n\t\t\t\tes = gf_dvb_mpe_section_new();\n\t\t\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\t\t\t((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\t//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (es) {\n\t\t\tes->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;\n\t\t\tes->program = pmt->program;\n\t\t\tes->pid = pid;\n\t\t\tes->component_tag = -1;\n\t\t}\n\n\t\tpos += 5;\n\t\tdata += 5;\n\n\t\twhile (desc_len) {\n\t\t\tif (pos + 2 > data_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d but position %d and need at least 2 bytes to parse descritpor\\n\", data_size, pos));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu8 tag = data[0];\n\t\t\tu32 len = data[1];\n\n\t\t\tif (pos + 2 + len > data_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d, desc size %d but position %d\\n\", data_size, len, pos));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (es) {\n\t\t\t\tswitch (tag) {\n\t\t\t\tcase GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=3) )\n\t\t\t\t\t\tpes->lang = GF_4CC(' ', data[2], data[3], data[4]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_MPEG4_SL_DESCRIPTOR:\n\t\t\t\t\tif (len>=2) {\n\t\t\t\t\t\tes->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];\n\t\t\t\t\t\tes->flags |= GF_M2TS_ES_IS_SL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_REGISTRATION_DESCRIPTOR:\n\t\t\t\t\tif (len>=4) {\n\t\t\t\t\t\treg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);\n\t\t\t\t\t\t/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/\n\t\t\t\t\t\tswitch (reg_desc_format) {\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_AC3:\n\t\t\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_AC3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_VC1:\n\t\t\t\t\t\t\tes->stream_type = GF_M2TS_VIDEO_VC1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_GPAC:\n\t\t\t\t\t\t\tif (len==8) {\n\t\t\t\t\t\t\t\tes->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);\n\t\t\t\t\t\t\t\tes->flags |= GF_M2TS_GPAC_CODEC_ID;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_EAC3_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_EC3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:\n\t\t\t\t\tif (len>=2) {\n\t\t\t\t\t\tu32 id = data[2]<<8 | data[3];\n\t\t\t\t\t\tif ((id == 0xB) && ses && !ses->sec) {\n\t\t\t\t\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=8)) {\n\t\t\t\t\t\tpes->sub.language[0] = data[2];\n\t\t\t\t\t\tpes->sub.language[1] = data[3];\n\t\t\t\t\t\tpes->sub.language[2] = data[4];\n\t\t\t\t\t\tpes->sub.type = data[5];\n\t\t\t\t\t\tpes->sub.composition_page_id = (data[6]<<8) | data[7];\n\t\t\t\t\t\tpes->sub.ancillary_page_id = (data[8]<<8) | data[9];\n\t\t\t\t\t}\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_SUBTITLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:\n\t\t\t\t\tif (len>=1) {\n\t\t\t\t\t\tes->component_tag = data[2];\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_TELETEXT_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_TELETEXT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_VBI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_HIERARCHY_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=4)) {\n\t\t\t\t\t\tu8 hierarchy_embedded_layer_index;\n\t\t\t\t\t\tGF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);\n\t\t\t\t\t\t/*u32 skip = */gf_bs_read_int(hbs, 16);\n\t\t\t\t\t\t/*u8 res1 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 temp_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 quality_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);\n\t\t\t\t\t\t/*u8 res2 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 res3 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\thierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 res4 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\tgf_bs_del(hbs);\n\n\t\t\t\t\t\tpes->depends_on_pid = 1+hierarchy_embedded_layer_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_METADATA_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tGF_BitStream *metadatad_bs;\n\t\t\t\t\tGF_M2TS_MetadataDescriptor *metad;\n\t\t\t\t\tmetadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);\n\t\t\t\t\tmetad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);\n\t\t\t\t\tgf_bs_del(metadatad_bs);\n\t\t\t\t\tif (metad->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t\t        metad->format_identifier == GF_M2TS_META_ID3) {\n\t\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\t\tif (pes) {\n\t\t\t\t\t\t\tpes->metadata_descriptor = metad;\n\t\t\t\t\t\t\tpes->stream_type = GF_M2TS_METADATA_ID3_HLS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\t\tgf_m2ts_metadata_descriptor_del(metad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata += len+2;\n\t\t\tpos += len+2;\n\t\t\tif (desc_len < len+2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc_len-=len+2;\n\t\t}\n\n\t\tif (es && !es->stream_type) {\n\t\t\tgf_free(es);\n\t\t\tes = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t}\n\n\t\tif (!es) continue;\n\n\t\tif (ts->ess[pid]) {\n\t\t\t//this is component reuse across programs, overwrite the previously declared stream ...\n\t\t\tif (status & GF_M2TS_TABLE_FOUND) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );\n\n\t\t\t\t//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)\n\t\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\t\tnb_es++;\n\t\t\t\t//skip assignment below\n\t\t\t\tes = NULL;\n\t\t\t}\n\t\t\t/*watchout for pmt update - FIXME this likely won't work in most cases*/\n\t\t\telse {\n\n\t\t\t\tGF_M2TS_ES *o_es = ts->ess[es->pid];\n\n\t\t\t\tif ((o_es->stream_type == es->stream_type)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))\n\t\t\t\t        && (o_es->mpeg4_es_id == es->mpeg4_es_id)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)\n\t\t\t\t   ) {\n\t\t\t\t\tgf_free(es);\n\t\t\t\t\tes = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tgf_m2ts_es_del(o_es, ts);\n\t\t\t\t\tts->ess[es->pid] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {\n\t\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 2;\n\t\t\t\telse es->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_es) {\n\t\tu32 i;\n\n\t\t//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *an_es = NULL;\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (!es->depends_on_pid) continue;\n\n\t\t\t//fixeme we are not always assured that hierarchy_layer_index matches the stream index...\n\t\t\t//+1 is because our first stream is the PMT\n\t\t\tan_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);\n\t\t\tif (an_es) {\n\t\t\t\tes->depends_on_pid = an_es->pid;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));\n\t\t\t\tes->depends_on_pid = 0;\n\t\t\t}\n\t\t}\n\n\t\tevt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;\n\t\tif (ts->on_event) ts->on_event(ts, evt_type, pmt->program);\n\t} else {\n\t\t/* if we found no new ES it's simply a repeat of the PMT */\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t}\n}\n\nstatic void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nstatic void gf_m2ts_process_cat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 evt_type;\n\t/*\n\t\tGF_M2TS_Program *prog;\n\t\tGF_M2TS_SECTION_ES *pmt;\n\t\tu32 i, nb_progs;\n\t\tu32 nb_sections;\n\t\tu32 data_size;\n\t\tunsigned char *data;\n\t\tGF_M2TS_Section *section;\n\t*/\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_CAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\t/*\n\t\tnb_sections = gf_list_count(sections);\n\t\tif (nb_sections > 1) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"CAT on multiple sections not supported\\n\"));\n\t\t}\n\n\t\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\t\tdata = section->data;\n\t\tdata_size = section->data_size;\n\n\t\tnb_progs = data_size / 4;\n\n\t\tfor (i=0; i<nb_progs; i++) {\n\t\t\tu16 number, pid;\n\t\t\tnumber = (data[0]<<8) | data[1];\n\t\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\t\tdata += 4;\n\t\t\tif (number==0) {\n\t\t\t\tif (!ts->nit) {\n\t\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\t\tprog->streams = gf_list_new();\n\t\t\t\tprog->pmt_pid = pid;\n\t\t\t\tprog->number = number;\n\t\t\t\tgf_list_add(ts->programs, prog);\n\t\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\t\tpmt->program = prog;\n\t\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t\t}\n\t\t}\n\t*/\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_CAT_UPDATE : GF_M2TS_EVT_CAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nu64 gf_m2ts_get_pts(unsigned char *data)\n{\n\tu64 pts;\n\tu32 val;\n\tpts = (u64)((data[0] >> 1) & 0x07) << 30;\n\tval = (data[1] << 8) | data[2];\n\tpts |= (u64)(val >> 1) << 15;\n\tval = (data[3] << 8) | data[4];\n\tpts |= (u64)(val >> 1);\n\treturn pts;\n}\n\nvoid gf_m2ts_pes_header(GF_M2TS_PES *pes, unsigned char *data, u32 data_size, GF_M2TS_PESHeader *pesh)\n{\n\tu32 has_pts, has_dts;\n\tu32 len_check;\n\tmemset(pesh, 0, sizeof(GF_M2TS_PESHeader));\n\n\tlen_check = 0;\n\n\tpesh->id = data[0];\n\tpesh->pck_len = (data[1]<<8) | data[2];\n\t/*\n\t\t2bits\n\t\tscrambling_control\t\t= gf_bs_read_int(bs,2);\n\t\tpriority\t\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\tpesh->data_alignment = (data[3] & 0x4) ? 1 : 0;\n\t/*\n\t\tcopyright\t\t\t\t= gf_bs_read_int(bs,1);\n\t\toriginal\t\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\thas_pts = (data[4]&0x80);\n\thas_dts = has_pts ? (data[4]&0x40) : 0;\n\t/*\n\t\tESCR_flag\t\t\t\t= gf_bs_read_int(bs,1);\n\t\tES_rate_flag\t\t\t= gf_bs_read_int(bs,1);\n\t\tDSM_flag\t\t\t\t= gf_bs_read_int(bs,1);\n\t\tadditional_copy_flag\t= gf_bs_read_int(bs,1);\n\t\tprev_crc_flag\t\t\t= gf_bs_read_int(bs,1);\n\t\textension_flag\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\n\tpesh->hdr_data_len = data[5];\n\n\tdata += 6;\n\tif (has_pts) {\n\t\tpesh->PTS = gf_m2ts_get_pts(data);\n\t\tdata+=5;\n\t\tlen_check += 5;\n\t}\n\tif (has_dts) {\n\t\tpesh->DTS = gf_m2ts_get_pts(data);\n\t\t//data+=5;\n\t\tlen_check += 5;\n\t} else {\n\t\tpesh->DTS = pesh->PTS;\n\t}\n\tif (len_check < pesh->hdr_data_len) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Skipping %d bytes in pes header\\n\", pes->pid, pesh->hdr_data_len - len_check));\n\t} else if (len_check > pesh->hdr_data_len) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Wrong pes_header_data_length field %d bytes - read %d\\n\", pes->pid, pesh->hdr_data_len, len_check));\n\t}\n\n\tif ((pesh->PTS<90000) && ((s32)pesh->DTS<0)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Wrong DTS %d negative for PTS %d - forcing to 0\\n\", pes->pid, pesh->DTS, pesh->PTS));\n\t\tpesh->DTS=0;\n\t}\n}\n\nstatic void gf_m2ts_store_temi(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes)\n{\n\tGF_BitStream *bs = gf_bs_new(pes->temi_tc_desc, pes->temi_tc_desc_len, GF_BITSTREAM_READ);\n\tu32 has_timestamp = gf_bs_read_int(bs, 2);\n\tBool has_ntp = (Bool) gf_bs_read_int(bs, 1);\n\t/*u32 has_ptp = */gf_bs_read_int(bs, 1);\n\t/*u32 has_timecode = */gf_bs_read_int(bs, 2);\n\n\tmemset(&pes->temi_tc, 0, sizeof(GF_M2TS_TemiTimecodeDescriptor));\n\tpes->temi_tc.force_reload = gf_bs_read_int(bs, 1);\n\tpes->temi_tc.is_paused = gf_bs_read_int(bs, 1);\n\tpes->temi_tc.is_discontinuity = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tpes->temi_tc.timeline_id = gf_bs_read_int(bs, 8);\n\tif (has_timestamp) {\n\t\tpes->temi_tc.media_timescale = gf_bs_read_u32(bs);\n\t\tif (has_timestamp==2)\n\t\t\tpes->temi_tc.media_timestamp = gf_bs_read_u64(bs);\n\t\telse\n\t\t\tpes->temi_tc.media_timestamp = gf_bs_read_u32(bs);\n\t}\n\tif (has_ntp) {\n\t\tpes->temi_tc.ntp = gf_bs_read_u64(bs);\n\t}\n\tgf_bs_del(bs);\n\tpes->temi_tc_desc_len = 0;\n\tpes->temi_pending = 1;\n}\n\nvoid gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes)\n{\n\tGF_M2TS_PESHeader pesh;\n\tif (!ts) return;\n\n\t/*we need at least a full, valid start code and PES header !!*/\n\tif ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) {\n\t\tu32 len;\n\t\tBool has_pes_header = GF_TRUE;\n\t\tu32 stream_id = pes->pck_data[3];\n\t\tBool same_pts = GF_FALSE;\n\n\t\tswitch (stream_id) {\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_MAP:\n\t\tcase GF_M2_STREAMID_PADDING:\n\t\tcase GF_M2_STREAMID_PRIVATE_2:\n\t\tcase GF_M2_STREAMID_ECM:\n\t\tcase GF_M2_STREAMID_EMM:\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY:\n\t\tcase GF_M2_STREAMID_DSMCC:\n\t\tcase GF_M2_STREAMID_H222_TYPE_E:\n\t\t\thas_pes_header = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (has_pes_header) {\n\n\t\t\t/*OK read header*/\n\t\t\tgf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh);\n\n\t\t\t/*send PES timing*/\n\t\t\tif (ts->notify_pes_timing) {\n\t\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\t\tpck.PTS = pesh.PTS;\n\t\t\t\tpck.DTS = pesh.DTS;\n\t\t\t\tpck.stream = pes;\n\t\t\t\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\t\t\t\tpes->pes_end_packet_number = ts->pck_number;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\\n\", pes->pid, pesh.DTS, pesh.PTS));\n\n\t\t\tif (pesh.PTS) {\n\t\t\t\tif (pesh.PTS == pes->PTS) {\n\t\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same PTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->PTS));\n\t\t\t\t}\n\t#ifndef GPAC_DISABLE_LOG\n\t\t\t\t/*FIXME - this test should only be done for non bi-directionnally coded media\n\t\t\t\telse if (pesh.PTS < pes->PTS) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - PTS \"LLU\" less than previous packet PTS \"LLU\"\\n\", pes->pid, pesh.PTS, pes->PTS) );\n\t\t\t\t}\n\t\t\t\t*/\n\t#endif\n\n\t\t\t\tpes->PTS = pesh.PTS;\n\t#ifndef GPAC_DISABLE_LOG\n\t\t\t\t{\n\t\t\t\t\tif (pes->DTS && (pesh.DTS == pes->DTS)) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same DTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t\tif (pesh.DTS < pes->DTS) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - DTS \"LLU\" less than previous DTS \"LLU\"\\n\", pes->pid, pesh.DTS, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t}\n\t#endif\n\t\t\t\tpes->DTS = pesh.DTS;\n\t\t\t}\n\t\t\t/*no PTSs were coded, same time*/\n\t\t\telse if (!pesh.hdr_data_len) {\n\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t}\n\n\n\t\t\t/*3-byte start-code + 6 bytes header + hdr extensions*/\n\t\t\tlen = 9 + pesh.hdr_data_len;\n\n\t\t} else {\n\t\t\t/*3-byte start-code + 1 byte streamid*/\n\t\t\tlen = 4;\n\t\t\tmemset(&pesh, 0, sizeof(pesh));\n\t\t}\n\n\t\tif ((u8) pes->pck_data[3]==0xfa) {\n\t\t\tGF_M2TS_SL_PCK sl_pck;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\\n\", pes->pid, pes->mpeg4_es_id));\n\n\t\t\tif (pes->pck_data_len > len) {\n\t\t\t\tsl_pck.data = (char *)pes->pck_data + len;\n\t\t\t\tsl_pck.data_len = pes->pck_data_len - len;\n\t\t\t\tsl_pck.stream = (GF_M2TS_ES *)pes;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\\n\", pes->pid, pes->pck_data_len, len));\n\t\t\t}\n\t\t} else if (pes->reframe) {\n\t\t\tu32 remain = 0;\n\t\t\tu32 offset = len;\n\n\t\t\tif (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\\n\", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len));\n\t\t\t}\n\t\t\t//copy over the remaining of previous PES payload before start of this PES payload\n\t\t\tif (pes->prev_data_len) {\n\t\t\t\tif (pes->prev_data_len < len) {\n\t\t\t\t\toffset = len - pes->prev_data_len;\n\t\t\t\t\tmemcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\\n\", pes->pid, pes->prev_data_len ));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pes->temi_pending && pes->temi_tc_desc_len) {\n\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\t\t\t}\n\n\t\t\tif (pes->temi_pending) {\n\t\t\t\tpes->temi_pending = 0;\n\t\t\t\tpes->temi_tc.pes_pts = pes->PTS;\n\t\t\t\tif (ts->on_event)\n\t\t\t\t\tts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc);\n\t\t\t}\n\n\t\t\tif (! ts->seek_mode)\n\t\t\t\tremain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh);\n\n\t\t\t//CLEANUP alloc stuff\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tif (remain) {\n\t\t\t\tpes->prev_data = gf_malloc(sizeof(char)*remain);\n\t\t\t\tassert(pes->pck_data_len >= remain);\n\t\t\t\tmemcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain);\n\t\t\t\tpes->prev_data_len = remain;\n\t\t\t}\n\t\t}\n\t} else if (pes->pck_data_len) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\\n\", pes->pid));\n\t}\n\tpes->pck_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->rap = 0;\n}\n\nstatic void gf_m2ts_process_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, GF_M2TS_Header *hdr, unsigned char *data, u32 data_size, GF_M2TS_AdaptationField *paf)\n{\n\tu8 expect_cc;\n\tBool disc=0;\n\tBool flush_pes = 0;\n\n\t/*duplicated packet, NOT A DISCONTINUITY, we should discard the packet - however we may encounter this configuration in DASH at segment boundaries.\n\tIf payload start is set, ignore duplication*/\n\tif (hdr->continuity_counter==pes->cc) {\n\t\tif (!hdr->payload_start || (hdr->adaptation_field!=3) ) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Duplicated Packet found (CC %d) - skipping\\n\", pes->pid, pes->cc));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\texpect_cc = (pes->cc<0) ? hdr->continuity_counter : (pes->cc + 1) & 0xf;\n\t\tif (expect_cc != hdr->continuity_counter)\n\t\t\tdisc = 1;\n\t}\n\tpes->cc = hdr->continuity_counter;\n\n\tif (disc) {\n\t\tif (pes->flags & GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY) {\n\t\t\tpes->flags &= ~GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY;\n\t\t\tdisc = 0;\n\t\t}\n\t\tif (disc) {\n\t\t\tif (hdr->payload_start) {\n\t\t\t\tif (pes->pck_data_len) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Packet discontinuity (%d expected - got %d) - may have lost end of previous PES\\n\", pes->pid, expect_cc, hdr->continuity_counter));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pes->pck_data_len) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Packet discontinuity (%d expected - got %d) - trashing PES packet\\n\", pes->pid, expect_cc, hdr->continuity_counter));\n\t\t\t\t}\n\t\t\t\tpes->pck_data_len = 0;\n\t\t\t\tpes->pes_len = 0;\n\t\t\t\tpes->cc = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!pes->reframe) return;\n\n\tif (hdr->payload_start) {\n\t\tflush_pes = 1;\n\t\tpes->pes_start_packet_number = ts->pck_number;\n\t\tpes->before_last_pcr_value = pes->program->before_last_pcr_value;\n\t\tpes->before_last_pcr_value_pck_number = pes->program->before_last_pcr_value_pck_number;\n\t\tpes->last_pcr_value = pes->program->last_pcr_value;\n\t\tpes->last_pcr_value_pck_number = pes->program->last_pcr_value_pck_number;\n\t} else if (pes->pes_len && (pes->pck_data_len + data_size == pes->pes_len + 6)) {\n\t\t/* 6 = startcode+stream_id+length*/\n\t\t/*reassemble pes*/\n\t\tif (pes->pck_data_len + data_size > pes->pck_alloc_len) {\n\t\t\tpes->pck_alloc_len = pes->pck_data_len + data_size;\n\t\t\tpes->pck_data = (u8*)gf_realloc(pes->pck_data, pes->pck_alloc_len);\n\t\t}\n\t\tmemcpy(pes->pck_data+pes->pck_data_len, data, data_size);\n\t\tpes->pck_data_len += data_size;\n\t\t/*force discard*/\n\t\tdata_size = 0;\n\t\tflush_pes = 1;\n\t}\n\n\t/*PES first fragment: flush previous packet*/\n\tif (flush_pes && pes->pck_data_len) {\n\t\tgf_m2ts_flush_pes(ts, pes);\n\t\tif (!data_size) return;\n\t}\n\t/*we need to wait for first packet of PES*/\n\tif (!pes->pck_data_len && !hdr->payload_start) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Waiting for PES header, trashing data\\n\", hdr->pid));\n\t\treturn;\n\t}\n\t/*reassemble*/\n\tif (pes->pck_data_len + data_size > pes->pck_alloc_len ) {\n\t\tpes->pck_alloc_len = pes->pck_data_len + data_size;\n\t\tpes->pck_data = (u8*)gf_realloc(pes->pck_data, pes->pck_alloc_len);\n\t}\n\tmemcpy(pes->pck_data + pes->pck_data_len, data, data_size);\n\tpes->pck_data_len += data_size;\n\n\tif (paf && paf->random_access_indicator) pes->rap = 1;\n\tif (hdr->payload_start && !pes->pes_len && (pes->pck_data_len>=6)) {\n\t\tpes->pes_len = (pes->pck_data[4]<<8) | pes->pck_data[5];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Got PES packet len %d\\n\", pes->pid, pes->pes_len));\n\n\t\tif (pes->pes_len + 6 == pes->pck_data_len) {\n\t\t\tgf_m2ts_flush_pes(ts, pes);\n\t\t}\n\t}\n}\n\n\nstatic void gf_m2ts_get_adaptation_field(GF_M2TS_Demuxer *ts, GF_M2TS_AdaptationField *paf, unsigned char *data, u32 size, u32 pid)\n{\n\tunsigned char *af_extension;\n\tpaf->discontinuity_indicator = (data[0] & 0x80) ? 1 : 0;\n\tpaf->random_access_indicator = (data[0] & 0x40) ? 1 : 0;\n\tpaf->priority_indicator = (data[0] & 0x20) ? 1 : 0;\n\tpaf->PCR_flag = (data[0] & 0x10) ? 1 : 0;\n\tpaf->OPCR_flag = (data[0] & 0x8) ? 1 : 0;\n\tpaf->splicing_point_flag = (data[0] & 0x4) ? 1 : 0;\n\tpaf->transport_private_data_flag = (data[0] & 0x2) ? 1 : 0;\n\tpaf->adaptation_field_extension_flag = (data[0] & 0x1) ? 1 : 0;\n\n\taf_extension = data + 1;\n\tif (paf->PCR_flag == 1) {\n\t\tu32 base = ((u32)data[1] << 24) | ((u32)data[2] << 16) | ((u32)data[3] << 8) | (u32)data[4];\n\t\tu64 PCR = (u64) base;\n\t\tpaf->PCR_base = (PCR << 1) | (data[5] >> 7);\n\t\tpaf->PCR_ext = ((data[5] & 1) << 8) | data[6];\n\t\taf_extension += 6;\n\t}\n\n\tif (paf->adaptation_field_extension_flag) {\n\t\tu32 afext_bytes;\n\t\tBool ltw_flag, pwr_flag, seamless_flag, af_desc_not_present;\n\t\tif (paf->OPCR_flag) {\n\t\t\taf_extension += 6;\n\t\t}\n\t\tif (paf->splicing_point_flag) {\n\t\t\taf_extension += 1;\n\t\t}\n\t\tif (paf->transport_private_data_flag) {\n\t\t\tu32 priv_bytes = af_extension[0];\n\t\t\taf_extension += 1 + priv_bytes;\n\t\t}\n\n\t\tafext_bytes = af_extension[0];\n\t\tltw_flag = af_extension[1] & 0x80 ? 1 : 0;\n\t\tpwr_flag = af_extension[1] & 0x40 ? 1 : 0;\n\t\tseamless_flag = af_extension[1] & 0x20 ? 1 : 0;\n\t\taf_desc_not_present = af_extension[1] & 0x10 ? 1 : 0;\n\t\taf_extension += 2;\n\t\tif (!afext_bytes) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\treturn;\n\t\t}\n\t\tafext_bytes-=1;\n\t\tif (ltw_flag) {\n\t\t\taf_extension += 2;\n\t\t\tif (afext_bytes<2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=2;\n\t\t}\n\t\tif (pwr_flag) {\n\t\t\taf_extension += 3;\n\t\t\tif (afext_bytes<3) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=3;\n\t\t}\n\t\tif (seamless_flag) {\n\t\t\taf_extension += 3;\n\t\t\tif (afext_bytes<3) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=3;\n\t\t}\n\n\t\tif (! af_desc_not_present) {\n\t\t\twhile (afext_bytes) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tchar *desc;\n\t\t\t\tu8 desc_tag = af_extension[0];\n\t\t\t\tu8 desc_len = af_extension[1];\n\t\t\t\tif (!desc_len || (u32) desc_len+2 > afext_bytes) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Descriptor found (tag %d) size is %d but only %d bytes available\\n\", pid, desc_tag, desc_len, afext_bytes));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = (char *) af_extension+2;\n\n\t\t\t\tbs = gf_bs_new(desc, desc_len, GF_BITSTREAM_READ);\n\t\t\t\tswitch (desc_tag) {\n\t\t\t\tcase GF_M2TS_AFDESC_LOCATION_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tBool use_base_temi_url;\n\t\t\t\t\tchar URL[255];\n\t\t\t\t\tGF_M2TS_TemiLocationDescriptor temi_loc;\n\t\t\t\t\tmemset(&temi_loc, 0, sizeof(GF_M2TS_TemiLocationDescriptor) );\n\t\t\t\t\ttemi_loc.reload_external = gf_bs_read_int(bs, 1);\n\t\t\t\t\ttemi_loc.is_announce = gf_bs_read_int(bs, 1);\n\t\t\t\t\ttemi_loc.is_splicing = gf_bs_read_int(bs, 1);\n\t\t\t\t\tuse_base_temi_url = gf_bs_read_int(bs, 1);\n\t\t\t\t\tgf_bs_read_int(bs, 5); //reserved\n\t\t\t\t\ttemi_loc.timeline_id = gf_bs_read_int(bs, 7);\n\t\t\t\t\tif (!use_base_temi_url) {\n\t\t\t\t\t\tchar *_url = URL;\n\t\t\t\t\t\tu8 scheme = gf_bs_read_int(bs, 8);\n\t\t\t\t\t\tu8 url_len = gf_bs_read_int(bs, 8);\n\t\t\t\t\t\tswitch (scheme) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tstrcpy(URL, \"http://\");\n\t\t\t\t\t\t\t_url = URL+7;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tstrcpy(URL, \"https://\");\n\t\t\t\t\t\t\t_url = URL+8;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_bs_read_data(bs, _url, url_len);\n\t\t\t\t\t\t_url[url_len] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttemi_loc.external_URL = URL;\n\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d AF Location descriptor found - URL %s\\n\", pid, URL));\n\t\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TEMI_LOCATION, &temi_loc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_AFDESC_TIMELINE_DESCRIPTOR:\n\t\t\t\t\tif (ts->ess[pid] && (ts->ess[pid]->flags & GF_M2TS_ES_IS_PES)) {\n\t\t\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *) ts->ess[pid];\n\n\t\t\t\t\t\tif (pes->temi_tc_desc_len)\n\t\t\t\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\n\t\t\t\t\t\tif (pes->temi_tc_desc_alloc_size < desc_len) {\n\t\t\t\t\t\t\tpes->temi_tc_desc = gf_realloc(pes->temi_tc_desc, desc_len);\n\t\t\t\t\t\t\tpes->temi_tc_desc_alloc_size = desc_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(pes->temi_tc_desc, desc, desc_len);\n\t\t\t\t\t\tpes->temi_tc_desc_len = desc_len;\n\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d AF Timeline descriptor found\\n\", pid));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\taf_extension += 2+desc_len;\n\t\t\t\tafext_bytes -= 2+desc_len;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Adaptation Field found: Discontinuity %d - RAP %d - PCR: \"LLD\"\\n\", pid, paf->discontinuity_indicator, paf->random_access_indicator, paf->PCR_flag ? paf->PCR_base * 300 + paf->PCR_ext : 0));\n}\n\nstatic GF_Err gf_m2ts_process_packet(GF_M2TS_Demuxer *ts, unsigned char *data)\n{\n\tGF_M2TS_ES *es;\n\tGF_M2TS_Header hdr;\n\tGF_M2TS_AdaptationField af, *paf;\n\tu32 payload_size, af_size;\n\tu32 pos = 0;\n\n\tts->pck_number++;\n\n\t/* read TS packet header*/\n\thdr.sync = data[0];\n\tif (hdr.sync != 0x47) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d does not start with sync marker\\n\", ts->pck_number));\n\t\treturn GF_CORRUPTED_DATA;\n\t}\n\thdr.error = (data[1] & 0x80) ? 1 : 0;\n\thdr.payload_start = (data[1] & 0x40) ? 1 : 0;\n\thdr.priority = (data[1] & 0x20) ? 1 : 0;\n\thdr.pid = ( (data[1]&0x1f) << 8) | data[2];\n\thdr.scrambling_ctrl = (data[3] >> 6) & 0x3;\n\thdr.adaptation_field = (data[3] >> 4) & 0x3;\n\thdr.continuity_counter = data[3] & 0xf;\n\n\tif (hdr.error) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d has error (PID could be %d)\\n\", ts->pck_number, hdr.pid));\n\t\treturn GF_CORRUPTED_DATA;\n\t}\n//#if DEBUG_TS_PACKET\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d PID %d CC %d Encrypted %d\\n\", ts->pck_number, hdr.pid, hdr.continuity_counter, hdr.scrambling_ctrl));\n//#endif\n\n\tif (hdr.scrambling_ctrl) {\n\t\t//TODO add decyphering\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d is scrambled - not supported\\n\", ts->pck_number, hdr.pid));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tpaf = NULL;\n\tpayload_size = 184;\n\tpos = 4;\n\tswitch (hdr.adaptation_field) {\n\t/*adaptation+data*/\n\tcase 3:\n\t\taf_size = data[4];\n\t\tif (af_size>183) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d AF field larger than 183 !\\n\", ts->pck_number));\n\t\t\t//error\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tpaf = &af;\n\t\tmemset(paf, 0, sizeof(GF_M2TS_AdaptationField));\n\t\t//this will stop you when processing invalid (yet existing) mpeg2ts streams in debug\n\t\tassert( af_size<=183);\n\t\tif (af_size>183)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d Detected wrong adaption field size %u when control value is 3\\n\", ts->pck_number, af_size));\n\t\tif (af_size) gf_m2ts_get_adaptation_field(ts, paf, data+5, af_size, hdr.pid);\n\t\tpos += 1+af_size;\n\t\tpayload_size = 183 - af_size;\n\t\tbreak;\n\t/*adaptation only - still process in case of PCR*/\n\tcase 2:\n\t\taf_size = data[4];\n\t\tif (af_size != 183) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d AF size is %d when it must be 183 for AF type 2\\n\", ts->pck_number, af_size));\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tpaf = &af;\n\t\tmemset(paf, 0, sizeof(GF_M2TS_AdaptationField));\n\t\tgf_m2ts_get_adaptation_field(ts, paf, data+5, af_size, hdr.pid);\n\t\tpayload_size = 0;\n\t\t/*no payload and no PCR, return*/\n\t\tif (!paf->PCR_flag)\n\t\t\treturn GF_OK;\n\t\tbreak;\n\t/*reserved*/\n\tcase 0:\n\t\treturn GF_OK;\n\tdefault:\n\t\tbreak;\n\t}\n\tdata += pos;\n\n\t/*PAT*/\n\tif (hdr.pid == GF_M2TS_PID_PAT) {\n\t\tgf_m2ts_gather_section(ts, ts->pat, NULL, &hdr, data, payload_size);\n\t\treturn GF_OK;\n\t} else if (hdr.pid == GF_M2TS_PID_CAT) {\n\t\tgf_m2ts_gather_section(ts, ts->cat, NULL, &hdr, data, payload_size);\n\t\treturn GF_OK;\n\t}\n\n\tes = ts->ess[hdr.pid];\n\tif (paf && paf->PCR_flag) {\n\t\tif (!es) {\n\t\t\tu32 i, j;\n\t\t\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\t\t\tGF_M2TS_PES *first_pes = NULL;\n\t\t\t\tGF_M2TS_Program *program = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\t\t\tif(program->pcr_pid != hdr.pid) continue;\n\t\t\t\tfor (j=0; j<gf_list_count(program->streams); j++) {\n\t\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *) gf_list_get(program->streams, j);\n\t\t\t\t\tif (pes->flags & GF_M2TS_INHERIT_PCR) {\n\t\t\t\t\t\tts->ess[hdr.pid] = (GF_M2TS_ES *) pes;\n\t\t\t\t\t\tpes->flags |= GF_M2TS_FAKE_PCR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (pes->flags & GF_M2TS_ES_IS_PES) {\n\t\t\t\t\t\tfirst_pes = pes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//non found, use the first media stream as a PCR destination - Q: is it legal to have PCR only streams not declared in PMT ?\n\t\t\t\tif (!es && first_pes) {\n\t\t\t\t\tes = (GF_M2TS_ES *) first_pes;\n\t\t\t\t\tfirst_pes->flags |= GF_M2TS_FAKE_PCR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!es)\n\t\t\t\tes = ts->ess[hdr.pid];\n\t\t}\n\t\tif (es) {\n\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\ts64 prev_diff_in_us;\n\t\t\tBool discontinuity;\n\t\t\ts32 cc = -1;\n\n\t\t\tif (es->flags & GF_M2TS_FAKE_PCR) {\n\t\t\t\tcc = es->program->pcr_cc;\n\t\t\t\tes->program->pcr_cc = hdr.continuity_counter;\n\t\t\t}\n\t\t\telse if (es->flags & GF_M2TS_ES_IS_PES) cc = ((GF_M2TS_PES*)es)->cc;\n\t\t\telse if (((GF_M2TS_SECTION_ES*)es)->sec) cc = ((GF_M2TS_SECTION_ES*)es)->sec->cc;\n\n\t\t\tdiscontinuity = paf->discontinuity_indicator;\n\t\t\tif ((cc>=0) && es->program->before_last_pcr_value) {\n\t\t\t\t//no increment of CC if AF only packet\n\t\t\t\tif (hdr.adaptation_field == 2) {\n\t\t\t\t\tif (hdr.continuity_counter != cc) {\n\t\t\t\t\t\tdiscontinuity = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (hdr.continuity_counter != ((cc + 1) & 0xF)) {\n\t\t\t\t\tdiscontinuity = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\tprev_diff_in_us = (s64) (es->program->last_pcr_value /27- es->program->before_last_pcr_value/27);\n\t\t\tes->program->before_last_pcr_value = es->program->last_pcr_value;\n\t\t\tes->program->before_last_pcr_value_pck_number = es->program->last_pcr_value_pck_number;\n\t\t\tes->program->last_pcr_value_pck_number = ts->pck_number;\n\t\t\tes->program->last_pcr_value = paf->PCR_base * 300 + paf->PCR_ext;\n\t\t\tif (!es->program->last_pcr_value) es->program->last_pcr_value =  1;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR found \"LLU\" (\"LLU\" at 90kHz) - PCR diff is %d us\\n\", hdr.pid, es->program->last_pcr_value, es->program->last_pcr_value/300, (s32) (es->program->last_pcr_value - es->program->before_last_pcr_value)/27 ));\n\n\t\t\tpck.PTS = es->program->last_pcr_value;\n\t\t\tpck.stream = (GF_M2TS_PES *)es;\n\n\t\t\t//try to ignore all discontinuities that are less than 200 ms (seen in some HLS setup ...)\n\t\t\tif (discontinuity) {\n\t\t\t\ts64 diff_in_us = (s64) (es->program->last_pcr_value - es->program->before_last_pcr_value) / 27;\n\t\t\t\tu64 diff = ABS(diff_in_us - prev_diff_in_us);\n\n\t\t\t\tif ((diff_in_us<0) && (diff_in_us >= -200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d new PCR, with discontinuity signaled, is less than previously received PCR (diff %d us) but not too large, trying to ignore discontinuity\\n\", hdr.pid, diff_in_us));\n\t\t\t\t}\n\n\t\t\t\t//ignore PCR discontinuity indicator if PCR found is larger than previously received PCR and diffence between PCR before and after discontinuity indicator is smaller than 50ms\n\t\t\t\telse if ((diff_in_us > 0) && (diff < 200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity signaled but diff is small (diff %d us - PCR diff %d vs prev PCR diff %d) - ignore it\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t} else if (paf->discontinuity_indicator) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity signaled (diff %d us - PCR diff %d vs prev PCR diff %d)\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity not signaled (diff %d us - PCR diff %d vs prev PCR diff %d)\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( (es->program->last_pcr_value < es->program->before_last_pcr_value) ) {\n\t\t\t\ts64 diff_in_us = (s64) (es->program->last_pcr_value - es->program->before_last_pcr_value) / 27;\n\t\t\t\t//if less than 200 ms before PCR loop at the last PCR, this is a PCR loop\n\t\t\t\tif (GF_M2TS_MAX_PCR - es->program->before_last_pcr_value < 5400000 /*2*2700000*/) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR loop found from \"LLU\" to \"LLU\" \\n\", hdr.pid, es->program->before_last_pcr_value, es->program->last_pcr_value));\n\t\t\t\t} else if ((diff_in_us<0) && (diff_in_us >= -200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d new PCR, without discontinuity signaled, is less than previously received PCR (diff %d us) but not too large, trying to ignore discontinuity\\n\", hdr.pid, diff_in_us));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR found \"LLU\" is less than previously received PCR \"LLU\" (PCR diff %g sec) but no discontinuity signaled\\n\", hdr.pid, es->program->last_pcr_value, es->program->before_last_pcr_value, (GF_M2TS_MAX_PCR - es->program->before_last_pcr_value + es->program->last_pcr_value) / 27000000.0));\n\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pck.flags & GF_M2TS_PES_PCK_DISCONTINUITY) {\n\t\t\t\tgf_m2ts_reset_parsers_for_program(ts, es->program);\n\t\t\t}\n\n\t\t\tif (ts->on_event) {\n\t\t\t\tts->on_event(ts, GF_M2TS_EVT_PES_PCR, &pck);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*check for DVB reserved PIDs*/\n\tif (!es) {\n\t\tif (hdr.pid == GF_M2TS_PID_SDT_BAT_ST) {\n\t\t\tgf_m2ts_gather_section(ts, ts->sdt, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_NIT_ST) {\n\t\t\t/*ignore them, unused at application level*/\n\t\t\tgf_m2ts_gather_section(ts, ts->nit, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_EIT_ST_CIT) {\n\t\t\t/* ignore EIT messages for the moment */\n\t\t\tgf_m2ts_gather_section(ts, ts->eit, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_TDT_TOT_ST) {\n\t\t\tgf_m2ts_gather_section(ts, ts->tdt_tot, NULL, &hdr, data, payload_size);\n\t\t} else {\n\t\t\t/* ignore packet */\n\t\t}\n\t} else if (es->flags & GF_M2TS_ES_IS_SECTION) { \t/* The stream uses sections to carry its payload */\n\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\tif (ses->sec) gf_m2ts_gather_section(ts, ses->sec, ses, &hdr, data, payload_size);\n\t} else {\n\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t/* regular stream using PES packets */\n\t\tif (pes->reframe && payload_size) gf_m2ts_process_pes(ts, pes, &hdr, data, payload_size, paf);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m2ts_process_data(GF_M2TS_Demuxer *ts, u8 *data, u32 data_size)\n{\n\tGF_Err e=GF_OK;\n\tu32 pos, pck_size;\n\tBool is_align = 1;\n\n\tif (ts->buffer_size) {\n\t\t//we are sync, copy remaining bytes\n\t\tif ( (ts->buffer[0]==0x47) && (ts->buffer_size<200)) {\n\t\t\tu32 pck_size = ts->prefix_present ? 192 : 188;\n\n\t\t\tif (ts->alloc_size < 200) {\n\t\t\t\tts->alloc_size = 200;\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ts->buffer + ts->buffer_size, data, pck_size - ts->buffer_size);\n\t\t\te |= gf_m2ts_process_packet(ts, (unsigned char *)ts->buffer);\n\t\t\tdata += (pck_size - ts->buffer_size);\n\t\t\tdata_size = data_size - (pck_size - ts->buffer_size);\n\t\t}\n\t\t//not sync, copy over the complete buffer\n\t\telse {\n\t\t\tif (ts->alloc_size < ts->buffer_size+data_size) {\n\t\t\t\tts->alloc_size = ts->buffer_size+data_size;\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ts->buffer + ts->buffer_size, data, sizeof(char)*data_size);\n\t\t\tts->buffer_size += data_size;\n\t\t\tis_align = 0;\n\t\t\tdata = ts->buffer;\n\t\t\tdata_size = ts->buffer_size;\n\t\t}\n\t}\n\n\t/*sync input data*/\n\tpos = gf_m2ts_sync(ts, data, data_size, is_align);\n\tif (pos==data_size) {\n\t\tif (is_align) {\n\t\t\tif (ts->alloc_size<data_size) {\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*data_size);\n\t\t\t\tts->alloc_size = data_size;\n\t\t\t}\n\t\t\tmemcpy(ts->buffer, data, sizeof(char)*data_size);\n\t\t\tts->buffer_size = data_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tpck_size = ts->prefix_present ? 192 : 188;\n\tfor (;;) {\n\t\t/*wait for a complete packet*/\n\t\tif (data_size < pos  + pck_size) {\n\t\t\tts->buffer_size = data_size - pos;\n\t\t\tdata += pos;\n\t\t\tif (!ts->buffer_size) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tassert(ts->buffer_size<pck_size);\n\n\t\t\tif (is_align) {\n\t\t\t\tu32 s = ts->buffer_size;\n\t\t\t\tif (s<200) s = 200;\n\n\t\t\t\tif (ts->alloc_size < s) {\n\t\t\t\t\tts->alloc_size = s;\n\t\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t\t}\n\t\t\t\tmemcpy(ts->buffer, data, sizeof(char)*ts->buffer_size);\n\t\t\t} else {\n\t\t\t\tmemmove(ts->buffer, data, sizeof(char)*ts->buffer_size);\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\t/*process*/\n\t\te |= gf_m2ts_process_packet(ts, (unsigned char *)data + pos);\n\t\tpos += pck_size;\n\t}\n\treturn e;\n}\n\n//unused\n#if 0\nGF_ESD *gf_m2ts_get_esd(GF_M2TS_ES *es)\n{\n\tGF_ESD *esd;\n\tu32 k, esd_count;\n\n\tesd = NULL;\n\tif (es->program->pmt_iod && es->program->pmt_iod->ESDescriptors) {\n\t\tesd_count = gf_list_count(es->program->pmt_iod->ESDescriptors);\n\t\tfor (k = 0; k < esd_count; k++) {\n\t\t\tGF_ESD *esd_tmp = (GF_ESD *)gf_list_get(es->program->pmt_iod->ESDescriptors, k);\n\t\t\tif (esd_tmp->ESID != es->mpeg4_es_id) continue;\n\t\t\tesd = esd_tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!esd && es->program->additional_ods) {\n\t\tu32 od_count, od_index;\n\t\tod_count = gf_list_count(es->program->additional_ods);\n\t\tfor (od_index = 0; od_index < od_count; od_index++) {\n\t\t\tGF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(es->program->additional_ods, od_index);\n\t\t\tesd_count = gf_list_count(od->ESDescriptors);\n\t\t\tfor (k = 0; k < esd_count; k++) {\n\t\t\t\tGF_ESD *esd_tmp = (GF_ESD *)gf_list_get(od->ESDescriptors, k);\n\t\t\t\tif (esd_tmp->ESID != es->mpeg4_es_id) continue;\n\t\t\t\tesd = esd_tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn esd;\n}\nvoid gf_m2ts_set_segment_switch(GF_M2TS_Demuxer *ts)\n{\n\tu32 i;\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *) ts->ess[i];\n\t\tif (!es) continue;\n\t\tes->flags |= GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY;\n\t}\n}\n\n\n#endif\n\n\nGF_EXPORT\nvoid gf_m2ts_reset_parsers_for_program(GF_M2TS_Demuxer *ts, GF_M2TS_Program *prog)\n{\n\tu32 i;\n\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *) ts->ess[i];\n\t\tif (!es) continue;\n\t\tif (prog && (es->program != prog) ) continue;\n\n\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\t\tgf_m2ts_section_filter_reset(ses->sec);\n\t\t} else {\n\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t\tif (!pes || (pes->pid==pes->program->pmt_pid)) continue;\n\t\t\tpes->cc = -1;\n\t\t\tpes->frame_state = 0;\n\t\t\tpes->pck_data_len = 0;\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tpes->PTS = pes->DTS = 0;\n//\t\t\tpes->prev_PTS = 0;\n//\t\t\tpes->first_dts = 0;\n\t\t\tpes->pes_len = pes->pes_end_packet_number = pes->pes_start_packet_number = 0;\n\t\t\tif (pes->buf) gf_free(pes->buf);\n\t\t\tpes->buf = NULL;\n\t\t\tif (pes->temi_tc_desc) gf_free(pes->temi_tc_desc);\n\t\t\tpes->temi_tc_desc = NULL;\n\t\t\tpes->temi_tc_desc_len = pes->temi_tc_desc_alloc_size = 0;\n\n\t\t\tpes->before_last_pcr_value = pes->before_last_pcr_value_pck_number = 0;\n\t\t\tpes->last_pcr_value = pes->last_pcr_value_pck_number = 0;\n\t\t\tif (pes->program->pcr_pid==pes->pid) {\n\t\t\t\tpes->program->last_pcr_value = pes->program->last_pcr_value_pck_number = 0;\n\t\t\t\tpes->program->before_last_pcr_value = pes->program->before_last_pcr_value_pck_number = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_m2ts_reset_parsers(GF_M2TS_Demuxer *ts)\n{\n\tgf_m2ts_reset_parsers_for_program(ts, NULL);\n\n\tts->pck_number = 0;\n\n\tgf_m2ts_section_filter_reset(ts->cat);\n\tgf_m2ts_section_filter_reset(ts->pat);\n\tgf_m2ts_section_filter_reset(ts->sdt);\n\tgf_m2ts_section_filter_reset(ts->nit);\n\tgf_m2ts_section_filter_reset(ts->eit);\n\tgf_m2ts_section_filter_reset(ts->tdt_tot);\n\n}\n\n\n#if 0 //unused\nu32 gf_m2ts_pes_get_framing_mode(GF_M2TS_PES *pes)\n{\n\tif (pes->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tif (pes->flags & GF_M2TS_ES_IS_SL) {\n\t\t\tif ( ((GF_M2TS_SECTION_ES *)pes)->sec->process_section == NULL)\n\t\t\t\treturn GF_M2TS_PES_FRAMING_DEFAULT;\n\n\t\t}\n\t\treturn GF_M2TS_PES_FRAMING_SKIP_NO_RESET;\n\t}\n\n\tif (!pes->reframe ) return GF_M2TS_PES_FRAMING_SKIP_NO_RESET;\n\tif (pes->reframe == gf_m2ts_reframe_default) return GF_M2TS_PES_FRAMING_RAW;\n\tif (pes->reframe == gf_m2ts_reframe_reset) return GF_M2TS_PES_FRAMING_SKIP;\n\treturn GF_M2TS_PES_FRAMING_DEFAULT;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_m2ts_set_pes_framing(GF_M2TS_PES *pes, u32 mode)\n{\n\tif (!pes) return GF_BAD_PARAM;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Setting pes framing mode of PID %d to %d\\n\", pes->pid, mode) );\n\t/*ignore request for section PIDs*/\n\tif (pes->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tif (pes->flags & GF_M2TS_ES_IS_SL) {\n\t\t\tif (mode==GF_M2TS_PES_FRAMING_DEFAULT) {\n\t\t\t\t((GF_M2TS_SECTION_ES *)pes)->sec->process_section = gf_m2ts_process_mpeg4section;\n\t\t\t} else {\n\t\t\t\t((GF_M2TS_SECTION_ES *)pes)->sec->process_section = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (pes->pid==pes->program->pmt_pid) return GF_BAD_PARAM;\n\n\t//if component reuse, disable previous pes\n\tif ((mode > GF_M2TS_PES_FRAMING_SKIP) && (pes->program->ts->ess[pes->pid] != (GF_M2TS_ES *) pes)) {\n\t\tGF_M2TS_PES *o_pes = (GF_M2TS_PES *) pes->program->ts->ess[pes->pid];\n\t\tif (o_pes->flags & GF_M2TS_ES_IS_PES)\n\t\t\tgf_m2ts_set_pes_framing(o_pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Reassinging PID %d from program %d to program %d\\n\", pes->pid, o_pes->program->number, pes->program->number) );\n\t\tpes->program->ts->ess[pes->pid] = (GF_M2TS_ES *) pes;\n\t}\n\n\tswitch (mode) {\n\tcase GF_M2TS_PES_FRAMING_RAW:\n\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_SKIP:\n\t\tpes->reframe = gf_m2ts_reframe_reset;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_SKIP_NO_RESET:\n\t\tpes->reframe = NULL;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_DEFAULT:\n\tdefault:\n\t\tswitch (pes->stream_type) {\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_EC3:\n\t\t\t//for all our supported codec types, use a reframer filter\n\t\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\t/* TODO: handle DVB subtitle streams */\n\t\t\tbreak;\n\t\tcase GF_M2TS_METADATA_ID3_HLS:\n\t\t\t//TODO\n\t\t\tpes->reframe = gf_m2ts_reframe_id3_pes;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_M2TS_Demuxer *gf_m2ts_demux_new()\n{\n\tGF_M2TS_Demuxer *ts;\n\n\tGF_SAFEALLOC(ts, GF_M2TS_Demuxer);\n\tif (!ts) return NULL;\n\tts->programs = gf_list_new();\n\tts->SDTs = gf_list_new();\n\n\tts->pat = gf_m2ts_section_filter_new(gf_m2ts_process_pat, 0);\n\tts->cat = gf_m2ts_section_filter_new(gf_m2ts_process_cat, 0);\n\tts->sdt = gf_m2ts_section_filter_new(gf_m2ts_process_sdt, 1);\n\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\tts->eit = gf_m2ts_section_filter_new(NULL/*gf_m2ts_process_eit*/, 1);\n\tts->tdt_tot = gf_m2ts_section_filter_new(gf_m2ts_process_tdt_tot, 1);\n\n#ifdef GPAC_ENABLE_MPE\n\tgf_dvb_mpe_init(ts);\n#endif\n\n\tts->nb_prog_pmt_received = 0;\n\tts->ChannelAppList = gf_list_new();\n\treturn ts;\n}\n\nGF_EXPORT\nvoid gf_m2ts_demux_dmscc_init(GF_M2TS_Demuxer *ts) {\n\n\tchar temp_dir[GF_MAX_PATH];\n\tu32 length;\n\tGF_Err e;\n\n\tts->dsmcc_controler = gf_list_new();\n\tts->process_dmscc = 1;\n\n\tstrcpy(temp_dir, gf_get_default_cache_directory() );\n\tlength = (u32) strlen(temp_dir);\n\tif(temp_dir[length-1] == GF_PATH_SEPARATOR) {\n\t\ttemp_dir[length-1] = 0;\n\t}\n\n\tts->dsmcc_root_dir = (char*)gf_calloc(strlen(temp_dir)+strlen(\"CarouselData\")+2,sizeof(char));\n\tsprintf(ts->dsmcc_root_dir,\"%s%cCarouselData\",temp_dir,GF_PATH_SEPARATOR);\n\te = gf_mkdir(ts->dsmcc_root_dir);\n\tif(e) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[Process DSMCC] Error during the creation of the directory %s \\n\",ts->dsmcc_root_dir));\n\t}\n\n}\n\nGF_EXPORT\nvoid gf_m2ts_demux_del(GF_M2TS_Demuxer *ts)\n{\n\tu32 i;\n\tif (ts->pat) gf_m2ts_section_filter_del(ts->pat);\n\tif (ts->cat) gf_m2ts_section_filter_del(ts->cat);\n\tif (ts->sdt) gf_m2ts_section_filter_del(ts->sdt);\n\tif (ts->nit) gf_m2ts_section_filter_del(ts->nit);\n\tif (ts->eit) gf_m2ts_section_filter_del(ts->eit);\n\tif (ts->tdt_tot) gf_m2ts_section_filter_del(ts->tdt_tot);\n\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\t//bacause of pure PCR streams, en ES might be reassigned on 2 PIDs, one for the ES and one for the PCR\n\t\tif (ts->ess[i] && (ts->ess[i]->pid==i)) gf_m2ts_es_del(ts->ess[i], ts);\n\t}\n\tif (ts->buffer) gf_free(ts->buffer);\n\twhile (gf_list_count(ts->programs)) {\n\t\tGF_M2TS_Program *p = (GF_M2TS_Program *)gf_list_last(ts->programs);\n\t\tgf_list_rem_last(ts->programs);\n\t\tgf_list_del(p->streams);\n\t\t/*reset OD list*/\n\t\tif (p->additional_ods) {\n\t\t\tgf_odf_desc_list_del(p->additional_ods);\n\t\t\tgf_list_del(p->additional_ods);\n\t\t}\n\t\tif (p->pmt_iod) gf_odf_desc_del((GF_Descriptor *)p->pmt_iod);\n\t\tif (p->metadata_pointer_descriptor)\tgf_m2ts_metadata_pointer_descriptor_del(p->metadata_pointer_descriptor);\n\t\tgf_free(p);\n\t}\n\tgf_list_del(ts->programs);\n\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tgf_m2ts_reset_sdt(ts);\n\tif (ts->tdt_tot)\n\t\tgf_list_del(ts->SDTs);\n\n#ifdef GPAC_ENABLE_MPE\n\tgf_dvb_mpe_shutdown(ts);\n#endif\n\n\tif (ts->dsmcc_controler) {\n\t\tif (gf_list_count(ts->dsmcc_controler)) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_DSMCC_OVERLORD* dsmcc_overlord = (GF_M2TS_DSMCC_OVERLORD*)gf_list_get(ts->dsmcc_controler,0);\n\t\t\tgf_cleanup_dir(dsmcc_overlord->root_dir);\n\t\t\tgf_rmdir(dsmcc_overlord->root_dir);\n\t\t\tgf_m2ts_delete_dsmcc_overlord(dsmcc_overlord);\n\t\t\tif(ts->dsmcc_root_dir) {\n\t\t\t\tgf_free(ts->dsmcc_root_dir);\n\t\t\t}\n#endif\n\t\t}\n\t\tgf_list_del(ts->dsmcc_controler);\n\t}\n\n\twhile(gf_list_count(ts->ChannelAppList)) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\tGF_M2TS_CHANNEL_APPLICATION_INFO* ChanAppInfo = (GF_M2TS_CHANNEL_APPLICATION_INFO*)gf_list_get(ts->ChannelAppList,0);\n\t\tgf_m2ts_delete_channel_application_info(ChanAppInfo);\n\t\tgf_list_rem(ts->ChannelAppList,0);\n#endif\n\t}\n\tgf_list_del(ts->ChannelAppList);\n\n\tif (ts->dsmcc_root_dir) gf_free(ts->dsmcc_root_dir);\n\tgf_free(ts);\n}\n\n#if 0//unused\nvoid gf_m2ts_print_info(GF_M2TS_Demuxer *ts)\n{\n#ifdef GPAC_ENABLE_MPE\n\tgf_m2ts_print_mpe_info(ts);\n#endif\n}\n#endif\n\n\n\n#define M2TS_PROBE_SIZE\t188000\nstatic Bool gf_m2ts_probe_buffer(char *buf, u32 size)\n{\n\tGF_Err e;\n\tGF_M2TS_Demuxer *ts;\n\tu32 lt;\n\n\tlt = gf_log_get_tool_level(GF_LOG_CONTAINER);\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, GF_LOG_QUIET);\n\n\tts = gf_m2ts_demux_new();\n\te = gf_m2ts_process_data(ts, buf, size);\n\tif (!ts->pck_number) e = GF_BAD_PARAM;\n\tgf_m2ts_demux_del(ts);\n\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, lt);\n\n\tif (e) return GF_FALSE;\n\treturn GF_TRUE;\n\n}\nGF_EXPORT\nBool gf_m2ts_probe_file(const char *fileName)\n{\n\tchar buf[M2TS_PROBE_SIZE];\n\tu32 size;\n\tFILE *t;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get_data(fileName, &mem_address, &size) != GF_OK) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tif (size>M2TS_PROBE_SIZE) size = M2TS_PROBE_SIZE;\n\t\tmemcpy(buf, mem_address, size);\n\t} else {\n\t\tt = gf_fopen(fileName, \"rb\");\n\t\tif (!t) return 0;\n\t\tsize = (u32) fread(buf, 1, M2TS_PROBE_SIZE, t);\n\t\tgf_fclose(t);\n\t\tif ((s32) size <= 0) return 0;\n\t}\n\treturn gf_m2ts_probe_buffer(buf, size);\n}\n\nGF_EXPORT\nBool gf_m2ts_probe_data(const u8 *data, u32 size)\n{\n\tsize /= 188;\n\tsize *= 188;\n\treturn gf_m2ts_probe_buffer((char *) data, size);\n}\n\n\nstatic void rewrite_pts_dts(unsigned char *ptr, u64 TS)\n{\n\tptr[0] &= 0xf1;\n\tptr[0] |= (unsigned char)((TS&0x1c0000000ULL)>>29);\n\tptr[1]  = (unsigned char)((TS&0x03fc00000ULL)>>22);\n\tptr[2] &= 0x1;\n\tptr[2] |= (unsigned char)((TS&0x0003f8000ULL)>>14);\n\tptr[3]  = (unsigned char)((TS&0x000007f80ULL)>>7);\n\tptr[4] &= 0x1;\n\tptr[4] |= (unsigned char)((TS&0x00000007fULL)<<1);\n\n\tassert(((u64)(ptr[0]&0xe)<<29) + ((u64)ptr[1]<<22) + ((u64)(ptr[2]&0xfe)<<14) + ((u64)ptr[3]<<7) + ((ptr[4]&0xfe)>>1) == TS);\n}\n\n#define ADJUST_TIMESTAMP(_TS) \\\n\tif (_TS < (u64) -ts_shift) _TS = pcr_mod + _TS + ts_shift; \\\n\telse _TS = _TS + ts_shift; \\\n\twhile (_TS > pcr_mod) _TS -= pcr_mod; \\\n\nGF_EXPORT\nGF_Err gf_m2ts_restamp(u8 *buffer, u32 size, s64 ts_shift, u8 *is_pes)\n{\n\tu32 done = 0;\n\tu64 pcr_mod;\n//\tif (!ts_shift) return GF_OK;\n\n\tpcr_mod = 0x80000000;\n\tpcr_mod*=4;\n\twhile (done + 188 <= size) {\n\t\tu8 *pesh;\n\t\tu8 *pck;\n\t\tu64 pcr_base=0, pcr_ext=0;\n\t\tu16 pid;\n\t\tu8 adaptation_field, adaptation_field_length;\n\n\t\tpck = (u8*) buffer+done;\n\t\tif (pck[0]!=0x47) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[M2TS Restamp] Invalid sync byte %X\\n\", pck[0]));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tpid = ((pck[1] & 0x1f) <<8 ) + pck[2];\n\n\t\tadaptation_field_length = 0;\n\t\tadaptation_field = (pck[3] >> 4) & 0x3;\n\t\tif ((adaptation_field==2) || (adaptation_field==3)) {\n\t\t\tadaptation_field_length = pck[4];\n\t\t\tif ( pck[5]&0x10 /*PCR_flag*/) {\n\t\t\t\tpcr_base = (((u64)pck[6])<<25) + (pck[7]<<17) + (pck[8]<<9) + (pck[9]<<1) + (pck[10]>>7);\n\t\t\t\tpcr_ext  = ((pck[10]&1)<<8) + pck[11];\n\n\t\t\t\tADJUST_TIMESTAMP(pcr_base);\n\n\t\t\t\tpck[6]  = (unsigned char)(0xff&(pcr_base>>25));\n\t\t\t\tpck[7]  = (unsigned char)(0xff&(pcr_base>>17));\n\t\t\t\tpck[8]  = (unsigned char)(0xff&(pcr_base>>9));\n\t\t\t\tpck[9]  = (unsigned char)(0xff&(pcr_base>>1));\n\t\t\t\tpck[10] = (unsigned char)(((0x1&pcr_base)<<7) | 0x7e | ((0x100&pcr_ext)>>8));\n\t\t\t\tif (pcr_ext != ((pck[10]&1)<<8) + pck[11]) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[M2TS Restamp] Sanity check failed for PCR restamping\\n\"));\n\t\t\t\t\treturn GF_IO_ERR;\n\t\t\t\t}\n\t\t\t\tpck[11] = (unsigned char)(0xff&pcr_ext);\n\t\t\t}\n\t\t\t/*add adaptation_field_length field*/\n\t\t\tadaptation_field_length++;\n\t\t}\n\t\tif (!is_pes[pid] || !(pck[1]&0x40)) {\n\t\t\tdone+=188;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpesh = &pck[4+adaptation_field_length];\n\n\t\tif ((pesh[0]==0x00) && (pesh[1]==0x00) && (pesh[2]==0x01)) {\n\t\t\tBool has_pts, has_dts;\n\t\t\tif ((pesh[6]&0xc0)!=0x80) {\n\t\t\t\tdone+=188;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thas_pts = (pesh[7]&0x80);\n\t\t\thas_dts = has_pts ? (pesh[7]&0x40) : 0;\n\n\t\t\tif (has_pts) {\n\t\t\t\tu64 PTS;\n\t\t\t\tif (((pesh[9]&0xe0)>>4)!=0x2) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS Restamp] PID %4d: Wrong PES header, PTS decoding: '0010' expected\\n\", pid));\n\t\t\t\t\tdone+=188;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPTS = gf_m2ts_get_pts(pesh + 9);\n\t\t\t\tADJUST_TIMESTAMP(PTS);\n\t\t\t\trewrite_pts_dts(pesh+9, PTS);\n\t\t\t}\n\n\t\t\tif (has_dts) {\n\t\t\t\tu64 DTS = gf_m2ts_get_pts(pesh + 14);\n\t\t\t\tADJUST_TIMESTAMP(DTS);\n\t\t\t\trewrite_pts_dts(pesh+14, DTS);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS Restamp] PID %4d: Wrong PES not beginning with start code\\n\", pid));\n\t\t}\n\t\tdone+=188;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_MPEG2TS*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2012\n *\n *  This file is part of GPAC / MPEG2-TS sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/mpegts.h>\n\n\n#ifndef GPAC_DISABLE_MPEG2TS\n\n#include <string.h>\n#include <gpac/constants.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/download.h>\n\n\n#ifndef GPAC_DISABLE_STREAMING\n#include <gpac/internal/ietf_dev.h>\n#endif\n\n\n#ifdef GPAC_CONFIG_LINUX\n#include <unistd.h>\n#endif\n\n#ifdef GPAC_ENABLE_MPE\n#include <gpac/dvb_mpe.h>\n#endif\n\n#ifdef GPAC_ENABLE_DSMCC\n#include <gpac/ait.h>\n#endif\n\n#define DEBUG_TS_PACKET 0\n\nGF_EXPORT\nconst char *gf_m2ts_get_stream_name(u32 streamType)\n{\n\tswitch (streamType) {\n\tcase GF_M2TS_VIDEO_MPEG1:\n\t\treturn \"MPEG-1 Video\";\n\tcase GF_M2TS_VIDEO_MPEG2:\n\t\treturn \"MPEG-2 Video\";\n\tcase GF_M2TS_AUDIO_MPEG1:\n\t\treturn \"MPEG-1 Audio\";\n\tcase GF_M2TS_AUDIO_MPEG2:\n\t\treturn \"MPEG-2 Audio\";\n\tcase GF_M2TS_PRIVATE_SECTION:\n\t\treturn \"Private Section\";\n\tcase GF_M2TS_PRIVATE_DATA:\n\t\treturn \"Private Data\";\n\tcase GF_M2TS_AUDIO_AAC:\n\t\treturn \"AAC Audio\";\n\tcase GF_M2TS_VIDEO_MPEG4:\n\t\treturn \"MPEG-4 Video\";\n\tcase GF_M2TS_VIDEO_H264:\n\t\treturn \"MPEG-4/H264 Video\";\n\tcase GF_M2TS_VIDEO_SVC:\n\t\treturn \"H264-SVC Video\";\n\tcase GF_M2TS_VIDEO_HEVC:\n\t\treturn \"HEVC Video\";\n\tcase GF_M2TS_VIDEO_SHVC:\n\t\treturn \"SHVC Video\";\n\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\treturn \"SHVC Video Temporal Sublayer\";\n\tcase GF_M2TS_VIDEO_MHVC:\n\t\treturn \"MHVC Video\";\n\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\treturn \"MHVC Video Temporal Sublayer\";\n\n\tcase GF_M2TS_AUDIO_AC3:\n\t\treturn \"Dolby AC3 Audio\";\n\tcase GF_M2TS_AUDIO_DTS:\n\t\treturn \"Dolby DTS Audio\";\n\tcase GF_M2TS_SUBTITLE_DVB:\n\t\treturn \"DVB Subtitle\";\n\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\treturn \"MPEG-4 SL (PES)\";\n\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\treturn \"MPEG-4 SL (Section)\";\n\tcase GF_M2TS_MPE_SECTIONS:\n\t\treturn \"MPE (Section)\";\n\n\tcase GF_M2TS_METADATA_PES:\n\t\treturn \"Metadata (PES)\";\n\tcase GF_M2TS_METADATA_ID3_HLS:\n\t\treturn \"ID3/HLS Metadata (PES)\";\n\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n\nstatic u32 gf_m2ts_reframe_default(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tGF_M2TS_PES_PCK pck;\n\tpck.flags = 0;\n\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\tif (!same_pts) pck.flags |= GF_M2TS_PES_PCK_AU_START;\n\tpck.DTS = pes->DTS;\n\tpck.PTS = pes->PTS;\n\tpck.data = (char *)data;\n\tpck.data_len = data_len;\n\tpck.stream = pes;\n\tts->on_event(ts, GF_M2TS_EVT_PES_PCK, &pck);\n\t/*we consumed all data*/\n\treturn 0;\n}\n\nstatic u32 gf_m2ts_reframe_reset(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tif (pes->pck_data) {\n\t\tgf_free(pes->pck_data);\n\t\tpes->pck_data = NULL;\n\t}\n\tpes->pck_data_len = pes->pck_alloc_len = 0;\n\tif (pes->prev_data) {\n\t\tgf_free(pes->prev_data);\n\t\tpes->prev_data = NULL;\n\t}\n\tpes->prev_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->prev_PTS = 0;\n\tpes->reframe = NULL;\n\tpes->cc = -1;\n\tpes->temi_tc_desc_len = 0;\n\treturn 0;\n}\n\nstatic void add_text(char **buffer, u32 *size, u32 *pos, char *msg, u32 msg_len)\n{\n\tif (!msg || !buffer) return;\n\n\tif (*pos+msg_len>*size) {\n\t\t*size = *pos+msg_len-*size+256;\n\t\t*buffer = (char *)gf_realloc(*buffer, *size);\n\t}\n\tstrncpy((*buffer)+(*pos), msg, msg_len);\n\t*pos += msg_len;\n}\n\nstatic GF_Err id3_parse_tag(char *data, u32 length, char **output, u32 *output_size, u32 *output_pos)\n{\n\tGF_BitStream *bs;\n\tu32 pos;\n\n\tif ((data[0] != 'I') || (data[1] != 'D') || (data[2] != '3'))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tbs = gf_bs_new(data, length, GF_BITSTREAM_READ);\n\n\tgf_bs_skip_bytes(bs, 3);\n\t/*u8 major = */gf_bs_read_u8(bs);\n\t/*u8 minor = */gf_bs_read_u8(bs);\n\t/*u8 unsync = */gf_bs_read_int(bs, 1);\n\t/*u8 ext_hdr = */ gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 6);\n\tu32 size = gf_id3_read_size(bs);\n\n\tpos = (u32) gf_bs_get_position(bs);\n\tif (size != length-pos)\n\t\tsize = length-pos;\n\n\twhile (size && (gf_bs_available(bs)>=10) ) {\n\t\tu32 ftag = gf_bs_read_u32(bs);\n\t\tu32 fsize = gf_id3_read_size(bs);\n\t\t/*u16 fflags = */gf_bs_read_u16(bs);\n\t\tsize -= 10;\n\n\t\t//TODO, handle more ID3 tags ?\n\t\tif (ftag==ID3V2_FRAME_TXXX) {\n\t\t\tu32 pos = (u32) gf_bs_get_position(bs);\n\t\t\tchar *text = data+pos;\n\t\t\tadd_text(output, output_size, output_pos, text, fsize);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] ID3 tag not handled, patch welcome\\n\", gf_4cc_to_str(ftag) ) );\n\t\t}\n\t\tgf_bs_skip_bytes(bs, fsize);\n\t}\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nstatic u32 gf_m2ts_reframe_id3_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, Bool same_pts, unsigned char *data, u32 data_len, GF_M2TS_PESHeader *pes_hdr)\n{\n\tchar frame_header[256];\n\tchar *output_text = NULL;\n\tu32 output_len = 0;\n\tu32 pos = 0;\n\tGF_M2TS_PES_PCK pck;\n\tpck.flags = 0;\n\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\tif (!same_pts) pck.flags |= GF_M2TS_PES_PCK_AU_START;\n\tpck.DTS = pes->DTS;\n\tpck.PTS = pes->PTS;\n\tsprintf(frame_header, LLU\" --> NEXT\\n\", pes->PTS);\n\tadd_text(&output_text, &output_len, &pos, frame_header, (u32)strlen(frame_header));\n\tid3_parse_tag((char *)data, data_len, &output_text, &output_len, &pos);\n\tadd_text(&output_text, &output_len, &pos, \"\\n\\n\", 2);\n\tpck.data = (char *)output_text;\n\tpck.data_len = pos;\n\tpck.stream = pes;\n\tts->on_event(ts, GF_M2TS_EVT_PES_PCK, &pck);\n\tgf_free(output_text);\n\t/*we consumed all data*/\n\treturn 0;\n}\n\nstatic u32 gf_m2ts_sync(GF_M2TS_Demuxer *ts, char *data, u32 size, Bool simple_check)\n{\n\tu32 i=0;\n\t/*if first byte is sync assume we're sync*/\n\tif (simple_check && (data[i]==0x47)) return 0;\n\n\twhile (i < size) {\n\t\tif (i+192 >= size) return size;\n\t\tif ((data[i]==0x47) && (data[i+188]==0x47))\n\t\t\tbreak;\n\t\tif (i+192 >= size) return size;\n\t\tif ((data[i]==0x47) && (data[i+192]==0x47)) {\n\t\t\tts->prefix_present = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] re-sync skipped %d bytes\\n\", i) );\n\t}\n\treturn i;\n}\n\nGF_EXPORT\nBool gf_m2ts_crc32_check(u8 *data, u32 len)\n{\n\tu32 crc = gf_crc_32(data, len);\n\tu32 crc_val = GF_4CC((u8) data[len], (u8) data[len+1], (u8) data[len+2], (u8) data[len+3]);\n\treturn (crc==crc_val) ? GF_TRUE : GF_FALSE;\n}\n\n\nstatic GF_M2TS_SectionFilter *gf_m2ts_section_filter_new(gf_m2ts_section_callback process_section_callback, Bool process_individual)\n{\n\tGF_M2TS_SectionFilter *sec;\n\tGF_SAFEALLOC(sec, GF_M2TS_SectionFilter);\n\tif (!sec) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] gf_m2ts_section_filter_new : OUT OF MEMORY\\n\"));\n\t\treturn NULL;\n\t}\n\tsec->cc = -1;\n\tsec->process_section = process_section_callback;\n\tsec->process_individual = process_individual;\n\treturn sec;\n}\n\nstatic void gf_m2ts_reset_sections(GF_List *sections)\n{\n\tu32 count;\n\tGF_M2TS_Section *section;\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Deleting sections\\n\"));\n\n\tcount = gf_list_count(sections);\n\twhile (count) {\n\t\tsection = gf_list_get(sections, 0);\n\t\tgf_list_rem(sections, 0);\n\t\tif (section->data) gf_free(section->data);\n\t\tgf_free(section);\n\t\tcount--;\n\t}\n}\n\nstatic void gf_m2ts_section_filter_reset(GF_M2TS_SectionFilter *sf)\n{\n\tif (sf->section) {\n\t\tgf_free(sf->section);\n\t\tsf->section = NULL;\n\t}\n\twhile (sf->table) {\n\t\tGF_M2TS_Table *t = sf->table;\n\t\tsf->table = t->next;\n\t\tgf_m2ts_reset_sections(t->sections);\n\t\tgf_list_del(t->sections);\n\t\tgf_free(t);\n\t}\n\tsf->cc = -1;\n\tsf->length = sf->received = 0;\n\tsf->demux_restarted = 1;\n\n}\nstatic void gf_m2ts_section_filter_del(GF_M2TS_SectionFilter *sf)\n{\n\tgf_m2ts_section_filter_reset(sf);\n\tgf_free(sf);\n}\n\n\nstatic void gf_m2ts_metadata_descriptor_del(GF_M2TS_MetadataDescriptor *metad)\n{\n\tif (metad) {\n\t\tif (metad->service_id_record) gf_free(metad->service_id_record);\n\t\tif (metad->decoder_config) gf_free(metad->decoder_config);\n\t\tif (metad->decoder_config_id) gf_free(metad->decoder_config_id);\n\t\tgf_free(metad);\n\t}\n}\n\nGF_EXPORT\nvoid gf_m2ts_es_del(GF_M2TS_ES *es, GF_M2TS_Demuxer *ts)\n{\n\tgf_list_del_item(es->program->streams, es);\n\n\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\tif (ses->sec) gf_m2ts_section_filter_del(ses->sec);\n\n#ifdef GPAC_ENABLE_MPE\n\t\tif (es->flags & GF_M2TS_ES_IS_MPE)\n\t\t\tgf_dvb_mpe_section_del(es);\n#endif\n\n\t} else if (es->pid!=es->program->pmt_pid) {\n\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\n\t\tif ((pes->flags & GF_M2TS_INHERIT_PCR) && ts->ess[es->program->pcr_pid]==es)\n\t\t\tts->ess[es->program->pcr_pid] = NULL;\n\n\t\tif (pes->pck_data) gf_free(pes->pck_data);\n\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\tif (pes->buf) gf_free(pes->buf);\n\t\tif (pes->reassemble_buf) gf_free(pes->reassemble_buf);\n\t\tif (pes->temi_tc_desc) gf_free(pes->temi_tc_desc);\n\n\t\tif (pes->metadata_descriptor) gf_m2ts_metadata_descriptor_del(pes->metadata_descriptor);\n\n\t}\n\tif (es->slcfg) gf_free(es->slcfg);\n\tgf_free(es);\n}\n\nstatic void gf_m2ts_reset_sdt(GF_M2TS_Demuxer *ts)\n{\n\twhile (gf_list_count(ts->SDTs)) {\n\t\tGF_M2TS_SDT *sdt = (GF_M2TS_SDT *)gf_list_last(ts->SDTs);\n\t\tgf_list_rem_last(ts->SDTs);\n\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\tif (sdt->service) gf_free(sdt->service);\n\t\tgf_free(sdt);\n\t}\n}\n\nGF_EXPORT\nGF_M2TS_SDT *gf_m2ts_get_sdt_info(GF_M2TS_Demuxer *ts, u32 program_id)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(ts->SDTs); i++) {\n\t\tGF_M2TS_SDT *sdt = (GF_M2TS_SDT *)gf_list_get(ts->SDTs, i);\n\t\tif (sdt->service_id==program_id) return sdt;\n\t}\n\treturn NULL;\n}\n\nstatic void gf_m2ts_section_complete(GF_M2TS_Demuxer *ts, GF_M2TS_SectionFilter *sec, GF_M2TS_SECTION_ES *ses)\n{\n\t//seek mode, only process PAT and PMT\n\tif (ts->seek_mode && (sec->section[0] != GF_M2TS_TABLE_ID_PAT) && (sec->section[0] != GF_M2TS_TABLE_ID_PMT)) {\n\t\t/*clean-up (including broken sections)*/\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->section = NULL;\n\t\tsec->length = sec->received = 0;\n\t\treturn;\n\t}\n\n\tif (!sec->process_section) {\n\t\tif ((ts->on_event && (sec->section[0]==GF_M2TS_TABLE_ID_AIT)) ) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\t//ts->on_event(ts, GF_M2TS_EVT_AIT_FOUND, &pck);\n\t\t\ton_ait_section(ts, GF_M2TS_EVT_AIT_FOUND, &pck);\n#endif\n\t\t} else if ((ts->on_event && (sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_ENCAPSULATED_DATA\t|| sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_UN_MESSAGE ||\n\t\t                             sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_DOWNLOAD_DATA_MESSAGE || sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_STREAM_DESCRIPTION || sec->section[0]==GF_M2TS_TABLE_ID_DSM_CC_PRIVATE)) ) {\n\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\ton_dsmcc_section(ts,GF_M2TS_EVT_DSMCC_FOUND,&pck);\n\t\t\t//ts->on_event(ts, GF_M2TS_EVT_DSMCC_FOUND, &pck);\n#endif\n\t\t}\n#ifdef GPAC_ENABLE_MPE\n\t\telse if (ts->on_mpe_event && ((ses && (ses->flags & GF_M2TS_EVT_DVB_MPE)) || (sec->section[0]==GF_M2TS_TABLE_ID_INT)) ) {\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\tts->on_mpe_event(ts, GF_M2TS_EVT_DVB_MPE, &pck);\n\t\t}\n#endif\n\t\telse if (ts->on_event) {\n\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\tpck.data_len = sec->length;\n\t\t\tpck.data = sec->section;\n\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\tts->on_event(ts, GF_M2TS_EVT_DVB_GENERAL, &pck);\n\t\t}\n\t} else {\n\t\tBool has_syntax_indicator;\n\t\tu8 table_id;\n\t\tu16 extended_table_id;\n\t\tu32 status, section_start, i;\n\t\tGF_M2TS_Table *t, *prev_t;\n\t\tunsigned char *data;\n\t\tBool section_valid = 0;\n\n\t\tstatus = 0;\n\t\t/*parse header*/\n\t\tdata = (u8 *)sec->section;\n\n\t\t/*look for proper table*/\n\t\ttable_id = data[0];\n\n\t\tif (ts->on_event) {\n\t\t\tswitch (table_id) {\n\t\t\tcase GF_M2TS_TABLE_ID_PAT:\n\t\t\tcase GF_M2TS_TABLE_ID_SDT_ACTUAL:\n\t\t\tcase GF_M2TS_TABLE_ID_PMT:\n\t\t\tcase GF_M2TS_TABLE_ID_NIT_ACTUAL:\n\t\t\tcase GF_M2TS_TABLE_ID_TDT:\n\t\t\tcase GF_M2TS_TABLE_ID_TOT:\n\t\t\t{\n\t\t\t\tGF_M2TS_SL_PCK pck;\n\t\t\t\tpck.data_len = sec->length;\n\t\t\t\tpck.data = sec->section;\n\t\t\t\tpck.stream = (GF_M2TS_ES *)ses;\n\t\t\t\tts->on_event(ts, GF_M2TS_EVT_DVB_GENERAL, &pck);\n\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thas_syntax_indicator = (data[1] & 0x80) ? 1 : 0;\n\t\tif (has_syntax_indicator) {\n\t\t\textended_table_id = (data[3]<<8) | data[4];\n\t\t} else {\n\t\t\textended_table_id = 0;\n\t\t}\n\n\t\tprev_t = NULL;\n\t\tt = sec->table;\n\t\twhile (t) {\n\t\t\tif ((t->table_id==table_id) && (t->ex_table_id == extended_table_id)) break;\n\t\t\tprev_t = t;\n\t\t\tt = t->next;\n\t\t}\n\n\t\t/*create table*/\n\t\tif (!t) {\n\t\t\tGF_SAFEALLOC(t, GF_M2TS_Table);\n\t\t\tif (!t) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc table %d %d\\n\", table_id, extended_table_id));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Creating table %d %d\\n\", table_id, extended_table_id));\n\t\t\tt->table_id = table_id;\n\t\t\tt->ex_table_id = extended_table_id;\n\t\t\tt->last_version_number = 0xFF;\n\t\t\tt->sections = gf_list_new();\n\t\t\tif (prev_t) prev_t->next = t;\n\t\t\telse sec->table = t;\n\t\t}\n\n\t\tif (has_syntax_indicator) {\n\t\t\tif (sec->length < 4) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted section length %d less than CRC \\n\", sec->length));\n\t\t\t} else {\n\t\t\t\t/*remove crc32*/\n\t\t\t\tsec->length -= 4;\n\t\t\t\tif (gf_m2ts_crc32_check((char *)data, sec->length)) {\n\t\t\t\t\ts32 cur_sec_num;\n\t\t\t\t\tt->version_number = (data[5] >> 1) & 0x1f;\n\t\t\t\t\tif (t->last_section_number && t->section_number && (t->version_number != t->last_version_number)) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] table transmission interrupted: previous table (v=%d) %d/%d sections - new table (v=%d) %d/%d sections\\n\", t->last_version_number, t->section_number, t->last_section_number, t->version_number, data[6] + 1, data[7] + 1) );\n\t\t\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t\t\t\tt->section_number = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tt->current_next_indicator = (data[5] & 0x1) ? 1 : 0;\n\t\t\t\t\t/*add one to section numbers to detect if we missed or not the first section in the table*/\n\t\t\t\t\tcur_sec_num = data[6] + 1;\n\t\t\t\t\tt->last_section_number = data[7] + 1;\n\t\t\t\t\tsection_start = 8;\n\t\t\t\t\t/*we missed something*/\n\t\t\t\t\tif (!sec->process_individual && t->section_number + 1 != cur_sec_num) {\n\t\t\t\t\t\t/* TODO - Check how to handle sections when the first complete section does\n\t\t\t\t\t\t   not have its sec num 0 */\n\t\t\t\t\t\tsection_valid = 0;\n\t\t\t\t\t\tif (t->is_init) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted table (lost section %d)\\n\", cur_sec_num ? cur_sec_num-1 : 31) );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsection_valid = 1;\n\t\t\t\t\t\tt->section_number = cur_sec_num;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted section (CRC32 failed)\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsection_valid = 1;\n\t\t\tsection_start = 3;\n\t\t}\n\t\t/*process section*/\n\t\tif (section_valid) {\n\t\t\tGF_M2TS_Section *section;\n\n\t\t\tGF_SAFEALLOC(section, GF_M2TS_Section);\n\t\t\tif (!section) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create section\\n\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsection->data_size = sec->length - section_start;\n\t\t\tsection->data = (unsigned char*)gf_malloc(sizeof(unsigned char)*section->data_size);\n\t\t\tmemcpy(section->data, sec->section + section_start, sizeof(unsigned char)*section->data_size);\n\t\t\tgf_list_add(t->sections, section);\n\n\t\t\tif (t->section_number == 1) {\n\t\t\t\tstatus |= GF_M2TS_TABLE_START;\n\t\t\t\tif (t->last_version_number == t->version_number) {\n\t\t\t\t\tt->is_repeat = 1;\n\t\t\t\t} else {\n\t\t\t\t\tt->is_repeat = 0;\n\t\t\t\t}\n\t\t\t\t/*only update version number in the first section of the table*/\n\t\t\t\tt->last_version_number = t->version_number;\n\t\t\t}\n\n\t\t\tif (t->is_init) {\n\t\t\t\tif (t->is_repeat) {\n\t\t\t\t\tstatus |=  GF_M2TS_TABLE_REPEAT;\n\t\t\t\t} else {\n\t\t\t\t\tstatus |=  GF_M2TS_TABLE_UPDATE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstatus |=  GF_M2TS_TABLE_FOUND;\n\t\t\t}\n\n\t\t\tif (t->last_section_number == t->section_number) {\n\t\t\t\tu32 table_size;\n\n\t\t\t\tstatus |= GF_M2TS_TABLE_END;\n\n\t\t\t\ttable_size = 0;\n\t\t\t\tfor (i=0; i<gf_list_count(t->sections); i++) {\n\t\t\t\t\tGF_M2TS_Section *section = gf_list_get(t->sections, i);\n\t\t\t\t\ttable_size += section->data_size;\n\t\t\t\t}\n\t\t\t\tif (t->is_repeat) {\n\t\t\t\t\tif (t->table_size != table_size) {\n\t\t\t\t\t\tstatus |= GF_M2TS_TABLE_UPDATE;\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Repeated section found with different sizes (old table %d bytes, new table %d bytes)\\n\", t->table_size, table_size) );\n\n\t\t\t\t\t\tt->table_size = table_size;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tt->table_size = table_size;\n\t\t\t\t}\n\n\t\t\t\tt->is_init = 1;\n\t\t\t\t/*reset section number*/\n\t\t\t\tt->section_number = 0;\n\n\t\t\t\tt->is_repeat = 0;\n\n\t\t\t}\n\n\t\t\tif (sec->process_individual) {\n\t\t\t\t/*send each section of the table and not the aggregated table*/\n\t\t\t\tif (sec->process_section)\n\t\t\t\t\tsec->process_section(ts, ses, t->sections, t->table_id, t->ex_table_id, t->version_number, (u8) (t->last_section_number - 1), status);\n\n\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t} else {\n\t\t\t\tif (status&GF_M2TS_TABLE_END) {\n\t\t\t\t\tif (sec->process_section)\n\t\t\t\t\t\tsec->process_section(ts, ses, t->sections, t->table_id, t->ex_table_id, t->version_number, (u8) (t->last_section_number - 1), status);\n\n\t\t\t\t\tgf_m2ts_reset_sections(t->sections);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tsec->cc = -1;\n\t\t\tt->section_number = 0;\n\t\t}\n\t}\n\t/*clean-up (including broken sections)*/\n\tif (sec->section) gf_free(sec->section);\n\tsec->section = NULL;\n\tsec->length = sec->received = 0;\n}\n\nstatic Bool gf_m2ts_is_long_section(u8 table_id)\n{\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_MPEG4_BIFS:\n\tcase GF_M2TS_TABLE_ID_MPEG4_OD:\n\tcase GF_M2TS_TABLE_ID_INT:\n\tcase GF_M2TS_TABLE_ID_EIT_ACTUAL_PF:\n\tcase GF_M2TS_TABLE_ID_EIT_OTHER_PF:\n\tcase GF_M2TS_TABLE_ID_ST:\n\tcase GF_M2TS_TABLE_ID_SIT:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_PRIVATE:\n\tcase GF_M2TS_TABLE_ID_MPE_FEC:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_DOWNLOAD_DATA_MESSAGE:\n\tcase GF_M2TS_TABLE_ID_DSM_CC_UN_MESSAGE:\n\t\treturn 1;\n\tdefault:\n\t\tif (table_id >= GF_M2TS_TABLE_ID_EIT_SCHEDULE_MIN && table_id <= GF_M2TS_TABLE_ID_EIT_SCHEDULE_MAX)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\t}\n}\n\nstatic u32 gf_m2ts_get_section_length(char byte0, char byte1, char byte2)\n{\n\tu32 length;\n\tif (gf_m2ts_is_long_section(byte0)) {\n\t\tlength = 3 + ( ((((u32)byte1)<<8) | (byte2&0xff)) & 0xfff );\n\t} else {\n\t\tlength = 3 + ( ((((u32)byte1)<<8) | (byte2&0xff)) & 0x3ff );\n\t}\n\treturn length;\n}\n\nstatic void gf_m2ts_gather_section(GF_M2TS_Demuxer *ts, GF_M2TS_SectionFilter *sec, GF_M2TS_SECTION_ES *ses, GF_M2TS_Header *hdr, unsigned char *data, u32 data_size)\n{\n\tu32 payload_size = data_size;\n\tu8 expect_cc = (sec->cc<0) ? hdr->continuity_counter : (sec->cc + 1) & 0xf;\n\tBool disc = (expect_cc == hdr->continuity_counter) ? 0 : 1;\n\tsec->cc = expect_cc;\n\n\t/*may happen if hdr->adaptation_field=2 no payload in TS packet*/\n\tif (!data_size) return;\n\n\tif (hdr->payload_start) {\n\t\tu32 ptr_field;\n\n\t\tptr_field = data[0];\n\t\tif (ptr_field+1>data_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid section start (@ptr_field=%d, @data_size=%d)\\n\", ptr_field, data_size) );\n\t\t\treturn;\n\t\t}\n\n\t\t/*end of previous section*/\n\t\tif (!sec->length && sec->received) {\n\t\t\t/* the length of the section could not be determined from the previous TS packet because we had only 1 or 2 bytes */\n\t\t\tif (sec->received == 1)\n\t\t\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], data[1], data[2]);\n\t\t\telse /* (sec->received == 2)  */\n\t\t\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], sec->section[1], data[1]);\n\t\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*sec->length);\n\t\t}\n\n\t\tif (sec->length && sec->received + ptr_field >= sec->length) {\n\t\t\tu32 len = sec->length - sec->received;\n\t\t\tmemcpy(sec->section + sec->received, data+1, sizeof(char)*len);\n\t\t\tsec->received += len;\n\t\t\tif (ptr_field > len)\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid pointer field (@ptr_field=%d, @remaining=%d)\\n\", ptr_field, len) );\n\t\t\tgf_m2ts_section_complete(ts, sec, ses);\n\t\t}\n\t\tdata += ptr_field+1;\n\t\tdata_size -= ptr_field+1;\n\t\tpayload_size -= ptr_field+1;\n\naggregated_section:\n\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->length = sec->received = 0;\n\t\tsec->section = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tmemcpy(sec->section, data, sizeof(char)*data_size);\n\t\tsec->received = data_size;\n\t} else if (disc) {\n\t\tif (sec->section) gf_free(sec->section);\n\t\tsec->section = NULL;\n\t\tsec->received = sec->length = 0;\n\t\treturn;\n\t} else if (!sec->section) {\n\t\treturn;\n\t} else {\n\t\tif (sec->length && sec->received+data_size > sec->length)\n\t\t\tdata_size = sec->length - sec->received;\n\n\t\tif (sec->length) {\n\t\t\tmemcpy(sec->section + sec->received, data, sizeof(char)*data_size);\n\t\t} else {\n\t\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*(sec->received+data_size));\n\t\t\tmemcpy(sec->section + sec->received, data, sizeof(char)*data_size);\n\t\t}\n\t\tsec->received += data_size;\n\t}\n\t/*alloc final buffer*/\n\tif (!sec->length && (sec->received >= 3)) {\n\t\tsec->length = gf_m2ts_get_section_length(sec->section[0], sec->section[1], sec->section[2]);\n\t\tsec->section = (char*)gf_realloc(sec->section, sizeof(char)*sec->length);\n\n\t\tif (sec->received > sec->length) {\n\t\t\tdata_size -= sec->received - sec->length;\n\t\t\tsec->received = sec->length;\n\t\t}\n\t}\n\tif (!sec->length || sec->received < sec->length) return;\n\n\t/*OK done*/\n\tgf_m2ts_section_complete(ts, sec, ses);\n\n\tif (payload_size > data_size) {\n\t\tdata += data_size;\n\t\t/* detect padding after previous section */\n\t\tif (data[0] != 0xFF) {\n\t\t\tdata_size = payload_size - data_size;\n\t\t\tpayload_size = data_size;\n\t\t\tgoto aggregated_section;\n\t\t}\n\t}\n}\n\nstatic void gf_m2ts_process_sdt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 pos, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SDT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tif (table_id != GF_M2TS_TABLE_ID_SDT_ACTUAL) {\n\t\treturn;\n\t}\n\n\tgf_m2ts_reset_sdt(ts);\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SDT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t//orig_net_id = (data[0] << 8) | data[1];\n\tpos = 3;\n\twhile (pos < data_size) {\n\t\tGF_M2TS_SDT *sdt;\n\t\tu32 descs_size, d_pos, ulen;\n\n\t\tGF_SAFEALLOC(sdt, GF_M2TS_SDT);\n\t\tif (!sdt) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to create SDT\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tgf_list_add(ts->SDTs, sdt);\n\n\t\tsdt->service_id = (data[pos]<<8) + data[pos+1];\n\t\tsdt->EIT_schedule = (data[pos+2] & 0x2) ? 1 : 0;\n\t\tsdt->EIT_present_following = (data[pos+2] & 0x1);\n\t\tsdt->running_status = (data[pos+3]>>5) & 0x7;\n\t\tsdt->free_CA_mode = (data[pos+3]>>4) & 0x1;\n\t\tdescs_size = ((data[pos+3]&0xf)<<8) | data[pos+4];\n\t\tpos += 5;\n\n\t\td_pos = 0;\n\t\twhile (d_pos < descs_size) {\n\t\t\tu8 d_tag = data[pos+d_pos];\n\t\t\tu8 d_len = data[pos+d_pos+1];\n\n\t\t\tswitch (d_tag) {\n\t\t\tcase GF_M2TS_DVB_SERVICE_DESCRIPTOR:\n\t\t\t\tif (sdt->provider) gf_free(sdt->provider);\n\t\t\t\tsdt->provider = NULL;\n\t\t\t\tif (sdt->service) gf_free(sdt->service);\n\t\t\t\tsdt->service = NULL;\n\n\t\t\t\td_pos+=2;\n\t\t\t\tsdt->service_type = data[pos+d_pos];\n\t\t\t\tulen = data[pos+d_pos+1];\n\t\t\t\td_pos += 2;\n\t\t\t\tsdt->provider = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->provider, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->provider[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\n\t\t\t\tulen = data[pos+d_pos];\n\t\t\t\td_pos += 1;\n\t\t\t\tsdt->service = (char*)gf_malloc(sizeof(char)*(ulen+1));\n\t\t\t\tmemcpy(sdt->service, data+pos+d_pos, sizeof(char)*ulen);\n\t\t\t\tsdt->service[ulen] = 0;\n\t\t\t\td_pos += ulen;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) not supported\\n\", d_tag));\n\t\t\t\td_pos += d_len;\n\t\t\t\tif (d_len == 0) d_pos = descs_size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpos += descs_size;\n\t}\n\tevt_type = GF_M2TS_EVT_SDT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nstatic void gf_m2ts_process_mpeg4section(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_SL_PCK sl_pck;\n\tu32 nb_sections, i;\n\tGF_M2TS_Section *section;\n\n\t/*skip if already received*/\n\tif (status & GF_M2TS_TABLE_REPEAT)\n\t\tif (!(es->flags & GF_M2TS_ES_SEND_REPEATED_SECTIONS))\n\t\t\treturn;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Sections for PID %d\\n\", es->pid) );\n\t/*send all sections (eg SL-packets)*/\n\tnb_sections = gf_list_count(sections);\n\tfor (i=0; i<nb_sections; i++) {\n\t\tsection = (GF_M2TS_Section *)gf_list_get(sections, i);\n\t\tsl_pck.data = (char *)section->data;\n\t\tsl_pck.data_len = section->data_size;\n\t\tsl_pck.stream = (GF_M2TS_ES *)es;\n\t\tsl_pck.version_number = version_number;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t}\n}\n\nstatic void gf_m2ts_process_nit(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *nit_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] NIT table processing (not yet implemented)\"));\n}\n\n\n\n\nstatic void gf_m2ts_process_tdt_tot(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *tdt_tot_es, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tunsigned char *data;\n\tu32 data_size, nb_sections;\n\tu32 date, yp, mp, k;\n\tGF_M2TS_Section *section;\n\tGF_M2TS_TDT_TOT *time_table;\n\tconst char *table_name;\n\n\t/*wait for the last section */\n\tif ( !(status & GF_M2TS_TABLE_END) )\n\t\treturn;\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\ttable_name = \"TDT\";\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n\t\ttable_name = \"TOT\";\n\t\tbreak;\n\tdefault:\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Unimplemented table_id %u for PID %u\\n\", table_id, GF_M2TS_PID_TDT_TOT_ST));\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] %s on multiple sections not supported\\n\", table_name));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\t/*TOT only contains 40 bits of UTC_time; TDT add descriptors and a CRC*/\n\tif ((table_id==GF_M2TS_TABLE_ID_TDT) && (data_size != 5)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Corrupted TDT size\\n\", table_name));\n\t}\n\tGF_SAFEALLOC(time_table, GF_M2TS_TDT_TOT);\n\tif (!time_table) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Fail to alloc DVB time table\\n\"));\n\t\treturn;\n\t}\n\n\t/*UTC_time - see annex C of DVB-SI ETSI EN 300468*/\n/* decodes an Modified Julian Date (MJD) into a Co-ordinated Universal Time (UTC)\nSee annex C of DVB-SI ETSI EN 300468 */\n\tdate = data[0]*256 + data[1];\n\typ = (u32)((date - 15078.2)/365.25);\n\tmp = (u32)((date - 14956.1 - (u32)(yp * 365.25))/30.6001);\n\ttime_table->day = (u32)(date - 14956 - (u32)(yp * 365.25) - (u32)(mp * 30.6001));\n\tif (mp == 14 || mp == 15) k = 1;\n\telse k = 0;\n\ttime_table->year = yp + k + 1900;\n\ttime_table->month = mp - 1 - k*12;\n\n\ttime_table->hour   = 10*((data[2]&0xf0)>>4) + (data[2]&0x0f);\n\ttime_table->minute = 10*((data[3]&0xf0)>>4) + (data[3]&0x0f);\n\ttime_table->second = 10*((data[4]&0xf0)>>4) + (data[4]&0x0f);\n\tassert(time_table->hour<24 && time_table->minute<60 && time_table->second<60);\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream UTC time is %u/%02u/%02u %02u:%02u:%02u\\n\", time_table->year, time_table->month, time_table->day, time_table->hour, time_table->minute, time_table->second));\n\n\tswitch (table_id) {\n\tcase GF_M2TS_TABLE_ID_TDT:\n\t\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\t\tts->TDT_time = time_table;\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TDT, time_table);\n\t\tbreak;\n\tcase GF_M2TS_TABLE_ID_TOT:\n#if 0\n\t{\n\t\tu32 pos, loop_len;\n\t\tloop_len = ((data[5]&0x0f) << 8) | (data[6] & 0xff);\n\t\tdata += 7;\n\t\tpos = 0;\n\t\twhile (pos < loop_len) {\n\t\t\tu8 tag = data[pos];\n\t\t\tpos += 2;\n\t\t\tif (tag == GF_M2TS_DVB_LOCAL_TIME_OFFSET_DESCRIPTOR) {\n\t\t\t\tchar tmp_time[10];\n\t\t\t\tu16 offset_hours, offset_minutes;\n\t\t\t\tnow->country_code[0] = data[pos];\n\t\t\t\tnow->country_code[1] = data[pos+1];\n\t\t\t\tnow->country_code[2] = data[pos+2];\n\t\t\t\tnow->country_region_id = data[pos+3]>>2;\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+4]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+5]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->local_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->local_time_offset_seconds *= -1;\n\n\t\t\t\tdvb_decode_mjd_to_unix_time(data+pos+6, &now->unix_next_toc);\n\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+11]);\n\t\t\t\toffset_hours = atoi(tmp_time);\n\t\t\t\tsprintf(tmp_time, \"%02x\", data[pos+12]);\n\t\t\t\toffset_minutes = atoi(tmp_time);\n\t\t\t\tnow->next_time_offset_seconds = (offset_hours * 60 + offset_minutes) * 60;\n\t\t\t\tif (data[pos+3] & 1) now->next_time_offset_seconds *= -1;\n\t\t\t\tpos+= 13;\n\t\t\t}\n\t\t}\n\t\t/*TODO: check lengths are ok*/\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\t}\n#endif\n\t/*check CRC32*/\n\tif (ts->tdt_tot->length<4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (less than 4 bytes but CRC32 should be present\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (!gf_m2ts_crc32_check(ts->tdt_tot->section, ts->tdt_tot->length-4)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] corrupted %s table (CRC32 failed)\\n\", table_name));\n\t\tgoto error_exit;\n\t}\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tts->TDT_time = time_table;\n\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TOT, time_table);\n\tbreak;\n\tdefault:\n\t\tassert(0);\n\t\tgoto error_exit;\n\t}\n\n\treturn; /*success*/\n\nerror_exit:\n\tgf_free(time_table);\n\treturn;\n}\n\nstatic GF_M2TS_MetadataPointerDescriptor *gf_m2ts_read_metadata_pointer_descriptor(GF_BitStream *bs, u32 length)\n{\n\tu32 size;\n\tGF_M2TS_MetadataPointerDescriptor *d;\n\tGF_SAFEALLOC(d, GF_M2TS_MetadataPointerDescriptor);\n\tif (!d) return NULL;\n\td->application_format = gf_bs_read_u16(bs);\n\tsize = 2;\n\tif (d->application_format == 0xFFFF) {\n\t\td->application_format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->format = gf_bs_read_u8(bs);\n\tsize += 1;\n\tif (d->format == 0xFF) {\n\t\td->format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->service_id = gf_bs_read_u8(bs);\n\td->locator_record_flag = (gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE);\n\td->carriage_flag = (enum metadata_carriage)gf_bs_read_int(bs, 2);\n\tgf_bs_read_int(bs, 5); /*reserved */\n\tsize += 2;\n\tif (d->locator_record_flag) {\n\t\td->locator_length = gf_bs_read_u8(bs);\n\t\td->locator_data = (char *)gf_malloc(d->locator_length);\n\t\tsize += 1 + d->locator_length;\n\t\tgf_bs_read_data(bs, d->locator_data, d->locator_length);\n\t}\n\tif (d->carriage_flag != 3) {\n\t\td->program_number = gf_bs_read_u16(bs);\n\t\tsize += 2;\n\t}\n\tif (d->carriage_flag == 1) {\n\t\td->ts_location = gf_bs_read_u16(bs);\n\t\td->ts_id = gf_bs_read_u16(bs);\n\t\tsize += 4;\n\t}\n\tif (length-size > 0) {\n\t\td->data_size = length-size;\n\t\td->data = (char *)gf_malloc(d->data_size);\n\t\tgf_bs_read_data(bs, d->data, d->data_size);\n\t}\n\treturn d;\n}\n\nstatic void gf_m2ts_metadata_pointer_descriptor_del(GF_M2TS_MetadataPointerDescriptor *metapd)\n{\n\tif (metapd) {\n\t\tif (metapd->locator_data) gf_free(metapd->locator_data);\n\t\tif (metapd->data) gf_free(metapd->data);\n\t\tgf_free(metapd);\n\t}\n}\n\nstatic GF_M2TS_MetadataDescriptor *gf_m2ts_read_metadata_descriptor(GF_BitStream *bs, u32 length)\n{\n\tu32 size;\n\tGF_M2TS_MetadataDescriptor *d;\n\tGF_SAFEALLOC(d, GF_M2TS_MetadataDescriptor);\n\tif (!d) return NULL;\n\td->application_format = gf_bs_read_u16(bs);\n\tsize = 2;\n\tif (d->application_format == 0xFFFF) {\n\t\td->application_format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->format = gf_bs_read_u8(bs);\n\tsize += 1;\n\tif (d->format == 0xFF) {\n\t\td->format_identifier = gf_bs_read_u32(bs);\n\t\tsize += 4;\n\t}\n\td->service_id = gf_bs_read_u8(bs);\n\td->decoder_config_flags = gf_bs_read_int(bs, 3);\n\td->dsmcc_flag = (gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE);\n\tgf_bs_read_int(bs, 4); /* reserved */\n\tsize += 2;\n\tif (d->dsmcc_flag) {\n\t\td->service_id_record_length = gf_bs_read_u8(bs);\n\t\td->service_id_record = (char *)gf_malloc(d->service_id_record_length);\n\t\tsize += 1 + d->service_id_record_length;\n\t\tgf_bs_read_data(bs, d->service_id_record, d->service_id_record_length);\n\t}\n\tif (d->decoder_config_flags == 1) {\n\t\td->decoder_config_length = gf_bs_read_u8(bs);\n\t\td->decoder_config = (char *)gf_malloc(d->decoder_config_length);\n\t\tsize += 1 + d->decoder_config_length;\n\t\tgf_bs_read_data(bs, d->decoder_config, d->decoder_config_length);\n\t}\n\tif (d->decoder_config_flags == 3) {\n\t\td->decoder_config_id_length = gf_bs_read_u8(bs);\n\t\td->decoder_config_id = (char *)gf_malloc(d->decoder_config_id_length);\n\t\tsize += 1 + d->decoder_config_id_length;\n\t\tgf_bs_read_data(bs, d->decoder_config_id, d->decoder_config_id_length);\n\t}\n\tif (d->decoder_config_flags == 4) {\n\t\td->decoder_config_service_id = gf_bs_read_u8(bs);\n\t\tsize++;\n\t}\n\treturn d;\n}\n\n\nstatic void gf_m2ts_process_pmt(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *pmt, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 info_length, pos, desc_len, evt_type, nb_es,i;\n\tu32 nb_sections;\n\tu32 data_size;\n\tu32 nb_hevc, nb_hevc_temp, nb_shvc, nb_shvc_temp, nb_mhvc, nb_mhvc_temp;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\tGF_Err e = GF_OK;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\tnb_es = 0;\n\n\t/*skip if already received but no update detected (eg same data) */\n\tif ((status&GF_M2TS_TABLE_REPEAT) && !(status&GF_M2TS_TABLE_UPDATE))  {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t\treturn;\n\t}\n\n\tif (pmt->sec->demux_restarted) {\n\t\tpmt->sec->demux_restarted = 0;\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PMT Found or updated\\n\"));\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length + 4 > data_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT first loop, %d bytes avail but first loop size %d\\n\", data_size, info_length));\n\t\treturn;\n\t} else if (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tif ((len>2) && (len - 2 <= info_length)) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken IOD! len %d less than 2 bytes to declare IOD\\n\", len));\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {\n\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\tpmt->program->metadata_pointer_descriptor = metapd;\n\t\t\t\t} else {\n\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\tgf_m2ts_metadata_pointer_descriptor_del(metapd);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Skipping descriptor (0x%x) and others not supported\\n\", tag));\n\t\t\t}\n\t\t\tfirst_loop_len += 2 + len;\n\t\t}\n\t}\n\tif (data_size <= 4 + info_length) return;\n\tdata += 4 + info_length;\n\tdata_size -= 4 + info_length;\n\tpos = 0;\n\n\t/* count de number of program related PMT received */\n\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\tGF_M2TS_Program *prog = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\tif(prog->pmt_pid == pmt->pid) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_hevc = nb_hevc_temp = nb_shvc = nb_shvc_temp = nb_mhvc = nb_mhvc_temp = 0;\n\twhile (pos<data_size) {\n\t\tGF_M2TS_PES *pes = NULL;\n\t\tGF_M2TS_SECTION_ES *ses = NULL;\n\t\tGF_M2TS_ES *es = NULL;\n\t\tBool inherit_pcr = 0;\n\t\tu32 pid, stream_type, reg_desc_format;\n\n\t\tif (pos + 5 > data_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT! size %d but position %d and need at least 5 bytes to declare es\\n\", data_size, pos));\n\t\t\tbreak;\n\t\t}\n\n\t\tstream_type = data[0];\n\t\tpid = ((data[1] & 0x1f) << 8) | data[2];\n\t\tdesc_len = ((data[3] & 0xf) << 8) | data[4];\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"stream_type :%d \\n\",stream_type));\n\t\tswitch (stream_type) {\n\n\t\t/* PES */\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_DCII:\n\t\tcase GF_M2TS_VIDEO_MPEG4:\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_PES:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_MVCD:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\tinherit_pcr = 1;\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_DTS:\n\t\tcase GF_M2TS_MHAS_MAIN:\n\t\tcase GF_M2TS_MHAS_AUX:\n\t\tcase GF_M2TS_SUBTITLE_DVB:\n\t\tcase GF_M2TS_METADATA_PES:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tif (inherit_pcr)\n\t\t\t\tpes->flags |= GF_M2TS_INHERIT_PCR;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\tGF_SAFEALLOC(pes, GF_M2TS_PES);\n\t\t\tif (!pes) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpes->cc = -1;\n\t\t\tpes->flags = GF_M2TS_ES_IS_PES;\n\t\t\tes = (GF_M2TS_ES *)pes;\n\t\t\tbreak;\n\t\t/* Sections */\n\t\tcase GF_M2TS_SYSTEMS_MPEG4_SECTIONS:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\t/* carriage of ISO_IEC_14496 data in sections */\n\t\t\tif (stream_type == GF_M2TS_SYSTEMS_MPEG4_SECTIONS) {\n\t\t\t\t/*MPEG-4 sections need to be fully checked: if one section is lost, this means we lost\n\t\t\t\tone SL packet in the AU so we must wait for the complete section again*/\n\t\t\t\tses->sec = gf_m2ts_section_filter_new(gf_m2ts_process_mpeg4section, 0);\n\t\t\t\t/*create OD container*/\n\t\t\t\tif (!pmt->program->additional_ods) {\n\t\t\t\t\tpmt->program->additional_ods = gf_list_new();\n\t\t\t\t\tts->has_4on2 = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_13818_6_ANNEX_A:\n\t\tcase GF_M2TS_13818_6_ANNEX_B:\n\t\tcase GF_M2TS_13818_6_ANNEX_C:\n\t\tcase GF_M2TS_13818_6_ANNEX_D:\n\t\tcase GF_M2TS_PRIVATE_SECTION:\n\t\tcase GF_M2TS_QUALITY_SEC:\n\t\tcase GF_M2TS_MORE_SEC:\n\t\t\tGF_SAFEALLOC(ses, GF_M2TS_SECTION_ES);\n\t\t\tif (!ses) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG2TS] Failed to allocate ES for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tes = (GF_M2TS_ES *)ses;\n\t\t\tes->flags |= GF_M2TS_ES_IS_SECTION;\n\t\t\tes->pid = pid;\n\t\t\tes->service_id = pmt->program->number;\n\t\t\tif (stream_type == GF_M2TS_PRIVATE_SECTION) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"AIT sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_QUALITY_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Quality metadata sections on pid %d\\n\", pid));\n\t\t\t} else if (stream_type == GF_M2TS_MORE_SEC) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"MORE sections on pid %d\\n\", pid));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type DSM CC user private sections on pid %d \\n\", pid));\n\t\t\t}\n\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t//ses->sec->service_id = pmt->program->number;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_MPE_SECTIONS:\n\t\t\tif (! ts->prefix_present) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"stream type MPE found : pid = %d \\n\", pid));\n#ifdef GPAC_ENABLE_MPE\n\t\t\t\tes = gf_dvb_mpe_section_new();\n\t\t\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\t\t\t/* NULL means: trigger the call to on_event with DVB_GENERAL type and the raw section as payload */\n\t\t\t\t\t((GF_M2TS_SECTION_ES*)es)->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t}\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\t//GF_LOG(/*GF_LOG_WARNING*/GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (es) {\n\t\t\tes->stream_type = (stream_type==GF_M2TS_PRIVATE_DATA) ? 0 : stream_type;\n\t\t\tes->program = pmt->program;\n\t\t\tes->pid = pid;\n\t\t\tes->component_tag = -1;\n\t\t}\n\n\t\tpos += 5;\n\t\tdata += 5;\n\n\t\twhile (desc_len) {\n\t\t\tif (pos + 2 > data_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d but position %d and need at least 2 bytes to parse descritpor\\n\", data_size, pos));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tu8 tag = data[0];\n\t\t\tu32 len = data[1];\n\n\t\t\tif (pos + 2 + len > data_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT descriptor! size %d, desc size %d but position %d\\n\", data_size, len, pos));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (es) {\n\t\t\t\tswitch (tag) {\n\t\t\t\tcase GF_M2TS_ISO_639_LANGUAGE_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=3) )\n\t\t\t\t\t\tpes->lang = GF_4CC(' ', data[2], data[3], data[4]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_MPEG4_SL_DESCRIPTOR:\n\t\t\t\t\tif (len>=2) {\n\t\t\t\t\t\tes->mpeg4_es_id = ( (u32) data[2] & 0x1f) << 8  | data[3];\n\t\t\t\t\t\tes->flags |= GF_M2TS_ES_IS_SL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_REGISTRATION_DESCRIPTOR:\n\t\t\t\t\tif (len>=4) {\n\t\t\t\t\t\treg_desc_format = GF_4CC(data[2], data[3], data[4], data[5]);\n\t\t\t\t\t\t/*cf http://www.smpte-ra.org/mpegreg/mpegreg.html*/\n\t\t\t\t\t\tswitch (reg_desc_format) {\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_AC3:\n\t\t\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_AC3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_VC1:\n\t\t\t\t\t\t\tes->stream_type = GF_M2TS_VIDEO_VC1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GF_M2TS_RA_STREAM_GPAC:\n\t\t\t\t\t\t\tif (len==8) {\n\t\t\t\t\t\t\t\tes->stream_type = GF_4CC(data[6], data[7], data[8], data[9]);\n\t\t\t\t\t\t\t\tes->flags |= GF_M2TS_GPAC_CODEC_ID;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"Unknown registration descriptor %s\\n\", gf_4cc_to_str(reg_desc_format) ));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_EAC3_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_AUDIO_EC3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_DATA_BROADCAST_ID_DESCRIPTOR:\n\t\t\t\t\tif (len>=2) {\n\t\t\t\t\t\tu32 id = data[2]<<8 | data[3];\n\t\t\t\t\t\tif ((id == 0xB) && ses && !ses->sec) {\n\t\t\t\t\t\t\tses->sec = gf_m2ts_section_filter_new(NULL, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_SUBTITLING_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=8)) {\n\t\t\t\t\t\tpes->sub.language[0] = data[2];\n\t\t\t\t\t\tpes->sub.language[1] = data[3];\n\t\t\t\t\t\tpes->sub.language[2] = data[4];\n\t\t\t\t\t\tpes->sub.type = data[5];\n\t\t\t\t\t\tpes->sub.composition_page_id = (data[6]<<8) | data[7];\n\t\t\t\t\t\tpes->sub.ancillary_page_id = (data[8]<<8) | data[9];\n\t\t\t\t\t}\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_SUBTITLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_STREAM_IDENTIFIER_DESCRIPTOR:\n\t\t\t\t\tif (len>=1) {\n\t\t\t\t\t\tes->component_tag = data[2];\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"Component Tag: %d on Program %d\\n\", es->component_tag, es->program->number));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_TELETEXT_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_TELETEXT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_DVB_VBI_DATA_DESCRIPTOR:\n\t\t\t\t\tes->stream_type = GF_M2TS_DVB_VBI;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_HIERARCHY_DESCRIPTOR:\n\t\t\t\t\tif (pes && (len>=4)) {\n\t\t\t\t\t\tu8 hierarchy_embedded_layer_index;\n\t\t\t\t\t\tGF_BitStream *hbs = gf_bs_new((const char *)data, data_size, GF_BITSTREAM_READ);\n\t\t\t\t\t\t/*u32 skip = */gf_bs_read_int(hbs, 16);\n\t\t\t\t\t\t/*u8 res1 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 temp_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 spatial_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 quality_scal = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 hierarchy_type = */gf_bs_read_int(hbs, 4);\n\t\t\t\t\t\t/*u8 res2 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_layer_index = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 tref_not_present = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\t/*u8 res3 = */gf_bs_read_int(hbs, 1);\n\t\t\t\t\t\thierarchy_embedded_layer_index = gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\t/*u8 res4 = */gf_bs_read_int(hbs, 2);\n\t\t\t\t\t\t/*u8 hierarchy_channel = */gf_bs_read_int(hbs, 6);\n\t\t\t\t\t\tgf_bs_del(hbs);\n\n\t\t\t\t\t\tpes->depends_on_pid = 1+hierarchy_embedded_layer_index;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_METADATA_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tGF_BitStream *metadatad_bs;\n\t\t\t\t\tGF_M2TS_MetadataDescriptor *metad;\n\t\t\t\t\tmetadatad_bs = gf_bs_new((char *)data+2, len, GF_BITSTREAM_READ);\n\t\t\t\t\tmetad = gf_m2ts_read_metadata_descriptor(metadatad_bs, len);\n\t\t\t\t\tgf_bs_del(metadatad_bs);\n\t\t\t\t\tif (metad->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t\t        metad->format_identifier == GF_M2TS_META_ID3) {\n\t\t\t\t\t\t/*HLS ID3 Metadata */\n\t\t\t\t\t\tif (pes) {\n\t\t\t\t\t\t\tpes->metadata_descriptor = metad;\n\t\t\t\t\t\t\tpes->stream_type = GF_M2TS_METADATA_ID3_HLS;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* don't know what to do with it for now, delete */\n\t\t\t\t\t\tgf_m2ts_metadata_descriptor_del(metad);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] skipping descriptor (0x%x) not supported\\n\", tag));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata += len+2;\n\t\t\tpos += len+2;\n\t\t\tif (desc_len < len+2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Invalid PMT es descriptor size for PID %d\\n\", pid ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc_len-=len+2;\n\t\t}\n\n\t\tif (es && !es->stream_type) {\n\t\t\tgf_free(es);\n\t\t\tes = NULL;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Private Stream type (0x%x) for PID %d not supported\\n\", stream_type, pid ) );\n\t\t}\n\n\t\tif (!es) continue;\n\n\t\tif (ts->ess[pid]) {\n\t\t\t//this is component reuse across programs, overwrite the previously declared stream ...\n\t\t\tif (status & GF_M2TS_TABLE_FOUND) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d reused across programs %d and %d, not completely supported\\n\", pid, ts->ess[pid]->program->number, es->program->number ) );\n\n\t\t\t\t//add stream to program but don't reassign the pid table until the stream is playing (>GF_M2TS_PES_FRAMING_SKIP)\n\t\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\t\tnb_es++;\n\t\t\t\t//skip assignment below\n\t\t\t\tes = NULL;\n\t\t\t}\n\t\t\t/*watchout for pmt update - FIXME this likely won't work in most cases*/\n\t\t\telse {\n\n\t\t\t\tGF_M2TS_ES *o_es = ts->ess[es->pid];\n\n\t\t\t\tif ((o_es->stream_type == es->stream_type)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK) == (es->flags & GF_M2TS_ES_STATIC_FLAGS_MASK))\n\t\t\t\t        && (o_es->mpeg4_es_id == es->mpeg4_es_id)\n\t\t\t\t        && ((o_es->flags & GF_M2TS_ES_IS_SECTION) || ((GF_M2TS_PES *)o_es)->lang == ((GF_M2TS_PES *)es)->lang)\n\t\t\t\t   ) {\n\t\t\t\t\tgf_free(es);\n\t\t\t\t\tes = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tgf_m2ts_es_del(o_es, ts);\n\t\t\t\t\tts->ess[es->pid] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {\n\t\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\t\t\tes->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 1;\n\t\t\t\telse es->depends_on_pid = 2;\n\t\t\t\tbreak;\n\t\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\t\t\tif (!nb_hevc_temp) es->depends_on_pid = 2;\n\t\t\t\telse es->depends_on_pid = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_es) {\n\t\tu32 i;\n\n\t\t//translate hierarchy descriptors indexes into PIDs - check whether the PMT-index rules are the same for HEVC\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *an_es = NULL;\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (!es->depends_on_pid) continue;\n\n\t\t\t//fixeme we are not always assured that hierarchy_layer_index matches the stream index...\n\t\t\t//+1 is because our first stream is the PMT\n\t\t\tan_es =  (GF_M2TS_PES *)gf_list_get(pmt->program->streams, es->depends_on_pid);\n\t\t\tif (an_es) {\n\t\t\t\tes->depends_on_pid = an_es->pid;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS] Wrong dependency index in hierarchy descriptor, assuming non-scalable stream\\n\"));\n\t\t\t\tes->depends_on_pid = 0;\n\t\t\t}\n\t\t}\n\n\t\tevt_type = (status&GF_M2TS_TABLE_FOUND) ? GF_M2TS_EVT_PMT_FOUND : GF_M2TS_EVT_PMT_UPDATE;\n\t\tif (ts->on_event) ts->on_event(ts, evt_type, pmt->program);\n\t} else {\n\t\t/* if we found no new ES it's simply a repeat of the PMT */\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PMT_REPEAT, pmt->program);\n\t}\n}\n\nstatic void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PAT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\\n\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size / 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate program for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Fail to allocate pmt filter for pid %d\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nstatic void gf_m2ts_process_cat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tu32 evt_type;\n\t/*\n\t\tGF_M2TS_Program *prog;\n\t\tGF_M2TS_SECTION_ES *pmt;\n\t\tu32 i, nb_progs;\n\t\tu32 nb_sections;\n\t\tu32 data_size;\n\t\tunsigned char *data;\n\t\tGF_M2TS_Section *section;\n\t*/\n\n\t/*wait for the last section */\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t/*skip if already received*/\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_CAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\t/*\n\t\tnb_sections = gf_list_count(sections);\n\t\tif (nb_sections > 1) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"CAT on multiple sections not supported\\n\"));\n\t\t}\n\n\t\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\t\tdata = section->data;\n\t\tdata_size = section->data_size;\n\n\t\tnb_progs = data_size / 4;\n\n\t\tfor (i=0; i<nb_progs; i++) {\n\t\t\tu16 number, pid;\n\t\t\tnumber = (data[0]<<8) | data[1];\n\t\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\t\tdata += 4;\n\t\t\tif (number==0) {\n\t\t\t\tif (!ts->nit) {\n\t\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\t\tprog->streams = gf_list_new();\n\t\t\t\tprog->pmt_pid = pid;\n\t\t\t\tprog->number = number;\n\t\t\t\tgf_list_add(ts->programs, prog);\n\t\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\t\tpmt->program = prog;\n\t\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t\t}\n\t\t}\n\t*/\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_CAT_UPDATE : GF_M2TS_EVT_CAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}\n\nu64 gf_m2ts_get_pts(unsigned char *data)\n{\n\tu64 pts;\n\tu32 val;\n\tpts = (u64)((data[0] >> 1) & 0x07) << 30;\n\tval = (data[1] << 8) | data[2];\n\tpts |= (u64)(val >> 1) << 15;\n\tval = (data[3] << 8) | data[4];\n\tpts |= (u64)(val >> 1);\n\treturn pts;\n}\n\nvoid gf_m2ts_pes_header(GF_M2TS_PES *pes, unsigned char *data, u32 data_size, GF_M2TS_PESHeader *pesh)\n{\n\tu32 has_pts, has_dts;\n\tu32 len_check;\n\tmemset(pesh, 0, sizeof(GF_M2TS_PESHeader));\n\n\tlen_check = 0;\n\n\tpesh->id = data[0];\n\tpesh->pck_len = (data[1]<<8) | data[2];\n\t/*\n\t\t2bits\n\t\tscrambling_control\t\t= gf_bs_read_int(bs,2);\n\t\tpriority\t\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\tpesh->data_alignment = (data[3] & 0x4) ? 1 : 0;\n\t/*\n\t\tcopyright\t\t\t\t= gf_bs_read_int(bs,1);\n\t\toriginal\t\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\thas_pts = (data[4]&0x80);\n\thas_dts = has_pts ? (data[4]&0x40) : 0;\n\t/*\n\t\tESCR_flag\t\t\t\t= gf_bs_read_int(bs,1);\n\t\tES_rate_flag\t\t\t= gf_bs_read_int(bs,1);\n\t\tDSM_flag\t\t\t\t= gf_bs_read_int(bs,1);\n\t\tadditional_copy_flag\t= gf_bs_read_int(bs,1);\n\t\tprev_crc_flag\t\t\t= gf_bs_read_int(bs,1);\n\t\textension_flag\t\t\t= gf_bs_read_int(bs,1);\n\t*/\n\n\tpesh->hdr_data_len = data[5];\n\n\tdata += 6;\n\tif (has_pts) {\n\t\tpesh->PTS = gf_m2ts_get_pts(data);\n\t\tdata+=5;\n\t\tlen_check += 5;\n\t}\n\tif (has_dts) {\n\t\tpesh->DTS = gf_m2ts_get_pts(data);\n\t\t//data+=5;\n\t\tlen_check += 5;\n\t} else {\n\t\tpesh->DTS = pesh->PTS;\n\t}\n\tif (len_check < pesh->hdr_data_len) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Skipping %d bytes in pes header\\n\", pes->pid, pesh->hdr_data_len - len_check));\n\t} else if (len_check > pesh->hdr_data_len) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Wrong pes_header_data_length field %d bytes - read %d\\n\", pes->pid, pesh->hdr_data_len, len_check));\n\t}\n\n\tif ((pesh->PTS<90000) && ((s32)pesh->DTS<0)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Wrong DTS %d negative for PTS %d - forcing to 0\\n\", pes->pid, pesh->DTS, pesh->PTS));\n\t\tpesh->DTS=0;\n\t}\n}\n\nstatic void gf_m2ts_store_temi(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes)\n{\n\tGF_BitStream *bs = gf_bs_new(pes->temi_tc_desc, pes->temi_tc_desc_len, GF_BITSTREAM_READ);\n\tu32 has_timestamp = gf_bs_read_int(bs, 2);\n\tBool has_ntp = (Bool) gf_bs_read_int(bs, 1);\n\t/*u32 has_ptp = */gf_bs_read_int(bs, 1);\n\t/*u32 has_timecode = */gf_bs_read_int(bs, 2);\n\n\tmemset(&pes->temi_tc, 0, sizeof(GF_M2TS_TemiTimecodeDescriptor));\n\tpes->temi_tc.force_reload = gf_bs_read_int(bs, 1);\n\tpes->temi_tc.is_paused = gf_bs_read_int(bs, 1);\n\tpes->temi_tc.is_discontinuity = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tpes->temi_tc.timeline_id = gf_bs_read_int(bs, 8);\n\tif (has_timestamp) {\n\t\tpes->temi_tc.media_timescale = gf_bs_read_u32(bs);\n\t\tif (has_timestamp==2)\n\t\t\tpes->temi_tc.media_timestamp = gf_bs_read_u64(bs);\n\t\telse\n\t\t\tpes->temi_tc.media_timestamp = gf_bs_read_u32(bs);\n\t}\n\tif (has_ntp) {\n\t\tpes->temi_tc.ntp = gf_bs_read_u64(bs);\n\t}\n\tgf_bs_del(bs);\n\tpes->temi_tc_desc_len = 0;\n\tpes->temi_pending = 1;\n}\n\nvoid gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes)\n{\n\tGF_M2TS_PESHeader pesh;\n\tif (!ts) return;\n\n\t/*we need at least a full, valid start code and PES header !!*/\n\tif ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) {\n\t\tu32 len;\n\t\tBool has_pes_header = GF_TRUE;\n\t\tu32 stream_id = pes->pck_data[3];\n\t\tBool same_pts = GF_FALSE;\n\n\t\tswitch (stream_id) {\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_MAP:\n\t\tcase GF_M2_STREAMID_PADDING:\n\t\tcase GF_M2_STREAMID_PRIVATE_2:\n\t\tcase GF_M2_STREAMID_ECM:\n\t\tcase GF_M2_STREAMID_EMM:\n\t\tcase GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY:\n\t\tcase GF_M2_STREAMID_DSMCC:\n\t\tcase GF_M2_STREAMID_H222_TYPE_E:\n\t\t\thas_pes_header = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (has_pes_header) {\n\n\t\t\t/*OK read header*/\n\t\t\tgf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh);\n\n\t\t\t/*send PES timing*/\n\t\t\tif (ts->notify_pes_timing) {\n\t\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\t\tpck.PTS = pesh.PTS;\n\t\t\t\tpck.DTS = pesh.DTS;\n\t\t\t\tpck.stream = pes;\n\t\t\t\tif (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP;\n\t\t\t\tpes->pes_end_packet_number = ts->pck_number;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\\n\", pes->pid, pesh.DTS, pesh.PTS));\n\n\t\t\tif (pesh.PTS) {\n\t\t\t\tif (pesh.PTS == pes->PTS) {\n\t\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same PTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->PTS));\n\t\t\t\t}\n\t#ifndef GPAC_DISABLE_LOG\n\t\t\t\t/*FIXME - this test should only be done for non bi-directionnally coded media\n\t\t\t\telse if (pesh.PTS < pes->PTS) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - PTS \"LLU\" less than previous packet PTS \"LLU\"\\n\", pes->pid, pesh.PTS, pes->PTS) );\n\t\t\t\t}\n\t\t\t\t*/\n\t#endif\n\n\t\t\t\tpes->PTS = pesh.PTS;\n\t#ifndef GPAC_DISABLE_LOG\n\t\t\t\t{\n\t\t\t\t\tif (pes->DTS && (pesh.DTS == pes->DTS)) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - same DTS \"LLU\" for two consecutive PES packets \\n\", pes->pid, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t\tif (pesh.DTS < pes->DTS) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d - DTS \"LLU\" less than previous DTS \"LLU\"\\n\", pes->pid, pesh.DTS, pes->DTS));\n\t\t\t\t\t}\n\t\t\t\t}\n\t#endif\n\t\t\t\tpes->DTS = pesh.DTS;\n\t\t\t}\n\t\t\t/*no PTSs were coded, same time*/\n\t\t\telse if (!pesh.hdr_data_len) {\n\t\t\t\tsame_pts = GF_TRUE;\n\t\t\t}\n\n\n\t\t\t/*3-byte start-code + 6 bytes header + hdr extensions*/\n\t\t\tlen = 9 + pesh.hdr_data_len;\n\n\t\t} else {\n\t\t\t/*3-byte start-code + 1 byte streamid*/\n\t\t\tlen = 4;\n\t\t\tmemset(&pesh, 0, sizeof(pesh));\n\t\t}\n\n\t\tif ((u8) pes->pck_data[3]==0xfa) {\n\t\t\tGF_M2TS_SL_PCK sl_pck;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\\n\", pes->pid, pes->mpeg4_es_id));\n\n\t\t\tif (pes->pck_data_len > len) {\n\t\t\t\tsl_pck.data = (char *)pes->pck_data + len;\n\t\t\t\tsl_pck.data_len = pes->pck_data_len - len;\n\t\t\t\tsl_pck.stream = (GF_M2TS_ES *)pes;\n\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\\n\", pes->pid, pes->pck_data_len, len));\n\t\t\t}\n\t\t} else if (pes->reframe) {\n\t\t\tu32 remain = 0;\n\t\t\tu32 offset = len;\n\n\t\t\tif (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\\n\", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len));\n\t\t\t}\n\t\t\t//copy over the remaining of previous PES payload before start of this PES payload\n\t\t\tif (pes->prev_data_len) {\n\t\t\t\tif (pes->prev_data_len < len) {\n\t\t\t\t\toffset = len - pes->prev_data_len;\n\t\t\t\t\tmemcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\\n\", pes->pid, pes->prev_data_len ));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!pes->temi_pending && pes->temi_tc_desc_len) {\n\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\t\t\t}\n\n\t\t\tif (pes->temi_pending) {\n\t\t\t\tpes->temi_pending = 0;\n\t\t\t\tpes->temi_tc.pes_pts = pes->PTS;\n\t\t\t\tif (ts->on_event)\n\t\t\t\t\tts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc);\n\t\t\t}\n\n\t\t\tif (! ts->seek_mode)\n\t\t\t\tremain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh);\n\n\t\t\t//CLEANUP alloc stuff\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tif (remain) {\n\t\t\t\tpes->prev_data = gf_malloc(sizeof(char)*remain);\n\t\t\t\tassert(pes->pck_data_len >= remain);\n\t\t\t\tmemcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain);\n\t\t\t\tpes->prev_data_len = remain;\n\t\t\t}\n\t\t}\n\t} else if (pes->pck_data_len) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\\n\", pes->pid));\n\t}\n\tpes->pck_data_len = 0;\n\tpes->pes_len = 0;\n\tpes->rap = 0;\n}\n\nstatic void gf_m2ts_process_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, GF_M2TS_Header *hdr, unsigned char *data, u32 data_size, GF_M2TS_AdaptationField *paf)\n{\n\tu8 expect_cc;\n\tBool disc=0;\n\tBool flush_pes = 0;\n\n\t/*duplicated packet, NOT A DISCONTINUITY, we should discard the packet - however we may encounter this configuration in DASH at segment boundaries.\n\tIf payload start is set, ignore duplication*/\n\tif (hdr->continuity_counter==pes->cc) {\n\t\tif (!hdr->payload_start || (hdr->adaptation_field!=3) ) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Duplicated Packet found (CC %d) - skipping\\n\", pes->pid, pes->cc));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\texpect_cc = (pes->cc<0) ? hdr->continuity_counter : (pes->cc + 1) & 0xf;\n\t\tif (expect_cc != hdr->continuity_counter)\n\t\t\tdisc = 1;\n\t}\n\tpes->cc = hdr->continuity_counter;\n\n\tif (disc) {\n\t\tif (pes->flags & GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY) {\n\t\t\tpes->flags &= ~GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY;\n\t\t\tdisc = 0;\n\t\t}\n\t\tif (disc) {\n\t\t\tif (hdr->payload_start) {\n\t\t\t\tif (pes->pck_data_len) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Packet discontinuity (%d expected - got %d) - may have lost end of previous PES\\n\", pes->pid, expect_cc, hdr->continuity_counter));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pes->pck_data_len) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PES %d: Packet discontinuity (%d expected - got %d) - trashing PES packet\\n\", pes->pid, expect_cc, hdr->continuity_counter));\n\t\t\t\t}\n\t\t\t\tpes->pck_data_len = 0;\n\t\t\t\tpes->pes_len = 0;\n\t\t\t\tpes->cc = -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!pes->reframe) return;\n\n\tif (hdr->payload_start) {\n\t\tflush_pes = 1;\n\t\tpes->pes_start_packet_number = ts->pck_number;\n\t\tpes->before_last_pcr_value = pes->program->before_last_pcr_value;\n\t\tpes->before_last_pcr_value_pck_number = pes->program->before_last_pcr_value_pck_number;\n\t\tpes->last_pcr_value = pes->program->last_pcr_value;\n\t\tpes->last_pcr_value_pck_number = pes->program->last_pcr_value_pck_number;\n\t} else if (pes->pes_len && (pes->pck_data_len + data_size == pes->pes_len + 6)) {\n\t\t/* 6 = startcode+stream_id+length*/\n\t\t/*reassemble pes*/\n\t\tif (pes->pck_data_len + data_size > pes->pck_alloc_len) {\n\t\t\tpes->pck_alloc_len = pes->pck_data_len + data_size;\n\t\t\tpes->pck_data = (u8*)gf_realloc(pes->pck_data, pes->pck_alloc_len);\n\t\t}\n\t\tmemcpy(pes->pck_data+pes->pck_data_len, data, data_size);\n\t\tpes->pck_data_len += data_size;\n\t\t/*force discard*/\n\t\tdata_size = 0;\n\t\tflush_pes = 1;\n\t}\n\n\t/*PES first fragment: flush previous packet*/\n\tif (flush_pes && pes->pck_data_len) {\n\t\tgf_m2ts_flush_pes(ts, pes);\n\t\tif (!data_size) return;\n\t}\n\t/*we need to wait for first packet of PES*/\n\tif (!pes->pck_data_len && !hdr->payload_start) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Waiting for PES header, trashing data\\n\", hdr->pid));\n\t\treturn;\n\t}\n\t/*reassemble*/\n\tif (pes->pck_data_len + data_size > pes->pck_alloc_len ) {\n\t\tpes->pck_alloc_len = pes->pck_data_len + data_size;\n\t\tpes->pck_data = (u8*)gf_realloc(pes->pck_data, pes->pck_alloc_len);\n\t}\n\tmemcpy(pes->pck_data + pes->pck_data_len, data, data_size);\n\tpes->pck_data_len += data_size;\n\n\tif (paf && paf->random_access_indicator) pes->rap = 1;\n\tif (hdr->payload_start && !pes->pes_len && (pes->pck_data_len>=6)) {\n\t\tpes->pes_len = (pes->pck_data[4]<<8) | pes->pck_data[5];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Got PES packet len %d\\n\", pes->pid, pes->pes_len));\n\n\t\tif (pes->pes_len + 6 == pes->pck_data_len) {\n\t\t\tgf_m2ts_flush_pes(ts, pes);\n\t\t}\n\t}\n}\n\n\nstatic void gf_m2ts_get_adaptation_field(GF_M2TS_Demuxer *ts, GF_M2TS_AdaptationField *paf, unsigned char *data, u32 size, u32 pid)\n{\n\tunsigned char *af_extension;\n\tpaf->discontinuity_indicator = (data[0] & 0x80) ? 1 : 0;\n\tpaf->random_access_indicator = (data[0] & 0x40) ? 1 : 0;\n\tpaf->priority_indicator = (data[0] & 0x20) ? 1 : 0;\n\tpaf->PCR_flag = (data[0] & 0x10) ? 1 : 0;\n\tpaf->OPCR_flag = (data[0] & 0x8) ? 1 : 0;\n\tpaf->splicing_point_flag = (data[0] & 0x4) ? 1 : 0;\n\tpaf->transport_private_data_flag = (data[0] & 0x2) ? 1 : 0;\n\tpaf->adaptation_field_extension_flag = (data[0] & 0x1) ? 1 : 0;\n\n\taf_extension = data + 1;\n\tif (paf->PCR_flag == 1) {\n\t\tu32 base = ((u32)data[1] << 24) | ((u32)data[2] << 16) | ((u32)data[3] << 8) | (u32)data[4];\n\t\tu64 PCR = (u64) base;\n\t\tpaf->PCR_base = (PCR << 1) | (data[5] >> 7);\n\t\tpaf->PCR_ext = ((data[5] & 1) << 8) | data[6];\n\t\taf_extension += 6;\n\t}\n\n\tif (paf->adaptation_field_extension_flag) {\n\t\tu32 afext_bytes;\n\t\tBool ltw_flag, pwr_flag, seamless_flag, af_desc_not_present;\n\t\tif (paf->OPCR_flag) {\n\t\t\taf_extension += 6;\n\t\t}\n\t\tif (paf->splicing_point_flag) {\n\t\t\taf_extension += 1;\n\t\t}\n\t\tif (paf->transport_private_data_flag) {\n\t\t\tu32 priv_bytes = af_extension[0];\n\t\t\taf_extension += 1 + priv_bytes;\n\t\t}\n\n\t\tafext_bytes = af_extension[0];\n\t\tltw_flag = af_extension[1] & 0x80 ? 1 : 0;\n\t\tpwr_flag = af_extension[1] & 0x40 ? 1 : 0;\n\t\tseamless_flag = af_extension[1] & 0x20 ? 1 : 0;\n\t\taf_desc_not_present = af_extension[1] & 0x10 ? 1 : 0;\n\t\taf_extension += 2;\n\t\tif (!afext_bytes) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\treturn;\n\t\t}\n\t\tafext_bytes-=1;\n\t\tif (ltw_flag) {\n\t\t\taf_extension += 2;\n\t\t\tif (afext_bytes<2) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=2;\n\t\t}\n\t\tif (pwr_flag) {\n\t\t\taf_extension += 3;\n\t\t\tif (afext_bytes<3) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=3;\n\t\t}\n\t\tif (seamless_flag) {\n\t\t\taf_extension += 3;\n\t\t\tif (afext_bytes<3) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Extension found\\n\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tafext_bytes-=3;\n\t\t}\n\n\t\tif (! af_desc_not_present) {\n\t\t\twhile (afext_bytes) {\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tchar *desc;\n\t\t\t\tu8 desc_tag = af_extension[0];\n\t\t\t\tu8 desc_len = af_extension[1];\n\t\t\t\tif (!desc_len || (u32) desc_len+2 > afext_bytes) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Bad Adaptation Descriptor found (tag %d) size is %d but only %d bytes available\\n\", pid, desc_tag, desc_len, afext_bytes));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdesc = (char *) af_extension+2;\n\n\t\t\t\tbs = gf_bs_new(desc, desc_len, GF_BITSTREAM_READ);\n\t\t\t\tswitch (desc_tag) {\n\t\t\t\tcase GF_M2TS_AFDESC_LOCATION_DESCRIPTOR:\n\t\t\t\t{\n\t\t\t\t\tBool use_base_temi_url;\n\t\t\t\t\tchar URL[255];\n\t\t\t\t\tGF_M2TS_TemiLocationDescriptor temi_loc;\n\t\t\t\t\tmemset(&temi_loc, 0, sizeof(GF_M2TS_TemiLocationDescriptor) );\n\t\t\t\t\ttemi_loc.reload_external = gf_bs_read_int(bs, 1);\n\t\t\t\t\ttemi_loc.is_announce = gf_bs_read_int(bs, 1);\n\t\t\t\t\ttemi_loc.is_splicing = gf_bs_read_int(bs, 1);\n\t\t\t\t\tuse_base_temi_url = gf_bs_read_int(bs, 1);\n\t\t\t\t\tgf_bs_read_int(bs, 5); //reserved\n\t\t\t\t\ttemi_loc.timeline_id = gf_bs_read_int(bs, 7);\n\t\t\t\t\tif (!use_base_temi_url) {\n\t\t\t\t\t\tchar *_url = URL;\n\t\t\t\t\t\tu8 scheme = gf_bs_read_int(bs, 8);\n\t\t\t\t\t\tu8 url_len = gf_bs_read_int(bs, 8);\n\t\t\t\t\t\tswitch (scheme) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tstrcpy(URL, \"http://\");\n\t\t\t\t\t\t\t_url = URL+7;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tstrcpy(URL, \"https://\");\n\t\t\t\t\t\t\t_url = URL+8;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_bs_read_data(bs, _url, url_len);\n\t\t\t\t\t\t_url[url_len] = 0;\n\t\t\t\t\t}\n\t\t\t\t\ttemi_loc.external_URL = URL;\n\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d AF Location descriptor found - URL %s\\n\", pid, URL));\n\t\t\t\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TEMI_LOCATION, &temi_loc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase GF_M2TS_AFDESC_TIMELINE_DESCRIPTOR:\n\t\t\t\t\tif (ts->ess[pid] && (ts->ess[pid]->flags & GF_M2TS_ES_IS_PES)) {\n\t\t\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *) ts->ess[pid];\n\n\t\t\t\t\t\tif (pes->temi_tc_desc_len)\n\t\t\t\t\t\t\tgf_m2ts_store_temi(ts, pes);\n\n\t\t\t\t\t\tif (pes->temi_tc_desc_alloc_size < desc_len) {\n\t\t\t\t\t\t\tpes->temi_tc_desc = gf_realloc(pes->temi_tc_desc, desc_len);\n\t\t\t\t\t\t\tpes->temi_tc_desc_alloc_size = desc_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmemcpy(pes->temi_tc_desc, desc, desc_len);\n\t\t\t\t\t\tpes->temi_tc_desc_len = desc_len;\n\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d AF Timeline descriptor found\\n\", pid));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\taf_extension += 2+desc_len;\n\t\t\t\tafext_bytes -= 2+desc_len;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d: Adaptation Field found: Discontinuity %d - RAP %d - PCR: \"LLD\"\\n\", pid, paf->discontinuity_indicator, paf->random_access_indicator, paf->PCR_flag ? paf->PCR_base * 300 + paf->PCR_ext : 0));\n}\n\nstatic GF_Err gf_m2ts_process_packet(GF_M2TS_Demuxer *ts, unsigned char *data)\n{\n\tGF_M2TS_ES *es;\n\tGF_M2TS_Header hdr;\n\tGF_M2TS_AdaptationField af, *paf;\n\tu32 payload_size, af_size;\n\tu32 pos = 0;\n\n\tts->pck_number++;\n\n\t/* read TS packet header*/\n\thdr.sync = data[0];\n\tif (hdr.sync != 0x47) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d does not start with sync marker\\n\", ts->pck_number));\n\t\treturn GF_CORRUPTED_DATA;\n\t}\n\thdr.error = (data[1] & 0x80) ? 1 : 0;\n\thdr.payload_start = (data[1] & 0x40) ? 1 : 0;\n\thdr.priority = (data[1] & 0x20) ? 1 : 0;\n\thdr.pid = ( (data[1]&0x1f) << 8) | data[2];\n\thdr.scrambling_ctrl = (data[3] >> 6) & 0x3;\n\thdr.adaptation_field = (data[3] >> 4) & 0x3;\n\thdr.continuity_counter = data[3] & 0xf;\n\n\tif (hdr.error) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d has error (PID could be %d)\\n\", ts->pck_number, hdr.pid));\n\t\treturn GF_CORRUPTED_DATA;\n\t}\n//#if DEBUG_TS_PACKET\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d PID %d CC %d Encrypted %d\\n\", ts->pck_number, hdr.pid, hdr.continuity_counter, hdr.scrambling_ctrl));\n//#endif\n\n\tif (hdr.scrambling_ctrl) {\n\t\t//TODO add decyphering\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d is scrambled - not supported\\n\", ts->pck_number, hdr.pid));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tpaf = NULL;\n\tpayload_size = 184;\n\tpos = 4;\n\tswitch (hdr.adaptation_field) {\n\t/*adaptation+data*/\n\tcase 3:\n\t\taf_size = data[4];\n\t\tif (af_size>183) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d AF field larger than 183 !\\n\", ts->pck_number));\n\t\t\t//error\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tpaf = &af;\n\t\tmemset(paf, 0, sizeof(GF_M2TS_AdaptationField));\n\t\t//this will stop you when processing invalid (yet existing) mpeg2ts streams in debug\n\t\tassert( af_size<=183);\n\t\tif (af_size>183)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d Detected wrong adaption field size %u when control value is 3\\n\", ts->pck_number, af_size));\n\t\tif (af_size) gf_m2ts_get_adaptation_field(ts, paf, data+5, af_size, hdr.pid);\n\t\tpos += 1+af_size;\n\t\tpayload_size = 183 - af_size;\n\t\tbreak;\n\t/*adaptation only - still process in case of PCR*/\n\tcase 2:\n\t\taf_size = data[4];\n\t\tif (af_size != 183) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] TS Packet %d AF size is %d when it must be 183 for AF type 2\\n\", ts->pck_number, af_size));\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\tpaf = &af;\n\t\tmemset(paf, 0, sizeof(GF_M2TS_AdaptationField));\n\t\tgf_m2ts_get_adaptation_field(ts, paf, data+5, af_size, hdr.pid);\n\t\tpayload_size = 0;\n\t\t/*no payload and no PCR, return*/\n\t\tif (!paf->PCR_flag)\n\t\t\treturn GF_OK;\n\t\tbreak;\n\t/*reserved*/\n\tcase 0:\n\t\treturn GF_OK;\n\tdefault:\n\t\tbreak;\n\t}\n\tdata += pos;\n\n\t/*PAT*/\n\tif (hdr.pid == GF_M2TS_PID_PAT) {\n\t\tgf_m2ts_gather_section(ts, ts->pat, NULL, &hdr, data, payload_size);\n\t\treturn GF_OK;\n\t} else if (hdr.pid == GF_M2TS_PID_CAT) {\n\t\tgf_m2ts_gather_section(ts, ts->cat, NULL, &hdr, data, payload_size);\n\t\treturn GF_OK;\n\t}\n\n\tes = ts->ess[hdr.pid];\n\tif (paf && paf->PCR_flag) {\n\t\tif (!es) {\n\t\t\tu32 i, j;\n\t\t\tfor(i=0; i<gf_list_count(ts->programs); i++) {\n\t\t\t\tGF_M2TS_PES *first_pes = NULL;\n\t\t\t\tGF_M2TS_Program *program = (GF_M2TS_Program *)gf_list_get(ts->programs,i);\n\t\t\t\tif(program->pcr_pid != hdr.pid) continue;\n\t\t\t\tfor (j=0; j<gf_list_count(program->streams); j++) {\n\t\t\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *) gf_list_get(program->streams, j);\n\t\t\t\t\tif (pes->flags & GF_M2TS_INHERIT_PCR) {\n\t\t\t\t\t\tts->ess[hdr.pid] = (GF_M2TS_ES *) pes;\n\t\t\t\t\t\tpes->flags |= GF_M2TS_FAKE_PCR;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (pes->flags & GF_M2TS_ES_IS_PES) {\n\t\t\t\t\t\tfirst_pes = pes;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//non found, use the first media stream as a PCR destination - Q: is it legal to have PCR only streams not declared in PMT ?\n\t\t\t\tif (!es && first_pes) {\n\t\t\t\t\tes = (GF_M2TS_ES *) first_pes;\n\t\t\t\t\tfirst_pes->flags |= GF_M2TS_FAKE_PCR;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!es)\n\t\t\t\tes = ts->ess[hdr.pid];\n\t\t}\n\t\tif (es) {\n\t\t\tGF_M2TS_PES_PCK pck;\n\t\t\ts64 prev_diff_in_us;\n\t\t\tBool discontinuity;\n\t\t\ts32 cc = -1;\n\n\t\t\tif (es->flags & GF_M2TS_FAKE_PCR) {\n\t\t\t\tcc = es->program->pcr_cc;\n\t\t\t\tes->program->pcr_cc = hdr.continuity_counter;\n\t\t\t}\n\t\t\telse if (es->flags & GF_M2TS_ES_IS_PES) cc = ((GF_M2TS_PES*)es)->cc;\n\t\t\telse if (((GF_M2TS_SECTION_ES*)es)->sec) cc = ((GF_M2TS_SECTION_ES*)es)->sec->cc;\n\n\t\t\tdiscontinuity = paf->discontinuity_indicator;\n\t\t\tif ((cc>=0) && es->program->before_last_pcr_value) {\n\t\t\t\t//no increment of CC if AF only packet\n\t\t\t\tif (hdr.adaptation_field == 2) {\n\t\t\t\t\tif (hdr.continuity_counter != cc) {\n\t\t\t\t\t\tdiscontinuity = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else if (hdr.continuity_counter != ((cc + 1) & 0xF)) {\n\t\t\t\t\tdiscontinuity = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(&pck, 0, sizeof(GF_M2TS_PES_PCK));\n\t\t\tprev_diff_in_us = (s64) (es->program->last_pcr_value /27- es->program->before_last_pcr_value/27);\n\t\t\tes->program->before_last_pcr_value = es->program->last_pcr_value;\n\t\t\tes->program->before_last_pcr_value_pck_number = es->program->last_pcr_value_pck_number;\n\t\t\tes->program->last_pcr_value_pck_number = ts->pck_number;\n\t\t\tes->program->last_pcr_value = paf->PCR_base * 300 + paf->PCR_ext;\n\t\t\tif (!es->program->last_pcr_value) es->program->last_pcr_value =  1;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR found \"LLU\" (\"LLU\" at 90kHz) - PCR diff is %d us\\n\", hdr.pid, es->program->last_pcr_value, es->program->last_pcr_value/300, (s32) (es->program->last_pcr_value - es->program->before_last_pcr_value)/27 ));\n\n\t\t\tpck.PTS = es->program->last_pcr_value;\n\t\t\tpck.stream = (GF_M2TS_PES *)es;\n\n\t\t\t//try to ignore all discontinuities that are less than 200 ms (seen in some HLS setup ...)\n\t\t\tif (discontinuity) {\n\t\t\t\ts64 diff_in_us = (s64) (es->program->last_pcr_value - es->program->before_last_pcr_value) / 27;\n\t\t\t\tu64 diff = ABS(diff_in_us - prev_diff_in_us);\n\n\t\t\t\tif ((diff_in_us<0) && (diff_in_us >= -200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d new PCR, with discontinuity signaled, is less than previously received PCR (diff %d us) but not too large, trying to ignore discontinuity\\n\", hdr.pid, diff_in_us));\n\t\t\t\t}\n\n\t\t\t\t//ignore PCR discontinuity indicator if PCR found is larger than previously received PCR and diffence between PCR before and after discontinuity indicator is smaller than 50ms\n\t\t\t\telse if ((diff_in_us > 0) && (diff < 200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity signaled but diff is small (diff %d us - PCR diff %d vs prev PCR diff %d) - ignore it\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t} else if (paf->discontinuity_indicator) {\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity signaled (diff %d us - PCR diff %d vs prev PCR diff %d)\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR discontinuity not signaled (diff %d us - PCR diff %d vs prev PCR diff %d)\\n\", hdr.pid, diff, diff_in_us, prev_diff_in_us));\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( (es->program->last_pcr_value < es->program->before_last_pcr_value) ) {\n\t\t\t\ts64 diff_in_us = (s64) (es->program->last_pcr_value - es->program->before_last_pcr_value) / 27;\n\t\t\t\t//if less than 200 ms before PCR loop at the last PCR, this is a PCR loop\n\t\t\t\tif (GF_M2TS_MAX_PCR - es->program->before_last_pcr_value < 5400000 /*2*2700000*/) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR loop found from \"LLU\" to \"LLU\" \\n\", hdr.pid, es->program->before_last_pcr_value, es->program->last_pcr_value));\n\t\t\t\t} else if ((diff_in_us<0) && (diff_in_us >= -200000)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d new PCR, without discontinuity signaled, is less than previously received PCR (diff %d us) but not too large, trying to ignore discontinuity\\n\", hdr.pid, diff_in_us));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MPEG-2 TS] PID %d PCR found \"LLU\" is less than previously received PCR \"LLU\" (PCR diff %g sec) but no discontinuity signaled\\n\", hdr.pid, es->program->last_pcr_value, es->program->before_last_pcr_value, (GF_M2TS_MAX_PCR - es->program->before_last_pcr_value + es->program->last_pcr_value) / 27000000.0));\n\n\t\t\t\t\tpck.flags = GF_M2TS_PES_PCK_DISCONTINUITY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pck.flags & GF_M2TS_PES_PCK_DISCONTINUITY) {\n\t\t\t\tgf_m2ts_reset_parsers_for_program(ts, es->program);\n\t\t\t}\n\n\t\t\tif (ts->on_event) {\n\t\t\t\tts->on_event(ts, GF_M2TS_EVT_PES_PCR, &pck);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*check for DVB reserved PIDs*/\n\tif (!es) {\n\t\tif (hdr.pid == GF_M2TS_PID_SDT_BAT_ST) {\n\t\t\tgf_m2ts_gather_section(ts, ts->sdt, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_NIT_ST) {\n\t\t\t/*ignore them, unused at application level*/\n\t\t\tgf_m2ts_gather_section(ts, ts->nit, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_EIT_ST_CIT) {\n\t\t\t/* ignore EIT messages for the moment */\n\t\t\tgf_m2ts_gather_section(ts, ts->eit, NULL, &hdr, data, payload_size);\n\t\t\treturn GF_OK;\n\t\t} else if (hdr.pid == GF_M2TS_PID_TDT_TOT_ST) {\n\t\t\tgf_m2ts_gather_section(ts, ts->tdt_tot, NULL, &hdr, data, payload_size);\n\t\t} else {\n\t\t\t/* ignore packet */\n\t\t}\n\t} else if (es->flags & GF_M2TS_ES_IS_SECTION) { \t/* The stream uses sections to carry its payload */\n\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\tif (ses->sec) gf_m2ts_gather_section(ts, ses->sec, ses, &hdr, data, payload_size);\n\t} else {\n\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t/* regular stream using PES packets */\n\t\tif (pes->reframe && payload_size) gf_m2ts_process_pes(ts, pes, &hdr, data, payload_size, paf);\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_m2ts_process_data(GF_M2TS_Demuxer *ts, u8 *data, u32 data_size)\n{\n\tGF_Err e=GF_OK;\n\tu32 pos, pck_size;\n\tBool is_align = 1;\n\n\tif (ts->buffer_size) {\n\t\t//we are sync, copy remaining bytes\n\t\tif ( (ts->buffer[0]==0x47) && (ts->buffer_size<200)) {\n\t\t\tu32 pck_size = ts->prefix_present ? 192 : 188;\n\n\t\t\tif (ts->alloc_size < 200) {\n\t\t\t\tts->alloc_size = 200;\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ts->buffer + ts->buffer_size, data, pck_size - ts->buffer_size);\n\t\t\te |= gf_m2ts_process_packet(ts, (unsigned char *)ts->buffer);\n\t\t\tdata += (pck_size - ts->buffer_size);\n\t\t\tdata_size = data_size - (pck_size - ts->buffer_size);\n\t\t}\n\t\t//not sync, copy over the complete buffer\n\t\telse {\n\t\t\tif (ts->alloc_size < ts->buffer_size+data_size) {\n\t\t\t\tts->alloc_size = ts->buffer_size+data_size;\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ts->buffer + ts->buffer_size, data, sizeof(char)*data_size);\n\t\t\tts->buffer_size += data_size;\n\t\t\tis_align = 0;\n\t\t\tdata = ts->buffer;\n\t\t\tdata_size = ts->buffer_size;\n\t\t}\n\t}\n\n\t/*sync input data*/\n\tpos = gf_m2ts_sync(ts, data, data_size, is_align);\n\tif (pos==data_size) {\n\t\tif (is_align) {\n\t\t\tif (ts->alloc_size<data_size) {\n\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*data_size);\n\t\t\t\tts->alloc_size = data_size;\n\t\t\t}\n\t\t\tmemcpy(ts->buffer, data, sizeof(char)*data_size);\n\t\t\tts->buffer_size = data_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tpck_size = ts->prefix_present ? 192 : 188;\n\tfor (;;) {\n\t\t/*wait for a complete packet*/\n\t\tif (data_size < pos  + pck_size) {\n\t\t\tts->buffer_size = data_size - pos;\n\t\t\tdata += pos;\n\t\t\tif (!ts->buffer_size) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tassert(ts->buffer_size<pck_size);\n\n\t\t\tif (is_align) {\n\t\t\t\tu32 s = ts->buffer_size;\n\t\t\t\tif (s<200) s = 200;\n\n\t\t\t\tif (ts->alloc_size < s) {\n\t\t\t\t\tts->alloc_size = s;\n\t\t\t\t\tts->buffer = (char*)gf_realloc(ts->buffer, sizeof(char)*ts->alloc_size);\n\t\t\t\t}\n\t\t\t\tmemcpy(ts->buffer, data, sizeof(char)*ts->buffer_size);\n\t\t\t} else {\n\t\t\t\tmemmove(ts->buffer, data, sizeof(char)*ts->buffer_size);\n\t\t\t}\n\t\t\treturn e;\n\t\t}\n\t\t/*process*/\n\t\te |= gf_m2ts_process_packet(ts, (unsigned char *)data + pos);\n\t\tpos += pck_size;\n\t}\n\treturn e;\n}\n\n//unused\n#if 0\nGF_ESD *gf_m2ts_get_esd(GF_M2TS_ES *es)\n{\n\tGF_ESD *esd;\n\tu32 k, esd_count;\n\n\tesd = NULL;\n\tif (es->program->pmt_iod && es->program->pmt_iod->ESDescriptors) {\n\t\tesd_count = gf_list_count(es->program->pmt_iod->ESDescriptors);\n\t\tfor (k = 0; k < esd_count; k++) {\n\t\t\tGF_ESD *esd_tmp = (GF_ESD *)gf_list_get(es->program->pmt_iod->ESDescriptors, k);\n\t\t\tif (esd_tmp->ESID != es->mpeg4_es_id) continue;\n\t\t\tesd = esd_tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!esd && es->program->additional_ods) {\n\t\tu32 od_count, od_index;\n\t\tod_count = gf_list_count(es->program->additional_ods);\n\t\tfor (od_index = 0; od_index < od_count; od_index++) {\n\t\t\tGF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(es->program->additional_ods, od_index);\n\t\t\tesd_count = gf_list_count(od->ESDescriptors);\n\t\t\tfor (k = 0; k < esd_count; k++) {\n\t\t\t\tGF_ESD *esd_tmp = (GF_ESD *)gf_list_get(od->ESDescriptors, k);\n\t\t\t\tif (esd_tmp->ESID != es->mpeg4_es_id) continue;\n\t\t\t\tesd = esd_tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn esd;\n}\nvoid gf_m2ts_set_segment_switch(GF_M2TS_Demuxer *ts)\n{\n\tu32 i;\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *) ts->ess[i];\n\t\tif (!es) continue;\n\t\tes->flags |= GF_M2TS_ES_IGNORE_NEXT_DISCONTINUITY;\n\t}\n}\n\n\n#endif\n\n\nGF_EXPORT\nvoid gf_m2ts_reset_parsers_for_program(GF_M2TS_Demuxer *ts, GF_M2TS_Program *prog)\n{\n\tu32 i;\n\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\tGF_M2TS_ES *es = (GF_M2TS_ES *) ts->ess[i];\n\t\tif (!es) continue;\n\t\tif (prog && (es->program != prog) ) continue;\n\n\t\tif (es->flags & GF_M2TS_ES_IS_SECTION) {\n\t\t\tGF_M2TS_SECTION_ES *ses = (GF_M2TS_SECTION_ES *)es;\n\t\t\tgf_m2ts_section_filter_reset(ses->sec);\n\t\t} else {\n\t\t\tGF_M2TS_PES *pes = (GF_M2TS_PES *)es;\n\t\t\tif (!pes || (pes->pid==pes->program->pmt_pid)) continue;\n\t\t\tpes->cc = -1;\n\t\t\tpes->frame_state = 0;\n\t\t\tpes->pck_data_len = 0;\n\t\t\tif (pes->prev_data) gf_free(pes->prev_data);\n\t\t\tpes->prev_data = NULL;\n\t\t\tpes->prev_data_len = 0;\n\t\t\tpes->PTS = pes->DTS = 0;\n//\t\t\tpes->prev_PTS = 0;\n//\t\t\tpes->first_dts = 0;\n\t\t\tpes->pes_len = pes->pes_end_packet_number = pes->pes_start_packet_number = 0;\n\t\t\tif (pes->buf) gf_free(pes->buf);\n\t\t\tpes->buf = NULL;\n\t\t\tif (pes->temi_tc_desc) gf_free(pes->temi_tc_desc);\n\t\t\tpes->temi_tc_desc = NULL;\n\t\t\tpes->temi_tc_desc_len = pes->temi_tc_desc_alloc_size = 0;\n\n\t\t\tpes->before_last_pcr_value = pes->before_last_pcr_value_pck_number = 0;\n\t\t\tpes->last_pcr_value = pes->last_pcr_value_pck_number = 0;\n\t\t\tif (pes->program->pcr_pid==pes->pid) {\n\t\t\t\tpes->program->last_pcr_value = pes->program->last_pcr_value_pck_number = 0;\n\t\t\t\tpes->program->before_last_pcr_value = pes->program->before_last_pcr_value_pck_number = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_EXPORT\nvoid gf_m2ts_reset_parsers(GF_M2TS_Demuxer *ts)\n{\n\tgf_m2ts_reset_parsers_for_program(ts, NULL);\n\n\tts->pck_number = 0;\n\n\tgf_m2ts_section_filter_reset(ts->cat);\n\tgf_m2ts_section_filter_reset(ts->pat);\n\tgf_m2ts_section_filter_reset(ts->sdt);\n\tgf_m2ts_section_filter_reset(ts->nit);\n\tgf_m2ts_section_filter_reset(ts->eit);\n\tgf_m2ts_section_filter_reset(ts->tdt_tot);\n\n}\n\n\n#if 0 //unused\nu32 gf_m2ts_pes_get_framing_mode(GF_M2TS_PES *pes)\n{\n\tif (pes->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tif (pes->flags & GF_M2TS_ES_IS_SL) {\n\t\t\tif ( ((GF_M2TS_SECTION_ES *)pes)->sec->process_section == NULL)\n\t\t\t\treturn GF_M2TS_PES_FRAMING_DEFAULT;\n\n\t\t}\n\t\treturn GF_M2TS_PES_FRAMING_SKIP_NO_RESET;\n\t}\n\n\tif (!pes->reframe ) return GF_M2TS_PES_FRAMING_SKIP_NO_RESET;\n\tif (pes->reframe == gf_m2ts_reframe_default) return GF_M2TS_PES_FRAMING_RAW;\n\tif (pes->reframe == gf_m2ts_reframe_reset) return GF_M2TS_PES_FRAMING_SKIP;\n\treturn GF_M2TS_PES_FRAMING_DEFAULT;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_m2ts_set_pes_framing(GF_M2TS_PES *pes, u32 mode)\n{\n\tif (!pes) return GF_BAD_PARAM;\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Setting pes framing mode of PID %d to %d\\n\", pes->pid, mode) );\n\t/*ignore request for section PIDs*/\n\tif (pes->flags & GF_M2TS_ES_IS_SECTION) {\n\t\tif (pes->flags & GF_M2TS_ES_IS_SL) {\n\t\t\tif (mode==GF_M2TS_PES_FRAMING_DEFAULT) {\n\t\t\t\t((GF_M2TS_SECTION_ES *)pes)->sec->process_section = gf_m2ts_process_mpeg4section;\n\t\t\t} else {\n\t\t\t\t((GF_M2TS_SECTION_ES *)pes)->sec->process_section = NULL;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (pes->pid==pes->program->pmt_pid) return GF_BAD_PARAM;\n\n\t//if component reuse, disable previous pes\n\tif ((mode > GF_M2TS_PES_FRAMING_SKIP) && (pes->program->ts->ess[pes->pid] != (GF_M2TS_ES *) pes)) {\n\t\tGF_M2TS_PES *o_pes = (GF_M2TS_PES *) pes->program->ts->ess[pes->pid];\n\t\tif (o_pes->flags & GF_M2TS_ES_IS_PES)\n\t\t\tgf_m2ts_set_pes_framing(o_pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MPEG-2 TS] Reassinging PID %d from program %d to program %d\\n\", pes->pid, o_pes->program->number, pes->program->number) );\n\t\tpes->program->ts->ess[pes->pid] = (GF_M2TS_ES *) pes;\n\t}\n\n\tswitch (mode) {\n\tcase GF_M2TS_PES_FRAMING_RAW:\n\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_SKIP:\n\t\tpes->reframe = gf_m2ts_reframe_reset;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_SKIP_NO_RESET:\n\t\tpes->reframe = NULL;\n\t\tbreak;\n\tcase GF_M2TS_PES_FRAMING_DEFAULT:\n\tdefault:\n\t\tswitch (pes->stream_type) {\n\t\tcase GF_M2TS_VIDEO_MPEG1:\n\t\tcase GF_M2TS_VIDEO_MPEG2:\n\t\tcase GF_M2TS_VIDEO_H264:\n\t\tcase GF_M2TS_VIDEO_SVC:\n\t\tcase GF_M2TS_VIDEO_HEVC:\n\t\tcase GF_M2TS_VIDEO_HEVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_HEVC_MCTS:\n\t\tcase GF_M2TS_VIDEO_SHVC:\n\t\tcase GF_M2TS_VIDEO_SHVC_TEMPORAL:\n\t\tcase GF_M2TS_VIDEO_MHVC:\n\t\tcase GF_M2TS_VIDEO_MHVC_TEMPORAL:\n\t\tcase GF_M2TS_AUDIO_MPEG1:\n\t\tcase GF_M2TS_AUDIO_MPEG2:\n\t\tcase GF_M2TS_AUDIO_AAC:\n\t\tcase GF_M2TS_AUDIO_LATM_AAC:\n\t\tcase GF_M2TS_AUDIO_AC3:\n\t\tcase GF_M2TS_AUDIO_EC3:\n\t\t\t//for all our supported codec types, use a reframer filter\n\t\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\t\tbreak;\n\n\t\tcase GF_M2TS_PRIVATE_DATA:\n\t\t\t/* TODO: handle DVB subtitle streams */\n\t\t\tbreak;\n\t\tcase GF_M2TS_METADATA_ID3_HLS:\n\t\t\t//TODO\n\t\t\tpes->reframe = gf_m2ts_reframe_id3_pes;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpes->reframe = gf_m2ts_reframe_default;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_M2TS_Demuxer *gf_m2ts_demux_new()\n{\n\tGF_M2TS_Demuxer *ts;\n\n\tGF_SAFEALLOC(ts, GF_M2TS_Demuxer);\n\tif (!ts) return NULL;\n\tts->programs = gf_list_new();\n\tts->SDTs = gf_list_new();\n\n\tts->pat = gf_m2ts_section_filter_new(gf_m2ts_process_pat, 0);\n\tts->cat = gf_m2ts_section_filter_new(gf_m2ts_process_cat, 0);\n\tts->sdt = gf_m2ts_section_filter_new(gf_m2ts_process_sdt, 1);\n\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\tts->eit = gf_m2ts_section_filter_new(NULL/*gf_m2ts_process_eit*/, 1);\n\tts->tdt_tot = gf_m2ts_section_filter_new(gf_m2ts_process_tdt_tot, 1);\n\n#ifdef GPAC_ENABLE_MPE\n\tgf_dvb_mpe_init(ts);\n#endif\n\n\tts->nb_prog_pmt_received = 0;\n\tts->ChannelAppList = gf_list_new();\n\treturn ts;\n}\n\nGF_EXPORT\nvoid gf_m2ts_demux_dmscc_init(GF_M2TS_Demuxer *ts) {\n\n\tchar temp_dir[GF_MAX_PATH];\n\tu32 length;\n\tGF_Err e;\n\n\tts->dsmcc_controler = gf_list_new();\n\tts->process_dmscc = 1;\n\n\tstrcpy(temp_dir, gf_get_default_cache_directory() );\n\tlength = (u32) strlen(temp_dir);\n\tif(temp_dir[length-1] == GF_PATH_SEPARATOR) {\n\t\ttemp_dir[length-1] = 0;\n\t}\n\n\tts->dsmcc_root_dir = (char*)gf_calloc(strlen(temp_dir)+strlen(\"CarouselData\")+2,sizeof(char));\n\tsprintf(ts->dsmcc_root_dir,\"%s%cCarouselData\",temp_dir,GF_PATH_SEPARATOR);\n\te = gf_mkdir(ts->dsmcc_root_dir);\n\tif(e) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[Process DSMCC] Error during the creation of the directory %s \\n\",ts->dsmcc_root_dir));\n\t}\n\n}\n\nGF_EXPORT\nvoid gf_m2ts_demux_del(GF_M2TS_Demuxer *ts)\n{\n\tu32 i;\n\tif (ts->pat) gf_m2ts_section_filter_del(ts->pat);\n\tif (ts->cat) gf_m2ts_section_filter_del(ts->cat);\n\tif (ts->sdt) gf_m2ts_section_filter_del(ts->sdt);\n\tif (ts->nit) gf_m2ts_section_filter_del(ts->nit);\n\tif (ts->eit) gf_m2ts_section_filter_del(ts->eit);\n\tif (ts->tdt_tot) gf_m2ts_section_filter_del(ts->tdt_tot);\n\n\tfor (i=0; i<GF_M2TS_MAX_STREAMS; i++) {\n\t\t//bacause of pure PCR streams, en ES might be reassigned on 2 PIDs, one for the ES and one for the PCR\n\t\tif (ts->ess[i] && (ts->ess[i]->pid==i)) gf_m2ts_es_del(ts->ess[i], ts);\n\t}\n\tif (ts->buffer) gf_free(ts->buffer);\n\twhile (gf_list_count(ts->programs)) {\n\t\tGF_M2TS_Program *p = (GF_M2TS_Program *)gf_list_last(ts->programs);\n\t\tgf_list_rem_last(ts->programs);\n\t\tgf_list_del(p->streams);\n\t\t/*reset OD list*/\n\t\tif (p->additional_ods) {\n\t\t\tgf_odf_desc_list_del(p->additional_ods);\n\t\t\tgf_list_del(p->additional_ods);\n\t\t}\n\t\tif (p->pmt_iod) gf_odf_desc_del((GF_Descriptor *)p->pmt_iod);\n\t\tif (p->metadata_pointer_descriptor)\tgf_m2ts_metadata_pointer_descriptor_del(p->metadata_pointer_descriptor);\n\t\tgf_free(p);\n\t}\n\tgf_list_del(ts->programs);\n\n\tif (ts->TDT_time) gf_free(ts->TDT_time);\n\tgf_m2ts_reset_sdt(ts);\n\tif (ts->tdt_tot)\n\t\tgf_list_del(ts->SDTs);\n\n#ifdef GPAC_ENABLE_MPE\n\tgf_dvb_mpe_shutdown(ts);\n#endif\n\n\tif (ts->dsmcc_controler) {\n\t\tif (gf_list_count(ts->dsmcc_controler)) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\t\tGF_M2TS_DSMCC_OVERLORD* dsmcc_overlord = (GF_M2TS_DSMCC_OVERLORD*)gf_list_get(ts->dsmcc_controler,0);\n\t\t\tgf_cleanup_dir(dsmcc_overlord->root_dir);\n\t\t\tgf_rmdir(dsmcc_overlord->root_dir);\n\t\t\tgf_m2ts_delete_dsmcc_overlord(dsmcc_overlord);\n\t\t\tif(ts->dsmcc_root_dir) {\n\t\t\t\tgf_free(ts->dsmcc_root_dir);\n\t\t\t}\n#endif\n\t\t}\n\t\tgf_list_del(ts->dsmcc_controler);\n\t}\n\n\twhile(gf_list_count(ts->ChannelAppList)) {\n#ifdef GPAC_ENABLE_DSMCC\n\t\tGF_M2TS_CHANNEL_APPLICATION_INFO* ChanAppInfo = (GF_M2TS_CHANNEL_APPLICATION_INFO*)gf_list_get(ts->ChannelAppList,0);\n\t\tgf_m2ts_delete_channel_application_info(ChanAppInfo);\n\t\tgf_list_rem(ts->ChannelAppList,0);\n#endif\n\t}\n\tgf_list_del(ts->ChannelAppList);\n\n\tif (ts->dsmcc_root_dir) gf_free(ts->dsmcc_root_dir);\n\tgf_free(ts);\n}\n\n#if 0//unused\nvoid gf_m2ts_print_info(GF_M2TS_Demuxer *ts)\n{\n#ifdef GPAC_ENABLE_MPE\n\tgf_m2ts_print_mpe_info(ts);\n#endif\n}\n#endif\n\n\n\n#define M2TS_PROBE_SIZE\t188000\nstatic Bool gf_m2ts_probe_buffer(char *buf, u32 size)\n{\n\tGF_Err e;\n\tGF_M2TS_Demuxer *ts;\n\tu32 lt;\n\n\tlt = gf_log_get_tool_level(GF_LOG_CONTAINER);\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, GF_LOG_QUIET);\n\n\tts = gf_m2ts_demux_new();\n\te = gf_m2ts_process_data(ts, buf, size);\n\tif (!ts->pck_number) e = GF_BAD_PARAM;\n\tgf_m2ts_demux_del(ts);\n\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, lt);\n\n\tif (e) return GF_FALSE;\n\treturn GF_TRUE;\n\n}\nGF_EXPORT\nBool gf_m2ts_probe_file(const char *fileName)\n{\n\tchar buf[M2TS_PROBE_SIZE];\n\tu32 size;\n\tFILE *t;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get_data(fileName, &mem_address, &size) != GF_OK) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tif (size>M2TS_PROBE_SIZE) size = M2TS_PROBE_SIZE;\n\t\tmemcpy(buf, mem_address, size);\n\t} else {\n\t\tt = gf_fopen(fileName, \"rb\");\n\t\tif (!t) return 0;\n\t\tsize = (u32) fread(buf, 1, M2TS_PROBE_SIZE, t);\n\t\tgf_fclose(t);\n\t\tif ((s32) size <= 0) return 0;\n\t}\n\treturn gf_m2ts_probe_buffer(buf, size);\n}\n\nGF_EXPORT\nBool gf_m2ts_probe_data(const u8 *data, u32 size)\n{\n\tsize /= 188;\n\tsize *= 188;\n\treturn gf_m2ts_probe_buffer((char *) data, size);\n}\n\n\nstatic void rewrite_pts_dts(unsigned char *ptr, u64 TS)\n{\n\tptr[0] &= 0xf1;\n\tptr[0] |= (unsigned char)((TS&0x1c0000000ULL)>>29);\n\tptr[1]  = (unsigned char)((TS&0x03fc00000ULL)>>22);\n\tptr[2] &= 0x1;\n\tptr[2] |= (unsigned char)((TS&0x0003f8000ULL)>>14);\n\tptr[3]  = (unsigned char)((TS&0x000007f80ULL)>>7);\n\tptr[4] &= 0x1;\n\tptr[4] |= (unsigned char)((TS&0x00000007fULL)<<1);\n\n\tassert(((u64)(ptr[0]&0xe)<<29) + ((u64)ptr[1]<<22) + ((u64)(ptr[2]&0xfe)<<14) + ((u64)ptr[3]<<7) + ((ptr[4]&0xfe)>>1) == TS);\n}\n\n#define ADJUST_TIMESTAMP(_TS) \\\n\tif (_TS < (u64) -ts_shift) _TS = pcr_mod + _TS + ts_shift; \\\n\telse _TS = _TS + ts_shift; \\\n\twhile (_TS > pcr_mod) _TS -= pcr_mod; \\\n\nGF_EXPORT\nGF_Err gf_m2ts_restamp(u8 *buffer, u32 size, s64 ts_shift, u8 *is_pes)\n{\n\tu32 done = 0;\n\tu64 pcr_mod;\n//\tif (!ts_shift) return GF_OK;\n\n\tpcr_mod = 0x80000000;\n\tpcr_mod*=4;\n\twhile (done + 188 <= size) {\n\t\tu8 *pesh;\n\t\tu8 *pck;\n\t\tu64 pcr_base=0, pcr_ext=0;\n\t\tu16 pid;\n\t\tu8 adaptation_field, adaptation_field_length;\n\n\t\tpck = (u8*) buffer+done;\n\t\tif (pck[0]!=0x47) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[M2TS Restamp] Invalid sync byte %X\\n\", pck[0]));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tpid = ((pck[1] & 0x1f) <<8 ) + pck[2];\n\n\t\tadaptation_field_length = 0;\n\t\tadaptation_field = (pck[3] >> 4) & 0x3;\n\t\tif ((adaptation_field==2) || (adaptation_field==3)) {\n\t\t\tadaptation_field_length = pck[4];\n\t\t\tif ( pck[5]&0x10 /*PCR_flag*/) {\n\t\t\t\tpcr_base = (((u64)pck[6])<<25) + (pck[7]<<17) + (pck[8]<<9) + (pck[9]<<1) + (pck[10]>>7);\n\t\t\t\tpcr_ext  = ((pck[10]&1)<<8) + pck[11];\n\n\t\t\t\tADJUST_TIMESTAMP(pcr_base);\n\n\t\t\t\tpck[6]  = (unsigned char)(0xff&(pcr_base>>25));\n\t\t\t\tpck[7]  = (unsigned char)(0xff&(pcr_base>>17));\n\t\t\t\tpck[8]  = (unsigned char)(0xff&(pcr_base>>9));\n\t\t\t\tpck[9]  = (unsigned char)(0xff&(pcr_base>>1));\n\t\t\t\tpck[10] = (unsigned char)(((0x1&pcr_base)<<7) | 0x7e | ((0x100&pcr_ext)>>8));\n\t\t\t\tif (pcr_ext != ((pck[10]&1)<<8) + pck[11]) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[M2TS Restamp] Sanity check failed for PCR restamping\\n\"));\n\t\t\t\t\treturn GF_IO_ERR;\n\t\t\t\t}\n\t\t\t\tpck[11] = (unsigned char)(0xff&pcr_ext);\n\t\t\t}\n\t\t\t/*add adaptation_field_length field*/\n\t\t\tadaptation_field_length++;\n\t\t}\n\t\tif (!is_pes[pid] || !(pck[1]&0x40)) {\n\t\t\tdone+=188;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpesh = &pck[4+adaptation_field_length];\n\n\t\tif ((pesh[0]==0x00) && (pesh[1]==0x00) && (pesh[2]==0x01)) {\n\t\t\tBool has_pts, has_dts;\n\t\t\tif ((pesh[6]&0xc0)!=0x80) {\n\t\t\t\tdone+=188;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thas_pts = (pesh[7]&0x80);\n\t\t\thas_dts = has_pts ? (pesh[7]&0x40) : 0;\n\n\t\t\tif (has_pts) {\n\t\t\t\tu64 PTS;\n\t\t\t\tif (((pesh[9]&0xe0)>>4)!=0x2) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS Restamp] PID %4d: Wrong PES header, PTS decoding: '0010' expected\\n\", pid));\n\t\t\t\t\tdone+=188;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tPTS = gf_m2ts_get_pts(pesh + 9);\n\t\t\t\tADJUST_TIMESTAMP(PTS);\n\t\t\t\trewrite_pts_dts(pesh+9, PTS);\n\t\t\t}\n\n\t\t\tif (has_dts) {\n\t\t\t\tu64 DTS = gf_m2ts_get_pts(pesh + 14);\n\t\t\t\tADJUST_TIMESTAMP(DTS);\n\t\t\t\trewrite_pts_dts(pesh+14, DTS);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[M2TS Restamp] PID %4d: Wrong PES not beginning with start code\\n\", pid));\n\t\t}\n\t\tdone+=188;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_MPEG2TS*/\n"], "filenames": ["src/media_tools/mpegts.c"], "buggy_code_start_loc": [1155], "buggy_code_end_loc": [1176], "fixing_code_start_loc": [1155], "fixing_code_end_loc": [1184], "type": "CWE-125", "message": "An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in BS_ReadByte (called from gf_bs_read_bit) in utils/bitstream.c that can cause a denial of service via a crafted MP4 file.", "other": {"cve": {"id": "CVE-2019-20630", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-24T19:15:21.070", "lastModified": "2020-03-25T13:54:08.433", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in libgpac.a in GPAC before 0.8.0, as demonstrated by MP4Box. It contains a heap-based buffer over-read in BS_ReadByte (called from gf_bs_read_bit) in utils/bitstream.c that can cause a denial of service via a crafted MP4 file."}, {"lang": "es", "value": "Se detect\u00f3 un problema en libgpac.a en GPAC versiones anteriores a 0.8.0, como es demostrado por MP4Box. Contiene una lectura excesiva de b\u00fafer en la regi\u00f3n heap de la memoria en BS_ReadByte (llamado desde la funci\u00f3n gf_bs_read_bit) en el archivo utils/bitstream.c que puede causar una denegaci\u00f3n de servicio por medio de un archivo MP4 dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.0", "matchCriteriaId": "123D0430-86B1-40BF-9B43-C782CC2EDDE8"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/1ab4860609f2e7a35634930571e7d0531297e090", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1268", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/1ab4860609f2e7a35634930571e7d0531297e090"}}