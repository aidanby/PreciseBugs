{"buggy_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.context;\n\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_EXECUTE_PARAM;\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_RENDER_PARAM;\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_RESET_VALUES_PARAM;\nimport static javax.faces.FactoryFinder.VISIT_CONTEXT_FACTORY;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.faces.FacesException;\nimport javax.faces.FactoryFinder;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.component.NamingContainer;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.component.visit.VisitCallback;\nimport javax.faces.component.visit.VisitContext;\nimport javax.faces.component.visit.VisitContextFactory;\nimport javax.faces.component.visit.VisitContextWrapper;\nimport javax.faces.component.visit.VisitHint;\nimport javax.faces.component.visit.VisitResult;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.faces.context.PartialResponseWriter;\nimport javax.faces.context.PartialViewContext;\nimport javax.faces.context.ResponseWriter;\nimport javax.faces.event.PhaseId;\nimport javax.faces.lifecycle.ClientWindow;\nimport javax.faces.render.RenderKit;\nimport javax.faces.render.RenderKitFactory;\n\nimport com.sun.faces.RIConstants;\nimport com.sun.faces.component.visit.PartialVisitContext;\nimport com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.HtmlUtils;\nimport com.sun.faces.util.Util;\n\n public class PartialViewContextImpl extends PartialViewContext {\n\n    // Log instance for this class\n    private static Logger LOGGER = FacesLogger.CONTEXT.getLogger();\n\n    private boolean released;\n\n    // BE SURE TO ADD NEW IVARS TO THE RELEASE METHOD\n    private PartialResponseWriter partialResponseWriter;\n    private List<String> executeIds;\n    private Collection<String> renderIds;\n    private List<String> evalScripts;\n    private Boolean ajaxRequest;\n    private Boolean partialRequest;\n    private Boolean renderAll;\n    private FacesContext ctx;\n\n    private static final String ORIGINAL_WRITER = \"com.sun.faces.ORIGINAL_WRITER\";\n\n\n    // ----------------------------------------------------------- Constructors\n\n\n    public PartialViewContextImpl(FacesContext ctx) {\n        this.ctx = ctx;\n    }\n\n\n    // ---------------------------------------------- Methods from PartialViewContext\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isAjaxRequest()\n     */\n    @Override\n    public boolean isAjaxRequest() {\n\n        assertNotReleased();\n        if (ajaxRequest == null) {\n            ajaxRequest = \"partial/ajax\".equals(ctx.\n                getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n            if (!ajaxRequest) {\n                ajaxRequest = \"partial/ajax\".equals(ctx.getExternalContext().getRequestParameterMap().\n                    get(\"Faces-Request\"));\n            }\n        }\n        return ajaxRequest;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isPartialRequest()\n     */\n    @Override\n    public boolean isPartialRequest() {\n\n        assertNotReleased();\n        if (partialRequest == null) {\n            partialRequest = isAjaxRequest() ||\n                    \"partial/process\".equals(ctx.\n                    getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n        }\n        return partialRequest;\n\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isExecuteAll()\n     */\n    @Override\n    public boolean isExecuteAll() {\n\n        assertNotReleased();\n        String execute = PARTIAL_EXECUTE_PARAM.getValue(ctx);\n        return (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(execute));\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isRenderAll()\n     */\n    @Override\n    public boolean isRenderAll() {\n\n        assertNotReleased();\n        if (renderAll == null) {\n            String render = PARTIAL_RENDER_PARAM.getValue(ctx);\n            renderAll = (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(render));\n        }\n\n        return renderAll;\n\n    }\n    \n    /**\n     * @see javax.faces.context.PartialViewContext#setRenderAll(boolean) \n     */\n    @Override\n    public void setRenderAll(boolean renderAll) {\n\n        this.renderAll = renderAll;\n\n    }\n\n    @Override\n    public boolean isResetValues() {\n        Object value = PARTIAL_RESET_VALUES_PARAM.getValue(ctx);\n        return (null != value && \"true\".equals(value)) ? true : false;\n    }\n\n    @Override\n    public void setPartialRequest(boolean isPartialRequest) {\n        this.partialRequest = isPartialRequest;\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getExecuteIds()\n     */\n    @Override\n    public Collection<String> getExecuteIds() {\n\n        assertNotReleased();\n        if (executeIds != null) {\n            return executeIds;\n        }\n        executeIds = populatePhaseClientIds(PARTIAL_EXECUTE_PARAM);\n\n        // include the view parameter facet ID if there are other execute IDs\n        // to process\n        if (!executeIds.isEmpty()) {\n            UIViewRoot root = ctx.getViewRoot();\n            if (root.getFacetCount() > 0) {\n                if (root.getFacet(UIViewRoot.METADATA_FACET_NAME) != null) {\n                    executeIds.add(0, UIViewRoot.METADATA_FACET_NAME);   \n                }\n            }\n        }\n        return executeIds;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getRenderIds()\n     */\n    @Override\n    public Collection<String> getRenderIds() {\n\n        assertNotReleased();\n        if (renderIds != null) {\n            return renderIds;\n        }\n        renderIds = populatePhaseClientIds(PARTIAL_RENDER_PARAM);\n        return renderIds;\n\n    }\n\n\t/**\n\t * @see javax.faces.context.PartialViewContext#getEvalScripts()\n\t */\n\t@Override\n\tpublic List<String> getEvalScripts() {\n\t\tassertNotReleased();\n\n\t\tif (evalScripts == null) {\n\t\t\tevalScripts = new ArrayList<>(1);\n\t\t}\n\n\t\treturn evalScripts;\n\t}\n\n    /**\n     * @see PartialViewContext#processPartial(javax.faces.event.PhaseId) \n     */\n    @Override\n    public void processPartial(PhaseId phaseId) {\n        PartialViewContext pvc = ctx.getPartialViewContext();\n        Collection <String> myExecuteIds = pvc.getExecuteIds();\n        Collection <String> myRenderIds = pvc.getRenderIds();\n        UIViewRoot viewRoot = ctx.getViewRoot();\n\n        if (phaseId == PhaseId.APPLY_REQUEST_VALUES ||\n            phaseId == PhaseId.PROCESS_VALIDATIONS ||\n            phaseId == PhaseId.UPDATE_MODEL_VALUES) {\n\n            // Skip this processing if \"none\" is specified in the render list,\n            // or there were no execute phase client ids.\n\n            if (myExecuteIds == null || myExecuteIds.isEmpty()) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                        \"No execute and render identifiers specified.  Skipping component processing.\");\n                }\n                return;\n            }\n\n            try {\n                processComponents(viewRoot, phaseId, myExecuteIds, ctx);\n            } catch (Exception e) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.log(Level.INFO,\n                           e.toString(),\n                           e);\n                }\n                throw new FacesException(e);\n            }\n\n            // If we have just finished APPLY_REQUEST_VALUES phase, install the\n            // partial response writer.  We want to make sure that any content\n            // or errors generated in the other phases are written using the\n            // partial response writer.\n            //\n            if (phaseId == PhaseId.APPLY_REQUEST_VALUES) {\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ctx.setResponseWriter(writer);\n            }\n\n        } else if (phaseId == PhaseId.RENDER_RESPONSE) {\n\n            try {\n                //\n                // We re-enable response writing.\n                //\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ResponseWriter orig = ctx.getResponseWriter();\n                ctx.getAttributes().put(ORIGINAL_WRITER, orig);\n                ctx.setResponseWriter(writer);\n\n                ExternalContext exContext = ctx.getExternalContext();\n                exContext.setResponseContentType(RIConstants.TEXT_XML_CONTENT_TYPE);\n                exContext.addResponseHeader(\"Cache-Control\", \"no-cache\");\n                \n//                String encoding = writer.getCharacterEncoding( );\n//                if( encoding == null ) {\n//                    encoding = \"UTF-8\";\n//                }\n//                writer.writePreamble(\"<?xml version='1.0' encoding='\" + encoding + \"'?>\\n\");\n                writer.startDocument();\n                \n                if (isResetValues()) {\n                    viewRoot.resetValues(ctx, myRenderIds);\n                }\n                \n                if (isRenderAll()) {\n                    renderAll(ctx, viewRoot);\n                    renderState(ctx);\n                    writer.endDocument();\n                    return;\n                }\n\n                renderComponentResources(ctx, viewRoot);\n\n                // Skip this processing if \"none\" is specified in the render list,\n                // or there were no render phase client ids.\n                if (myRenderIds != null && !myRenderIds.isEmpty()) {\n                    processComponents(viewRoot, phaseId, myRenderIds, ctx);\n                }\n\n                renderState(ctx);\n                renderEvalScripts(ctx);\n\n                writer.endDocument();\n            } catch (IOException ex) {\n                this.cleanupAfterView();\n            } catch (RuntimeException ex) {\n                this.cleanupAfterView();\n                // Throw the exception\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getPartialResponseWriter()\n     */\n    @Override\n    public PartialResponseWriter getPartialResponseWriter() {\n        assertNotReleased();\n        if (partialResponseWriter == null) {\n            partialResponseWriter = new DelayedInitPartialResponseWriter(this);\n        }\n        return partialResponseWriter;\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#release()\n     */\n    @Override\n    public void release() {\n        \n        released = true;\n        ajaxRequest = null;\n        renderAll = null;\n        partialResponseWriter = null;\n        executeIds = null;\n        renderIds = null;\n        evalScripts = null;\n        ctx = null;\n        partialRequest = null;\n\n    }\n\n    // -------------------------------------------------------- Private Methods\n\n\n\n    private List<String> populatePhaseClientIds(PredefinedPostbackParameter parameterName) {\n\n        String param = parameterName.getValue(ctx);\n        if (param == null) {\n            return new ArrayList<>();\n        } else {\n            Map<String, Object> appMap = FacesContext.getCurrentInstance().getExternalContext().getApplicationMap();\n            String[] pcs = Util.split(appMap, param, \"[ \\t]+\");\n            return ((pcs != null && pcs.length != 0)\n                    ? new ArrayList<>(Arrays.asList(pcs))\n                    : new ArrayList<>());\n        }\n        \n    }\n\n    // Process the components specified in the phaseClientIds list\n    private void processComponents(UIComponent component, PhaseId phaseId,\n        Collection<String> phaseClientIds, FacesContext context) throws IOException {\n\n        // We use the tree visitor mechanism to locate the components to\n        // process.  Create our (partial) VisitContext and the\n        // VisitCallback that will be invoked for each component that\n        // is visited.  Note that we use the SKIP_UNRENDERED hint as we\n        // only want to visit the rendered subtree.\n        EnumSet<VisitHint> hints = EnumSet.of(VisitHint.SKIP_UNRENDERED, VisitHint.EXECUTE_LIFECYCLE);\n        VisitContextFactory visitContextFactory = (VisitContextFactory) \n                FactoryFinder.getFactory(VISIT_CONTEXT_FACTORY);\n        VisitContext visitContext = visitContextFactory.getVisitContext(context, phaseClientIds, hints);\n        PhaseAwareVisitCallback visitCallback =\n            new PhaseAwareVisitCallback(ctx, phaseId);\n        component.visitTree(visitContext, visitCallback);\n\n        PartialVisitContext partialVisitContext = unwrapPartialVisitContext(visitContext);\n        if (partialVisitContext != null) {\n            if (LOGGER.isLoggable(Level.FINER) && !partialVisitContext.getUnvisitedClientIds().isEmpty()) {\n                Collection<String> unvisitedClientIds = partialVisitContext.getUnvisitedClientIds();\n                StringBuilder builder = new StringBuilder();\n                for (String cur : unvisitedClientIds) {\n                    builder.append(cur).append(\" \");\n                }\n                LOGGER.log(Level.FINER,\n                        \"jsf.context.partial_visit_context_unvisited_children\",\n                        new Object[]{builder.toString()});\n            }\n        }    \n    }\n\n    /**\n     * Unwraps {@link PartialVisitContext} from a chain of {@link VisitContextWrapper}s.\n     *\n     * If no {@link PartialVisitContext} is found in the chain, null is returned instead.\n     * \n     * @param visitContext the visit context.\n     * @return the (unwrapped) partial visit context.\n     */\n    private static PartialVisitContext unwrapPartialVisitContext(VisitContext visitContext) {\n        if (visitContext == null) {\n            return null;\n        }\n        if (visitContext instanceof PartialVisitContext) {\n            return (PartialVisitContext) visitContext;\n        }\n        if (visitContext instanceof VisitContextWrapper) {\n            return unwrapPartialVisitContext(((VisitContextWrapper) visitContext).getWrapped());\n        }\n        return null;\n    }\n    \n    private void renderAll(FacesContext context, UIViewRoot viewRoot) throws IOException {\n        // If this is a \"render all via ajax\" request,\n        // make sure to wrap the entire page in a <render> elemnt\n        // with the special viewStateId of VIEW_ROOT_ID.  This is how the client\n        // JavaScript knows how to replace the entire document with\n        // this response.\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        \n        if (!(viewRoot instanceof NamingContainer)) {\n            writer.startUpdate(PartialResponseWriter.RENDER_ALL_MARKER);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            writer.endUpdate();\n        }\n        else {\n            /*\n             * If we have a portlet request, start rendering at the view root.\n             */\n            writer.startUpdate(viewRoot.getClientId(context));\n            viewRoot.encodeBegin(context);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            viewRoot.encodeEnd(context);\n            writer.endUpdate();\n        }\n    }\n\n    private void renderComponentResources(FacesContext context, UIViewRoot viewRoot) throws IOException {\n        ResourceHandler resourceHandler = context.getApplication().getResourceHandler();\n        PartialResponseWriter writer = context.getPartialViewContext().getPartialResponseWriter();\n        boolean updateStarted = false;\n\n        for (UIComponent resource : viewRoot.getComponentResources(context)) {\n            String name = (String) resource.getAttributes().get(\"name\");\n            String library = (String) resource.getAttributes().get(\"library\");\n\n            if (resource.getChildCount() == 0 \n              && resourceHandler.getRendererTypeForResourceName(name) != null \n              && !resourceHandler.isResourceRendered(context, name, library)) \n            {\n                if (!updateStarted) {\n                    writer.startUpdate(\"javax.faces.Resource\");\n                    updateStarted = true;\n                }\n\n                resource.encodeAll(context);\n            }\n        }\n\n        if (updateStarted) {\n            writer.endUpdate();\n        }\n    }\n    \n    private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.write(window.getId());\n            writer.endUpdate();\n        }\n    }\n\n\tprivate void renderEvalScripts(FacesContext context) throws IOException {\n\t\tPartialViewContext pvc = context.getPartialViewContext();\n\t\tPartialResponseWriter writer = pvc.getPartialResponseWriter();\n\n\t\tfor (String evalScript : pvc.getEvalScripts()) {\n\t\t\twriter.startEval();\n\t\t\twriter.write(evalScript);\n\t\t\twriter.endEval();\n\t\t}\n\t}\n\n    private PartialResponseWriter createPartialResponseWriter() {\n\n        ExternalContext extContext = ctx.getExternalContext();\n        String encoding = extContext.getRequestCharacterEncoding();\n        extContext.setResponseCharacterEncoding(encoding);\n        ResponseWriter responseWriter = null;\n        Writer out = null;\n        try {\n            out = extContext.getResponseOutputWriter();\n        } catch (IOException ioe) {\n            if (LOGGER.isLoggable(Level.SEVERE)) {\n                LOGGER.log(Level.SEVERE,\n                           ioe.toString(),\n                           ioe);\n            }\n        }\n\n        if (out != null) {\n            UIViewRoot viewRoot = ctx.getViewRoot();\n            if (viewRoot != null) {\n                responseWriter =\n                    ctx.getRenderKit().createResponseWriter(out,\n                    RIConstants.TEXT_XML_CONTENT_TYPE, encoding);\n            } else {\n                RenderKitFactory factory = (RenderKitFactory)\n                    FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);\n                RenderKit renderKit = factory.getRenderKit(ctx, RenderKitFactory.HTML_BASIC_RENDER_KIT);\n                responseWriter = renderKit.createResponseWriter(out, RIConstants.TEXT_XML_CONTENT_TYPE, encoding);\n            }\n        }\n        if (responseWriter instanceof PartialResponseWriter)  {\n            return (PartialResponseWriter) responseWriter;\n        } else {\n            return new PartialResponseWriter(responseWriter);\n        }\n\n    }\n\n    private void cleanupAfterView() {\n        ResponseWriter orig = (ResponseWriter) ctx.getAttributes().\n            get(ORIGINAL_WRITER);\n        assert(null != orig);\n        // move aside the PartialResponseWriter\n        ctx.setResponseWriter(orig);\n    }\n\n    private void assertNotReleased() {\n        if (released) {\n            throw new IllegalStateException();\n        }\n    }\n\n    // ----------------------------------------------------------- Inner Classes\n\n\n    private static class PhaseAwareVisitCallback implements VisitCallback {\n\n        private PhaseId curPhase;\n        private FacesContext ctx;\n\n        private PhaseAwareVisitCallback(FacesContext ctx, PhaseId curPhase) {\n            this.ctx = ctx;\n            this.curPhase = curPhase;\n        }  \n\n\n        @Override\n        public VisitResult visit(VisitContext context, UIComponent comp) {\n            try {\n\n                if (curPhase == PhaseId.APPLY_REQUEST_VALUES) {\n\n                    // RELEASE_PENDING handle immediate request(s)\n                    // If the user requested an immediate request\n                    // Make sure to set the immediate flag here.\n\n                    comp.processDecodes(ctx);\n                } else if (curPhase == PhaseId.PROCESS_VALIDATIONS) {\n                    comp.processValidators(ctx);\n                } else if (curPhase == PhaseId.UPDATE_MODEL_VALUES) {\n                    comp.processUpdates(ctx);\n                } else if (curPhase == PhaseId.RENDER_RESPONSE) {\n                    PartialResponseWriter writer = ctx.getPartialViewContext().getPartialResponseWriter();\n                    writer.startUpdate(comp.getClientId(ctx));\n                    // do the default behavior...\n                    comp.encodeAll(ctx);\n                    writer.endUpdate();\n                } else {\n                    throw new IllegalStateException(\"I18N: Unexpected \" +\n                                                    \"PhaseId passed to \" +\n                                              \" PhaseAwareContextCallback: \" +\n                                                    curPhase.toString());\n                }\n            }\n            catch (IOException ex) {\n                if (LOGGER.isLoggable(Level.SEVERE)) {\n                    LOGGER.severe(ex.toString());\n                }\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                    ex.toString(),\n                    ex);\n                }\n                throw new FacesException(ex);\n            }\n\n            // Once we visit a component, there is no need to visit\n            // its children, since processDecodes/Validators/Updates and\n            // encodeAll() already traverse the subtree.  We return\n            // VisitResult.REJECT to supress the subtree visit.\n            return VisitResult.REJECT;\n        }\n    }\n\n\n     /**\n      * Delays the actual construction of the PartialResponseWriter <em>until</em>\n      * content is going to actually be written.\n      */\n    private static final class DelayedInitPartialResponseWriter extends PartialResponseWriter {\n\n        private ResponseWriter writer;\n        private PartialViewContextImpl ctx;\n\n        // -------------------------------------------------------- Constructors\n\n\n        public DelayedInitPartialResponseWriter(PartialViewContextImpl ctx) {\n\n            super(null);\n            this.ctx = ctx;\n            ExternalContext extCtx = ctx.ctx.getExternalContext();\n            extCtx.setResponseContentType(RIConstants.TEXT_XML_CONTENT_TYPE);\n            extCtx.setResponseCharacterEncoding(extCtx.getRequestCharacterEncoding());\n            extCtx.setResponseBufferSize(ctx.ctx.getExternalContext().getResponseBufferSize());\n        }\n\n\n        // ---------------------------------- Methods from PartialResponseWriter\n\n        @Override\n        public void write(String text) throws IOException {\n            HtmlUtils.writeUnescapedTextForXML(getWrapped(), text);\n        }\n\n        @Override\n        public ResponseWriter getWrapped() {\n\n            if (writer == null) {\n                writer = ctx.createPartialResponseWriter();\n            }\n            return writer;\n\n        }\n         \n    } // END DelayedInitPartialResponseWriter\n\n} \n"], "fixing_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.context;\n\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_EXECUTE_PARAM;\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_RENDER_PARAM;\nimport static com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter.PARTIAL_RESET_VALUES_PARAM;\nimport static javax.faces.FactoryFinder.VISIT_CONTEXT_FACTORY;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.faces.FacesException;\nimport javax.faces.FactoryFinder;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.component.NamingContainer;\nimport javax.faces.component.UIComponent;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.component.visit.VisitCallback;\nimport javax.faces.component.visit.VisitContext;\nimport javax.faces.component.visit.VisitContextFactory;\nimport javax.faces.component.visit.VisitContextWrapper;\nimport javax.faces.component.visit.VisitHint;\nimport javax.faces.component.visit.VisitResult;\nimport javax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.faces.context.PartialResponseWriter;\nimport javax.faces.context.PartialViewContext;\nimport javax.faces.context.ResponseWriter;\nimport javax.faces.event.PhaseId;\nimport javax.faces.lifecycle.ClientWindow;\nimport javax.faces.render.RenderKit;\nimport javax.faces.render.RenderKitFactory;\n\nimport com.sun.faces.RIConstants;\nimport com.sun.faces.component.visit.PartialVisitContext;\nimport com.sun.faces.renderkit.RenderKitUtils.PredefinedPostbackParameter;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.HtmlUtils;\nimport com.sun.faces.util.Util;\n\n public class PartialViewContextImpl extends PartialViewContext {\n\n    // Log instance for this class\n    private static Logger LOGGER = FacesLogger.CONTEXT.getLogger();\n\n    private boolean released;\n\n    // BE SURE TO ADD NEW IVARS TO THE RELEASE METHOD\n    private PartialResponseWriter partialResponseWriter;\n    private List<String> executeIds;\n    private Collection<String> renderIds;\n    private List<String> evalScripts;\n    private Boolean ajaxRequest;\n    private Boolean partialRequest;\n    private Boolean renderAll;\n    private FacesContext ctx;\n\n    private static final String ORIGINAL_WRITER = \"com.sun.faces.ORIGINAL_WRITER\";\n\n\n    // ----------------------------------------------------------- Constructors\n\n\n    public PartialViewContextImpl(FacesContext ctx) {\n        this.ctx = ctx;\n    }\n\n\n    // ---------------------------------------------- Methods from PartialViewContext\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isAjaxRequest()\n     */\n    @Override\n    public boolean isAjaxRequest() {\n\n        assertNotReleased();\n        if (ajaxRequest == null) {\n            ajaxRequest = \"partial/ajax\".equals(ctx.\n                getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n            if (!ajaxRequest) {\n                ajaxRequest = \"partial/ajax\".equals(ctx.getExternalContext().getRequestParameterMap().\n                    get(\"Faces-Request\"));\n            }\n        }\n        return ajaxRequest;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isPartialRequest()\n     */\n    @Override\n    public boolean isPartialRequest() {\n\n        assertNotReleased();\n        if (partialRequest == null) {\n            partialRequest = isAjaxRequest() ||\n                    \"partial/process\".equals(ctx.\n                    getExternalContext().getRequestHeaderMap().get(\"Faces-Request\"));\n        }\n        return partialRequest;\n\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isExecuteAll()\n     */\n    @Override\n    public boolean isExecuteAll() {\n\n        assertNotReleased();\n        String execute = PARTIAL_EXECUTE_PARAM.getValue(ctx);\n        return (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(execute));\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#isRenderAll()\n     */\n    @Override\n    public boolean isRenderAll() {\n\n        assertNotReleased();\n        if (renderAll == null) {\n            String render = PARTIAL_RENDER_PARAM.getValue(ctx);\n            renderAll = (ALL_PARTIAL_PHASE_CLIENT_IDS.equals(render));\n        }\n\n        return renderAll;\n\n    }\n    \n    /**\n     * @see javax.faces.context.PartialViewContext#setRenderAll(boolean) \n     */\n    @Override\n    public void setRenderAll(boolean renderAll) {\n\n        this.renderAll = renderAll;\n\n    }\n\n    @Override\n    public boolean isResetValues() {\n        Object value = PARTIAL_RESET_VALUES_PARAM.getValue(ctx);\n        return (null != value && \"true\".equals(value)) ? true : false;\n    }\n\n    @Override\n    public void setPartialRequest(boolean isPartialRequest) {\n        this.partialRequest = isPartialRequest;\n    }\n\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getExecuteIds()\n     */\n    @Override\n    public Collection<String> getExecuteIds() {\n\n        assertNotReleased();\n        if (executeIds != null) {\n            return executeIds;\n        }\n        executeIds = populatePhaseClientIds(PARTIAL_EXECUTE_PARAM);\n\n        // include the view parameter facet ID if there are other execute IDs\n        // to process\n        if (!executeIds.isEmpty()) {\n            UIViewRoot root = ctx.getViewRoot();\n            if (root.getFacetCount() > 0) {\n                if (root.getFacet(UIViewRoot.METADATA_FACET_NAME) != null) {\n                    executeIds.add(0, UIViewRoot.METADATA_FACET_NAME);   \n                }\n            }\n        }\n        return executeIds;\n\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getRenderIds()\n     */\n    @Override\n    public Collection<String> getRenderIds() {\n\n        assertNotReleased();\n        if (renderIds != null) {\n            return renderIds;\n        }\n        renderIds = populatePhaseClientIds(PARTIAL_RENDER_PARAM);\n        return renderIds;\n\n    }\n\n\t/**\n\t * @see javax.faces.context.PartialViewContext#getEvalScripts()\n\t */\n\t@Override\n\tpublic List<String> getEvalScripts() {\n\t\tassertNotReleased();\n\n\t\tif (evalScripts == null) {\n\t\t\tevalScripts = new ArrayList<>(1);\n\t\t}\n\n\t\treturn evalScripts;\n\t}\n\n    /**\n     * @see PartialViewContext#processPartial(javax.faces.event.PhaseId) \n     */\n    @Override\n    public void processPartial(PhaseId phaseId) {\n        PartialViewContext pvc = ctx.getPartialViewContext();\n        Collection <String> myExecuteIds = pvc.getExecuteIds();\n        Collection <String> myRenderIds = pvc.getRenderIds();\n        UIViewRoot viewRoot = ctx.getViewRoot();\n\n        if (phaseId == PhaseId.APPLY_REQUEST_VALUES ||\n            phaseId == PhaseId.PROCESS_VALIDATIONS ||\n            phaseId == PhaseId.UPDATE_MODEL_VALUES) {\n\n            // Skip this processing if \"none\" is specified in the render list,\n            // or there were no execute phase client ids.\n\n            if (myExecuteIds == null || myExecuteIds.isEmpty()) {\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                        \"No execute and render identifiers specified.  Skipping component processing.\");\n                }\n                return;\n            }\n\n            try {\n                processComponents(viewRoot, phaseId, myExecuteIds, ctx);\n            } catch (Exception e) {\n                if (LOGGER.isLoggable(Level.INFO)) {\n                    LOGGER.log(Level.INFO,\n                           e.toString(),\n                           e);\n                }\n                throw new FacesException(e);\n            }\n\n            // If we have just finished APPLY_REQUEST_VALUES phase, install the\n            // partial response writer.  We want to make sure that any content\n            // or errors generated in the other phases are written using the\n            // partial response writer.\n            //\n            if (phaseId == PhaseId.APPLY_REQUEST_VALUES) {\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ctx.setResponseWriter(writer);\n            }\n\n        } else if (phaseId == PhaseId.RENDER_RESPONSE) {\n\n            try {\n                //\n                // We re-enable response writing.\n                //\n                PartialResponseWriter writer = pvc.getPartialResponseWriter();\n                ResponseWriter orig = ctx.getResponseWriter();\n                ctx.getAttributes().put(ORIGINAL_WRITER, orig);\n                ctx.setResponseWriter(writer);\n\n                ExternalContext exContext = ctx.getExternalContext();\n                exContext.setResponseContentType(RIConstants.TEXT_XML_CONTENT_TYPE);\n                exContext.addResponseHeader(\"Cache-Control\", \"no-cache\");\n                \n//                String encoding = writer.getCharacterEncoding( );\n//                if( encoding == null ) {\n//                    encoding = \"UTF-8\";\n//                }\n//                writer.writePreamble(\"<?xml version='1.0' encoding='\" + encoding + \"'?>\\n\");\n                writer.startDocument();\n                \n                if (isResetValues()) {\n                    viewRoot.resetValues(ctx, myRenderIds);\n                }\n                \n                if (isRenderAll()) {\n                    renderAll(ctx, viewRoot);\n                    renderState(ctx);\n                    writer.endDocument();\n                    return;\n                }\n\n                renderComponentResources(ctx, viewRoot);\n\n                // Skip this processing if \"none\" is specified in the render list,\n                // or there were no render phase client ids.\n                if (myRenderIds != null && !myRenderIds.isEmpty()) {\n                    processComponents(viewRoot, phaseId, myRenderIds, ctx);\n                }\n\n                renderState(ctx);\n                renderEvalScripts(ctx);\n\n                writer.endDocument();\n            } catch (IOException ex) {\n                this.cleanupAfterView();\n            } catch (RuntimeException ex) {\n                this.cleanupAfterView();\n                // Throw the exception\n                throw ex;\n            }\n        }\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#getPartialResponseWriter()\n     */\n    @Override\n    public PartialResponseWriter getPartialResponseWriter() {\n        assertNotReleased();\n        if (partialResponseWriter == null) {\n            partialResponseWriter = new DelayedInitPartialResponseWriter(this);\n        }\n        return partialResponseWriter;\n    }\n\n    /**\n     * @see javax.faces.context.PartialViewContext#release()\n     */\n    @Override\n    public void release() {\n        \n        released = true;\n        ajaxRequest = null;\n        renderAll = null;\n        partialResponseWriter = null;\n        executeIds = null;\n        renderIds = null;\n        evalScripts = null;\n        ctx = null;\n        partialRequest = null;\n\n    }\n\n    // -------------------------------------------------------- Private Methods\n\n\n\n    private List<String> populatePhaseClientIds(PredefinedPostbackParameter parameterName) {\n\n        String param = parameterName.getValue(ctx);\n        if (param == null) {\n            return new ArrayList<>();\n        } else {\n            Map<String, Object> appMap = FacesContext.getCurrentInstance().getExternalContext().getApplicationMap();\n            String[] pcs = Util.split(appMap, param, \"[ \\t]+\");\n            return ((pcs != null && pcs.length != 0)\n                    ? new ArrayList<>(Arrays.asList(pcs))\n                    : new ArrayList<>());\n        }\n        \n    }\n\n    // Process the components specified in the phaseClientIds list\n    private void processComponents(UIComponent component, PhaseId phaseId,\n        Collection<String> phaseClientIds, FacesContext context) throws IOException {\n\n        // We use the tree visitor mechanism to locate the components to\n        // process.  Create our (partial) VisitContext and the\n        // VisitCallback that will be invoked for each component that\n        // is visited.  Note that we use the SKIP_UNRENDERED hint as we\n        // only want to visit the rendered subtree.\n        EnumSet<VisitHint> hints = EnumSet.of(VisitHint.SKIP_UNRENDERED, VisitHint.EXECUTE_LIFECYCLE);\n        VisitContextFactory visitContextFactory = (VisitContextFactory) \n                FactoryFinder.getFactory(VISIT_CONTEXT_FACTORY);\n        VisitContext visitContext = visitContextFactory.getVisitContext(context, phaseClientIds, hints);\n        PhaseAwareVisitCallback visitCallback =\n            new PhaseAwareVisitCallback(ctx, phaseId);\n        component.visitTree(visitContext, visitCallback);\n\n        PartialVisitContext partialVisitContext = unwrapPartialVisitContext(visitContext);\n        if (partialVisitContext != null) {\n            if (LOGGER.isLoggable(Level.FINER) && !partialVisitContext.getUnvisitedClientIds().isEmpty()) {\n                Collection<String> unvisitedClientIds = partialVisitContext.getUnvisitedClientIds();\n                StringBuilder builder = new StringBuilder();\n                for (String cur : unvisitedClientIds) {\n                    builder.append(cur).append(\" \");\n                }\n                LOGGER.log(Level.FINER,\n                        \"jsf.context.partial_visit_context_unvisited_children\",\n                        new Object[]{builder.toString()});\n            }\n        }    \n    }\n\n    /**\n     * Unwraps {@link PartialVisitContext} from a chain of {@link VisitContextWrapper}s.\n     *\n     * If no {@link PartialVisitContext} is found in the chain, null is returned instead.\n     * \n     * @param visitContext the visit context.\n     * @return the (unwrapped) partial visit context.\n     */\n    private static PartialVisitContext unwrapPartialVisitContext(VisitContext visitContext) {\n        if (visitContext == null) {\n            return null;\n        }\n        if (visitContext instanceof PartialVisitContext) {\n            return (PartialVisitContext) visitContext;\n        }\n        if (visitContext instanceof VisitContextWrapper) {\n            return unwrapPartialVisitContext(((VisitContextWrapper) visitContext).getWrapped());\n        }\n        return null;\n    }\n    \n    private void renderAll(FacesContext context, UIViewRoot viewRoot) throws IOException {\n        // If this is a \"render all via ajax\" request,\n        // make sure to wrap the entire page in a <render> elemnt\n        // with the special viewStateId of VIEW_ROOT_ID.  This is how the client\n        // JavaScript knows how to replace the entire document with\n        // this response.\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        \n        if (!(viewRoot instanceof NamingContainer)) {\n            writer.startUpdate(PartialResponseWriter.RENDER_ALL_MARKER);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            writer.endUpdate();\n        }\n        else {\n            /*\n             * If we have a portlet request, start rendering at the view root.\n             */\n            writer.startUpdate(viewRoot.getClientId(context));\n            viewRoot.encodeBegin(context);\n            if (viewRoot.getChildCount() > 0) {\n                for (UIComponent uiComponent : viewRoot.getChildren()) {\n                    uiComponent.encodeAll(context);\n                }\n            }\n            viewRoot.encodeEnd(context);\n            writer.endUpdate();\n        }\n    }\n\n    private void renderComponentResources(FacesContext context, UIViewRoot viewRoot) throws IOException {\n        ResourceHandler resourceHandler = context.getApplication().getResourceHandler();\n        PartialResponseWriter writer = context.getPartialViewContext().getPartialResponseWriter();\n        boolean updateStarted = false;\n\n        for (UIComponent resource : viewRoot.getComponentResources(context)) {\n            String name = (String) resource.getAttributes().get(\"name\");\n            String library = (String) resource.getAttributes().get(\"library\");\n\n            if (resource.getChildCount() == 0 \n              && resourceHandler.getRendererTypeForResourceName(name) != null \n              && !resourceHandler.isResourceRendered(context, name, library)) \n            {\n                if (!updateStarted) {\n                    writer.startUpdate(\"javax.faces.Resource\");\n                    updateStarted = true;\n                }\n\n                resource.encodeAll(context);\n            }\n        }\n\n        if (updateStarted) {\n            writer.endUpdate();\n        }\n    }\n    \n    private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.writeText(window.getId(), null);\n            writer.endUpdate();\n        }\n    }\n\n\tprivate void renderEvalScripts(FacesContext context) throws IOException {\n\t\tPartialViewContext pvc = context.getPartialViewContext();\n\t\tPartialResponseWriter writer = pvc.getPartialResponseWriter();\n\n\t\tfor (String evalScript : pvc.getEvalScripts()) {\n\t\t\twriter.startEval();\n\t\t\twriter.write(evalScript);\n\t\t\twriter.endEval();\n\t\t}\n\t}\n\n    private PartialResponseWriter createPartialResponseWriter() {\n\n        ExternalContext extContext = ctx.getExternalContext();\n        String encoding = extContext.getRequestCharacterEncoding();\n        extContext.setResponseCharacterEncoding(encoding);\n        ResponseWriter responseWriter = null;\n        Writer out = null;\n        try {\n            out = extContext.getResponseOutputWriter();\n        } catch (IOException ioe) {\n            if (LOGGER.isLoggable(Level.SEVERE)) {\n                LOGGER.log(Level.SEVERE,\n                           ioe.toString(),\n                           ioe);\n            }\n        }\n\n        if (out != null) {\n            UIViewRoot viewRoot = ctx.getViewRoot();\n            if (viewRoot != null) {\n                responseWriter =\n                    ctx.getRenderKit().createResponseWriter(out,\n                    RIConstants.TEXT_XML_CONTENT_TYPE, encoding);\n            } else {\n                RenderKitFactory factory = (RenderKitFactory)\n                    FactoryFinder.getFactory(FactoryFinder.RENDER_KIT_FACTORY);\n                RenderKit renderKit = factory.getRenderKit(ctx, RenderKitFactory.HTML_BASIC_RENDER_KIT);\n                responseWriter = renderKit.createResponseWriter(out, RIConstants.TEXT_XML_CONTENT_TYPE, encoding);\n            }\n        }\n        if (responseWriter instanceof PartialResponseWriter)  {\n            return (PartialResponseWriter) responseWriter;\n        } else {\n            return new PartialResponseWriter(responseWriter);\n        }\n\n    }\n\n    private void cleanupAfterView() {\n        ResponseWriter orig = (ResponseWriter) ctx.getAttributes().\n            get(ORIGINAL_WRITER);\n        assert(null != orig);\n        // move aside the PartialResponseWriter\n        ctx.setResponseWriter(orig);\n    }\n\n    private void assertNotReleased() {\n        if (released) {\n            throw new IllegalStateException();\n        }\n    }\n\n    // ----------------------------------------------------------- Inner Classes\n\n\n    private static class PhaseAwareVisitCallback implements VisitCallback {\n\n        private PhaseId curPhase;\n        private FacesContext ctx;\n\n        private PhaseAwareVisitCallback(FacesContext ctx, PhaseId curPhase) {\n            this.ctx = ctx;\n            this.curPhase = curPhase;\n        }  \n\n\n        @Override\n        public VisitResult visit(VisitContext context, UIComponent comp) {\n            try {\n\n                if (curPhase == PhaseId.APPLY_REQUEST_VALUES) {\n\n                    // RELEASE_PENDING handle immediate request(s)\n                    // If the user requested an immediate request\n                    // Make sure to set the immediate flag here.\n\n                    comp.processDecodes(ctx);\n                } else if (curPhase == PhaseId.PROCESS_VALIDATIONS) {\n                    comp.processValidators(ctx);\n                } else if (curPhase == PhaseId.UPDATE_MODEL_VALUES) {\n                    comp.processUpdates(ctx);\n                } else if (curPhase == PhaseId.RENDER_RESPONSE) {\n                    PartialResponseWriter writer = ctx.getPartialViewContext().getPartialResponseWriter();\n                    writer.startUpdate(comp.getClientId(ctx));\n                    // do the default behavior...\n                    comp.encodeAll(ctx);\n                    writer.endUpdate();\n                } else {\n                    throw new IllegalStateException(\"I18N: Unexpected \" +\n                                                    \"PhaseId passed to \" +\n                                              \" PhaseAwareContextCallback: \" +\n                                                    curPhase.toString());\n                }\n            }\n            catch (IOException ex) {\n                if (LOGGER.isLoggable(Level.SEVERE)) {\n                    LOGGER.severe(ex.toString());\n                }\n                if (LOGGER.isLoggable(Level.FINE)) {\n                    LOGGER.log(Level.FINE,\n                    ex.toString(),\n                    ex);\n                }\n                throw new FacesException(ex);\n            }\n\n            // Once we visit a component, there is no need to visit\n            // its children, since processDecodes/Validators/Updates and\n            // encodeAll() already traverse the subtree.  We return\n            // VisitResult.REJECT to supress the subtree visit.\n            return VisitResult.REJECT;\n        }\n    }\n\n\n     /**\n      * Delays the actual construction of the PartialResponseWriter <em>until</em>\n      * content is going to actually be written.\n      */\n    private static final class DelayedInitPartialResponseWriter extends PartialResponseWriter {\n\n        private ResponseWriter writer;\n        private PartialViewContextImpl ctx;\n\n        // -------------------------------------------------------- Constructors\n\n\n        public DelayedInitPartialResponseWriter(PartialViewContextImpl ctx) {\n\n            super(null);\n            this.ctx = ctx;\n            ExternalContext extCtx = ctx.ctx.getExternalContext();\n            extCtx.setResponseContentType(RIConstants.TEXT_XML_CONTENT_TYPE);\n            extCtx.setResponseCharacterEncoding(extCtx.getRequestCharacterEncoding());\n            extCtx.setResponseBufferSize(ctx.ctx.getExternalContext().getResponseBufferSize());\n        }\n\n\n        // ---------------------------------- Methods from PartialResponseWriter\n\n        @Override\n        public void write(String text) throws IOException {\n            HtmlUtils.writeUnescapedTextForXML(getWrapped(), text);\n        }\n\n        @Override\n        public ResponseWriter getWrapped() {\n\n            if (writer == null) {\n                writer = ctx.createPartialResponseWriter();\n            }\n            return writer;\n\n        }\n         \n    } // END DelayedInitPartialResponseWriter\n\n} \n"], "filenames": ["impl/src/main/java/com/sun/faces/context/PartialViewContextImpl.java"], "buggy_code_start_loc": [514], "buggy_code_end_loc": [515], "fixing_code_start_loc": [514], "fixing_code_end_loc": [515], "type": "CWE-79", "message": "faces/context/PartialViewContextImpl.java in Eclipse Mojarra, as used in Mojarra for Eclipse EE4J before 2.3.10 and Mojarra JavaServer Faces before 2.2.20, allows Reflected XSS because a client window field is mishandled.", "other": {"cve": {"id": "CVE-2019-17091", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-02T14:15:12.600", "lastModified": "2022-04-06T18:00:47.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "faces/context/PartialViewContextImpl.java in Eclipse Mojarra, as used in Mojarra for Eclipse EE4J before 2.3.10 and Mojarra JavaServer Faces before 2.2.20, allows Reflected XSS because a client window field is mishandled."}, {"lang": "es", "value": "El archivo faces/context/PartialViewContextImpl.java en Eclipse Mojarra, como es usado en Mojarra para Eclipse EE4J versiones anteriores a 2.3.10 y Mojarra JavaServer Faces versiones anteriores a 2.2.20, permite un ataque de tipo XSS Reflejado porque un campo client window es manejado inapropiadamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:mojarra:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.10", "matchCriteriaId": "AF187C4C-1F1D-4C85-AD4F-B1583FE38E55"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mojarra_javaserver_faces:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.20", "matchCriteriaId": "1802D8E3-E0CB-40AB-A326-D86676EBAE75"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:application_testing_suite:13.2.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "10F17843-32EA-4C31-B65C-F424447BEF7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:application_testing_suite:13.3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A125E817-F974-4509-872C-B71933F42AD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_enterprise_product_manufacturing:2.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AED3C78-7D65-4F02-820D-B51BCE4022F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_enterprise_product_manufacturing:2.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "557A23A1-4762-4D29-A478-D1670C1847D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0.0", "versionEndIncluding": "8.4.0.5", "matchCriteriaId": "12981AA7-BBF6-4158-8F7D-9DD3880FDCC1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_network_integrity:7.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "FB92D8A7-2ABD-4B70-A32C-4B6B866C5B8B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_network_integrity:7.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "B21E6EEF-2AB7-4E96-B092-1F49D11B4175"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_unified_inventory_management:7.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "05AD47CC-8A6D-4AEC-B23E-701D3D649CC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_unified_inventory_management:7.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "539DA24F-E3E0-4455-84C6-A9D96CD601B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_data_quality:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "36CF85A9-2C29-46E7-961E-8ADD0B5822CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:health_sciences_information_manager:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "9027528A-4FE7-4E3C-B2DF-CCCED22128F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:healthcare_data_repository:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "E76102AD-1FFE-4E47-A616-F38382C67344"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.1.0.0", "versionEndIncluding": "15.2.18.7", "matchCriteriaId": "2EE28E34-1D55-42ED-88F2-B2A0C954E298"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.1.0.0", "versionEndIncluding": "16.2.19.0", "matchCriteriaId": "A2549AF5-E459-46EC-BC20-F5F7A2199802"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.1.0.0", "versionEndIncluding": "17.12.15.0", "matchCriteriaId": "7D701969-8B0B-40A9-8992-C383FD8B1F7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.1.0.0", "versionEndIncluding": "18.8.15.0", "matchCriteriaId": "87D6640E-3A12-4B4F-B5D7-AC1427B05B20"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:19.12.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F18C399-058C-427C-878C-5AAFE9EE31D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rapid_planning:12.1:*:*:*:*:*:*:*", "matchCriteriaId": "19A0F1AF-F2E6-44E7-8E2D-190E103B72D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rapid_planning:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "6D53690D-3390-4A27-988A-709CD89DD05B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_advanced_inventory_planning:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "517E0654-F1DE-43C4-90B5-FB90CA31734B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_advanced_inventory_planning:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "43DA1635-08DA-434D-AA39-20D117468B5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_assortment_planning:16.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "48C9BD8E-7214-4B44-B549-6F11B3EA8A04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_bulk_data_integration:16.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "360B307A-3D7F-4B38-8248-76CF8318B023"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_financial_integration:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "457C8C66-FB0C-4532-9027-8777CF42D17A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_financial_integration:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "FF2B9DA6-2937-4574-90DF-09FD770B23D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_integration_bus:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "42064F46-3012-4FB1-89BA-F13C2E4CBB6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_integration_bus:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "F73E2EFA-0F43-4D92-8C7D-9E66811B76D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_invoice_matching:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "7D939BB4-9D34-43A4-A19C-1CC90DB748FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_merchandising_system:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "46525CA6-4226-4F6F-B899-D800D4DDE0B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_service_backbone:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "363395FA-C296-4B2B-9D6F-BCB8DBE6FACE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_service_backbone:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "F62A2144-5EF8-4319-B8C2-D7975F51E5FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_store_inventory_management:14.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "0E703304-0752-46F2-998B-A3D37C9E7A54"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_store_inventory_management:14.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "722969B5-36CD-4413-954B-347BB7E51FAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_store_inventory_management:15.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "BF295023-399E-4180-A28B-2DA3327A372C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_store_inventory_management:16.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "3E5A2A49-42B0-44EB-B606-999275DC1DA1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:secure_global_desktop:5.4:*:*:*:*:*:*:*", "matchCriteriaId": "B5265C91-FF5C-4451-A7C2-D388A65ACFA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:secure_global_desktop:5.5:*:*:*:*:*:*:*", "matchCriteriaId": "C2B933E8-DBC4-4443-B837-BA8BAF8CC249"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:time_and_labor:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.2.6", "versionEndIncluding": "12.2.11", "matchCriteriaId": "19A74710-0E0F-4123-A64C-0684824D13CA"}]}]}], "references": [{"url": "https://bugs.eclipse.org/bugs/show_bug.cgi?id=548244", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/commit/8f70f2bd024f00ecd5b3dcca45df73edda29dcee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/commit/a3fa9573789ed5e867c43ea38374f4dbd5a8f81f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/compare/2.3.9-RELEASE...2.3.10-RELEASE", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/files/3039198/advisory.txt", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/issues/4556", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/pull/4567", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/javaserverfaces/mojarra/commit/ae1c234d0a6750822ac69d4ae26d90e3571f27fe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/javaserverfaces/mojarra/commit/f61935cd39f34329fbf27b1972a506fbdd0ab4d4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/javaserverfaces/mojarra/compare/2.2.19...2.2.20", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse-ee4j/mojarra/commit/8f70f2bd024f00ecd5b3dcca45df73edda29dcee"}}