{"buggy_code": ["/* radare - LGPL - Copyright 2010-2017 - nibble, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n\n#define bprintf if(bin->verbose)eprintf\n\ntypedef struct _ulebr {\n\tut8 *p;\n} ulebr;\n\n/* move into struct MACH0_(obj_t) *bin */\nstatic bool little_;\n\nstatic ut64 read_uleb128(ulebr *r, ut8 *end) {\n\tut64 result = 0;\n\tint bit = 0;\n\tut64 slice = 0;\n\tut8 *p = r->p;\n\tdo {\n\t\tif (p == end) {\n\t\t\teprintf (\"malformed uleb128\");\n\t\t\tbreak;\n\t\t}\n\t\tslice = *p & 0x7f;\n\t\tif (bit > 63) {\n\t\t\teprintf (\"uleb128 too big for uint64, bit=%d, result=0x%\"PFMT64x, bit, result);\n\t\t} else {\n\t\t\tresult |= (slice << bit);\n\t\t\tbit += 7;\n\t\t}\n\t} while (*p++ & 0x80);\n\tr->p = p;\n\treturn result;\n}\n\nstatic st64 read_sleb128(ulebr *r, ut8 *end) {\n\tst64 result = 0;\n\tint bit = 0;\n\tut8 byte = 0;\n\tut8 *p = r->p;\n\tdo {\n\t\tif (p == end) {\n\t\t\teprintf (\"malformed sleb128\");\n\t\t\tbreak;\n\t\t}\n\t\tbyte = *p++;\n\t\tresult |= (((st64)(byte & 0x7f)) << bit);\n\t\tbit += 7;\n\t} while (byte & 0x80);\n\t// sign extend negative numbers\n\tif ((byte & 0x40)) {\n\t\tresult |= (-1LL) << bit;\n\t}\n\tr->p = p;\n\treturn result;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t)* bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t)* bin, ut64 addr) {\n\tut64 segment_base, segment_size;\n\tint i;\n \n\tif (!bin->segs) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tsegment_base = (ut64)bin->segs[i].vmaddr;\n\t\tsegment_size = (ut64)bin->segs[i].vmsize;\n\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int init_hdr(struct MACH0_(obj_t)* bin) {\n\tut8 magicbytes[4]= {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == 0xfeedface) { \n\t\tbin->big_endian = true;\n\t} else if (r_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxxxddx \"\n\t\t\"magic cputype cpusubtype filetype ncmds sizeofcmds flags\", 0);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\tsdb_set (bin->kv, \"mach_filetype.cparse\", \"enum mach_filetype{MH_OBJECT=1,\"\n\t\t\t\"MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6,\"\n\t\t\t\"MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10,\"\n\t\t\t\"MH_KEXT_BUNDLE=11}\"\n\t\t\t,0);\n\tsdb_set (bin->kv, \"mach_flags.cparse\", \"enum mach_flags{MH_NOUNDEFS=1,\"\n\t\t\t\"MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10,\"\n\t\t\t\"MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80,\"\n\t\t\t\"MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400,\"\n\t\t\t\"MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000,\"\n\t\t\t\"MH_SUBSECTIONS_VIA_SYMBOLS=0x2000,\"\n\t\t\t\"MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000,\"\n\t\t\t\"MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000,\"\n\t\t\t\"MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000,\"\n\t\t\t\"MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000,\"\n\t\t\t\"MH_DEAD_STRIPPABLE_DYLIB=0x400000,\"\n\t\t\t\"MH_HAS_TLV_DESCRIPTORS=0x800000,\"\n\t\t\t\"MH_NO_HEAP_EXECUTION=0x1000000 }\",0);\n\treturn true;\n}\n\nstatic int parse_segments(struct MACH0_(obj_t)* bin, ut64 off) {\n\tint i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tperror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tsdb_num_set (bin->kv, sdb_fmt (0, \"mach0_segment_%d.offset\", j), off, 0);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"xd[16]zxxxxoodx \"\n\t\t\"cmd cmdsize segname vmaddr vmsize \"\n\t\t\"fileoff filesize maxprot initprot nsects flags\", 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tperror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\tbin->sects[k].segname[15] = 0;\n\t\t\ti += 16;\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tint i;\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\n\tif (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size) { \n\t\treturn false;\n\t}\t\n\tint len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tbprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (&symt[0], bin->big_endian);\n\tst.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);\n\tst.symoff = r_read_ble32 (&symt[8], bin->big_endian);\n\tst.nsyms = r_read_ble32 (&symt[12], bin->big_endian);\n\tst.stroff = r_read_ble32 (&symt[16], bin->big_endian);\n\tst.strsize = r_read_ble32 (&symt[20], bin->big_endian);\n\n\tbin->symtab = NULL;\n\tbin->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {\n\t\tbin->nsymtab = st.nsyms;\n\t\tif (st.stroff > bin->size || st.stroff + st.strsize > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tbprintf(\"fail2\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tbprintf(\"fail3\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (st.symoff > bin->size || st.symoff + size_sym > bin->size) {\n\t\t\tbprintf(\"fail4\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!(bin->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tperror (\"calloc (symstr)\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tbprintf (\"Error: read (symstr)\\n\");\n\t\t\tR_FREE (bin->symstr);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(bin->symtab = calloc (bin->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tperror (\"calloc (symtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))), \n\t\t\t\t\t\t\t\tnlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tbprintf (\"Error: read (nlist)\\n\");\n\t\t\t\tR_FREE (bin->symtab);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tbin->symtab[i].n_strx = r_read_ble32 (&nlst[0], bin->big_endian);\n\t\t\tbin->symtab[i].n_type = r_read_ble8 (&nlst[4]);\n\t\t\tbin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);\n\t\t\tbin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);\n#else\n\t\t\tbin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int parse_dysymtab(struct MACH0_(obj_t)* bin, ut64 off) {\n\tint len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at(bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof(struct dylib_table_of_contents)))) {\n\t\t\tperror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at(bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tif (bin->nmodtab > 0) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof(struct MACH0_(dylib_module))))) {\n\t\t\tperror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at(bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof(ut32)))) {\n\t\t\tperror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {};\n\tstruct super_blob_t super = {};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_read_ble32 (bin->b->buf + data, little_);\n\tsuper.blob.length = r_read_ble32 (bin->b->buf + data + 4, little_);\n\tsuper.count = r_read_ble32 (bin->b->buf + data + 8, little_);\n\tfor (i = 0; i < super.count; ++i) {\n\t\tif ((ut8 *)(bin->b->buf + data + i) > (ut8 *)(bin->b->buf + bin->size)) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, little_);\n\t\tidx.offset = r_read_ble32 (&bi.offset, little_);\n\t\tif (idx.type == CSSLOT_ENTITLEMENTS) {\n\t\t\tut64 off = data + idx.offset;\n\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstruct blob_t entitlements = {}; \n\t\t\tentitlements.magic = r_read_ble32 (bin->b->buf + off, little_);\n\t\t\tentitlements.length = r_read_ble32 (bin->b->buf + off + 4, little_);\n\t\t\tlen = entitlements.length - sizeof(struct blob_t);\n\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\tif (bin->signature) {\n\t\t\t\t\tut8 *src = bin->b->buf + off + sizeof (struct blob_t);\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < bin->b->length) {\n\t\t\t\t\t\tmemcpy (bin->signature, src, len);\n\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t}\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t)* bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size)\n\t\treturn false;\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1)\n\t\tgoto wrong_read;\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tflavor = r_read_ble32 (bin->b->buf + off + sizeof(struct thread_command), bin->big_endian);\n\tif (len == -1)\n\t\tgoto wrong_read;\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size || \\\n\t  off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size)\n\t\treturn false;\n\n\t// TODO: use count for checks\n\tcount = r_read_ble32 (bin->b->buf + off + sizeof (struct thread_command) + sizeof(flavor),\n\t\t\t\tbin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size)\n\t\treturn false;\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian?\"40I\":\"40i\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian?\"34LI3LI\":\"34li3li\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size)\n\t\t\treturn false;\n\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian?\"17I\":\"17i\", 1)) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((len = r_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian?\"34LI1I\":\"34Li1i\", 1)) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts (struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tut8 *buf;\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tbuf = calloc (1, fc.datasize + 1);\n\tif (!buf) {\n\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\treturn false;\n\t}\n\tbin->func_size = fc.datasize;\n\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\tfree (buf);\n\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\tif (len != fc.datasize) {\n\t\tfree (buf);\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\treturn false;\n\t}\n\tbuf[fc.datasize] = 0; // null-terminated buffer\n\tbin->func_start = buf;\n\treturn true;\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size)\n\t\treturn false;\n\tlib = bin->nlibs - 1;\n\n\tif (!(bin->libs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH))) {\n\t\tperror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size)\n\t\treturn false;\n\n\tlen = r_buf_read_at (bin->b, off+dl.dylib.name, (ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH);\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\t}\n\treturn \"\";\n}\n\nstatic int init_items(struct MACH0_(obj_t)* bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)); \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size){\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1.\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\t// TODO: a different format for each cmd\n\t\tsdb_num_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.offset\", i), off, 0);\n\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.format\", i), \"xd cmd size\", 0);\n\n\t\t//bprintf (\"%d\\n\", lc.cmd);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\t// TODO table of non-instructions in __text\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab(bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of obunds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);\n\t\t\t\tfree (bin->intrp);\n\t\t\t\tbin->intrp = NULL;\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n\n\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t} else {\n\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int init(struct MACH0_(obj_t)* bin) {\n\tunion {\n\t\tut16 word;\n\t\tut8 byte[2];\n\t} endian = { 1 };\n\tlittle_ = endian.byte[0];\n\tif (!init_hdr(bin)) {\n\t\tbprintf (\"Warning: File is not MACH0\\n\");\n\t\treturn false;\n\t}\n\tif (!init_items (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tbin->baddr = MACH0_(get_baddr)(bin);\n\treturn true;\n}\n\nvoid* MACH0_(mach0_free)(struct MACH0_(obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->segs);\n\tfree (bin->sects);\n\tfree (bin->symtab);\n\tfree (bin->symstr);\n\tfree (bin->indirectsyms);\n\tfree (bin->imports_by_ord);\n\tfree (bin->dyld_info);\n\tfree (bin->toc);\n\tfree (bin->modtab);\n\tfree (bin->libs);\n\tfree (bin->func_start);\n\tfree (bin->signature);\n\tr_buf_free (bin->b);\n\tfree (bin);\n\treturn NULL;\n}\n\nstruct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file, bool verbose) {\n\tut8 *buf;\n\tstruct MACH0_(obj_t) *bin;\n\tif (!(bin = malloc (sizeof (struct MACH0_(obj_t))))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct MACH0_(obj_t)));\n\tbin->verbose = verbose;\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp(file, &bin->size)))\n\t\treturn MACH0_(mach0_free)(bin);\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes(bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init(bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\treturn bin;\n}\n\nstruct MACH0_(obj_t)* MACH0_(new_buf)(RBuffer *buf, bool verbose) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\tbin->b = r_buf_new ();\n\tbin->size = buf->length;\n\tbin->verbose = verbose;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, bin->size)){\n\t\treturn MACH0_(mach0_free) (bin);\n\t}\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm (int x) {\n\tint r = 0;\n\tif (x&1) r |= 4;\n\tif (x&2) r |= 2;\n\tif (x&4) r |= 1;\n\treturn r;\n}\n\nstruct section_t* MACH0_(get_sections)(struct MACH0_(obj_t)* bin) {\n\tstruct section_t *sections;\n\tchar segname[32], sectname[32];\n\tint i, j, to;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, sizeof (sectname) - 1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].srwx = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = malloc ((bin->nsects + 1) * sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, sizeof (sectname) - 1);\n\t\t// hack to support multiple sections with same name\n\t\t// snprintf (segname, sizeof (segname), \"%d\", i); // wtf\n\t\tsnprintf (segname, sizeof (segname), \"%d.%s\", i, bin->sects[i].segname);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].srwx = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// XXX: if two sections have the same name are merged :O\n\t\t// XXX: append section index in flag name maybe?\n\t\t// XXX: do not load out of bound sections?\n\t\t// XXX: load segments instead of sections? what about PAGEZERO and ...\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name), \"%s.%s\", segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic int parse_import_stub(struct MACH0_(obj_t)* bin, struct symbol_t *symbol, int idx) {\n\tint i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name[0] = '\\0';\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tnsyms = (int)(bin->sects[i].size / bin->sects[i].reserved2);\n\t\t\tif (nsyms > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t}\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tsymbol->offset = bin->sects[i].offset + j * bin->sects[i].reserved2;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + j * bin->sects[i].reserved2;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr+stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsnprintf (symbol->name, R_BIN_MACH0_STRING_LENGTH, \"imp.%s\", symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#if 0\nstatic ut64 get_text_base(struct MACH0_(obj_t)* bin) {\n\tut64 ret = 0LL;\n\tstruct section_t *sections;\n\tif ((sections = MACH0_(get_sections) (bin))) {\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (strstr(sections[i].name, \"text\")) {\n\t\t\t\tret =  sections[i].offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree (sections);\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int inSymtab(SdbHash *hash, struct symbol_t *symbols, const char *name, ut64 addr) {\n\tbool found;\n\tconst char *key = sdb_fmt (0, \"%s.%\"PFMT64x, name, addr);\n\t(void)sdb_ht_find (hash, key, &found);\n\tif (found) {\n\t\treturn true;\n\t}\n\tsdb_ht_insert (hash, key, \"1\");\n\treturn false;\n}\n\nstruct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\t//ut64 text_base = get_text_base (bin);\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\t//symbols_count = bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof(struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof(struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr+stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH-1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i))\n\t\t\tsymbols[j++].last = 0;\n\t}\n\n#if 1\n// symtab is wrongly parsed and produces dupped syms with incorrect vaddr */\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL; \n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\treturn NULL;\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym +i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"\";\n\t\t}\n\t\tif (!*symstr) {\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint len = 0;\n\t\t\tchar *symstr_dup = NULL;\n\t\t\tlen = bin->symstrlen - stridx;\n\t\t\timports[j].name[0] = 0;\n\t\t\tif (len > 0) {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tif ((unsigned char)symstr[i] == 0xff || !symstr[i]) {\n\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\tif (symstr_dup) {\n\t\t\t\t\tstrncpy (imports[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\t\t\timports[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\n\nstruct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n\tstruct reloc_t *relocs;\n\tint i = 0, len;\n\tulebr ur = {NULL};\n\tint wordsize = MACH0_(get_bits)(bin) / 8;\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes,*end, type = 0, rel_type = 0;\n\t\tint lib_ord, seg_idx = -1, sym_ord = -1;\n\t\tsize_t j, count, skip, bind_size, lazy_size;\n\t\tst64 addend = 0;\n\t\tut64 segmentAddress = 0LL;\n\t\tut64 addr = 0LL;\n\t\tut8 done = 0;\n\n#define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\n\t\tif (!bind_size || !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)\n\t\t\treturn NULL;\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)\n\t\t\treturn NULL;\n\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)\n\t\t\treturn NULL;\n\t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))\n\t\t\treturn NULL;\n\n\t\topcodes = calloc (1, bind_size + lazy_size + 1);\n\t\tif (!opcodes) {\n\t\t\tfree (relocs);\n\t\t\treturn NULL;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\ti = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tif (len < 1 || i < 1) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",\n\t\t\t(ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tfree (opcodes);\n\t\t\trelocs[i].last = 1;\n\t\t\treturn relocs;\n\t\t}\n\t\ti = 0;\n\t\t// that +2 is a minimum required for uleb128, this may be wrong,\n\t\t// the correct fix would be to make ULEB() must use rutil's\n\t\t// implementation that already checks for buffer boundaries\n\t\tfor (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {\n\t\t\tut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;\n\t\t\t++ur.p;\n\t\t\tswitch (op) {\n#define ULEB() read_uleb128 (&ur,end)\n#define SLEB() read_sleb128 (&ur,end)\n\t\t\tcase BIND_OPCODE_DONE:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\tlib_ord = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\tlib_ord = ULEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\tchar *sym_name = (char*)ur.p;\n\t\t\t\t//ut8 sym_flags = imm;\n\t\t\t\twhile (*ur.p++ && ur.p<end) {\n\t\t\t\t\t/* empty loop */\n\t\t\t\t}\n\t\t\t\tsym_ord = -1;\n\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < 0xffff)\n\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\tint stridx = 0;\n\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\tif (iundefsym>=0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\tint sidx = iundefsym +j;\n\t\t\t\t\t\tif (sidx<0 || sidx>= bin->nsymtab)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\tif (stridx < 0 || stridx >= bin->symstrlen)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp ((char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\ttype = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\taddend = SLEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\tseg_idx = imm;\n\t\t\t\tif (seg_idx < 0 || seg_idx >= bin->nsegs) {\n\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\taddr = 0LL;\n\t\t\t\t\treturn 0; // early exit to avoid future mayhem\n\t\t\t\t} else {\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + ULEB();\n\t\t\t\t\tsegmentAddress = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\taddr += ULEB();\n\t\t\t\tbreak;\n#define DO_BIND() do {\\\nif (sym_ord < 0 || seg_idx < 0 ) break;\\\nif (i >= (bind_size + lazy_size)) break;\\\nrelocs[i].addr = addr;\\\nrelocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\nif (type == BIND_TYPE_TEXT_PCREL32)\\\n\trelocs[i].addend = addend - (bin->baddr + addr);\\\nelse relocs[i].addend = addend;\\\n/* library ordinal ??? */ \\\nrelocs[i].ord = lib_ord;\\\nrelocs[i].ord = sym_ord;\\\nrelocs[i].type = rel_type;\\\nrelocs[i++].last = 0;\\\n} while (0)\n\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += ULEB() + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\tcount = ULEB();\n\t\t\t\tskip = ULEB();\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND();\n\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n#undef DO_BIND\n#undef ULEB\n#undef SLEB\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);\n\t\t\t\tfree (opcodes);\n\t\t\t\trelocs[i].last = 1;\n\t\t\t\treturn relocs;\n\t\t\t}\n\t\t}\n\t\tfree (opcodes);\n\t} else {\n\t\tint j;\n\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\t\treturn NULL;\n\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))\n\t\t\treturn NULL;\n\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n\t\t\t\trelocs[i].ord = j;\n\t\t\t\trelocs[i++].last = 0;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\trelocs[i].last = 1;\n\n\treturn relocs;\n}\n\nstruct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\n\tif (!bin->entry || entry->offset == 0) {\n\t\t// XXX: section name doesnt matters at all.. just check for exec flags\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\n\treturn entry;\n}\n\nstruct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}\n\nchar* MACH0_(get_class)(struct MACH0_(obj_t)* bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t} \n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header)* hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char* MACH0_(get_intrp)(struct MACH0_(obj_t)* bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char* MACH0_(get_os)(struct MACH0_(obj_t)* bin) {\n\tif (bin)\n\tswitch (bin->os) {\n\tcase 1: return \"osx\";\n\tcase 2: return \"ios\";\n\tcase 3: return \"watchos\";\n\tcase 4: return \"tvos\";\n\t}\n\treturn \"darwin\";\n}\n\nchar* MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t}\n\treturn strdup (archstr);\n}\n\nchar* MACH0_(get_cputype)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\treturn MACH0_(get_cputype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"unknown\");\n}\n\n// TODO: use const char*\n\nchar* MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr) {\n\t\tswitch (hdr->cputype) {\n\t\tcase CPU_TYPE_VAX:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_VAX780:\treturn strdup (\"vax780\");\n\t\t\tcase CPU_SUBTYPE_VAX785:\treturn strdup (\"vax785\");\n\t\t\tcase CPU_SUBTYPE_VAX750:\treturn strdup (\"vax750\");\n\t\t\tcase CPU_SUBTYPE_VAX730:\treturn strdup (\"vax730\");\n\t\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn strdup (\"uvaxI\");\n\t\t\tcase CPU_SUBTYPE_UVAXII:\treturn strdup (\"uvaxII\");\n\t\t\tcase CPU_SUBTYPE_VAX8200:\treturn strdup (\"vax8200\");\n\t\t\tcase CPU_SUBTYPE_VAX8500:\treturn strdup (\"vax8500\");\n\t\t\tcase CPU_SUBTYPE_VAX8600:\treturn strdup (\"vax8600\");\n\t\t\tcase CPU_SUBTYPE_VAX8650:\treturn strdup (\"vax8650\");\n\t\t\tcase CPU_SUBTYPE_VAX8800:\treturn strdup (\"vax8800\");\n\t\t\tcase CPU_SUBTYPE_UVAXIII:\treturn strdup (\"uvaxIII\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown vax subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC680x0:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_MC68030:\treturn strdup (\"mc68030\");\n\t\t\tcase CPU_SUBTYPE_MC68040:\treturn strdup (\"mc68040\");\n\t\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn strdup (\"mc68030 only\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc680x0 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_I386:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_386: \t\t\treturn strdup (\"386\");\n\t\t\tcase CPU_SUBTYPE_486: \t\t\treturn strdup (\"486\");\n\t\t\tcase CPU_SUBTYPE_486SX: \t\treturn strdup (\"486sx\");\n\t\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn strdup (\"Pentium\");\n\t\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn strdup (\"Pentium Pro\");\n\t\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn strdup (\"Pentium 3 M3\");\n\t\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn strdup (\"Pentium 3 M5\");\n\t\t\tcase CPU_SUBTYPE_CELERON: \t\treturn strdup (\"Celeron\");\n\t\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn strdup (\"Celeron Mobile\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn strdup (\"Pentium 3\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn strdup (\"Pentium 3 M\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn strdup (\"Pentium 3 Xeon\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn strdup (\"Pentium Mobile\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn strdup (\"Pentium 4\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn strdup (\"Pentium 4 M\");\n\t\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn strdup (\"Itanium\");\n\t\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn strdup (\"Itanium 2\");\n\t\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn strdup (\"Xeon\");\n\t\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn strdup (\"Xeon MP\");\n\t\t\tdefault:\t\t\t\treturn strdup (\"Unknown i386 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_X86_64:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn strdup (\"x86 64 all\");\n\t\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn strdup (\"x86 arch 1\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown x86 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC88000:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MC88100:\treturn strdup (\"mc88100\");\n\t\t\tcase CPU_SUBTYPE_MC88110:\treturn strdup (\"mc88110\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc88000 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC98000:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MC98601:\treturn strdup (\"mc98601\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc98000 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_HPPA:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn strdup (\"hppa7100\");\n\t\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn strdup (\"hppa7100LC\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown hppa subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_ARM64:\n\t\t\treturn strdup (\"v8\");\n\t\tcase CPU_TYPE_ARM:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\t\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\t\treturn strdup (\"v4t\");\n\t\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\t\treturn strdup (\"v5\");\n\t\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\t\treturn strdup (\"v6\");\n\t\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\t\treturn strdup (\"xscale\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\t\treturn strdup (\"v7\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\t\treturn strdup (\"v7f\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\t\treturn strdup (\"v7s\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\t\treturn strdup (\"v7k\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\t\treturn strdup (\"v7m\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\t\treturn strdup (\"v7em\");\n\t\t\tdefault:\n\t\t\t\treturn r_str_newf (\"unknown ARM subtype %d\", hdr->cpusubtype & 0xff);\n\t\t\t}\n\t\tcase CPU_TYPE_SPARC:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn strdup (\"all\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown sparc subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MIPS:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn strdup (\"r2300\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn strdup (\"r2600\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn strdup (\"r2800\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn strdup (\"r2000a\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn strdup (\"r2000\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn strdup (\"r3000a\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn strdup (\"r3000\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mips subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_I860:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_I860_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_I860_860:\treturn strdup (\"860\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown i860 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_POWERPC:\n\t\tcase CPU_TYPE_POWERPC64:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn strdup (\"601\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn strdup (\"602\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn strdup (\"603\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn strdup (\"603e\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn strdup (\"603ev\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn strdup (\"604\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn strdup (\"604e\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn strdup (\"620\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn strdup (\"750\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn strdup (\"7400\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn strdup (\"7450\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn strdup (\"970\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown ppc subtype\");\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup (\"Unknown cputype\");\n}\n\n\nchar* MACH0_(get_cpusubtype)(struct MACH0_(obj_t)* bin) { \n\tif (bin) {\n\t\treturn MACH0_(get_cpusubtype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"Unknown\");\n}\n\nint MACH0_(is_pie)(struct MACH0_(obj_t)* bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nint MACH0_(has_nx)(struct MACH0_(obj_t)* bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\n\nchar* MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar* MACH0_(get_filetype)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\treturn MACH0_(get_filetype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *file) {\n\tRBuffer *buf = file->buf;\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(buf);\n\teprintf (\"0x00000000  Magic       0x%x\\n\", mh->magic);\n\teprintf (\"0x00000004  CpuType     0x%x\\n\", mh->cputype);\n\teprintf (\"0x00000008  CpuSubType  0x%x\\n\", mh->cpusubtype);\n\teprintf (\"0x0000000c  FileType    0x%x\\n\", mh->filetype);\n\teprintf (\"0x00000010  nCmds       %d\\n\", mh->ncmds);\n\teprintf (\"0x00000014  sizeOfCmds  %d\\n\", mh->sizeofcmds);\n\teprintf (\"0x00000018  Flags       0x%x\\n\", mh->flags);\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof(word)];\n#define READWORD() \\\n\t\taddr += 4; \\\n\t\tif (!r_buf_read_at (buf, addr, (ut8*)wordbuf, 4)) { \\\n\t\t\teprintf (\"Invalid address in buffer.\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\tword = r_read_le32 (wordbuf);\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\teprintf (\"\\nLoad Command %d\\n\", n);\n\t\tREADWORD();\n\t\teprintf (\"0x%08\"PFMT64x\"  cmd          0x%x %s\\n\",\n\t\t\taddr, word, cmd_to_string (word));\n\t\tREADWORD();\n\t\tword &= 0xFFFFFF;\n\t\teprintf (\"0x%08\"PFMT64x\"  cmdsize      %d\\n\", addr, word);\n\t\tif ((int)(word) < 1) {\n\t\t\teprintf (\"Invalid size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\taddr += word - 8;\n\t}\n}\n\nRList* MACH0_(mach_fields)(RBinFile *arch) {\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(arch->buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = 0;\n\n#define ROW(nam,siz,val,fmt) \\\n\tr_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (0, \"0x%08x\", val), fmt)); \\\n\taddr += 4;\n\n\tROW(\"hdr.magic\", 4, mh->magic, \"x\");\n\tROW(\"hdr.cputype\", 4, mh->cputype, NULL);\n\tROW(\"hdr.cpusubtype\", 4, mh->cpusubtype, NULL);\n\tROW(\"hdr.filetype\", 4, mh->filetype, NULL);\n\tROW(\"hdr.ncmds\", 4, mh->ncmds, NULL);\n\tROW(\"hdr.sizeofcmds\", 4, mh->sizeofcmds, NULL);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) * MACH0_(get_hdr_from_bytes)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) { \n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0 \n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof(struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2017 - nibble, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n\n#define bprintf if(bin->verbose)eprintf\n\ntypedef struct _ulebr {\n\tut8 *p;\n} ulebr;\n\n/* move into struct MACH0_(obj_t) *bin */\nstatic bool little_;\n\nstatic ut64 read_uleb128(ulebr *r, ut8 *end) {\n\tut64 result = 0;\n\tint bit = 0;\n\tut64 slice = 0;\n\tut8 *p = r->p;\n\tdo {\n\t\tif (p == end) {\n\t\t\teprintf (\"malformed uleb128\");\n\t\t\tbreak;\n\t\t}\n\t\tslice = *p & 0x7f;\n\t\tif (bit > 63) {\n\t\t\teprintf (\"uleb128 too big for uint64, bit=%d, result=0x%\"PFMT64x, bit, result);\n\t\t} else {\n\t\t\tresult |= (slice << bit);\n\t\t\tbit += 7;\n\t\t}\n\t} while (*p++ & 0x80);\n\tr->p = p;\n\treturn result;\n}\n\nstatic st64 read_sleb128(ulebr *r, ut8 *end) {\n\tst64 result = 0;\n\tint bit = 0;\n\tut8 byte = 0;\n\tut8 *p = r->p;\n\tdo {\n\t\tif (p == end) {\n\t\t\teprintf (\"malformed sleb128\");\n\t\t\tbreak;\n\t\t}\n\t\tbyte = *p++;\n\t\tresult |= (((st64)(byte & 0x7f)) << bit);\n\t\tbit += 7;\n\t} while (byte & 0x80);\n\t// sign extend negative numbers\n\tif ((byte & 0x40)) {\n\t\tresult |= (-1LL) << bit;\n\t}\n\tr->p = p;\n\treturn result;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t)* bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t)* bin, ut64 addr) {\n\tut64 segment_base, segment_size;\n\tint i;\n \n\tif (!bin->segs) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tsegment_base = (ut64)bin->segs[i].vmaddr;\n\t\tsegment_size = (ut64)bin->segs[i].vmsize;\n\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int init_hdr(struct MACH0_(obj_t)* bin) {\n\tut8 magicbytes[4]= {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32(magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == 0xfeedface) { \n\t\tbin->big_endian = true;\n\t} else if (r_read_le32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32(magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxxxddx \"\n\t\t\"magic cputype cpusubtype filetype ncmds sizeofcmds flags\", 0);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\tsdb_set (bin->kv, \"mach_filetype.cparse\", \"enum mach_filetype{MH_OBJECT=1,\"\n\t\t\t\"MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6,\"\n\t\t\t\"MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10,\"\n\t\t\t\"MH_KEXT_BUNDLE=11}\"\n\t\t\t,0);\n\tsdb_set (bin->kv, \"mach_flags.cparse\", \"enum mach_flags{MH_NOUNDEFS=1,\"\n\t\t\t\"MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10,\"\n\t\t\t\"MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80,\"\n\t\t\t\"MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400,\"\n\t\t\t\"MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000,\"\n\t\t\t\"MH_SUBSECTIONS_VIA_SYMBOLS=0x2000,\"\n\t\t\t\"MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000,\"\n\t\t\t\"MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000,\"\n\t\t\t\"MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000,\"\n\t\t\t\"MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000,\"\n\t\t\t\"MH_DEAD_STRIPPABLE_DYLIB=0x400000,\"\n\t\t\t\"MH_HAS_TLV_DESCRIPTORS=0x800000,\"\n\t\t\t\"MH_NO_HEAP_EXECUTION=0x1000000 }\",0);\n\treturn true;\n}\n\nstatic int parse_segments(struct MACH0_(obj_t)* bin, ut64 off) {\n\tint i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tperror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tsdb_num_set (bin->kv, sdb_fmt (0, \"mach0_segment_%d.offset\", j), off, 0);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"xd[16]zxxxxoodx \"\n\t\t\"cmd cmdsize segname vmaddr vmsize \"\n\t\t\"fileoff filesize maxprot initprot nsects flags\", 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tperror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\tbin->sects[k].segname[15] = 0;\n\t\t\ti += 16;\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tint i;\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\n\tif (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size) { \n\t\treturn false;\n\t}\t\n\tint len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tbprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (&symt[0], bin->big_endian);\n\tst.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);\n\tst.symoff = r_read_ble32 (&symt[8], bin->big_endian);\n\tst.nsyms = r_read_ble32 (&symt[12], bin->big_endian);\n\tst.stroff = r_read_ble32 (&symt[16], bin->big_endian);\n\tst.strsize = r_read_ble32 (&symt[20], bin->big_endian);\n\n\tbin->symtab = NULL;\n\tbin->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {\n\t\tbin->nsymtab = st.nsyms;\n\t\tif (st.stroff > bin->size || st.stroff + st.strsize > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tbprintf(\"fail2\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tbprintf(\"fail3\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (st.symoff > bin->size || st.symoff + size_sym > bin->size) {\n\t\t\tbprintf(\"fail4\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!(bin->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tperror (\"calloc (symstr)\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tbprintf (\"Error: read (symstr)\\n\");\n\t\t\tR_FREE (bin->symstr);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(bin->symtab = calloc (bin->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tperror (\"calloc (symtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))), \n\t\t\t\t\t\t\t\tnlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tbprintf (\"Error: read (nlist)\\n\");\n\t\t\t\tR_FREE (bin->symtab);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tbin->symtab[i].n_strx = r_read_ble32 (&nlst[0], bin->big_endian);\n\t\t\tbin->symtab[i].n_type = r_read_ble8 (&nlst[4]);\n\t\t\tbin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);\n\t\t\tbin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);\n#else\n\t\t\tbin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int parse_dysymtab(struct MACH0_(obj_t)* bin, ut64 off) {\n\tint len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at(bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof(struct dylib_table_of_contents)))) {\n\t\t\tperror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at(bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tif (bin->nmodtab > 0) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof(struct MACH0_(dylib_module))))) {\n\t\t\tperror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at(bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof(ut32)))) {\n\t\t\tperror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {};\n\tstruct super_blob_t super = {};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_read_ble32 (bin->b->buf + data, little_);\n\tsuper.blob.length = r_read_ble32 (bin->b->buf + data + 4, little_);\n\tsuper.count = r_read_ble32 (bin->b->buf + data + 8, little_);\n\tfor (i = 0; i < super.count; ++i) {\n\t\tif ((ut8 *)(bin->b->buf + data + i) > (ut8 *)(bin->b->buf + bin->size)) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, little_);\n\t\tidx.offset = r_read_ble32 (&bi.offset, little_);\n\t\tif (idx.type == CSSLOT_ENTITLEMENTS) {\n\t\t\tut64 off = data + idx.offset;\n\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstruct blob_t entitlements = {}; \n\t\t\tentitlements.magic = r_read_ble32 (bin->b->buf + off, little_);\n\t\t\tentitlements.length = r_read_ble32 (bin->b->buf + off + 4, little_);\n\t\t\tlen = entitlements.length - sizeof(struct blob_t);\n\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\tif (bin->signature) {\n\t\t\t\t\tut8 *src = bin->b->buf + off + sizeof (struct blob_t);\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < bin->b->length) {\n\t\t\t\t\t\tmemcpy (bin->signature, src, len);\n\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t}\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t)* bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size)\n\t\treturn false;\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1)\n\t\tgoto wrong_read;\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tflavor = r_read_ble32 (bin->b->buf + off + sizeof(struct thread_command), bin->big_endian);\n\tif (len == -1)\n\t\tgoto wrong_read;\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size || \\\n\t  off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size)\n\t\treturn false;\n\n\t// TODO: use count for checks\n\tcount = r_read_ble32 (bin->b->buf + off + sizeof (struct thread_command) + sizeof(flavor),\n\t\t\t\tbin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size)\n\t\treturn false;\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian?\"40I\":\"40i\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size)\n\t\t\t\treturn false;\n\t\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian?\"34LI3LI\":\"34li3li\", 1)) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size)\n\t\t\treturn false;\n\t\tif ((len = r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian?\"17I\":\"17i\", 1)) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif ((len = r_buf_fread_at(bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian?\"34LI1I\":\"34Li1i\", 1)) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts (struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tut8 *buf;\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tbuf = calloc (1, fc.datasize + 1);\n\tif (!buf) {\n\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\treturn false;\n\t}\n\tbin->func_size = fc.datasize;\n\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\tfree (buf);\n\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\tif (len != fc.datasize) {\n\t\tfree (buf);\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\treturn false;\n\t}\n\tbuf[fc.datasize] = 0; // null-terminated buffer\n\tbin->func_start = buf;\n\treturn true;\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t)* bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size)\n\t\treturn false;\n\tlib = bin->nlibs - 1;\n\n\tif (!(bin->libs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH))) {\n\t\tperror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size)\n\t\treturn false;\n\n\tlen = r_buf_read_at (bin->b, off+dl.dylib.name, (ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH);\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\t}\n\treturn \"\";\n}\n\nstatic int init_items(struct MACH0_(obj_t)* bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)); \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size){\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1.\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\t// TODO: a different format for each cmd\n\t\tsdb_num_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.offset\", i), off, 0);\n\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.format\", i), \"xd cmd size\", 0);\n\n\t\t//bprintf (\"%d\\n\", lc.cmd);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"data_in_code\", 0);\n\t\t\t// TODO table of non-instructions in __text\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab(bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of obunds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylinker\", 0);\n\t\t\t\tfree (bin->intrp);\n\t\t\t\tbin->intrp = NULL;\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf(\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tfree (bin->dyld_info);\n\t\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic int init(struct MACH0_(obj_t)* bin) {\n\tunion {\n\t\tut16 word;\n\t\tut8 byte[2];\n\t} endian = { 1 };\n\tlittle_ = endian.byte[0];\n\tif (!init_hdr(bin)) {\n\t\tbprintf (\"Warning: File is not MACH0\\n\");\n\t\treturn false;\n\t}\n\tif (!init_items (bin)) {\n\t\tbprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tbin->baddr = MACH0_(get_baddr)(bin);\n\treturn true;\n}\n\nvoid* MACH0_(mach0_free)(struct MACH0_(obj_t)* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tfree (bin->segs);\n\tfree (bin->sects);\n\tfree (bin->symtab);\n\tfree (bin->symstr);\n\tfree (bin->indirectsyms);\n\tfree (bin->imports_by_ord);\n\tfree (bin->dyld_info);\n\tfree (bin->toc);\n\tfree (bin->modtab);\n\tfree (bin->libs);\n\tfree (bin->func_start);\n\tfree (bin->signature);\n\tr_buf_free (bin->b);\n\tfree (bin);\n\treturn NULL;\n}\n\nstruct MACH0_(obj_t)* MACH0_(mach0_new)(const char* file, bool verbose) {\n\tut8 *buf;\n\tstruct MACH0_(obj_t) *bin;\n\tif (!(bin = malloc (sizeof (struct MACH0_(obj_t))))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct MACH0_(obj_t)));\n\tbin->verbose = verbose;\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp(file, &bin->size)))\n\t\treturn MACH0_(mach0_free)(bin);\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes(bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init(bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\treturn bin;\n}\n\nstruct MACH0_(obj_t)* MACH0_(new_buf)(RBuffer *buf, bool verbose) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\tbin->b = r_buf_new ();\n\tbin->size = buf->length;\n\tbin->verbose = verbose;\n\tif (!r_buf_set_bytes (bin->b, buf->buf, bin->size)){\n\t\treturn MACH0_(mach0_free) (bin);\n\t}\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm (int x) {\n\tint r = 0;\n\tif (x&1) r |= 4;\n\tif (x&2) r |= 2;\n\tif (x&4) r |= 1;\n\treturn r;\n}\n\nstruct section_t* MACH0_(get_sections)(struct MACH0_(obj_t)* bin) {\n\tstruct section_t *sections;\n\tchar segname[32], sectname[32];\n\tint i, j, to;\n\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, sizeof (sectname) - 1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].srwx = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = malloc ((bin->nsects + 1) * sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, sizeof (sectname) - 1);\n\t\t// hack to support multiple sections with same name\n\t\t// snprintf (segname, sizeof (segname), \"%d\", i); // wtf\n\t\tsnprintf (segname, sizeof (segname), \"%d.%s\", i, bin->sects[i].segname);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].srwx = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// XXX: if two sections have the same name are merged :O\n\t\t// XXX: append section index in flag name maybe?\n\t\t// XXX: do not load out of bound sections?\n\t\t// XXX: load segments instead of sections? what about PAGEZERO and ...\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name), \"%s.%s\", segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic int parse_import_stub(struct MACH0_(obj_t)* bin, struct symbol_t *symbol, int idx) {\n\tint i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn 0;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name[0] = '\\0';\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tnsyms = (int)(bin->sects[i].size / bin->sects[i].reserved2);\n\t\t\tif (nsyms > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t}\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tsymbol->offset = bin->sects[i].offset + j * bin->sects[i].reserved2;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + j * bin->sects[i].reserved2;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr+stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsnprintf (symbol->name, R_BIN_MACH0_STRING_LENGTH, \"imp.%s\", symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n#if 0\nstatic ut64 get_text_base(struct MACH0_(obj_t)* bin) {\n\tut64 ret = 0LL;\n\tstruct section_t *sections;\n\tif ((sections = MACH0_(get_sections) (bin))) {\n\t\tint i;\n\t\tfor (i = 0; !sections[i].last; i++) {\n\t\t\tif (strstr(sections[i].name, \"text\")) {\n\t\t\t\tret =  sections[i].offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree (sections);\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int inSymtab(SdbHash *hash, struct symbol_t *symbols, const char *name, ut64 addr) {\n\tbool found;\n\tconst char *key = sdb_fmt (0, \"%s.%\"PFMT64x, name, addr);\n\t(void)sdb_ht_find (hash, key, &found);\n\tif (found) {\n\t\treturn true;\n\t}\n\tsdb_ht_insert (hash, key, \"1\");\n\treturn false;\n}\n\nstruct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n\tconst char *symstr;\n\tstruct symbol_t *symbols;\n\tint from, to, i, j, s, stridx, symbols_size, symbols_count;\n\tSdbHash *hash;\n\t//ut64 text_base = get_text_base (bin);\n\n\tif (!bin || !bin->symtab || !bin->symstr) {\n\t\treturn NULL;\n\t}\n\t/* parse symbol table */\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\t//symbols_count = bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(symbols = calloc (1, symbols_size))) {\n\t\treturn NULL;\n\t}\n\thash = sdb_ht_new ();\n\tj = 0; // symbol_idx\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n#define OLD 1\n#if OLD\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to , symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (to, bin->nsymtab);\n#else\n\t\tfrom = R_MIN (R_MAX (0, from), symbols_size/sizeof(struct symbol_t));\n\t\tto = symbols_count; //symbols_size/sizeof(struct symbol_t);\n#endif\n\t\tint maxsymbols = symbols_size / sizeof(struct symbol_t);\n\t\tif (to > 0x500000) {\n\t\t\tbprintf (\"WARNING: corrupted mach0 header: symbol table is too big %d\\n\", to);\n\t\t\tfree (symbols);\n\t\t\tsdb_ht_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t}\n\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\t\tsymstr = (char*)bin->symstr+stridx;\n\t\t\t} else {\n\t\t\t\tsymstr = \"???\";\n\t\t\t}\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tint len = 0;\n\t\t\t\tlen = bin->symstrlen - stridx;\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tchar *symstr_dup = NULL;\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\t\t}\n\t\t\t\t\tif (!symstr_dup) {\n\t\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy (symbols[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH-1);\n\t\t\t\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t}\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN (bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub(bin, &symbols[j], i))\n\t\t\tsymbols[j++].last = 0;\n\t}\n\n#if 1\n// symtab is wrongly parsed and produces dupped syms with incorrect vaddr */\n\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n#if 0\n\t\tbprintf (\"stridx %d -> section %d type %d value = %d\\n\",\n\t\t\tst->n_strx, st->n_sect, st->n_type, st->n_value);\n#endif\n\t\tstridx = st->n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char*)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"???\";\n\t\t}\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1)\n\t\t\t/* is symbol */\n\t\t\tsymbols[j].addr = st->n_value; // + text_base;\n\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\t\t} else {\n\t\t\t\tsymbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL; \n\t\t\t}\n\t\t\tstrncpy (symbols[j].name, symstr, R_BIN_MACH0_STRING_LENGTH);\n\t\t\tsymbols[j].name[R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\t\t\tsymbols[j].last = 0;\n\t\t\tif (inSymtab (hash, symbols, symbols[j].name, symbols[j].addr)) {\n\t\t\t\tsymbols[j].name[0] = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\tsdb_ht_free (hash);\n\tsymbols[j].last = 1;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\treturn NULL;\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym +i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tif (stridx >= 0 && stridx < bin->symstrlen) {\n\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t} else {\n\t\t\tsymstr = \"\";\n\t\t}\n\t\tif (!*symstr) {\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint i = 0;\n\t\t\tint len = 0;\n\t\t\tchar *symstr_dup = NULL;\n\t\t\tlen = bin->symstrlen - stridx;\n\t\t\timports[j].name[0] = 0;\n\t\t\tif (len > 0) {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tif ((unsigned char)symstr[i] == 0xff || !symstr[i]) {\n\t\t\t\t\t\tlen = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsymstr_dup = r_str_ndup (symstr, len);\n\t\t\t\tif (symstr_dup) {\n\t\t\t\t\tstrncpy (imports[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\t\t\timports[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;\n\t\t\t\t\tfree (symstr_dup);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\n\nstruct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n\tstruct reloc_t *relocs;\n\tint i = 0, len;\n\tulebr ur = {NULL};\n\tint wordsize = MACH0_(get_bits)(bin) / 8;\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes,*end, type = 0, rel_type = 0;\n\t\tint lib_ord, seg_idx = -1, sym_ord = -1;\n\t\tsize_t j, count, skip, bind_size, lazy_size;\n\t\tst64 addend = 0;\n\t\tut64 segmentAddress = 0LL;\n\t\tut64 addr = 0LL;\n\t\tut8 done = 0;\n\n#define CASE(T) case (T / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\n\t\tif (!bind_size || !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, bind_size + lazy_size + 1);\n\t\tif (!opcodes) {\n\t\t\tfree (relocs);\n\t\t\treturn NULL;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\ti = r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tif (len < 1 || i < 1) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\",\n\t\t\t(ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tfree (opcodes);\n\t\t\trelocs[i].last = 1;\n\t\t\treturn relocs;\n\t\t}\n\t\ti = 0;\n\t\t// that +2 is a minimum required for uleb128, this may be wrong,\n\t\t// the correct fix would be to make ULEB() must use rutil's\n\t\t// implementation that already checks for buffer boundaries\n\t\tfor (ur.p = opcodes, end = opcodes + bind_size + lazy_size ; (ur.p+2 < end) && !done; ) {\n\t\t\tut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;\n\t\t\t++ur.p;\n\t\t\tswitch (op) {\n#define ULEB() read_uleb128 (&ur,end)\n#define SLEB() read_sleb128 (&ur,end)\n\t\t\tcase BIND_OPCODE_DONE:\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\tlib_ord = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\tlib_ord = ULEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\tchar *sym_name = (char*)ur.p;\n\t\t\t\t//ut8 sym_flags = imm;\n\t\t\t\twhile (*ur.p++ && ur.p<end) {\n\t\t\t\t\t/* empty loop */\n\t\t\t\t}\n\t\t\t\tsym_ord = -1;\n\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < 0xffff)\n\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\tint stridx = 0;\n\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\tif (iundefsym>=0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\tint sidx = iundefsym +j;\n\t\t\t\t\t\tif (sidx<0 || sidx>= bin->nsymtab)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\tif (stridx < 0 || stridx >= bin->symstrlen)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strcmp ((char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\ttype = imm;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\taddend = SLEB();\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\tseg_idx = imm;\n\t\t\t\tif (seg_idx < 0 || seg_idx >= bin->nsegs) {\n\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\taddr = 0LL;\n\t\t\t\t\treturn 0; // early exit to avoid future mayhem\n\t\t\t\t} else {\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + ULEB();\n\t\t\t\t\tsegmentAddress = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\taddr += ULEB();\n\t\t\t\tbreak;\n#define DO_BIND() do {\\\nif (sym_ord < 0 || seg_idx < 0 ) break;\\\nif (i >= (bind_size + lazy_size)) break;\\\nrelocs[i].addr = addr;\\\nrelocs[i].offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\nif (type == BIND_TYPE_TEXT_PCREL32)\\\n\trelocs[i].addend = addend - (bin->baddr + addr);\\\nelse relocs[i].addend = addend;\\\n/* library ordinal ??? */ \\\nrelocs[i].ord = lib_ord;\\\nrelocs[i].ord = sym_ord;\\\nrelocs[i].type = rel_type;\\\nrelocs[i++].last = 0;\\\n} while (0)\n\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += ULEB() + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tDO_BIND();\n\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\tbreak;\n\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\tcount = ULEB();\n\t\t\t\tskip = ULEB();\n\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\tif (addr >= segmentAddress) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND();\n\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t}\n\t\t\t\tbreak;\n#undef DO_BIND\n#undef ULEB\n#undef SLEB\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *ur.p);\n\t\t\t\tfree (opcodes);\n\t\t\t\trelocs[i].last = 1;\n\t\t\t\treturn relocs;\n\t\t\t}\n\t\t}\n\t\tfree (opcodes);\n\t} else {\n\t\tint j;\n\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n\t\t\t\trelocs[i].ord = j;\n\t\t\t\trelocs[i++].last = 0;\n\t\t\t}\n\t\t}\n\t}\nbeach:\n\trelocs[i].last = 1;\n\n\treturn relocs;\n}\n\nstruct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\n\tif (!bin->entry || entry->offset == 0) {\n\t\t// XXX: section name doesnt matters at all.. just check for exec flags\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nstruct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; ++i) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar* MACH0_(get_class)(struct MACH0_(obj_t)* bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t} \n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header)* hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char* MACH0_(get_intrp)(struct MACH0_(obj_t)* bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char* MACH0_(get_os)(struct MACH0_(obj_t)* bin) {\n\tif (bin)\n\tswitch (bin->os) {\n\tcase 1: return \"osx\";\n\tcase 2: return \"ios\";\n\tcase 3: return \"watchos\";\n\tcase 4: return \"tvos\";\n\t}\n\treturn \"darwin\";\n}\n\nchar* MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t}\n\treturn strdup (archstr);\n}\n\nchar* MACH0_(get_cputype)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\treturn MACH0_(get_cputype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"unknown\");\n}\n\n// TODO: use const char*\n\nchar* MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr) {\n\t\tswitch (hdr->cputype) {\n\t\tcase CPU_TYPE_VAX:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_VAX780:\treturn strdup (\"vax780\");\n\t\t\tcase CPU_SUBTYPE_VAX785:\treturn strdup (\"vax785\");\n\t\t\tcase CPU_SUBTYPE_VAX750:\treturn strdup (\"vax750\");\n\t\t\tcase CPU_SUBTYPE_VAX730:\treturn strdup (\"vax730\");\n\t\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn strdup (\"uvaxI\");\n\t\t\tcase CPU_SUBTYPE_UVAXII:\treturn strdup (\"uvaxII\");\n\t\t\tcase CPU_SUBTYPE_VAX8200:\treturn strdup (\"vax8200\");\n\t\t\tcase CPU_SUBTYPE_VAX8500:\treturn strdup (\"vax8500\");\n\t\t\tcase CPU_SUBTYPE_VAX8600:\treturn strdup (\"vax8600\");\n\t\t\tcase CPU_SUBTYPE_VAX8650:\treturn strdup (\"vax8650\");\n\t\t\tcase CPU_SUBTYPE_VAX8800:\treturn strdup (\"vax8800\");\n\t\t\tcase CPU_SUBTYPE_UVAXIII:\treturn strdup (\"uvaxIII\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown vax subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC680x0:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_MC68030:\treturn strdup (\"mc68030\");\n\t\t\tcase CPU_SUBTYPE_MC68040:\treturn strdup (\"mc68040\");\n\t\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn strdup (\"mc68030 only\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc680x0 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_I386:\n\t\t\tswitch (hdr->cpusubtype) {\n\t\t\tcase CPU_SUBTYPE_386: \t\t\treturn strdup (\"386\");\n\t\t\tcase CPU_SUBTYPE_486: \t\t\treturn strdup (\"486\");\n\t\t\tcase CPU_SUBTYPE_486SX: \t\treturn strdup (\"486sx\");\n\t\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn strdup (\"Pentium\");\n\t\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn strdup (\"Pentium Pro\");\n\t\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn strdup (\"Pentium 3 M3\");\n\t\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn strdup (\"Pentium 3 M5\");\n\t\t\tcase CPU_SUBTYPE_CELERON: \t\treturn strdup (\"Celeron\");\n\t\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn strdup (\"Celeron Mobile\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn strdup (\"Pentium 3\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn strdup (\"Pentium 3 M\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn strdup (\"Pentium 3 Xeon\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn strdup (\"Pentium Mobile\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn strdup (\"Pentium 4\");\n\t\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn strdup (\"Pentium 4 M\");\n\t\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn strdup (\"Itanium\");\n\t\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn strdup (\"Itanium 2\");\n\t\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn strdup (\"Xeon\");\n\t\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn strdup (\"Xeon MP\");\n\t\t\tdefault:\t\t\t\treturn strdup (\"Unknown i386 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_X86_64:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn strdup (\"x86 64 all\");\n\t\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn strdup (\"x86 arch 1\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown x86 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC88000:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MC88100:\treturn strdup (\"mc88100\");\n\t\t\tcase CPU_SUBTYPE_MC88110:\treturn strdup (\"mc88110\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc88000 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MC98000:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MC98601:\treturn strdup (\"mc98601\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mc98000 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_HPPA:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn strdup (\"hppa7100\");\n\t\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn strdup (\"hppa7100LC\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown hppa subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_ARM64:\n\t\t\treturn strdup (\"v8\");\n\t\tcase CPU_TYPE_ARM:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\t\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\t\treturn strdup (\"v4t\");\n\t\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\t\treturn strdup (\"v5\");\n\t\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\t\treturn strdup (\"v6\");\n\t\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\t\treturn strdup (\"xscale\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\t\treturn strdup (\"v7\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\t\treturn strdup (\"v7f\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\t\treturn strdup (\"v7s\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\t\treturn strdup (\"v7k\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\t\treturn strdup (\"v7m\");\n\t\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\t\treturn strdup (\"v7em\");\n\t\t\tdefault:\n\t\t\t\treturn r_str_newf (\"unknown ARM subtype %d\", hdr->cpusubtype & 0xff);\n\t\t\t}\n\t\tcase CPU_TYPE_SPARC:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn strdup (\"all\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown sparc subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_MIPS:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn strdup (\"r2300\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn strdup (\"r2600\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn strdup (\"r2800\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn strdup (\"r2000a\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn strdup (\"r2000\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn strdup (\"r3000a\");\n\t\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn strdup (\"r3000\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown mips subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_I860:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_I860_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_I860_860:\treturn strdup (\"860\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown i860 subtype\");\n\t\t\t}\n\t\tcase CPU_TYPE_POWERPC:\n\t\tcase CPU_TYPE_POWERPC64:\n\t\t\tswitch (hdr->cpusubtype & 0xff) {\n\t\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn strdup (\"all\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn strdup (\"601\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn strdup (\"602\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn strdup (\"603\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn strdup (\"603e\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn strdup (\"603ev\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn strdup (\"604\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn strdup (\"604e\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn strdup (\"620\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn strdup (\"750\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn strdup (\"7400\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn strdup (\"7450\");\n\t\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn strdup (\"970\");\n\t\t\tdefault:\t\t\treturn strdup (\"Unknown ppc subtype\");\n\t\t\t}\n\t\t}\n\t}\n\treturn strdup (\"Unknown cputype\");\n}\n\n\nchar* MACH0_(get_cpusubtype)(struct MACH0_(obj_t)* bin) { \n\tif (bin) {\n\t\treturn MACH0_(get_cpusubtype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"Unknown\");\n}\n\nint MACH0_(is_pie)(struct MACH0_(obj_t)* bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nint MACH0_(has_nx)(struct MACH0_(obj_t)* bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\n\nchar* MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar* MACH0_(get_filetype)(struct MACH0_(obj_t)* bin) {\n\tif (bin) {\n\t\treturn MACH0_(get_filetype_from_hdr) (&bin->hdr);\n\t}\n\treturn strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn 0;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *file) {\n\tRBuffer *buf = file->buf;\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(buf);\n\teprintf (\"0x00000000  Magic       0x%x\\n\", mh->magic);\n\teprintf (\"0x00000004  CpuType     0x%x\\n\", mh->cputype);\n\teprintf (\"0x00000008  CpuSubType  0x%x\\n\", mh->cpusubtype);\n\teprintf (\"0x0000000c  FileType    0x%x\\n\", mh->filetype);\n\teprintf (\"0x00000010  nCmds       %d\\n\", mh->ncmds);\n\teprintf (\"0x00000014  sizeOfCmds  %d\\n\", mh->sizeofcmds);\n\teprintf (\"0x00000018  Flags       0x%x\\n\", mh->flags);\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof(word)];\n#define READWORD() \\\n\t\taddr += 4; \\\n\t\tif (!r_buf_read_at (buf, addr, (ut8*)wordbuf, 4)) { \\\n\t\t\teprintf (\"Invalid address in buffer.\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\tword = r_read_le32 (wordbuf);\n\tfor (n = 0; n < mh->ncmds; n++) {\n\t\teprintf (\"\\nLoad Command %d\\n\", n);\n\t\tREADWORD();\n\t\teprintf (\"0x%08\"PFMT64x\"  cmd          0x%x %s\\n\",\n\t\t\taddr, word, cmd_to_string (word));\n\t\tREADWORD();\n\t\tword &= 0xFFFFFF;\n\t\teprintf (\"0x%08\"PFMT64x\"  cmdsize      %d\\n\", addr, word);\n\t\tif ((int)(word) < 1) {\n\t\t\teprintf (\"Invalid size\\n\");\n\t\t\tbreak;\n\t\t}\n\t\taddr += word - 8;\n\t}\n}\n\nRList* MACH0_(mach_fields)(RBinFile *arch) {\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(arch->buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = 0;\n\n#define ROW(nam,siz,val,fmt) \\\n\tr_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt (0, \"0x%08x\", val), fmt)); \\\n\taddr += 4;\n\n\tROW(\"hdr.magic\", 4, mh->magic, \"x\");\n\tROW(\"hdr.cputype\", 4, mh->cputype, NULL);\n\tROW(\"hdr.cpusubtype\", 4, mh->cpusubtype, NULL);\n\tROW(\"hdr.filetype\", 4, mh->filetype, NULL);\n\tROW(\"hdr.ncmds\", 4, mh->ncmds, NULL);\n\tROW(\"hdr.sizeofcmds\", 4, mh->sizeofcmds, NULL);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) * MACH0_(get_hdr_from_bytes)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) { \n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0 \n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof(struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n"], "filenames": ["libr/bin/format/mach0/mach0.c"], "buggy_code_start_loc": [1122], "buggy_code_end_loc": [2313], "fixing_code_start_loc": [1122], "fixing_code_end_loc": [2324], "type": "CWE-416", "message": "The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.", "other": {"cve": {"id": "CVE-2017-7946", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-18T20:59:00.200", "lastModified": "2017-04-21T15:22:10.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file."}, {"lang": "es", "value": "La funci\u00f3n get_relocs_64 en libr/bin/format/mach0/mach0.c en radare2 1.3.0 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n y ca\u00edda de aplicaci\u00f3n) a trav\u00e9s de un archivo Mach0 manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "6FEDA3B8-616C-42E1-A70A-D8ABE8DEF929"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/7301", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92"}}