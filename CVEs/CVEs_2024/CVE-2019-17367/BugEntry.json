{"buggy_code": ["-- Copyright 2008 Steven Barth <steven@midlink.org>\n-- Copyright 2008-2015 Jo-Philipp Wich <jow@openwrt.org>\n-- Licensed to the public under the Apache License 2.0.\n\nlocal fs = require \"nixio.fs\"\nlocal sys = require \"luci.sys\"\nlocal util = require \"luci.util\"\nlocal http = require \"luci.http\"\nlocal nixio = require \"nixio\", require \"nixio.util\"\n\nmodule(\"luci.dispatcher\", package.seeall)\ncontext = util.threadlocal()\nuci = require \"luci.model.uci\"\ni18n = require \"luci.i18n\"\n_M.fs = fs\n\n-- Index table\nlocal index = nil\n\n-- Fastindex\nlocal fi\n\n\nfunction build_url(...)\n\tlocal path = {...}\n\tlocal url = { http.getenv(\"SCRIPT_NAME\") or \"\" }\n\n\tlocal p\n\tfor _, p in ipairs(path) do\n\t\tif p:match(\"^[a-zA-Z0-9_%-%.%%/,;]+$\") then\n\t\t\turl[#url+1] = \"/\"\n\t\t\turl[#url+1] = p\n\t\tend\n\tend\n\n\tif #path == 0 then\n\t\turl[#url+1] = \"/\"\n\tend\n\n\treturn table.concat(url, \"\")\nend\n\nfunction _ordered_children(node)\n\tlocal name, child, children = nil, nil, {}\n\n\tfor name, child in pairs(node.nodes) do\n\t\tchildren[#children+1] = {\n\t\t\tname  = name,\n\t\t\tnode  = child,\n\t\t\torder = child.order or 100\n\t\t}\n\tend\n\n\ttable.sort(children, function(a, b)\n\t\tif a.order == b.order then\n\t\t\treturn a.name < b.name\n\t\telse\n\t\t\treturn a.order < b.order\n\t\tend\n\tend)\n\n\treturn children\nend\n\nfunction node_visible(node)\n   if node then\n\t  return not (\n\t\t (not node.title or #node.title == 0) or\n\t\t (not node.target or node.hidden == true) or\n\t\t (type(node.target) == \"table\" and node.target.type == \"firstchild\" and\n\t\t  (type(node.nodes) ~= \"table\" or not next(node.nodes)))\n\t  )\n   end\n   return false\nend\n\nfunction node_childs(node)\n\tlocal rv = { }\n\tif node then\n\t\tlocal _, child\n\t\tfor _, child in ipairs(_ordered_children(node)) do\n\t\t\tif node_visible(child.node) then\n\t\t\t\trv[#rv+1] = child.name\n\t\t\tend\n\t\tend\n\tend\n\treturn rv\nend\n\n\nfunction error404(message)\n\thttp.status(404, \"Not Found\")\n\tmessage = message or \"Not Found\"\n\n\tlocal function render()\n\t\tlocal template = require \"luci.template\"\n\t\ttemplate.render(\"error404\")\n\tend\n\n\tif not util.copcall(render) then\n\t\thttp.prepare_content(\"text/plain\")\n\t\thttp.write(message)\n\tend\n\n\treturn false\nend\n\nfunction error500(message)\n\tutil.perror(message)\n\tif not context.template_header_sent then\n\t\thttp.status(500, \"Internal Server Error\")\n\t\thttp.prepare_content(\"text/plain\")\n\t\thttp.write(message)\n\telse\n\t\trequire(\"luci.template\")\n\t\tif not util.copcall(luci.template.render, \"error500\", {message=message}) then\n\t\t\thttp.prepare_content(\"text/plain\")\n\t\t\thttp.write(message)\n\t\tend\n\tend\n\treturn false\nend\n\nfunction httpdispatch(request, prefix)\n\thttp.context.request = request\n\n\tlocal r = {}\n\tcontext.request = r\n\n\tlocal pathinfo = http.urldecode(request:getenv(\"PATH_INFO\") or \"\", true)\n\n\tif prefix then\n\t\tfor _, node in ipairs(prefix) do\n\t\t\tr[#r+1] = node\n\t\tend\n\tend\n\n\tlocal node\n\tfor node in pathinfo:gmatch(\"[^/%z]+\") do\n\t\tr[#r+1] = node\n\tend\n\n\tlocal stat, err = util.coxpcall(function()\n\t\tdispatch(context.request)\n\tend, error500)\n\n\thttp.close()\n\n\t--context._disable_memtrace()\nend\n\nlocal function require_post_security(target)\n\tif type(target) == \"table\" then\n\t\tif type(target.post) == \"table\" then\n\t\t\tlocal param_name, required_val, request_val\n\n\t\t\tfor param_name, required_val in pairs(target.post) do\n\t\t\t\trequest_val = http.formvalue(param_name)\n\n\t\t\t\tif (type(required_val) == \"string\" and\n\t\t\t\t    request_val ~= required_val) or\n\t\t\t\t   (required_val == true and request_val == nil)\n\t\t\t\tthen\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\n\t\t\treturn true\n\t\tend\n\n\t\treturn (target.post == true)\n\tend\n\n\treturn false\nend\n\nfunction test_post_security()\n\tif http.getenv(\"REQUEST_METHOD\") ~= \"POST\" then\n\t\thttp.status(405, \"Method Not Allowed\")\n\t\thttp.header(\"Allow\", \"POST\")\n\t\treturn false\n\tend\n\n\tif http.formvalue(\"token\") ~= context.authtoken then\n\t\thttp.status(403, \"Forbidden\")\n\t\tluci.template.render(\"csrftoken\")\n\t\treturn false\n\tend\n\n\treturn true\nend\n\nlocal function session_retrieve(sid, allowed_users)\n\tlocal sdat = util.ubus(\"session\", \"get\", { ubus_rpc_session = sid })\n\n\tif type(sdat) == \"table\" and\n\t   type(sdat.values) == \"table\" and\n\t   type(sdat.values.token) == \"string\" and\n\t   (not allowed_users or\n\t    util.contains(allowed_users, sdat.values.username))\n\tthen\n\t\tuci:set_session_id(sid)\n\t\treturn sid, sdat.values\n\tend\n\n\treturn nil, nil\nend\n\nlocal function session_setup(user, pass, allowed_users)\n\tif util.contains(allowed_users, user) then\n\t\tlocal login = util.ubus(\"session\", \"login\", {\n\t\t\tusername = user,\n\t\t\tpassword = pass,\n\t\t\ttimeout  = tonumber(luci.config.sauth.sessiontime)\n\t\t})\n\n\t\tlocal rp = context.requestpath\n\t\t\tand table.concat(context.requestpath, \"/\") or \"\"\n\n\t\tif type(login) == \"table\" and\n\t\t   type(login.ubus_rpc_session) == \"string\"\n\t\tthen\n\t\t\tutil.ubus(\"session\", \"set\", {\n\t\t\t\tubus_rpc_session = login.ubus_rpc_session,\n\t\t\t\tvalues = { token = sys.uniqueid(16) }\n\t\t\t})\n\n\t\t\tio.stderr:write(\"luci: accepted login on /%s for %s from %s\\n\"\n\t\t\t\t%{ rp, user, http.getenv(\"REMOTE_ADDR\") or \"?\" })\n\n\t\t\treturn session_retrieve(login.ubus_rpc_session)\n\t\tend\n\n\t\tio.stderr:write(\"luci: failed login on /%s for %s from %s\\n\"\n\t\t\t%{ rp, user, http.getenv(\"REMOTE_ADDR\") or \"?\" })\n\tend\n\n\treturn nil, nil\nend\n\nfunction dispatch(request)\n\t--context._disable_memtrace = require \"luci.debug\".trap_memtrace(\"l\")\n\tlocal ctx = context\n\tctx.path = request\n\n\tlocal conf = require \"luci.config\"\n\tassert(conf.main,\n\t\t\"/etc/config/luci seems to be corrupt, unable to find section 'main'\")\n\n\tlocal i18n = require \"luci.i18n\"\n\tlocal lang = conf.main.lang or \"auto\"\n\tif lang == \"auto\" then\n\t\tlocal aclang = http.getenv(\"HTTP_ACCEPT_LANGUAGE\") or \"\"\n\t\tfor aclang in aclang:gmatch(\"[%w_-]+\") do\n\t\t\tlocal country, culture = aclang:match(\"^([a-z][a-z])[_-]([a-zA-Z][a-zA-Z])$\")\n\t\t\tif country and culture then\n\t\t\t\tlocal cc = \"%s_%s\" %{ country, culture:lower() }\n\t\t\t\tif conf.languages[cc] then\n\t\t\t\t\tlang = cc\n\t\t\t\t\tbreak\n\t\t\t\telseif conf.languages[country] then\n\t\t\t\t\tlang = country\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telseif conf.languages[aclang] then\n\t\t\t\tlang = aclang\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tif lang == \"auto\" then\n\t\tlang = i18n.default\n\tend\n\ti18n.setlanguage(lang)\n\n\tlocal c = ctx.tree\n\tlocal stat\n\tif not c then\n\t\tc = createtree()\n\tend\n\n\tlocal track = {}\n\tlocal args = {}\n\tctx.args = args\n\tctx.requestargs = ctx.requestargs or args\n\tlocal n\n\tlocal preq = {}\n\tlocal freq = {}\n\n\tfor i, s in ipairs(request) do\n\t\tpreq[#preq+1] = s\n\t\tfreq[#freq+1] = s\n\t\tc = c.nodes[s]\n\t\tn = i\n\t\tif not c then\n\t\t\tbreak\n\t\tend\n\n\t\tutil.update(track, c)\n\n\t\tif c.leaf then\n\t\t\tbreak\n\t\tend\n\tend\n\n\tif c and c.leaf then\n\t\tfor j=n+1, #request do\n\t\t\targs[#args+1] = request[j]\n\t\t\tfreq[#freq+1] = request[j]\n\t\tend\n\tend\n\n\tctx.requestpath = ctx.requestpath or freq\n\tctx.path = preq\n\n\t-- Init template engine\n\tif (c and c.index) or not track.notemplate then\n\t\tlocal tpl = require(\"luci.template\")\n\t\tlocal media = track.mediaurlbase or luci.config.main.mediaurlbase\n\t\tif not pcall(tpl.Template, \"themes/%s/header\" % fs.basename(media)) then\n\t\t\tmedia = nil\n\t\t\tfor name, theme in pairs(luci.config.themes) do\n\t\t\t\tif name:sub(1,1) ~= \".\" and pcall(tpl.Template,\n\t\t\t\t \"themes/%s/header\" % fs.basename(theme)) then\n\t\t\t\t\tmedia = theme\n\t\t\t\tend\n\t\t\tend\n\t\t\tassert(media, \"No valid theme found\")\n\t\tend\n\n\t\tlocal function _ifattr(cond, key, val, noescape)\n\t\t\tif cond then\n\t\t\t\tlocal env = getfenv(3)\n\t\t\t\tlocal scope = (type(env.self) == \"table\") and env.self\n\t\t\t\tif type(val) == \"table\" then\n\t\t\t\t\tif not next(val) then\n\t\t\t\t\t\treturn ''\n\t\t\t\t\telse\n\t\t\t\t\t\tval = util.serialize_json(val)\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tval = tostring(val or\n\t\t\t\t\t(type(env[key]) ~= \"function\" and env[key]) or\n\t\t\t\t\t(scope and type(scope[key]) ~= \"function\" and scope[key]) or \"\")\n\n\t\t\t\tif noescape ~= true then\n\t\t\t\t\tval = util.pcdata(val)\n\t\t\t\tend\n\n\t\t\t\treturn string.format(' %s=\"%s\"', tostring(key), val)\n\t\t\telse\n\t\t\t\treturn ''\n\t\t\tend\n\t\tend\n\n\t\ttpl.context.viewns = setmetatable({\n\t\t   write       = http.write;\n\t\t   include     = function(name) tpl.Template(name):render(getfenv(2)) end;\n\t\t   translate   = i18n.translate;\n\t\t   translatef  = i18n.translatef;\n\t\t   export      = function(k, v) if tpl.context.viewns[k] == nil then tpl.context.viewns[k] = v end end;\n\t\t   striptags   = util.striptags;\n\t\t   pcdata      = util.pcdata;\n\t\t   media       = media;\n\t\t   theme       = fs.basename(media);\n\t\t   resource    = luci.config.main.resourcebase;\n\t\t   ifattr      = function(...) return _ifattr(...) end;\n\t\t   attr        = function(...) return _ifattr(true, ...) end;\n\t\t   url         = build_url;\n\t\t}, {__index=function(tbl, key)\n\t\t\tif key == \"controller\" then\n\t\t\t\treturn build_url()\n\t\t\telseif key == \"REQUEST_URI\" then\n\t\t\t\treturn build_url(unpack(ctx.requestpath))\n\t\t\telseif key == \"FULL_REQUEST_URI\" then\n\t\t\t\tlocal url = { http.getenv(\"SCRIPT_NAME\") or \"\", http.getenv(\"PATH_INFO\") }\n\t\t\t\tlocal query = http.getenv(\"QUERY_STRING\")\n\t\t\t\tif query and #query > 0 then\n\t\t\t\t\turl[#url+1] = \"?\"\n\t\t\t\t\turl[#url+1] = query\n\t\t\t\tend\n\t\t\t\treturn table.concat(url, \"\")\n\t\t\telseif key == \"token\" then\n\t\t\t\treturn ctx.authtoken\n\t\t\telse\n\t\t\t\treturn rawget(tbl, key) or _G[key]\n\t\t\tend\n\t\tend})\n\tend\n\n\ttrack.dependent = (track.dependent ~= false)\n\tassert(not track.dependent or not track.auto,\n\t\t\"Access Violation\\nThe page at '\" .. table.concat(request, \"/\") .. \"/' \" ..\n\t\t\"has no parent node so the access to this location has been denied.\\n\" ..\n\t\t\"This is a software bug, please report this message at \" ..\n\t\t\"https://github.com/openwrt/luci/issues\"\n\t)\n\n\tif track.sysauth and not ctx.authsession then\n\t\tlocal authen = track.sysauth_authenticator\n\t\tlocal _, sid, sdat, default_user, allowed_users\n\n\t\tif type(authen) == \"string\" and authen ~= \"htmlauth\" then\n\t\t\terror500(\"Unsupported authenticator %q configured\" % authen)\n\t\t\treturn\n\t\tend\n\n\t\tif type(track.sysauth) == \"table\" then\n\t\t\tdefault_user, allowed_users = nil, track.sysauth\n\t\telse\n\t\t\tdefault_user, allowed_users = track.sysauth, { track.sysauth }\n\t\tend\n\n\t\tif type(authen) == \"function\" then\n\t\t\t_, sid = authen(sys.user.checkpasswd, allowed_users)\n\t\telse\n\t\t\tsid = http.getcookie(\"sysauth\")\n\t\tend\n\n\t\tsid, sdat = session_retrieve(sid, allowed_users)\n\n\t\tif not (sid and sdat) and authen == \"htmlauth\" then\n\t\t\tlocal user = http.getenv(\"HTTP_AUTH_USER\")\n\t\t\tlocal pass = http.getenv(\"HTTP_AUTH_PASS\")\n\n\t\t\tif user == nil and pass == nil then\n\t\t\t\tuser = http.formvalue(\"luci_username\")\n\t\t\t\tpass = http.formvalue(\"luci_password\")\n\t\t\tend\n\n\t\t\tsid, sdat = session_setup(user, pass, allowed_users)\n\n\t\t\tif not sid then\n\t\t\t\tlocal tmpl = require \"luci.template\"\n\n\t\t\t\tcontext.path = {}\n\n\t\t\t\thttp.status(403, \"Forbidden\")\n\t\t\t\thttp.header(\"X-LuCI-Login-Required\", \"yes\")\n\t\t\t\ttmpl.render(track.sysauth_template or \"sysauth\", {\n\t\t\t\t\tduser = default_user,\n\t\t\t\t\tfuser = user\n\t\t\t\t})\n\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\thttp.header(\"Set-Cookie\", 'sysauth=%s; path=%s; HttpOnly%s' %{\n\t\t\t\tsid, build_url(), http.getenv(\"HTTPS\") == \"on\" and \"; secure\" or \"\"\n\t\t\t})\n\t\t\thttp.redirect(build_url(unpack(ctx.requestpath)))\n\t\tend\n\n\t\tif not sid or not sdat then\n\t\t\thttp.status(403, \"Forbidden\")\n\t\t\thttp.header(\"X-LuCI-Login-Required\", \"yes\")\n\t\t\treturn\n\t\tend\n\n\t\tctx.authsession = sid\n\t\tctx.authtoken = sdat.token\n\t\tctx.authuser = sdat.username\n\tend\n\n\tif track.cors and http.getenv(\"REQUEST_METHOD\") == \"OPTIONS\" then\n\t\tluci.http.status(200, \"OK\")\n\t\tluci.http.header(\"Access-Control-Allow-Origin\", http.getenv(\"HTTP_ORIGIN\") or \"*\")\n\t\tluci.http.header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n\t\treturn\n\tend\n\n\tif c and require_post_security(c.target) then\n\t\tif not test_post_security(c) then\n\t\t\treturn\n\t\tend\n\tend\n\n\tif track.setgroup then\n\t\tsys.process.setgroup(track.setgroup)\n\tend\n\n\tif track.setuser then\n\t\tsys.process.setuser(track.setuser)\n\tend\n\n\tlocal target = nil\n\tif c then\n\t\tif type(c.target) == \"function\" then\n\t\t\ttarget = c.target\n\t\telseif type(c.target) == \"table\" then\n\t\t\ttarget = c.target.target\n\t\tend\n\tend\n\n\tif c and (c.index or type(target) == \"function\") then\n\t\tctx.dispatched = c\n\t\tctx.requested = ctx.requested or ctx.dispatched\n\tend\n\n\tif c and c.index then\n\t\tlocal tpl = require \"luci.template\"\n\n\t\tif util.copcall(tpl.render, \"indexer\", {}) then\n\t\t\treturn true\n\t\tend\n\tend\n\n\tif type(target) == \"function\" then\n\t\tutil.copcall(function()\n\t\t\tlocal oldenv = getfenv(target)\n\t\t\tlocal module = require(c.module)\n\t\t\tlocal env = setmetatable({}, {__index=\n\n\t\t\tfunction(tbl, key)\n\t\t\t\treturn rawget(tbl, key) or module[key] or oldenv[key]\n\t\t\tend})\n\n\t\t\tsetfenv(target, env)\n\t\tend)\n\n\t\tlocal ok, err\n\t\tif type(c.target) == \"table\" then\n\t\t\tok, err = util.copcall(target, c.target, unpack(args))\n\t\telse\n\t\t\tok, err = util.copcall(target, unpack(args))\n\t\tend\n\t\tif not ok then\n\t\t\terror500(\"Failed to execute \" .. (type(c.target) == \"function\" and \"function\" or c.target.type or \"unknown\") ..\n\t\t\t         \" dispatcher target for entry '/\" .. table.concat(request, \"/\") .. \"'.\\n\" ..\n\t\t\t         \"The called action terminated with an exception:\\n\" .. tostring(err or \"(unknown)\"))\n\t\tend\n\telse\n\t\tlocal root = node()\n\t\tif not root or not root.target then\n\t\t\terror404(\"No root node was registered, this usually happens if no module was installed.\\n\" ..\n\t\t\t         \"Install luci-mod-admin-full and retry. \" ..\n\t\t\t         \"If the module is already installed, try removing the /tmp/luci-indexcache file.\")\n\t\telse\n\t\t\terror404(\"No page is registered at '/\" .. table.concat(request, \"/\") .. \"'.\\n\" ..\n\t\t\t         \"If this url belongs to an extension, make sure it is properly installed.\\n\" ..\n\t\t\t         \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\")\n\t\tend\n\tend\nend\n\nfunction createindex()\n\tlocal controllers = { }\n\tlocal base = \"%s/controller/\" % util.libpath()\n\tlocal _, path\n\n\tfor path in (fs.glob(\"%s*.lua\" % base) or function() end) do\n\t\tcontrollers[#controllers+1] = path\n\tend\n\n\tfor path in (fs.glob(\"%s*/*.lua\" % base) or function() end) do\n\t\tcontrollers[#controllers+1] = path\n\tend\n\n\tif indexcache then\n\t\tlocal cachedate = fs.stat(indexcache, \"mtime\")\n\t\tif cachedate then\n\t\t\tlocal realdate = 0\n\t\t\tfor _, obj in ipairs(controllers) do\n\t\t\t\tlocal omtime = fs.stat(obj, \"mtime\")\n\t\t\t\trealdate = (omtime and omtime > realdate) and omtime or realdate\n\t\t\tend\n\n\t\t\tif cachedate > realdate and sys.process.info(\"uid\") == 0 then\n\t\t\t\tassert(\n\t\t\t\t\tsys.process.info(\"uid\") == fs.stat(indexcache, \"uid\")\n\t\t\t\t\tand fs.stat(indexcache, \"modestr\") == \"rw-------\",\n\t\t\t\t\t\"Fatal: Indexcache is not sane!\"\n\t\t\t\t)\n\n\t\t\t\tindex = loadfile(indexcache)()\n\t\t\t\treturn index\n\t\t\tend\n\t\tend\n\tend\n\n\tindex = {}\n\n\tfor _, path in ipairs(controllers) do\n\t\tlocal modname = \"luci.controller.\" .. path:sub(#base+1, #path-4):gsub(\"/\", \".\")\n\t\tlocal mod = require(modname)\n\t\tassert(mod ~= true,\n\t\t       \"Invalid controller file found\\n\" ..\n\t\t       \"The file '\" .. path .. \"' contains an invalid module line.\\n\" ..\n\t\t       \"Please verify whether the module name is set to '\" .. modname ..\n\t\t       \"' - It must correspond to the file path!\")\n\n\t\tlocal idx = mod.index\n\t\tassert(type(idx) == \"function\",\n\t\t       \"Invalid controller file found\\n\" ..\n\t\t       \"The file '\" .. path .. \"' contains no index() function.\\n\" ..\n\t\t       \"Please make sure that the controller contains a valid \" ..\n\t\t       \"index function and verify the spelling!\")\n\n\t\tindex[modname] = idx\n\tend\n\n\tif indexcache then\n\t\tlocal f = nixio.open(indexcache, \"w\", 600)\n\t\tf:writeall(util.get_bytecode(index))\n\t\tf:close()\n\tend\nend\n\n-- Build the index before if it does not exist yet.\nfunction createtree()\n\tif not index then\n\t\tcreateindex()\n\tend\n\n\tlocal ctx  = context\n\tlocal tree = {nodes={}, inreq=true}\n\n\tctx.treecache = setmetatable({}, {__mode=\"v\"})\n\tctx.tree = tree\n\n\tlocal scope = setmetatable({}, {__index = luci.dispatcher})\n\n\tfor k, v in pairs(index) do\n\t\tscope._NAME = k\n\t\tsetfenv(v, scope)\n\t\tv()\n\tend\n\n\treturn tree\nend\n\nfunction assign(path, clone, title, order)\n\tlocal obj  = node(unpack(path))\n\tobj.nodes  = nil\n\tobj.module = nil\n\n\tobj.title = title\n\tobj.order = order\n\n\tsetmetatable(obj, {__index = _create_node(clone)})\n\n\treturn obj\nend\n\nfunction entry(path, target, title, order)\n\tlocal c = node(unpack(path))\n\n\tc.target = target\n\tc.title  = title\n\tc.order  = order\n\tc.module = getfenv(2)._NAME\n\n\treturn c\nend\n\n-- enabling the node.\nfunction get(...)\n\treturn _create_node({...})\nend\n\nfunction node(...)\n\tlocal c = _create_node({...})\n\n\tc.module = getfenv(2)._NAME\n\tc.auto = nil\n\n\treturn c\nend\n\nfunction lookup(...)\n\tlocal i, path = nil, {}\n\tfor i = 1, select('#', ...) do\n\t\tlocal name, arg = nil, tostring(select(i, ...))\n\t\tfor name in arg:gmatch(\"[^/]+\") do\n\t\t\tpath[#path+1] = name\n\t\tend\n\tend\n\n\tfor i = #path, 1, -1 do\n\t\tlocal node = context.treecache[table.concat(path, \".\", 1, i)]\n\t\tif node and (i == #path or node.leaf) then\n\t\t\treturn node, build_url(unpack(path))\n\t\tend\n\tend\nend\n\nfunction _create_node(path)\n\tif #path == 0 then\n\t\treturn context.tree\n\tend\n\n\tlocal name = table.concat(path, \".\")\n\tlocal c = context.treecache[name]\n\n\tif not c then\n\t\tlocal last = table.remove(path)\n\t\tlocal parent = _create_node(path)\n\n\t\tc = {nodes={}, auto=true, inreq=true}\n\n\t\tlocal _, n\n\t\tfor _, n in ipairs(path) do\n\t\t\tif context.path[_] ~= n then\n\t\t\t\tc.inreq = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tc.inreq = c.inreq and (context.path[#path + 1] == last)\n\n\t\tparent.nodes[last] = c\n\t\tcontext.treecache[name] = c\n\tend\n\n\treturn c\nend\n\n-- Subdispatchers --\n\nfunction _find_eligible_node(root, prefix, deep, types, descend)\n\tlocal children = _ordered_children(root)\n\n\tif not root.leaf and deep ~= nil then\n\t\tlocal sub_path = { unpack(prefix) }\n\n\t\tif deep == false then\n\t\t\tdeep = nil\n\t\tend\n\n\t\tlocal _, child\n\t\tfor _, child in ipairs(children) do\n\t\t\tsub_path[#prefix+1] = child.name\n\n\t\t\tlocal res_path = _find_eligible_node(child.node, sub_path,\n\t\t\t                                     deep, types, true)\n\n\t\t\tif res_path then\n\t\t\t\treturn res_path\n\t\t\tend\n\t\tend\n\tend\n\n\tif descend and\n\t   (not types or\n\t    (type(root.target) == \"table\" and\n\t     util.contains(types, root.target.type)))\n\tthen\n\t\treturn prefix\n\tend\nend\n\nfunction _find_node(recurse, types)\n\tlocal path = { unpack(context.path) }\n\tlocal name = table.concat(path, \".\")\n\tlocal node = context.treecache[name]\n\n\tpath = _find_eligible_node(node, path, recurse, types)\n\n\tif path then\n\t\tdispatch(path)\n\telse\n\t\trequire \"luci.template\".render(\"empty_node_placeholder\")\n\tend\nend\n\nfunction _firstchild()\n\treturn _find_node(false, nil)\nend\n\nfunction firstchild()\n\treturn { type = \"firstchild\", target = _firstchild }\nend\n\nfunction _firstnode()\n\treturn _find_node(true, { \"cbi\", \"form\", \"template\", \"arcombine\" })\nend\n\nfunction firstnode()\n\treturn { type = \"firstnode\", target = _firstnode }\nend\n\nfunction alias(...)\n\tlocal req = {...}\n\treturn function(...)\n\t\tfor _, r in ipairs({...}) do\n\t\t\treq[#req+1] = r\n\t\tend\n\n\t\tdispatch(req)\n\tend\nend\n\nfunction rewrite(n, ...)\n\tlocal req = {...}\n\treturn function(...)\n\t\tlocal dispatched = util.clone(context.dispatched)\n\n\t\tfor i=1,n do\n\t\t\ttable.remove(dispatched, 1)\n\t\tend\n\n\t\tfor i, r in ipairs(req) do\n\t\t\ttable.insert(dispatched, i, r)\n\t\tend\n\n\t\tfor _, r in ipairs({...}) do\n\t\t\tdispatched[#dispatched+1] = r\n\t\tend\n\n\t\tdispatch(dispatched)\n\tend\nend\n\n\nlocal function _call(self, ...)\n\tlocal func = getfenv()[self.name]\n\tassert(func ~= nil,\n\t       'Cannot resolve function \"' .. self.name .. '\". Is it misspelled or local?')\n\n\tassert(type(func) == \"function\",\n\t       'The symbol \"' .. self.name .. '\" does not refer to a function but data ' ..\n\t       'of type \"' .. type(func) .. '\".')\n\n\tif #self.argv > 0 then\n\t\treturn func(unpack(self.argv), ...)\n\telse\n\t\treturn func(...)\n\tend\nend\n\nfunction call(name, ...)\n\treturn {type = \"call\", argv = {...}, name = name, target = _call}\nend\n\nfunction post_on(params, name, ...)\n\treturn {\n\t\ttype = \"call\",\n\t\tpost = params,\n\t\targv = { ... },\n\t\tname = name,\n\t\ttarget = _call\n\t}\nend\n\nfunction post(...)\n\treturn post_on(true, ...)\nend\n\n\nlocal _template = function(self, ...)\n\trequire \"luci.template\".render(self.view)\nend\n\nfunction template(name)\n\treturn {type = \"template\", view = name, target = _template}\nend\n\n\nlocal _view = function(self, ...)\n\trequire \"luci.template\".render(\"view\", { view = self.view })\nend\n\nfunction view(name)\n\treturn {type = \"view\", view = name, target = _view}\nend\n\n\nlocal function _cbi(self, ...)\n\tlocal cbi = require \"luci.cbi\"\n\tlocal tpl = require \"luci.template\"\n\tlocal http = require \"luci.http\"\n\n\tlocal config = self.config or {}\n\tlocal maps = cbi.load(self.model, ...)\n\n\tlocal state = nil\n\n\tlocal i, res\n\tfor i, res in ipairs(maps) do\n\t\tif util.instanceof(res, cbi.SimpleForm) then\n\t\t\tio.stderr:write(\"Model %s returns SimpleForm but is dispatched via cbi(),\\n\"\n\t\t\t\t% self.model)\n\n\t\t\tio.stderr:write(\"please change %s to use the form() action instead.\\n\"\n\t\t\t\t% table.concat(context.request, \"/\"))\n\t\tend\n\n\t\tres.flow = config\n\t\tlocal cstate = res:parse()\n\t\tif cstate and (not state or cstate < state) then\n\t\t\tstate = cstate\n\t\tend\n\tend\n\n\tlocal function _resolve_path(path)\n\t\treturn type(path) == \"table\" and build_url(unpack(path)) or path\n\tend\n\n\tif config.on_valid_to and state and state > 0 and state < 2 then\n\t\thttp.redirect(_resolve_path(config.on_valid_to))\n\t\treturn\n\tend\n\n\tif config.on_changed_to and state and state > 1 then\n\t\thttp.redirect(_resolve_path(config.on_changed_to))\n\t\treturn\n\tend\n\n\tif config.on_success_to and state and state > 0 then\n\t\thttp.redirect(_resolve_path(config.on_success_to))\n\t\treturn\n\tend\n\n\tif config.state_handler then\n\t\tif not config.state_handler(state, maps) then\n\t\t\treturn\n\t\tend\n\tend\n\n\thttp.header(\"X-CBI-State\", state or 0)\n\n\tif not config.noheader then\n\t\ttpl.render(\"cbi/header\", {state = state})\n\tend\n\n\tlocal redirect\n\tlocal messages\n\tlocal applymap   = false\n\tlocal pageaction = true\n\tlocal parsechain = { }\n\n\tfor i, res in ipairs(maps) do\n\t\tif res.apply_needed and res.parsechain then\n\t\t\tlocal c\n\t\t\tfor _, c in ipairs(res.parsechain) do\n\t\t\t\tparsechain[#parsechain+1] = c\n\t\t\tend\n\t\t\tapplymap = true\n\t\tend\n\n\t\tif res.redirect then\n\t\t\tredirect = redirect or res.redirect\n\t\tend\n\n\t\tif res.pageaction == false then\n\t\t\tpageaction = false\n\t\tend\n\n\t\tif res.message then\n\t\t\tmessages = messages or { }\n\t\t\tmessages[#messages+1] = res.message\n\t\tend\n\tend\n\n\tfor i, res in ipairs(maps) do\n\t\tres:render({\n\t\t\tfirstmap   = (i == 1),\n\t\t\tredirect   = redirect,\n\t\t\tmessages   = messages,\n\t\t\tpageaction = pageaction,\n\t\t\tparsechain = parsechain\n\t\t})\n\tend\n\n\tif not config.nofooter then\n\t\ttpl.render(\"cbi/footer\", {\n\t\t\tflow          = config,\n\t\t\tpageaction    = pageaction,\n\t\t\tredirect      = redirect,\n\t\t\tstate         = state,\n\t\t\tautoapply     = config.autoapply,\n\t\t\ttrigger_apply = applymap\n\t\t})\n\tend\nend\n\nfunction cbi(model, config)\n\treturn {\n\t\ttype = \"cbi\",\n\t\tpost = { [\"cbi.submit\"] = true },\n\t\tconfig = config,\n\t\tmodel = model,\n\t\ttarget = _cbi\n\t}\nend\n\n\nlocal function _arcombine(self, ...)\n\tlocal argv = {...}\n\tlocal target = #argv > 0 and self.targets[2] or self.targets[1]\n\tsetfenv(target.target, self.env)\n\ttarget:target(unpack(argv))\nend\n\nfunction arcombine(trg1, trg2)\n\treturn {type = \"arcombine\", env = getfenv(), target = _arcombine, targets = {trg1, trg2}}\nend\n\n\nlocal function _form(self, ...)\n\tlocal cbi = require \"luci.cbi\"\n\tlocal tpl = require \"luci.template\"\n\tlocal http = require \"luci.http\"\n\n\tlocal maps = luci.cbi.load(self.model, ...)\n\tlocal state = nil\n\n\tlocal i, res\n\tfor i, res in ipairs(maps) do\n\t\tlocal cstate = res:parse()\n\t\tif cstate and (not state or cstate < state) then\n\t\t\tstate = cstate\n\t\tend\n\tend\n\n\thttp.header(\"X-CBI-State\", state or 0)\n\ttpl.render(\"header\")\n\tfor i, res in ipairs(maps) do\n\t\tres:render()\n\tend\n\ttpl.render(\"footer\")\nend\n\nfunction form(model)\n\treturn {\n\t\ttype = \"cbi\",\n\t\tpost = { [\"cbi.submit\"] = true },\n\t\tmodel = model,\n\t\ttarget = _form\n\t}\nend\n\ntranslate = i18n.translate\n\n-- This function does not actually translate the given argument but\n-- is used by build/i18n-scan.pl to find translatable entries.\nfunction _(text)\n\treturn text\nend\n"], "fixing_code": ["-- Copyright 2008 Steven Barth <steven@midlink.org>\n-- Copyright 2008-2015 Jo-Philipp Wich <jow@openwrt.org>\n-- Licensed to the public under the Apache License 2.0.\n\nlocal fs = require \"nixio.fs\"\nlocal sys = require \"luci.sys\"\nlocal util = require \"luci.util\"\nlocal http = require \"luci.http\"\nlocal nixio = require \"nixio\", require \"nixio.util\"\n\nmodule(\"luci.dispatcher\", package.seeall)\ncontext = util.threadlocal()\nuci = require \"luci.model.uci\"\ni18n = require \"luci.i18n\"\n_M.fs = fs\n\n-- Index table\nlocal index = nil\n\n-- Fastindex\nlocal fi\n\n\nfunction build_url(...)\n\tlocal path = {...}\n\tlocal url = { http.getenv(\"SCRIPT_NAME\") or \"\" }\n\n\tlocal p\n\tfor _, p in ipairs(path) do\n\t\tif p:match(\"^[a-zA-Z0-9_%-%.%%/,;]+$\") then\n\t\t\turl[#url+1] = \"/\"\n\t\t\turl[#url+1] = p\n\t\tend\n\tend\n\n\tif #path == 0 then\n\t\turl[#url+1] = \"/\"\n\tend\n\n\treturn table.concat(url, \"\")\nend\n\nfunction _ordered_children(node)\n\tlocal name, child, children = nil, nil, {}\n\n\tfor name, child in pairs(node.nodes) do\n\t\tchildren[#children+1] = {\n\t\t\tname  = name,\n\t\t\tnode  = child,\n\t\t\torder = child.order or 100\n\t\t}\n\tend\n\n\ttable.sort(children, function(a, b)\n\t\tif a.order == b.order then\n\t\t\treturn a.name < b.name\n\t\telse\n\t\t\treturn a.order < b.order\n\t\tend\n\tend)\n\n\treturn children\nend\n\nfunction node_visible(node)\n   if node then\n\t  return not (\n\t\t (not node.title or #node.title == 0) or\n\t\t (not node.target or node.hidden == true) or\n\t\t (type(node.target) == \"table\" and node.target.type == \"firstchild\" and\n\t\t  (type(node.nodes) ~= \"table\" or not next(node.nodes)))\n\t  )\n   end\n   return false\nend\n\nfunction node_childs(node)\n\tlocal rv = { }\n\tif node then\n\t\tlocal _, child\n\t\tfor _, child in ipairs(_ordered_children(node)) do\n\t\t\tif node_visible(child.node) then\n\t\t\t\trv[#rv+1] = child.name\n\t\t\tend\n\t\tend\n\tend\n\treturn rv\nend\n\n\nfunction error404(message)\n\thttp.status(404, \"Not Found\")\n\tmessage = message or \"Not Found\"\n\n\tlocal function render()\n\t\tlocal template = require \"luci.template\"\n\t\ttemplate.render(\"error404\")\n\tend\n\n\tif not util.copcall(render) then\n\t\thttp.prepare_content(\"text/plain\")\n\t\thttp.write(message)\n\tend\n\n\treturn false\nend\n\nfunction error500(message)\n\tutil.perror(message)\n\tif not context.template_header_sent then\n\t\thttp.status(500, \"Internal Server Error\")\n\t\thttp.prepare_content(\"text/plain\")\n\t\thttp.write(message)\n\telse\n\t\trequire(\"luci.template\")\n\t\tif not util.copcall(luci.template.render, \"error500\", {message=message}) then\n\t\t\thttp.prepare_content(\"text/plain\")\n\t\t\thttp.write(message)\n\t\tend\n\tend\n\treturn false\nend\n\nfunction httpdispatch(request, prefix)\n\thttp.context.request = request\n\n\tlocal r = {}\n\tcontext.request = r\n\n\tlocal pathinfo = http.urldecode(request:getenv(\"PATH_INFO\") or \"\", true)\n\n\tif prefix then\n\t\tfor _, node in ipairs(prefix) do\n\t\t\tr[#r+1] = node\n\t\tend\n\tend\n\n\tlocal node\n\tfor node in pathinfo:gmatch(\"[^/%z]+\") do\n\t\tr[#r+1] = node\n\tend\n\n\tlocal stat, err = util.coxpcall(function()\n\t\tdispatch(context.request)\n\tend, error500)\n\n\thttp.close()\n\n\t--context._disable_memtrace()\nend\n\nlocal function require_post_security(target, args)\n\tif type(target) == \"table\" and target.type == \"arcombine\" and type(target.targets) == \"table\" then\n\t\treturn require_post_security((type(args) == \"table\" and #args > 0) and target.targets[2] or target.targets[1], args)\n\tend\n\n\tif type(target) == \"table\" then\n\t\tif type(target.post) == \"table\" then\n\t\t\tlocal param_name, required_val, request_val\n\n\t\t\tfor param_name, required_val in pairs(target.post) do\n\t\t\t\trequest_val = http.formvalue(param_name)\n\n\t\t\t\tif (type(required_val) == \"string\" and\n\t\t\t\t    request_val ~= required_val) or\n\t\t\t\t   (required_val == true and request_val == nil)\n\t\t\t\tthen\n\t\t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\n\t\t\treturn true\n\t\tend\n\n\t\treturn (target.post == true)\n\tend\n\n\treturn false\nend\n\nfunction test_post_security()\n\tif http.getenv(\"REQUEST_METHOD\") ~= \"POST\" then\n\t\thttp.status(405, \"Method Not Allowed\")\n\t\thttp.header(\"Allow\", \"POST\")\n\t\treturn false\n\tend\n\n\tif http.formvalue(\"token\") ~= context.authtoken then\n\t\thttp.status(403, \"Forbidden\")\n\t\tluci.template.render(\"csrftoken\")\n\t\treturn false\n\tend\n\n\treturn true\nend\n\nlocal function session_retrieve(sid, allowed_users)\n\tlocal sdat = util.ubus(\"session\", \"get\", { ubus_rpc_session = sid })\n\n\tif type(sdat) == \"table\" and\n\t   type(sdat.values) == \"table\" and\n\t   type(sdat.values.token) == \"string\" and\n\t   (not allowed_users or\n\t    util.contains(allowed_users, sdat.values.username))\n\tthen\n\t\tuci:set_session_id(sid)\n\t\treturn sid, sdat.values\n\tend\n\n\treturn nil, nil\nend\n\nlocal function session_setup(user, pass, allowed_users)\n\tif util.contains(allowed_users, user) then\n\t\tlocal login = util.ubus(\"session\", \"login\", {\n\t\t\tusername = user,\n\t\t\tpassword = pass,\n\t\t\ttimeout  = tonumber(luci.config.sauth.sessiontime)\n\t\t})\n\n\t\tlocal rp = context.requestpath\n\t\t\tand table.concat(context.requestpath, \"/\") or \"\"\n\n\t\tif type(login) == \"table\" and\n\t\t   type(login.ubus_rpc_session) == \"string\"\n\t\tthen\n\t\t\tutil.ubus(\"session\", \"set\", {\n\t\t\t\tubus_rpc_session = login.ubus_rpc_session,\n\t\t\t\tvalues = { token = sys.uniqueid(16) }\n\t\t\t})\n\n\t\t\tio.stderr:write(\"luci: accepted login on /%s for %s from %s\\n\"\n\t\t\t\t%{ rp, user, http.getenv(\"REMOTE_ADDR\") or \"?\" })\n\n\t\t\treturn session_retrieve(login.ubus_rpc_session)\n\t\tend\n\n\t\tio.stderr:write(\"luci: failed login on /%s for %s from %s\\n\"\n\t\t\t%{ rp, user, http.getenv(\"REMOTE_ADDR\") or \"?\" })\n\tend\n\n\treturn nil, nil\nend\n\nfunction dispatch(request)\n\t--context._disable_memtrace = require \"luci.debug\".trap_memtrace(\"l\")\n\tlocal ctx = context\n\tctx.path = request\n\n\tlocal conf = require \"luci.config\"\n\tassert(conf.main,\n\t\t\"/etc/config/luci seems to be corrupt, unable to find section 'main'\")\n\n\tlocal i18n = require \"luci.i18n\"\n\tlocal lang = conf.main.lang or \"auto\"\n\tif lang == \"auto\" then\n\t\tlocal aclang = http.getenv(\"HTTP_ACCEPT_LANGUAGE\") or \"\"\n\t\tfor aclang in aclang:gmatch(\"[%w_-]+\") do\n\t\t\tlocal country, culture = aclang:match(\"^([a-z][a-z])[_-]([a-zA-Z][a-zA-Z])$\")\n\t\t\tif country and culture then\n\t\t\t\tlocal cc = \"%s_%s\" %{ country, culture:lower() }\n\t\t\t\tif conf.languages[cc] then\n\t\t\t\t\tlang = cc\n\t\t\t\t\tbreak\n\t\t\t\telseif conf.languages[country] then\n\t\t\t\t\tlang = country\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\telseif conf.languages[aclang] then\n\t\t\t\tlang = aclang\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\tif lang == \"auto\" then\n\t\tlang = i18n.default\n\tend\n\ti18n.setlanguage(lang)\n\n\tlocal c = ctx.tree\n\tlocal stat\n\tif not c then\n\t\tc = createtree()\n\tend\n\n\tlocal track = {}\n\tlocal args = {}\n\tctx.args = args\n\tctx.requestargs = ctx.requestargs or args\n\tlocal n\n\tlocal preq = {}\n\tlocal freq = {}\n\n\tfor i, s in ipairs(request) do\n\t\tpreq[#preq+1] = s\n\t\tfreq[#freq+1] = s\n\t\tc = c.nodes[s]\n\t\tn = i\n\t\tif not c then\n\t\t\tbreak\n\t\tend\n\n\t\tutil.update(track, c)\n\n\t\tif c.leaf then\n\t\t\tbreak\n\t\tend\n\tend\n\n\tif c and c.leaf then\n\t\tfor j=n+1, #request do\n\t\t\targs[#args+1] = request[j]\n\t\t\tfreq[#freq+1] = request[j]\n\t\tend\n\tend\n\n\tctx.requestpath = ctx.requestpath or freq\n\tctx.path = preq\n\n\t-- Init template engine\n\tif (c and c.index) or not track.notemplate then\n\t\tlocal tpl = require(\"luci.template\")\n\t\tlocal media = track.mediaurlbase or luci.config.main.mediaurlbase\n\t\tif not pcall(tpl.Template, \"themes/%s/header\" % fs.basename(media)) then\n\t\t\tmedia = nil\n\t\t\tfor name, theme in pairs(luci.config.themes) do\n\t\t\t\tif name:sub(1,1) ~= \".\" and pcall(tpl.Template,\n\t\t\t\t \"themes/%s/header\" % fs.basename(theme)) then\n\t\t\t\t\tmedia = theme\n\t\t\t\tend\n\t\t\tend\n\t\t\tassert(media, \"No valid theme found\")\n\t\tend\n\n\t\tlocal function _ifattr(cond, key, val, noescape)\n\t\t\tif cond then\n\t\t\t\tlocal env = getfenv(3)\n\t\t\t\tlocal scope = (type(env.self) == \"table\") and env.self\n\t\t\t\tif type(val) == \"table\" then\n\t\t\t\t\tif not next(val) then\n\t\t\t\t\t\treturn ''\n\t\t\t\t\telse\n\t\t\t\t\t\tval = util.serialize_json(val)\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\tval = tostring(val or\n\t\t\t\t\t(type(env[key]) ~= \"function\" and env[key]) or\n\t\t\t\t\t(scope and type(scope[key]) ~= \"function\" and scope[key]) or \"\")\n\n\t\t\t\tif noescape ~= true then\n\t\t\t\t\tval = util.pcdata(val)\n\t\t\t\tend\n\n\t\t\t\treturn string.format(' %s=\"%s\"', tostring(key), val)\n\t\t\telse\n\t\t\t\treturn ''\n\t\t\tend\n\t\tend\n\n\t\ttpl.context.viewns = setmetatable({\n\t\t   write       = http.write;\n\t\t   include     = function(name) tpl.Template(name):render(getfenv(2)) end;\n\t\t   translate   = i18n.translate;\n\t\t   translatef  = i18n.translatef;\n\t\t   export      = function(k, v) if tpl.context.viewns[k] == nil then tpl.context.viewns[k] = v end end;\n\t\t   striptags   = util.striptags;\n\t\t   pcdata      = util.pcdata;\n\t\t   media       = media;\n\t\t   theme       = fs.basename(media);\n\t\t   resource    = luci.config.main.resourcebase;\n\t\t   ifattr      = function(...) return _ifattr(...) end;\n\t\t   attr        = function(...) return _ifattr(true, ...) end;\n\t\t   url         = build_url;\n\t\t}, {__index=function(tbl, key)\n\t\t\tif key == \"controller\" then\n\t\t\t\treturn build_url()\n\t\t\telseif key == \"REQUEST_URI\" then\n\t\t\t\treturn build_url(unpack(ctx.requestpath))\n\t\t\telseif key == \"FULL_REQUEST_URI\" then\n\t\t\t\tlocal url = { http.getenv(\"SCRIPT_NAME\") or \"\", http.getenv(\"PATH_INFO\") }\n\t\t\t\tlocal query = http.getenv(\"QUERY_STRING\")\n\t\t\t\tif query and #query > 0 then\n\t\t\t\t\turl[#url+1] = \"?\"\n\t\t\t\t\turl[#url+1] = query\n\t\t\t\tend\n\t\t\t\treturn table.concat(url, \"\")\n\t\t\telseif key == \"token\" then\n\t\t\t\treturn ctx.authtoken\n\t\t\telse\n\t\t\t\treturn rawget(tbl, key) or _G[key]\n\t\t\tend\n\t\tend})\n\tend\n\n\ttrack.dependent = (track.dependent ~= false)\n\tassert(not track.dependent or not track.auto,\n\t\t\"Access Violation\\nThe page at '\" .. table.concat(request, \"/\") .. \"/' \" ..\n\t\t\"has no parent node so the access to this location has been denied.\\n\" ..\n\t\t\"This is a software bug, please report this message at \" ..\n\t\t\"https://github.com/openwrt/luci/issues\"\n\t)\n\n\tif track.sysauth and not ctx.authsession then\n\t\tlocal authen = track.sysauth_authenticator\n\t\tlocal _, sid, sdat, default_user, allowed_users\n\n\t\tif type(authen) == \"string\" and authen ~= \"htmlauth\" then\n\t\t\terror500(\"Unsupported authenticator %q configured\" % authen)\n\t\t\treturn\n\t\tend\n\n\t\tif type(track.sysauth) == \"table\" then\n\t\t\tdefault_user, allowed_users = nil, track.sysauth\n\t\telse\n\t\t\tdefault_user, allowed_users = track.sysauth, { track.sysauth }\n\t\tend\n\n\t\tif type(authen) == \"function\" then\n\t\t\t_, sid = authen(sys.user.checkpasswd, allowed_users)\n\t\telse\n\t\t\tsid = http.getcookie(\"sysauth\")\n\t\tend\n\n\t\tsid, sdat = session_retrieve(sid, allowed_users)\n\n\t\tif not (sid and sdat) and authen == \"htmlauth\" then\n\t\t\tlocal user = http.getenv(\"HTTP_AUTH_USER\")\n\t\t\tlocal pass = http.getenv(\"HTTP_AUTH_PASS\")\n\n\t\t\tif user == nil and pass == nil then\n\t\t\t\tuser = http.formvalue(\"luci_username\")\n\t\t\t\tpass = http.formvalue(\"luci_password\")\n\t\t\tend\n\n\t\t\tsid, sdat = session_setup(user, pass, allowed_users)\n\n\t\t\tif not sid then\n\t\t\t\tlocal tmpl = require \"luci.template\"\n\n\t\t\t\tcontext.path = {}\n\n\t\t\t\thttp.status(403, \"Forbidden\")\n\t\t\t\thttp.header(\"X-LuCI-Login-Required\", \"yes\")\n\t\t\t\ttmpl.render(track.sysauth_template or \"sysauth\", {\n\t\t\t\t\tduser = default_user,\n\t\t\t\t\tfuser = user\n\t\t\t\t})\n\n\t\t\t\treturn\n\t\t\tend\n\n\t\t\thttp.header(\"Set-Cookie\", 'sysauth=%s; path=%s; HttpOnly%s' %{\n\t\t\t\tsid, build_url(), http.getenv(\"HTTPS\") == \"on\" and \"; secure\" or \"\"\n\t\t\t})\n\t\t\thttp.redirect(build_url(unpack(ctx.requestpath)))\n\t\tend\n\n\t\tif not sid or not sdat then\n\t\t\thttp.status(403, \"Forbidden\")\n\t\t\thttp.header(\"X-LuCI-Login-Required\", \"yes\")\n\t\t\treturn\n\t\tend\n\n\t\tctx.authsession = sid\n\t\tctx.authtoken = sdat.token\n\t\tctx.authuser = sdat.username\n\tend\n\n\tif track.cors and http.getenv(\"REQUEST_METHOD\") == \"OPTIONS\" then\n\t\tluci.http.status(200, \"OK\")\n\t\tluci.http.header(\"Access-Control-Allow-Origin\", http.getenv(\"HTTP_ORIGIN\") or \"*\")\n\t\tluci.http.header(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\")\n\t\treturn\n\tend\n\n\tif c and require_post_security(c.target, args) then\n\t\tif not test_post_security(c) then\n\t\t\treturn\n\t\tend\n\tend\n\n\tif track.setgroup then\n\t\tsys.process.setgroup(track.setgroup)\n\tend\n\n\tif track.setuser then\n\t\tsys.process.setuser(track.setuser)\n\tend\n\n\tlocal target = nil\n\tif c then\n\t\tif type(c.target) == \"function\" then\n\t\t\ttarget = c.target\n\t\telseif type(c.target) == \"table\" then\n\t\t\ttarget = c.target.target\n\t\tend\n\tend\n\n\tif c and (c.index or type(target) == \"function\") then\n\t\tctx.dispatched = c\n\t\tctx.requested = ctx.requested or ctx.dispatched\n\tend\n\n\tif c and c.index then\n\t\tlocal tpl = require \"luci.template\"\n\n\t\tif util.copcall(tpl.render, \"indexer\", {}) then\n\t\t\treturn true\n\t\tend\n\tend\n\n\tif type(target) == \"function\" then\n\t\tutil.copcall(function()\n\t\t\tlocal oldenv = getfenv(target)\n\t\t\tlocal module = require(c.module)\n\t\t\tlocal env = setmetatable({}, {__index=\n\n\t\t\tfunction(tbl, key)\n\t\t\t\treturn rawget(tbl, key) or module[key] or oldenv[key]\n\t\t\tend})\n\n\t\t\tsetfenv(target, env)\n\t\tend)\n\n\t\tlocal ok, err\n\t\tif type(c.target) == \"table\" then\n\t\t\tok, err = util.copcall(target, c.target, unpack(args))\n\t\telse\n\t\t\tok, err = util.copcall(target, unpack(args))\n\t\tend\n\t\tif not ok then\n\t\t\terror500(\"Failed to execute \" .. (type(c.target) == \"function\" and \"function\" or c.target.type or \"unknown\") ..\n\t\t\t         \" dispatcher target for entry '/\" .. table.concat(request, \"/\") .. \"'.\\n\" ..\n\t\t\t         \"The called action terminated with an exception:\\n\" .. tostring(err or \"(unknown)\"))\n\t\tend\n\telse\n\t\tlocal root = node()\n\t\tif not root or not root.target then\n\t\t\terror404(\"No root node was registered, this usually happens if no module was installed.\\n\" ..\n\t\t\t         \"Install luci-mod-admin-full and retry. \" ..\n\t\t\t         \"If the module is already installed, try removing the /tmp/luci-indexcache file.\")\n\t\telse\n\t\t\terror404(\"No page is registered at '/\" .. table.concat(request, \"/\") .. \"'.\\n\" ..\n\t\t\t         \"If this url belongs to an extension, make sure it is properly installed.\\n\" ..\n\t\t\t         \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\")\n\t\tend\n\tend\nend\n\nfunction createindex()\n\tlocal controllers = { }\n\tlocal base = \"%s/controller/\" % util.libpath()\n\tlocal _, path\n\n\tfor path in (fs.glob(\"%s*.lua\" % base) or function() end) do\n\t\tcontrollers[#controllers+1] = path\n\tend\n\n\tfor path in (fs.glob(\"%s*/*.lua\" % base) or function() end) do\n\t\tcontrollers[#controllers+1] = path\n\tend\n\n\tif indexcache then\n\t\tlocal cachedate = fs.stat(indexcache, \"mtime\")\n\t\tif cachedate then\n\t\t\tlocal realdate = 0\n\t\t\tfor _, obj in ipairs(controllers) do\n\t\t\t\tlocal omtime = fs.stat(obj, \"mtime\")\n\t\t\t\trealdate = (omtime and omtime > realdate) and omtime or realdate\n\t\t\tend\n\n\t\t\tif cachedate > realdate and sys.process.info(\"uid\") == 0 then\n\t\t\t\tassert(\n\t\t\t\t\tsys.process.info(\"uid\") == fs.stat(indexcache, \"uid\")\n\t\t\t\t\tand fs.stat(indexcache, \"modestr\") == \"rw-------\",\n\t\t\t\t\t\"Fatal: Indexcache is not sane!\"\n\t\t\t\t)\n\n\t\t\t\tindex = loadfile(indexcache)()\n\t\t\t\treturn index\n\t\t\tend\n\t\tend\n\tend\n\n\tindex = {}\n\n\tfor _, path in ipairs(controllers) do\n\t\tlocal modname = \"luci.controller.\" .. path:sub(#base+1, #path-4):gsub(\"/\", \".\")\n\t\tlocal mod = require(modname)\n\t\tassert(mod ~= true,\n\t\t       \"Invalid controller file found\\n\" ..\n\t\t       \"The file '\" .. path .. \"' contains an invalid module line.\\n\" ..\n\t\t       \"Please verify whether the module name is set to '\" .. modname ..\n\t\t       \"' - It must correspond to the file path!\")\n\n\t\tlocal idx = mod.index\n\t\tassert(type(idx) == \"function\",\n\t\t       \"Invalid controller file found\\n\" ..\n\t\t       \"The file '\" .. path .. \"' contains no index() function.\\n\" ..\n\t\t       \"Please make sure that the controller contains a valid \" ..\n\t\t       \"index function and verify the spelling!\")\n\n\t\tindex[modname] = idx\n\tend\n\n\tif indexcache then\n\t\tlocal f = nixio.open(indexcache, \"w\", 600)\n\t\tf:writeall(util.get_bytecode(index))\n\t\tf:close()\n\tend\nend\n\n-- Build the index before if it does not exist yet.\nfunction createtree()\n\tif not index then\n\t\tcreateindex()\n\tend\n\n\tlocal ctx  = context\n\tlocal tree = {nodes={}, inreq=true}\n\n\tctx.treecache = setmetatable({}, {__mode=\"v\"})\n\tctx.tree = tree\n\n\tlocal scope = setmetatable({}, {__index = luci.dispatcher})\n\n\tfor k, v in pairs(index) do\n\t\tscope._NAME = k\n\t\tsetfenv(v, scope)\n\t\tv()\n\tend\n\n\treturn tree\nend\n\nfunction assign(path, clone, title, order)\n\tlocal obj  = node(unpack(path))\n\tobj.nodes  = nil\n\tobj.module = nil\n\n\tobj.title = title\n\tobj.order = order\n\n\tsetmetatable(obj, {__index = _create_node(clone)})\n\n\treturn obj\nend\n\nfunction entry(path, target, title, order)\n\tlocal c = node(unpack(path))\n\n\tc.target = target\n\tc.title  = title\n\tc.order  = order\n\tc.module = getfenv(2)._NAME\n\n\treturn c\nend\n\n-- enabling the node.\nfunction get(...)\n\treturn _create_node({...})\nend\n\nfunction node(...)\n\tlocal c = _create_node({...})\n\n\tc.module = getfenv(2)._NAME\n\tc.auto = nil\n\n\treturn c\nend\n\nfunction lookup(...)\n\tlocal i, path = nil, {}\n\tfor i = 1, select('#', ...) do\n\t\tlocal name, arg = nil, tostring(select(i, ...))\n\t\tfor name in arg:gmatch(\"[^/]+\") do\n\t\t\tpath[#path+1] = name\n\t\tend\n\tend\n\n\tfor i = #path, 1, -1 do\n\t\tlocal node = context.treecache[table.concat(path, \".\", 1, i)]\n\t\tif node and (i == #path or node.leaf) then\n\t\t\treturn node, build_url(unpack(path))\n\t\tend\n\tend\nend\n\nfunction _create_node(path)\n\tif #path == 0 then\n\t\treturn context.tree\n\tend\n\n\tlocal name = table.concat(path, \".\")\n\tlocal c = context.treecache[name]\n\n\tif not c then\n\t\tlocal last = table.remove(path)\n\t\tlocal parent = _create_node(path)\n\n\t\tc = {nodes={}, auto=true, inreq=true}\n\n\t\tlocal _, n\n\t\tfor _, n in ipairs(path) do\n\t\t\tif context.path[_] ~= n then\n\t\t\t\tc.inreq = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tc.inreq = c.inreq and (context.path[#path + 1] == last)\n\n\t\tparent.nodes[last] = c\n\t\tcontext.treecache[name] = c\n\tend\n\n\treturn c\nend\n\n-- Subdispatchers --\n\nfunction _find_eligible_node(root, prefix, deep, types, descend)\n\tlocal children = _ordered_children(root)\n\n\tif not root.leaf and deep ~= nil then\n\t\tlocal sub_path = { unpack(prefix) }\n\n\t\tif deep == false then\n\t\t\tdeep = nil\n\t\tend\n\n\t\tlocal _, child\n\t\tfor _, child in ipairs(children) do\n\t\t\tsub_path[#prefix+1] = child.name\n\n\t\t\tlocal res_path = _find_eligible_node(child.node, sub_path,\n\t\t\t                                     deep, types, true)\n\n\t\t\tif res_path then\n\t\t\t\treturn res_path\n\t\t\tend\n\t\tend\n\tend\n\n\tif descend and\n\t   (not types or\n\t    (type(root.target) == \"table\" and\n\t     util.contains(types, root.target.type)))\n\tthen\n\t\treturn prefix\n\tend\nend\n\nfunction _find_node(recurse, types)\n\tlocal path = { unpack(context.path) }\n\tlocal name = table.concat(path, \".\")\n\tlocal node = context.treecache[name]\n\n\tpath = _find_eligible_node(node, path, recurse, types)\n\n\tif path then\n\t\tdispatch(path)\n\telse\n\t\trequire \"luci.template\".render(\"empty_node_placeholder\")\n\tend\nend\n\nfunction _firstchild()\n\treturn _find_node(false, nil)\nend\n\nfunction firstchild()\n\treturn { type = \"firstchild\", target = _firstchild }\nend\n\nfunction _firstnode()\n\treturn _find_node(true, { \"cbi\", \"form\", \"template\", \"arcombine\" })\nend\n\nfunction firstnode()\n\treturn { type = \"firstnode\", target = _firstnode }\nend\n\nfunction alias(...)\n\tlocal req = {...}\n\treturn function(...)\n\t\tfor _, r in ipairs({...}) do\n\t\t\treq[#req+1] = r\n\t\tend\n\n\t\tdispatch(req)\n\tend\nend\n\nfunction rewrite(n, ...)\n\tlocal req = {...}\n\treturn function(...)\n\t\tlocal dispatched = util.clone(context.dispatched)\n\n\t\tfor i=1,n do\n\t\t\ttable.remove(dispatched, 1)\n\t\tend\n\n\t\tfor i, r in ipairs(req) do\n\t\t\ttable.insert(dispatched, i, r)\n\t\tend\n\n\t\tfor _, r in ipairs({...}) do\n\t\t\tdispatched[#dispatched+1] = r\n\t\tend\n\n\t\tdispatch(dispatched)\n\tend\nend\n\n\nlocal function _call(self, ...)\n\tlocal func = getfenv()[self.name]\n\tassert(func ~= nil,\n\t       'Cannot resolve function \"' .. self.name .. '\". Is it misspelled or local?')\n\n\tassert(type(func) == \"function\",\n\t       'The symbol \"' .. self.name .. '\" does not refer to a function but data ' ..\n\t       'of type \"' .. type(func) .. '\".')\n\n\tif #self.argv > 0 then\n\t\treturn func(unpack(self.argv), ...)\n\telse\n\t\treturn func(...)\n\tend\nend\n\nfunction call(name, ...)\n\treturn {type = \"call\", argv = {...}, name = name, target = _call}\nend\n\nfunction post_on(params, name, ...)\n\treturn {\n\t\ttype = \"call\",\n\t\tpost = params,\n\t\targv = { ... },\n\t\tname = name,\n\t\ttarget = _call\n\t}\nend\n\nfunction post(...)\n\treturn post_on(true, ...)\nend\n\n\nlocal _template = function(self, ...)\n\trequire \"luci.template\".render(self.view)\nend\n\nfunction template(name)\n\treturn {type = \"template\", view = name, target = _template}\nend\n\n\nlocal _view = function(self, ...)\n\trequire \"luci.template\".render(\"view\", { view = self.view })\nend\n\nfunction view(name)\n\treturn {type = \"view\", view = name, target = _view}\nend\n\n\nlocal function _cbi(self, ...)\n\tlocal cbi = require \"luci.cbi\"\n\tlocal tpl = require \"luci.template\"\n\tlocal http = require \"luci.http\"\n\n\tlocal config = self.config or {}\n\tlocal maps = cbi.load(self.model, ...)\n\n\tlocal state = nil\n\n\tlocal i, res\n\tfor i, res in ipairs(maps) do\n\t\tif util.instanceof(res, cbi.SimpleForm) then\n\t\t\tio.stderr:write(\"Model %s returns SimpleForm but is dispatched via cbi(),\\n\"\n\t\t\t\t% self.model)\n\n\t\t\tio.stderr:write(\"please change %s to use the form() action instead.\\n\"\n\t\t\t\t% table.concat(context.request, \"/\"))\n\t\tend\n\n\t\tres.flow = config\n\t\tlocal cstate = res:parse()\n\t\tif cstate and (not state or cstate < state) then\n\t\t\tstate = cstate\n\t\tend\n\tend\n\n\tlocal function _resolve_path(path)\n\t\treturn type(path) == \"table\" and build_url(unpack(path)) or path\n\tend\n\n\tif config.on_valid_to and state and state > 0 and state < 2 then\n\t\thttp.redirect(_resolve_path(config.on_valid_to))\n\t\treturn\n\tend\n\n\tif config.on_changed_to and state and state > 1 then\n\t\thttp.redirect(_resolve_path(config.on_changed_to))\n\t\treturn\n\tend\n\n\tif config.on_success_to and state and state > 0 then\n\t\thttp.redirect(_resolve_path(config.on_success_to))\n\t\treturn\n\tend\n\n\tif config.state_handler then\n\t\tif not config.state_handler(state, maps) then\n\t\t\treturn\n\t\tend\n\tend\n\n\thttp.header(\"X-CBI-State\", state or 0)\n\n\tif not config.noheader then\n\t\ttpl.render(\"cbi/header\", {state = state})\n\tend\n\n\tlocal redirect\n\tlocal messages\n\tlocal applymap   = false\n\tlocal pageaction = true\n\tlocal parsechain = { }\n\n\tfor i, res in ipairs(maps) do\n\t\tif res.apply_needed and res.parsechain then\n\t\t\tlocal c\n\t\t\tfor _, c in ipairs(res.parsechain) do\n\t\t\t\tparsechain[#parsechain+1] = c\n\t\t\tend\n\t\t\tapplymap = true\n\t\tend\n\n\t\tif res.redirect then\n\t\t\tredirect = redirect or res.redirect\n\t\tend\n\n\t\tif res.pageaction == false then\n\t\t\tpageaction = false\n\t\tend\n\n\t\tif res.message then\n\t\t\tmessages = messages or { }\n\t\t\tmessages[#messages+1] = res.message\n\t\tend\n\tend\n\n\tfor i, res in ipairs(maps) do\n\t\tres:render({\n\t\t\tfirstmap   = (i == 1),\n\t\t\tredirect   = redirect,\n\t\t\tmessages   = messages,\n\t\t\tpageaction = pageaction,\n\t\t\tparsechain = parsechain\n\t\t})\n\tend\n\n\tif not config.nofooter then\n\t\ttpl.render(\"cbi/footer\", {\n\t\t\tflow          = config,\n\t\t\tpageaction    = pageaction,\n\t\t\tredirect      = redirect,\n\t\t\tstate         = state,\n\t\t\tautoapply     = config.autoapply,\n\t\t\ttrigger_apply = applymap\n\t\t})\n\tend\nend\n\nfunction cbi(model, config)\n\treturn {\n\t\ttype = \"cbi\",\n\t\tpost = { [\"cbi.submit\"] = true },\n\t\tconfig = config,\n\t\tmodel = model,\n\t\ttarget = _cbi\n\t}\nend\n\n\nlocal function _arcombine(self, ...)\n\tlocal argv = {...}\n\tlocal target = #argv > 0 and self.targets[2] or self.targets[1]\n\tsetfenv(target.target, self.env)\n\ttarget:target(unpack(argv))\nend\n\nfunction arcombine(trg1, trg2)\n\treturn {type = \"arcombine\", env = getfenv(), target = _arcombine, targets = {trg1, trg2}}\nend\n\n\nlocal function _form(self, ...)\n\tlocal cbi = require \"luci.cbi\"\n\tlocal tpl = require \"luci.template\"\n\tlocal http = require \"luci.http\"\n\n\tlocal maps = luci.cbi.load(self.model, ...)\n\tlocal state = nil\n\n\tlocal i, res\n\tfor i, res in ipairs(maps) do\n\t\tlocal cstate = res:parse()\n\t\tif cstate and (not state or cstate < state) then\n\t\t\tstate = cstate\n\t\tend\n\tend\n\n\thttp.header(\"X-CBI-State\", state or 0)\n\ttpl.render(\"header\")\n\tfor i, res in ipairs(maps) do\n\t\tres:render()\n\tend\n\ttpl.render(\"footer\")\nend\n\nfunction form(model)\n\treturn {\n\t\ttype = \"cbi\",\n\t\tpost = { [\"cbi.submit\"] = true },\n\t\tmodel = model,\n\t\ttarget = _form\n\t}\nend\n\ntranslate = i18n.translate\n\n-- This function does not actually translate the given argument but\n-- is used by build/i18n-scan.pl to find translatable entries.\nfunction _(text)\n\treturn text\nend\n"], "filenames": ["modules/luci-base/luasrc/dispatcher.lua"], "buggy_code_start_loc": [152], "buggy_code_end_loc": [474], "fixing_code_start_loc": [152], "fixing_code_end_loc": [478], "type": "CWE-352", "message": "OpenWRT firmware version 18.06.4 is vulnerable to CSRF via wireless/radio0.network1, wireless/radio1.network1, firewall, firewall/zones, firewall/forwards, firewall/rules, network/wan, network/wan6, or network/lan under /cgi-bin/luci/admin/network/.", "other": {"cve": {"id": "CVE-2019-17367", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-18T17:15:10.343", "lastModified": "2019-10-22T13:32:35.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenWRT firmware version 18.06.4 is vulnerable to CSRF via wireless/radio0.network1, wireless/radio1.network1, firewall, firewall/zones, firewall/forwards, firewall/rules, network/wan, network/wan6, or network/lan under /cgi-bin/luci/admin/network/."}, {"lang": "es", "value": "OpenWRT versi\u00f3n de firmware 18.06.4, es vulnerable a CSRF por medio del archivo wireless/radio0.network1, wireless/radio1.network1, firewall, firewall/zones, firewall/forwards, firewall/rules, network/wan, network/wan6, o network/lan bajo /cgi-bin/luci/admin/network/."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openwrt:openwrt:18:06.4:*:*:*:*:*:*", "matchCriteriaId": "3BDB0BA0-7C08-468E-97D1-AC399EA6ABC4"}]}]}], "references": [{"url": "https://github.com/openwrt/luci/commit/f8c6eb67cd9da09ee20248fec6ab742069635e47", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openwrt/luci/commit/f8c6eb67cd9da09ee20248fec6ab742069635e47"}}