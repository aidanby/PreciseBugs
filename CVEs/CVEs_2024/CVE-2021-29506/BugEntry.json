{"buggy_code": ["/*\n *  Licensed to GraphHopper GmbH under one or more contributor\n *  license agreements. See the NOTICE file distributed with this work for\n *  additional information regarding copyright ownership.\n *\n *  GraphHopper GmbH licenses this file to you under the Apache License,\n *  Version 2.0 (the \"License\"); you may not use this file except in\n *  compliance with the License. You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage com.graphhopper.navigation;\n\nimport com.graphhopper.GHRequest;\nimport com.graphhopper.GHResponse;\nimport com.graphhopper.GraphHopperAPI;\nimport com.graphhopper.GraphHopperConfig;\nimport com.graphhopper.util.Helper;\nimport com.graphhopper.util.Parameters;\nimport com.graphhopper.util.StopWatch;\nimport com.graphhopper.util.TranslationMap;\nimport com.graphhopper.util.shapes.GHPoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Inject;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.*;\nimport javax.ws.rs.container.ContainerRequestContext;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.UriInfo;\nimport java.util.*;\n\nimport static com.graphhopper.util.Parameters.Routing.*;\n\n/**\n * Provides an endpoint that is consumable with the Mapbox Navigation SDK. The Mapbox Navigation SDK consumes json\n * responses that follow the specification of the Mapbox API v5.\n * <p>\n * See: https://www.mapbox.com/api-documentation/#directions\n * <p>\n * The baseurl of this endpoint is: [YOUR-IP/HOST]/navigate\n * The version of this endpoint is: v5\n * The user of this endpoint is: gh\n *\n * @author Robin Boldt\n */\n@Path(\"navigate/directions/v5/gh\")\npublic class NavigateResource {\n\n    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);\n\n    private final GraphHopperAPI graphHopper;\n    private final TranslationMap translationMap;\n    private final Map<String, String> resolverMap;\n\n    @Inject\n    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {\n        this.graphHopper = graphHopper;\n        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());\n        if (resolverMap.isEmpty()) {\n            resolverMap.put(\"driving\", \"car\");\n            // driving-traffic is mapped to regular car as well\n            resolverMap.put(\"driving-traffic\", \"car\");\n            resolverMap.put(\"walking\", \"foot\");\n            resolverMap.put(\"cycling\", \"bike\");\n        }\n        this.translationMap = translationMap;\n    }\n\n    @GET\n    @Path(\"/{profile}/{coordinatesArray : .+}\")\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response doGet(\n            @Context HttpServletRequest httpReq,\n            @Context UriInfo uriInfo,\n            @Context ContainerRequestContext rc,\n            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,\n            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,\n            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,\n            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,\n            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,\n            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,\n            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,\n            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,\n            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,\n            @PathParam(\"profile\") String mapboxProfile) {\n\n        /*\n            Currently, the NavigateResponseConverter is pretty limited.\n            Therefore, we enforce these values to make sure the client does not receive an unexpected answer.\n         */\n        if (!geometries.equals(\"polyline6\"))\n            throw new IllegalArgumentException(\"Currently, we only support polyline6\");\n        if (!enableInstructions)\n            throw new IllegalArgumentException(\"Currently, you need to enable steps\");\n        if (!roundaboutExits)\n            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");\n        if (!voiceInstructions)\n            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");\n        if (!bannerInstructions)\n            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");\n\n        double minPathPrecision = 1;\n        if (overview.equals(\"full\"))\n            minPathPrecision = 0;\n\n        DistanceUtils.Unit unit;\n        if (voiceUnits.equals(\"metric\")) {\n            unit = DistanceUtils.Unit.METRIC;\n        } else {\n            unit = DistanceUtils.Unit.IMPERIAL;\n        }\n\n        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);\n        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);\n\n        List<Double> favoredHeadings = getBearing(bearings);\n        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {\n            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");\n        }\n\n        StopWatch sw = new StopWatch().start();\n\n        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n\n        // Only do this, when there are more than 2 points, otherwise we use alternative routes\n        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {\n            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {\n                ghResponse.getAll().add(noHeadingResponse.getBest());\n            }\n        }\n\n        float took = sw.stop().getSeconds();\n        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");\n        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"\n                + took + \", \" + ghProfile;\n        Locale locale = Helper.getLocale(localeStr);\n        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);\n\n        if (ghResponse.hasErrors()) {\n            logger.error(logStr + \", errors:\" + ghResponse.getErrors());\n            // Mapbox specifies 422 return type for input errors\n            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        } else {\n            logger.info(logStr);\n            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        }\n    }\n\n    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,\n                                 String localeStr, boolean enableInstructions, double minPathPrecision) {\n        GHRequest request;\n        if (favoredHeadings.size() > 0) {\n            request = new GHRequest(requestPoints, favoredHeadings);\n        } else {\n            request = new GHRequest(requestPoints);\n        }\n\n        request.setProfile(profileStr).\n                setLocale(localeStr).\n                putHint(CALC_POINTS, true).\n                putHint(INSTRUCTIONS, enableInstructions).\n                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).\n                putHint(Parameters.CH.DISABLE, true).\n                putHint(Parameters.Routing.PASS_THROUGH, false);\n\n        return graphHopper.route(request);\n    }\n\n    /**\n     * This method is parsing the request URL String. Unfortunately it seems that there is no better options right now.\n     * See: https://stackoverflow.com/q/51420380/1548788\n     * <p>\n     * The url looks like: \".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..\"\n     */\n    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n\n        String url = httpServletRequest.getRequestURI();\n        url = url.replaceFirst(\"/navigate/directions/v5/gh/\" + profile + \"/\", \"\");\n        url = url.replaceAll(\"\\\\?[*]\", \"\");\n\n        String[] pointStrings = url.split(\";\");\n\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    static List<Double> getBearing(String bearingString) {\n        if (bearingString == null || bearingString.isEmpty())\n            return Collections.EMPTY_LIST;\n\n        String[] bearingArray = bearingString.split(\";\", -1);\n        List<Double> bearings = new ArrayList<>(bearingArray.length);\n\n        for (int i = 0; i < bearingArray.length; i++) {\n            String singleBearing = bearingArray[i];\n            if (singleBearing.isEmpty()) {\n                bearings.add(Double.NaN);\n            } else {\n                if (!singleBearing.contains(\",\")) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n                String[] singleBearingArray = singleBearing.split(\",\");\n                try {\n                    bearings.add(Double.parseDouble(singleBearingArray[0]));\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n            }\n        }\n        return bearings;\n    }\n}\n"], "fixing_code": ["/*\n *  Licensed to GraphHopper GmbH under one or more contributor\n *  license agreements. See the NOTICE file distributed with this work for\n *  additional information regarding copyright ownership.\n *\n *  GraphHopper GmbH licenses this file to you under the Apache License,\n *  Version 2.0 (the \"License\"); you may not use this file except in\n *  compliance with the License. You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage com.graphhopper.navigation;\n\nimport com.graphhopper.GHRequest;\nimport com.graphhopper.GHResponse;\nimport com.graphhopper.GraphHopperAPI;\nimport com.graphhopper.GraphHopperConfig;\nimport com.graphhopper.util.Helper;\nimport com.graphhopper.util.Parameters;\nimport com.graphhopper.util.StopWatch;\nimport com.graphhopper.util.TranslationMap;\nimport com.graphhopper.util.shapes.GHPoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Inject;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.ws.rs.*;\nimport javax.ws.rs.container.ContainerRequestContext;\nimport javax.ws.rs.core.Context;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.UriInfo;\nimport java.util.*;\n\nimport static com.graphhopper.util.Parameters.Routing.*;\n\n/**\n * Provides an endpoint that is consumable with the Mapbox Navigation SDK. The Mapbox Navigation SDK consumes json\n * responses that follow the specification of the Mapbox API v5.\n * <p>\n * See: https://www.mapbox.com/api-documentation/#directions\n * <p>\n * The baseurl of this endpoint is: [YOUR-IP/HOST]/navigate\n * The version of this endpoint is: v5\n * The user of this endpoint is: gh\n *\n * @author Robin Boldt\n */\n@Path(\"navigate/directions/v5/gh\")\npublic class NavigateResource {\n\n    private static final Logger logger = LoggerFactory.getLogger(NavigateResource.class);\n\n    private final GraphHopperAPI graphHopper;\n    private final TranslationMap translationMap;\n    private final Map<String, String> resolverMap;\n\n    @Inject\n    public NavigateResource(GraphHopperAPI graphHopper, TranslationMap translationMap, GraphHopperConfig config) {\n        this.graphHopper = graphHopper;\n        resolverMap = config.asPMap().getObject(\"profiles_mapbox\", new HashMap<>());\n        if (resolverMap.isEmpty()) {\n            resolverMap.put(\"driving\", \"car\");\n            // driving-traffic is mapped to regular car as well\n            resolverMap.put(\"driving-traffic\", \"car\");\n            resolverMap.put(\"walking\", \"foot\");\n            resolverMap.put(\"cycling\", \"bike\");\n        }\n        this.translationMap = translationMap;\n    }\n\n    @GET\n    @Path(\"/{profile}/{coordinatesArray : .+}\")\n    @Produces({MediaType.APPLICATION_JSON})\n    public Response doGet(\n            @Context HttpServletRequest httpReq,\n            @Context UriInfo uriInfo,\n            @Context ContainerRequestContext rc,\n            @QueryParam(\"steps\") @DefaultValue(\"false\") boolean enableInstructions,\n            @QueryParam(\"voice_instructions\") @DefaultValue(\"false\") boolean voiceInstructions,\n            @QueryParam(\"banner_instructions\") @DefaultValue(\"false\") boolean bannerInstructions,\n            @QueryParam(\"roundabout_exits\") @DefaultValue(\"false\") boolean roundaboutExits,\n            @QueryParam(\"voice_units\") @DefaultValue(\"metric\") String voiceUnits,\n            @QueryParam(\"overview\") @DefaultValue(\"simplified\") String overview,\n            @QueryParam(\"geometries\") @DefaultValue(\"polyline\") String geometries,\n            @QueryParam(\"bearings\") @DefaultValue(\"\") String bearings,\n            @QueryParam(\"language\") @DefaultValue(\"en\") String localeStr,\n            @PathParam(\"profile\") String mapboxProfile) {\n\n        /*\n            Currently, the NavigateResponseConverter is pretty limited.\n            Therefore, we enforce these values to make sure the client does not receive an unexpected answer.\n         */\n        if (!geometries.equals(\"polyline6\"))\n            throw new IllegalArgumentException(\"Currently, we only support polyline6\");\n        if (!enableInstructions)\n            throw new IllegalArgumentException(\"Currently, you need to enable steps\");\n        if (!roundaboutExits)\n            throw new IllegalArgumentException(\"Roundabout exits have to be enabled right now\");\n        if (!voiceInstructions)\n            throw new IllegalArgumentException(\"You need to enable voice instructions right now\");\n        if (!bannerInstructions)\n            throw new IllegalArgumentException(\"You need to enable banner instructions right now\");\n\n        double minPathPrecision = 1;\n        if (overview.equals(\"full\"))\n            minPathPrecision = 0;\n\n        DistanceUtils.Unit unit;\n        if (voiceUnits.equals(\"metric\")) {\n            unit = DistanceUtils.Unit.METRIC;\n        } else {\n            unit = DistanceUtils.Unit.IMPERIAL;\n        }\n\n        String ghProfile = resolverMap.getOrDefault(mapboxProfile, mapboxProfile);\n        List<GHPoint> requestPoints = getPointsFromRequest(httpReq, mapboxProfile);\n\n        List<Double> favoredHeadings = getBearing(bearings);\n        if (favoredHeadings.size() > 0 && favoredHeadings.size() != requestPoints.size()) {\n            throw new IllegalArgumentException(\"Number of bearings and waypoints did not match\");\n        }\n\n        StopWatch sw = new StopWatch().start();\n\n        GHResponse ghResponse = calcRoute(favoredHeadings, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n\n        // Only do this, when there are more than 2 points, otherwise we use alternative routes\n        if (!ghResponse.hasErrors() && favoredHeadings.size() > 0) {\n            GHResponse noHeadingResponse = calcRoute(Collections.EMPTY_LIST, requestPoints, ghProfile, localeStr, enableInstructions, minPathPrecision);\n            if (ghResponse.getBest().getDistance() != noHeadingResponse.getBest().getDistance()) {\n                ghResponse.getAll().add(noHeadingResponse.getBest());\n            }\n        }\n\n        float took = sw.stop().getSeconds();\n        String infoStr = httpReq.getRemoteAddr() + \" \" + httpReq.getLocale() + \" \" + httpReq.getHeader(\"User-Agent\");\n        String logStr = httpReq.getQueryString() + \" \" + infoStr + \" \" + requestPoints + \", took:\"\n                + took + \", \" + ghProfile;\n        Locale locale = Helper.getLocale(localeStr);\n        DistanceConfig config = new DistanceConfig(unit, translationMap, locale);\n\n        if (ghResponse.hasErrors()) {\n            logger.error(logStr + \", errors:\" + ghResponse.getErrors());\n            // Mapbox specifies 422 return type for input errors\n            return Response.status(422).entity(NavigateResponseConverter.convertFromGHResponseError(ghResponse)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        } else {\n            logger.info(logStr);\n            return Response.ok(NavigateResponseConverter.convertFromGHResponse(ghResponse, translationMap, locale, config)).\n                    header(\"X-GH-Took\", \"\" + Math.round(took * 1000)).\n                    build();\n        }\n    }\n\n    private GHResponse calcRoute(List<Double> favoredHeadings, List<GHPoint> requestPoints, String profileStr,\n                                 String localeStr, boolean enableInstructions, double minPathPrecision) {\n        GHRequest request;\n        if (favoredHeadings.size() > 0) {\n            request = new GHRequest(requestPoints, favoredHeadings);\n        } else {\n            request = new GHRequest(requestPoints);\n        }\n\n        request.setProfile(profileStr).\n                setLocale(localeStr).\n                putHint(CALC_POINTS, true).\n                putHint(INSTRUCTIONS, enableInstructions).\n                putHint(WAY_POINT_MAX_DISTANCE, minPathPrecision).\n                putHint(Parameters.CH.DISABLE, true).\n                putHint(Parameters.Routing.PASS_THROUGH, false);\n\n        return graphHopper.route(request);\n    }\n\n    /**\n     * This method is parsing the request URL String. Unfortunately it seems that there is no better options right now.\n     * See: https://stackoverflow.com/q/51420380/1548788\n     * <p>\n     * The url looks like: \".../{profile}/1.522438,42.504606;1.527209,42.504776;1.526113,42.505144;1.527218,42.50529?..\"\n     */\n    private List<GHPoint> getPointsFromRequest(HttpServletRequest httpServletRequest, String profile) {\n        String url = httpServletRequest.getRequestURI();\n        String urlStart = \"/navigate/directions/v5/gh/\" + profile + \"/\";\n        if (!url.startsWith(urlStart)) throw new IllegalArgumentException(\"Incorrect URL \" + url);\n        url = url.substring(urlStart.length());\n        String[] pointStrings = url.split(\";\");\n        List<GHPoint> points = new ArrayList<>(pointStrings.length);\n        for (int i = 0; i < pointStrings.length; i++) {\n            points.add(GHPoint.fromStringLonLat(pointStrings[i]));\n        }\n\n        return points;\n    }\n\n    static List<Double> getBearing(String bearingString) {\n        if (bearingString == null || bearingString.isEmpty())\n            return Collections.EMPTY_LIST;\n\n        String[] bearingArray = bearingString.split(\";\", -1);\n        List<Double> bearings = new ArrayList<>(bearingArray.length);\n\n        for (int i = 0; i < bearingArray.length; i++) {\n            String singleBearing = bearingArray[i];\n            if (singleBearing.isEmpty()) {\n                bearings.add(Double.NaN);\n            } else {\n                if (!singleBearing.contains(\",\")) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n                String[] singleBearingArray = singleBearing.split(\",\");\n                try {\n                    bearings.add(Double.parseDouble(singleBearingArray[0]));\n                } catch (NumberFormatException e) {\n                    throw new IllegalArgumentException(\"You passed an invalid bearings parameter \" + bearingString);\n                }\n            }\n        }\n        return bearings;\n    }\n}\n"], "filenames": ["navigation/src/main/java/com/graphhopper/navigation/NavigateResource.java"], "buggy_code_start_loc": [191], "buggy_code_end_loc": [198], "fixing_code_start_loc": [190], "fixing_code_end_loc": [195], "type": "CWE-400", "message": "GraphHopper is an open-source Java routing engine. In GrassHopper from version 2.0 and before version 2.4, there is a regular expression injection vulnerability that may lead to Denial of Service. This has been patched in 2.4 and 3.0 See this pull request for the fix: https://github.com/graphhopper/graphhopper/pull/2304", "other": {"cve": {"id": "CVE-2021-29506", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-13T19:15:07.983", "lastModified": "2021-05-24T19:56:23.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GraphHopper is an open-source Java routing engine. In GrassHopper from version 2.0 and before version 2.4, there is a regular expression injection vulnerability that may lead to Denial of Service. This has been patched in 2.4 and 3.0 See this pull request for the fix: https://github.com/graphhopper/graphhopper/pull/2304"}, {"lang": "es", "value": "GraphHopper es un motor de enrutamiento Java de c\u00f3digo abierto. En GraphHopper a partir de la versi\u00f3n 2.0 y antes de la versi\u00f3n 2.4, existe una vulnerabilidad de inyecci\u00f3n de expresiones regulares que puede llevar a una denegaci\u00f3n de servicio. Esto ha sido parcheado en las versiones 2.4 y 3.0. Vea este pull request para la correcci\u00f3n: https://github.com/graphhopper/graphhopper/pull/2304"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:graphhopper:graphhopper:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0", "versionEndExcluding": "2.4", "matchCriteriaId": "6E39E2B7-C138-49EB-9445-0ECF88BDF790"}]}]}], "references": [{"url": "https://github.com/graphhopper/graphhopper/commit/eb189be1fa7443ebf4ae881e737a18f818c95f41", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/graphhopper/graphhopper/pull/2304", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/graphhopper/graphhopper/security/advisories/GHSA-hf44-3mx6-vhhw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/graphhopper/graphhopper/commit/eb189be1fa7443ebf4ae881e737a18f818c95f41"}}