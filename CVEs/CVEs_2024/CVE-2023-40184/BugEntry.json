{"buggy_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2013\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file verify_user_pam.c\n * @brief Authenticate user using pam\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"arch.h\"\n#include \"os_calls.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n#include \"sesman_auth.h\"\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n/* Allows the conversation function to find required items */\nstruct conv_func_data\n{\n    const char *pass;\n};\n\nstruct auth_info\n{\n    int session_opened;\n    int did_setcred;\n    pam_handle_t *ph;\n};\n\n/***************************************************************************//**\n * Returns a string representing a pam_conv message style\n *\n * @param msg_style PAM msg_style (pam_conv(3))\n * @param buff      Buffer for conversion of unrecognised values\n * @param bufflen   Total length of above\n *\n * The buffer described by buff is only written to if required.\n */\nstatic const char *\nmsg_style_to_str(int msg_style, char *buff, unsigned int bufflen)\n{\n    const char *result;\n    switch (msg_style)\n    {\n        case PAM_PROMPT_ECHO_OFF:\n            result = \"PAM_PROMPT_ECHO_OFF\";\n            break;\n\n        case PAM_PROMPT_ECHO_ON:\n            result = \"PAM_PROMPT_ECHO_ON\";\n            break;\n\n        case PAM_ERROR_MSG:\n            result = \"PAM_ERROR_MSG\";\n            break;\n\n        case PAM_TEXT_INFO:\n            result = \"PAM_TEXT_INFO\";\n            break;\n\n        default:\n            g_snprintf(buff, bufflen, \"UNKNOWN_0x%x\", msg_style);\n            result = buff;\n    }\n\n    return result;\n}\n\n/***************************************************************************//**\n * Provides the PAM conversation callback function\n *\n * At present, the main purpose of this function is to supply the\n * user's password to the PAM stack, although some module logging is\n * implemented here.\n *\n * @param[in] num_msg Count of messages in the msg array\n * @param[in] msg Messages from the PAM stack to the application\n * @param[out] resp Message replies from the application to the PAM stack\n * @param[in] appdata_ptr Used to pass in a struct conv_func_data pointer\n *\n * @result PAM_SUCCESS if the messages were all processed successfully.\n *\n * @post If PAM_SUCCESS is returned, resp and its contents are allocated here\n *       and must be freed by the caller\n * @post If PAM_SUCCESS is not returned, resp is not allocated and must not\n *       be not freed by the caller\n *\n * @note See pam_conv(3) for more information\n * @note A basic example conversation function can be found in OSF RFC\n         86.0 (1995)\n */\n\nstatic int\nverify_pam_conv(int num_msg, const struct pam_message **msg,\n                struct pam_response **resp, void *appdata_ptr)\n{\n    int i;\n    struct pam_response *reply = NULL;\n    struct conv_func_data *conv_func_data;\n    char sb[64];\n    int rv = PAM_SUCCESS;\n\n    if (num_msg <= 0 || num_msg > PAM_MAX_NUM_MSG)\n    {\n        rv = PAM_CONV_ERR;\n    }\n    else if ((reply = g_new0(struct pam_response, num_msg)) == NULL)\n    {\n        rv = PAM_BUF_ERR;\n    }\n    else\n    {\n        for (i = 0; i < num_msg && rv == PAM_SUCCESS; i++)\n        {\n            LOG_DEVEL(LOG_LEVEL_INFO, \"Handling struct pam_message\"\n                      \" { style = %s, msg = \\\"%s\\\" }\",\n                      msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)),\n                      msg[i]->msg == NULL ? \"<null>\" : msg[i]->msg);\n\n            switch (msg[i]->msg_style)\n            {\n                case PAM_PROMPT_ECHO_OFF: /* password */\n                    conv_func_data = (struct conv_func_data *) appdata_ptr;\n                    /* Check this function isn't being called\n                     * later than we expected */\n                    if (conv_func_data == NULL || conv_func_data->pass == NULL)\n                    {\n                        LOG(LOG_LEVEL_ERROR,\n                            \"verify_pam_conv: Password unavailable\");\n                        reply[i].resp = g_strdup(\"????\");\n                    }\n                    else\n                    {\n                        reply[i].resp = g_strdup(conv_func_data->pass);\n                    }\n                    break;\n\n                case PAM_ERROR_MSG:\n                    LOG(LOG_LEVEL_ERROR, \"PAM: %s\", msg[i]->msg);\n                    break;\n\n                case PAM_TEXT_INFO:\n                    LOG(LOG_LEVEL_INFO, \"PAM: %s\", msg[i]->msg);\n                    break;\n\n                default:\n                {\n                    LOG(LOG_LEVEL_ERROR, \"Unhandled message in verify_pam_conv\"\n                        \" { style = %s, msg = \\\"%s\\\" }\",\n                        msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)),\n                        msg[i]->msg == NULL ? \"<null>\" : msg[i]->msg);\n                    rv = PAM_CONV_ERR;\n                }\n            }\n        }\n    }\n\n    if (rv == PAM_SUCCESS)\n    {\n        *resp = reply;\n    }\n    else if (reply != NULL)\n    {\n        for (i = 0; i < num_msg; i++)\n        {\n            if (reply[i].resp != NULL)\n            {\n                g_free(reply[i].resp);\n            }\n        }\n        g_free(reply);\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\nstatic void\nget_service_name(char *service_name)\n{\n    service_name[0] = 0;\n\n    if (g_file_exist(\"/etc/pam.d/xrdp-sesman\") ||\n#ifdef __LINUX_PAM__\n            /* /usr/lib/pam.d is hardcoded into Linux-PAM */\n            g_file_exist(\"/usr/lib/pam.d/xrdp-sesman\") ||\n#endif\n#ifdef OPENPAM_VERSION\n            /* /usr/local/etc/pam.d is hardcoded into OpenPAM */\n            g_file_exist(\"/usr/local/etc/pam.d/xrdp-sesman\") ||\n#endif\n            g_file_exist(XRDP_PAMCONF_PATH \"/xrdp-sesman\"))\n    {\n        g_strncpy(service_name, \"xrdp-sesman\", 255);\n    }\n    else\n    {\n        g_strncpy(service_name, \"gdm\", 255);\n    }\n}\n\n/******************************************************************************/\n\n/** Performs PAM operations common to login methods\n *\n * @param auth_info Module auth_info structure\n * @param user User name\n * @param pass Password, if needed for authentication.\n * @param client_ip Client IP if known, or NULL\n * @param authentication_required True if user must be authenticated\n *\n * For a UDS connection, the user can be assumed to be authenticated,\n * so in this instance authentication_required can be false.\n *\n * @return Code describing the success of the operation\n */\nstatic enum scp_login_status\ncommon_pam_login(struct auth_info *auth_info,\n                 const char *user,\n                 const char *pass,\n                 const char *client_ip,\n                 int authentication_required)\n{\n    int perror;\n    char service_name[256];\n    struct conv_func_data conv_func_data;\n    struct pam_conv pamc;\n\n    /*\n     * Set up the data required by the conversation function, and the\n     * structure which allows us to pass this to pam_start()\n     */\n    conv_func_data.pass = (authentication_required) ? pass : NULL;\n    pamc.conv = verify_pam_conv;\n    pamc.appdata_ptr = (void *) &conv_func_data;\n\n    get_service_name(service_name);\n    perror = pam_start(service_name, user, &pamc, &(auth_info->ph));\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_start failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_GENERAL_ERROR;\n    }\n\n    if (client_ip != NULL && client_ip[0] != '\\0')\n    {\n        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_RHOST) failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n        }\n    }\n\n    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_TTY) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    if (authentication_required)\n    {\n        perror = pam_authenticate(auth_info->ph, 0);\n\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_authenticate failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n            pam_end(auth_info->ph, perror);\n            return E_SCP_LOGIN_NOT_AUTHENTICATED;\n        }\n    }\n    /* From man page:\n       The pam_acct_mgmt function is used to determine if the users account is\n       valid. It checks for authentication token and account expiration and\n       verifies access restrictions. It is typically called after the user has\n       been authenticated.\n     */\n    perror = pam_acct_mgmt(auth_info->ph, 0);\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_acct_mgmt failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_NOT_AUTHORIZED;\n    }\n\n    /* Set the appdata_ptr passed to the conversation function to\n     * NULL, as the existing value is going out of scope */\n    pamc.appdata_ptr = NULL;\n    perror = pam_set_item(auth_info->ph, PAM_CONV, &pamc);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_CONV) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    return E_SCP_LOGIN_OK;\n}\n\n\n/******************************************************************************/\n/* returns non-NULL for success\n * Detailed error code is in the errorcode variable */\n\nstruct auth_info *\nauth_userpass(const char *user, const char *pass,\n              const char *client_ip, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        status = common_pam_login(auth_info, user, pass, client_ip, 1);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\nstruct auth_info *\nauth_uds(const char *user, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        status = common_pam_login(auth_info, user, NULL, NULL, 0);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\n/* returns error */\nint\nauth_start_session(struct auth_info *auth_info, int display_num)\n{\n    int error;\n    char display[256];\n\n    g_sprintf(display, \":%d\", display_num);\n    error = pam_set_item(auth_info->ph, PAM_TTY, display);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    error = pam_setcred(auth_info->ph, PAM_ESTABLISH_CRED);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_setcred failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->did_setcred = 1;\n    error = pam_open_session(auth_info->ph, 0);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_open_session failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->session_opened = 1;\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\nstatic int\nauth_stop_session(struct auth_info *auth_info)\n{\n    int rv = 0;\n    int error;\n\n    if (auth_info->session_opened)\n    {\n        error = pam_close_session(auth_info->ph, 0);\n        if (error != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_close_session failed: %s\",\n                pam_strerror(auth_info->ph, error));\n            rv = 1;\n        }\n        else\n        {\n            auth_info->session_opened = 0;\n        }\n    }\n\n    if (auth_info->did_setcred)\n    {\n        pam_setcred(auth_info->ph, PAM_DELETE_CRED);\n        auth_info->did_setcred = 0;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\n/* returns error */\n/* cleanup */\nint\nauth_end(struct auth_info *auth_info)\n{\n    if (auth_info != NULL)\n    {\n        if (auth_info->ph != 0)\n        {\n            auth_stop_session(auth_info);\n\n            pam_end(auth_info->ph, PAM_SUCCESS);\n            auth_info->ph = 0;\n        }\n    }\n\n    g_free(auth_info);\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\n/* set any pam env vars */\nint\nauth_set_env(struct auth_info *auth_info)\n{\n    char **pam_envlist;\n    char **pam_env;\n\n    if (auth_info != NULL)\n    {\n        /* export PAM environment */\n        pam_envlist = pam_getenvlist(auth_info->ph);\n\n        if (pam_envlist != NULL)\n        {\n            for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env)\n            {\n                char *str = *pam_env;\n                int eq_pos = g_pos(str, \"=\");\n\n                if (eq_pos > 0)\n                {\n                    str[eq_pos] = '\\0';\n                    g_setenv(str, str + eq_pos + 1, 1);\n                }\n\n                g_free(str);\n            }\n\n            g_free(pam_envlist);\n        }\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2013\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file verify_user_pam.c\n * @brief Authenticate user using pam\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"arch.h\"\n#include \"os_calls.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n#include \"sesman_auth.h\"\n\n#include <security/pam_userpass.h>\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n#define SERVICE \"xrdp\"\n\nstruct auth_info\n{\n    pam_userpass_t userpass;\n    int session_opened;\n    int did_setcred;\n    struct pam_conv pamc;\n    pam_handle_t *ph;\n};\n\n/******************************************************************************/\n\n/** Performs PAM operations common to login methods\n *\n * @param auth_info Module auth_info structure\n * @param client_ip Client IP if known, or NULL\n * @param need_pam_authenticate True if user must be authenticated as\n *                              well as authorized\n * @return Code describing the success of the operation\n *\n * The username is assumed to be supplied by the caller in\n * auth_info->userpass.user\n */\nstatic enum scp_login_status\ncommon_pam_login(struct auth_info *auth_info,\n                 const char *client_ip,\n                 int need_pam_authenticate)\n{\n    int perror;\n    char service_name[256];\n\n    perror = pam_start(SERVICE, auth_info->userpass.user,\n                       &(auth_info->pamc), &(auth_info->ph));\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_start failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_GENERAL_ERROR;\n    }\n\n    if (client_ip != NULL && client_ip[0] != '\\0')\n    {\n        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_RHOST) failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n        }\n    }\n\n    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_TTY) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    if (need_pam_authenticate)\n    {\n        perror = pam_authenticate(auth_info->ph, 0);\n\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_authenticate failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n            pam_end(auth_info->ph, perror);\n            return E_SCP_LOGIN_NOT_AUTHENTICATED;\n        }\n    }\n    /* From man page:\n       The pam_acct_mgmt function is used to determine if the users account is\n       valid. It checks for authentication token and account expiration and\n       verifies access restrictions. It is typically called after the user has\n       been authenticated.\n     */\n    perror = pam_acct_mgmt(auth_info->ph, 0);\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_acct_mgmt failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_NOT_AUTHORIZED;\n    }\n\n    return E_SCP_LOGIN_OK;\n}\n\n\n/******************************************************************************/\n/* returns non-NULL for success\n * Detailed error code is in the errorcode variable */\n\nstruct auth_info *\nauth_userpass(const char *user, const char *pass,\n              const char *client_ip, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        auth_info->userpass.user = user;\n        auth_info->userpass.pass = pass;\n\n        auth_info->pamc.conv = &pam_userpass_conv;\n        auth_info->pamc.appdata_ptr = &(auth_info->userpass);\n        status = common_pam_login(auth_info, client_ip, 1);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\nstruct auth_info *\nauth_uds(const char *user, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        auth_info->userpass.user = user;\n        status = common_pam_login(auth_info, NULL, 0);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\n/* returns error */\nint\nauth_start_session(struct auth_info *auth_info, int display_num)\n{\n    int error;\n    char display[256];\n\n    g_sprintf(display, \":%d\", display_num);\n    error = pam_set_item(auth_info->ph, PAM_TTY, display);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    error = pam_setcred(auth_info->ph, PAM_ESTABLISH_CRED);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_setcred failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->did_setcred = 1;\n    error = pam_open_session(auth_info->ph, 0);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_open_session failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->session_opened = 1;\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\nstatic int\nauth_stop_session(struct auth_info *auth_info)\n{\n    int rv = 0;\n    int error;\n\n    if (auth_info->session_opened)\n    {\n        error = pam_close_session(auth_info->ph, 0);\n        if (error != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_close_session failed: %s\",\n                pam_strerror(auth_info->ph, error));\n            rv = 1;\n        }\n        else\n        {\n            auth_info->session_opened = 0;\n        }\n    }\n\n    if (auth_info->did_setcred)\n    {\n        pam_setcred(auth_info->ph, PAM_DELETE_CRED);\n        auth_info->did_setcred = 0;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\n/* returns error */\n/* cleanup */\nint\nauth_end(struct auth_info *auth_info)\n{\n    if (auth_info != NULL)\n    {\n        if (auth_info->ph != 0)\n        {\n            auth_stop_session(auth_info);\n\n            pam_end(auth_info->ph, PAM_SUCCESS);\n            auth_info->ph = 0;\n        }\n    }\n\n    g_free(auth_info);\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\n/* set any pam env vars */\nint\nauth_set_env(struct auth_info *auth_info)\n{\n    char **pam_envlist;\n    char **pam_env;\n\n    if (auth_info != NULL)\n    {\n        /* export PAM environment */\n        pam_envlist = pam_getenvlist(auth_info->ph);\n\n        if (pam_envlist != NULL)\n        {\n            for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env)\n            {\n                char *str = *pam_env;\n                int eq_pos = g_pos(str, \"=\");\n\n                if (eq_pos > 0)\n                {\n                    str[eq_pos] = '\\0';\n                    g_setenv(str, str + eq_pos + 1, 1);\n                }\n\n                g_free(str);\n            }\n\n            g_free(pam_envlist);\n        }\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * BSD process grouping by:\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland.\n * Copyright (c) 2000-2001 Markus Friedl.\n * Copyright (c) 2011-2015 Koichiro Iwao, Kyushu Institute of Technology.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file session.c\n * @brief Session management code\n * @author Jay Sorg, Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include \"config_ac.h\"\n#endif\n\n#include <errno.h>\n\n#include \"arch.h\"\n#include \"session.h\"\n\n#include \"sesman_auth.h\"\n#include \"sesman_config.h\"\n#include \"env.h\"\n#include \"guid.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"login_info.h\"\n#include \"os_calls.h\"\n#include \"sesexec.h\"\n#include \"string_calls.h\"\n#include \"xauth.h\"\n#include \"xwait.h\"\n#include \"xrdp_sockets.h\"\n\nstruct session_data\n{\n    pid_t x_server; ///< PID of X server\n    pid_t win_mgr; ///< PID of window manager\n    pid_t chansrv; //< PID of chansrv\n    time_t start_time;\n    struct session_parameters params;\n    // Flexible array member used to store strings in params and ip_addr;\n#ifdef __cplusplus\n    char strings[1];\n#else\n    char strings[];\n#endif\n};\n\n/******************************************************************************/\n/**\n * Create a new session_data structure from a session_parameters object\n *\n * @param sp Session parameters passed to session_start()\n * @return semi-initialised session_data struct\n */\nstatic struct session_data *\nsession_data_new(const struct session_parameters *sp)\n{\n    unsigned int string_length = 0;\n    // What string length do we need?\n    string_length += g_strlen(sp->shell) + 1;\n    string_length += g_strlen(sp->directory) + 1;\n\n    struct session_data *sd = (struct session_data *)g_malloc(sizeof(*sd) + string_length, 0);\n\n    if (sd == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Out of memory allocating session data struct\");\n    }\n    else\n    {\n        sd->win_mgr = -1;\n        sd->x_server = -1;\n        sd->chansrv = -1;\n        sd->start_time = 0;\n\n        /* Copy all the non-string session parameters... */\n        sd->params = *sp;\n\n        /* ...and then the strings */\n        char *memptr = sd->strings;\n\n#define COPY_STRING(dest,src) \\\n    (dest) = memptr; \\\n    strcpy(memptr, src); \\\n    memptr += strlen(memptr) + 1\n\n        COPY_STRING(sd->params.shell, sp->shell);\n        COPY_STRING(sd->params.directory, sp->directory);\n\n#undef COPY_STRING\n    }\n\n    return sd;\n}\n\n/******************************************************************************/\nvoid\nsession_data_free(struct session_data *session_data)\n{\n    if (session_data != NULL)\n    {\n#ifdef USE_DEVEL_LOGGING\n        if (session_data->win_mgr > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid window manager PID %d\",\n                      session_data->win_mgr);\n        }\n        if (session_data->x_server > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid X server PID %d\",\n                      session_data->x_server);\n        }\n        if (session_data->chansrv > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid chansrv PID %d\",\n                      session_data->chansrv);\n        }\n#endif\n\n        free(session_data);\n    }\n}\n\n/******************************************************************************/\n/**\n * Creates a string consisting of all parameters that is hosted in the param list\n * @param self\n * @param outstr, allocate this buffer before you use this function\n * @param len the allocated len for outstr\n * @return\n */\nchar *\ndumpItemsToString(struct list *self, char *outstr, int len)\n{\n    int index;\n    int totalLen = 0;\n\n    g_memset(outstr, 0, len);\n    if (self->count == 0)\n    {\n        LOG_DEVEL(LOG_LEVEL_TRACE, \"List is empty\");\n    }\n\n    for (index = 0; index < self->count; index++)\n    {\n        /* +1 = one space*/\n        totalLen = totalLen + g_strlen((char *)list_get_item(self, index)) + 1;\n\n        if (len > totalLen)\n        {\n            g_strcat(outstr, (char *)list_get_item(self, index));\n            g_strcat(outstr, \" \");\n        }\n    }\n\n    return outstr ;\n}\n\n/******************************************************************************/\nstatic void\nstart_chansrv(struct login_info *login_info,\n              const struct session_parameters *s)\n{\n    struct list *chansrv_params = list_create();\n    const char *exe_path = XRDP_SBIN_PATH \"/xrdp-chansrv\";\n\n    if (chansrv_params != NULL)\n    {\n        chansrv_params->auto_free = 1;\n        if (!list_add_strdup(chansrv_params, exe_path))\n        {\n            list_delete(chansrv_params);\n            chansrv_params = NULL;\n        }\n    }\n\n    if (chansrv_params == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Out of memory starting chansrv\");\n    }\n    else\n    {\n        env_set_user(login_info->uid, 0, s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n\n        LOG_DEVEL_LEAKING_FDS(\"chansrv\", 3, -1);\n\n        /* executing chansrv */\n        g_execvp_list(exe_path, chansrv_params);\n\n        /* should not get here */\n        list_delete(chansrv_params);\n    }\n}\n\n/******************************************************************************/\nstatic void\nstart_window_manager(struct login_info *login_info,\n                     const struct session_parameters *s)\n{\n    char text[256];\n\n    env_set_user(login_info->uid,\n                 0,\n                 s->display,\n                 g_cfg->env_names,\n                 g_cfg->env_values);\n\n    auth_set_env(login_info->auth_info);\n    LOG_DEVEL_LEAKING_FDS(\"window manager\", 3, -1);\n\n    if (s->directory[0] != '\\0')\n    {\n        if (g_cfg->sec.allow_alternate_shell)\n        {\n            g_set_current_dir(s->directory);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"Directory change to %s requested, but not \"\n                \"allowed by AllowAlternateShell config value.\",\n                s->directory);\n        }\n    }\n\n    if (s->shell[0] != '\\0')\n    {\n        if (g_cfg->sec.allow_alternate_shell)\n        {\n            if (g_strchr(s->shell, ' ') != 0 || g_strchr(s->shell, '\\t') != 0)\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Using user requested window manager on \"\n                    \"display %u with embedded arguments using a shell: %s\",\n                    s->display, s->shell);\n                const char *argv[] = {\"sh\", \"-c\", s->shell, NULL};\n                g_execvp(\"/bin/sh\", (char **)argv);\n            }\n            else\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Using user requested window manager on \"\n                    \"display %d: %s\", s->display, s->shell);\n                g_execlp3(s->shell, s->shell, 0);\n            }\n        }\n        else\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"Shell %s requested by user, but not allowed by \"\n                \"AllowAlternateShell config value.\",\n                s->shell);\n        }\n    }\n    else\n    {\n        LOG(LOG_LEVEL_DEBUG, \"The user session on display %u did \"\n            \"not request a specific window manager\", s->display);\n    }\n\n    /* try to execute user window manager if enabled */\n    if (g_cfg->enable_user_wm)\n    {\n        g_snprintf(text, sizeof(text), \"%s/%s\",\n                   g_getenv(\"HOME\"), g_cfg->user_wm);\n        if (g_file_exist(text))\n        {\n            LOG(LOG_LEVEL_INFO,\n                \"Using window manager on display %u\"\n                \" from user home directory: %s\", s->display, text);\n            g_execlp3(text, g_cfg->user_wm, 0);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_DEBUG,\n                \"The user home directory window manager configuration \"\n                \"is enabled but window manager program does not exist: %s\",\n                text);\n        }\n    }\n\n    LOG(LOG_LEVEL_INFO,\n        \"Using the default window manager on display %u: %s\",\n        s->display, g_cfg->default_wm);\n    g_execlp3(g_cfg->default_wm, g_cfg->default_wm, 0);\n\n    /* still a problem starting window manager just start xterm */\n    LOG(LOG_LEVEL_WARNING,\n        \"No window manager on display %u started, \"\n        \"so falling back to starting xterm for user debugging\",\n        s->display);\n    g_execlp3(\"xterm\", \"xterm\", 0);\n\n    /* should not get here */\n    LOG(LOG_LEVEL_ERROR, \"A fatal error has occurred attempting to start \"\n        \"the window manager on display %u, aborting connection\",\n        s->display);\n}\n\n/******************************************************************************/\nstatic struct list *\nprepare_xorg_xserver_params(const struct session_parameters *s,\n                            const char *authfile)\n{\n\n    char screen[32]; /* display number */\n    char text[128];\n    const char *xserver;\n\n    struct list *params = list_create();\n    if (params != NULL)\n    {\n        params->auto_free = 1;\n\n        /*\n         * Make sure Xorg doesn't run setuid root. Root access is not\n         * needed. Xorg can fail when run as root and the user has no\n         * console permissions.\n         */\n        if (g_cfg->sec.xorg_no_new_privileges && g_no_new_privs() != 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"[session start] (display %u): Failed to disable \"\n                \"setuid on X server: %s\",\n                s->display, g_get_strerror());\n        }\n\n        g_snprintf(screen, sizeof(screen), \":%u\", s->display);\n\n        /* some args are passed via env vars */\n        g_snprintf(text, sizeof(text), \"%d\", s->width);\n        g_setenv(\"XRDP_START_WIDTH\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", s->height);\n        g_setenv(\"XRDP_START_HEIGHT\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.max_idle_time);\n        g_setenv(\"XRDP_SESMAN_MAX_IDLE_TIME\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.max_disc_time);\n        g_setenv(\"XRDP_SESMAN_MAX_DISC_TIME\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.kill_disconnected);\n        g_setenv(\"XRDP_SESMAN_KILL_DISCONNECTED\", text, 1);\n\n        g_setenv(\"XRDP_SOCKET_PATH\", XRDP_SOCKET_PATH, 1);\n\n        /* get path of Xorg from config */\n        xserver = (const char *)list_get_item(g_cfg->xorg_params, 0);\n\n        /* these are the must have parameters */\n        list_add_strdup_multi(params,\n                              xserver, screen,\n                              \"-auth\", authfile,\n                              NULL);\n\n        /* additional parameters from sesman.ini file */\n        list_append_list_strdup(g_cfg->xorg_params, params, 1);\n    }\n\n    return params;\n}\n\n/******************************************************************************/\nstatic struct list *\nprepare_xvnc_xserver_params(const struct session_parameters *s,\n                            const char *authfile,\n                            const char *passwd_file)\n{\n    char screen[32] = {0}; /* display number */\n    char geometry[32] = {0};\n    char depth[32] = {0};\n    char guid_str[GUID_STR_SIZE];\n    const char *xserver;\n\n    struct list *params = list_create();\n    if (params != NULL)\n    {\n        params->auto_free = 1;\n\n        g_snprintf(screen, sizeof(screen), \":%u\", s->display);\n        g_snprintf(geometry, sizeof(geometry), \"%dx%d\", s->width, s->height);\n        g_snprintf(depth, sizeof(depth), \"%d\", s->bpp);\n\n        guid_to_str(&s->guid, guid_str);\n        env_check_password_file(passwd_file, guid_str);\n\n        /* get path of Xvnc from config */\n        xserver = (const char *)list_get_item(g_cfg->vnc_params, 0);\n\n        /* these are the must have parameters */\n        list_add_strdup_multi(params,\n                              xserver, screen,\n                              \"-auth\", authfile,\n                              \"-geometry\", geometry,\n                              \"-depth\", depth,\n                              \"-rfbauth\", passwd_file,\n                              NULL);\n\n        /* additional parameters from sesman.ini file */\n        //config_read_xserver_params(SCP_SESSION_TYPE_XVNC,\n        //                           xserver_params);\n        list_append_list_strdup(g_cfg->vnc_params, params, 1);\n    }\n    return params;\n}\n\n/******************************************************************************/\n/* Either execs the X server, or returns */\nstatic void\nstart_x_server(struct login_info *login_info,\n               const struct session_parameters *s)\n{\n    char authfile[256]; /* The filename for storing xauth information */\n    char execvpparams[2048];\n    char *passwd_file = NULL;\n    struct list *xserver_params = NULL;\n    int unknown_session_type = 0;\n\n    if (s->type == SCP_SESSION_TYPE_XVNC)\n    {\n        env_set_user(login_info->uid,\n                     &passwd_file,\n                     s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n    }\n    else\n    {\n        env_set_user(login_info->uid,\n                     0,\n                     s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n    }\n\n    /* prepare the Xauthority stuff */\n    if (g_getenv(\"XAUTHORITY\") != NULL)\n    {\n        g_snprintf(authfile, sizeof(authfile), \"%s\",\n                   g_getenv(\"XAUTHORITY\"));\n    }\n    else\n    {\n        g_snprintf(authfile, sizeof(authfile), \"%s\", \".Xauthority\");\n    }\n\n    /* Add the entry in XAUTHORITY file or exit if error */\n    if (add_xauth_cookie(s->display, authfile) != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Error setting the xauth cookie for display %u in file %s\",\n            s->display, authfile);\n    }\n    else\n    {\n        switch (s->type)\n        {\n            case SCP_SESSION_TYPE_XORG:\n                xserver_params = prepare_xorg_xserver_params(s, authfile);\n                break;\n\n            case SCP_SESSION_TYPE_XVNC:\n                xserver_params = prepare_xvnc_xserver_params(s, authfile,\n                                 passwd_file);\n                break;\n\n            default:\n                unknown_session_type = 1;\n        }\n\n        g_free(passwd_file);\n        passwd_file = NULL;\n\n        if (xserver_params == NULL)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Out of memory allocating X server params\");\n        }\n        else if (unknown_session_type)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Unknown session type: %d\",\n                s->type);\n        }\n        else\n        {\n            /* fire up X server */\n            LOG(LOG_LEVEL_INFO, \"Starting X server on display %u: %s\",\n                s->display,\n                dumpItemsToString(xserver_params, execvpparams, 2048));\n            LOG_DEVEL_LEAKING_FDS(\"X server\", 3, -1);\n            g_execvp_list((const char *)xserver_params->items[0],\n                          xserver_params);\n        }\n    }\n\n    /* should not get here */\n    list_delete(xserver_params);\n    LOG(LOG_LEVEL_ERROR, \"A fatal error has occurred attempting \"\n        \"to start the X server on display %u, aborting connection\",\n        s->display);\n}\n\n/******************************************************************************/\n/*\n * Simple helper process to fork a child and log errors */\nstatic int\nfork_child(\n    void (*runproc)(struct login_info *, const struct session_parameters *),\n    struct login_info *login_info,\n    const struct session_parameters *s,\n    pid_t group_pid)\n{\n    int pid = g_fork();\n    if (pid == 0)\n    {\n        /* Child process */\n        if (group_pid >= 0)\n        {\n            (void)g_setpgid(0, group_pid);\n        }\n        runproc(login_info, s);\n        g_exit(0);\n    }\n\n    if (pid < 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Fork failed [%s]\", g_get_strerror());\n    }\n\n    return pid;\n}\n\n/******************************************************************************/\nenum scp_screate_status\nsession_start_wrapped(struct login_info *login_info,\n                      const struct session_parameters *s,\n                      struct session_data *sd)\n{\n    int chansrv_pid;\n    int display_pid;\n    int window_manager_pid;\n    enum scp_screate_status status = E_SCP_SCREATE_GENERAL_ERROR;\n\n    auth_start_session(login_info->auth_info, s->display);\n#ifdef USE_BSD_SETLOGIN\n    /**\n     * Create a new session and process group since the 4.4BSD\n     * setlogin() affects the entire process group\n     */\n    if (g_setsid() < 0)\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"[session start] (display %d): setsid failed - pid %d\",\n            s->display, g_getpid());\n    }\n\n    if (g_setlogin(login_info->username) < 0)\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"[session start] (display %d): setlogin failed for user %s - pid %d\",\n            s->display, login_info->username, g_getpid());\n    }\n#endif\n\n    /* Set the secondary groups before starting the session to prevent\n     * problems on PAM-based systems (see Linux pam_setcred(3)).\n     * If we have *BSD setusercontext() this is not done here */\n#ifndef HAVE_SETUSERCONTEXT\n    if (g_initgroups(login_info->username) != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Failed to initialise secondary groups for %s: %s\",\n            login_info->username, g_get_strerror());\n        return E_SCP_SCREATE_GENERAL_ERROR;\n    }\n#endif\n\n    /* start the X server in a new process group.\n     *\n     * We group the X server, window manager and chansrv in a single\n     * process group, as it allows signals to be sent to the user session\n     * without affecting sesexec (and vice-versa). This is particularly\n     * important when debugging sesexec as we don't want a SIGINT in\n     * the debugger to be passed to the children */\n    display_pid = fork_child(start_x_server, login_info, s, 0);\n    if (display_pid > 0)\n    {\n        enum xwait_status xws;\n        xws = wait_for_xserver(login_info->uid,\n                               g_cfg->env_names,\n                               g_cfg->env_values,\n                               s->display);\n\n        if (xws != XW_STATUS_OK)\n        {\n            switch (xws)\n            {\n                case XW_STATUS_TIMED_OUT:\n                    LOG(LOG_LEVEL_ERROR, \"Timed out waiting for X server\");\n                    break;\n                case XW_STATUS_FAILED_TO_START:\n                    LOG(LOG_LEVEL_ERROR, \"X server failed to start\");\n                    break;\n                default:\n                    LOG(LOG_LEVEL_ERROR,\n                        \"An error occurred waiting for the X server\");\n            }\n            status = E_SCP_SCREATE_X_SERVER_FAIL;\n            /* Kill it anyway in case it did start and we just failed to\n             * pick up on it */\n            g_sigterm(display_pid);\n            g_waitpid(display_pid);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_INFO, \"X server :%d is working\", s->display);\n            LOG(LOG_LEVEL_INFO, \"Starting window manager for display :%d\",\n                s->display);\n\n            window_manager_pid = fork_child(start_window_manager,\n                                            login_info, s, display_pid);\n            if (window_manager_pid < 0)\n            {\n                g_sigterm(display_pid);\n                g_waitpid(display_pid);\n            }\n            else\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Starting the xrdp channel server for display :%d\",\n                    s->display);\n\n                chansrv_pid = fork_child(start_chansrv, login_info,\n                                         s, display_pid);\n\n                // Tell the caller we've started\n                LOG(LOG_LEVEL_INFO,\n                    \"Session in progress on display :%d. Waiting until the \"\n                    \"window manager (pid %d) exits to end the session\",\n                    s->display, window_manager_pid);\n\n                sd->win_mgr = window_manager_pid;\n                sd->x_server = display_pid;\n                sd->chansrv = chansrv_pid;\n                sd->start_time = g_time1();\n                status = E_SCP_SCREATE_OK;\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/******************************************************************************/\nenum scp_screate_status\nsession_start(struct login_info *login_info,\n              const struct session_parameters *sp,\n              struct session_data **session_data)\n{\n    enum scp_screate_status status = E_SCP_SCREATE_GENERAL_ERROR;\n    /* Create the session_data struct first */\n    struct session_data *sd = session_data_new(sp);\n    if (sd == NULL)\n    {\n        status = E_SCP_SCREATE_NO_MEMORY;\n    }\n    else\n    {\n        status = session_start_wrapped(login_info, sp, sd);\n        if (status == E_SCP_SCREATE_OK)\n        {\n            *session_data = sd;\n        }\n        else\n        {\n            *session_data = NULL;\n            session_data_free(sd);\n        }\n    }\n\n    return status;\n}\n\n/******************************************************************************/\nstatic int\ncleanup_sockets(int display)\n{\n    LOG(LOG_LEVEL_INFO, \"cleanup_sockets:\");\n    char file[256];\n    int error;\n\n    error = 0;\n\n    g_snprintf(file, 255, CHANSRV_PORT_OUT_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, CHANSRV_PORT_IN_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, XRDP_CHANSRV_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, CHANSRV_API_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    /* the following files should be deleted by xorgxrdp\n     * but just in case the deletion failed */\n\n    g_snprintf(file, 255, XRDP_X11RDP_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, XRDP_DISCONNECT_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    return error;\n}\n\n/******************************************************************************/\nstatic void\nexit_status_to_str(const struct exit_status *e, char buff[], int bufflen)\n{\n    switch (e->reason)\n    {\n        case E_XR_STATUS_CODE:\n            if (e->val == 0)\n            {\n                g_snprintf(buff, bufflen, \"exit code zero\");\n            }\n            else\n            {\n                g_snprintf(buff, bufflen, \"non-zero exit code %d\", e->val);\n            }\n            break;\n\n        case E_XR_SIGNAL:\n        {\n            char sigstr[MAXSTRSIGLEN];\n            g_snprintf(buff, bufflen, \"signal %s\",\n                       g_sig2text(e->val, sigstr));\n        }\n        break;\n\n        default:\n            g_snprintf(buff, bufflen, \"an unexpected error\");\n            break;\n    }\n}\n\n/******************************************************************************/\nvoid\nsession_process_child_exit(struct session_data *sd,\n                           int pid,\n                           const struct exit_status *e)\n{\n    if (pid == sd->x_server)\n    {\n        LOG(LOG_LEVEL_INFO, \"X server pid %d on display :%d finished\",\n            sd->x_server, sd->params.display);\n        sd->x_server = -1;\n        // No other action - window manager should be going soon\n    }\n    else if (pid == sd->chansrv)\n    {\n        LOG(LOG_LEVEL_INFO,\n            \"xrdp channel server pid %d on display :%d finished\",\n            sd->chansrv, sd->params.display);\n        sd->chansrv = -1;\n    }\n    else if (pid == sd->win_mgr)\n    {\n        int wm_wait_time = g_time1() - sd->start_time;\n\n        if (e->reason == E_XR_STATUS_CODE && e->val == 0)\n        {\n            LOG(LOG_LEVEL_INFO,\n                \"Window manager (pid %d, display %d) \"\n                \"finished normally in %d secs\",\n                sd->win_mgr, sd->params.display, wm_wait_time);\n        }\n        else\n        {\n            char reason[128];\n            exit_status_to_str(e, reason, sizeof(reason));\n\n            LOG(LOG_LEVEL_WARNING, \"Window manager (pid %d, display %d) \"\n                \"exited with %s. This \"\n                \"could indicate a window manager config problem\",\n                sd->win_mgr, sd->params.display, reason);\n        }\n        if (wm_wait_time < 10)\n        {\n            /* This could be a config issue. Log a significant error */\n            LOG(LOG_LEVEL_WARNING, \"Window manager (pid %d, display %d) \"\n                \"exited quickly (%d secs). This could indicate a window \"\n                \"manager config problem\",\n                sd->win_mgr, sd->params.display, wm_wait_time);\n        }\n\n        sd->win_mgr = -1;\n\n        if (sd->x_server > 0)\n        {\n            LOG(LOG_LEVEL_INFO, \"Terminating X server (pid %d) on display :%d\",\n                sd->x_server, sd->params.display);\n            g_sigterm(sd->x_server);\n        }\n\n        if (sd->chansrv > 0)\n        {\n            LOG(LOG_LEVEL_INFO, \"Terminating the xrdp channel server (pid %d) \"\n                \"on display :%d\", sd->chansrv, sd->params.display);\n            g_sigterm(sd->chansrv);\n        }\n    }\n\n    if (!session_active(sd))\n    {\n        cleanup_sockets(sd->params.display);\n    }\n}\n\n/******************************************************************************/\nunsigned int\nsession_active(const struct session_data *sd)\n{\n    return\n        (sd == NULL)\n        ? 0\n        : (sd->win_mgr > 0) + (sd->x_server > 0) + (sd->chansrv > 0);\n}\n\n/******************************************************************************/\ntime_t\nsession_get_start_time(const struct session_data *sd)\n{\n    return (sd == NULL) ? 0 : sd->start_time;\n}\n\n/******************************************************************************/\nvoid\nsession_send_term(struct session_data *sd)\n{\n    if (sd != NULL && sd->win_mgr > 0)\n    {\n        g_sigterm(sd->win_mgr);\n    }\n}\n\n/******************************************************************************/\nstatic void\nstart_reconnect_script(struct login_info *login_info,\n                       const struct session_parameters *s)\n{\n    env_set_user(login_info->uid, 0, s->display,\n                 g_cfg->env_names,\n                 g_cfg->env_values);\n\n    auth_set_env(login_info->auth_info);\n\n    if (g_file_exist(g_cfg->reconnect_sh))\n    {\n        LOG_DEVEL_LEAKING_FDS(\"reconnect script\", 3, -1);\n\n        LOG(LOG_LEVEL_INFO,\n            \"Starting session reconnection script on display %d: %s\",\n            s->display, g_cfg->reconnect_sh);\n        g_execlp3(g_cfg->reconnect_sh, g_cfg->reconnect_sh, 0);\n\n        /* should not get here */\n        LOG(LOG_LEVEL_ERROR,\n            \"Error starting session reconnection script on display %d: %s\",\n            s->display, g_cfg->reconnect_sh);\n    }\n    else\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"Session reconnection script file does not exist: %s\",\n            g_cfg->reconnect_sh);\n    }\n}\n\n/******************************************************************************/\nvoid\nsession_reconnect(struct login_info *login_info,\n                  struct session_data *sd)\n{\n    if (fork_child(start_reconnect_script,\n                   login_info, &sd->params, sd->x_server) < 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Failed to fork for session reconnection script\");\n    }\n}\n"], "fixing_code": ["/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2013\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file verify_user_pam.c\n * @brief Authenticate user using pam\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"arch.h\"\n#include \"os_calls.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n#include \"sesman_auth.h\"\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n/* Allows the conversation function to find required items */\nstruct conv_func_data\n{\n    const char *pass;\n};\n\nstruct auth_info\n{\n    int session_opened;\n    int did_setcred;\n    pam_handle_t *ph;\n};\n\n/***************************************************************************//**\n * Returns a string representing a pam_conv message style\n *\n * @param msg_style PAM msg_style (pam_conv(3))\n * @param buff      Buffer for conversion of unrecognised values\n * @param bufflen   Total length of above\n *\n * The buffer described by buff is only written to if required.\n */\nstatic const char *\nmsg_style_to_str(int msg_style, char *buff, unsigned int bufflen)\n{\n    const char *result;\n    switch (msg_style)\n    {\n        case PAM_PROMPT_ECHO_OFF:\n            result = \"PAM_PROMPT_ECHO_OFF\";\n            break;\n\n        case PAM_PROMPT_ECHO_ON:\n            result = \"PAM_PROMPT_ECHO_ON\";\n            break;\n\n        case PAM_ERROR_MSG:\n            result = \"PAM_ERROR_MSG\";\n            break;\n\n        case PAM_TEXT_INFO:\n            result = \"PAM_TEXT_INFO\";\n            break;\n\n        default:\n            g_snprintf(buff, bufflen, \"UNKNOWN_0x%x\", msg_style);\n            result = buff;\n    }\n\n    return result;\n}\n\n/***************************************************************************//**\n * Provides the PAM conversation callback function\n *\n * At present, the main purpose of this function is to supply the\n * user's password to the PAM stack, although some module logging is\n * implemented here.\n *\n * @param[in] num_msg Count of messages in the msg array\n * @param[in] msg Messages from the PAM stack to the application\n * @param[out] resp Message replies from the application to the PAM stack\n * @param[in] appdata_ptr Used to pass in a struct conv_func_data pointer\n *\n * @result PAM_SUCCESS if the messages were all processed successfully.\n *\n * @post If PAM_SUCCESS is returned, resp and its contents are allocated here\n *       and must be freed by the caller\n * @post If PAM_SUCCESS is not returned, resp is not allocated and must not\n *       be not freed by the caller\n *\n * @note See pam_conv(3) for more information\n * @note A basic example conversation function can be found in OSF RFC\n         86.0 (1995)\n */\n\nstatic int\nverify_pam_conv(int num_msg, const struct pam_message **msg,\n                struct pam_response **resp, void *appdata_ptr)\n{\n    int i;\n    struct pam_response *reply = NULL;\n    struct conv_func_data *conv_func_data;\n    char sb[64];\n    int rv = PAM_SUCCESS;\n\n    if (num_msg <= 0 || num_msg > PAM_MAX_NUM_MSG)\n    {\n        rv = PAM_CONV_ERR;\n    }\n    else if ((reply = g_new0(struct pam_response, num_msg)) == NULL)\n    {\n        rv = PAM_BUF_ERR;\n    }\n    else\n    {\n        for (i = 0; i < num_msg && rv == PAM_SUCCESS; i++)\n        {\n            LOG_DEVEL(LOG_LEVEL_INFO, \"Handling struct pam_message\"\n                      \" { style = %s, msg = \\\"%s\\\" }\",\n                      msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)),\n                      msg[i]->msg == NULL ? \"<null>\" : msg[i]->msg);\n\n            switch (msg[i]->msg_style)\n            {\n                case PAM_PROMPT_ECHO_OFF: /* password */\n                    conv_func_data = (struct conv_func_data *) appdata_ptr;\n                    /* Check this function isn't being called\n                     * later than we expected */\n                    if (conv_func_data == NULL || conv_func_data->pass == NULL)\n                    {\n                        LOG(LOG_LEVEL_ERROR,\n                            \"verify_pam_conv: Password unavailable\");\n                        reply[i].resp = g_strdup(\"????\");\n                    }\n                    else\n                    {\n                        reply[i].resp = g_strdup(conv_func_data->pass);\n                    }\n                    break;\n\n                case PAM_ERROR_MSG:\n                    LOG(LOG_LEVEL_ERROR, \"PAM: %s\", msg[i]->msg);\n                    break;\n\n                case PAM_TEXT_INFO:\n                    LOG(LOG_LEVEL_INFO, \"PAM: %s\", msg[i]->msg);\n                    break;\n\n                default:\n                {\n                    LOG(LOG_LEVEL_ERROR, \"Unhandled message in verify_pam_conv\"\n                        \" { style = %s, msg = \\\"%s\\\" }\",\n                        msg_style_to_str(msg[i]->msg_style, sb, sizeof (sb)),\n                        msg[i]->msg == NULL ? \"<null>\" : msg[i]->msg);\n                    rv = PAM_CONV_ERR;\n                }\n            }\n        }\n    }\n\n    if (rv == PAM_SUCCESS)\n    {\n        *resp = reply;\n    }\n    else if (reply != NULL)\n    {\n        for (i = 0; i < num_msg; i++)\n        {\n            if (reply[i].resp != NULL)\n            {\n                g_free(reply[i].resp);\n            }\n        }\n        g_free(reply);\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\nstatic void\nget_service_name(char *service_name)\n{\n    service_name[0] = 0;\n\n    if (g_file_exist(\"/etc/pam.d/xrdp-sesman\") ||\n#ifdef __LINUX_PAM__\n            /* /usr/lib/pam.d is hardcoded into Linux-PAM */\n            g_file_exist(\"/usr/lib/pam.d/xrdp-sesman\") ||\n#endif\n#ifdef OPENPAM_VERSION\n            /* /usr/local/etc/pam.d is hardcoded into OpenPAM */\n            g_file_exist(\"/usr/local/etc/pam.d/xrdp-sesman\") ||\n#endif\n            g_file_exist(XRDP_PAMCONF_PATH \"/xrdp-sesman\"))\n    {\n        g_strncpy(service_name, \"xrdp-sesman\", 255);\n    }\n    else\n    {\n        g_strncpy(service_name, \"gdm\", 255);\n    }\n}\n\n/******************************************************************************/\n\n/** Performs PAM operations common to login methods\n *\n * @param auth_info Module auth_info structure\n * @param user User name\n * @param pass Password, if needed for authentication.\n * @param client_ip Client IP if known, or NULL\n * @param authentication_required True if user must be authenticated\n *\n * For a UDS connection, the user can be assumed to be authenticated,\n * so in this instance authentication_required can be false.\n *\n * @return Code describing the success of the operation\n */\nstatic enum scp_login_status\ncommon_pam_login(struct auth_info *auth_info,\n                 const char *user,\n                 const char *pass,\n                 const char *client_ip,\n                 int authentication_required)\n{\n    int perror;\n    char service_name[256];\n    struct conv_func_data conv_func_data;\n    struct pam_conv pamc;\n\n    /*\n     * Set up the data required by the conversation function, and the\n     * structure which allows us to pass this to pam_start()\n     */\n    conv_func_data.pass = (authentication_required) ? pass : NULL;\n    pamc.conv = verify_pam_conv;\n    pamc.appdata_ptr = (void *) &conv_func_data;\n\n    get_service_name(service_name);\n    perror = pam_start(service_name, user, &pamc, &(auth_info->ph));\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_start failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_GENERAL_ERROR;\n    }\n\n    if (client_ip != NULL && client_ip[0] != '\\0')\n    {\n        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_RHOST) failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n        }\n    }\n\n    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_TTY) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    if (authentication_required)\n    {\n        perror = pam_authenticate(auth_info->ph, 0);\n\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_authenticate failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n            pam_end(auth_info->ph, perror);\n            return E_SCP_LOGIN_NOT_AUTHENTICATED;\n        }\n    }\n    /* From man page:\n       The pam_acct_mgmt function is used to determine if the users account is\n       valid. It checks for authentication token and account expiration and\n       verifies access restrictions. It is typically called after the user has\n       been authenticated.\n     */\n    perror = pam_acct_mgmt(auth_info->ph, 0);\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_acct_mgmt failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_NOT_AUTHORIZED;\n    }\n\n    /* Set the appdata_ptr passed to the conversation function to\n     * NULL, as the existing value is going out of scope */\n    pamc.appdata_ptr = NULL;\n    perror = pam_set_item(auth_info->ph, PAM_CONV, &pamc);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_CONV) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    return E_SCP_LOGIN_OK;\n}\n\n\n/******************************************************************************/\n/* returns non-NULL for success\n * Detailed error code is in the errorcode variable */\n\nstruct auth_info *\nauth_userpass(const char *user, const char *pass,\n              const char *client_ip, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        status = common_pam_login(auth_info, user, pass, client_ip, 1);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\nstruct auth_info *\nauth_uds(const char *user, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        status = common_pam_login(auth_info, user, NULL, NULL, 0);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\n/* returns error */\nstatic int\nauth_start_session_private(struct auth_info *auth_info, int display_num)\n{\n    int error;\n    char display[256];\n\n    g_sprintf(display, \":%d\", display_num);\n    error = pam_set_item(auth_info->ph, PAM_TTY, display);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    error = pam_setcred(auth_info->ph, PAM_ESTABLISH_CRED);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_setcred failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->did_setcred = 1;\n    error = pam_open_session(auth_info->ph, 0);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_open_session failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->session_opened = 1;\n    return 0;\n}\n\n/******************************************************************************/\n/**\n * Main routine to start a session\n *\n * Calls the private routine and logs an additional error if the private\n * routine fails\n */\nint\nauth_start_session(struct auth_info *auth_info, int display_num)\n{\n    int result = auth_start_session_private(auth_info, display_num);\n    if (result != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Can't start PAM session. See PAM logging for more info\");\n    }\n\n    return result;\n}\n\n/******************************************************************************/\n/* returns error */\nstatic int\nauth_stop_session(struct auth_info *auth_info)\n{\n    int rv = 0;\n    int error;\n\n    if (auth_info->session_opened)\n    {\n        error = pam_close_session(auth_info->ph, 0);\n        if (error != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_close_session failed: %s\",\n                pam_strerror(auth_info->ph, error));\n            rv = 1;\n        }\n        else\n        {\n            auth_info->session_opened = 0;\n        }\n    }\n\n    if (auth_info->did_setcred)\n    {\n        pam_setcred(auth_info->ph, PAM_DELETE_CRED);\n        auth_info->did_setcred = 0;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\n/* returns error */\n/* cleanup */\nint\nauth_end(struct auth_info *auth_info)\n{\n    if (auth_info != NULL)\n    {\n        if (auth_info->ph != 0)\n        {\n            auth_stop_session(auth_info);\n\n            pam_end(auth_info->ph, PAM_SUCCESS);\n            auth_info->ph = 0;\n        }\n    }\n\n    g_free(auth_info);\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\n/* set any pam env vars */\nint\nauth_set_env(struct auth_info *auth_info)\n{\n    char **pam_envlist;\n    char **pam_env;\n\n    if (auth_info != NULL)\n    {\n        /* export PAM environment */\n        pam_envlist = pam_getenvlist(auth_info->ph);\n\n        if (pam_envlist != NULL)\n        {\n            for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env)\n            {\n                char *str = *pam_env;\n                int eq_pos = g_pos(str, \"=\");\n\n                if (eq_pos > 0)\n                {\n                    str[eq_pos] = '\\0';\n                    g_setenv(str, str + eq_pos + 1, 1);\n                }\n\n                g_free(str);\n            }\n\n            g_free(pam_envlist);\n        }\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2013\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file verify_user_pam.c\n * @brief Authenticate user using pam\n * @author Jay Sorg\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include <config_ac.h>\n#endif\n\n#include \"arch.h\"\n#include \"os_calls.h\"\n#include \"log.h\"\n#include \"string_calls.h\"\n#include \"sesman_auth.h\"\n\n#include <security/pam_userpass.h>\n\n#include <stdio.h>\n#include <security/pam_appl.h>\n\n#define SERVICE \"xrdp\"\n\nstruct auth_info\n{\n    pam_userpass_t userpass;\n    int session_opened;\n    int did_setcred;\n    struct pam_conv pamc;\n    pam_handle_t *ph;\n};\n\n/******************************************************************************/\n\n/** Performs PAM operations common to login methods\n *\n * @param auth_info Module auth_info structure\n * @param client_ip Client IP if known, or NULL\n * @param need_pam_authenticate True if user must be authenticated as\n *                              well as authorized\n * @return Code describing the success of the operation\n *\n * The username is assumed to be supplied by the caller in\n * auth_info->userpass.user\n */\nstatic enum scp_login_status\ncommon_pam_login(struct auth_info *auth_info,\n                 const char *client_ip,\n                 int need_pam_authenticate)\n{\n    int perror;\n    char service_name[256];\n\n    perror = pam_start(SERVICE, auth_info->userpass.user,\n                       &(auth_info->pamc), &(auth_info->ph));\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_start failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_GENERAL_ERROR;\n    }\n\n    if (client_ip != NULL && client_ip[0] != '\\0')\n    {\n        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_RHOST) failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n        }\n    }\n\n    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item(PAM_TTY) failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n    }\n\n    if (need_pam_authenticate)\n    {\n        perror = pam_authenticate(auth_info->ph, 0);\n\n        if (perror != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_authenticate failed: %s\",\n                pam_strerror(auth_info->ph, perror));\n            pam_end(auth_info->ph, perror);\n            return E_SCP_LOGIN_NOT_AUTHENTICATED;\n        }\n    }\n    /* From man page:\n       The pam_acct_mgmt function is used to determine if the users account is\n       valid. It checks for authentication token and account expiration and\n       verifies access restrictions. It is typically called after the user has\n       been authenticated.\n     */\n    perror = pam_acct_mgmt(auth_info->ph, 0);\n\n    if (perror != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_acct_mgmt failed: %s\",\n            pam_strerror(auth_info->ph, perror));\n        pam_end(auth_info->ph, perror);\n        return E_SCP_LOGIN_NOT_AUTHORIZED;\n    }\n\n    return E_SCP_LOGIN_OK;\n}\n\n\n/******************************************************************************/\n/* returns non-NULL for success\n * Detailed error code is in the errorcode variable */\n\nstruct auth_info *\nauth_userpass(const char *user, const char *pass,\n              const char *client_ip, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        auth_info->userpass.user = user;\n        auth_info->userpass.pass = pass;\n\n        auth_info->pamc.conv = &pam_userpass_conv;\n        auth_info->pamc.appdata_ptr = &(auth_info->userpass);\n        status = common_pam_login(auth_info, client_ip, 1);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\nstruct auth_info *\nauth_uds(const char *user, enum scp_login_status *errorcode)\n{\n    struct auth_info *auth_info;\n    enum scp_login_status status;\n\n    auth_info = g_new0(struct auth_info, 1);\n    if (auth_info == NULL)\n    {\n        status = E_SCP_LOGIN_NO_MEMORY;\n    }\n    else\n    {\n        auth_info->userpass.user = user;\n        status = common_pam_login(auth_info, NULL, 0);\n\n        if (status != E_SCP_LOGIN_OK)\n        {\n            g_free(auth_info);\n            auth_info = NULL;\n        }\n    }\n\n    if (errorcode != NULL)\n    {\n        *errorcode = status;\n    }\n\n    return auth_info;\n}\n\n/******************************************************************************/\n\n/* returns error */\nstatic int\nauth_start_session_private(struct auth_info *auth_info, int display_num)\n{\n    int error;\n    char display[256];\n\n    g_sprintf(display, \":%d\", display_num);\n    error = pam_set_item(auth_info->ph, PAM_TTY, display);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_set_item failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    error = pam_setcred(auth_info->ph, PAM_ESTABLISH_CRED);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_setcred failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->did_setcred = 1;\n    error = pam_open_session(auth_info->ph, 0);\n\n    if (error != PAM_SUCCESS)\n    {\n        LOG(LOG_LEVEL_ERROR, \"pam_open_session failed: %s\",\n            pam_strerror(auth_info->ph, error));\n        return 1;\n    }\n\n    auth_info->session_opened = 1;\n    return 0;\n}\n\n/******************************************************************************/\n/**\n * Main routine to start a session\n *\n * Calls the private routine and logs an additional error if the private\n * routine fails\n */\nint\nauth_start_session(struct auth_info *auth_info, int display_num)\n{\n    int result = auth_start_session_private(auth_info, display_num);\n    if (result != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Can't start PAM session. See PAM logging for more info\");\n    }\n\n    return result;\n}\n\n/******************************************************************************/\n/* returns error */\nstatic int\nauth_stop_session(struct auth_info *auth_info)\n{\n    int rv = 0;\n    int error;\n\n    if (auth_info->session_opened)\n    {\n        error = pam_close_session(auth_info->ph, 0);\n        if (error != PAM_SUCCESS)\n        {\n            LOG(LOG_LEVEL_ERROR, \"pam_close_session failed: %s\",\n                pam_strerror(auth_info->ph, error));\n            rv = 1;\n        }\n        else\n        {\n            auth_info->session_opened = 0;\n        }\n    }\n\n    if (auth_info->did_setcred)\n    {\n        pam_setcred(auth_info->ph, PAM_DELETE_CRED);\n        auth_info->did_setcred = 0;\n    }\n\n    return rv;\n}\n\n/******************************************************************************/\n/* returns error */\n/* cleanup */\nint\nauth_end(struct auth_info *auth_info)\n{\n    if (auth_info != NULL)\n    {\n        if (auth_info->ph != 0)\n        {\n            auth_stop_session(auth_info);\n\n            pam_end(auth_info->ph, PAM_SUCCESS);\n            auth_info->ph = 0;\n        }\n    }\n\n    g_free(auth_info);\n    return 0;\n}\n\n/******************************************************************************/\n/* returns error */\n/* set any pam env vars */\nint\nauth_set_env(struct auth_info *auth_info)\n{\n    char **pam_envlist;\n    char **pam_env;\n\n    if (auth_info != NULL)\n    {\n        /* export PAM environment */\n        pam_envlist = pam_getenvlist(auth_info->ph);\n\n        if (pam_envlist != NULL)\n        {\n            for (pam_env = pam_envlist; *pam_env != NULL; ++pam_env)\n            {\n                char *str = *pam_env;\n                int eq_pos = g_pos(str, \"=\");\n\n                if (eq_pos > 0)\n                {\n                    str[eq_pos] = '\\0';\n                    g_setenv(str, str + eq_pos + 1, 1);\n                }\n\n                g_free(str);\n            }\n\n            g_free(pam_envlist);\n        }\n    }\n\n    return 0;\n}\n", "/**\n * xrdp: A Remote Desktop Protocol server.\n *\n * Copyright (C) Jay Sorg 2004-2015\n *\n * BSD process grouping by:\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland.\n * Copyright (c) 2000-2001 Markus Friedl.\n * Copyright (c) 2011-2015 Koichiro Iwao, Kyushu Institute of Technology.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n *\n * @file session.c\n * @brief Session management code\n * @author Jay Sorg, Simone Fedele\n *\n */\n\n#if defined(HAVE_CONFIG_H)\n#include \"config_ac.h\"\n#endif\n\n#include <errno.h>\n\n#include \"arch.h\"\n#include \"session.h\"\n\n#include \"sesman_auth.h\"\n#include \"sesman_config.h\"\n#include \"env.h\"\n#include \"guid.h\"\n#include \"list.h\"\n#include \"log.h\"\n#include \"login_info.h\"\n#include \"os_calls.h\"\n#include \"sesexec.h\"\n#include \"string_calls.h\"\n#include \"xauth.h\"\n#include \"xwait.h\"\n#include \"xrdp_sockets.h\"\n\nstruct session_data\n{\n    pid_t x_server; ///< PID of X server\n    pid_t win_mgr; ///< PID of window manager\n    pid_t chansrv; //< PID of chansrv\n    time_t start_time;\n    struct session_parameters params;\n    // Flexible array member used to store strings in params and ip_addr;\n#ifdef __cplusplus\n    char strings[1];\n#else\n    char strings[];\n#endif\n};\n\n/******************************************************************************/\n/**\n * Create a new session_data structure from a session_parameters object\n *\n * @param sp Session parameters passed to session_start()\n * @return semi-initialised session_data struct\n */\nstatic struct session_data *\nsession_data_new(const struct session_parameters *sp)\n{\n    unsigned int string_length = 0;\n    // What string length do we need?\n    string_length += g_strlen(sp->shell) + 1;\n    string_length += g_strlen(sp->directory) + 1;\n\n    struct session_data *sd = (struct session_data *)g_malloc(sizeof(*sd) + string_length, 0);\n\n    if (sd == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Out of memory allocating session data struct\");\n    }\n    else\n    {\n        sd->win_mgr = -1;\n        sd->x_server = -1;\n        sd->chansrv = -1;\n        sd->start_time = 0;\n\n        /* Copy all the non-string session parameters... */\n        sd->params = *sp;\n\n        /* ...and then the strings */\n        char *memptr = sd->strings;\n\n#define COPY_STRING(dest,src) \\\n    (dest) = memptr; \\\n    strcpy(memptr, src); \\\n    memptr += strlen(memptr) + 1\n\n        COPY_STRING(sd->params.shell, sp->shell);\n        COPY_STRING(sd->params.directory, sp->directory);\n\n#undef COPY_STRING\n    }\n\n    return sd;\n}\n\n/******************************************************************************/\nvoid\nsession_data_free(struct session_data *session_data)\n{\n    if (session_data != NULL)\n    {\n#ifdef USE_DEVEL_LOGGING\n        if (session_data->win_mgr > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid window manager PID %d\",\n                      session_data->win_mgr);\n        }\n        if (session_data->x_server > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid X server PID %d\",\n                      session_data->x_server);\n        }\n        if (session_data->chansrv > 0)\n        {\n            LOG_DEVEL(LOG_LEVEL_WARNING,\n                      \"Freeing session data with valid chansrv PID %d\",\n                      session_data->chansrv);\n        }\n#endif\n\n        free(session_data);\n    }\n}\n\n/******************************************************************************/\n/**\n * Creates a string consisting of all parameters that is hosted in the param list\n * @param self\n * @param outstr, allocate this buffer before you use this function\n * @param len the allocated len for outstr\n * @return\n */\nchar *\ndumpItemsToString(struct list *self, char *outstr, int len)\n{\n    int index;\n    int totalLen = 0;\n\n    g_memset(outstr, 0, len);\n    if (self->count == 0)\n    {\n        LOG_DEVEL(LOG_LEVEL_TRACE, \"List is empty\");\n    }\n\n    for (index = 0; index < self->count; index++)\n    {\n        /* +1 = one space*/\n        totalLen = totalLen + g_strlen((char *)list_get_item(self, index)) + 1;\n\n        if (len > totalLen)\n        {\n            g_strcat(outstr, (char *)list_get_item(self, index));\n            g_strcat(outstr, \" \");\n        }\n    }\n\n    return outstr ;\n}\n\n/******************************************************************************/\nstatic void\nstart_chansrv(struct login_info *login_info,\n              const struct session_parameters *s)\n{\n    struct list *chansrv_params = list_create();\n    const char *exe_path = XRDP_SBIN_PATH \"/xrdp-chansrv\";\n\n    if (chansrv_params != NULL)\n    {\n        chansrv_params->auto_free = 1;\n        if (!list_add_strdup(chansrv_params, exe_path))\n        {\n            list_delete(chansrv_params);\n            chansrv_params = NULL;\n        }\n    }\n\n    if (chansrv_params == NULL)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Out of memory starting chansrv\");\n    }\n    else\n    {\n        env_set_user(login_info->uid, 0, s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n\n        LOG_DEVEL_LEAKING_FDS(\"chansrv\", 3, -1);\n\n        /* executing chansrv */\n        g_execvp_list(exe_path, chansrv_params);\n\n        /* should not get here */\n        list_delete(chansrv_params);\n    }\n}\n\n/******************************************************************************/\nstatic void\nstart_window_manager(struct login_info *login_info,\n                     const struct session_parameters *s)\n{\n    char text[256];\n\n    env_set_user(login_info->uid,\n                 0,\n                 s->display,\n                 g_cfg->env_names,\n                 g_cfg->env_values);\n\n    auth_set_env(login_info->auth_info);\n    LOG_DEVEL_LEAKING_FDS(\"window manager\", 3, -1);\n\n    if (s->directory[0] != '\\0')\n    {\n        if (g_cfg->sec.allow_alternate_shell)\n        {\n            g_set_current_dir(s->directory);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"Directory change to %s requested, but not \"\n                \"allowed by AllowAlternateShell config value.\",\n                s->directory);\n        }\n    }\n\n    if (s->shell[0] != '\\0')\n    {\n        if (g_cfg->sec.allow_alternate_shell)\n        {\n            if (g_strchr(s->shell, ' ') != 0 || g_strchr(s->shell, '\\t') != 0)\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Using user requested window manager on \"\n                    \"display %u with embedded arguments using a shell: %s\",\n                    s->display, s->shell);\n                const char *argv[] = {\"sh\", \"-c\", s->shell, NULL};\n                g_execvp(\"/bin/sh\", (char **)argv);\n            }\n            else\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Using user requested window manager on \"\n                    \"display %d: %s\", s->display, s->shell);\n                g_execlp3(s->shell, s->shell, 0);\n            }\n        }\n        else\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"Shell %s requested by user, but not allowed by \"\n                \"AllowAlternateShell config value.\",\n                s->shell);\n        }\n    }\n    else\n    {\n        LOG(LOG_LEVEL_DEBUG, \"The user session on display %u did \"\n            \"not request a specific window manager\", s->display);\n    }\n\n    /* try to execute user window manager if enabled */\n    if (g_cfg->enable_user_wm)\n    {\n        g_snprintf(text, sizeof(text), \"%s/%s\",\n                   g_getenv(\"HOME\"), g_cfg->user_wm);\n        if (g_file_exist(text))\n        {\n            LOG(LOG_LEVEL_INFO,\n                \"Using window manager on display %u\"\n                \" from user home directory: %s\", s->display, text);\n            g_execlp3(text, g_cfg->user_wm, 0);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_DEBUG,\n                \"The user home directory window manager configuration \"\n                \"is enabled but window manager program does not exist: %s\",\n                text);\n        }\n    }\n\n    LOG(LOG_LEVEL_INFO,\n        \"Using the default window manager on display %u: %s\",\n        s->display, g_cfg->default_wm);\n    g_execlp3(g_cfg->default_wm, g_cfg->default_wm, 0);\n\n    /* still a problem starting window manager just start xterm */\n    LOG(LOG_LEVEL_WARNING,\n        \"No window manager on display %u started, \"\n        \"so falling back to starting xterm for user debugging\",\n        s->display);\n    g_execlp3(\"xterm\", \"xterm\", 0);\n\n    /* should not get here */\n    LOG(LOG_LEVEL_ERROR, \"A fatal error has occurred attempting to start \"\n        \"the window manager on display %u, aborting connection\",\n        s->display);\n}\n\n/******************************************************************************/\nstatic struct list *\nprepare_xorg_xserver_params(const struct session_parameters *s,\n                            const char *authfile)\n{\n\n    char screen[32]; /* display number */\n    char text[128];\n    const char *xserver;\n\n    struct list *params = list_create();\n    if (params != NULL)\n    {\n        params->auto_free = 1;\n\n        /*\n         * Make sure Xorg doesn't run setuid root. Root access is not\n         * needed. Xorg can fail when run as root and the user has no\n         * console permissions.\n         */\n        if (g_cfg->sec.xorg_no_new_privileges && g_no_new_privs() != 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"[session start] (display %u): Failed to disable \"\n                \"setuid on X server: %s\",\n                s->display, g_get_strerror());\n        }\n\n        g_snprintf(screen, sizeof(screen), \":%u\", s->display);\n\n        /* some args are passed via env vars */\n        g_snprintf(text, sizeof(text), \"%d\", s->width);\n        g_setenv(\"XRDP_START_WIDTH\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", s->height);\n        g_setenv(\"XRDP_START_HEIGHT\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.max_idle_time);\n        g_setenv(\"XRDP_SESMAN_MAX_IDLE_TIME\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.max_disc_time);\n        g_setenv(\"XRDP_SESMAN_MAX_DISC_TIME\", text, 1);\n\n        g_snprintf(text, sizeof(text), \"%d\", g_cfg->sess.kill_disconnected);\n        g_setenv(\"XRDP_SESMAN_KILL_DISCONNECTED\", text, 1);\n\n        g_setenv(\"XRDP_SOCKET_PATH\", XRDP_SOCKET_PATH, 1);\n\n        /* get path of Xorg from config */\n        xserver = (const char *)list_get_item(g_cfg->xorg_params, 0);\n\n        /* these are the must have parameters */\n        list_add_strdup_multi(params,\n                              xserver, screen,\n                              \"-auth\", authfile,\n                              NULL);\n\n        /* additional parameters from sesman.ini file */\n        list_append_list_strdup(g_cfg->xorg_params, params, 1);\n    }\n\n    return params;\n}\n\n/******************************************************************************/\nstatic struct list *\nprepare_xvnc_xserver_params(const struct session_parameters *s,\n                            const char *authfile,\n                            const char *passwd_file)\n{\n    char screen[32] = {0}; /* display number */\n    char geometry[32] = {0};\n    char depth[32] = {0};\n    char guid_str[GUID_STR_SIZE];\n    const char *xserver;\n\n    struct list *params = list_create();\n    if (params != NULL)\n    {\n        params->auto_free = 1;\n\n        g_snprintf(screen, sizeof(screen), \":%u\", s->display);\n        g_snprintf(geometry, sizeof(geometry), \"%dx%d\", s->width, s->height);\n        g_snprintf(depth, sizeof(depth), \"%d\", s->bpp);\n\n        guid_to_str(&s->guid, guid_str);\n        env_check_password_file(passwd_file, guid_str);\n\n        /* get path of Xvnc from config */\n        xserver = (const char *)list_get_item(g_cfg->vnc_params, 0);\n\n        /* these are the must have parameters */\n        list_add_strdup_multi(params,\n                              xserver, screen,\n                              \"-auth\", authfile,\n                              \"-geometry\", geometry,\n                              \"-depth\", depth,\n                              \"-rfbauth\", passwd_file,\n                              NULL);\n\n        /* additional parameters from sesman.ini file */\n        //config_read_xserver_params(SCP_SESSION_TYPE_XVNC,\n        //                           xserver_params);\n        list_append_list_strdup(g_cfg->vnc_params, params, 1);\n    }\n    return params;\n}\n\n/******************************************************************************/\n/* Either execs the X server, or returns */\nstatic void\nstart_x_server(struct login_info *login_info,\n               const struct session_parameters *s)\n{\n    char authfile[256]; /* The filename for storing xauth information */\n    char execvpparams[2048];\n    char *passwd_file = NULL;\n    struct list *xserver_params = NULL;\n    int unknown_session_type = 0;\n\n    if (s->type == SCP_SESSION_TYPE_XVNC)\n    {\n        env_set_user(login_info->uid,\n                     &passwd_file,\n                     s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n    }\n    else\n    {\n        env_set_user(login_info->uid,\n                     0,\n                     s->display,\n                     g_cfg->env_names,\n                     g_cfg->env_values);\n    }\n\n    /* prepare the Xauthority stuff */\n    if (g_getenv(\"XAUTHORITY\") != NULL)\n    {\n        g_snprintf(authfile, sizeof(authfile), \"%s\",\n                   g_getenv(\"XAUTHORITY\"));\n    }\n    else\n    {\n        g_snprintf(authfile, sizeof(authfile), \"%s\", \".Xauthority\");\n    }\n\n    /* Add the entry in XAUTHORITY file or exit if error */\n    if (add_xauth_cookie(s->display, authfile) != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Error setting the xauth cookie for display %u in file %s\",\n            s->display, authfile);\n    }\n    else\n    {\n        switch (s->type)\n        {\n            case SCP_SESSION_TYPE_XORG:\n                xserver_params = prepare_xorg_xserver_params(s, authfile);\n                break;\n\n            case SCP_SESSION_TYPE_XVNC:\n                xserver_params = prepare_xvnc_xserver_params(s, authfile,\n                                 passwd_file);\n                break;\n\n            default:\n                unknown_session_type = 1;\n        }\n\n        g_free(passwd_file);\n        passwd_file = NULL;\n\n        if (xserver_params == NULL)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Out of memory allocating X server params\");\n        }\n        else if (unknown_session_type)\n        {\n            LOG(LOG_LEVEL_ERROR, \"Unknown session type: %d\",\n                s->type);\n        }\n        else\n        {\n            /* fire up X server */\n            LOG(LOG_LEVEL_INFO, \"Starting X server on display %u: %s\",\n                s->display,\n                dumpItemsToString(xserver_params, execvpparams, 2048));\n            LOG_DEVEL_LEAKING_FDS(\"X server\", 3, -1);\n            g_execvp_list((const char *)xserver_params->items[0],\n                          xserver_params);\n        }\n    }\n\n    /* should not get here */\n    list_delete(xserver_params);\n    LOG(LOG_LEVEL_ERROR, \"A fatal error has occurred attempting \"\n        \"to start the X server on display %u, aborting connection\",\n        s->display);\n}\n\n/******************************************************************************/\n/*\n * Simple helper process to fork a child and log errors */\nstatic int\nfork_child(\n    void (*runproc)(struct login_info *, const struct session_parameters *),\n    struct login_info *login_info,\n    const struct session_parameters *s,\n    pid_t group_pid)\n{\n    int pid = g_fork();\n    if (pid == 0)\n    {\n        /* Child process */\n        if (group_pid >= 0)\n        {\n            (void)g_setpgid(0, group_pid);\n        }\n        runproc(login_info, s);\n        g_exit(0);\n    }\n\n    if (pid < 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Fork failed [%s]\", g_get_strerror());\n    }\n\n    return pid;\n}\n\n/******************************************************************************/\nenum scp_screate_status\nsession_start_wrapped(struct login_info *login_info,\n                      const struct session_parameters *s,\n                      struct session_data *sd)\n{\n    int chansrv_pid;\n    int display_pid;\n    int window_manager_pid;\n    enum scp_screate_status status = E_SCP_SCREATE_GENERAL_ERROR;\n\n    if (auth_start_session(login_info->auth_info, s->display) != 0)\n    {\n        // Errors are logged by the auth module, as they are\n        // specific to that module\n        return E_SCP_SCREATE_GENERAL_ERROR;\n    }\n#ifdef USE_BSD_SETLOGIN\n    /**\n     * Create a new session and process group since the 4.4BSD\n     * setlogin() affects the entire process group\n     */\n    if (g_setsid() < 0)\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"[session start] (display %d): setsid failed - pid %d\",\n            s->display, g_getpid());\n    }\n\n    if (g_setlogin(login_info->username) < 0)\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"[session start] (display %d): setlogin failed for user %s - pid %d\",\n            s->display, login_info->username, g_getpid());\n    }\n#endif\n\n    /* Set the secondary groups before starting the session to prevent\n     * problems on PAM-based systems (see Linux pam_setcred(3)).\n     * If we have *BSD setusercontext() this is not done here */\n#ifndef HAVE_SETUSERCONTEXT\n    if (g_initgroups(login_info->username) != 0)\n    {\n        LOG(LOG_LEVEL_ERROR,\n            \"Failed to initialise secondary groups for %s: %s\",\n            login_info->username, g_get_strerror());\n        return E_SCP_SCREATE_GENERAL_ERROR;\n    }\n#endif\n\n    /* start the X server in a new process group.\n     *\n     * We group the X server, window manager and chansrv in a single\n     * process group, as it allows signals to be sent to the user session\n     * without affecting sesexec (and vice-versa). This is particularly\n     * important when debugging sesexec as we don't want a SIGINT in\n     * the debugger to be passed to the children */\n    display_pid = fork_child(start_x_server, login_info, s, 0);\n    if (display_pid > 0)\n    {\n        enum xwait_status xws;\n        xws = wait_for_xserver(login_info->uid,\n                               g_cfg->env_names,\n                               g_cfg->env_values,\n                               s->display);\n\n        if (xws != XW_STATUS_OK)\n        {\n            switch (xws)\n            {\n                case XW_STATUS_TIMED_OUT:\n                    LOG(LOG_LEVEL_ERROR, \"Timed out waiting for X server\");\n                    break;\n                case XW_STATUS_FAILED_TO_START:\n                    LOG(LOG_LEVEL_ERROR, \"X server failed to start\");\n                    break;\n                default:\n                    LOG(LOG_LEVEL_ERROR,\n                        \"An error occurred waiting for the X server\");\n            }\n            status = E_SCP_SCREATE_X_SERVER_FAIL;\n            /* Kill it anyway in case it did start and we just failed to\n             * pick up on it */\n            g_sigterm(display_pid);\n            g_waitpid(display_pid);\n        }\n        else\n        {\n            LOG(LOG_LEVEL_INFO, \"X server :%d is working\", s->display);\n            LOG(LOG_LEVEL_INFO, \"Starting window manager for display :%d\",\n                s->display);\n\n            window_manager_pid = fork_child(start_window_manager,\n                                            login_info, s, display_pid);\n            if (window_manager_pid < 0)\n            {\n                g_sigterm(display_pid);\n                g_waitpid(display_pid);\n            }\n            else\n            {\n                LOG(LOG_LEVEL_INFO,\n                    \"Starting the xrdp channel server for display :%d\",\n                    s->display);\n\n                chansrv_pid = fork_child(start_chansrv, login_info,\n                                         s, display_pid);\n\n                // Tell the caller we've started\n                LOG(LOG_LEVEL_INFO,\n                    \"Session in progress on display :%d. Waiting until the \"\n                    \"window manager (pid %d) exits to end the session\",\n                    s->display, window_manager_pid);\n\n                sd->win_mgr = window_manager_pid;\n                sd->x_server = display_pid;\n                sd->chansrv = chansrv_pid;\n                sd->start_time = g_time1();\n                status = E_SCP_SCREATE_OK;\n            }\n        }\n    }\n\n    return status;\n}\n\n\n/******************************************************************************/\nenum scp_screate_status\nsession_start(struct login_info *login_info,\n              const struct session_parameters *sp,\n              struct session_data **session_data)\n{\n    enum scp_screate_status status = E_SCP_SCREATE_GENERAL_ERROR;\n    /* Create the session_data struct first */\n    struct session_data *sd = session_data_new(sp);\n    if (sd == NULL)\n    {\n        status = E_SCP_SCREATE_NO_MEMORY;\n    }\n    else\n    {\n        status = session_start_wrapped(login_info, sp, sd);\n        if (status == E_SCP_SCREATE_OK)\n        {\n            *session_data = sd;\n        }\n        else\n        {\n            *session_data = NULL;\n            session_data_free(sd);\n        }\n    }\n\n    return status;\n}\n\n/******************************************************************************/\nstatic int\ncleanup_sockets(int display)\n{\n    LOG(LOG_LEVEL_INFO, \"cleanup_sockets:\");\n    char file[256];\n    int error;\n\n    error = 0;\n\n    g_snprintf(file, 255, CHANSRV_PORT_OUT_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, CHANSRV_PORT_IN_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, XRDP_CHANSRV_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, CHANSRV_API_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    /* the following files should be deleted by xorgxrdp\n     * but just in case the deletion failed */\n\n    g_snprintf(file, 255, XRDP_X11RDP_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    g_snprintf(file, 255, XRDP_DISCONNECT_STR, display);\n    if (g_file_exist(file))\n    {\n        LOG(LOG_LEVEL_DEBUG, \"cleanup_sockets: deleting %s\", file);\n        if (g_file_delete(file) == 0)\n        {\n            LOG(LOG_LEVEL_WARNING,\n                \"cleanup_sockets: failed to delete %s (%s)\",\n                file, g_get_strerror());\n            error++;\n        }\n    }\n\n    return error;\n}\n\n/******************************************************************************/\nstatic void\nexit_status_to_str(const struct exit_status *e, char buff[], int bufflen)\n{\n    switch (e->reason)\n    {\n        case E_XR_STATUS_CODE:\n            if (e->val == 0)\n            {\n                g_snprintf(buff, bufflen, \"exit code zero\");\n            }\n            else\n            {\n                g_snprintf(buff, bufflen, \"non-zero exit code %d\", e->val);\n            }\n            break;\n\n        case E_XR_SIGNAL:\n        {\n            char sigstr[MAXSTRSIGLEN];\n            g_snprintf(buff, bufflen, \"signal %s\",\n                       g_sig2text(e->val, sigstr));\n        }\n        break;\n\n        default:\n            g_snprintf(buff, bufflen, \"an unexpected error\");\n            break;\n    }\n}\n\n/******************************************************************************/\nvoid\nsession_process_child_exit(struct session_data *sd,\n                           int pid,\n                           const struct exit_status *e)\n{\n    if (pid == sd->x_server)\n    {\n        LOG(LOG_LEVEL_INFO, \"X server pid %d on display :%d finished\",\n            sd->x_server, sd->params.display);\n        sd->x_server = -1;\n        // No other action - window manager should be going soon\n    }\n    else if (pid == sd->chansrv)\n    {\n        LOG(LOG_LEVEL_INFO,\n            \"xrdp channel server pid %d on display :%d finished\",\n            sd->chansrv, sd->params.display);\n        sd->chansrv = -1;\n    }\n    else if (pid == sd->win_mgr)\n    {\n        int wm_wait_time = g_time1() - sd->start_time;\n\n        if (e->reason == E_XR_STATUS_CODE && e->val == 0)\n        {\n            LOG(LOG_LEVEL_INFO,\n                \"Window manager (pid %d, display %d) \"\n                \"finished normally in %d secs\",\n                sd->win_mgr, sd->params.display, wm_wait_time);\n        }\n        else\n        {\n            char reason[128];\n            exit_status_to_str(e, reason, sizeof(reason));\n\n            LOG(LOG_LEVEL_WARNING, \"Window manager (pid %d, display %d) \"\n                \"exited with %s. This \"\n                \"could indicate a window manager config problem\",\n                sd->win_mgr, sd->params.display, reason);\n        }\n        if (wm_wait_time < 10)\n        {\n            /* This could be a config issue. Log a significant error */\n            LOG(LOG_LEVEL_WARNING, \"Window manager (pid %d, display %d) \"\n                \"exited quickly (%d secs). This could indicate a window \"\n                \"manager config problem\",\n                sd->win_mgr, sd->params.display, wm_wait_time);\n        }\n\n        sd->win_mgr = -1;\n\n        if (sd->x_server > 0)\n        {\n            LOG(LOG_LEVEL_INFO, \"Terminating X server (pid %d) on display :%d\",\n                sd->x_server, sd->params.display);\n            g_sigterm(sd->x_server);\n        }\n\n        if (sd->chansrv > 0)\n        {\n            LOG(LOG_LEVEL_INFO, \"Terminating the xrdp channel server (pid %d) \"\n                \"on display :%d\", sd->chansrv, sd->params.display);\n            g_sigterm(sd->chansrv);\n        }\n    }\n\n    if (!session_active(sd))\n    {\n        cleanup_sockets(sd->params.display);\n    }\n}\n\n/******************************************************************************/\nunsigned int\nsession_active(const struct session_data *sd)\n{\n    return\n        (sd == NULL)\n        ? 0\n        : (sd->win_mgr > 0) + (sd->x_server > 0) + (sd->chansrv > 0);\n}\n\n/******************************************************************************/\ntime_t\nsession_get_start_time(const struct session_data *sd)\n{\n    return (sd == NULL) ? 0 : sd->start_time;\n}\n\n/******************************************************************************/\nvoid\nsession_send_term(struct session_data *sd)\n{\n    if (sd != NULL && sd->win_mgr > 0)\n    {\n        g_sigterm(sd->win_mgr);\n    }\n}\n\n/******************************************************************************/\nstatic void\nstart_reconnect_script(struct login_info *login_info,\n                       const struct session_parameters *s)\n{\n    env_set_user(login_info->uid, 0, s->display,\n                 g_cfg->env_names,\n                 g_cfg->env_values);\n\n    auth_set_env(login_info->auth_info);\n\n    if (g_file_exist(g_cfg->reconnect_sh))\n    {\n        LOG_DEVEL_LEAKING_FDS(\"reconnect script\", 3, -1);\n\n        LOG(LOG_LEVEL_INFO,\n            \"Starting session reconnection script on display %d: %s\",\n            s->display, g_cfg->reconnect_sh);\n        g_execlp3(g_cfg->reconnect_sh, g_cfg->reconnect_sh, 0);\n\n        /* should not get here */\n        LOG(LOG_LEVEL_ERROR,\n            \"Error starting session reconnection script on display %d: %s\",\n            s->display, g_cfg->reconnect_sh);\n    }\n    else\n    {\n        LOG(LOG_LEVEL_WARNING,\n            \"Session reconnection script file does not exist: %s\",\n            g_cfg->reconnect_sh);\n    }\n}\n\n/******************************************************************************/\nvoid\nsession_reconnect(struct login_info *login_info,\n                  struct session_data *sd)\n{\n    if (fork_child(start_reconnect_script,\n                   login_info, &sd->params, sd->x_server) < 0)\n    {\n        LOG(LOG_LEVEL_ERROR, \"Failed to fork for session reconnection script\");\n    }\n}\n"], "filenames": ["sesman/libsesman/verify_user_pam.c", "sesman/libsesman/verify_user_pam_userpass.c", "sesman/sesexec/session.c"], "buggy_code_start_loc": [400, 210, 571], "buggy_code_end_loc": [436, 246, 572], "fixing_code_start_loc": [400, 210, 571], "fixing_code_end_loc": [457, 267, 577], "type": "CWE-755", "message": " xrdp is an open source remote desktop protocol (RDP) server. In versions prior to 0.9.23 improper handling of session establishment errors allows bypassing OS-level session restrictions. The `auth_start_session` function can return non-zero (1) value on, e.g., PAM error which may result in in session restrictions such as max concurrent sessions per user by PAM (ex ./etc/security/limits.conf) to be bypassed. Users (administrators) don't use restrictions by PAM are not affected. This issue has been addressed in release version 0.9.23. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2023-40184", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-30T18:15:09.690", "lastModified": "2023-09-15T22:15:14.457", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": " xrdp is an open source remote desktop protocol (RDP) server. In versions prior to 0.9.23 improper handling of session establishment errors allows bypassing OS-level session restrictions. The `auth_start_session` function can return non-zero (1) value on, e.g., PAM error which may result in in session restrictions such as max concurrent sessions per user by PAM (ex ./etc/security/limits.conf) to be bypassed. Users (administrators) don't use restrictions by PAM are not affected. This issue has been addressed in release version 0.9.23. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "xrdp es un servidor de protocolo de escritorio remoto (RDP) de c\u00f3digo abierto. En versiones anteriores a la 0.9.23, el manejo inadecuado de los errores de establecimiento de sesi\u00f3n permite eludir las restricciones de sesi\u00f3n a nivel del sistema operativo. La funci\u00f3n `auth_start_session` puede devolver un valor distinto de cero (1), por ejemplo, en un error de PAM, lo que puede dar lugar a restricciones de sesi\u00f3n, como el n\u00famero m\u00e1ximo de sesiones simult\u00e1neas por usuario por parte de PAM (por ejemplo, ./etc/security/limits.conf) para ser omitido. Los usuarios (administradores) que no utilizan restricciones por PAM no se ven afectados. Este problema se solucion\u00f3 en la versi\u00f3n 0.9.23. Se recomienda a los usuarios que actualicen. No se conocen workarounds para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.6, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:neutrinolabs:xrdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.23", "matchCriteriaId": "F5F0C8DA-06A5-477C-A303-6715A9D01C6E"}]}]}], "references": [{"url": "https://github.com/neutrinolabs/xrdp/blame/9bbb2ec68f390504c32f2062847aa3d821a0089a/sesman/sesexec/session.c#L571C5-L571C19", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/neutrinolabs/xrdp/commit/a111a0fdfe2421ef600e40708b5f0168594cfb23", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/neutrinolabs/xrdp/security/advisories/GHSA-f489-557v-47jq", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SOT237TIHTHPX5YNIWLVNINOEYC7WMG2/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U5IXMQODV3OIJ7DRQBUQV7PUKNT7SH36/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/URO3FKTFBPNKFARAQBEJLI4MH6YS35P5/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/neutrinolabs/xrdp/commit/a111a0fdfe2421ef600e40708b5f0168594cfb23"}}