{"buggy_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#ifndef HERMES_VM_INTERPRETER_H\n#define HERMES_VM_INTERPRETER_H\n#include <cstdint>\n\n#include \"hermes/VM/Runtime.h\"\n\nclass CodeBlock;\n\nnamespace hermes {\nnamespace vm {\n/// This class is a convenience wrapper for the interpreter implementation that\n/// needs access to the private fields of Runtime, but doesn't belong in\n/// Runtime.\nclass Interpreter {\n public:\n  /// Allocate a GeneratorFuncxtion for the specified function and the specified\n  /// environment. \\param funcIndex function index in the global function table.\n  static CallResult<PseudoHandle<JSGeneratorFunction>> createGeneratorClosure(\n      Runtime *runtime,\n      RuntimeModule *runtimeModule,\n      unsigned funcIndex,\n      Handle<Environment> envHandle);\n\n  /// Allocate a generator for the specified function and the specified\n  /// environment. \\param funcIndex function index in the global function table.\n  static CallResult<PseudoHandle<JSGenerator>> createGenerator_RJS(\n      Runtime *runtime,\n      RuntimeModule *runtimeModule,\n      unsigned funcIndex,\n      Handle<Environment> envHandle,\n      NativeArgs args);\n\n  /// Slow path for ReifyArguments resReg, lazyReg\n  /// It assumes that he fast path has handled the case when 'lazyReg' is\n  /// already initialized. It creates a new 'arguments' object and populates it\n  /// with the argument values.\n  static CallResult<Handle<Arguments>> reifyArgumentsSlowPath(\n      Runtime *runtime,\n      Handle<Callable> curFunction,\n      bool strictMode);\n\n  /// Slow path for GetArgumentsPropByVal resReg, propNameReg, lazyReg.\n  ///\n  /// It assumes that the \"fast path\" has already taken care of the case when\n  /// the 'lazyReg' is still uninitialized and 'propNameReg' is a valid integer\n  /// index less than 'argCount'. So we arrive here when either of these is\n  /// true:\n  /// - 'lazyReg' is initialized.\n  /// - index is >= argCount\n  /// - index is not an integer\n  /// In the first case we simply perform a normal property get. In the latter\n  /// we ultimately need to reify the arguments object, but we try to avoid\n  /// doing that by:\n  /// - checking if the property name is \"length\". In that case we can just\n  ///   return the value.\n  /// - checking if the property name in the prototype is not an accessor. In\n  /// that\n  ///   case we can also just return the value read from the prototype.\n  /// Only if all else fails, we reify.\n  /// The FRAME in question is obtained from \\p runtime, and the registers\n  /// \\p lazyReg and \\p valueReg are passed directly to make this function\n  /// easier to use outside the interpeter.\n  static CallResult<PseudoHandle<>> getArgumentsPropByValSlowPath_RJS(\n      Runtime *runtime,\n      PinnedHermesValue *lazyReg,\n      PinnedHermesValue *valueReg,\n      Handle<Callable> curFunction,\n      bool strictMode);\n\n  static ExecutionStatus handleGetPNameList(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const Inst *ip);\n\n  /// Implement the slow path of OpCode::Call/CallLong/Construct/ConstructLong.\n  /// The callee frame must have been initialized already and the fast path\n  /// (calling a \\c JSFunction) must have been handled.\n  /// This handles the rest of the cases (native function, bound funcation, and\n  /// not even a function).\n  /// \\param callTarget the register containing the function object\n  /// \\return ExecutionStatus::EXCEPTION if the call threw.\n  static CallResult<PseudoHandle<>> handleCallSlowPath(\n      Runtime *runtime,\n      PinnedHermesValue *callTarget);\n\n  /// Fast path to get primitive value \\p base's own properties by name \\p id\n  /// without boxing.\n  /// Primitive own properties are properties fetching values from primitive\n  /// value itself.\n  /// Currently the only primitive own property is String.prototype.length.\n  /// If the fast path property does not exist, return Empty.\n  static PseudoHandle<>\n  tryGetPrimitiveOwnPropertyById(Runtime *runtime, Handle<> base, SymbolID id);\n\n  /// Implement OpCode::GetById/TryGetById when the base is not an object.\n  static CallResult<PseudoHandle<>>\n  getByIdTransient_RJS(Runtime *runtime, Handle<> base, SymbolID id);\n\n  /// Fast path for getByValTransient() -- avoid boxing for \\p base if it is\n  /// string primitive and \\p nameHandle is an array index.\n  /// If the property does not exist, return Empty.\n  static PseudoHandle<>\n  getByValTransientFast(Runtime *runtime, Handle<> base, Handle<> nameHandle);\n\n  /// Implement OpCode::GetByVal when the base is not an object.\n  static CallResult<PseudoHandle<>>\n  getByValTransient_RJS(Runtime *runtime, Handle<> base, Handle<> name);\n\n  /// Implement OpCode::PutById/TryPutById when the base is not an object.\n  static ExecutionStatus putByIdTransient_RJS(\n      Runtime *runtime,\n      Handle<> base,\n      SymbolID id,\n      Handle<> value,\n      bool strictMode);\n\n  /// Implement OpCode::PutByVal when the base is not an object.\n  static ExecutionStatus putByValTransient_RJS(\n      Runtime *runtime,\n      Handle<> base,\n      Handle<> name,\n      Handle<> value,\n      bool strictMode);\n\n  template <bool SingleStep>\n  static CallResult<HermesValue> interpretFunction(\n      Runtime *runtime,\n      InterpreterState &state);\n\n  /// Populates an object with literal values from the object buffer.\n  /// \\param numLiterals the amount of literals to read from the buffer.\n  /// \\param keyBufferIndex the first element of the key buffer to read.\n  /// \\param valBufferIndex the first element of the val buffer to read.\n  /// \\return ExecutionStatus::EXCEPTION if the property definitions throw.\n  static CallResult<PseudoHandle<>> createObjectFromBuffer(\n      Runtime *runtime,\n      CodeBlock *curCodeBlock,\n      unsigned numLiterals,\n      unsigned keyBufferIndex,\n      unsigned valBufferIndex);\n\n  /// Populates an array with literal values from the array buffer.\n  /// \\param numLiterals the amount of literals to read from the buffer.\n  /// \\param bufferIndex the first element of the buffer to read.\n  /// \\return ExecutionStatus::EXCEPTION if the property definitions throw.\n  static CallResult<PseudoHandle<>> createArrayFromBuffer(\n      Runtime *runtime,\n      CodeBlock *curCodeBlock,\n      unsigned numElements,\n      unsigned numLiterals,\n      unsigned bufferIndex);\n\n#ifdef HERMES_ENABLE_DEBUGGER\n  /// Wrapper around runDebugger() that reapplies the interpreter state.\n  /// Constructs an interpreter state from the given \\p codeBlock and \\p ip.\n  /// It then invokes the debugger and returns the new code block, and offset by\n  /// reference, and updates frameRegs to its new value. Note this function is\n  /// inline to allow the compiler to verify that the parameters do not escape,\n  /// which might otherwise prevent them from being promoted to registers.\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static inline ExecutionStatus runDebuggerUpdatingState(\n      Debugger::RunReason reason,\n      Runtime *runtime,\n      CodeBlock *&codeBlock,\n      const Inst *&ip,\n      PinnedHermesValue *&frameRegs) {\n    // Hack: if we are already debugging, do nothing. TODO: in the event that we\n    // are already debugging and we get an async debugger request, abort the\n    // current debugging command (e.g. eval something infinite).\n    if (runtime->debugger_.isDebugging())\n      return ExecutionStatus::RETURNED;\n    uint32_t offset = codeBlock->getOffsetOf(ip);\n    InterpreterState state(codeBlock, offset);\n    ExecutionStatus status = runtime->debugger_.runDebugger(reason, state);\n    codeBlock = state.codeBlock;\n    ip = state.codeBlock->getOffsetPtr(state.offset);\n    frameRegs = &runtime->currentFrame_.getFirstLocalRef();\n    return status;\n  }\n#endif\n\n  //===========================================================================\n  // Out-of-line implementations of entire instructions.\n\n  /// Partial implementation of ES6 18.2.1.1\n  /// `PerformEval(x, evalRealm, strictCaller=true, direct=true)`.\n  /// The difference is that we don't support actual lexical scope, of course.\n  static ExecutionStatus caseDirectEval(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus casePutOwnByVal(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus casePutOwnGetterSetterByVal(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus caseIteratorBegin(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n  static ExecutionStatus caseIteratorNext(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n};\n\n} // namespace vm\n} // namespace hermes\n\n#endif\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#define DEBUG_TYPE \"vm\"\n#include \"JSLib/JSLibInternal.h\"\n#include \"hermes/VM/Casting.h\"\n#include \"hermes/VM/Interpreter.h\"\n#include \"hermes/VM/StringPrimitive.h\"\n\n#include \"Interpreter-internal.h\"\n\nusing namespace hermes::inst;\n\nnamespace hermes {\nnamespace vm {\n\nExecutionStatus Interpreter::caseDirectEval(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  auto *result = &O1REG(DirectEval);\n  auto *input = &O2REG(DirectEval);\n\n  GCScopeMarkerRAII gcMarker{runtime};\n\n  // Check to see if global eval() has been overriden, in which case call it as\n  // as normal function.\n  auto global = runtime->getGlobal();\n  auto existingEval = global->getNamed_RJS(\n      global, runtime, Predefined::getSymbolID(Predefined::eval));\n  if (LLVM_UNLIKELY(existingEval == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto *nativeExistingEval = dyn_vmcast<NativeFunction>(existingEval->get());\n  if (LLVM_UNLIKELY(\n          !nativeExistingEval ||\n          nativeExistingEval->getFunctionPtr() != hermes::vm::eval)) {\n    if (auto *existingEvalCallable =\n            dyn_vmcast<Callable>(existingEval->get())) {\n      auto evalRes = existingEvalCallable->executeCall1(\n          runtime->makeHandle<Callable>(existingEvalCallable),\n          runtime,\n          Runtime::getUndefinedValue(),\n          *input);\n      if (LLVM_UNLIKELY(evalRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      *result = evalRes->get();\n      evalRes->invalidate();\n      return ExecutionStatus::RETURNED;\n    }\n    return runtime->raiseTypeErrorForValue(\n        runtime->makeHandle(std::move(*existingEval)), \" is not a function\");\n  }\n\n  if (!input->isString()) {\n    *result = *input;\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Create a dummy scope, so that the local eval executes in its own scope\n  // (as per the spec for strict callers, which is the only thing we support).\n\n  ScopeChain scopeChain{};\n  scopeChain.functions.emplace_back();\n\n  auto cr = vm::directEval(\n      runtime, Handle<StringPrimitive>::vmcast(input), scopeChain, false);\n  if (cr == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n\n  *result = *cr;\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::casePutOwnByVal(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  return JSObject::defineOwnComputed(\n             Handle<JSObject>::vmcast(&O1REG(PutOwnByVal)),\n             runtime,\n             Handle<>(&O3REG(PutOwnByVal)),\n             ip->iPutOwnByVal.op4\n                 ? DefinePropertyFlags::getDefaultNewPropertyFlags()\n                 : DefinePropertyFlags::getNewNonEnumerableFlags(),\n             Handle<>(&O2REG(PutOwnByVal)))\n      .getStatus();\n}\n\nExecutionStatus Interpreter::casePutOwnGetterSetterByVal(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  DefinePropertyFlags dpFlags{};\n  dpFlags.setConfigurable = 1;\n  dpFlags.configurable = 1;\n  dpFlags.setEnumerable = 1;\n  dpFlags.enumerable = ip->iPutOwnGetterSetterByVal.op5;\n\n  MutableHandle<Callable> getter(runtime);\n  MutableHandle<Callable> setter(runtime);\n  if (LLVM_LIKELY(!O3REG(PutOwnGetterSetterByVal).isUndefined())) {\n    dpFlags.setGetter = 1;\n    getter = vmcast<Callable>(O3REG(PutOwnGetterSetterByVal));\n  }\n  if (LLVM_LIKELY(!O4REG(PutOwnGetterSetterByVal).isUndefined())) {\n    dpFlags.setSetter = 1;\n    setter = vmcast<Callable>(O4REG(PutOwnGetterSetterByVal));\n  }\n  assert(\n      (dpFlags.setSetter || dpFlags.setGetter) &&\n      \"No accessor set in PutOwnGetterSetterByVal\");\n\n  auto res = PropertyAccessor::create(runtime, getter, setter);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n\n  auto accessor = runtime->makeHandle<PropertyAccessor>(*res);\n\n  return JSObject::defineOwnComputed(\n             Handle<JSObject>::vmcast(&O1REG(PutOwnGetterSetterByVal)),\n             runtime,\n             Handle<>(&O2REG(PutOwnGetterSetterByVal)),\n             dpFlags,\n             accessor)\n      .getStatus();\n}\n\nExecutionStatus Interpreter::caseIteratorBegin(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  if (LLVM_LIKELY(vmisa<JSArray>(O2REG(IteratorBegin)))) {\n    // Attempt to get the fast path for array iteration.\n    NamedPropertyDescriptor desc;\n    JSObject *propObj = JSObject::getNamedDescriptor(\n        Handle<JSArray>::vmcast(&O2REG(IteratorBegin)),\n        runtime,\n        Predefined::getSymbolID(Predefined::SymbolIterator),\n        desc);\n    if (propObj) {\n      HermesValue slotValue =\n          JSObject::getNamedSlotValue(propObj, runtime, desc);\n      if (slotValue.getRaw() == runtime->arrayPrototypeValues.getRaw()) {\n        O1REG(IteratorBegin) = HermesValue::encodeNumberValue(0);\n        return ExecutionStatus::RETURNED;\n      }\n    }\n  }\n  GCScopeMarkerRAII marker{runtime};\n  CallResult<IteratorRecord> iterRecord =\n      getIterator(runtime, Handle<>(&O2REG(IteratorBegin)));\n  if (LLVM_UNLIKELY(iterRecord == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  O1REG(IteratorBegin) = iterRecord->iterator.getHermesValue();\n  O2REG(IteratorBegin) = iterRecord->nextMethod.getHermesValue();\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::caseIteratorNext(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  if (LLVM_LIKELY(O2REG(IteratorNext).isNumber())) {\n    JSArray::size_type i =\n        O2REG(IteratorNext).getNumberAs<JSArray::size_type>();\n    if (i >= JSArray::getLength(vmcast<JSArray>(O3REG(IteratorNext)))) {\n      // Finished iterating the array, stop.\n      O2REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n      O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n      return ExecutionStatus::RETURNED;\n    }\n    Handle<JSArray> arr = Handle<JSArray>::vmcast(&O3REG(IteratorNext));\n    {\n      // Fast path: look up the property in indexed storage.\n      // Runs when there is no hole and a regular non-accessor property exists\n      // at the current index, because those are the only properties stored\n      // in indexed storage.\n      // If there is another kind of property we have to call getComputed_RJS.\n      // No need to check the fastIndexProperties flag because the indexed\n      // storage would be deleted and at() would return empty in that case.\n      NoAllocScope noAlloc{runtime};\n      HermesValue value = arr->at(runtime, i);\n      if (LLVM_LIKELY(!value.isEmpty())) {\n        O1REG(IteratorNext) = value;\n        O2REG(IteratorNext) = HermesValue::encodeNumberValue(i + 1);\n        return ExecutionStatus::RETURNED;\n      }\n    }\n    // Slow path, just run the full getComputedPropertyValue_RJS path.\n    GCScopeMarkerRAII marker{runtime};\n    Handle<> idxHandle{&O2REG(IteratorNext)};\n    CallResult<PseudoHandle<>> valueRes =\n        JSObject::getComputed_RJS(arr, runtime, idxHandle);\n    if (LLVM_UNLIKELY(valueRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    O1REG(IteratorNext) = valueRes->get();\n    O2REG(IteratorNext) = HermesValue::encodeNumberValue(i + 1);\n    return ExecutionStatus::RETURNED;\n  }\n  if (LLVM_UNLIKELY(O2REG(IteratorNext).isUndefined())) {\n    // In all current use cases of IteratorNext, we check and branch away\n    // from IteratorNext in the case that iterStorage was set to undefined\n    // (which indicates completion of iteration).\n    // If we introduce a use case which allows calling IteratorNext,\n    // then this assert can be removed. For now, this branch just returned\n    // undefined in NDEBUG mode.\n    assert(false && \"IteratorNext called on completed iterator\");\n    O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n    return ExecutionStatus::RETURNED;\n  }\n\n  GCScopeMarkerRAII marker{runtime};\n\n  IteratorRecord iterRecord{Handle<JSObject>::vmcast(&O2REG(IteratorNext)),\n                            Handle<Callable>::vmcast(&O3REG(IteratorNext))};\n\n  CallResult<PseudoHandle<JSObject>> resultObjRes =\n      iteratorNext(runtime, iterRecord, llvh::None);\n  if (LLVM_UNLIKELY(resultObjRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<JSObject> resultObj = runtime->makeHandle(std::move(*resultObjRes));\n  CallResult<PseudoHandle<>> doneRes = JSObject::getNamed_RJS(\n      resultObj, runtime, Predefined::getSymbolID(Predefined::done));\n  if (LLVM_UNLIKELY(doneRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (toBoolean(doneRes->get())) {\n    // Done with iteration. Clear the iterator so that subsequent\n    // instructions do not call next() or return().\n    O2REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n    O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n  } else {\n    // Not done iterating, so get the `value` property and store it\n    // as the result.\n    CallResult<PseudoHandle<>> propRes = JSObject::getNamed_RJS(\n        resultObj, runtime, Predefined::getSymbolID(Predefined::value));\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    O1REG(IteratorNext) = propRes->get();\n    propRes->invalidate();\n  }\n  return ExecutionStatus::RETURNED;\n}\n\n} // namespace vm\n} // namespace hermes\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#define DEBUG_TYPE \"vm\"\n#include \"hermes/VM/Interpreter.h\"\n#include \"hermes/VM/Runtime.h\"\n\n#include \"hermes/Inst/InstDecode.h\"\n#include \"hermes/Support/Conversions.h\"\n#include \"hermes/Support/SlowAssert.h\"\n#include \"hermes/Support/Statistic.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/CodeBlock.h\"\n#include \"hermes/VM/HandleRootOwner-inline.h\"\n#include \"hermes/VM/JIT/JIT.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSError.h\"\n#include \"hermes/VM/JSGenerator.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/JSRegExp.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/Profiler.h\"\n#include \"hermes/VM/Profiler/CodeCoverageProfiler.h\"\n#include \"hermes/VM/Runtime-inline.h\"\n#include \"hermes/VM/RuntimeModule-inline.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringPrimitive.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n#include \"llvh/Support/Debug.h\"\n#include \"llvh/Support/Format.h\"\n#include \"llvh/Support/raw_ostream.h\"\n\n#include \"Interpreter-internal.h\"\n\nusing llvh::dbgs;\nusing namespace hermes::inst;\n\nHERMES_SLOW_STATISTIC(\n    NumGetById,\n    \"NumGetById: Number of property 'read by id' accesses\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdCacheHits,\n    \"NumGetByIdCacheHits: Number of property 'read by id' cache hits\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdProtoHits,\n    \"NumGetByIdProtoHits: Number of property 'read by id' cache hits for the prototype\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdCacheEvicts,\n    \"NumGetByIdCacheEvicts: Number of property 'read by id' cache evictions\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdFastPaths,\n    \"NumGetByIdFastPaths: Number of property 'read by id' fast paths\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdAccessor,\n    \"NumGetByIdAccessor: Number of property 'read by id' accessors\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdProto,\n    \"NumGetByIdProto: Number of property 'read by id' in the prototype chain\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdNotFound,\n    \"NumGetByIdNotFound: Number of property 'read by id' not found\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdTransient,\n    \"NumGetByIdTransient: Number of property 'read by id' of non-objects\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdDict,\n    \"NumGetByIdDict: Number of property 'read by id' of dictionaries\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdSlow,\n    \"NumGetByIdSlow: Number of property 'read by id' slow path\");\n\nHERMES_SLOW_STATISTIC(\n    NumPutById,\n    \"NumPutById: Number of property 'write by id' accesses\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdCacheHits,\n    \"NumPutByIdCacheHits: Number of property 'write by id' cache hits\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdCacheEvicts,\n    \"NumPutByIdCacheEvicts: Number of property 'write by id' cache evictions\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdFastPaths,\n    \"NumPutByIdFastPaths: Number of property 'write by id' fast paths\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdTransient,\n    \"NumPutByIdTransient: Number of property 'write by id' to non-objects\");\n\nHERMES_SLOW_STATISTIC(\n    NumNativeFunctionCalls,\n    \"NumNativeFunctionCalls: Number of native function calls\");\nHERMES_SLOW_STATISTIC(\n    NumBoundFunctionCalls,\n    \"NumBoundCalls: Number of bound function calls\");\n\n// Ensure that instructions declared as having matching layouts actually do.\n#include \"InstLayout.inc\"\n\n#if defined(HERMESVM_PROFILER_EXTERN)\n// External profiler mode wraps calls to each JS function with a unique native\n// function that recusively calls the interpreter. See Profiler.{h,cpp} for how\n// these symbols are subsequently patched with JS function names.\n#define INTERP_WRAPPER(name)                                                \\\n  __attribute__((__noinline__)) static llvh::CallResult<llvh::HermesValue>  \\\n  name(hermes::vm::Runtime *runtime, hermes::vm::CodeBlock *newCodeBlock) { \\\n    return runtime->interpretFunctionImpl(newCodeBlock);                    \\\n  }\nPROFILER_SYMBOLS(INTERP_WRAPPER)\n#endif\n\nnamespace hermes {\nnamespace vm {\n\n#if defined(HERMESVM_PROFILER_EXTERN)\ntypedef CallResult<HermesValue> (*WrapperFunc)(Runtime *, CodeBlock *);\n#define LIST_ITEM(name) name,\nstatic const WrapperFunc interpWrappers[] = {PROFILER_SYMBOLS(LIST_ITEM)};\n#endif\n\n/// Initialize the state of some internal variables based on the current\n/// code block.\n#define INIT_STATE_FOR_CODEBLOCK(codeBlock)                 \\\n  do {                                                      \\\n    strictMode = (codeBlock)->isStrictMode();               \\\n    defaultPropOpFlags = DEFAULT_PROP_OP_FLAGS(strictMode); \\\n  } while (0)\n\nCallResult<PseudoHandle<JSGeneratorFunction>>\nInterpreter::createGeneratorClosure(\n    Runtime *runtime,\n    RuntimeModule *runtimeModule,\n    unsigned funcIndex,\n    Handle<Environment> envHandle) {\n  return JSGeneratorFunction::create(\n      runtime,\n      runtimeModule->getDomain(runtime),\n      Handle<JSObject>::vmcast(&runtime->generatorFunctionPrototype),\n      envHandle,\n      runtimeModule->getCodeBlockMayAllocate(funcIndex));\n}\n\nCallResult<PseudoHandle<JSGenerator>> Interpreter::createGenerator_RJS(\n    Runtime *runtime,\n    RuntimeModule *runtimeModule,\n    unsigned funcIndex,\n    Handle<Environment> envHandle,\n    NativeArgs args) {\n  auto gifRes = GeneratorInnerFunction::create(\n      runtime,\n      runtimeModule->getDomain(runtime),\n      Handle<JSObject>::vmcast(&runtime->functionPrototype),\n      envHandle,\n      runtimeModule->getCodeBlockMayAllocate(funcIndex),\n      args);\n  if (LLVM_UNLIKELY(gifRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto generatorFunction = runtime->makeHandle(vmcast<JSGeneratorFunction>(\n      runtime->getCurrentFrame().getCalleeClosure()));\n\n  auto prototypeProp = JSObject::getNamed_RJS(\n      generatorFunction,\n      runtime,\n      Predefined::getSymbolID(Predefined::prototype));\n  if (LLVM_UNLIKELY(prototypeProp == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<JSObject> prototype = vmisa<JSObject>(prototypeProp->get())\n      ? runtime->makeHandle<JSObject>(prototypeProp->get())\n      : Handle<JSObject>::vmcast(&runtime->generatorPrototype);\n\n  return JSGenerator::create(runtime, *gifRes, prototype);\n}\n\nCallResult<Handle<Arguments>> Interpreter::reifyArgumentsSlowPath(\n    Runtime *runtime,\n    Handle<Callable> curFunction,\n    bool strictMode) {\n  auto frame = runtime->getCurrentFrame();\n  uint32_t argCount = frame.getArgCount();\n  // Define each JavaScript argument.\n  auto argRes = Arguments::create(runtime, argCount, curFunction, strictMode);\n  if (LLVM_UNLIKELY(argRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<Arguments> args = *argRes;\n\n  for (uint32_t argIndex = 0; argIndex < argCount; ++argIndex) {\n    Arguments::unsafeSetExistingElementAt(\n        *args, runtime, argIndex, frame.getArgRef(argIndex));\n  }\n\n  // The returned value should already be set from the create call.\n  return args;\n}\n\nCallResult<PseudoHandle<>> Interpreter::getArgumentsPropByValSlowPath_RJS(\n    Runtime *runtime,\n    PinnedHermesValue *lazyReg,\n    PinnedHermesValue *valueReg,\n    Handle<Callable> curFunction,\n    bool strictMode) {\n  auto frame = runtime->getCurrentFrame();\n\n  // If the arguments object has already been created.\n  if (!lazyReg->isUndefined()) {\n    // The arguments object has been created, so this is a regular property\n    // get.\n    assert(lazyReg->isObject() && \"arguments lazy register is not an object\");\n\n    return JSObject::getComputed_RJS(\n        Handle<JSObject>::vmcast(lazyReg), runtime, Handle<>(valueReg));\n  }\n\n  if (!valueReg->isSymbol()) {\n    // Attempt a fast path in the case that the key is not a symbol.\n    // If it is a symbol, force reification for now.\n    // Convert the value to a string.\n    auto strRes = toString_RJS(runtime, Handle<>(valueReg));\n    if (strRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    auto strPrim = runtime->makeHandle(std::move(*strRes));\n\n    // Check if the string is a valid argument index.\n    if (auto index = toArrayIndex(runtime, strPrim)) {\n      if (*index < frame.getArgCount()) {\n        return createPseudoHandle(frame.getArgRef(*index));\n      }\n\n      auto objectPrototype =\n          Handle<JSObject>::vmcast(&runtime->objectPrototype);\n\n      // OK, they are requesting an index that either doesn't exist or is\n      // somewhere up in the prototype chain. Since we want to avoid reifying,\n      // check which it is:\n      MutableHandle<JSObject> inObject{runtime};\n      ComputedPropertyDescriptor desc;\n      JSObject::getComputedPrimitiveDescriptor(\n          objectPrototype, runtime, strPrim, inObject, desc);\n\n      // If we couldn't find the property, just return 'undefined'.\n      if (!inObject)\n        return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n      // If the property isn't an accessor, we can just return it without\n      // reifying.\n      if (!desc.flags.accessor) {\n        return createPseudoHandle(\n            JSObject::getComputedSlotValue(inObject.get(), runtime, desc));\n      }\n    }\n\n    // Are they requesting \"arguments.length\"?\n    if (runtime->symbolEqualsToStringPrim(\n            Predefined::getSymbolID(Predefined::length), *strPrim)) {\n      return createPseudoHandle(\n          HermesValue::encodeDoubleValue(frame.getArgCount()));\n    }\n  }\n\n  // Looking for an accessor or a property that needs reification.\n  auto argRes = reifyArgumentsSlowPath(runtime, curFunction, strictMode);\n  if (argRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // Update the register with the reified value.\n  *lazyReg = argRes->getHermesValue();\n\n  // For simplicity, call ourselves again.\n  return getArgumentsPropByValSlowPath_RJS(\n      runtime, lazyReg, valueReg, curFunction, strictMode);\n}\n\nExecutionStatus Interpreter::handleGetPNameList(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  if (O2REG(GetPNameList).isUndefined() || O2REG(GetPNameList).isNull()) {\n    // Set the iterator to be undefined value.\n    O1REG(GetPNameList) = HermesValue::encodeUndefinedValue();\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Convert to object and store it back to the register.\n  auto res = toObject(runtime, Handle<>(&O2REG(GetPNameList)));\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  O2REG(GetPNameList) = res.getValue();\n\n  auto obj = runtime->makeMutableHandle(vmcast<JSObject>(res.getValue()));\n  uint32_t beginIndex;\n  uint32_t endIndex;\n  auto cr = getForInPropertyNames(runtime, obj, beginIndex, endIndex);\n  if (cr == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto arr = *cr;\n  O1REG(GetPNameList) = arr.getHermesValue();\n  O3REG(GetPNameList) = HermesValue::encodeNumberValue(beginIndex);\n  O4REG(GetPNameList) = HermesValue::encodeNumberValue(endIndex);\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<PseudoHandle<>> Interpreter::handleCallSlowPath(\n    Runtime *runtime,\n    PinnedHermesValue *callTarget) {\n  if (auto *native = dyn_vmcast<NativeFunction>(*callTarget)) {\n    ++NumNativeFunctionCalls;\n    // Call the native function directly\n    return NativeFunction::_nativeCall(native, runtime);\n  } else if (auto *bound = dyn_vmcast<BoundFunction>(*callTarget)) {\n    ++NumBoundFunctionCalls;\n    // Call the bound function.\n    return BoundFunction::_boundCall(bound, runtime->getCurrentIP(), runtime);\n  } else {\n    return runtime->raiseTypeErrorForValue(\n        Handle<>(callTarget), \" is not a function\");\n  }\n}\n\ninline PseudoHandle<> Interpreter::tryGetPrimitiveOwnPropertyById(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id) {\n  if (base->isString() && id == Predefined::getSymbolID(Predefined::length)) {\n    return createPseudoHandle(\n        HermesValue::encodeNumberValue(base->getString()->getStringLength()));\n  }\n  return createPseudoHandle(HermesValue::encodeEmptyValue());\n}\n\nCallResult<PseudoHandle<>> Interpreter::getByIdTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id) {\n  // This is similar to what ES5.1 8.7.1 special [[Get]] internal\n  // method did, but that section doesn't exist in ES9 anymore.\n  // Instead, the [[Get]] Receiver argument serves a similar purpose.\n\n  // Fast path: try to get primitive own property directly first.\n  PseudoHandle<> valOpt = tryGetPrimitiveOwnPropertyById(runtime, base, id);\n  if (!valOpt->isEmpty()) {\n    return valOpt;\n  }\n\n  // get the property descriptor from primitive prototype without\n  // boxing with vm::toObject().  This is where any properties will\n  // be.\n  CallResult<Handle<JSObject>> primitivePrototypeResult =\n      getPrimitivePrototype(runtime, base);\n  if (primitivePrototypeResult == ExecutionStatus::EXCEPTION) {\n    // If an exception is thrown, likely we are trying to read property on\n    // undefined/null. Passing over the name of the property\n    // so that we could emit more meaningful error messages.\n    return amendPropAccessErrorMsgWithPropName(runtime, base, \"read\", id);\n  }\n\n  return JSObject::getNamedWithReceiver_RJS(\n      *primitivePrototypeResult, runtime, id, base);\n}\n\nPseudoHandle<> Interpreter::getByValTransientFast(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> nameHandle) {\n  if (base->isString()) {\n    // Handle most common fast path -- array index property for string\n    // primitive.\n    // Since primitive string cannot have index like property we can\n    // skip ObjectFlags::fastIndexProperties checking and directly\n    // checking index storage from StringPrimitive.\n\n    OptValue<uint32_t> arrayIndex = toArrayIndexFastPath(*nameHandle);\n    // Get character directly from primitive if arrayIndex is within range.\n    // Otherwise we need to fall back to prototype lookup.\n    if (arrayIndex &&\n        arrayIndex.getValue() < base->getString()->getStringLength()) {\n      return createPseudoHandle(\n          runtime\n              ->getCharacterString(base->getString()->at(arrayIndex.getValue()))\n              .getHermesValue());\n    }\n  }\n  return createPseudoHandle(HermesValue::encodeEmptyValue());\n}\n\nCallResult<PseudoHandle<>> Interpreter::getByValTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> name) {\n  // This is similar to what ES5.1 8.7.1 special [[Get]] internal\n  // method did, but that section doesn't exist in ES9 anymore.\n  // Instead, the [[Get]] Receiver argument serves a similar purpose.\n\n  // Optimization: check fast path first.\n  PseudoHandle<> fastRes = getByValTransientFast(runtime, base, name);\n  if (!fastRes->isEmpty()) {\n    return fastRes;\n  }\n\n  auto res = toObject(runtime, base);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n\n  return JSObject::getComputedWithReceiver_RJS(\n      runtime->makeHandle<JSObject>(res.getValue()), runtime, name, base);\n}\n\nstatic ExecutionStatus\ntransientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  // Emit an error message that looks like:\n  // \"Cannot create property '%{id}' on ${typeof base} '${String(base)}'\".\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    // Special workaround for Symbol which can't be stringified.\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n\n  SmallU16String<32> tmp1;\n  SmallU16String<32> tmp2;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp1) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp2) + \"'\");\n}\n\nExecutionStatus Interpreter::putByIdTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id,\n    Handle<> value,\n    bool strictMode) {\n  // ES5.1 8.7.2 special [[Get]] internal method.\n  // TODO: avoid boxing primitives unless we are calling an accessor.\n\n  // 1. Let O be ToObject(base)\n  auto res = toObject(runtime, base);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    // If an exception is thrown, likely we are trying to convert\n    // undefined/null to an object. Passing over the name of the property\n    // so that we could emit more meaningful error messages.\n    return amendPropAccessErrorMsgWithPropName(runtime, base, \"set\", id);\n  }\n\n  auto O = runtime->makeHandle<JSObject>(res.getValue());\n\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = JSObject::getNamedDescriptor(O, runtime, id, desc);\n\n  // Is this a missing property, or a data property defined in the prototype\n  // chain? In both cases we would need to create an own property on the\n  // transient object, which is prohibited.\n  if (!propObj ||\n      (propObj != O.get() &&\n       (!desc.flags.accessor && !desc.flags.proxyObject))) {\n    if (strictMode) {\n      return transientObjectPutErrorMessage(runtime, base, id);\n    }\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Modifying an own data property in a transient object is prohibited.\n  if (!desc.flags.accessor && !desc.flags.proxyObject) {\n    if (strictMode) {\n      return runtime->raiseTypeError(\n          \"Cannot modify a property in a transient object\");\n    }\n    return ExecutionStatus::RETURNED;\n  }\n\n  if (desc.flags.accessor) {\n    // This is an accessor.\n    auto *accessor = vmcast<PropertyAccessor>(\n        JSObject::getNamedSlotValue(propObj, runtime, desc));\n\n    // It needs to have a setter.\n    if (!accessor->setter) {\n      if (strictMode) {\n        return runtime->raiseTypeError(\"Cannot modify a read-only accessor\");\n      }\n      return ExecutionStatus::RETURNED;\n    }\n\n    CallResult<PseudoHandle<>> setRes =\n        accessor->setter.get(runtime)->executeCall1(\n            runtime->makeHandle(accessor->setter), runtime, base, *value);\n    if (setRes == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<bool> setRes = JSProxy::setNamed(\n        runtime->makeHandle(propObj), runtime, id, value, base);\n    if (setRes == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (!*setRes && strictMode) {\n      return runtime->raiseTypeError(\"transient proxy set returned false\");\n    }\n  }\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::putByValTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> name,\n    Handle<> value,\n    bool strictMode) {\n  auto idRes = valueToSymbolID(runtime, name);\n  if (idRes == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n\n  return putByIdTransient_RJS(runtime, base, **idRes, value, strictMode);\n}\n\nCallResult<PseudoHandle<>> Interpreter::createObjectFromBuffer(\n    Runtime *runtime,\n    CodeBlock *curCodeBlock,\n    unsigned numLiterals,\n    unsigned keyBufferIndex,\n    unsigned valBufferIndex) {\n  // Fetch any cached hidden class first.\n  auto *runtimeModule = curCodeBlock->getRuntimeModule();\n  const llvh::Optional<Handle<HiddenClass>> optCachedHiddenClassHandle =\n      runtimeModule->findCachedLiteralHiddenClass(\n          runtime, keyBufferIndex, numLiterals);\n  // Create a new object using the built-in constructor or cached hidden class.\n  // Note that the built-in constructor is empty, so we don't actually need to\n  // call it.\n  auto obj = runtime->makeHandle(\n      optCachedHiddenClassHandle.hasValue()\n          ? JSObject::create(runtime, optCachedHiddenClassHandle.getValue())\n          : JSObject::create(runtime, numLiterals));\n\n  MutableHandle<> tmpHandleKey(runtime);\n  MutableHandle<> tmpHandleVal(runtime);\n  auto &gcScope = *runtime->getTopGCScope();\n  auto marker = gcScope.createMarker();\n\n  auto genPair = curCodeBlock->getObjectBufferIter(\n      keyBufferIndex, valBufferIndex, numLiterals);\n  auto keyGen = genPair.first;\n  auto valGen = genPair.second;\n\n  if (optCachedHiddenClassHandle.hasValue()) {\n    uint32_t propIndex = 0;\n    // keyGen should always have the same amount of elements as valGen\n    while (valGen.hasNext()) {\n#ifndef NDEBUG\n      {\n        // keyGen points to an element in the key buffer, which means it will\n        // only ever generate a Number or a Symbol. This means it will never\n        // allocate memory, and it is safe to not use a Handle.\n        SymbolID stringIdResult{};\n        auto key = keyGen.get(runtime);\n        if (key.isSymbol()) {\n          stringIdResult = ID(key.getSymbol().unsafeGetIndex());\n        } else {\n          tmpHandleKey = HermesValue::encodeDoubleValue(key.getNumber());\n          auto idRes = valueToSymbolID(runtime, tmpHandleKey);\n          assert(\n              idRes != ExecutionStatus::EXCEPTION &&\n              \"valueToIdentifier() failed for uint32_t value\");\n          stringIdResult = **idRes;\n        }\n        NamedPropertyDescriptor desc;\n        auto pos = HiddenClass::findProperty(\n            optCachedHiddenClassHandle.getValue(),\n            runtime,\n            stringIdResult,\n            PropertyFlags::defaultNewNamedPropertyFlags(),\n            desc);\n        assert(\n            pos &&\n            \"Should find this property in cached hidden class property table.\");\n        assert(\n            desc.slot == propIndex &&\n            \"propIndex should be the same as recorded in hidden class table.\");\n      }\n#endif\n      // Explicitly make sure valGen.get() is called before obj.get() so that\n      // any allocation in valGen.get() won't invalidate the raw pointer\n      // retruned from obj.get().\n      auto val = valGen.get(runtime);\n      JSObject::setNamedSlotValue(obj.get(), runtime, propIndex, val);\n      gcScope.flushToMarker(marker);\n      ++propIndex;\n    }\n  } else {\n    // keyGen should always have the same amount of elements as valGen\n    while (keyGen.hasNext()) {\n      // keyGen points to an element in the key buffer, which means it will\n      // only ever generate a Number or a Symbol. This means it will never\n      // allocate memory, and it is safe to not use a Handle.\n      auto key = keyGen.get(runtime);\n      tmpHandleVal = valGen.get(runtime);\n      if (key.isSymbol()) {\n        auto stringIdResult = ID(key.getSymbol().unsafeGetIndex());\n        if (LLVM_UNLIKELY(\n                JSObject::defineNewOwnProperty(\n                    obj,\n                    runtime,\n                    stringIdResult,\n                    PropertyFlags::defaultNewNamedPropertyFlags(),\n                    tmpHandleVal) == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      } else {\n        tmpHandleKey = HermesValue::encodeDoubleValue(key.getNumber());\n        if (LLVM_UNLIKELY(\n                !JSObject::defineOwnComputedPrimitive(\n                     obj,\n                     runtime,\n                     tmpHandleKey,\n                     DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                     tmpHandleVal)\n                     .getValue())) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n      gcScope.flushToMarker(marker);\n    }\n  }\n  tmpHandleKey.clear();\n  tmpHandleVal.clear();\n\n  // Hidden class in dictionary mode can't be shared.\n  HiddenClass *const clazz = obj->getClass(runtime);\n  if (!optCachedHiddenClassHandle.hasValue() && !clazz->isDictionary()) {\n    assert(\n        numLiterals == clazz->getNumProperties() &&\n        \"numLiterals should match hidden class property count.\");\n    assert(\n        clazz->getNumProperties() < 256 &&\n        \"cached hidden class should have property count less than 256\");\n    runtimeModule->tryCacheLiteralHiddenClass(runtime, keyBufferIndex, clazz);\n  }\n\n  return createPseudoHandle(HermesValue::encodeObjectValue(*obj));\n}\n\nCallResult<PseudoHandle<>> Interpreter::createArrayFromBuffer(\n    Runtime *runtime,\n    CodeBlock *curCodeBlock,\n    unsigned numElements,\n    unsigned numLiterals,\n    unsigned bufferIndex) {\n  // Create a new array using the built-in constructor, and initialize\n  // the elements from a literal array buffer.\n  auto arrRes = JSArray::create(runtime, numElements, numElements);\n  if (arrRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Resize the array storage in advance.\n  auto arr = runtime->makeHandle(std::move(*arrRes));\n  JSArray::setStorageEndIndex(arr, runtime, numElements);\n\n  auto iter = curCodeBlock->getArrayBufferIter(bufferIndex, numLiterals);\n  JSArray::size_type i = 0;\n  while (iter.hasNext()) {\n    // NOTE: we must get the value in a separate step to guarantee ordering.\n    auto value = iter.get(runtime);\n    JSArray::unsafeSetExistingElementAt(*arr, runtime, i++, value);\n  }\n\n  return createPseudoHandle(HermesValue::encodeObjectValue(*arr));\n}\n\n#ifndef NDEBUG\nnamespace {\n/// A tag used to instruct the output stream to dump more details about the\n/// HermesValue, like the length of the string, etc.\nstruct DumpHermesValue {\n  const HermesValue hv;\n  DumpHermesValue(HermesValue hv) : hv(hv) {}\n};\n\n} // anonymous namespace.\n\nstatic llvh::raw_ostream &operator<<(\n    llvh::raw_ostream &OS,\n    DumpHermesValue dhv) {\n  OS << dhv.hv;\n  // If it is a string, dump the contents, truncated to 8 characters.\n  if (dhv.hv.isString()) {\n    SmallU16String<32> str;\n    dhv.hv.getString()->appendUTF16String(str);\n    UTF16Ref ref = str.arrayRef();\n    if (str.size() <= 8) {\n      OS << \":'\" << ref << \"'\";\n    } else {\n      OS << \":'\" << ref.slice(0, 8) << \"'\";\n      OS << \"...[\" << str.size() << \"]\";\n    }\n  }\n  return OS;\n}\n\n/// Dump the arguments from a callee frame.\nLLVM_ATTRIBUTE_UNUSED\nstatic void dumpCallArguments(\n    llvh::raw_ostream &OS,\n    Runtime *runtime,\n    StackFramePtr calleeFrame) {\n  OS << \"arguments:\\n\";\n  OS << \"  \" << 0 << \" \" << DumpHermesValue(calleeFrame.getThisArgRef())\n     << \"\\n\";\n  for (unsigned i = 0; i < calleeFrame.getArgCount(); ++i) {\n    OS << \"  \" << (i + 1) << \" \" << DumpHermesValue(calleeFrame.getArgRef(i))\n       << \"\\n\";\n  }\n}\n\nLLVM_ATTRIBUTE_UNUSED\nstatic void printDebugInfo(\n    CodeBlock *curCodeBlock,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  // Check if LLVm debugging is enabled for us.\n  bool debug = false;\n  SLOW_DEBUG(debug = true);\n  if (!debug)\n    return;\n\n  DecodedInstruction decoded = decodeInstruction(ip);\n\n  dbgs() << llvh::format_decimal((const uint8_t *)ip - curCodeBlock->begin(), 4)\n         << \" OpCode::\" << getOpCodeString(decoded.meta.opCode);\n\n  for (unsigned i = 0; i < decoded.meta.numOperands; ++i) {\n    auto operandType = decoded.meta.operandType[i];\n    auto value = decoded.operandValue[i];\n\n    dbgs() << (i == 0 ? \" \" : \", \");\n    dumpOperand(dbgs(), operandType, value);\n\n    if (operandType == OperandType::Reg8 || operandType == OperandType::Reg32) {\n      // Print the register value, if source.\n      if (i != 0 || decoded.meta.numOperands == 1)\n        dbgs() << \"=\" << DumpHermesValue(REG(value.integer));\n    }\n  }\n\n  dbgs() << \"\\n\";\n}\n\n/// \\return whether \\p opcode is a call opcode (Call, CallDirect, Construct,\n/// CallLongIndex, etc). Note CallBuiltin is not really a Call.\nLLVM_ATTRIBUTE_UNUSED\nstatic bool isCallType(OpCode opcode) {\n  switch (opcode) {\n#define DEFINE_RET_TARGET(name) \\\n  case OpCode::name:            \\\n    return true;\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n    default:\n      return false;\n  }\n}\n\n#endif\n\n/// \\return the address of the next instruction after \\p ip, which must be a\n/// call-type instruction.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nstatic inline const Inst *nextInstCall(const Inst *ip) {\n  HERMES_SLOW_ASSERT(isCallType(ip->opCode) && \"ip is not of call type\");\n\n  // The following is written to elicit compares instead of table lookup.\n  // The idea is to present code like so:\n  //   if (opcode <= 70) return ip + 4;\n  //   if (opcode <= 71) return ip + 4;\n  //   if (opcode <= 72) return ip + 4;\n  //   if (opcode <= 73) return ip + 5;\n  //   if (opcode <= 74) return ip + 5;\n  //   ...\n  // and the compiler will retain only compares where the result changes (here,\n  // 72 and 74). This allows us to compute the next instruction using three\n  // compares, instead of a naive compare-per-call type (or lookup table).\n  //\n  // Statically verify that increasing call opcodes correspond to monotone\n  // instruction sizes; this enables the compiler to do a better job optimizing.\n  constexpr bool callSizesMonotoneIncreasing = monotoneIncreasing(\n#define DEFINE_RET_TARGET(name) sizeof(inst::name##Inst),\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n      SIZE_MAX // sentinel avoiding a trailing comma.\n  );\n  static_assert(\n      callSizesMonotoneIncreasing,\n      \"Call instruction sizes are not monotone increasing\");\n\n#define DEFINE_RET_TARGET(name)   \\\n  if (ip->opCode <= OpCode::name) \\\n    return NEXTINST(name);\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n  llvm_unreachable(\"Not a call type\");\n}\n\nCallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(this);\n\n#if defined(HERMES_ENABLE_ALLOCATION_LOCATION_TRACES) || !defined(NDEBUG)\n  // We always call getCurrentIP() in a debug build as this has the effect\n  // of asserting the IP is correctly set (not invalidated) at this point.\n  // This allows us to leverage our whole test-suite to find missing cases\n  // of CAPTURE_IP* macros in the interpreter loop.\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    // All functions end in a Ret so we must match this with a pushCallStack()\n    // before executing.\n    if (codeBlock) {\n      // Push a call entry at the last location we were executing bytecode.\n      // This will correctly attribute things like eval().\n      pushCallStack(codeBlock, ip);\n    } else {\n      // Push a call entry at the entry at the top of interpreted code.\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    // Push a call entry at the entry at the top of interpreted code.\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n\n  InterpreterState state{newCodeBlock, 0};\n  return Interpreter::interpretFunction<false>(this, state);\n}\n\nCallResult<HermesValue> Runtime::interpretFunction(CodeBlock *newCodeBlock) {\n#ifdef HERMESVM_PROFILER_EXTERN\n  auto id = getProfilerID(newCodeBlock);\n  if (id >= NUM_PROFILER_SYMBOLS) {\n    id = NUM_PROFILER_SYMBOLS - 1; // Overflow entry.\n  }\n  return interpWrappers[id](this, newCodeBlock);\n#else\n  return interpretFunctionImpl(newCodeBlock);\n#endif\n}\n\n#ifdef HERMES_ENABLE_DEBUGGER\nExecutionStatus Runtime::stepFunction(InterpreterState &state) {\n  return Interpreter::interpretFunction<true>(this, state).getStatus();\n}\n#endif\n\n/// \\return the quotient of x divided by y.\nstatic double doDiv(double x, double y)\n    LLVM_NO_SANITIZE(\"float-divide-by-zero\");\nstatic inline double doDiv(double x, double y) {\n  // UBSan will complain about float divide by zero as our implementation\n  // of OpCode::Div depends on IEEE 754 float divide by zero. All modern\n  // compilers implement this and there is no trivial work-around without\n  // sacrificing performance and readability.\n  // NOTE: This was pulled out of the interpreter to avoid putting the sanitize\n  // silencer on the entire interpreter function.\n  return x / y;\n}\n\n/// \\return the product of x multiplied by y.\nstatic inline double doMult(double x, double y) {\n  return x * y;\n}\n\n/// \\return the difference of y subtracted from x.\nstatic inline double doSub(double x, double y) {\n  return x - y;\n}\n\ntemplate <bool SingleStep>\nCallResult<HermesValue> Interpreter::interpretFunction(\n    Runtime *runtime,\n    InterpreterState &state) {\n  // The interepter is re-entrant and also saves/restores its IP via the runtime\n  // whenever a call out is made (see the CAPTURE_IP_* macros). As such, failure\n  // to preserve the IP across calls to interpeterFunction() disrupt interpreter\n  // calls further up the C++ callstack. The RAII utility class below makes sure\n  // we always do this correctly.\n  //\n  // TODO: The IPs stored in the C++ callstack via this holder will generally be\n  // the same as in the JS stack frames via the Saved IP field. We can probably\n  // get rid of one of these redundant stores. Doing this isn't completely\n  // trivial as there are currently cases where we re-enter the interpreter\n  // without calling Runtime::saveCallerIPInStackFrame(), and there are features\n  // (I think mostly the debugger + stack traces) which implicitly rely on\n  // this behavior. At least their tests break if this behavior is not\n  // preserved.\n  struct IPSaver {\n    IPSaver(Runtime *runtime)\n        : ip_(runtime->getCurrentIP()), runtime_(runtime) {}\n\n    ~IPSaver() {\n      runtime_->setCurrentIP(ip_);\n    }\n\n   private:\n    const Inst *ip_;\n    Runtime *runtime_;\n  };\n  IPSaver ipSaver(runtime);\n\n#ifndef HERMES_ENABLE_DEBUGGER\n  static_assert(!SingleStep, \"can't use single-step mode without the debugger\");\n#endif\n  // Make sure that the cache can use an optimization by avoiding a branch to\n  // access the property storage.\n  static_assert(\n      HiddenClass::kDictionaryThreshold <=\n          SegmentedArray::kValueToSegmentThreshold,\n      \"Cannot avoid branches in cache check if the dictionary \"\n      \"crossover point is larger than the inline storage\");\n\n  CodeBlock *curCodeBlock = state.codeBlock;\n  const Inst *ip = nullptr;\n  // Holds runtime->currentFrame_.ptr()-1 which is the first local\n  // register. This eliminates the indirect load from Runtime and the -1 offset.\n  PinnedHermesValue *frameRegs;\n  // Strictness of current function.\n  bool strictMode;\n  // Default flags when accessing properties.\n  PropOpFlags defaultPropOpFlags;\n\n// These CAPTURE_IP* macros should wrap around any major calls out of the\n// interpeter loop. They stash and retrieve the IP via the current Runtime\n// allowing the IP to be externally observed and even altered to change the flow\n// of execution. Explicitly saving AND restoring the IP from the Runtime in this\n// way means the C++ compiler will keep IP in a register within the rest of the\n// interpeter loop.\n//\n// When assertions are enabled we take the extra step of \"invalidating\" the IP\n// between captures so we can detect if it's erroneously accessed.\n//\n// In some cases we explicitly don't want to invalidate the IP and instead want\n// it to stay set. For this we use the *NO_INVALIDATE variants. This comes up\n// when we're performing a call operation which may re-enter the interpeter\n// loop, and so need the IP available for the saveCallerIPInStackFrame() call\n// when we next enter.\n#define CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr) \\\n  runtime->setCurrentIP(ip);                       \\\n  dst = expr;                                      \\\n  ip = runtime->getCurrentIP();\n\n#ifdef NDEBUG\n\n#define CAPTURE_IP(expr)     \\\n  runtime->setCurrentIP(ip); \\\n  (void)expr;                \\\n  ip = runtime->getCurrentIP();\n\n#define CAPTURE_IP_ASSIGN(dst, expr) CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr)\n\n#else // !NDEBUG\n\n#define CAPTURE_IP(expr)        \\\n  runtime->setCurrentIP(ip);    \\\n  (void)expr;                   \\\n  ip = runtime->getCurrentIP(); \\\n  runtime->invalidateCurrentIP();\n\n#define CAPTURE_IP_ASSIGN(dst, expr) \\\n  runtime->setCurrentIP(ip);         \\\n  dst = expr;                        \\\n  ip = runtime->getCurrentIP();      \\\n  runtime->invalidateCurrentIP();\n\n#endif // NDEBUG\n\n  LLVM_DEBUG(dbgs() << \"interpretFunction() called\\n\");\n\n  ScopedNativeDepthTracker depthTracker{runtime};\n  if (LLVM_UNLIKELY(depthTracker.overflowed())) {\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  }\n\n  if (!SingleStep) {\n    if (auto jitPtr = runtime->jitContext_.compile(runtime, curCodeBlock)) {\n      return (*jitPtr)(runtime);\n    }\n  }\n\n  GCScope gcScope(runtime);\n  // Avoid allocating a handle dynamically by reusing this one.\n  MutableHandle<> tmpHandle(runtime);\n  CallResult<HermesValue> res{ExecutionStatus::EXCEPTION};\n  CallResult<PseudoHandle<>> resPH{ExecutionStatus::EXCEPTION};\n  CallResult<Handle<Arguments>> resArgs{ExecutionStatus::EXCEPTION};\n  CallResult<bool> boolRes{ExecutionStatus::EXCEPTION};\n\n  // Mark the gcScope so we can clear all allocated handles.\n  // Remember how many handles the scope has so we can clear them in the loop.\n  static constexpr unsigned KEEP_HANDLES = 1;\n  assert(\n      gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n      \"scope has unexpected number of handles\");\n\n  INIT_OPCODE_PROFILER;\n\n#if !defined(HERMESVM_PROFILER_EXTERN)\ntailCall:\n#endif\n  PROFILER_ENTER_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_DEBUGGER\n  runtime->getDebugger().willEnterCodeBlock(curCodeBlock);\n#endif\n\n  runtime->getCodeCoverageProfiler().markExecuted(runtime, curCodeBlock);\n\n  // Update function executionCount_ count\n  curCodeBlock->incrementExecutionCount();\n\n  if (!SingleStep) {\n    auto newFrame = runtime->setCurrentFrameToTopOfStack();\n    runtime->saveCallerIPInStackFrame();\n#ifndef NDEBUG\n    runtime->invalidateCurrentIP();\n#endif\n\n    // Point frameRegs to the first register in the new frame. Note that at this\n    // moment technically it points above the top of the stack, but we are never\n    // going to access it.\n    frameRegs = &newFrame.getFirstLocalRef();\n\n#ifndef NDEBUG\n    LLVM_DEBUG(\n        dbgs() << \"function entry: stackLevel=\" << runtime->getStackLevel()\n               << \", argCount=\" << runtime->getCurrentFrame().getArgCount()\n               << \", frameSize=\" << curCodeBlock->getFrameSize() << \"\\n\");\n\n    LLVM_DEBUG(\n        dbgs() << \" callee \"\n               << DumpHermesValue(\n                      runtime->getCurrentFrame().getCalleeClosureOrCBRef())\n               << \"\\n\");\n    LLVM_DEBUG(\n        dbgs() << \"   this \"\n               << DumpHermesValue(runtime->getCurrentFrame().getThisArgRef())\n               << \"\\n\");\n    for (uint32_t i = 0; i != runtime->getCurrentFrame()->getArgCount(); ++i) {\n      LLVM_DEBUG(\n          dbgs() << \"   \" << llvh::format_decimal(i, 4) << \" \"\n                 << DumpHermesValue(runtime->getCurrentFrame().getArgRef(i))\n                 << \"\\n\");\n    }\n#endif\n\n    // Allocate the registers for the new frame.\n    if (LLVM_UNLIKELY(!runtime->checkAndAllocStack(\n            curCodeBlock->getFrameSize() +\n                StackFrameLayout::CalleeExtraRegistersAtStart,\n            HermesValue::encodeUndefinedValue())))\n      goto stackOverflow;\n\n    ip = (Inst const *)curCodeBlock->begin();\n\n    // Check for invalid invocation.\n    if (LLVM_UNLIKELY(curCodeBlock->getHeaderFlags().isCallProhibited(\n            newFrame.isConstructorCall()))) {\n      if (!newFrame.isConstructorCall()) {\n        CAPTURE_IP(\n            runtime->raiseTypeError(\"Class constructor invoked without new\"));\n      } else {\n        CAPTURE_IP(runtime->raiseTypeError(\"Function is not a constructor\"));\n      }\n      goto handleExceptionInParent;\n    }\n  } else {\n    // Point frameRegs to the first register in the frame.\n    frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n    ip = (Inst const *)(curCodeBlock->begin() + state.offset);\n  }\n\n  assert((const uint8_t *)ip < curCodeBlock->end() && \"CodeBlock is empty\");\n\n  INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n\n#define BEFORE_OP_CODE                                                       \\\n  {                                                                          \\\n    UPDATE_OPCODE_TIME_SPENT;                                                \\\n    HERMES_SLOW_ASSERT(                                                      \\\n        curCodeBlock->contains(ip) && \"curCodeBlock must contain ip\");       \\\n    HERMES_SLOW_ASSERT((printDebugInfo(curCodeBlock, frameRegs, ip), true)); \\\n    HERMES_SLOW_ASSERT(                                                      \\\n        gcScope.getHandleCountDbg() == KEEP_HANDLES &&                       \\\n        \"unaccounted handles were created\");                                 \\\n    HERMES_SLOW_ASSERT(tmpHandle->isUndefined() && \"tmpHandle not cleared\"); \\\n    RECORD_OPCODE_START_TIME;                                                \\\n    INC_OPCODE_COUNT;                                                        \\\n  }\n\n#ifdef HERMESVM_INDIRECT_THREADING\n  static void *opcodeDispatch[] = {\n#define DEFINE_OPCODE(name) &&case_##name,\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n      &&case__last};\n\n#define CASE(name) case_##name:\n#define DISPATCH                                \\\n  BEFORE_OP_CODE;                               \\\n  if (SingleStep) {                             \\\n    state.codeBlock = curCodeBlock;             \\\n    state.offset = CUROFFSET;                   \\\n    return HermesValue::encodeUndefinedValue(); \\\n  }                                             \\\n  goto *opcodeDispatch[(unsigned)ip->opCode]\n\n#else // HERMESVM_INDIRECT_THREADING\n\n#define CASE(name) case OpCode::name:\n#define DISPATCH                                \\\n  if (SingleStep) {                             \\\n    state.codeBlock = curCodeBlock;             \\\n    state.offset = CUROFFSET;                   \\\n    return HermesValue::encodeUndefinedValue(); \\\n  }                                             \\\n  continue\n\n#endif // HERMESVM_INDIRECT_THREADING\n\n#define RUN_DEBUGGER_ASYNC_BREAK(flags)                                      \\\n  do {                                                                       \\\n    CAPTURE_IP_ASSIGN(                                                       \\\n        auto dRes,                                                           \\\n        runDebuggerUpdatingState(                                            \\\n            (uint8_t)(flags) &                                               \\\n                    (uint8_t)Runtime::AsyncBreakReasonBits::DebuggerExplicit \\\n                ? Debugger::RunReason::AsyncBreakExplicit                    \\\n                : Debugger::RunReason::AsyncBreakImplicit,                   \\\n            runtime,                                                         \\\n            curCodeBlock,                                                    \\\n            ip,                                                              \\\n            frameRegs));                                                     \\\n    if (dRes == ExecutionStatus::EXCEPTION)                                  \\\n      goto exception;                                                        \\\n  } while (0)\n\n  for (;;) {\n    BEFORE_OP_CODE;\n\n#ifdef HERMESVM_INDIRECT_THREADING\n    goto *opcodeDispatch[(unsigned)ip->opCode];\n#else\n    switch (ip->opCode)\n#endif\n    {\n      const Inst *nextIP;\n      uint32_t idVal;\n      bool tryProp;\n      uint32_t callArgCount;\n      // This is HermesValue::getRaw(), since HermesValue cannot be assigned\n      // to. It is meant to be used only for very short durations, in the\n      // dispatch of call instructions, when there is definitely no possibility\n      // of a GC.\n      HermesValue::RawType callNewTarget;\n\n/// Handle an opcode \\p name with an out-of-line implementation in a function\n///   ExecutionStatus caseName(\n///       Runtime *,\n///       PinnedHermesValue *frameRegs,\n///       Inst *ip)\n#define CASE_OUTOFLINE(name)                                         \\\n  CASE(name) {                                                       \\\n    CAPTURE_IP_ASSIGN(auto res, case##name(runtime, frameRegs, ip)); \\\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {          \\\n      goto exception;                                                \\\n    }                                                                \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                         \\\n    ip = NEXTINST(name);                                             \\\n    DISPATCH;                                                        \\\n  }\n\n/// Implement a binary arithmetic instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction. The fast path case will have a\n///     \"n\" appended to the name.\n/// \\param oper the C++ operator to use to actually perform the arithmetic\n///     operation.\n#define BINOP(name, oper)                                                  \\\n  CASE(name) {                                                             \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {   \\\n      /* Fast-path. */                                                     \\\n      CASE(name##N) {                                                      \\\n        O1REG(name) = HermesValue::encodeDoubleValue(                      \\\n            oper(O2REG(name).getNumber(), O3REG(name).getNumber()));       \\\n        ip = NEXTINST(name);                                               \\\n        DISPATCH;                                                          \\\n      }                                                                    \\\n    }                                                                      \\\n    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION)                                 \\\n      goto exception;                                                      \\\n    double left = res->getDouble();                                        \\\n    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION)                                 \\\n      goto exception;                                                      \\\n    O1REG(name) =                                                          \\\n        HermesValue::encodeDoubleValue(oper(left, res->getDouble()));      \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n    ip = NEXTINST(name);                                                   \\\n    DISPATCH;                                                              \\\n  }\n\n/// Implement a shift instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the shift\n///     operation.\n/// \\param lConv the conversion function for the LHS of the expression.\n/// \\param lType the type of the LHS operand.\n/// \\param returnType the type of the return value.\n#define SHIFTOP(name, oper, lConv, lType, returnType)                      \\\n  CASE(name) {                                                             \\\n    if (LLVM_LIKELY(                                                       \\\n            O2REG(name).isNumber() &&                                      \\\n            O3REG(name).isNumber())) { /* Fast-path. */                    \\\n      auto lnum = static_cast<lType>(                                      \\\n          hermes::truncateToInt32(O2REG(name).getNumber()));               \\\n      auto rnum = static_cast<uint32_t>(                                   \\\n                      hermes::truncateToInt32(O3REG(name).getNumber())) &  \\\n          0x1f;                                                            \\\n      O1REG(name) = HermesValue::encodeDoubleValue(                        \\\n          static_cast<returnType>(lnum oper rnum));                        \\\n      ip = NEXTINST(name);                                                 \\\n      DISPATCH;                                                            \\\n    }                                                                      \\\n    CAPTURE_IP_ASSIGN(res, lConv(runtime, Handle<>(&O2REG(name))));        \\\n    if (res == ExecutionStatus::EXCEPTION) {                               \\\n      goto exception;                                                      \\\n    }                                                                      \\\n    auto lnum = static_cast<lType>(res->getNumber());                      \\\n    CAPTURE_IP_ASSIGN(res, toUInt32_RJS(runtime, Handle<>(&O3REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION) {                               \\\n      goto exception;                                                      \\\n    }                                                                      \\\n    auto rnum = static_cast<uint32_t>(res->getNumber()) & 0x1f;            \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n    O1REG(name) = HermesValue::encodeDoubleValue(                          \\\n        static_cast<returnType>(lnum oper rnum));                          \\\n    ip = NEXTINST(name);                                                   \\\n    DISPATCH;                                                              \\\n  }\n\n/// Implement a binary bitwise instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the bitwise\n///     operation.\n#define BITWISEBINOP(name, oper)                                               \\\n  CASE(name) {                                                                 \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {       \\\n      /* Fast-path. */                                                         \\\n      O1REG(name) = HermesValue::encodeDoubleValue(                            \\\n          hermes::truncateToInt32(O2REG(name).getNumber())                     \\\n              oper hermes::truncateToInt32(O3REG(name).getNumber()));          \\\n      ip = NEXTINST(name);                                                     \\\n      DISPATCH;                                                                \\\n    }                                                                          \\\n    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(name))));      \\\n    if (res == ExecutionStatus::EXCEPTION) {                                   \\\n      goto exception;                                                          \\\n    }                                                                          \\\n    int32_t left = res->getNumberAs<int32_t>();                                \\\n    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O3REG(name))));      \\\n    if (res == ExecutionStatus::EXCEPTION) {                                   \\\n      goto exception;                                                          \\\n    }                                                                          \\\n    O1REG(name) =                                                              \\\n        HermesValue::encodeNumberValue(left oper res->getNumberAs<int32_t>()); \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                                   \\\n    ip = NEXTINST(name);                                                       \\\n    DISPATCH;                                                                  \\\n  }\n\n/// Implement a comparison instruction.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the fast arithmetic\n///     comparison.\n/// \\param operFuncName  function to call for the slow-path comparison.\n#define CONDOP(name, oper, operFuncName)                                 \\\n  CASE(name) {                                                           \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) { \\\n      /* Fast-path. */                                                   \\\n      O1REG(name) = HermesValue::encodeBoolValue(                        \\\n          O2REG(name).getNumber() oper O3REG(name).getNumber());         \\\n      ip = NEXTINST(name);                                               \\\n      DISPATCH;                                                          \\\n    }                                                                    \\\n    CAPTURE_IP_ASSIGN(                                                   \\\n        boolRes,                                                         \\\n        operFuncName(                                                    \\\n            runtime, Handle<>(&O2REG(name)), Handle<>(&O3REG(name))));   \\\n    if (boolRes == ExecutionStatus::EXCEPTION)                           \\\n      goto exception;                                                    \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                             \\\n    O1REG(name) = HermesValue::encodeBoolValue(boolRes.getValue());      \\\n    ip = NEXTINST(name);                                                 \\\n    DISPATCH;                                                            \\\n  }\n\n/// Implement a comparison conditional jump with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction. The fast path case will have a\n///     \"N\" appended to the name.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param oper the C++ operator to use to actually perform the fast arithmetic\n///     comparison.\n/// \\param operFuncName  function to call for the slow-path comparison.\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_IMPL(name, suffix, oper, operFuncName, trueDest, falseDest) \\\n  CASE(name##suffix) {                                                    \\\n    if (LLVM_LIKELY(                                                      \\\n            O2REG(name##suffix).isNumber() &&                             \\\n            O3REG(name##suffix).isNumber())) {                            \\\n      /* Fast-path. */                                                    \\\n      CASE(name##N##suffix) {                                             \\\n        if (O2REG(name##N##suffix)                                        \\\n                .getNumber() oper O3REG(name##N##suffix)                  \\\n                .getNumber()) {                                           \\\n          ip = trueDest;                                                  \\\n          DISPATCH;                                                       \\\n        }                                                                 \\\n        ip = falseDest;                                                   \\\n        DISPATCH;                                                         \\\n      }                                                                   \\\n    }                                                                     \\\n    CAPTURE_IP_ASSIGN(                                                    \\\n        boolRes,                                                          \\\n        operFuncName(                                                     \\\n            runtime,                                                      \\\n            Handle<>(&O2REG(name##suffix)),                               \\\n            Handle<>(&O3REG(name##suffix))));                             \\\n    if (boolRes == ExecutionStatus::EXCEPTION)                            \\\n      goto exception;                                                     \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                              \\\n    if (boolRes.getValue()) {                                             \\\n      ip = trueDest;                                                      \\\n      DISPATCH;                                                           \\\n    }                                                                     \\\n    ip = falseDest;                                                       \\\n    DISPATCH;                                                             \\\n  }\n\n/// Implement a strict equality conditional jump\n/// \\param name the name of the instruction.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_STRICT_EQ_IMPL(name, suffix, trueDest, falseDest)         \\\n  CASE(name##suffix) {                                                  \\\n    if (strictEqualityTest(O2REG(name##suffix), O3REG(name##suffix))) { \\\n      ip = trueDest;                                                    \\\n      DISPATCH;                                                         \\\n    }                                                                   \\\n    ip = falseDest;                                                     \\\n    DISPATCH;                                                           \\\n  }\n\n/// Implement an equality conditional jump\n/// \\param name the name of the instruction.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_EQ_IMPL(name, suffix, trueDest, falseDest) \\\n  CASE(name##suffix) {                                   \\\n    CAPTURE_IP_ASSIGN(                                   \\\n        res,                                             \\\n        abstractEqualityTest_RJS(                        \\\n            runtime,                                     \\\n            Handle<>(&O2REG(name##suffix)),              \\\n            Handle<>(&O3REG(name##suffix))));            \\\n    if (res == ExecutionStatus::EXCEPTION) {             \\\n      goto exception;                                    \\\n    }                                                    \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);             \\\n    if (res->getBool()) {                                \\\n      ip = trueDest;                                     \\\n      DISPATCH;                                          \\\n    }                                                    \\\n    ip = falseDest;                                      \\\n    DISPATCH;                                            \\\n  }\n\n/// Implement the long and short forms of a conditional jump, and its negation.\n#define JCOND(name, oper, operFuncName) \\\n  JCOND_IMPL(                           \\\n      J##name,                          \\\n      ,                                 \\\n      oper,                             \\\n      operFuncName,                     \\\n      IPADD(ip->iJ##name.op1),          \\\n      NEXTINST(J##name));               \\\n  JCOND_IMPL(                           \\\n      J##name,                          \\\n      Long,                             \\\n      oper,                             \\\n      operFuncName,                     \\\n      IPADD(ip->iJ##name##Long.op1),    \\\n      NEXTINST(J##name##Long));         \\\n  JCOND_IMPL(                           \\\n      JNot##name,                       \\\n      ,                                 \\\n      oper,                             \\\n      operFuncName,                     \\\n      NEXTINST(JNot##name),             \\\n      IPADD(ip->iJNot##name.op1));      \\\n  JCOND_IMPL(                           \\\n      JNot##name,                       \\\n      Long,                             \\\n      oper,                             \\\n      operFuncName,                     \\\n      NEXTINST(JNot##name##Long),       \\\n      IPADD(ip->iJNot##name##Long.op1));\n\n/// Load a constant.\n/// \\param value is the value to store in the output register.\n#define LOAD_CONST(name, value) \\\n  CASE(name) {                  \\\n    O1REG(name) = value;        \\\n    ip = NEXTINST(name);        \\\n    DISPATCH;                   \\\n  }\n\n#define LOAD_CONST_CAPTURE_IP(name, value) \\\n  CASE(name) {                             \\\n    CAPTURE_IP_ASSIGN(O1REG(name), value); \\\n    ip = NEXTINST(name);                   \\\n    DISPATCH;                              \\\n  }\n\n      CASE(Mov) {\n        O1REG(Mov) = O2REG(Mov);\n        ip = NEXTINST(Mov);\n        DISPATCH;\n      }\n\n      CASE(MovLong) {\n        O1REG(MovLong) = O2REG(MovLong);\n        ip = NEXTINST(MovLong);\n        DISPATCH;\n      }\n\n      CASE(LoadParam) {\n        if (LLVM_LIKELY(ip->iLoadParam.op2 <= FRAME.getArgCount())) {\n          // index 0 must load 'this'. Index 1 the first argument, etc.\n          O1REG(LoadParam) = FRAME.getArgRef((int32_t)ip->iLoadParam.op2 - 1);\n          ip = NEXTINST(LoadParam);\n          DISPATCH;\n        }\n        O1REG(LoadParam) = HermesValue::encodeUndefinedValue();\n        ip = NEXTINST(LoadParam);\n        DISPATCH;\n      }\n\n      CASE(LoadParamLong) {\n        if (LLVM_LIKELY(ip->iLoadParamLong.op2 <= FRAME.getArgCount())) {\n          // index 0 must load 'this'. Index 1 the first argument, etc.\n          O1REG(LoadParamLong) =\n              FRAME.getArgRef((int32_t)ip->iLoadParamLong.op2 - 1);\n          ip = NEXTINST(LoadParamLong);\n          DISPATCH;\n        }\n        O1REG(LoadParamLong) = HermesValue::encodeUndefinedValue();\n        ip = NEXTINST(LoadParamLong);\n        DISPATCH;\n      }\n\n      CASE(CoerceThisNS) {\n        if (LLVM_LIKELY(O2REG(CoerceThisNS).isObject())) {\n          O1REG(CoerceThisNS) = O2REG(CoerceThisNS);\n        } else if (\n            O2REG(CoerceThisNS).isNull() || O2REG(CoerceThisNS).isUndefined()) {\n          O1REG(CoerceThisNS) = runtime->global_;\n        } else {\n          tmpHandle = O2REG(CoerceThisNS);\n          nextIP = NEXTINST(CoerceThisNS);\n          goto coerceThisSlowPath;\n        }\n        ip = NEXTINST(CoerceThisNS);\n        DISPATCH;\n      }\n      CASE(LoadThisNS) {\n        if (LLVM_LIKELY(FRAME.getThisArgRef().isObject())) {\n          O1REG(LoadThisNS) = FRAME.getThisArgRef();\n        } else if (\n            FRAME.getThisArgRef().isNull() ||\n            FRAME.getThisArgRef().isUndefined()) {\n          O1REG(LoadThisNS) = runtime->global_;\n        } else {\n          tmpHandle = FRAME.getThisArgRef();\n          nextIP = NEXTINST(LoadThisNS);\n          goto coerceThisSlowPath;\n        }\n        ip = NEXTINST(LoadThisNS);\n        DISPATCH;\n      }\n    coerceThisSlowPath : {\n      CAPTURE_IP_ASSIGN(res, toObject(runtime, tmpHandle));\n      if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      O1REG(CoerceThisNS) = res.getValue();\n      tmpHandle.clear();\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(ConstructLong) {\n        callArgCount = (uint32_t)ip->iConstructLong.op3;\n        nextIP = NEXTINST(ConstructLong);\n        callNewTarget = O2REG(ConstructLong).getRaw();\n        goto doCall;\n      }\n      CASE(CallLong) {\n        callArgCount = (uint32_t)ip->iCallLong.op3;\n        nextIP = NEXTINST(CallLong);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      // Note in Call1 through Call4, the first argument is 'this' which has\n      // argument index -1.\n      // Also note that we are writing to callNewTarget last, to avoid the\n      // possibility of it being aliased by the arg writes.\n      CASE(Call1) {\n        callArgCount = 1;\n        nextIP = NEXTINST(Call1);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call1);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call2) {\n        callArgCount = 2;\n        nextIP = NEXTINST(Call2);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call2);\n        fr.getArgRefUnsafe(0) = O4REG(Call2);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call3) {\n        callArgCount = 3;\n        nextIP = NEXTINST(Call3);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call3);\n        fr.getArgRefUnsafe(0) = O4REG(Call3);\n        fr.getArgRefUnsafe(1) = O5REG(Call3);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call4) {\n        callArgCount = 4;\n        nextIP = NEXTINST(Call4);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call4);\n        fr.getArgRefUnsafe(0) = O4REG(Call4);\n        fr.getArgRefUnsafe(1) = O5REG(Call4);\n        fr.getArgRefUnsafe(2) = O6REG(Call4);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Construct) {\n        callArgCount = (uint32_t)ip->iConstruct.op3;\n        nextIP = NEXTINST(Construct);\n        callNewTarget = O2REG(Construct).getRaw();\n        goto doCall;\n      }\n      CASE(Call) {\n        callArgCount = (uint32_t)ip->iCall.op3;\n        nextIP = NEXTINST(Call);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        // Fall through.\n      }\n\n    doCall : {\n#ifdef HERMES_ENABLE_DEBUGGER\n      // Check for an async debugger request.\n      if (uint8_t asyncFlags =\n              runtime->testAndClearDebuggerAsyncBreakRequest()) {\n        RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        DISPATCH;\n      }\n#endif\n\n      // Subtract 1 from callArgCount as 'this' is considered an argument in the\n      // instruction, but not in the frame.\n      CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n          auto newFrame,\n          StackFramePtr::initFrame(\n              runtime->stackPointer_,\n              FRAME,\n              ip,\n              curCodeBlock,\n              callArgCount - 1,\n              O2REG(Call),\n              HermesValue::fromRaw(callNewTarget)));\n      (void)newFrame;\n\n      SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n      if (auto *func = dyn_vmcast<JSFunction>(O2REG(Call))) {\n        assert(!SingleStep && \"can't single-step a call\");\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n        runtime->pushCallStack(curCodeBlock, ip);\n#endif\n\n        CodeBlock *calleeBlock = func->getCodeBlock();\n        calleeBlock->lazyCompile(runtime);\n#if defined(HERMESVM_PROFILER_EXTERN)\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            res, runtime->interpretFunction(calleeBlock));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(Call) = *res;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = nextIP;\n        DISPATCH;\n#else\n        if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n          res = (*jitPtr)(runtime);\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          O1REG(Call) = *res;\n          SLOW_DEBUG(\n              dbgs() << \"JIT return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                     << DumpHermesValue(O1REG(Call)) << \"\\n\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          ip = nextIP;\n          DISPATCH;\n        }\n        curCodeBlock = calleeBlock;\n        goto tailCall;\n#endif\n      }\n      CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n          resPH, Interpreter::handleCallSlowPath(runtime, &O2REG(Call)));\n      if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      O1REG(Call) = std::move(resPH->get());\n      SLOW_DEBUG(\n          dbgs() << \"native return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                 << DumpHermesValue(O1REG(Call)) << \"\\n\");\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(CallDirect)\n      CASE(CallDirectLongIndex) {\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Check for an async debugger request.\n        if (uint8_t asyncFlags =\n                runtime->testAndClearDebuggerAsyncBreakRequest()) {\n          RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          DISPATCH;\n        }\n#endif\n\n        CAPTURE_IP_ASSIGN(\n            CodeBlock * calleeBlock,\n            ip->opCode == OpCode::CallDirect\n                ? curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                      ip->iCallDirect.op3)\n                : curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                      ip->iCallDirectLongIndex.op3));\n\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            auto newFrame,\n            StackFramePtr::initFrame(\n                runtime->stackPointer_,\n                FRAME,\n                ip,\n                curCodeBlock,\n                (uint32_t)ip->iCallDirect.op2 - 1,\n                HermesValue::encodeNativePointer(calleeBlock),\n                HermesValue::encodeUndefinedValue()));\n        (void)newFrame;\n\n        LLVM_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n        assert(!SingleStep && \"can't single-step a call\");\n\n        calleeBlock->lazyCompile(runtime);\n#if defined(HERMESVM_PROFILER_EXTERN)\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            res, runtime->interpretFunction(calleeBlock));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CallDirect) = *res;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                              : NEXTINST(CallDirectLongIndex);\n        DISPATCH;\n#else\n        if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n          res = (*jitPtr)(runtime);\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          O1REG(CallDirect) = *res;\n          LLVM_DEBUG(\n              dbgs() << \"JIT return value r\" << (unsigned)ip->iCallDirect.op1\n                     << \"=\" << DumpHermesValue(O1REG(Call)) << \"\\n\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                                : NEXTINST(CallDirectLongIndex);\n          DISPATCH;\n        }\n        curCodeBlock = calleeBlock;\n        goto tailCall;\n#endif\n      }\n\n      CASE(CallBuiltin) {\n        NativeFunction *nf =\n            runtime->getBuiltinNativeFunction(ip->iCallBuiltin.op2);\n\n        CAPTURE_IP_ASSIGN(\n            auto newFrame,\n            StackFramePtr::initFrame(\n                runtime->stackPointer_,\n                FRAME,\n                ip,\n                curCodeBlock,\n                (uint32_t)ip->iCallBuiltin.op3 - 1,\n                nf,\n                false));\n        // \"thisArg\" is implicitly assumed to \"undefined\".\n        newFrame.getThisArgRef() = HermesValue::encodeUndefinedValue();\n\n        SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n        CAPTURE_IP_ASSIGN(resPH, NativeFunction::_nativeCall(nf, runtime));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION))\n          goto exception;\n        O1REG(CallBuiltin) = std::move(resPH->get());\n        SLOW_DEBUG(\n            dbgs() << \"native return value r\" << (unsigned)ip->iCallBuiltin.op1\n                   << \"=\" << DumpHermesValue(O1REG(CallBuiltin)) << \"\\n\");\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CallBuiltin);\n        DISPATCH;\n      }\n\n      CASE(CompleteGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        innerFn->setState(GeneratorInnerFunction::State::Completed);\n        ip = NEXTINST(CompleteGenerator);\n        DISPATCH;\n      }\n\n      CASE(SaveGenerator) {\n        nextIP = IPADD(ip->iSaveGenerator.op1);\n        goto doSaveGen;\n      }\n      CASE(SaveGeneratorLong) {\n        nextIP = IPADD(ip->iSaveGeneratorLong.op1);\n        goto doSaveGen;\n      }\n\n    doSaveGen : {\n      auto *innerFn = vmcast<GeneratorInnerFunction>(\n          runtime->getCurrentFrame().getCalleeClosure());\n\n      innerFn->saveStack(runtime);\n      innerFn->setNextIP(nextIP);\n      innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n      ip = NEXTINST(SaveGenerator);\n      DISPATCH;\n    }\n\n      CASE(StartGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        if (innerFn->getState() ==\n            GeneratorInnerFunction::State::SuspendedStart) {\n          nextIP = NEXTINST(StartGenerator);\n        } else {\n          nextIP = innerFn->getNextIP();\n          innerFn->restoreStack(runtime);\n        }\n        innerFn->setState(GeneratorInnerFunction::State::Executing);\n        ip = nextIP;\n        DISPATCH;\n      }\n\n      CASE(ResumeGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        O1REG(ResumeGenerator) = innerFn->getResult();\n        O2REG(ResumeGenerator) = HermesValue::encodeBoolValue(\n            innerFn->getAction() == GeneratorInnerFunction::Action::Return);\n        innerFn->clearResult(runtime);\n        if (innerFn->getAction() == GeneratorInnerFunction::Action::Throw) {\n          runtime->setThrownValue(O1REG(ResumeGenerator));\n          goto exception;\n        }\n        ip = NEXTINST(ResumeGenerator);\n        DISPATCH;\n      }\n\n      CASE(Ret) {\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Check for an async debugger request.\n        if (uint8_t asyncFlags =\n                runtime->testAndClearDebuggerAsyncBreakRequest()) {\n          RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          DISPATCH;\n        }\n#endif\n\n        PROFILER_EXIT_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n        runtime->popCallStack();\n#endif\n\n        // Store the return value.\n        res = O1REG(Ret);\n\n        ip = FRAME.getSavedIP();\n        curCodeBlock = FRAME.getSavedCodeBlock();\n\n        frameRegs =\n            &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n        SLOW_DEBUG(\n            dbgs() << \"function exit: restored stackLevel=\"\n                   << runtime->getStackLevel() << \"\\n\");\n\n        // Are we returning to native code?\n        if (!curCodeBlock) {\n          SLOW_DEBUG(dbgs() << \"function exit: returning to native code\\n\");\n          return res;\n        }\n\n// Return because of recursive calling structure\n#if defined(HERMESVM_PROFILER_EXTERN)\n        return res;\n#endif\n\n        INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n        O1REG(Call) = res.getValue();\n        ip = nextInstCall(ip);\n        DISPATCH;\n      }\n\n      CASE(Catch) {\n        assert(!runtime->thrownValue_.isEmpty() && \"Invalid thrown value\");\n        assert(\n            !isUncatchableError(runtime->thrownValue_) &&\n            \"Uncatchable thrown value was caught\");\n        O1REG(Catch) = runtime->thrownValue_;\n        runtime->clearThrownValue();\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Signal to the debugger that we're done unwinding an exception,\n        // and we can resume normal debugging flow.\n        runtime->debugger_.finishedUnwindingException();\n#endif\n        ip = NEXTINST(Catch);\n        DISPATCH;\n      }\n\n      CASE(Throw) {\n        runtime->thrownValue_ = O1REG(Throw);\n        SLOW_DEBUG(\n            dbgs() << \"Exception thrown: \"\n                   << DumpHermesValue(runtime->thrownValue_) << \"\\n\");\n        goto exception;\n      }\n\n      CASE(ThrowIfUndefinedInst) {\n        if (LLVM_UNLIKELY(O1REG(ThrowIfUndefinedInst).isUndefined())) {\n          SLOW_DEBUG(\n              dbgs() << \"Throwing ReferenceError for undefined variable\");\n          CAPTURE_IP(runtime->raiseReferenceError(\n              \"accessing an uninitialized variable\"));\n          goto exception;\n        }\n        ip = NEXTINST(ThrowIfUndefinedInst);\n        DISPATCH;\n      }\n\n      CASE(Debugger) {\n        SLOW_DEBUG(dbgs() << \"debugger statement executed\\n\");\n#ifdef HERMES_ENABLE_DEBUGGER\n        {\n          if (!runtime->debugger_.isDebugging()) {\n            // Only run the debugger if we're not already debugging.\n            // Don't want to call it again and mess with its state.\n            CAPTURE_IP_ASSIGN(\n                auto res,\n                runDebuggerUpdatingState(\n                    Debugger::RunReason::Opcode,\n                    runtime,\n                    curCodeBlock,\n                    ip,\n                    frameRegs));\n            if (res == ExecutionStatus::EXCEPTION) {\n              // If one of the internal steps threw,\n              // then handle that here by jumping to where we're supposed to go.\n              // If we're in mid-step, the breakpoint at the catch point\n              // will have been set by the debugger.\n              // We don't want to execute this instruction because it's already\n              // thrown.\n              goto exception;\n            }\n          }\n          auto breakpointOpt = runtime->debugger_.getBreakpointLocation(ip);\n          if (breakpointOpt.hasValue()) {\n            // We're on a breakpoint but we're supposed to continue.\n            curCodeBlock->uninstallBreakpointAtOffset(\n                CUROFFSET, breakpointOpt->opCode);\n            if (ip->opCode == OpCode::Debugger) {\n              // Breakpointed a debugger instruction, so move past it\n              // since we've already called the debugger on this instruction.\n              ip = NEXTINST(Debugger);\n            } else {\n              InterpreterState newState{curCodeBlock, (uint32_t)CUROFFSET};\n              CAPTURE_IP_ASSIGN(\n                  ExecutionStatus status, runtime->stepFunction(newState));\n              curCodeBlock->installBreakpointAtOffset(CUROFFSET);\n              if (status == ExecutionStatus::EXCEPTION) {\n                goto exception;\n              }\n              curCodeBlock = newState.codeBlock;\n              ip = newState.codeBlock->getOffsetPtr(newState.offset);\n              INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n              // Single-stepping should handle call stack management for us.\n              frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n            }\n          } else if (ip->opCode == OpCode::Debugger) {\n            // No breakpoint here and we've already run the debugger,\n            // just continue on.\n            // If the current instruction is no longer a debugger instruction,\n            // we're just going to keep executing from the current IP.\n            ip = NEXTINST(Debugger);\n          }\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n        DISPATCH;\n#else\n        ip = NEXTINST(Debugger);\n        DISPATCH;\n#endif\n      }\n\n      CASE(AsyncBreakCheck) {\n        if (LLVM_UNLIKELY(runtime->hasAsyncBreak())) {\n#ifdef HERMES_ENABLE_DEBUGGER\n          if (uint8_t asyncFlags =\n                  runtime->testAndClearDebuggerAsyncBreakRequest()) {\n            RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          }\n#endif\n          if (runtime->testAndClearTimeoutAsyncBreakRequest()) {\n            CAPTURE_IP_ASSIGN(auto nRes, runtime->notifyTimeout());\n            if (nRes == ExecutionStatus::EXCEPTION) {\n              goto exception;\n            }\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n\n        ip = NEXTINST(AsyncBreakCheck);\n        DISPATCH;\n      }\n\n      CASE(ProfilePoint) {\n#ifdef HERMESVM_PROFILER_BB\n        auto pointIndex = ip->iProfilePoint.op1;\n        SLOW_DEBUG(llvh::dbgs() << \"ProfilePoint: \" << pointIndex << \"\\n\");\n        CAPTURE_IP(runtime->getBasicBlockExecutionInfo().executeBlock(\n            curCodeBlock, pointIndex));\n#endif\n        ip = NEXTINST(ProfilePoint);\n        DISPATCH;\n      }\n\n      CASE(Unreachable) {\n        llvm_unreachable(\"Hermes bug: unreachable instruction\");\n      }\n\n      CASE(CreateClosure) {\n        idVal = ip->iCreateClosure.op3;\n        nextIP = NEXTINST(CreateClosure);\n        goto createClosure;\n      }\n      CASE(CreateClosureLongIndex) {\n        idVal = ip->iCreateClosureLongIndex.op3;\n        nextIP = NEXTINST(CreateClosureLongIndex);\n        goto createClosure;\n      }\n    createClosure : {\n      auto *runtimeModule = curCodeBlock->getRuntimeModule();\n      CAPTURE_IP_ASSIGN(\n          O1REG(CreateClosure),\n          JSFunction::create(\n              runtime,\n              runtimeModule->getDomain(runtime),\n              Handle<JSObject>::vmcast(&runtime->functionPrototype),\n              Handle<Environment>::vmcast(&O2REG(CreateClosure)),\n              runtimeModule->getCodeBlockMayAllocate(idVal))\n              .getHermesValue());\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(CreateGeneratorClosure) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGeneratorClosure(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateClosure.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGeneratorClosure))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorClosure) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorClosure);\n        DISPATCH;\n      }\n      CASE(CreateGeneratorClosureLongIndex) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGeneratorClosure(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateClosureLongIndex.op3,\n                Handle<Environment>::vmcast(\n                    &O2REG(CreateGeneratorClosureLongIndex))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorClosureLongIndex) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorClosureLongIndex);\n        DISPATCH;\n      }\n\n      CASE(CreateGenerator) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGenerator_RJS(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateGenerator.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGenerator)),\n                FRAME.getNativeArgs()));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGenerator) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGenerator);\n        DISPATCH;\n      }\n      CASE(CreateGeneratorLongIndex) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGenerator_RJS(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateGeneratorLongIndex.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGeneratorLongIndex)),\n                FRAME.getNativeArgs()));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorLongIndex) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorLongIndex);\n        DISPATCH;\n      }\n\n      CASE(GetEnvironment) {\n        // The currently executing function must exist, so get the environment.\n        Environment *curEnv =\n            FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime);\n        for (unsigned level = ip->iGetEnvironment.op2; level; --level) {\n          assert(curEnv && \"invalid environment relative level\");\n          curEnv = curEnv->getParentEnvironment(runtime);\n        }\n        O1REG(GetEnvironment) = HermesValue::encodeObjectValue(curEnv);\n        ip = NEXTINST(GetEnvironment);\n        DISPATCH;\n      }\n\n      CASE(CreateEnvironment) {\n        tmpHandle = HermesValue::encodeObjectValue(\n            FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime));\n\n        CAPTURE_IP_ASSIGN(\n            res,\n            Environment::create(\n                runtime,\n                tmpHandle->getPointer() ? Handle<Environment>::vmcast(tmpHandle)\n                                        : Handle<Environment>::vmcast_or_null(\n                                              &runtime->nullPointer_),\n                curCodeBlock->getEnvironmentSize()));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        O1REG(CreateEnvironment) = *res;\n#ifdef HERMES_ENABLE_DEBUGGER\n        FRAME.getDebugEnvironmentRef() = *res;\n#endif\n        tmpHandle = HermesValue::encodeUndefinedValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateEnvironment);\n        DISPATCH;\n      }\n\n      CASE(StoreToEnvironment) {\n        vmcast<Environment>(O1REG(StoreToEnvironment))\n            ->slot(ip->iStoreToEnvironment.op2)\n            .set(O3REG(StoreToEnvironment), &runtime->getHeap());\n        ip = NEXTINST(StoreToEnvironment);\n        DISPATCH;\n      }\n      CASE(StoreToEnvironmentL) {\n        vmcast<Environment>(O1REG(StoreToEnvironmentL))\n            ->slot(ip->iStoreToEnvironmentL.op2)\n            .set(O3REG(StoreToEnvironmentL), &runtime->getHeap());\n        ip = NEXTINST(StoreToEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(StoreNPToEnvironment) {\n        vmcast<Environment>(O1REG(StoreNPToEnvironment))\n            ->slot(ip->iStoreNPToEnvironment.op2)\n            .setNonPtr(O3REG(StoreNPToEnvironment), &runtime->getHeap());\n        ip = NEXTINST(StoreNPToEnvironment);\n        DISPATCH;\n      }\n      CASE(StoreNPToEnvironmentL) {\n        vmcast<Environment>(O1REG(StoreNPToEnvironmentL))\n            ->slot(ip->iStoreNPToEnvironmentL.op2)\n            .setNonPtr(O3REG(StoreNPToEnvironmentL), &runtime->getHeap());\n        ip = NEXTINST(StoreNPToEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(LoadFromEnvironment) {\n        O1REG(LoadFromEnvironment) =\n            vmcast<Environment>(O2REG(LoadFromEnvironment))\n                ->slot(ip->iLoadFromEnvironment.op3);\n        ip = NEXTINST(LoadFromEnvironment);\n        DISPATCH;\n      }\n\n      CASE(LoadFromEnvironmentL) {\n        O1REG(LoadFromEnvironmentL) =\n            vmcast<Environment>(O2REG(LoadFromEnvironmentL))\n                ->slot(ip->iLoadFromEnvironmentL.op3);\n        ip = NEXTINST(LoadFromEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(GetGlobalObject) {\n        O1REG(GetGlobalObject) = runtime->global_;\n        ip = NEXTINST(GetGlobalObject);\n        DISPATCH;\n      }\n\n      CASE(GetNewTarget) {\n        O1REG(GetNewTarget) = FRAME.getNewTargetRef();\n        ip = NEXTINST(GetNewTarget);\n        DISPATCH;\n      }\n\n      CASE(DeclareGlobalVar) {\n        DefinePropertyFlags dpf =\n            DefinePropertyFlags::getDefaultNewPropertyFlags();\n        dpf.configurable = 0;\n        // Do not overwrite existing globals with undefined.\n        dpf.setValue = 0;\n\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            JSObject::defineOwnProperty(\n                runtime->getGlobal(),\n                runtime,\n                ID(ip->iDeclareGlobalVar.op1),\n                dpf,\n                Runtime::getUndefinedValue(),\n                PropOpFlags().plusThrowOnError()));\n        if (res == ExecutionStatus::EXCEPTION) {\n          assert(\n              !runtime->getGlobal()->isProxyObject() &&\n              \"global can't be a proxy object\");\n          // If the property already exists, this should be a noop.\n          // Instead of incurring the cost to check every time, do it\n          // only if an exception is thrown, and swallow the exception\n          // if it exists, since we didn't want to make the call,\n          // anyway.  This most likely means the property is\n          // non-configurable.\n          NamedPropertyDescriptor desc;\n          CAPTURE_IP_ASSIGN(\n              auto res,\n              JSObject::getOwnNamedDescriptor(\n                  runtime->getGlobal(),\n                  runtime,\n                  ID(ip->iDeclareGlobalVar.op1),\n                  desc));\n          if (!res) {\n            goto exception;\n          } else {\n            runtime->clearThrownValue();\n          }\n          // fall through\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(DeclareGlobalVar);\n        DISPATCH;\n      }\n\n      CASE(TryGetByIdLong) {\n        tryProp = true;\n        idVal = ip->iTryGetByIdLong.op4;\n        nextIP = NEXTINST(TryGetByIdLong);\n        goto getById;\n      }\n      CASE(GetByIdLong) {\n        tryProp = false;\n        idVal = ip->iGetByIdLong.op4;\n        nextIP = NEXTINST(GetByIdLong);\n        goto getById;\n      }\n      CASE(GetByIdShort) {\n        tryProp = false;\n        idVal = ip->iGetByIdShort.op4;\n        nextIP = NEXTINST(GetByIdShort);\n        goto getById;\n      }\n      CASE(TryGetById) {\n        tryProp = true;\n        idVal = ip->iTryGetById.op4;\n        nextIP = NEXTINST(TryGetById);\n        goto getById;\n      }\n      CASE(GetById) {\n        tryProp = false;\n        idVal = ip->iGetById.op4;\n        nextIP = NEXTINST(GetById);\n      }\n    getById : {\n      ++NumGetById;\n      // NOTE: it is safe to use OnREG(GetById) here because all instructions\n      // have the same layout: opcode, registers, non-register operands, i.e.\n      // they only differ in the width of the last \"identifier\" field.\n      CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n      if (LLVM_LIKELY(O2REG(GetById).isObject())) {\n        auto *obj = vmcast<JSObject>(O2REG(GetById));\n        auto cacheIdx = ip->iGetById.op3;\n        auto *cacheEntry = curCodeBlock->getReadCacheEntry(cacheIdx);\n\n#ifdef HERMESVM_PROFILER_BB\n        {\n          HERMES_SLOW_ASSERT(\n              gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n              \"unaccounted handles were created\");\n          auto objHandle = runtime->makeHandle(obj);\n          auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n              cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n          CAPTURE_IP(runtime->recordHiddenClass(\n              curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n          // obj may be moved by GC due to recordHiddenClass\n          obj = objHandle.get();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n#endif\n        auto clazzGCPtr = obj->getClassGCPtr();\n#ifndef NDEBUG\n        if (clazzGCPtr.get(runtime)->isDictionary())\n          ++NumGetByIdDict;\n#else\n        (void)NumGetByIdDict;\n#endif\n\n        // If we have a cache hit, reuse the cached offset and immediately\n        // return the property.\n        if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n          ++NumGetByIdCacheHits;\n          CAPTURE_IP_ASSIGN(\n              O1REG(GetById),\n              JSObject::getNamedSlotValue<PropStorage::Inline::Yes>(\n                  obj, runtime, cacheEntry->slot));\n          ip = nextIP;\n          DISPATCH;\n        }\n        auto id = ID(idVal);\n        NamedPropertyDescriptor desc;\n        CAPTURE_IP_ASSIGN(\n            OptValue<bool> fastPathResult,\n            JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n        if (LLVM_LIKELY(\n                fastPathResult.hasValue() && fastPathResult.getValue()) &&\n            !desc.flags.accessor) {\n          ++NumGetByIdFastPaths;\n\n          // cacheIdx == 0 indicates no caching so don't update the cache in\n          // those cases.\n          auto *clazz = clazzGCPtr.getNonNull(runtime);\n          if (LLVM_LIKELY(!clazz->isDictionaryNoCache()) &&\n              LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n#ifdef HERMES_SLOW_DEBUG\n            if (cacheEntry->clazz &&\n                cacheEntry->clazz != clazzGCPtr.getStorageType())\n              ++NumGetByIdCacheEvicts;\n#else\n            (void)NumGetByIdCacheEvicts;\n#endif\n            // Cache the class, id and property slot.\n            cacheEntry->clazz = clazzGCPtr.getStorageType();\n            cacheEntry->slot = desc.slot;\n          }\n\n          CAPTURE_IP_ASSIGN(\n              O1REG(GetById), JSObject::getNamedSlotValue(obj, runtime, desc));\n          ip = nextIP;\n          DISPATCH;\n        }\n\n        // The cache may also be populated via the prototype of the object.\n        // This value is only reliable if the fast path was a definite\n        // not-found.\n        if (fastPathResult.hasValue() && !fastPathResult.getValue() &&\n            !obj->isProxyObject()) {\n          CAPTURE_IP_ASSIGN(JSObject * parent, obj->getParent(runtime));\n          // TODO: This isLazy check is because a lazy object is reported as\n          // having no properties and therefore cannot contain the property.\n          // This check does not belong here, it should be merged into\n          // tryGetOwnNamedDescriptorFast().\n          if (parent &&\n              cacheEntry->clazz == parent->getClassGCPtr().getStorageType() &&\n              LLVM_LIKELY(!obj->isLazy())) {\n            ++NumGetByIdProtoHits;\n            CAPTURE_IP_ASSIGN(\n                O1REG(GetById),\n                JSObject::getNamedSlotValue(parent, runtime, cacheEntry->slot));\n            ip = nextIP;\n            DISPATCH;\n          }\n        }\n\n#ifdef HERMES_SLOW_DEBUG\n        CAPTURE_IP_ASSIGN(\n            JSObject * propObj,\n            JSObject::getNamedDescriptor(\n                Handle<JSObject>::vmcast(&O2REG(GetById)), runtime, id, desc));\n        if (propObj) {\n          if (desc.flags.accessor)\n            ++NumGetByIdAccessor;\n          else if (propObj != vmcast<JSObject>(O2REG(GetById)))\n            ++NumGetByIdProto;\n        } else {\n          ++NumGetByIdNotFound;\n        }\n#else\n        (void)NumGetByIdAccessor;\n        (void)NumGetByIdProto;\n        (void)NumGetByIdNotFound;\n#endif\n#ifdef HERMES_SLOW_DEBUG\n        auto *savedClass = cacheIdx != hbc::PROPERTY_CACHING_DISABLED\n            ? cacheEntry->clazz.get(runtime, &runtime->getHeap())\n            : nullptr;\n#endif\n        ++NumGetByIdSlow;\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            JSObject::getNamed_RJS(\n                Handle<JSObject>::vmcast(&O2REG(GetById)),\n                runtime,\n                id,\n                !tryProp ? defaultPropOpFlags\n                         : defaultPropOpFlags.plusMustExist(),\n                cacheIdx != hbc::PROPERTY_CACHING_DISABLED ? cacheEntry\n                                                           : nullptr));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n#ifdef HERMES_SLOW_DEBUG\n        if (cacheIdx != hbc::PROPERTY_CACHING_DISABLED && savedClass &&\n            cacheEntry->clazz.get(runtime, &runtime->getHeap()) != savedClass) {\n          ++NumGetByIdCacheEvicts;\n        }\n#endif\n      } else {\n        ++NumGetByIdTransient;\n        assert(!tryProp && \"TryGetById can only be used on the global object\");\n        /* Slow path. */\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::getByIdTransient_RJS(\n                runtime, Handle<>(&O2REG(GetById)), ID(idVal)));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n      }\n      O1REG(GetById) = resPH->get();\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(TryPutByIdLong) {\n        tryProp = true;\n        idVal = ip->iTryPutByIdLong.op4;\n        nextIP = NEXTINST(TryPutByIdLong);\n        goto putById;\n      }\n      CASE(PutByIdLong) {\n        tryProp = false;\n        idVal = ip->iPutByIdLong.op4;\n        nextIP = NEXTINST(PutByIdLong);\n        goto putById;\n      }\n      CASE(TryPutById) {\n        tryProp = true;\n        idVal = ip->iTryPutById.op4;\n        nextIP = NEXTINST(TryPutById);\n        goto putById;\n      }\n      CASE(PutById) {\n        tryProp = false;\n        idVal = ip->iPutById.op4;\n        nextIP = NEXTINST(PutById);\n      }\n    putById : {\n      ++NumPutById;\n      if (LLVM_LIKELY(O1REG(PutById).isObject())) {\n        auto *obj = vmcast<JSObject>(O1REG(PutById));\n        auto cacheIdx = ip->iPutById.op3;\n        auto *cacheEntry = curCodeBlock->getWriteCacheEntry(cacheIdx);\n\n#ifdef HERMESVM_PROFILER_BB\n        {\n          HERMES_SLOW_ASSERT(\n              gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n              \"unaccounted handles were created\");\n          auto objHandle = runtime->makeHandle(obj);\n          auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n              cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n          CAPTURE_IP(runtime->recordHiddenClass(\n              curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n          // obj may be moved by GC due to recordHiddenClass\n          obj = objHandle.get();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n#endif\n        auto clazzGCPtr = obj->getClassGCPtr();\n        // If we have a cache hit, reuse the cached offset and immediately\n        // return the property.\n        if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n          ++NumPutByIdCacheHits;\n          CAPTURE_IP(JSObject::setNamedSlotValue<PropStorage::Inline::Yes>(\n              obj, runtime, cacheEntry->slot, O2REG(PutById)));\n          ip = nextIP;\n          DISPATCH;\n        }\n        auto id = ID(idVal);\n        NamedPropertyDescriptor desc;\n        CAPTURE_IP_ASSIGN(\n            OptValue<bool> hasOwnProp,\n            JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n        if (LLVM_LIKELY(hasOwnProp.hasValue() && hasOwnProp.getValue()) &&\n            !desc.flags.accessor && desc.flags.writable &&\n            !desc.flags.internalSetter) {\n          ++NumPutByIdFastPaths;\n\n          // cacheIdx == 0 indicates no caching so don't update the cache in\n          // those cases.\n          auto *clazz = clazzGCPtr.getNonNull(runtime);\n          if (LLVM_LIKELY(!clazz->isDictionary()) &&\n              LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n#ifdef HERMES_SLOW_DEBUG\n            if (cacheEntry->clazz &&\n                cacheEntry->clazz != clazzGCPtr.getStorageType())\n              ++NumPutByIdCacheEvicts;\n#else\n            (void)NumPutByIdCacheEvicts;\n#endif\n            // Cache the class and property slot.\n            cacheEntry->clazz = clazzGCPtr.getStorageType();\n            cacheEntry->slot = desc.slot;\n          }\n\n          CAPTURE_IP(JSObject::setNamedSlotValue(\n              obj, runtime, desc.slot, O2REG(PutById)));\n          ip = nextIP;\n          DISPATCH;\n        }\n\n        CAPTURE_IP_ASSIGN(\n            auto putRes,\n            JSObject::putNamed_RJS(\n                Handle<JSObject>::vmcast(&O1REG(PutById)),\n                runtime,\n                id,\n                Handle<>(&O2REG(PutById)),\n                !tryProp ? defaultPropOpFlags\n                         : defaultPropOpFlags.plusMustExist()));\n        if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n      } else {\n        ++NumPutByIdTransient;\n        assert(!tryProp && \"TryPutById can only be used on the global object\");\n        CAPTURE_IP_ASSIGN(\n            auto retStatus,\n            Interpreter::putByIdTransient_RJS(\n                runtime,\n                Handle<>(&O1REG(PutById)),\n                ID(idVal),\n                Handle<>(&O2REG(PutById)),\n                strictMode));\n        if (retStatus == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(GetByVal) {\n        CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n        if (LLVM_LIKELY(O2REG(GetByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              resPH,\n              JSObject::getComputed_RJS(\n                  Handle<JSObject>::vmcast(&O2REG(GetByVal)),\n                  runtime,\n                  Handle<>(&O3REG(GetByVal))));\n          if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(\n              resPH,\n              Interpreter::getByValTransient_RJS(\n                  runtime,\n                  Handle<>(&O2REG(GetByVal)),\n                  Handle<>(&O3REG(GetByVal))));\n          if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetByVal) = resPH->get();\n        ip = NEXTINST(GetByVal);\n        DISPATCH;\n      }\n\n      CASE(PutByVal) {\n        if (LLVM_LIKELY(O1REG(PutByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              auto putRes,\n              JSObject::putComputed_RJS(\n                  Handle<JSObject>::vmcast(&O1REG(PutByVal)),\n                  runtime,\n                  Handle<>(&O2REG(PutByVal)),\n                  Handle<>(&O3REG(PutByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(\n              auto retStatus,\n              Interpreter::putByValTransient_RJS(\n                  runtime,\n                  Handle<>(&O1REG(PutByVal)),\n                  Handle<>(&O2REG(PutByVal)),\n                  Handle<>(&O3REG(PutByVal)),\n                  strictMode));\n          if (LLVM_UNLIKELY(retStatus == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(PutByVal);\n        DISPATCH;\n      }\n\n      CASE(PutOwnByIndexL) {\n        nextIP = NEXTINST(PutOwnByIndexL);\n        idVal = ip->iPutOwnByIndexL.op3;\n        goto putOwnByIndex;\n      }\n      CASE(PutOwnByIndex) {\n        nextIP = NEXTINST(PutOwnByIndex);\n        idVal = ip->iPutOwnByIndex.op3;\n      }\n    putOwnByIndex : {\n      tmpHandle = HermesValue::encodeDoubleValue(idVal);\n      CAPTURE_IP(JSObject::defineOwnComputedPrimitive(\n          Handle<JSObject>::vmcast(&O1REG(PutOwnByIndex)),\n          runtime,\n          tmpHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          Handle<>(&O2REG(PutOwnByIndex))));\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      tmpHandle.clear();\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(GetPNameList) {\n        CAPTURE_IP_ASSIGN(\n            auto pRes, handleGetPNameList(runtime, frameRegs, ip));\n        if (LLVM_UNLIKELY(pRes == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(GetPNameList);\n        DISPATCH;\n      }\n\n      CASE(GetNextPName) {\n        {\n          assert(\n              vmisa<BigStorage>(O2REG(GetNextPName)) &&\n              \"GetNextPName's second op must be BigStorage\");\n          auto obj = Handle<JSObject>::vmcast(&O3REG(GetNextPName));\n          auto arr = Handle<BigStorage>::vmcast(&O2REG(GetNextPName));\n          uint32_t idx = O4REG(GetNextPName).getNumber();\n          uint32_t size = O5REG(GetNextPName).getNumber();\n          MutableHandle<JSObject> propObj{runtime};\n          // Loop until we find a property which is present.\n          while (idx < size) {\n            tmpHandle = arr->at(idx);\n            ComputedPropertyDescriptor desc;\n            CAPTURE_IP(JSObject::getComputedPrimitiveDescriptor(\n                obj, runtime, tmpHandle, propObj, desc));\n            if (LLVM_LIKELY(propObj))\n              break;\n            ++idx;\n          }\n          if (idx < size) {\n            // We must return the property as a string\n            if (tmpHandle->isNumber()) {\n              CAPTURE_IP_ASSIGN(auto status, toString_RJS(runtime, tmpHandle));\n              assert(\n                  status == ExecutionStatus::RETURNED &&\n                  \"toString on number cannot fail\");\n              tmpHandle = status->getHermesValue();\n            }\n            O1REG(GetNextPName) = tmpHandle.get();\n            O4REG(GetNextPName) = HermesValue::encodeNumberValue(idx + 1);\n          } else {\n            O1REG(GetNextPName) = HermesValue::encodeUndefinedValue();\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(GetNextPName);\n        DISPATCH;\n      }\n\n      CASE(ToNumber) {\n        if (LLVM_LIKELY(O2REG(ToNumber).isNumber())) {\n          O1REG(ToNumber) = O2REG(ToNumber);\n          ip = NEXTINST(ToNumber);\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res, toNumber_RJS(runtime, Handle<>(&O2REG(ToNumber))));\n          if (res == ExecutionStatus::EXCEPTION)\n            goto exception;\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(ToNumber) = res.getValue();\n          ip = NEXTINST(ToNumber);\n        }\n        DISPATCH;\n      }\n\n      CASE(ToInt32) {\n        CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(ToInt32))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n          goto exception;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(ToInt32) = res.getValue();\n        ip = NEXTINST(ToInt32);\n        DISPATCH;\n      }\n\n      CASE(AddEmptyString) {\n        if (LLVM_LIKELY(O2REG(AddEmptyString).isString())) {\n          O1REG(AddEmptyString) = O2REG(AddEmptyString);\n          ip = NEXTINST(AddEmptyString);\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res,\n              toPrimitive_RJS(\n                  runtime,\n                  Handle<>(&O2REG(AddEmptyString)),\n                  PreferredType::NONE));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          tmpHandle = res.getValue();\n          CAPTURE_IP_ASSIGN(auto strRes, toString_RJS(runtime, tmpHandle));\n          if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION))\n            goto exception;\n          tmpHandle.clear();\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(AddEmptyString) = strRes->getHermesValue();\n          ip = NEXTINST(AddEmptyString);\n        }\n        DISPATCH;\n      }\n\n      CASE(Jmp) {\n        ip = IPADD(ip->iJmp.op1);\n        DISPATCH;\n      }\n      CASE(JmpLong) {\n        ip = IPADD(ip->iJmpLong.op1);\n        DISPATCH;\n      }\n      CASE(JmpTrue) {\n        if (toBoolean(O2REG(JmpTrue)))\n          ip = IPADD(ip->iJmpTrue.op1);\n        else\n          ip = NEXTINST(JmpTrue);\n        DISPATCH;\n      }\n      CASE(JmpTrueLong) {\n        if (toBoolean(O2REG(JmpTrueLong)))\n          ip = IPADD(ip->iJmpTrueLong.op1);\n        else\n          ip = NEXTINST(JmpTrueLong);\n        DISPATCH;\n      }\n      CASE(JmpFalse) {\n        if (!toBoolean(O2REG(JmpFalse)))\n          ip = IPADD(ip->iJmpFalse.op1);\n        else\n          ip = NEXTINST(JmpFalse);\n        DISPATCH;\n      }\n      CASE(JmpFalseLong) {\n        if (!toBoolean(O2REG(JmpFalseLong)))\n          ip = IPADD(ip->iJmpFalseLong.op1);\n        else\n          ip = NEXTINST(JmpFalseLong);\n        DISPATCH;\n      }\n      CASE(JmpUndefined) {\n        if (O2REG(JmpUndefined).isUndefined())\n          ip = IPADD(ip->iJmpUndefined.op1);\n        else\n          ip = NEXTINST(JmpUndefined);\n        DISPATCH;\n      }\n      CASE(JmpUndefinedLong) {\n        if (O2REG(JmpUndefinedLong).isUndefined())\n          ip = IPADD(ip->iJmpUndefinedLong.op1);\n        else\n          ip = NEXTINST(JmpUndefinedLong);\n        DISPATCH;\n      }\n      CASE(Add) {\n        if (LLVM_LIKELY(\n                O2REG(Add).isNumber() &&\n                O3REG(Add).isNumber())) { /* Fast-path. */\n          CASE(AddN) {\n            O1REG(Add) = HermesValue::encodeDoubleValue(\n                O2REG(Add).getNumber() + O3REG(Add).getNumber());\n            ip = NEXTINST(Add);\n            DISPATCH;\n          }\n        }\n        CAPTURE_IP_ASSIGN(\n            res,\n            addOp_RJS(runtime, Handle<>(&O2REG(Add)), Handle<>(&O3REG(Add))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(Add) = res.getValue();\n        ip = NEXTINST(Add);\n        DISPATCH;\n      }\n\n      CASE(BitNot) {\n        if (LLVM_LIKELY(O2REG(BitNot).isNumber())) { /* Fast-path. */\n          O1REG(BitNot) = HermesValue::encodeDoubleValue(\n              ~hermes::truncateToInt32(O2REG(BitNot).getNumber()));\n          ip = NEXTINST(BitNot);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(BitNot))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(BitNot) = HermesValue::encodeDoubleValue(\n            ~static_cast<int32_t>(res->getNumber()));\n        ip = NEXTINST(BitNot);\n        DISPATCH;\n      }\n\n      CASE(GetArgumentsLength) {\n        // If the arguments object hasn't been created yet.\n        if (O2REG(GetArgumentsLength).isUndefined()) {\n          O1REG(GetArgumentsLength) =\n              HermesValue::encodeNumberValue(FRAME.getArgCount());\n          ip = NEXTINST(GetArgumentsLength);\n          DISPATCH;\n        }\n        // The arguments object has been created, so this is a regular property\n        // get.\n        assert(\n            O2REG(GetArgumentsLength).isObject() &&\n            \"arguments lazy register is not an object\");\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            JSObject::getNamed_RJS(\n                Handle<JSObject>::vmcast(&O2REG(GetArgumentsLength)),\n                runtime,\n                Predefined::getSymbolID(Predefined::length)));\n        if (resPH == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetArgumentsLength) = resPH->get();\n        ip = NEXTINST(GetArgumentsLength);\n        DISPATCH;\n      }\n\n      CASE(GetArgumentsPropByVal) {\n        // If the arguments object hasn't been created yet and we have a\n        // valid integer index, we use the fast path.\n        if (O3REG(GetArgumentsPropByVal).isUndefined()) {\n          // If this is an integer index.\n          if (auto index = toArrayIndexFastPath(O2REG(GetArgumentsPropByVal))) {\n            // Is this an existing argument?\n            if (*index < FRAME.getArgCount()) {\n              O1REG(GetArgumentsPropByVal) = FRAME.getArgRef(*index);\n              ip = NEXTINST(GetArgumentsPropByVal);\n              DISPATCH;\n            }\n          }\n        }\n        // Slow path.\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            getArgumentsPropByValSlowPath_RJS(\n                runtime,\n                &O3REG(GetArgumentsPropByVal),\n                &O2REG(GetArgumentsPropByVal),\n                FRAME.getCalleeClosureHandleUnsafe(),\n                strictMode));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetArgumentsPropByVal) = res->getHermesValue();\n        ip = NEXTINST(GetArgumentsPropByVal);\n        DISPATCH;\n      }\n\n      CASE(ReifyArguments) {\n        // If the arguments object was already created, do nothing.\n        if (!O1REG(ReifyArguments).isUndefined()) {\n          assert(\n              O1REG(ReifyArguments).isObject() &&\n              \"arguments lazy register is not an object\");\n          ip = NEXTINST(ReifyArguments);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(\n            resArgs,\n            reifyArgumentsSlowPath(\n                runtime, FRAME.getCalleeClosureHandleUnsafe(), strictMode));\n        if (LLVM_UNLIKELY(resArgs == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(ReifyArguments) = resArgs->getHermesValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(ReifyArguments);\n        DISPATCH;\n      }\n\n      CASE(NewObject) {\n        // Create a new object using the built-in constructor. Note that the\n        // built-in constructor is empty, so we don't actually need to call\n        // it.\n        CAPTURE_IP_ASSIGN(\n            O1REG(NewObject), JSObject::create(runtime).getHermesValue());\n        assert(\n            gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n            \"Should not create handles.\");\n        ip = NEXTINST(NewObject);\n        DISPATCH;\n      }\n      CASE(NewObjectWithParent) {\n        CAPTURE_IP_ASSIGN(\n            O1REG(NewObjectWithParent),\n            JSObject::create(\n                runtime,\n                O2REG(NewObjectWithParent).isObject()\n                    ? Handle<JSObject>::vmcast(&O2REG(NewObjectWithParent))\n                    : O2REG(NewObjectWithParent).isNull()\n                        ? Runtime::makeNullHandle<JSObject>()\n                        : Handle<JSObject>::vmcast(&runtime->objectPrototype))\n                .getHermesValue());\n        assert(\n            gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n            \"Should not create handles.\");\n        ip = NEXTINST(NewObjectWithParent);\n        DISPATCH;\n      }\n\n      CASE(NewObjectWithBuffer) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createObjectFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewObjectWithBuffer.op3,\n                ip->iNewObjectWithBuffer.op4,\n                ip->iNewObjectWithBuffer.op5));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewObjectWithBuffer) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewObjectWithBuffer);\n        DISPATCH;\n      }\n\n      CASE(NewObjectWithBufferLong) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createObjectFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewObjectWithBufferLong.op3,\n                ip->iNewObjectWithBufferLong.op4,\n                ip->iNewObjectWithBufferLong.op5));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewObjectWithBufferLong) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewObjectWithBufferLong);\n        DISPATCH;\n      }\n\n      CASE(NewArray) {\n        // Create a new array using the built-in constructor. Note that the\n        // built-in constructor is empty, so we don't actually need to call\n        // it.\n        CAPTURE_IP_ASSIGN(\n            auto createRes,\n            JSArray::create(runtime, ip->iNewArray.op2, ip->iNewArray.op2));\n        if (createRes == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        O1REG(NewArray) = createRes->getHermesValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewArray);\n        DISPATCH;\n      }\n\n      CASE(NewArrayWithBuffer) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createArrayFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewArrayWithBuffer.op2,\n                ip->iNewArrayWithBuffer.op3,\n                ip->iNewArrayWithBuffer.op4));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewArrayWithBuffer) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(NewArrayWithBuffer);\n        DISPATCH;\n      }\n\n      CASE(NewArrayWithBufferLong) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createArrayFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewArrayWithBufferLong.op2,\n                ip->iNewArrayWithBufferLong.op3,\n                ip->iNewArrayWithBufferLong.op4));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewArrayWithBufferLong) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(NewArrayWithBufferLong);\n        DISPATCH;\n      }\n\n      CASE(CreateThis) {\n        // Registers: output, prototype, closure.\n        if (LLVM_UNLIKELY(!vmisa<Callable>(O3REG(CreateThis)))) {\n          CAPTURE_IP(runtime->raiseTypeError(\"constructor is not callable\"));\n          goto exception;\n        }\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            Callable::newObject(\n                Handle<Callable>::vmcast(&O3REG(CreateThis)),\n                runtime,\n                Handle<JSObject>::vmcast(\n                    O2REG(CreateThis).isObject() ? &O2REG(CreateThis)\n                                                 : &runtime->objectPrototype)));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(CreateThis) = res->getHermesValue();\n        ip = NEXTINST(CreateThis);\n        DISPATCH;\n      }\n\n      CASE(SelectObject) {\n        // Registers: output, thisObject, constructorReturnValue.\n        O1REG(SelectObject) = O3REG(SelectObject).isObject()\n            ? O3REG(SelectObject)\n            : O2REG(SelectObject);\n        ip = NEXTINST(SelectObject);\n        DISPATCH;\n      }\n\n      CASE(Eq)\n      CASE(Neq) {\n        CAPTURE_IP_ASSIGN(\n            res,\n            abstractEqualityTest_RJS(\n                runtime, Handle<>(&O2REG(Eq)), Handle<>(&O3REG(Eq))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(Eq) = ip->opCode == OpCode::Eq\n            ? res.getValue()\n            : HermesValue::encodeBoolValue(!res->getBool());\n        ip = NEXTINST(Eq);\n        DISPATCH;\n      }\n      CASE(StrictEq) {\n        O1REG(StrictEq) = HermesValue::encodeBoolValue(\n            strictEqualityTest(O2REG(StrictEq), O3REG(StrictEq)));\n        ip = NEXTINST(StrictEq);\n        DISPATCH;\n      }\n      CASE(StrictNeq) {\n        O1REG(StrictNeq) = HermesValue::encodeBoolValue(\n            !strictEqualityTest(O2REG(StrictNeq), O3REG(StrictNeq)));\n        ip = NEXTINST(StrictNeq);\n        DISPATCH;\n      }\n      CASE(Not) {\n        O1REG(Not) = HermesValue::encodeBoolValue(!toBoolean(O2REG(Not)));\n        ip = NEXTINST(Not);\n        DISPATCH;\n      }\n      CASE(Negate) {\n        if (LLVM_LIKELY(O2REG(Negate).isNumber())) {\n          O1REG(Negate) =\n              HermesValue::encodeDoubleValue(-O2REG(Negate).getNumber());\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res, toNumber_RJS(runtime, Handle<>(&O2REG(Negate))));\n          if (res == ExecutionStatus::EXCEPTION)\n            goto exception;\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(Negate) = HermesValue::encodeDoubleValue(-res->getNumber());\n        }\n        ip = NEXTINST(Negate);\n        DISPATCH;\n      }\n      CASE(TypeOf) {\n        CAPTURE_IP_ASSIGN(\n            O1REG(TypeOf), typeOf(runtime, Handle<>(&O2REG(TypeOf))));\n        ip = NEXTINST(TypeOf);\n        DISPATCH;\n      }\n      CASE(Mod) {\n        // We use fmod here for simplicity. Theoretically fmod behaves slightly\n        // differently than the ECMAScript Spec. fmod applies round-towards-zero\n        // for the remainder when it's not representable by a double; while the\n        // spec requires round-to-nearest. As an example, 5 % 0.7 will give\n        // 0.10000000000000031 using fmod, but using the rounding style\n        // described\n        // by the spec, the output should really be 0.10000000000000053.\n        // Such difference can be ignored in practice.\n        if (LLVM_LIKELY(O2REG(Mod).isNumber() && O3REG(Mod).isNumber())) {\n          /* Fast-path. */\n          O1REG(Mod) = HermesValue::encodeDoubleValue(\n              std::fmod(O2REG(Mod).getNumber(), O3REG(Mod).getNumber()));\n          ip = NEXTINST(Mod);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(Mod))));\n        if (res == ExecutionStatus::EXCEPTION)\n          goto exception;\n        double left = res->getDouble();\n        CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(Mod))));\n        if (res == ExecutionStatus::EXCEPTION)\n          goto exception;\n        O1REG(Mod) =\n            HermesValue::encodeDoubleValue(std::fmod(left, res->getDouble()));\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(Mod);\n        DISPATCH;\n      }\n      CASE(InstanceOf) {\n        CAPTURE_IP_ASSIGN(\n            auto result,\n            instanceOfOperator_RJS(\n                runtime,\n                Handle<>(&O2REG(InstanceOf)),\n                Handle<>(&O3REG(InstanceOf))));\n        if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(InstanceOf) = HermesValue::encodeBoolValue(*result);\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(InstanceOf);\n        DISPATCH;\n      }\n      CASE(IsIn) {\n        {\n          if (LLVM_UNLIKELY(!O3REG(IsIn).isObject())) {\n            CAPTURE_IP(runtime->raiseTypeError(\n                \"right operand of 'in' is not an object\"));\n            goto exception;\n          }\n          CAPTURE_IP_ASSIGN(\n              auto cr,\n              JSObject::hasComputed(\n                  Handle<JSObject>::vmcast(&O3REG(IsIn)),\n                  runtime,\n                  Handle<>(&O2REG(IsIn))));\n          if (cr == ExecutionStatus::EXCEPTION) {\n            goto exception;\n          }\n          O1REG(IsIn) = HermesValue::encodeBoolValue(*cr);\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(IsIn);\n        DISPATCH;\n      }\n\n      CASE(PutNewOwnByIdShort) {\n        nextIP = NEXTINST(PutNewOwnByIdShort);\n        idVal = ip->iPutNewOwnByIdShort.op3;\n        goto putOwnById;\n      }\n      CASE(PutNewOwnNEByIdLong)\n      CASE(PutNewOwnByIdLong) {\n        nextIP = NEXTINST(PutNewOwnByIdLong);\n        idVal = ip->iPutNewOwnByIdLong.op3;\n        goto putOwnById;\n      }\n      CASE(PutNewOwnNEById)\n      CASE(PutNewOwnById) {\n        nextIP = NEXTINST(PutNewOwnById);\n        idVal = ip->iPutNewOwnById.op3;\n      }\n    putOwnById : {\n      assert(\n          O1REG(PutNewOwnById).isObject() &&\n          \"Object argument of PutNewOwnById must be an object\");\n      CAPTURE_IP_ASSIGN(\n          auto res,\n          JSObject::defineNewOwnProperty(\n              Handle<JSObject>::vmcast(&O1REG(PutNewOwnById)),\n              runtime,\n              ID(idVal),\n              ip->opCode <= OpCode::PutNewOwnByIdLong\n                  ? PropertyFlags::defaultNewNamedPropertyFlags()\n                  : PropertyFlags::nonEnumerablePropertyFlags(),\n              Handle<>(&O2REG(PutNewOwnById))));\n      if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(DelByIdLong) {\n        idVal = ip->iDelByIdLong.op3;\n        nextIP = NEXTINST(DelByIdLong);\n        goto DelById;\n      }\n\n      CASE(DelById) {\n        idVal = ip->iDelById.op3;\n        nextIP = NEXTINST(DelById);\n      }\n    DelById : {\n      if (LLVM_LIKELY(O2REG(DelById).isObject())) {\n        CAPTURE_IP_ASSIGN(\n            auto status,\n            JSObject::deleteNamed(\n                Handle<JSObject>::vmcast(&O2REG(DelById)),\n                runtime,\n                ID(idVal),\n                defaultPropOpFlags));\n        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());\n      } else {\n        // This is the \"slow path\".\n        CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelById))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          // If an exception is thrown, likely we are trying to convert\n          // undefined/null to an object. Passing over the name of the property\n          // so that we could emit more meaningful error messages.\n          CAPTURE_IP(amendPropAccessErrorMsgWithPropName(\n              runtime, Handle<>(&O2REG(DelById)), \"delete\", ID(idVal)));\n          goto exception;\n        }\n        tmpHandle = res.getValue();\n        CAPTURE_IP_ASSIGN(\n            auto status,\n            JSObject::deleteNamed(\n                Handle<JSObject>::vmcast(tmpHandle),\n                runtime,\n                ID(idVal),\n                defaultPropOpFlags));\n        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());\n        tmpHandle.clear();\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(DelByVal) {\n        if (LLVM_LIKELY(O2REG(DelByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              auto status,\n              JSObject::deleteComputed(\n                  Handle<JSObject>::vmcast(&O2REG(DelByVal)),\n                  runtime,\n                  Handle<>(&O3REG(DelByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelByVal))));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          tmpHandle = res.getValue();\n          CAPTURE_IP_ASSIGN(\n              auto status,\n              JSObject::deleteComputed(\n                  Handle<JSObject>::vmcast(tmpHandle),\n                  runtime,\n                  Handle<>(&O3REG(DelByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(DelByVal);\n        DISPATCH;\n      }\n      CASE(CreateRegExp) {\n        {\n          // Create the RegExp object.\n          CAPTURE_IP_ASSIGN(auto re, JSRegExp::create(runtime));\n          // Initialize the regexp.\n          CAPTURE_IP_ASSIGN(\n              auto pattern,\n              runtime->makeHandle(curCodeBlock->getRuntimeModule()\n                                      ->getStringPrimFromStringIDMayAllocate(\n                                          ip->iCreateRegExp.op2)));\n          CAPTURE_IP_ASSIGN(\n              auto flags,\n              runtime->makeHandle(curCodeBlock->getRuntimeModule()\n                                      ->getStringPrimFromStringIDMayAllocate(\n                                          ip->iCreateRegExp.op3)));\n          CAPTURE_IP_ASSIGN(\n              auto bytecode,\n              curCodeBlock->getRuntimeModule()->getRegExpBytecodeFromRegExpID(\n                  ip->iCreateRegExp.op4));\n          CAPTURE_IP_ASSIGN(\n              auto initRes,\n              JSRegExp::initialize(re, runtime, pattern, flags, bytecode));\n          if (LLVM_UNLIKELY(initRes == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          // Done, return the new object.\n          O1REG(CreateRegExp) = re.getHermesValue();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateRegExp);\n        DISPATCH;\n      }\n\n      CASE(SwitchImm) {\n        if (LLVM_LIKELY(O1REG(SwitchImm).isNumber())) {\n          double numVal = O1REG(SwitchImm).getNumber();\n          uint32_t uintVal = (uint32_t)numVal;\n          if (LLVM_LIKELY(numVal == uintVal) && // Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && // Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) // Bounds checking.\n          {\n            // Calculate the offset into the bytecode where the jump table for\n            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            // Must be signed to account for backwards branching.\n            const int32_t *loc =\n                (const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        // Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(\n          LoadConstUInt8,\n          HermesValue::encodeDoubleValue(ip->iLoadConstUInt8.op2));\n      LOAD_CONST(\n          LoadConstInt, HermesValue::encodeDoubleValue(ip->iLoadConstInt.op2));\n      LOAD_CONST(\n          LoadConstDouble,\n          HermesValue::encodeDoubleValue(ip->iLoadConstDouble.op2));\n      LOAD_CONST_CAPTURE_IP(\n          LoadConstString,\n          HermesValue::encodeStringValue(\n              curCodeBlock->getRuntimeModule()\n                  ->getStringPrimFromStringIDMayAllocate(\n                      ip->iLoadConstString.op2)));\n      LOAD_CONST_CAPTURE_IP(\n          LoadConstStringLongIndex,\n          HermesValue::encodeStringValue(\n              curCodeBlock->getRuntimeModule()\n                  ->getStringPrimFromStringIDMayAllocate(\n                      ip->iLoadConstStringLongIndex.op2)));\n      LOAD_CONST(LoadConstUndefined, HermesValue::encodeUndefinedValue());\n      LOAD_CONST(LoadConstNull, HermesValue::encodeNullValue());\n      LOAD_CONST(LoadConstTrue, HermesValue::encodeBoolValue(true));\n      LOAD_CONST(LoadConstFalse, HermesValue::encodeBoolValue(false));\n      LOAD_CONST(LoadConstZero, HermesValue::encodeDoubleValue(0));\n      BINOP(Sub, doSub);\n      BINOP(Mul, doMult);\n      BINOP(Div, doDiv);\n      BITWISEBINOP(BitAnd, &);\n      BITWISEBINOP(BitOr, |);\n      BITWISEBINOP(BitXor, ^);\n      // For LShift, we need to use toUInt32 first because lshift on negative\n      // numbers is undefined behavior in theory.\n      SHIFTOP(LShift, <<, toUInt32_RJS, uint32_t, int32_t);\n      SHIFTOP(RShift, >>, toInt32_RJS, int32_t, int32_t);\n      SHIFTOP(URshift, >>, toUInt32_RJS, uint32_t, uint32_t);\n      CONDOP(Less, <, lessOp_RJS);\n      CONDOP(LessEq, <=, lessEqualOp_RJS);\n      CONDOP(Greater, >, greaterOp_RJS);\n      CONDOP(GreaterEq, >=, greaterEqualOp_RJS);\n      JCOND(Less, <, lessOp_RJS);\n      JCOND(LessEqual, <=, lessEqualOp_RJS);\n      JCOND(Greater, >, greaterOp_RJS);\n      JCOND(GreaterEqual, >=, greaterEqualOp_RJS);\n\n      JCOND_STRICT_EQ_IMPL(\n          JStrictEqual, , IPADD(ip->iJStrictEqual.op1), NEXTINST(JStrictEqual));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictEqual,\n          Long,\n          IPADD(ip->iJStrictEqualLong.op1),\n          NEXTINST(JStrictEqualLong));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictNotEqual,\n          ,\n          NEXTINST(JStrictNotEqual),\n          IPADD(ip->iJStrictNotEqual.op1));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictNotEqual,\n          Long,\n          NEXTINST(JStrictNotEqualLong),\n          IPADD(ip->iJStrictNotEqualLong.op1));\n\n      JCOND_EQ_IMPL(JEqual, , IPADD(ip->iJEqual.op1), NEXTINST(JEqual));\n      JCOND_EQ_IMPL(\n          JEqual, Long, IPADD(ip->iJEqualLong.op1), NEXTINST(JEqualLong));\n      JCOND_EQ_IMPL(\n          JNotEqual, , NEXTINST(JNotEqual), IPADD(ip->iJNotEqual.op1));\n      JCOND_EQ_IMPL(\n          JNotEqual,\n          Long,\n          NEXTINST(JNotEqualLong),\n          IPADD(ip->iJNotEqualLong.op1));\n\n      CASE_OUTOFLINE(PutOwnByVal);\n      CASE_OUTOFLINE(PutOwnGetterSetterByVal);\n      CASE_OUTOFLINE(DirectEval);\n\n      CASE_OUTOFLINE(IteratorBegin);\n      CASE_OUTOFLINE(IteratorNext);\n      CASE(IteratorClose) {\n        if (LLVM_UNLIKELY(O1REG(IteratorClose).isObject())) {\n          // The iterator must be closed if it's still an object.\n          // That means it was never an index and is not done iterating (a state\n          // which is indicated by `undefined`).\n          CAPTURE_IP_ASSIGN(\n              auto res,\n              iteratorClose(\n                  runtime,\n                  Handle<JSObject>::vmcast(&O1REG(IteratorClose)),\n                  Runtime::getEmptyValue()));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n            if (ip->iIteratorClose.op2 &&\n                !isUncatchableError(runtime->thrownValue_)) {\n              // Ignore inner exception.\n              runtime->clearThrownValue();\n            } else {\n              goto exception;\n            }\n          }\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n        ip = NEXTINST(IteratorClose);\n        DISPATCH;\n      }\n\n      CASE(_last) {\n        llvm_unreachable(\"Invalid opcode _last\");\n      }\n    }\n\n    llvm_unreachable(\"unreachable\");\n\n  // We arrive here if we couldn't allocate the registers for the current frame.\n  stackOverflow:\n    CAPTURE_IP(runtime->raiseStackOverflow(\n        Runtime::StackOverflowKind::JSRegisterStack));\n\n  // We arrive here when we raised an exception in a callee, but we don't want\n  // the callee to be able to handle it.\n  handleExceptionInParent:\n    // Restore the caller code block and IP.\n    curCodeBlock = FRAME.getSavedCodeBlock();\n    ip = FRAME.getSavedIP();\n\n    // Pop to the previous frame where technically the error happened.\n    frameRegs =\n        &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n    // If we are coming from native code, return.\n    if (!curCodeBlock)\n      return ExecutionStatus::EXCEPTION;\n\n// Return because of recursive calling structure\n#ifdef HERMESVM_PROFILER_EXTERN\n    return ExecutionStatus::EXCEPTION;\n#endif\n  // Handle the exception.\n  exception:\n    UPDATE_OPCODE_TIME_SPENT;\n    assert(\n        !runtime->thrownValue_.isEmpty() &&\n        \"thrownValue unavailable at exception\");\n\n    bool catchable = true;\n    // If this is an Error object that was thrown internally, it didn't have\n    // access to the current codeblock and IP, so collect the stack trace here.\n    if (auto *jsError = dyn_vmcast<JSError>(runtime->thrownValue_)) {\n      catchable = jsError->catchable();\n      if (!jsError->getStackTrace()) {\n        // Temporarily clear the thrown value for following operations.\n        CAPTURE_IP_ASSIGN(\n            auto errorHandle,\n            runtime->makeHandle(vmcast<JSError>(runtime->thrownValue_)));\n        runtime->clearThrownValue();\n\n        CAPTURE_IP(JSError::recordStackTrace(\n            errorHandle, runtime, false, curCodeBlock, ip));\n\n        // Restore the thrown value.\n        runtime->setThrownValue(errorHandle.getHermesValue());\n      }\n    }\n\n    gcScope.flushToSmallCount(KEEP_HANDLES);\n    tmpHandle.clear();\n\n#ifdef HERMES_ENABLE_DEBUGGER\n    if (SingleStep) {\n      // If we're single stepping, don't bother with any more checks,\n      // and simply signal that we should continue execution with an exception.\n      state.codeBlock = curCodeBlock;\n      state.offset = CUROFFSET;\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    using PauseOnThrowMode = facebook::hermes::debugger::PauseOnThrowMode;\n    auto mode = runtime->debugger_.getPauseOnThrowMode();\n    if (mode != PauseOnThrowMode::None) {\n      if (!runtime->debugger_.isDebugging()) {\n        // Determine whether the PauseOnThrowMode requires us to stop here.\n        bool caught =\n            runtime->debugger_\n                .findCatchTarget(InterpreterState(curCodeBlock, CUROFFSET))\n                .hasValue();\n        bool shouldStop = mode == PauseOnThrowMode::All ||\n            (mode == PauseOnThrowMode::Uncaught && !caught);\n        if (shouldStop) {\n          // When runDebugger is invoked after an exception,\n          // stepping should never happen internally.\n          // Any step is a step to an exception handler, which we do\n          // directly here in the interpreter.\n          // Thus, the result state should be the same as the input state.\n          InterpreterState tmpState{curCodeBlock, (uint32_t)CUROFFSET};\n          CAPTURE_IP_ASSIGN(\n              ExecutionStatus resultStatus,\n              runtime->debugger_.runDebugger(\n                  Debugger::RunReason::Exception, tmpState));\n          (void)resultStatus;\n          assert(\n              tmpState == InterpreterState(curCodeBlock, CUROFFSET) &&\n              \"not allowed to step internally in a pauseOnThrow\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n      }\n    }\n#endif\n\n    int32_t handlerOffset = 0;\n\n    // If the exception is not catchable, skip found catch blocks.\n    while (((handlerOffset = curCodeBlock->findCatchTargetOffset(CUROFFSET)) ==\n            -1) ||\n           !catchable) {\n      PROFILER_EXIT_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n      runtime->popCallStack();\n#endif\n\n      // Restore the code block and IP.\n      curCodeBlock = FRAME.getSavedCodeBlock();\n      ip = FRAME.getSavedIP();\n\n      // Pop a stack frame.\n      frameRegs =\n          &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n      SLOW_DEBUG(\n          dbgs() << \"function exit with exception: restored stackLevel=\"\n                 << runtime->getStackLevel() << \"\\n\");\n\n      // Are we returning to native code?\n      if (!curCodeBlock) {\n        SLOW_DEBUG(\n            dbgs()\n            << \"function exit with exception: returning to native code\\n\");\n        return ExecutionStatus::EXCEPTION;\n      }\n\n      assert(\n          isCallType(ip->opCode) &&\n          \"return address is not Call-type instruction\");\n\n// Return because of recursive calling structure\n#ifdef HERMESVM_PROFILER_EXTERN\n      return ExecutionStatus::EXCEPTION;\n#endif\n    }\n\n    INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n\n    ip = IPADD(handlerOffset - CUROFFSET);\n  }\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes %s | %FileCheck --match-full-lines %s\n// RUN: %hermes -O %s | %FileCheck --match-full-lines %s\n\nfunction show(iterResult) {\n  print(iterResult.value, '|', iterResult.done);\n}\n\nprint('generators');;\n// CHECK-LABEL: generators\n\nfunction* simple() {\n  yield 1;\n}\n\nvar it = simple();\nshow(it.next());\n// CHECK-NEXT: 1 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\ntry {\n  new simple();\n  print('must throw');\n} catch (e) {\n  print('caught', e.name);\n}\n// CHECK-NEXT: caught TypeError\n\nfunction *useArgs(x, y) {\n  yield x;\n  yield x + 1;\n  ++x;\n  yield x + y;\n}\n\nvar it = useArgs(100, 10);\nshow(it.next());\n// CHECK-NEXT: 100 | false\nshow(it.next());\n// CHECK-NEXT: 101 | false\nshow(it.next());\n// CHECK-NEXT: 111 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *locals(x,y) {\n  var a,b,c;\n  a = 4;\n  yield a;\n  b = a + 5;\n  yield b;\n  c = b + 6;\n  yield c;\n}\n\nvar it = locals(10, 42);\nshow(it.next());\n// CHECK-NEXT: 4 | false\nshow(it.next());\n// CHECK-NEXT: 9 | false\nshow(it.next());\n// CHECK-NEXT: 15 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *args() {\n  yield arguments[0];\n  yield arguments[1];\n}\n\nvar it = args(184, 457);\nshow(it.next());\n// CHECK-NEXT: 184 | false\nshow(it.next());\n// CHECK-NEXT: 457 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction* thrower(x, y) {\n  try {\n    print('in try');\n    yield 1;\n  } catch (e) {\n    print('in catch');\n    yield e;\n    return x;\n  } finally {\n    print('in finally');\n    return y;\n  }\n}\n\nvar it = thrower(10, 20);\nshow(it.next(15));\n// CHECK-NEXT: in try\n// CHECK-NEXT: 1 | false\nshow(it.throw('MY ERROR'));\n// CHECK-NEXT: in catch\n// CHECK-NEXT: MY ERROR | false\nshow(it.throw());\n// CHECK-NEXT: in finally\n// CHECK-NEXT: 20 | true\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *returning(x, y) {\n  try {\n    print('try');\n    yield x;\n  } finally {\n    print('finally');\n    yield y;\n  }\n}\n\nvar it = returning(10, 20);\nshow(it.next(15));\n// CHECK-NEXT: try\n// CHECK-NEXT: 10 | false\nshow(it.return('MY RETVAL'));\n// CHECK-NEXT: finally\n// CHECK-NEXT: 20 | false\nshow(it.next());\n// CHECK-NEXT: MY RETVAL | true\n\n// Ensures that the StartGenerator instruction is moved to the start\n// of the function after optimizations.\nfunction *localsTry() {\n  var x = 0;\n  try {\n    yield x;\n  } catch (e) {\n  }\n}\n\nvar it = localsTry();\nshow(it.next());\n// CHECK-NEXT: 0 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *simpleDelegate() {\n  yield* [1,2,3];\n}\n\nvar it = simpleDelegate();\nshow(it.next());\n// CHECK-NEXT: 1 | false\nshow(it.next());\n// CHECK-NEXT: 2 | false\nshow(it.next());\n// CHECK-NEXT: 3 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *tryCatchDelegate() {\n  function *gen() {\n    try {\n      yield 1;\n      yield 2;\n      yield 3;\n    } catch (e) {\n      print('gen caught', e);\n      return 292;\n    } finally {\n      print('gen finally');\n    }\n  }\n\n  try {\n    var x = yield* gen();\n  } catch (e) {\n    print('outer caught', e);\n    return 193;\n  } finally {\n    print('outer finally');\n  }\n  print('out of the try', x);\n  return 1092;\n}\n\nvar it = tryCatchDelegate()\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.return('c'));\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: c | true\n\nvar it = tryCatchDelegate()\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.throw('c'));\n// CHECK-NEXT: gen caught c\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: out of the try 292\n// CHECK-NEXT: 1092 | true\n\nfunction *complexDelegate() {\n  function *gen() {\n    try {\n      yield 1;\n      yield 2;\n      yield 3;\n    } catch (e) {\n      print('gen caught', e);\n      return 292;\n    } finally {\n      print('gen finally');\n      yield 919;\n      return 100;\n    }\n  }\n\n  try {\n    var x = yield* gen();\n  } catch (e) {\n    print('outer caught', e);\n    return 193;\n  } finally {\n    print('outer finally');\n    return 101;\n  }\n  print(x);\n}\n\nvar it = complexDelegate();\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.return('c'));\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: 919 | false\nshow(it.next('d'));\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: 101 | true\nshow(it.next('e'));\n// CHECK-NEXT: undefined | true\n\nvar it = complexDelegate();\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.throw('c'));\n// CHECK-NEXT: gen caught c\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: 919 | false\nshow(it.next('d'));\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: 101 | true\nshow(it.next('e'));\n// CHECK-NEXT: undefined | true\n\n// Ensure that we don't unwrap/rewrap the value/done properties\n// of the results of .next(), and make sure that abrupt .return() works.\nfunction *iterDelegateWithSecret() {\n  var count = 0;\n  var iterable = {};\n  iterable[Symbol.iterator] = function() {\n    return {\n      next(x) {\n        print('from inside:', x, arguments.length);\n        count++;\n        return { value: count, done: count > 1, SECRET: 42 };\n      },\n      return() {\n        print('closing iterator');\n        return {};\n      }\n    }\n  }\n  yield* iterable;\n}\n\nvar it = iterDelegateWithSecret();\nvar result = it.next(1234);\n// CHECK-NEXT: from inside: undefined 1\nshow(result);\n// CHECK-NEXT: 1 | false\nprint(result.SECRET);\n// CHECK-NEXT: 42\nshow(it.next(1234));\n// CHECK-NEXT: from inside: 1234 1\n// CHECK-NEXT: undefined | true\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nvar it = iterDelegateWithSecret();\nshow(it.next());\n// CHECK-NEXT: from inside: undefined 1\n// CHECK-NEXT: 1 | false\ntry { it.throw() } catch(e) { print(e.name, e.message) }\n// CHECK-NEXT: closing iterator\n// CHECK-NEXT: TypeError yield* delegate must have a .throw() method\n\nvar iter = {\n  [Symbol.iterator]: function() {\n    print('OPEN')\n    return {\n      next: function() {\n        return { value: 42, done: false };\n      }\n    };\n  }\n};\n\nvar callCount = 0;\nvar f = function*([x]) {\n  print('START', x)\n  return 5;\n};\nprint(f.length);\n// CHECK-NEXT: 1\nvar it = f(iter);\n// CHECK-NEXT: OPEN\nshow(it.next())\n// CHECK-NEXT: START 42\n// CHECK-NEXT: 5 | true\n\nvar iterable = {\n  next() {\n    return { value: 1, done: false };\n  },\n  get return() {\n    print('get return');\n    return null;\n  },\n  [Symbol.iterator]() {\n    return iterable;\n  },\n};\n\nfunction* generator() {\n  yield* iterable;\n}\n\n// GetMethod returns undefined, so there shouldn't be an attempt to call.\nvar iterator = generator();\nprint(iterator.next().value);\niterator.return(123);\n// CHECK-NEXT: 1\n// CHECK-NEXT: get return\n"], "fixing_code": ["/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#ifndef HERMES_VM_INTERPRETER_H\n#define HERMES_VM_INTERPRETER_H\n#include <cstdint>\n\n#include \"hermes/VM/Runtime.h\"\n\nclass CodeBlock;\n\nnamespace hermes {\nnamespace vm {\n/// This class is a convenience wrapper for the interpreter implementation that\n/// needs access to the private fields of Runtime, but doesn't belong in\n/// Runtime.\nclass Interpreter {\n public:\n  /// Allocate a GeneratorFuncxtion for the specified function and the specified\n  /// environment. \\param funcIndex function index in the global function table.\n  static CallResult<PseudoHandle<JSGeneratorFunction>> createGeneratorClosure(\n      Runtime *runtime,\n      RuntimeModule *runtimeModule,\n      unsigned funcIndex,\n      Handle<Environment> envHandle);\n\n  /// Allocate a generator for the specified function and the specified\n  /// environment. \\param funcIndex function index in the global function table.\n  static CallResult<PseudoHandle<JSGenerator>> createGenerator_RJS(\n      Runtime *runtime,\n      RuntimeModule *runtimeModule,\n      unsigned funcIndex,\n      Handle<Environment> envHandle,\n      NativeArgs args);\n\n  /// Suspend the generator function and yield to the caller.\n  /// \\param resumeIP Is the IP where the generator should resume from when it\n  ///   is resumed.\n  static void saveGenerator(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const Inst *resumeIP);\n\n  /// Slow path for ReifyArguments resReg, lazyReg\n  /// It assumes that he fast path has handled the case when 'lazyReg' is\n  /// already initialized. It creates a new 'arguments' object and populates it\n  /// with the argument values.\n  static CallResult<Handle<Arguments>> reifyArgumentsSlowPath(\n      Runtime *runtime,\n      Handle<Callable> curFunction,\n      bool strictMode);\n\n  /// Slow path for GetArgumentsPropByVal resReg, propNameReg, lazyReg.\n  ///\n  /// It assumes that the \"fast path\" has already taken care of the case when\n  /// the 'lazyReg' is still uninitialized and 'propNameReg' is a valid integer\n  /// index less than 'argCount'. So we arrive here when either of these is\n  /// true:\n  /// - 'lazyReg' is initialized.\n  /// - index is >= argCount\n  /// - index is not an integer\n  /// In the first case we simply perform a normal property get. In the latter\n  /// we ultimately need to reify the arguments object, but we try to avoid\n  /// doing that by:\n  /// - checking if the property name is \"length\". In that case we can just\n  ///   return the value.\n  /// - checking if the property name in the prototype is not an accessor. In\n  /// that\n  ///   case we can also just return the value read from the prototype.\n  /// Only if all else fails, we reify.\n  /// The FRAME in question is obtained from \\p runtime, and the registers\n  /// \\p lazyReg and \\p valueReg are passed directly to make this function\n  /// easier to use outside the interpeter.\n  static CallResult<PseudoHandle<>> getArgumentsPropByValSlowPath_RJS(\n      Runtime *runtime,\n      PinnedHermesValue *lazyReg,\n      PinnedHermesValue *valueReg,\n      Handle<Callable> curFunction,\n      bool strictMode);\n\n  static ExecutionStatus handleGetPNameList(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const Inst *ip);\n\n  /// Implement the slow path of OpCode::Call/CallLong/Construct/ConstructLong.\n  /// The callee frame must have been initialized already and the fast path\n  /// (calling a \\c JSFunction) must have been handled.\n  /// This handles the rest of the cases (native function, bound funcation, and\n  /// not even a function).\n  /// \\param callTarget the register containing the function object\n  /// \\return ExecutionStatus::EXCEPTION if the call threw.\n  static CallResult<PseudoHandle<>> handleCallSlowPath(\n      Runtime *runtime,\n      PinnedHermesValue *callTarget);\n\n  /// Fast path to get primitive value \\p base's own properties by name \\p id\n  /// without boxing.\n  /// Primitive own properties are properties fetching values from primitive\n  /// value itself.\n  /// Currently the only primitive own property is String.prototype.length.\n  /// If the fast path property does not exist, return Empty.\n  static PseudoHandle<>\n  tryGetPrimitiveOwnPropertyById(Runtime *runtime, Handle<> base, SymbolID id);\n\n  /// Implement OpCode::GetById/TryGetById when the base is not an object.\n  static CallResult<PseudoHandle<>>\n  getByIdTransient_RJS(Runtime *runtime, Handle<> base, SymbolID id);\n\n  /// Fast path for getByValTransient() -- avoid boxing for \\p base if it is\n  /// string primitive and \\p nameHandle is an array index.\n  /// If the property does not exist, return Empty.\n  static PseudoHandle<>\n  getByValTransientFast(Runtime *runtime, Handle<> base, Handle<> nameHandle);\n\n  /// Implement OpCode::GetByVal when the base is not an object.\n  static CallResult<PseudoHandle<>>\n  getByValTransient_RJS(Runtime *runtime, Handle<> base, Handle<> name);\n\n  /// Implement OpCode::PutById/TryPutById when the base is not an object.\n  static ExecutionStatus putByIdTransient_RJS(\n      Runtime *runtime,\n      Handle<> base,\n      SymbolID id,\n      Handle<> value,\n      bool strictMode);\n\n  /// Implement OpCode::PutByVal when the base is not an object.\n  static ExecutionStatus putByValTransient_RJS(\n      Runtime *runtime,\n      Handle<> base,\n      Handle<> name,\n      Handle<> value,\n      bool strictMode);\n\n  template <bool SingleStep>\n  static CallResult<HermesValue> interpretFunction(\n      Runtime *runtime,\n      InterpreterState &state);\n\n  /// Populates an object with literal values from the object buffer.\n  /// \\param numLiterals the amount of literals to read from the buffer.\n  /// \\param keyBufferIndex the first element of the key buffer to read.\n  /// \\param valBufferIndex the first element of the val buffer to read.\n  /// \\return ExecutionStatus::EXCEPTION if the property definitions throw.\n  static CallResult<PseudoHandle<>> createObjectFromBuffer(\n      Runtime *runtime,\n      CodeBlock *curCodeBlock,\n      unsigned numLiterals,\n      unsigned keyBufferIndex,\n      unsigned valBufferIndex);\n\n  /// Populates an array with literal values from the array buffer.\n  /// \\param numLiterals the amount of literals to read from the buffer.\n  /// \\param bufferIndex the first element of the buffer to read.\n  /// \\return ExecutionStatus::EXCEPTION if the property definitions throw.\n  static CallResult<PseudoHandle<>> createArrayFromBuffer(\n      Runtime *runtime,\n      CodeBlock *curCodeBlock,\n      unsigned numElements,\n      unsigned numLiterals,\n      unsigned bufferIndex);\n\n#ifdef HERMES_ENABLE_DEBUGGER\n  /// Wrapper around runDebugger() that reapplies the interpreter state.\n  /// Constructs an interpreter state from the given \\p codeBlock and \\p ip.\n  /// It then invokes the debugger and returns the new code block, and offset by\n  /// reference, and updates frameRegs to its new value. Note this function is\n  /// inline to allow the compiler to verify that the parameters do not escape,\n  /// which might otherwise prevent them from being promoted to registers.\n  LLVM_ATTRIBUTE_ALWAYS_INLINE\n  static inline ExecutionStatus runDebuggerUpdatingState(\n      Debugger::RunReason reason,\n      Runtime *runtime,\n      CodeBlock *&codeBlock,\n      const Inst *&ip,\n      PinnedHermesValue *&frameRegs) {\n    // Hack: if we are already debugging, do nothing. TODO: in the event that we\n    // are already debugging and we get an async debugger request, abort the\n    // current debugging command (e.g. eval something infinite).\n    if (runtime->debugger_.isDebugging())\n      return ExecutionStatus::RETURNED;\n    uint32_t offset = codeBlock->getOffsetOf(ip);\n    InterpreterState state(codeBlock, offset);\n    ExecutionStatus status = runtime->debugger_.runDebugger(reason, state);\n    codeBlock = state.codeBlock;\n    ip = state.codeBlock->getOffsetPtr(state.offset);\n    frameRegs = &runtime->currentFrame_.getFirstLocalRef();\n    return status;\n  }\n#endif\n\n  //===========================================================================\n  // Out-of-line implementations of entire instructions.\n\n  /// Partial implementation of ES6 18.2.1.1\n  /// `PerformEval(x, evalRealm, strictCaller=true, direct=true)`.\n  /// The difference is that we don't support actual lexical scope, of course.\n  static ExecutionStatus caseDirectEval(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus casePutOwnByVal(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus casePutOwnGetterSetterByVal(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n\n  static ExecutionStatus caseIteratorBegin(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n  static ExecutionStatus caseIteratorNext(\n      Runtime *runtime,\n      PinnedHermesValue *frameRegs,\n      const inst::Inst *ip);\n};\n\n} // namespace vm\n} // namespace hermes\n\n#endif\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#define DEBUG_TYPE \"vm\"\n#include \"JSLib/JSLibInternal.h\"\n#include \"hermes/VM/Casting.h\"\n#include \"hermes/VM/Interpreter.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringPrimitive.h\"\n\n#include \"Interpreter-internal.h\"\n\nusing namespace hermes::inst;\n\nnamespace hermes {\nnamespace vm {\n\nvoid Interpreter::saveGenerator(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *resumeIP) {\n  auto *innerFn = vmcast<GeneratorInnerFunction>(FRAME.getCalleeClosure());\n  innerFn->saveStack(runtime);\n  innerFn->setNextIP(resumeIP);\n  innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n}\n\nExecutionStatus Interpreter::caseDirectEval(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  auto *result = &O1REG(DirectEval);\n  auto *input = &O2REG(DirectEval);\n\n  GCScopeMarkerRAII gcMarker{runtime};\n\n  // Check to see if global eval() has been overriden, in which case call it as\n  // as normal function.\n  auto global = runtime->getGlobal();\n  auto existingEval = global->getNamed_RJS(\n      global, runtime, Predefined::getSymbolID(Predefined::eval));\n  if (LLVM_UNLIKELY(existingEval == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto *nativeExistingEval = dyn_vmcast<NativeFunction>(existingEval->get());\n  if (LLVM_UNLIKELY(\n          !nativeExistingEval ||\n          nativeExistingEval->getFunctionPtr() != hermes::vm::eval)) {\n    if (auto *existingEvalCallable =\n            dyn_vmcast<Callable>(existingEval->get())) {\n      auto evalRes = existingEvalCallable->executeCall1(\n          runtime->makeHandle<Callable>(existingEvalCallable),\n          runtime,\n          Runtime::getUndefinedValue(),\n          *input);\n      if (LLVM_UNLIKELY(evalRes == ExecutionStatus::EXCEPTION)) {\n        return ExecutionStatus::EXCEPTION;\n      }\n      *result = evalRes->get();\n      evalRes->invalidate();\n      return ExecutionStatus::RETURNED;\n    }\n    return runtime->raiseTypeErrorForValue(\n        runtime->makeHandle(std::move(*existingEval)), \" is not a function\");\n  }\n\n  if (!input->isString()) {\n    *result = *input;\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Create a dummy scope, so that the local eval executes in its own scope\n  // (as per the spec for strict callers, which is the only thing we support).\n\n  ScopeChain scopeChain{};\n  scopeChain.functions.emplace_back();\n\n  auto cr = vm::directEval(\n      runtime, Handle<StringPrimitive>::vmcast(input), scopeChain, false);\n  if (cr == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n\n  *result = *cr;\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::casePutOwnByVal(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  return JSObject::defineOwnComputed(\n             Handle<JSObject>::vmcast(&O1REG(PutOwnByVal)),\n             runtime,\n             Handle<>(&O3REG(PutOwnByVal)),\n             ip->iPutOwnByVal.op4\n                 ? DefinePropertyFlags::getDefaultNewPropertyFlags()\n                 : DefinePropertyFlags::getNewNonEnumerableFlags(),\n             Handle<>(&O2REG(PutOwnByVal)))\n      .getStatus();\n}\n\nExecutionStatus Interpreter::casePutOwnGetterSetterByVal(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  DefinePropertyFlags dpFlags{};\n  dpFlags.setConfigurable = 1;\n  dpFlags.configurable = 1;\n  dpFlags.setEnumerable = 1;\n  dpFlags.enumerable = ip->iPutOwnGetterSetterByVal.op5;\n\n  MutableHandle<Callable> getter(runtime);\n  MutableHandle<Callable> setter(runtime);\n  if (LLVM_LIKELY(!O3REG(PutOwnGetterSetterByVal).isUndefined())) {\n    dpFlags.setGetter = 1;\n    getter = vmcast<Callable>(O3REG(PutOwnGetterSetterByVal));\n  }\n  if (LLVM_LIKELY(!O4REG(PutOwnGetterSetterByVal).isUndefined())) {\n    dpFlags.setSetter = 1;\n    setter = vmcast<Callable>(O4REG(PutOwnGetterSetterByVal));\n  }\n  assert(\n      (dpFlags.setSetter || dpFlags.setGetter) &&\n      \"No accessor set in PutOwnGetterSetterByVal\");\n\n  auto res = PropertyAccessor::create(runtime, getter, setter);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n\n  auto accessor = runtime->makeHandle<PropertyAccessor>(*res);\n\n  return JSObject::defineOwnComputed(\n             Handle<JSObject>::vmcast(&O1REG(PutOwnGetterSetterByVal)),\n             runtime,\n             Handle<>(&O2REG(PutOwnGetterSetterByVal)),\n             dpFlags,\n             accessor)\n      .getStatus();\n}\n\nExecutionStatus Interpreter::caseIteratorBegin(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  if (LLVM_LIKELY(vmisa<JSArray>(O2REG(IteratorBegin)))) {\n    // Attempt to get the fast path for array iteration.\n    NamedPropertyDescriptor desc;\n    JSObject *propObj = JSObject::getNamedDescriptor(\n        Handle<JSArray>::vmcast(&O2REG(IteratorBegin)),\n        runtime,\n        Predefined::getSymbolID(Predefined::SymbolIterator),\n        desc);\n    if (propObj) {\n      HermesValue slotValue =\n          JSObject::getNamedSlotValue(propObj, runtime, desc);\n      if (slotValue.getRaw() == runtime->arrayPrototypeValues.getRaw()) {\n        O1REG(IteratorBegin) = HermesValue::encodeNumberValue(0);\n        return ExecutionStatus::RETURNED;\n      }\n    }\n  }\n  GCScopeMarkerRAII marker{runtime};\n  CallResult<IteratorRecord> iterRecord =\n      getIterator(runtime, Handle<>(&O2REG(IteratorBegin)));\n  if (LLVM_UNLIKELY(iterRecord == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  O1REG(IteratorBegin) = iterRecord->iterator.getHermesValue();\n  O2REG(IteratorBegin) = iterRecord->nextMethod.getHermesValue();\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::caseIteratorNext(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const inst::Inst *ip) {\n  if (LLVM_LIKELY(O2REG(IteratorNext).isNumber())) {\n    JSArray::size_type i =\n        O2REG(IteratorNext).getNumberAs<JSArray::size_type>();\n    if (i >= JSArray::getLength(vmcast<JSArray>(O3REG(IteratorNext)))) {\n      // Finished iterating the array, stop.\n      O2REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n      O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n      return ExecutionStatus::RETURNED;\n    }\n    Handle<JSArray> arr = Handle<JSArray>::vmcast(&O3REG(IteratorNext));\n    {\n      // Fast path: look up the property in indexed storage.\n      // Runs when there is no hole and a regular non-accessor property exists\n      // at the current index, because those are the only properties stored\n      // in indexed storage.\n      // If there is another kind of property we have to call getComputed_RJS.\n      // No need to check the fastIndexProperties flag because the indexed\n      // storage would be deleted and at() would return empty in that case.\n      NoAllocScope noAlloc{runtime};\n      HermesValue value = arr->at(runtime, i);\n      if (LLVM_LIKELY(!value.isEmpty())) {\n        O1REG(IteratorNext) = value;\n        O2REG(IteratorNext) = HermesValue::encodeNumberValue(i + 1);\n        return ExecutionStatus::RETURNED;\n      }\n    }\n    // Slow path, just run the full getComputedPropertyValue_RJS path.\n    GCScopeMarkerRAII marker{runtime};\n    Handle<> idxHandle{&O2REG(IteratorNext)};\n    CallResult<PseudoHandle<>> valueRes =\n        JSObject::getComputed_RJS(arr, runtime, idxHandle);\n    if (LLVM_UNLIKELY(valueRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    O1REG(IteratorNext) = valueRes->get();\n    O2REG(IteratorNext) = HermesValue::encodeNumberValue(i + 1);\n    return ExecutionStatus::RETURNED;\n  }\n  if (LLVM_UNLIKELY(O2REG(IteratorNext).isUndefined())) {\n    // In all current use cases of IteratorNext, we check and branch away\n    // from IteratorNext in the case that iterStorage was set to undefined\n    // (which indicates completion of iteration).\n    // If we introduce a use case which allows calling IteratorNext,\n    // then this assert can be removed. For now, this branch just returned\n    // undefined in NDEBUG mode.\n    assert(false && \"IteratorNext called on completed iterator\");\n    O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n    return ExecutionStatus::RETURNED;\n  }\n\n  GCScopeMarkerRAII marker{runtime};\n\n  IteratorRecord iterRecord{Handle<JSObject>::vmcast(&O2REG(IteratorNext)),\n                            Handle<Callable>::vmcast(&O3REG(IteratorNext))};\n\n  CallResult<PseudoHandle<JSObject>> resultObjRes =\n      iteratorNext(runtime, iterRecord, llvh::None);\n  if (LLVM_UNLIKELY(resultObjRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<JSObject> resultObj = runtime->makeHandle(std::move(*resultObjRes));\n  CallResult<PseudoHandle<>> doneRes = JSObject::getNamed_RJS(\n      resultObj, runtime, Predefined::getSymbolID(Predefined::done));\n  if (LLVM_UNLIKELY(doneRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (toBoolean(doneRes->get())) {\n    // Done with iteration. Clear the iterator so that subsequent\n    // instructions do not call next() or return().\n    O2REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n    O1REG(IteratorNext) = HermesValue::encodeUndefinedValue();\n  } else {\n    // Not done iterating, so get the `value` property and store it\n    // as the result.\n    CallResult<PseudoHandle<>> propRes = JSObject::getNamed_RJS(\n        resultObj, runtime, Predefined::getSymbolID(Predefined::value));\n    if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    O1REG(IteratorNext) = propRes->get();\n    propRes->invalidate();\n  }\n  return ExecutionStatus::RETURNED;\n}\n\n} // namespace vm\n} // namespace hermes\n", "/*\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#define DEBUG_TYPE \"vm\"\n#include \"hermes/VM/Interpreter.h\"\n#include \"hermes/VM/Runtime.h\"\n\n#include \"hermes/Inst/InstDecode.h\"\n#include \"hermes/Support/Conversions.h\"\n#include \"hermes/Support/SlowAssert.h\"\n#include \"hermes/Support/Statistic.h\"\n#include \"hermes/VM/Callable.h\"\n#include \"hermes/VM/CodeBlock.h\"\n#include \"hermes/VM/HandleRootOwner-inline.h\"\n#include \"hermes/VM/JIT/JIT.h\"\n#include \"hermes/VM/JSArray.h\"\n#include \"hermes/VM/JSError.h\"\n#include \"hermes/VM/JSGenerator.h\"\n#include \"hermes/VM/JSProxy.h\"\n#include \"hermes/VM/JSRegExp.h\"\n#include \"hermes/VM/Operations.h\"\n#include \"hermes/VM/Profiler.h\"\n#include \"hermes/VM/Profiler/CodeCoverageProfiler.h\"\n#include \"hermes/VM/Runtime-inline.h\"\n#include \"hermes/VM/RuntimeModule-inline.h\"\n#include \"hermes/VM/StackFrame-inline.h\"\n#include \"hermes/VM/StringPrimitive.h\"\n#include \"hermes/VM/StringView.h\"\n\n#include \"llvh/ADT/SmallSet.h\"\n#include \"llvh/Support/Debug.h\"\n#include \"llvh/Support/Format.h\"\n#include \"llvh/Support/raw_ostream.h\"\n\n#include \"Interpreter-internal.h\"\n\nusing llvh::dbgs;\nusing namespace hermes::inst;\n\nHERMES_SLOW_STATISTIC(\n    NumGetById,\n    \"NumGetById: Number of property 'read by id' accesses\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdCacheHits,\n    \"NumGetByIdCacheHits: Number of property 'read by id' cache hits\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdProtoHits,\n    \"NumGetByIdProtoHits: Number of property 'read by id' cache hits for the prototype\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdCacheEvicts,\n    \"NumGetByIdCacheEvicts: Number of property 'read by id' cache evictions\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdFastPaths,\n    \"NumGetByIdFastPaths: Number of property 'read by id' fast paths\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdAccessor,\n    \"NumGetByIdAccessor: Number of property 'read by id' accessors\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdProto,\n    \"NumGetByIdProto: Number of property 'read by id' in the prototype chain\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdNotFound,\n    \"NumGetByIdNotFound: Number of property 'read by id' not found\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdTransient,\n    \"NumGetByIdTransient: Number of property 'read by id' of non-objects\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdDict,\n    \"NumGetByIdDict: Number of property 'read by id' of dictionaries\");\nHERMES_SLOW_STATISTIC(\n    NumGetByIdSlow,\n    \"NumGetByIdSlow: Number of property 'read by id' slow path\");\n\nHERMES_SLOW_STATISTIC(\n    NumPutById,\n    \"NumPutById: Number of property 'write by id' accesses\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdCacheHits,\n    \"NumPutByIdCacheHits: Number of property 'write by id' cache hits\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdCacheEvicts,\n    \"NumPutByIdCacheEvicts: Number of property 'write by id' cache evictions\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdFastPaths,\n    \"NumPutByIdFastPaths: Number of property 'write by id' fast paths\");\nHERMES_SLOW_STATISTIC(\n    NumPutByIdTransient,\n    \"NumPutByIdTransient: Number of property 'write by id' to non-objects\");\n\nHERMES_SLOW_STATISTIC(\n    NumNativeFunctionCalls,\n    \"NumNativeFunctionCalls: Number of native function calls\");\nHERMES_SLOW_STATISTIC(\n    NumBoundFunctionCalls,\n    \"NumBoundCalls: Number of bound function calls\");\n\n// Ensure that instructions declared as having matching layouts actually do.\n#include \"InstLayout.inc\"\n\n#if defined(HERMESVM_PROFILER_EXTERN)\n// External profiler mode wraps calls to each JS function with a unique native\n// function that recusively calls the interpreter. See Profiler.{h,cpp} for how\n// these symbols are subsequently patched with JS function names.\n#define INTERP_WRAPPER(name)                                                \\\n  __attribute__((__noinline__)) static llvh::CallResult<llvh::HermesValue>  \\\n  name(hermes::vm::Runtime *runtime, hermes::vm::CodeBlock *newCodeBlock) { \\\n    return runtime->interpretFunctionImpl(newCodeBlock);                    \\\n  }\nPROFILER_SYMBOLS(INTERP_WRAPPER)\n#endif\n\nnamespace hermes {\nnamespace vm {\n\n#if defined(HERMESVM_PROFILER_EXTERN)\ntypedef CallResult<HermesValue> (*WrapperFunc)(Runtime *, CodeBlock *);\n#define LIST_ITEM(name) name,\nstatic const WrapperFunc interpWrappers[] = {PROFILER_SYMBOLS(LIST_ITEM)};\n#endif\n\n/// Initialize the state of some internal variables based on the current\n/// code block.\n#define INIT_STATE_FOR_CODEBLOCK(codeBlock)                 \\\n  do {                                                      \\\n    strictMode = (codeBlock)->isStrictMode();               \\\n    defaultPropOpFlags = DEFAULT_PROP_OP_FLAGS(strictMode); \\\n  } while (0)\n\nCallResult<PseudoHandle<JSGeneratorFunction>>\nInterpreter::createGeneratorClosure(\n    Runtime *runtime,\n    RuntimeModule *runtimeModule,\n    unsigned funcIndex,\n    Handle<Environment> envHandle) {\n  return JSGeneratorFunction::create(\n      runtime,\n      runtimeModule->getDomain(runtime),\n      Handle<JSObject>::vmcast(&runtime->generatorFunctionPrototype),\n      envHandle,\n      runtimeModule->getCodeBlockMayAllocate(funcIndex));\n}\n\nCallResult<PseudoHandle<JSGenerator>> Interpreter::createGenerator_RJS(\n    Runtime *runtime,\n    RuntimeModule *runtimeModule,\n    unsigned funcIndex,\n    Handle<Environment> envHandle,\n    NativeArgs args) {\n  auto gifRes = GeneratorInnerFunction::create(\n      runtime,\n      runtimeModule->getDomain(runtime),\n      Handle<JSObject>::vmcast(&runtime->functionPrototype),\n      envHandle,\n      runtimeModule->getCodeBlockMayAllocate(funcIndex),\n      args);\n  if (LLVM_UNLIKELY(gifRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  auto generatorFunction = runtime->makeHandle(vmcast<JSGeneratorFunction>(\n      runtime->getCurrentFrame().getCalleeClosure()));\n\n  auto prototypeProp = JSObject::getNamed_RJS(\n      generatorFunction,\n      runtime,\n      Predefined::getSymbolID(Predefined::prototype));\n  if (LLVM_UNLIKELY(prototypeProp == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<JSObject> prototype = vmisa<JSObject>(prototypeProp->get())\n      ? runtime->makeHandle<JSObject>(prototypeProp->get())\n      : Handle<JSObject>::vmcast(&runtime->generatorPrototype);\n\n  return JSGenerator::create(runtime, *gifRes, prototype);\n}\n\nCallResult<Handle<Arguments>> Interpreter::reifyArgumentsSlowPath(\n    Runtime *runtime,\n    Handle<Callable> curFunction,\n    bool strictMode) {\n  auto frame = runtime->getCurrentFrame();\n  uint32_t argCount = frame.getArgCount();\n  // Define each JavaScript argument.\n  auto argRes = Arguments::create(runtime, argCount, curFunction, strictMode);\n  if (LLVM_UNLIKELY(argRes == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  Handle<Arguments> args = *argRes;\n\n  for (uint32_t argIndex = 0; argIndex < argCount; ++argIndex) {\n    Arguments::unsafeSetExistingElementAt(\n        *args, runtime, argIndex, frame.getArgRef(argIndex));\n  }\n\n  // The returned value should already be set from the create call.\n  return args;\n}\n\nCallResult<PseudoHandle<>> Interpreter::getArgumentsPropByValSlowPath_RJS(\n    Runtime *runtime,\n    PinnedHermesValue *lazyReg,\n    PinnedHermesValue *valueReg,\n    Handle<Callable> curFunction,\n    bool strictMode) {\n  auto frame = runtime->getCurrentFrame();\n\n  // If the arguments object has already been created.\n  if (!lazyReg->isUndefined()) {\n    // The arguments object has been created, so this is a regular property\n    // get.\n    assert(lazyReg->isObject() && \"arguments lazy register is not an object\");\n\n    return JSObject::getComputed_RJS(\n        Handle<JSObject>::vmcast(lazyReg), runtime, Handle<>(valueReg));\n  }\n\n  if (!valueReg->isSymbol()) {\n    // Attempt a fast path in the case that the key is not a symbol.\n    // If it is a symbol, force reification for now.\n    // Convert the value to a string.\n    auto strRes = toString_RJS(runtime, Handle<>(valueReg));\n    if (strRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    auto strPrim = runtime->makeHandle(std::move(*strRes));\n\n    // Check if the string is a valid argument index.\n    if (auto index = toArrayIndex(runtime, strPrim)) {\n      if (*index < frame.getArgCount()) {\n        return createPseudoHandle(frame.getArgRef(*index));\n      }\n\n      auto objectPrototype =\n          Handle<JSObject>::vmcast(&runtime->objectPrototype);\n\n      // OK, they are requesting an index that either doesn't exist or is\n      // somewhere up in the prototype chain. Since we want to avoid reifying,\n      // check which it is:\n      MutableHandle<JSObject> inObject{runtime};\n      ComputedPropertyDescriptor desc;\n      JSObject::getComputedPrimitiveDescriptor(\n          objectPrototype, runtime, strPrim, inObject, desc);\n\n      // If we couldn't find the property, just return 'undefined'.\n      if (!inObject)\n        return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n      // If the property isn't an accessor, we can just return it without\n      // reifying.\n      if (!desc.flags.accessor) {\n        return createPseudoHandle(\n            JSObject::getComputedSlotValue(inObject.get(), runtime, desc));\n      }\n    }\n\n    // Are they requesting \"arguments.length\"?\n    if (runtime->symbolEqualsToStringPrim(\n            Predefined::getSymbolID(Predefined::length), *strPrim)) {\n      return createPseudoHandle(\n          HermesValue::encodeDoubleValue(frame.getArgCount()));\n    }\n  }\n\n  // Looking for an accessor or a property that needs reification.\n  auto argRes = reifyArgumentsSlowPath(runtime, curFunction, strictMode);\n  if (argRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n\n  // Update the register with the reified value.\n  *lazyReg = argRes->getHermesValue();\n\n  // For simplicity, call ourselves again.\n  return getArgumentsPropByValSlowPath_RJS(\n      runtime, lazyReg, valueReg, curFunction, strictMode);\n}\n\nExecutionStatus Interpreter::handleGetPNameList(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  if (O2REG(GetPNameList).isUndefined() || O2REG(GetPNameList).isNull()) {\n    // Set the iterator to be undefined value.\n    O1REG(GetPNameList) = HermesValue::encodeUndefinedValue();\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Convert to object and store it back to the register.\n  auto res = toObject(runtime, Handle<>(&O2REG(GetPNameList)));\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  O2REG(GetPNameList) = res.getValue();\n\n  auto obj = runtime->makeMutableHandle(vmcast<JSObject>(res.getValue()));\n  uint32_t beginIndex;\n  uint32_t endIndex;\n  auto cr = getForInPropertyNames(runtime, obj, beginIndex, endIndex);\n  if (cr == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto arr = *cr;\n  O1REG(GetPNameList) = arr.getHermesValue();\n  O3REG(GetPNameList) = HermesValue::encodeNumberValue(beginIndex);\n  O4REG(GetPNameList) = HermesValue::encodeNumberValue(endIndex);\n  return ExecutionStatus::RETURNED;\n}\n\nCallResult<PseudoHandle<>> Interpreter::handleCallSlowPath(\n    Runtime *runtime,\n    PinnedHermesValue *callTarget) {\n  if (auto *native = dyn_vmcast<NativeFunction>(*callTarget)) {\n    ++NumNativeFunctionCalls;\n    // Call the native function directly\n    return NativeFunction::_nativeCall(native, runtime);\n  } else if (auto *bound = dyn_vmcast<BoundFunction>(*callTarget)) {\n    ++NumBoundFunctionCalls;\n    // Call the bound function.\n    return BoundFunction::_boundCall(bound, runtime->getCurrentIP(), runtime);\n  } else {\n    return runtime->raiseTypeErrorForValue(\n        Handle<>(callTarget), \" is not a function\");\n  }\n}\n\ninline PseudoHandle<> Interpreter::tryGetPrimitiveOwnPropertyById(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id) {\n  if (base->isString() && id == Predefined::getSymbolID(Predefined::length)) {\n    return createPseudoHandle(\n        HermesValue::encodeNumberValue(base->getString()->getStringLength()));\n  }\n  return createPseudoHandle(HermesValue::encodeEmptyValue());\n}\n\nCallResult<PseudoHandle<>> Interpreter::getByIdTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id) {\n  // This is similar to what ES5.1 8.7.1 special [[Get]] internal\n  // method did, but that section doesn't exist in ES9 anymore.\n  // Instead, the [[Get]] Receiver argument serves a similar purpose.\n\n  // Fast path: try to get primitive own property directly first.\n  PseudoHandle<> valOpt = tryGetPrimitiveOwnPropertyById(runtime, base, id);\n  if (!valOpt->isEmpty()) {\n    return valOpt;\n  }\n\n  // get the property descriptor from primitive prototype without\n  // boxing with vm::toObject().  This is where any properties will\n  // be.\n  CallResult<Handle<JSObject>> primitivePrototypeResult =\n      getPrimitivePrototype(runtime, base);\n  if (primitivePrototypeResult == ExecutionStatus::EXCEPTION) {\n    // If an exception is thrown, likely we are trying to read property on\n    // undefined/null. Passing over the name of the property\n    // so that we could emit more meaningful error messages.\n    return amendPropAccessErrorMsgWithPropName(runtime, base, \"read\", id);\n  }\n\n  return JSObject::getNamedWithReceiver_RJS(\n      *primitivePrototypeResult, runtime, id, base);\n}\n\nPseudoHandle<> Interpreter::getByValTransientFast(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> nameHandle) {\n  if (base->isString()) {\n    // Handle most common fast path -- array index property for string\n    // primitive.\n    // Since primitive string cannot have index like property we can\n    // skip ObjectFlags::fastIndexProperties checking and directly\n    // checking index storage from StringPrimitive.\n\n    OptValue<uint32_t> arrayIndex = toArrayIndexFastPath(*nameHandle);\n    // Get character directly from primitive if arrayIndex is within range.\n    // Otherwise we need to fall back to prototype lookup.\n    if (arrayIndex &&\n        arrayIndex.getValue() < base->getString()->getStringLength()) {\n      return createPseudoHandle(\n          runtime\n              ->getCharacterString(base->getString()->at(arrayIndex.getValue()))\n              .getHermesValue());\n    }\n  }\n  return createPseudoHandle(HermesValue::encodeEmptyValue());\n}\n\nCallResult<PseudoHandle<>> Interpreter::getByValTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> name) {\n  // This is similar to what ES5.1 8.7.1 special [[Get]] internal\n  // method did, but that section doesn't exist in ES9 anymore.\n  // Instead, the [[Get]] Receiver argument serves a similar purpose.\n\n  // Optimization: check fast path first.\n  PseudoHandle<> fastRes = getByValTransientFast(runtime, base, name);\n  if (!fastRes->isEmpty()) {\n    return fastRes;\n  }\n\n  auto res = toObject(runtime, base);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n    return ExecutionStatus::EXCEPTION;\n\n  return JSObject::getComputedWithReceiver_RJS(\n      runtime->makeHandle<JSObject>(res.getValue()), runtime, name, base);\n}\n\nstatic ExecutionStatus\ntransientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  // Emit an error message that looks like:\n  // \"Cannot create property '%{id}' on ${typeof base} '${String(base)}'\".\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    // Special workaround for Symbol which can't be stringified.\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n\n  SmallU16String<32> tmp1;\n  SmallU16String<32> tmp2;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp1) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp2) + \"'\");\n}\n\nExecutionStatus Interpreter::putByIdTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    SymbolID id,\n    Handle<> value,\n    bool strictMode) {\n  // ES5.1 8.7.2 special [[Get]] internal method.\n  // TODO: avoid boxing primitives unless we are calling an accessor.\n\n  // 1. Let O be ToObject(base)\n  auto res = toObject(runtime, base);\n  if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n    // If an exception is thrown, likely we are trying to convert\n    // undefined/null to an object. Passing over the name of the property\n    // so that we could emit more meaningful error messages.\n    return amendPropAccessErrorMsgWithPropName(runtime, base, \"set\", id);\n  }\n\n  auto O = runtime->makeHandle<JSObject>(res.getValue());\n\n  NamedPropertyDescriptor desc;\n  JSObject *propObj = JSObject::getNamedDescriptor(O, runtime, id, desc);\n\n  // Is this a missing property, or a data property defined in the prototype\n  // chain? In both cases we would need to create an own property on the\n  // transient object, which is prohibited.\n  if (!propObj ||\n      (propObj != O.get() &&\n       (!desc.flags.accessor && !desc.flags.proxyObject))) {\n    if (strictMode) {\n      return transientObjectPutErrorMessage(runtime, base, id);\n    }\n    return ExecutionStatus::RETURNED;\n  }\n\n  // Modifying an own data property in a transient object is prohibited.\n  if (!desc.flags.accessor && !desc.flags.proxyObject) {\n    if (strictMode) {\n      return runtime->raiseTypeError(\n          \"Cannot modify a property in a transient object\");\n    }\n    return ExecutionStatus::RETURNED;\n  }\n\n  if (desc.flags.accessor) {\n    // This is an accessor.\n    auto *accessor = vmcast<PropertyAccessor>(\n        JSObject::getNamedSlotValue(propObj, runtime, desc));\n\n    // It needs to have a setter.\n    if (!accessor->setter) {\n      if (strictMode) {\n        return runtime->raiseTypeError(\"Cannot modify a read-only accessor\");\n      }\n      return ExecutionStatus::RETURNED;\n    }\n\n    CallResult<PseudoHandle<>> setRes =\n        accessor->setter.get(runtime)->executeCall1(\n            runtime->makeHandle(accessor->setter), runtime, base, *value);\n    if (setRes == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<bool> setRes = JSProxy::setNamed(\n        runtime->makeHandle(propObj), runtime, id, value, base);\n    if (setRes == ExecutionStatus::EXCEPTION) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    if (!*setRes && strictMode) {\n      return runtime->raiseTypeError(\"transient proxy set returned false\");\n    }\n  }\n  return ExecutionStatus::RETURNED;\n}\n\nExecutionStatus Interpreter::putByValTransient_RJS(\n    Runtime *runtime,\n    Handle<> base,\n    Handle<> name,\n    Handle<> value,\n    bool strictMode) {\n  auto idRes = valueToSymbolID(runtime, name);\n  if (idRes == ExecutionStatus::EXCEPTION)\n    return ExecutionStatus::EXCEPTION;\n\n  return putByIdTransient_RJS(runtime, base, **idRes, value, strictMode);\n}\n\nCallResult<PseudoHandle<>> Interpreter::createObjectFromBuffer(\n    Runtime *runtime,\n    CodeBlock *curCodeBlock,\n    unsigned numLiterals,\n    unsigned keyBufferIndex,\n    unsigned valBufferIndex) {\n  // Fetch any cached hidden class first.\n  auto *runtimeModule = curCodeBlock->getRuntimeModule();\n  const llvh::Optional<Handle<HiddenClass>> optCachedHiddenClassHandle =\n      runtimeModule->findCachedLiteralHiddenClass(\n          runtime, keyBufferIndex, numLiterals);\n  // Create a new object using the built-in constructor or cached hidden class.\n  // Note that the built-in constructor is empty, so we don't actually need to\n  // call it.\n  auto obj = runtime->makeHandle(\n      optCachedHiddenClassHandle.hasValue()\n          ? JSObject::create(runtime, optCachedHiddenClassHandle.getValue())\n          : JSObject::create(runtime, numLiterals));\n\n  MutableHandle<> tmpHandleKey(runtime);\n  MutableHandle<> tmpHandleVal(runtime);\n  auto &gcScope = *runtime->getTopGCScope();\n  auto marker = gcScope.createMarker();\n\n  auto genPair = curCodeBlock->getObjectBufferIter(\n      keyBufferIndex, valBufferIndex, numLiterals);\n  auto keyGen = genPair.first;\n  auto valGen = genPair.second;\n\n  if (optCachedHiddenClassHandle.hasValue()) {\n    uint32_t propIndex = 0;\n    // keyGen should always have the same amount of elements as valGen\n    while (valGen.hasNext()) {\n#ifndef NDEBUG\n      {\n        // keyGen points to an element in the key buffer, which means it will\n        // only ever generate a Number or a Symbol. This means it will never\n        // allocate memory, and it is safe to not use a Handle.\n        SymbolID stringIdResult{};\n        auto key = keyGen.get(runtime);\n        if (key.isSymbol()) {\n          stringIdResult = ID(key.getSymbol().unsafeGetIndex());\n        } else {\n          tmpHandleKey = HermesValue::encodeDoubleValue(key.getNumber());\n          auto idRes = valueToSymbolID(runtime, tmpHandleKey);\n          assert(\n              idRes != ExecutionStatus::EXCEPTION &&\n              \"valueToIdentifier() failed for uint32_t value\");\n          stringIdResult = **idRes;\n        }\n        NamedPropertyDescriptor desc;\n        auto pos = HiddenClass::findProperty(\n            optCachedHiddenClassHandle.getValue(),\n            runtime,\n            stringIdResult,\n            PropertyFlags::defaultNewNamedPropertyFlags(),\n            desc);\n        assert(\n            pos &&\n            \"Should find this property in cached hidden class property table.\");\n        assert(\n            desc.slot == propIndex &&\n            \"propIndex should be the same as recorded in hidden class table.\");\n      }\n#endif\n      // Explicitly make sure valGen.get() is called before obj.get() so that\n      // any allocation in valGen.get() won't invalidate the raw pointer\n      // retruned from obj.get().\n      auto val = valGen.get(runtime);\n      JSObject::setNamedSlotValue(obj.get(), runtime, propIndex, val);\n      gcScope.flushToMarker(marker);\n      ++propIndex;\n    }\n  } else {\n    // keyGen should always have the same amount of elements as valGen\n    while (keyGen.hasNext()) {\n      // keyGen points to an element in the key buffer, which means it will\n      // only ever generate a Number or a Symbol. This means it will never\n      // allocate memory, and it is safe to not use a Handle.\n      auto key = keyGen.get(runtime);\n      tmpHandleVal = valGen.get(runtime);\n      if (key.isSymbol()) {\n        auto stringIdResult = ID(key.getSymbol().unsafeGetIndex());\n        if (LLVM_UNLIKELY(\n                JSObject::defineNewOwnProperty(\n                    obj,\n                    runtime,\n                    stringIdResult,\n                    PropertyFlags::defaultNewNamedPropertyFlags(),\n                    tmpHandleVal) == ExecutionStatus::EXCEPTION)) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      } else {\n        tmpHandleKey = HermesValue::encodeDoubleValue(key.getNumber());\n        if (LLVM_UNLIKELY(\n                !JSObject::defineOwnComputedPrimitive(\n                     obj,\n                     runtime,\n                     tmpHandleKey,\n                     DefinePropertyFlags::getDefaultNewPropertyFlags(),\n                     tmpHandleVal)\n                     .getValue())) {\n          return ExecutionStatus::EXCEPTION;\n        }\n      }\n      gcScope.flushToMarker(marker);\n    }\n  }\n  tmpHandleKey.clear();\n  tmpHandleVal.clear();\n\n  // Hidden class in dictionary mode can't be shared.\n  HiddenClass *const clazz = obj->getClass(runtime);\n  if (!optCachedHiddenClassHandle.hasValue() && !clazz->isDictionary()) {\n    assert(\n        numLiterals == clazz->getNumProperties() &&\n        \"numLiterals should match hidden class property count.\");\n    assert(\n        clazz->getNumProperties() < 256 &&\n        \"cached hidden class should have property count less than 256\");\n    runtimeModule->tryCacheLiteralHiddenClass(runtime, keyBufferIndex, clazz);\n  }\n\n  return createPseudoHandle(HermesValue::encodeObjectValue(*obj));\n}\n\nCallResult<PseudoHandle<>> Interpreter::createArrayFromBuffer(\n    Runtime *runtime,\n    CodeBlock *curCodeBlock,\n    unsigned numElements,\n    unsigned numLiterals,\n    unsigned bufferIndex) {\n  // Create a new array using the built-in constructor, and initialize\n  // the elements from a literal array buffer.\n  auto arrRes = JSArray::create(runtime, numElements, numElements);\n  if (arrRes == ExecutionStatus::EXCEPTION) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  // Resize the array storage in advance.\n  auto arr = runtime->makeHandle(std::move(*arrRes));\n  JSArray::setStorageEndIndex(arr, runtime, numElements);\n\n  auto iter = curCodeBlock->getArrayBufferIter(bufferIndex, numLiterals);\n  JSArray::size_type i = 0;\n  while (iter.hasNext()) {\n    // NOTE: we must get the value in a separate step to guarantee ordering.\n    auto value = iter.get(runtime);\n    JSArray::unsafeSetExistingElementAt(*arr, runtime, i++, value);\n  }\n\n  return createPseudoHandle(HermesValue::encodeObjectValue(*arr));\n}\n\n#ifndef NDEBUG\nnamespace {\n/// A tag used to instruct the output stream to dump more details about the\n/// HermesValue, like the length of the string, etc.\nstruct DumpHermesValue {\n  const HermesValue hv;\n  DumpHermesValue(HermesValue hv) : hv(hv) {}\n};\n\n} // anonymous namespace.\n\nstatic llvh::raw_ostream &operator<<(\n    llvh::raw_ostream &OS,\n    DumpHermesValue dhv) {\n  OS << dhv.hv;\n  // If it is a string, dump the contents, truncated to 8 characters.\n  if (dhv.hv.isString()) {\n    SmallU16String<32> str;\n    dhv.hv.getString()->appendUTF16String(str);\n    UTF16Ref ref = str.arrayRef();\n    if (str.size() <= 8) {\n      OS << \":'\" << ref << \"'\";\n    } else {\n      OS << \":'\" << ref.slice(0, 8) << \"'\";\n      OS << \"...[\" << str.size() << \"]\";\n    }\n  }\n  return OS;\n}\n\n/// Dump the arguments from a callee frame.\nLLVM_ATTRIBUTE_UNUSED\nstatic void dumpCallArguments(\n    llvh::raw_ostream &OS,\n    Runtime *runtime,\n    StackFramePtr calleeFrame) {\n  OS << \"arguments:\\n\";\n  OS << \"  \" << 0 << \" \" << DumpHermesValue(calleeFrame.getThisArgRef())\n     << \"\\n\";\n  for (unsigned i = 0; i < calleeFrame.getArgCount(); ++i) {\n    OS << \"  \" << (i + 1) << \" \" << DumpHermesValue(calleeFrame.getArgRef(i))\n       << \"\\n\";\n  }\n}\n\nLLVM_ATTRIBUTE_UNUSED\nstatic void printDebugInfo(\n    CodeBlock *curCodeBlock,\n    PinnedHermesValue *frameRegs,\n    const Inst *ip) {\n  // Check if LLVm debugging is enabled for us.\n  bool debug = false;\n  SLOW_DEBUG(debug = true);\n  if (!debug)\n    return;\n\n  DecodedInstruction decoded = decodeInstruction(ip);\n\n  dbgs() << llvh::format_decimal((const uint8_t *)ip - curCodeBlock->begin(), 4)\n         << \" OpCode::\" << getOpCodeString(decoded.meta.opCode);\n\n  for (unsigned i = 0; i < decoded.meta.numOperands; ++i) {\n    auto operandType = decoded.meta.operandType[i];\n    auto value = decoded.operandValue[i];\n\n    dbgs() << (i == 0 ? \" \" : \", \");\n    dumpOperand(dbgs(), operandType, value);\n\n    if (operandType == OperandType::Reg8 || operandType == OperandType::Reg32) {\n      // Print the register value, if source.\n      if (i != 0 || decoded.meta.numOperands == 1)\n        dbgs() << \"=\" << DumpHermesValue(REG(value.integer));\n    }\n  }\n\n  dbgs() << \"\\n\";\n}\n\n/// \\return whether \\p opcode is a call opcode (Call, CallDirect, Construct,\n/// CallLongIndex, etc). Note CallBuiltin is not really a Call.\nLLVM_ATTRIBUTE_UNUSED\nstatic bool isCallType(OpCode opcode) {\n  switch (opcode) {\n#define DEFINE_RET_TARGET(name) \\\n  case OpCode::name:            \\\n    return true;\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n    default:\n      return false;\n  }\n}\n\n#endif\n\n/// \\return the address of the next instruction after \\p ip, which must be a\n/// call-type instruction.\nLLVM_ATTRIBUTE_ALWAYS_INLINE\nstatic inline const Inst *nextInstCall(const Inst *ip) {\n  HERMES_SLOW_ASSERT(isCallType(ip->opCode) && \"ip is not of call type\");\n\n  // The following is written to elicit compares instead of table lookup.\n  // The idea is to present code like so:\n  //   if (opcode <= 70) return ip + 4;\n  //   if (opcode <= 71) return ip + 4;\n  //   if (opcode <= 72) return ip + 4;\n  //   if (opcode <= 73) return ip + 5;\n  //   if (opcode <= 74) return ip + 5;\n  //   ...\n  // and the compiler will retain only compares where the result changes (here,\n  // 72 and 74). This allows us to compute the next instruction using three\n  // compares, instead of a naive compare-per-call type (or lookup table).\n  //\n  // Statically verify that increasing call opcodes correspond to monotone\n  // instruction sizes; this enables the compiler to do a better job optimizing.\n  constexpr bool callSizesMonotoneIncreasing = monotoneIncreasing(\n#define DEFINE_RET_TARGET(name) sizeof(inst::name##Inst),\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n      SIZE_MAX // sentinel avoiding a trailing comma.\n  );\n  static_assert(\n      callSizesMonotoneIncreasing,\n      \"Call instruction sizes are not monotone increasing\");\n\n#define DEFINE_RET_TARGET(name)   \\\n  if (ip->opCode <= OpCode::name) \\\n    return NEXTINST(name);\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n  llvm_unreachable(\"Not a call type\");\n}\n\nCallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(this);\n\n#if defined(HERMES_ENABLE_ALLOCATION_LOCATION_TRACES) || !defined(NDEBUG)\n  // We always call getCurrentIP() in a debug build as this has the effect\n  // of asserting the IP is correctly set (not invalidated) at this point.\n  // This allows us to leverage our whole test-suite to find missing cases\n  // of CAPTURE_IP* macros in the interpreter loop.\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    // All functions end in a Ret so we must match this with a pushCallStack()\n    // before executing.\n    if (codeBlock) {\n      // Push a call entry at the last location we were executing bytecode.\n      // This will correctly attribute things like eval().\n      pushCallStack(codeBlock, ip);\n    } else {\n      // Push a call entry at the entry at the top of interpreted code.\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    // Push a call entry at the entry at the top of interpreted code.\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n\n  InterpreterState state{newCodeBlock, 0};\n  return Interpreter::interpretFunction<false>(this, state);\n}\n\nCallResult<HermesValue> Runtime::interpretFunction(CodeBlock *newCodeBlock) {\n#ifdef HERMESVM_PROFILER_EXTERN\n  auto id = getProfilerID(newCodeBlock);\n  if (id >= NUM_PROFILER_SYMBOLS) {\n    id = NUM_PROFILER_SYMBOLS - 1; // Overflow entry.\n  }\n  return interpWrappers[id](this, newCodeBlock);\n#else\n  return interpretFunctionImpl(newCodeBlock);\n#endif\n}\n\n#ifdef HERMES_ENABLE_DEBUGGER\nExecutionStatus Runtime::stepFunction(InterpreterState &state) {\n  return Interpreter::interpretFunction<true>(this, state).getStatus();\n}\n#endif\n\n/// \\return the quotient of x divided by y.\nstatic double doDiv(double x, double y)\n    LLVM_NO_SANITIZE(\"float-divide-by-zero\");\nstatic inline double doDiv(double x, double y) {\n  // UBSan will complain about float divide by zero as our implementation\n  // of OpCode::Div depends on IEEE 754 float divide by zero. All modern\n  // compilers implement this and there is no trivial work-around without\n  // sacrificing performance and readability.\n  // NOTE: This was pulled out of the interpreter to avoid putting the sanitize\n  // silencer on the entire interpreter function.\n  return x / y;\n}\n\n/// \\return the product of x multiplied by y.\nstatic inline double doMult(double x, double y) {\n  return x * y;\n}\n\n/// \\return the difference of y subtracted from x.\nstatic inline double doSub(double x, double y) {\n  return x - y;\n}\n\ntemplate <bool SingleStep>\nCallResult<HermesValue> Interpreter::interpretFunction(\n    Runtime *runtime,\n    InterpreterState &state) {\n  // The interepter is re-entrant and also saves/restores its IP via the runtime\n  // whenever a call out is made (see the CAPTURE_IP_* macros). As such, failure\n  // to preserve the IP across calls to interpeterFunction() disrupt interpreter\n  // calls further up the C++ callstack. The RAII utility class below makes sure\n  // we always do this correctly.\n  //\n  // TODO: The IPs stored in the C++ callstack via this holder will generally be\n  // the same as in the JS stack frames via the Saved IP field. We can probably\n  // get rid of one of these redundant stores. Doing this isn't completely\n  // trivial as there are currently cases where we re-enter the interpreter\n  // without calling Runtime::saveCallerIPInStackFrame(), and there are features\n  // (I think mostly the debugger + stack traces) which implicitly rely on\n  // this behavior. At least their tests break if this behavior is not\n  // preserved.\n  struct IPSaver {\n    IPSaver(Runtime *runtime)\n        : ip_(runtime->getCurrentIP()), runtime_(runtime) {}\n\n    ~IPSaver() {\n      runtime_->setCurrentIP(ip_);\n    }\n\n   private:\n    const Inst *ip_;\n    Runtime *runtime_;\n  };\n  IPSaver ipSaver(runtime);\n\n#ifndef HERMES_ENABLE_DEBUGGER\n  static_assert(!SingleStep, \"can't use single-step mode without the debugger\");\n#endif\n  // Make sure that the cache can use an optimization by avoiding a branch to\n  // access the property storage.\n  static_assert(\n      HiddenClass::kDictionaryThreshold <=\n          SegmentedArray::kValueToSegmentThreshold,\n      \"Cannot avoid branches in cache check if the dictionary \"\n      \"crossover point is larger than the inline storage\");\n\n  CodeBlock *curCodeBlock = state.codeBlock;\n  const Inst *ip = nullptr;\n  // Holds runtime->currentFrame_.ptr()-1 which is the first local\n  // register. This eliminates the indirect load from Runtime and the -1 offset.\n  PinnedHermesValue *frameRegs;\n  // Strictness of current function.\n  bool strictMode;\n  // Default flags when accessing properties.\n  PropOpFlags defaultPropOpFlags;\n\n// These CAPTURE_IP* macros should wrap around any major calls out of the\n// interpeter loop. They stash and retrieve the IP via the current Runtime\n// allowing the IP to be externally observed and even altered to change the flow\n// of execution. Explicitly saving AND restoring the IP from the Runtime in this\n// way means the C++ compiler will keep IP in a register within the rest of the\n// interpeter loop.\n//\n// When assertions are enabled we take the extra step of \"invalidating\" the IP\n// between captures so we can detect if it's erroneously accessed.\n//\n// In some cases we explicitly don't want to invalidate the IP and instead want\n// it to stay set. For this we use the *NO_INVALIDATE variants. This comes up\n// when we're performing a call operation which may re-enter the interpeter\n// loop, and so need the IP available for the saveCallerIPInStackFrame() call\n// when we next enter.\n#define CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr) \\\n  runtime->setCurrentIP(ip);                       \\\n  dst = expr;                                      \\\n  ip = runtime->getCurrentIP();\n\n#ifdef NDEBUG\n\n#define CAPTURE_IP(expr)     \\\n  runtime->setCurrentIP(ip); \\\n  (void)expr;                \\\n  ip = runtime->getCurrentIP();\n\n#define CAPTURE_IP_ASSIGN(dst, expr) CAPTURE_IP_ASSIGN_NO_INVALIDATE(dst, expr)\n\n#else // !NDEBUG\n\n#define CAPTURE_IP(expr)        \\\n  runtime->setCurrentIP(ip);    \\\n  (void)expr;                   \\\n  ip = runtime->getCurrentIP(); \\\n  runtime->invalidateCurrentIP();\n\n#define CAPTURE_IP_ASSIGN(dst, expr) \\\n  runtime->setCurrentIP(ip);         \\\n  dst = expr;                        \\\n  ip = runtime->getCurrentIP();      \\\n  runtime->invalidateCurrentIP();\n\n#endif // NDEBUG\n\n/// \\def DONT_CAPTURE_IP(expr)\n/// \\param expr A call expression to a function external to the interpreter. The\n///   expression should not make any allocations and the IP should be set\n///   immediately following this macro.\n#define DONT_CAPTURE_IP(expr)      \\\n  do {                             \\\n    NoAllocScope noAlloc(runtime); \\\n    (void)expr;                    \\\n  } while (false)\n\n  LLVM_DEBUG(dbgs() << \"interpretFunction() called\\n\");\n\n  ScopedNativeDepthTracker depthTracker{runtime};\n  if (LLVM_UNLIKELY(depthTracker.overflowed())) {\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  }\n\n  if (!SingleStep) {\n    if (auto jitPtr = runtime->jitContext_.compile(runtime, curCodeBlock)) {\n      return (*jitPtr)(runtime);\n    }\n  }\n\n  GCScope gcScope(runtime);\n  // Avoid allocating a handle dynamically by reusing this one.\n  MutableHandle<> tmpHandle(runtime);\n  CallResult<HermesValue> res{ExecutionStatus::EXCEPTION};\n  CallResult<PseudoHandle<>> resPH{ExecutionStatus::EXCEPTION};\n  CallResult<Handle<Arguments>> resArgs{ExecutionStatus::EXCEPTION};\n  CallResult<bool> boolRes{ExecutionStatus::EXCEPTION};\n\n  // Mark the gcScope so we can clear all allocated handles.\n  // Remember how many handles the scope has so we can clear them in the loop.\n  static constexpr unsigned KEEP_HANDLES = 1;\n  assert(\n      gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n      \"scope has unexpected number of handles\");\n\n  INIT_OPCODE_PROFILER;\n\n#if !defined(HERMESVM_PROFILER_EXTERN)\ntailCall:\n#endif\n  PROFILER_ENTER_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_DEBUGGER\n  runtime->getDebugger().willEnterCodeBlock(curCodeBlock);\n#endif\n\n  runtime->getCodeCoverageProfiler().markExecuted(runtime, curCodeBlock);\n\n  // Update function executionCount_ count\n  curCodeBlock->incrementExecutionCount();\n\n  if (!SingleStep) {\n    auto newFrame = runtime->setCurrentFrameToTopOfStack();\n    runtime->saveCallerIPInStackFrame();\n#ifndef NDEBUG\n    runtime->invalidateCurrentIP();\n#endif\n\n    // Point frameRegs to the first register in the new frame. Note that at this\n    // moment technically it points above the top of the stack, but we are never\n    // going to access it.\n    frameRegs = &newFrame.getFirstLocalRef();\n\n#ifndef NDEBUG\n    LLVM_DEBUG(\n        dbgs() << \"function entry: stackLevel=\" << runtime->getStackLevel()\n               << \", argCount=\" << runtime->getCurrentFrame().getArgCount()\n               << \", frameSize=\" << curCodeBlock->getFrameSize() << \"\\n\");\n\n    LLVM_DEBUG(\n        dbgs() << \" callee \"\n               << DumpHermesValue(\n                      runtime->getCurrentFrame().getCalleeClosureOrCBRef())\n               << \"\\n\");\n    LLVM_DEBUG(\n        dbgs() << \"   this \"\n               << DumpHermesValue(runtime->getCurrentFrame().getThisArgRef())\n               << \"\\n\");\n    for (uint32_t i = 0; i != runtime->getCurrentFrame()->getArgCount(); ++i) {\n      LLVM_DEBUG(\n          dbgs() << \"   \" << llvh::format_decimal(i, 4) << \" \"\n                 << DumpHermesValue(runtime->getCurrentFrame().getArgRef(i))\n                 << \"\\n\");\n    }\n#endif\n\n    // Allocate the registers for the new frame.\n    if (LLVM_UNLIKELY(!runtime->checkAndAllocStack(\n            curCodeBlock->getFrameSize() +\n                StackFrameLayout::CalleeExtraRegistersAtStart,\n            HermesValue::encodeUndefinedValue())))\n      goto stackOverflow;\n\n    ip = (Inst const *)curCodeBlock->begin();\n\n    // Check for invalid invocation.\n    if (LLVM_UNLIKELY(curCodeBlock->getHeaderFlags().isCallProhibited(\n            newFrame.isConstructorCall()))) {\n      if (!newFrame.isConstructorCall()) {\n        CAPTURE_IP(\n            runtime->raiseTypeError(\"Class constructor invoked without new\"));\n      } else {\n        CAPTURE_IP(runtime->raiseTypeError(\"Function is not a constructor\"));\n      }\n      goto handleExceptionInParent;\n    }\n  } else {\n    // Point frameRegs to the first register in the frame.\n    frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n    ip = (Inst const *)(curCodeBlock->begin() + state.offset);\n  }\n\n  assert((const uint8_t *)ip < curCodeBlock->end() && \"CodeBlock is empty\");\n\n  INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n\n#define BEFORE_OP_CODE                                                       \\\n  {                                                                          \\\n    UPDATE_OPCODE_TIME_SPENT;                                                \\\n    HERMES_SLOW_ASSERT(                                                      \\\n        curCodeBlock->contains(ip) && \"curCodeBlock must contain ip\");       \\\n    HERMES_SLOW_ASSERT((printDebugInfo(curCodeBlock, frameRegs, ip), true)); \\\n    HERMES_SLOW_ASSERT(                                                      \\\n        gcScope.getHandleCountDbg() == KEEP_HANDLES &&                       \\\n        \"unaccounted handles were created\");                                 \\\n    HERMES_SLOW_ASSERT(tmpHandle->isUndefined() && \"tmpHandle not cleared\"); \\\n    RECORD_OPCODE_START_TIME;                                                \\\n    INC_OPCODE_COUNT;                                                        \\\n  }\n\n#ifdef HERMESVM_INDIRECT_THREADING\n  static void *opcodeDispatch[] = {\n#define DEFINE_OPCODE(name) &&case_##name,\n#include \"hermes/BCGen/HBC/BytecodeList.def\"\n      &&case__last};\n\n#define CASE(name) case_##name:\n#define DISPATCH                                \\\n  BEFORE_OP_CODE;                               \\\n  if (SingleStep) {                             \\\n    state.codeBlock = curCodeBlock;             \\\n    state.offset = CUROFFSET;                   \\\n    return HermesValue::encodeUndefinedValue(); \\\n  }                                             \\\n  goto *opcodeDispatch[(unsigned)ip->opCode]\n\n#else // HERMESVM_INDIRECT_THREADING\n\n#define CASE(name) case OpCode::name:\n#define DISPATCH                                \\\n  if (SingleStep) {                             \\\n    state.codeBlock = curCodeBlock;             \\\n    state.offset = CUROFFSET;                   \\\n    return HermesValue::encodeUndefinedValue(); \\\n  }                                             \\\n  continue\n\n#endif // HERMESVM_INDIRECT_THREADING\n\n#define RUN_DEBUGGER_ASYNC_BREAK(flags)                                      \\\n  do {                                                                       \\\n    CAPTURE_IP_ASSIGN(                                                       \\\n        auto dRes,                                                           \\\n        runDebuggerUpdatingState(                                            \\\n            (uint8_t)(flags) &                                               \\\n                    (uint8_t)Runtime::AsyncBreakReasonBits::DebuggerExplicit \\\n                ? Debugger::RunReason::AsyncBreakExplicit                    \\\n                : Debugger::RunReason::AsyncBreakImplicit,                   \\\n            runtime,                                                         \\\n            curCodeBlock,                                                    \\\n            ip,                                                              \\\n            frameRegs));                                                     \\\n    if (dRes == ExecutionStatus::EXCEPTION)                                  \\\n      goto exception;                                                        \\\n  } while (0)\n\n  for (;;) {\n    BEFORE_OP_CODE;\n\n#ifdef HERMESVM_INDIRECT_THREADING\n    goto *opcodeDispatch[(unsigned)ip->opCode];\n#else\n    switch (ip->opCode)\n#endif\n    {\n      const Inst *nextIP;\n      uint32_t idVal;\n      bool tryProp;\n      uint32_t callArgCount;\n      // This is HermesValue::getRaw(), since HermesValue cannot be assigned\n      // to. It is meant to be used only for very short durations, in the\n      // dispatch of call instructions, when there is definitely no possibility\n      // of a GC.\n      HermesValue::RawType callNewTarget;\n\n/// Handle an opcode \\p name with an out-of-line implementation in a function\n///   ExecutionStatus caseName(\n///       Runtime *,\n///       PinnedHermesValue *frameRegs,\n///       Inst *ip)\n#define CASE_OUTOFLINE(name)                                         \\\n  CASE(name) {                                                       \\\n    CAPTURE_IP_ASSIGN(auto res, case##name(runtime, frameRegs, ip)); \\\n    if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {          \\\n      goto exception;                                                \\\n    }                                                                \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                         \\\n    ip = NEXTINST(name);                                             \\\n    DISPATCH;                                                        \\\n  }\n\n/// Implement a binary arithmetic instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction. The fast path case will have a\n///     \"n\" appended to the name.\n/// \\param oper the C++ operator to use to actually perform the arithmetic\n///     operation.\n#define BINOP(name, oper)                                                  \\\n  CASE(name) {                                                             \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {   \\\n      /* Fast-path. */                                                     \\\n      CASE(name##N) {                                                      \\\n        O1REG(name) = HermesValue::encodeDoubleValue(                      \\\n            oper(O2REG(name).getNumber(), O3REG(name).getNumber()));       \\\n        ip = NEXTINST(name);                                               \\\n        DISPATCH;                                                          \\\n      }                                                                    \\\n    }                                                                      \\\n    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION)                                 \\\n      goto exception;                                                      \\\n    double left = res->getDouble();                                        \\\n    CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION)                                 \\\n      goto exception;                                                      \\\n    O1REG(name) =                                                          \\\n        HermesValue::encodeDoubleValue(oper(left, res->getDouble()));      \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n    ip = NEXTINST(name);                                                   \\\n    DISPATCH;                                                              \\\n  }\n\n/// Implement a shift instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the shift\n///     operation.\n/// \\param lConv the conversion function for the LHS of the expression.\n/// \\param lType the type of the LHS operand.\n/// \\param returnType the type of the return value.\n#define SHIFTOP(name, oper, lConv, lType, returnType)                      \\\n  CASE(name) {                                                             \\\n    if (LLVM_LIKELY(                                                       \\\n            O2REG(name).isNumber() &&                                      \\\n            O3REG(name).isNumber())) { /* Fast-path. */                    \\\n      auto lnum = static_cast<lType>(                                      \\\n          hermes::truncateToInt32(O2REG(name).getNumber()));               \\\n      auto rnum = static_cast<uint32_t>(                                   \\\n                      hermes::truncateToInt32(O3REG(name).getNumber())) &  \\\n          0x1f;                                                            \\\n      O1REG(name) = HermesValue::encodeDoubleValue(                        \\\n          static_cast<returnType>(lnum oper rnum));                        \\\n      ip = NEXTINST(name);                                                 \\\n      DISPATCH;                                                            \\\n    }                                                                      \\\n    CAPTURE_IP_ASSIGN(res, lConv(runtime, Handle<>(&O2REG(name))));        \\\n    if (res == ExecutionStatus::EXCEPTION) {                               \\\n      goto exception;                                                      \\\n    }                                                                      \\\n    auto lnum = static_cast<lType>(res->getNumber());                      \\\n    CAPTURE_IP_ASSIGN(res, toUInt32_RJS(runtime, Handle<>(&O3REG(name)))); \\\n    if (res == ExecutionStatus::EXCEPTION) {                               \\\n      goto exception;                                                      \\\n    }                                                                      \\\n    auto rnum = static_cast<uint32_t>(res->getNumber()) & 0x1f;            \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                               \\\n    O1REG(name) = HermesValue::encodeDoubleValue(                          \\\n        static_cast<returnType>(lnum oper rnum));                          \\\n    ip = NEXTINST(name);                                                   \\\n    DISPATCH;                                                              \\\n  }\n\n/// Implement a binary bitwise instruction with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the bitwise\n///     operation.\n#define BITWISEBINOP(name, oper)                                               \\\n  CASE(name) {                                                                 \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) {       \\\n      /* Fast-path. */                                                         \\\n      O1REG(name) = HermesValue::encodeDoubleValue(                            \\\n          hermes::truncateToInt32(O2REG(name).getNumber())                     \\\n              oper hermes::truncateToInt32(O3REG(name).getNumber()));          \\\n      ip = NEXTINST(name);                                                     \\\n      DISPATCH;                                                                \\\n    }                                                                          \\\n    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(name))));      \\\n    if (res == ExecutionStatus::EXCEPTION) {                                   \\\n      goto exception;                                                          \\\n    }                                                                          \\\n    int32_t left = res->getNumberAs<int32_t>();                                \\\n    CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O3REG(name))));      \\\n    if (res == ExecutionStatus::EXCEPTION) {                                   \\\n      goto exception;                                                          \\\n    }                                                                          \\\n    O1REG(name) =                                                              \\\n        HermesValue::encodeNumberValue(left oper res->getNumberAs<int32_t>()); \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                                   \\\n    ip = NEXTINST(name);                                                       \\\n    DISPATCH;                                                                  \\\n  }\n\n/// Implement a comparison instruction.\n/// \\param name the name of the instruction.\n/// \\param oper the C++ operator to use to actually perform the fast arithmetic\n///     comparison.\n/// \\param operFuncName  function to call for the slow-path comparison.\n#define CONDOP(name, oper, operFuncName)                                 \\\n  CASE(name) {                                                           \\\n    if (LLVM_LIKELY(O2REG(name).isNumber() && O3REG(name).isNumber())) { \\\n      /* Fast-path. */                                                   \\\n      O1REG(name) = HermesValue::encodeBoolValue(                        \\\n          O2REG(name).getNumber() oper O3REG(name).getNumber());         \\\n      ip = NEXTINST(name);                                               \\\n      DISPATCH;                                                          \\\n    }                                                                    \\\n    CAPTURE_IP_ASSIGN(                                                   \\\n        boolRes,                                                         \\\n        operFuncName(                                                    \\\n            runtime, Handle<>(&O2REG(name)), Handle<>(&O3REG(name))));   \\\n    if (boolRes == ExecutionStatus::EXCEPTION)                           \\\n      goto exception;                                                    \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                             \\\n    O1REG(name) = HermesValue::encodeBoolValue(boolRes.getValue());      \\\n    ip = NEXTINST(name);                                                 \\\n    DISPATCH;                                                            \\\n  }\n\n/// Implement a comparison conditional jump with a fast path where both\n/// operands are numbers.\n/// \\param name the name of the instruction. The fast path case will have a\n///     \"N\" appended to the name.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param oper the C++ operator to use to actually perform the fast arithmetic\n///     comparison.\n/// \\param operFuncName  function to call for the slow-path comparison.\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_IMPL(name, suffix, oper, operFuncName, trueDest, falseDest) \\\n  CASE(name##suffix) {                                                    \\\n    if (LLVM_LIKELY(                                                      \\\n            O2REG(name##suffix).isNumber() &&                             \\\n            O3REG(name##suffix).isNumber())) {                            \\\n      /* Fast-path. */                                                    \\\n      CASE(name##N##suffix) {                                             \\\n        if (O2REG(name##N##suffix)                                        \\\n                .getNumber() oper O3REG(name##N##suffix)                  \\\n                .getNumber()) {                                           \\\n          ip = trueDest;                                                  \\\n          DISPATCH;                                                       \\\n        }                                                                 \\\n        ip = falseDest;                                                   \\\n        DISPATCH;                                                         \\\n      }                                                                   \\\n    }                                                                     \\\n    CAPTURE_IP_ASSIGN(                                                    \\\n        boolRes,                                                          \\\n        operFuncName(                                                     \\\n            runtime,                                                      \\\n            Handle<>(&O2REG(name##suffix)),                               \\\n            Handle<>(&O3REG(name##suffix))));                             \\\n    if (boolRes == ExecutionStatus::EXCEPTION)                            \\\n      goto exception;                                                     \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);                              \\\n    if (boolRes.getValue()) {                                             \\\n      ip = trueDest;                                                      \\\n      DISPATCH;                                                           \\\n    }                                                                     \\\n    ip = falseDest;                                                       \\\n    DISPATCH;                                                             \\\n  }\n\n/// Implement a strict equality conditional jump\n/// \\param name the name of the instruction.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_STRICT_EQ_IMPL(name, suffix, trueDest, falseDest)         \\\n  CASE(name##suffix) {                                                  \\\n    if (strictEqualityTest(O2REG(name##suffix), O3REG(name##suffix))) { \\\n      ip = trueDest;                                                    \\\n      DISPATCH;                                                         \\\n    }                                                                   \\\n    ip = falseDest;                                                     \\\n    DISPATCH;                                                           \\\n  }\n\n/// Implement an equality conditional jump\n/// \\param name the name of the instruction.\n/// \\param suffix  Optional suffix to be added to the end (e.g. Long)\n/// \\param trueDest  ip value if the conditional evaluates to true\n/// \\param falseDest  ip value if the conditional evaluates to false\n#define JCOND_EQ_IMPL(name, suffix, trueDest, falseDest) \\\n  CASE(name##suffix) {                                   \\\n    CAPTURE_IP_ASSIGN(                                   \\\n        res,                                             \\\n        abstractEqualityTest_RJS(                        \\\n            runtime,                                     \\\n            Handle<>(&O2REG(name##suffix)),              \\\n            Handle<>(&O3REG(name##suffix))));            \\\n    if (res == ExecutionStatus::EXCEPTION) {             \\\n      goto exception;                                    \\\n    }                                                    \\\n    gcScope.flushToSmallCount(KEEP_HANDLES);             \\\n    if (res->getBool()) {                                \\\n      ip = trueDest;                                     \\\n      DISPATCH;                                          \\\n    }                                                    \\\n    ip = falseDest;                                      \\\n    DISPATCH;                                            \\\n  }\n\n/// Implement the long and short forms of a conditional jump, and its negation.\n#define JCOND(name, oper, operFuncName) \\\n  JCOND_IMPL(                           \\\n      J##name,                          \\\n      ,                                 \\\n      oper,                             \\\n      operFuncName,                     \\\n      IPADD(ip->iJ##name.op1),          \\\n      NEXTINST(J##name));               \\\n  JCOND_IMPL(                           \\\n      J##name,                          \\\n      Long,                             \\\n      oper,                             \\\n      operFuncName,                     \\\n      IPADD(ip->iJ##name##Long.op1),    \\\n      NEXTINST(J##name##Long));         \\\n  JCOND_IMPL(                           \\\n      JNot##name,                       \\\n      ,                                 \\\n      oper,                             \\\n      operFuncName,                     \\\n      NEXTINST(JNot##name),             \\\n      IPADD(ip->iJNot##name.op1));      \\\n  JCOND_IMPL(                           \\\n      JNot##name,                       \\\n      Long,                             \\\n      oper,                             \\\n      operFuncName,                     \\\n      NEXTINST(JNot##name##Long),       \\\n      IPADD(ip->iJNot##name##Long.op1));\n\n/// Load a constant.\n/// \\param value is the value to store in the output register.\n#define LOAD_CONST(name, value) \\\n  CASE(name) {                  \\\n    O1REG(name) = value;        \\\n    ip = NEXTINST(name);        \\\n    DISPATCH;                   \\\n  }\n\n#define LOAD_CONST_CAPTURE_IP(name, value) \\\n  CASE(name) {                             \\\n    CAPTURE_IP_ASSIGN(O1REG(name), value); \\\n    ip = NEXTINST(name);                   \\\n    DISPATCH;                              \\\n  }\n\n      CASE(Mov) {\n        O1REG(Mov) = O2REG(Mov);\n        ip = NEXTINST(Mov);\n        DISPATCH;\n      }\n\n      CASE(MovLong) {\n        O1REG(MovLong) = O2REG(MovLong);\n        ip = NEXTINST(MovLong);\n        DISPATCH;\n      }\n\n      CASE(LoadParam) {\n        if (LLVM_LIKELY(ip->iLoadParam.op2 <= FRAME.getArgCount())) {\n          // index 0 must load 'this'. Index 1 the first argument, etc.\n          O1REG(LoadParam) = FRAME.getArgRef((int32_t)ip->iLoadParam.op2 - 1);\n          ip = NEXTINST(LoadParam);\n          DISPATCH;\n        }\n        O1REG(LoadParam) = HermesValue::encodeUndefinedValue();\n        ip = NEXTINST(LoadParam);\n        DISPATCH;\n      }\n\n      CASE(LoadParamLong) {\n        if (LLVM_LIKELY(ip->iLoadParamLong.op2 <= FRAME.getArgCount())) {\n          // index 0 must load 'this'. Index 1 the first argument, etc.\n          O1REG(LoadParamLong) =\n              FRAME.getArgRef((int32_t)ip->iLoadParamLong.op2 - 1);\n          ip = NEXTINST(LoadParamLong);\n          DISPATCH;\n        }\n        O1REG(LoadParamLong) = HermesValue::encodeUndefinedValue();\n        ip = NEXTINST(LoadParamLong);\n        DISPATCH;\n      }\n\n      CASE(CoerceThisNS) {\n        if (LLVM_LIKELY(O2REG(CoerceThisNS).isObject())) {\n          O1REG(CoerceThisNS) = O2REG(CoerceThisNS);\n        } else if (\n            O2REG(CoerceThisNS).isNull() || O2REG(CoerceThisNS).isUndefined()) {\n          O1REG(CoerceThisNS) = runtime->global_;\n        } else {\n          tmpHandle = O2REG(CoerceThisNS);\n          nextIP = NEXTINST(CoerceThisNS);\n          goto coerceThisSlowPath;\n        }\n        ip = NEXTINST(CoerceThisNS);\n        DISPATCH;\n      }\n      CASE(LoadThisNS) {\n        if (LLVM_LIKELY(FRAME.getThisArgRef().isObject())) {\n          O1REG(LoadThisNS) = FRAME.getThisArgRef();\n        } else if (\n            FRAME.getThisArgRef().isNull() ||\n            FRAME.getThisArgRef().isUndefined()) {\n          O1REG(LoadThisNS) = runtime->global_;\n        } else {\n          tmpHandle = FRAME.getThisArgRef();\n          nextIP = NEXTINST(LoadThisNS);\n          goto coerceThisSlowPath;\n        }\n        ip = NEXTINST(LoadThisNS);\n        DISPATCH;\n      }\n    coerceThisSlowPath : {\n      CAPTURE_IP_ASSIGN(res, toObject(runtime, tmpHandle));\n      if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      O1REG(CoerceThisNS) = res.getValue();\n      tmpHandle.clear();\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(ConstructLong) {\n        callArgCount = (uint32_t)ip->iConstructLong.op3;\n        nextIP = NEXTINST(ConstructLong);\n        callNewTarget = O2REG(ConstructLong).getRaw();\n        goto doCall;\n      }\n      CASE(CallLong) {\n        callArgCount = (uint32_t)ip->iCallLong.op3;\n        nextIP = NEXTINST(CallLong);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      // Note in Call1 through Call4, the first argument is 'this' which has\n      // argument index -1.\n      // Also note that we are writing to callNewTarget last, to avoid the\n      // possibility of it being aliased by the arg writes.\n      CASE(Call1) {\n        callArgCount = 1;\n        nextIP = NEXTINST(Call1);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call1);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call2) {\n        callArgCount = 2;\n        nextIP = NEXTINST(Call2);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call2);\n        fr.getArgRefUnsafe(0) = O4REG(Call2);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call3) {\n        callArgCount = 3;\n        nextIP = NEXTINST(Call3);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call3);\n        fr.getArgRefUnsafe(0) = O4REG(Call3);\n        fr.getArgRefUnsafe(1) = O5REG(Call3);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Call4) {\n        callArgCount = 4;\n        nextIP = NEXTINST(Call4);\n        StackFramePtr fr{runtime->stackPointer_};\n        fr.getArgRefUnsafe(-1) = O3REG(Call4);\n        fr.getArgRefUnsafe(0) = O4REG(Call4);\n        fr.getArgRefUnsafe(1) = O5REG(Call4);\n        fr.getArgRefUnsafe(2) = O6REG(Call4);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        goto doCall;\n      }\n\n      CASE(Construct) {\n        callArgCount = (uint32_t)ip->iConstruct.op3;\n        nextIP = NEXTINST(Construct);\n        callNewTarget = O2REG(Construct).getRaw();\n        goto doCall;\n      }\n      CASE(Call) {\n        callArgCount = (uint32_t)ip->iCall.op3;\n        nextIP = NEXTINST(Call);\n        callNewTarget = HermesValue::encodeUndefinedValue().getRaw();\n        // Fall through.\n      }\n\n    doCall : {\n#ifdef HERMES_ENABLE_DEBUGGER\n      // Check for an async debugger request.\n      if (uint8_t asyncFlags =\n              runtime->testAndClearDebuggerAsyncBreakRequest()) {\n        RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        DISPATCH;\n      }\n#endif\n\n      // Subtract 1 from callArgCount as 'this' is considered an argument in the\n      // instruction, but not in the frame.\n      CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n          auto newFrame,\n          StackFramePtr::initFrame(\n              runtime->stackPointer_,\n              FRAME,\n              ip,\n              curCodeBlock,\n              callArgCount - 1,\n              O2REG(Call),\n              HermesValue::fromRaw(callNewTarget)));\n      (void)newFrame;\n\n      SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n      if (auto *func = dyn_vmcast<JSFunction>(O2REG(Call))) {\n        assert(!SingleStep && \"can't single-step a call\");\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n        runtime->pushCallStack(curCodeBlock, ip);\n#endif\n\n        CodeBlock *calleeBlock = func->getCodeBlock();\n        calleeBlock->lazyCompile(runtime);\n#if defined(HERMESVM_PROFILER_EXTERN)\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            res, runtime->interpretFunction(calleeBlock));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(Call) = *res;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = nextIP;\n        DISPATCH;\n#else\n        if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n          res = (*jitPtr)(runtime);\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          O1REG(Call) = *res;\n          SLOW_DEBUG(\n              dbgs() << \"JIT return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                     << DumpHermesValue(O1REG(Call)) << \"\\n\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          ip = nextIP;\n          DISPATCH;\n        }\n        curCodeBlock = calleeBlock;\n        goto tailCall;\n#endif\n      }\n      CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n          resPH, Interpreter::handleCallSlowPath(runtime, &O2REG(Call)));\n      if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      O1REG(Call) = std::move(resPH->get());\n      SLOW_DEBUG(\n          dbgs() << \"native return value r\" << (unsigned)ip->iCall.op1 << \"=\"\n                 << DumpHermesValue(O1REG(Call)) << \"\\n\");\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(CallDirect)\n      CASE(CallDirectLongIndex) {\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Check for an async debugger request.\n        if (uint8_t asyncFlags =\n                runtime->testAndClearDebuggerAsyncBreakRequest()) {\n          RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          DISPATCH;\n        }\n#endif\n\n        CAPTURE_IP_ASSIGN(\n            CodeBlock * calleeBlock,\n            ip->opCode == OpCode::CallDirect\n                ? curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                      ip->iCallDirect.op3)\n                : curCodeBlock->getRuntimeModule()->getCodeBlockMayAllocate(\n                      ip->iCallDirectLongIndex.op3));\n\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            auto newFrame,\n            StackFramePtr::initFrame(\n                runtime->stackPointer_,\n                FRAME,\n                ip,\n                curCodeBlock,\n                (uint32_t)ip->iCallDirect.op2 - 1,\n                HermesValue::encodeNativePointer(calleeBlock),\n                HermesValue::encodeUndefinedValue()));\n        (void)newFrame;\n\n        LLVM_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n        assert(!SingleStep && \"can't single-step a call\");\n\n        calleeBlock->lazyCompile(runtime);\n#if defined(HERMESVM_PROFILER_EXTERN)\n        CAPTURE_IP_ASSIGN_NO_INVALIDATE(\n            res, runtime->interpretFunction(calleeBlock));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CallDirect) = *res;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                              : NEXTINST(CallDirectLongIndex);\n        DISPATCH;\n#else\n        if (auto jitPtr = runtime->jitContext_.compile(runtime, calleeBlock)) {\n          res = (*jitPtr)(runtime);\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          O1REG(CallDirect) = *res;\n          LLVM_DEBUG(\n              dbgs() << \"JIT return value r\" << (unsigned)ip->iCallDirect.op1\n                     << \"=\" << DumpHermesValue(O1REG(Call)) << \"\\n\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          ip = ip->opCode == OpCode::CallDirect ? NEXTINST(CallDirect)\n                                                : NEXTINST(CallDirectLongIndex);\n          DISPATCH;\n        }\n        curCodeBlock = calleeBlock;\n        goto tailCall;\n#endif\n      }\n\n      CASE(CallBuiltin) {\n        NativeFunction *nf =\n            runtime->getBuiltinNativeFunction(ip->iCallBuiltin.op2);\n\n        CAPTURE_IP_ASSIGN(\n            auto newFrame,\n            StackFramePtr::initFrame(\n                runtime->stackPointer_,\n                FRAME,\n                ip,\n                curCodeBlock,\n                (uint32_t)ip->iCallBuiltin.op3 - 1,\n                nf,\n                false));\n        // \"thisArg\" is implicitly assumed to \"undefined\".\n        newFrame.getThisArgRef() = HermesValue::encodeUndefinedValue();\n\n        SLOW_DEBUG(dumpCallArguments(dbgs(), runtime, newFrame));\n\n        CAPTURE_IP_ASSIGN(resPH, NativeFunction::_nativeCall(nf, runtime));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION))\n          goto exception;\n        O1REG(CallBuiltin) = std::move(resPH->get());\n        SLOW_DEBUG(\n            dbgs() << \"native return value r\" << (unsigned)ip->iCallBuiltin.op1\n                   << \"=\" << DumpHermesValue(O1REG(CallBuiltin)) << \"\\n\");\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CallBuiltin);\n        DISPATCH;\n      }\n\n      CASE(CompleteGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        innerFn->setState(GeneratorInnerFunction::State::Completed);\n        ip = NEXTINST(CompleteGenerator);\n        DISPATCH;\n      }\n\n      CASE(SaveGenerator) {\n        DONT_CAPTURE_IP(\n            saveGenerator(runtime, frameRegs, IPADD(ip->iSaveGenerator.op1)));\n        ip = NEXTINST(SaveGenerator);\n        DISPATCH;\n      }\n      CASE(SaveGeneratorLong) {\n        DONT_CAPTURE_IP(saveGenerator(\n            runtime, frameRegs, IPADD(ip->iSaveGeneratorLong.op1)));\n        ip = NEXTINST(SaveGeneratorLong);\n        DISPATCH;\n      }\n\n      CASE(StartGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        if (innerFn->getState() ==\n            GeneratorInnerFunction::State::SuspendedStart) {\n          nextIP = NEXTINST(StartGenerator);\n        } else {\n          nextIP = innerFn->getNextIP();\n          innerFn->restoreStack(runtime);\n        }\n        innerFn->setState(GeneratorInnerFunction::State::Executing);\n        ip = nextIP;\n        DISPATCH;\n      }\n\n      CASE(ResumeGenerator) {\n        auto *innerFn = vmcast<GeneratorInnerFunction>(\n            runtime->getCurrentFrame().getCalleeClosure());\n        O1REG(ResumeGenerator) = innerFn->getResult();\n        O2REG(ResumeGenerator) = HermesValue::encodeBoolValue(\n            innerFn->getAction() == GeneratorInnerFunction::Action::Return);\n        innerFn->clearResult(runtime);\n        if (innerFn->getAction() == GeneratorInnerFunction::Action::Throw) {\n          runtime->setThrownValue(O1REG(ResumeGenerator));\n          goto exception;\n        }\n        ip = NEXTINST(ResumeGenerator);\n        DISPATCH;\n      }\n\n      CASE(Ret) {\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Check for an async debugger request.\n        if (uint8_t asyncFlags =\n                runtime->testAndClearDebuggerAsyncBreakRequest()) {\n          RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          DISPATCH;\n        }\n#endif\n\n        PROFILER_EXIT_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n        runtime->popCallStack();\n#endif\n\n        // Store the return value.\n        res = O1REG(Ret);\n\n        ip = FRAME.getSavedIP();\n        curCodeBlock = FRAME.getSavedCodeBlock();\n\n        frameRegs =\n            &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n        SLOW_DEBUG(\n            dbgs() << \"function exit: restored stackLevel=\"\n                   << runtime->getStackLevel() << \"\\n\");\n\n        // Are we returning to native code?\n        if (!curCodeBlock) {\n          SLOW_DEBUG(dbgs() << \"function exit: returning to native code\\n\");\n          return res;\n        }\n\n// Return because of recursive calling structure\n#if defined(HERMESVM_PROFILER_EXTERN)\n        return res;\n#endif\n\n        INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n        O1REG(Call) = res.getValue();\n        ip = nextInstCall(ip);\n        DISPATCH;\n      }\n\n      CASE(Catch) {\n        assert(!runtime->thrownValue_.isEmpty() && \"Invalid thrown value\");\n        assert(\n            !isUncatchableError(runtime->thrownValue_) &&\n            \"Uncatchable thrown value was caught\");\n        O1REG(Catch) = runtime->thrownValue_;\n        runtime->clearThrownValue();\n#ifdef HERMES_ENABLE_DEBUGGER\n        // Signal to the debugger that we're done unwinding an exception,\n        // and we can resume normal debugging flow.\n        runtime->debugger_.finishedUnwindingException();\n#endif\n        ip = NEXTINST(Catch);\n        DISPATCH;\n      }\n\n      CASE(Throw) {\n        runtime->thrownValue_ = O1REG(Throw);\n        SLOW_DEBUG(\n            dbgs() << \"Exception thrown: \"\n                   << DumpHermesValue(runtime->thrownValue_) << \"\\n\");\n        goto exception;\n      }\n\n      CASE(ThrowIfUndefinedInst) {\n        if (LLVM_UNLIKELY(O1REG(ThrowIfUndefinedInst).isUndefined())) {\n          SLOW_DEBUG(\n              dbgs() << \"Throwing ReferenceError for undefined variable\");\n          CAPTURE_IP(runtime->raiseReferenceError(\n              \"accessing an uninitialized variable\"));\n          goto exception;\n        }\n        ip = NEXTINST(ThrowIfUndefinedInst);\n        DISPATCH;\n      }\n\n      CASE(Debugger) {\n        SLOW_DEBUG(dbgs() << \"debugger statement executed\\n\");\n#ifdef HERMES_ENABLE_DEBUGGER\n        {\n          if (!runtime->debugger_.isDebugging()) {\n            // Only run the debugger if we're not already debugging.\n            // Don't want to call it again and mess with its state.\n            CAPTURE_IP_ASSIGN(\n                auto res,\n                runDebuggerUpdatingState(\n                    Debugger::RunReason::Opcode,\n                    runtime,\n                    curCodeBlock,\n                    ip,\n                    frameRegs));\n            if (res == ExecutionStatus::EXCEPTION) {\n              // If one of the internal steps threw,\n              // then handle that here by jumping to where we're supposed to go.\n              // If we're in mid-step, the breakpoint at the catch point\n              // will have been set by the debugger.\n              // We don't want to execute this instruction because it's already\n              // thrown.\n              goto exception;\n            }\n          }\n          auto breakpointOpt = runtime->debugger_.getBreakpointLocation(ip);\n          if (breakpointOpt.hasValue()) {\n            // We're on a breakpoint but we're supposed to continue.\n            curCodeBlock->uninstallBreakpointAtOffset(\n                CUROFFSET, breakpointOpt->opCode);\n            if (ip->opCode == OpCode::Debugger) {\n              // Breakpointed a debugger instruction, so move past it\n              // since we've already called the debugger on this instruction.\n              ip = NEXTINST(Debugger);\n            } else {\n              InterpreterState newState{curCodeBlock, (uint32_t)CUROFFSET};\n              CAPTURE_IP_ASSIGN(\n                  ExecutionStatus status, runtime->stepFunction(newState));\n              curCodeBlock->installBreakpointAtOffset(CUROFFSET);\n              if (status == ExecutionStatus::EXCEPTION) {\n                goto exception;\n              }\n              curCodeBlock = newState.codeBlock;\n              ip = newState.codeBlock->getOffsetPtr(newState.offset);\n              INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n              // Single-stepping should handle call stack management for us.\n              frameRegs = &runtime->getCurrentFrame().getFirstLocalRef();\n            }\n          } else if (ip->opCode == OpCode::Debugger) {\n            // No breakpoint here and we've already run the debugger,\n            // just continue on.\n            // If the current instruction is no longer a debugger instruction,\n            // we're just going to keep executing from the current IP.\n            ip = NEXTINST(Debugger);\n          }\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n        DISPATCH;\n#else\n        ip = NEXTINST(Debugger);\n        DISPATCH;\n#endif\n      }\n\n      CASE(AsyncBreakCheck) {\n        if (LLVM_UNLIKELY(runtime->hasAsyncBreak())) {\n#ifdef HERMES_ENABLE_DEBUGGER\n          if (uint8_t asyncFlags =\n                  runtime->testAndClearDebuggerAsyncBreakRequest()) {\n            RUN_DEBUGGER_ASYNC_BREAK(asyncFlags);\n          }\n#endif\n          if (runtime->testAndClearTimeoutAsyncBreakRequest()) {\n            CAPTURE_IP_ASSIGN(auto nRes, runtime->notifyTimeout());\n            if (nRes == ExecutionStatus::EXCEPTION) {\n              goto exception;\n            }\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n\n        ip = NEXTINST(AsyncBreakCheck);\n        DISPATCH;\n      }\n\n      CASE(ProfilePoint) {\n#ifdef HERMESVM_PROFILER_BB\n        auto pointIndex = ip->iProfilePoint.op1;\n        SLOW_DEBUG(llvh::dbgs() << \"ProfilePoint: \" << pointIndex << \"\\n\");\n        CAPTURE_IP(runtime->getBasicBlockExecutionInfo().executeBlock(\n            curCodeBlock, pointIndex));\n#endif\n        ip = NEXTINST(ProfilePoint);\n        DISPATCH;\n      }\n\n      CASE(Unreachable) {\n        llvm_unreachable(\"Hermes bug: unreachable instruction\");\n      }\n\n      CASE(CreateClosure) {\n        idVal = ip->iCreateClosure.op3;\n        nextIP = NEXTINST(CreateClosure);\n        goto createClosure;\n      }\n      CASE(CreateClosureLongIndex) {\n        idVal = ip->iCreateClosureLongIndex.op3;\n        nextIP = NEXTINST(CreateClosureLongIndex);\n        goto createClosure;\n      }\n    createClosure : {\n      auto *runtimeModule = curCodeBlock->getRuntimeModule();\n      CAPTURE_IP_ASSIGN(\n          O1REG(CreateClosure),\n          JSFunction::create(\n              runtime,\n              runtimeModule->getDomain(runtime),\n              Handle<JSObject>::vmcast(&runtime->functionPrototype),\n              Handle<Environment>::vmcast(&O2REG(CreateClosure)),\n              runtimeModule->getCodeBlockMayAllocate(idVal))\n              .getHermesValue());\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(CreateGeneratorClosure) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGeneratorClosure(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateClosure.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGeneratorClosure))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorClosure) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorClosure);\n        DISPATCH;\n      }\n      CASE(CreateGeneratorClosureLongIndex) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGeneratorClosure(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateClosureLongIndex.op3,\n                Handle<Environment>::vmcast(\n                    &O2REG(CreateGeneratorClosureLongIndex))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorClosureLongIndex) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorClosureLongIndex);\n        DISPATCH;\n      }\n\n      CASE(CreateGenerator) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGenerator_RJS(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateGenerator.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGenerator)),\n                FRAME.getNativeArgs()));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGenerator) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGenerator);\n        DISPATCH;\n      }\n      CASE(CreateGeneratorLongIndex) {\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            createGenerator_RJS(\n                runtime,\n                curCodeBlock->getRuntimeModule(),\n                ip->iCreateGeneratorLongIndex.op3,\n                Handle<Environment>::vmcast(&O2REG(CreateGeneratorLongIndex)),\n                FRAME.getNativeArgs()));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(CreateGeneratorLongIndex) = res->getHermesValue();\n        res->invalidate();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateGeneratorLongIndex);\n        DISPATCH;\n      }\n\n      CASE(GetEnvironment) {\n        // The currently executing function must exist, so get the environment.\n        Environment *curEnv =\n            FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime);\n        for (unsigned level = ip->iGetEnvironment.op2; level; --level) {\n          assert(curEnv && \"invalid environment relative level\");\n          curEnv = curEnv->getParentEnvironment(runtime);\n        }\n        O1REG(GetEnvironment) = HermesValue::encodeObjectValue(curEnv);\n        ip = NEXTINST(GetEnvironment);\n        DISPATCH;\n      }\n\n      CASE(CreateEnvironment) {\n        tmpHandle = HermesValue::encodeObjectValue(\n            FRAME.getCalleeClosureUnsafe()->getEnvironment(runtime));\n\n        CAPTURE_IP_ASSIGN(\n            res,\n            Environment::create(\n                runtime,\n                tmpHandle->getPointer() ? Handle<Environment>::vmcast(tmpHandle)\n                                        : Handle<Environment>::vmcast_or_null(\n                                              &runtime->nullPointer_),\n                curCodeBlock->getEnvironmentSize()));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        O1REG(CreateEnvironment) = *res;\n#ifdef HERMES_ENABLE_DEBUGGER\n        FRAME.getDebugEnvironmentRef() = *res;\n#endif\n        tmpHandle = HermesValue::encodeUndefinedValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateEnvironment);\n        DISPATCH;\n      }\n\n      CASE(StoreToEnvironment) {\n        vmcast<Environment>(O1REG(StoreToEnvironment))\n            ->slot(ip->iStoreToEnvironment.op2)\n            .set(O3REG(StoreToEnvironment), &runtime->getHeap());\n        ip = NEXTINST(StoreToEnvironment);\n        DISPATCH;\n      }\n      CASE(StoreToEnvironmentL) {\n        vmcast<Environment>(O1REG(StoreToEnvironmentL))\n            ->slot(ip->iStoreToEnvironmentL.op2)\n            .set(O3REG(StoreToEnvironmentL), &runtime->getHeap());\n        ip = NEXTINST(StoreToEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(StoreNPToEnvironment) {\n        vmcast<Environment>(O1REG(StoreNPToEnvironment))\n            ->slot(ip->iStoreNPToEnvironment.op2)\n            .setNonPtr(O3REG(StoreNPToEnvironment), &runtime->getHeap());\n        ip = NEXTINST(StoreNPToEnvironment);\n        DISPATCH;\n      }\n      CASE(StoreNPToEnvironmentL) {\n        vmcast<Environment>(O1REG(StoreNPToEnvironmentL))\n            ->slot(ip->iStoreNPToEnvironmentL.op2)\n            .setNonPtr(O3REG(StoreNPToEnvironmentL), &runtime->getHeap());\n        ip = NEXTINST(StoreNPToEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(LoadFromEnvironment) {\n        O1REG(LoadFromEnvironment) =\n            vmcast<Environment>(O2REG(LoadFromEnvironment))\n                ->slot(ip->iLoadFromEnvironment.op3);\n        ip = NEXTINST(LoadFromEnvironment);\n        DISPATCH;\n      }\n\n      CASE(LoadFromEnvironmentL) {\n        O1REG(LoadFromEnvironmentL) =\n            vmcast<Environment>(O2REG(LoadFromEnvironmentL))\n                ->slot(ip->iLoadFromEnvironmentL.op3);\n        ip = NEXTINST(LoadFromEnvironmentL);\n        DISPATCH;\n      }\n\n      CASE(GetGlobalObject) {\n        O1REG(GetGlobalObject) = runtime->global_;\n        ip = NEXTINST(GetGlobalObject);\n        DISPATCH;\n      }\n\n      CASE(GetNewTarget) {\n        O1REG(GetNewTarget) = FRAME.getNewTargetRef();\n        ip = NEXTINST(GetNewTarget);\n        DISPATCH;\n      }\n\n      CASE(DeclareGlobalVar) {\n        DefinePropertyFlags dpf =\n            DefinePropertyFlags::getDefaultNewPropertyFlags();\n        dpf.configurable = 0;\n        // Do not overwrite existing globals with undefined.\n        dpf.setValue = 0;\n\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            JSObject::defineOwnProperty(\n                runtime->getGlobal(),\n                runtime,\n                ID(ip->iDeclareGlobalVar.op1),\n                dpf,\n                Runtime::getUndefinedValue(),\n                PropOpFlags().plusThrowOnError()));\n        if (res == ExecutionStatus::EXCEPTION) {\n          assert(\n              !runtime->getGlobal()->isProxyObject() &&\n              \"global can't be a proxy object\");\n          // If the property already exists, this should be a noop.\n          // Instead of incurring the cost to check every time, do it\n          // only if an exception is thrown, and swallow the exception\n          // if it exists, since we didn't want to make the call,\n          // anyway.  This most likely means the property is\n          // non-configurable.\n          NamedPropertyDescriptor desc;\n          CAPTURE_IP_ASSIGN(\n              auto res,\n              JSObject::getOwnNamedDescriptor(\n                  runtime->getGlobal(),\n                  runtime,\n                  ID(ip->iDeclareGlobalVar.op1),\n                  desc));\n          if (!res) {\n            goto exception;\n          } else {\n            runtime->clearThrownValue();\n          }\n          // fall through\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(DeclareGlobalVar);\n        DISPATCH;\n      }\n\n      CASE(TryGetByIdLong) {\n        tryProp = true;\n        idVal = ip->iTryGetByIdLong.op4;\n        nextIP = NEXTINST(TryGetByIdLong);\n        goto getById;\n      }\n      CASE(GetByIdLong) {\n        tryProp = false;\n        idVal = ip->iGetByIdLong.op4;\n        nextIP = NEXTINST(GetByIdLong);\n        goto getById;\n      }\n      CASE(GetByIdShort) {\n        tryProp = false;\n        idVal = ip->iGetByIdShort.op4;\n        nextIP = NEXTINST(GetByIdShort);\n        goto getById;\n      }\n      CASE(TryGetById) {\n        tryProp = true;\n        idVal = ip->iTryGetById.op4;\n        nextIP = NEXTINST(TryGetById);\n        goto getById;\n      }\n      CASE(GetById) {\n        tryProp = false;\n        idVal = ip->iGetById.op4;\n        nextIP = NEXTINST(GetById);\n      }\n    getById : {\n      ++NumGetById;\n      // NOTE: it is safe to use OnREG(GetById) here because all instructions\n      // have the same layout: opcode, registers, non-register operands, i.e.\n      // they only differ in the width of the last \"identifier\" field.\n      CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n      if (LLVM_LIKELY(O2REG(GetById).isObject())) {\n        auto *obj = vmcast<JSObject>(O2REG(GetById));\n        auto cacheIdx = ip->iGetById.op3;\n        auto *cacheEntry = curCodeBlock->getReadCacheEntry(cacheIdx);\n\n#ifdef HERMESVM_PROFILER_BB\n        {\n          HERMES_SLOW_ASSERT(\n              gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n              \"unaccounted handles were created\");\n          auto objHandle = runtime->makeHandle(obj);\n          auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n              cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n          CAPTURE_IP(runtime->recordHiddenClass(\n              curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n          // obj may be moved by GC due to recordHiddenClass\n          obj = objHandle.get();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n#endif\n        auto clazzGCPtr = obj->getClassGCPtr();\n#ifndef NDEBUG\n        if (clazzGCPtr.get(runtime)->isDictionary())\n          ++NumGetByIdDict;\n#else\n        (void)NumGetByIdDict;\n#endif\n\n        // If we have a cache hit, reuse the cached offset and immediately\n        // return the property.\n        if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n          ++NumGetByIdCacheHits;\n          CAPTURE_IP_ASSIGN(\n              O1REG(GetById),\n              JSObject::getNamedSlotValue<PropStorage::Inline::Yes>(\n                  obj, runtime, cacheEntry->slot));\n          ip = nextIP;\n          DISPATCH;\n        }\n        auto id = ID(idVal);\n        NamedPropertyDescriptor desc;\n        CAPTURE_IP_ASSIGN(\n            OptValue<bool> fastPathResult,\n            JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n        if (LLVM_LIKELY(\n                fastPathResult.hasValue() && fastPathResult.getValue()) &&\n            !desc.flags.accessor) {\n          ++NumGetByIdFastPaths;\n\n          // cacheIdx == 0 indicates no caching so don't update the cache in\n          // those cases.\n          auto *clazz = clazzGCPtr.getNonNull(runtime);\n          if (LLVM_LIKELY(!clazz->isDictionaryNoCache()) &&\n              LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n#ifdef HERMES_SLOW_DEBUG\n            if (cacheEntry->clazz &&\n                cacheEntry->clazz != clazzGCPtr.getStorageType())\n              ++NumGetByIdCacheEvicts;\n#else\n            (void)NumGetByIdCacheEvicts;\n#endif\n            // Cache the class, id and property slot.\n            cacheEntry->clazz = clazzGCPtr.getStorageType();\n            cacheEntry->slot = desc.slot;\n          }\n\n          CAPTURE_IP_ASSIGN(\n              O1REG(GetById), JSObject::getNamedSlotValue(obj, runtime, desc));\n          ip = nextIP;\n          DISPATCH;\n        }\n\n        // The cache may also be populated via the prototype of the object.\n        // This value is only reliable if the fast path was a definite\n        // not-found.\n        if (fastPathResult.hasValue() && !fastPathResult.getValue() &&\n            !obj->isProxyObject()) {\n          CAPTURE_IP_ASSIGN(JSObject * parent, obj->getParent(runtime));\n          // TODO: This isLazy check is because a lazy object is reported as\n          // having no properties and therefore cannot contain the property.\n          // This check does not belong here, it should be merged into\n          // tryGetOwnNamedDescriptorFast().\n          if (parent &&\n              cacheEntry->clazz == parent->getClassGCPtr().getStorageType() &&\n              LLVM_LIKELY(!obj->isLazy())) {\n            ++NumGetByIdProtoHits;\n            CAPTURE_IP_ASSIGN(\n                O1REG(GetById),\n                JSObject::getNamedSlotValue(parent, runtime, cacheEntry->slot));\n            ip = nextIP;\n            DISPATCH;\n          }\n        }\n\n#ifdef HERMES_SLOW_DEBUG\n        CAPTURE_IP_ASSIGN(\n            JSObject * propObj,\n            JSObject::getNamedDescriptor(\n                Handle<JSObject>::vmcast(&O2REG(GetById)), runtime, id, desc));\n        if (propObj) {\n          if (desc.flags.accessor)\n            ++NumGetByIdAccessor;\n          else if (propObj != vmcast<JSObject>(O2REG(GetById)))\n            ++NumGetByIdProto;\n        } else {\n          ++NumGetByIdNotFound;\n        }\n#else\n        (void)NumGetByIdAccessor;\n        (void)NumGetByIdProto;\n        (void)NumGetByIdNotFound;\n#endif\n#ifdef HERMES_SLOW_DEBUG\n        auto *savedClass = cacheIdx != hbc::PROPERTY_CACHING_DISABLED\n            ? cacheEntry->clazz.get(runtime, &runtime->getHeap())\n            : nullptr;\n#endif\n        ++NumGetByIdSlow;\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            JSObject::getNamed_RJS(\n                Handle<JSObject>::vmcast(&O2REG(GetById)),\n                runtime,\n                id,\n                !tryProp ? defaultPropOpFlags\n                         : defaultPropOpFlags.plusMustExist(),\n                cacheIdx != hbc::PROPERTY_CACHING_DISABLED ? cacheEntry\n                                                           : nullptr));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n#ifdef HERMES_SLOW_DEBUG\n        if (cacheIdx != hbc::PROPERTY_CACHING_DISABLED && savedClass &&\n            cacheEntry->clazz.get(runtime, &runtime->getHeap()) != savedClass) {\n          ++NumGetByIdCacheEvicts;\n        }\n#endif\n      } else {\n        ++NumGetByIdTransient;\n        assert(!tryProp && \"TryGetById can only be used on the global object\");\n        /* Slow path. */\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::getByIdTransient_RJS(\n                runtime, Handle<>(&O2REG(GetById)), ID(idVal)));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n      }\n      O1REG(GetById) = resPH->get();\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(TryPutByIdLong) {\n        tryProp = true;\n        idVal = ip->iTryPutByIdLong.op4;\n        nextIP = NEXTINST(TryPutByIdLong);\n        goto putById;\n      }\n      CASE(PutByIdLong) {\n        tryProp = false;\n        idVal = ip->iPutByIdLong.op4;\n        nextIP = NEXTINST(PutByIdLong);\n        goto putById;\n      }\n      CASE(TryPutById) {\n        tryProp = true;\n        idVal = ip->iTryPutById.op4;\n        nextIP = NEXTINST(TryPutById);\n        goto putById;\n      }\n      CASE(PutById) {\n        tryProp = false;\n        idVal = ip->iPutById.op4;\n        nextIP = NEXTINST(PutById);\n      }\n    putById : {\n      ++NumPutById;\n      if (LLVM_LIKELY(O1REG(PutById).isObject())) {\n        auto *obj = vmcast<JSObject>(O1REG(PutById));\n        auto cacheIdx = ip->iPutById.op3;\n        auto *cacheEntry = curCodeBlock->getWriteCacheEntry(cacheIdx);\n\n#ifdef HERMESVM_PROFILER_BB\n        {\n          HERMES_SLOW_ASSERT(\n              gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n              \"unaccounted handles were created\");\n          auto objHandle = runtime->makeHandle(obj);\n          auto cacheHCPtr = vmcast_or_null<HiddenClass>(static_cast<GCCell *>(\n              cacheEntry->clazz.get(runtime, &runtime->getHeap())));\n          CAPTURE_IP(runtime->recordHiddenClass(\n              curCodeBlock, ip, ID(idVal), obj->getClass(runtime), cacheHCPtr));\n          // obj may be moved by GC due to recordHiddenClass\n          obj = objHandle.get();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n#endif\n        auto clazzGCPtr = obj->getClassGCPtr();\n        // If we have a cache hit, reuse the cached offset and immediately\n        // return the property.\n        if (LLVM_LIKELY(cacheEntry->clazz == clazzGCPtr.getStorageType())) {\n          ++NumPutByIdCacheHits;\n          CAPTURE_IP(JSObject::setNamedSlotValue<PropStorage::Inline::Yes>(\n              obj, runtime, cacheEntry->slot, O2REG(PutById)));\n          ip = nextIP;\n          DISPATCH;\n        }\n        auto id = ID(idVal);\n        NamedPropertyDescriptor desc;\n        CAPTURE_IP_ASSIGN(\n            OptValue<bool> hasOwnProp,\n            JSObject::tryGetOwnNamedDescriptorFast(obj, runtime, id, desc));\n        if (LLVM_LIKELY(hasOwnProp.hasValue() && hasOwnProp.getValue()) &&\n            !desc.flags.accessor && desc.flags.writable &&\n            !desc.flags.internalSetter) {\n          ++NumPutByIdFastPaths;\n\n          // cacheIdx == 0 indicates no caching so don't update the cache in\n          // those cases.\n          auto *clazz = clazzGCPtr.getNonNull(runtime);\n          if (LLVM_LIKELY(!clazz->isDictionary()) &&\n              LLVM_LIKELY(cacheIdx != hbc::PROPERTY_CACHING_DISABLED)) {\n#ifdef HERMES_SLOW_DEBUG\n            if (cacheEntry->clazz &&\n                cacheEntry->clazz != clazzGCPtr.getStorageType())\n              ++NumPutByIdCacheEvicts;\n#else\n            (void)NumPutByIdCacheEvicts;\n#endif\n            // Cache the class and property slot.\n            cacheEntry->clazz = clazzGCPtr.getStorageType();\n            cacheEntry->slot = desc.slot;\n          }\n\n          CAPTURE_IP(JSObject::setNamedSlotValue(\n              obj, runtime, desc.slot, O2REG(PutById)));\n          ip = nextIP;\n          DISPATCH;\n        }\n\n        CAPTURE_IP_ASSIGN(\n            auto putRes,\n            JSObject::putNamed_RJS(\n                Handle<JSObject>::vmcast(&O1REG(PutById)),\n                runtime,\n                id,\n                Handle<>(&O2REG(PutById)),\n                !tryProp ? defaultPropOpFlags\n                         : defaultPropOpFlags.plusMustExist()));\n        if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n      } else {\n        ++NumPutByIdTransient;\n        assert(!tryProp && \"TryPutById can only be used on the global object\");\n        CAPTURE_IP_ASSIGN(\n            auto retStatus,\n            Interpreter::putByIdTransient_RJS(\n                runtime,\n                Handle<>(&O1REG(PutById)),\n                ID(idVal),\n                Handle<>(&O2REG(PutById)),\n                strictMode));\n        if (retStatus == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(GetByVal) {\n        CallResult<HermesValue> propRes{ExecutionStatus::EXCEPTION};\n        if (LLVM_LIKELY(O2REG(GetByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              resPH,\n              JSObject::getComputed_RJS(\n                  Handle<JSObject>::vmcast(&O2REG(GetByVal)),\n                  runtime,\n                  Handle<>(&O3REG(GetByVal))));\n          if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(\n              resPH,\n              Interpreter::getByValTransient_RJS(\n                  runtime,\n                  Handle<>(&O2REG(GetByVal)),\n                  Handle<>(&O3REG(GetByVal))));\n          if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetByVal) = resPH->get();\n        ip = NEXTINST(GetByVal);\n        DISPATCH;\n      }\n\n      CASE(PutByVal) {\n        if (LLVM_LIKELY(O1REG(PutByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              auto putRes,\n              JSObject::putComputed_RJS(\n                  Handle<JSObject>::vmcast(&O1REG(PutByVal)),\n                  runtime,\n                  Handle<>(&O2REG(PutByVal)),\n                  Handle<>(&O3REG(PutByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(putRes == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(\n              auto retStatus,\n              Interpreter::putByValTransient_RJS(\n                  runtime,\n                  Handle<>(&O1REG(PutByVal)),\n                  Handle<>(&O2REG(PutByVal)),\n                  Handle<>(&O3REG(PutByVal)),\n                  strictMode));\n          if (LLVM_UNLIKELY(retStatus == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(PutByVal);\n        DISPATCH;\n      }\n\n      CASE(PutOwnByIndexL) {\n        nextIP = NEXTINST(PutOwnByIndexL);\n        idVal = ip->iPutOwnByIndexL.op3;\n        goto putOwnByIndex;\n      }\n      CASE(PutOwnByIndex) {\n        nextIP = NEXTINST(PutOwnByIndex);\n        idVal = ip->iPutOwnByIndex.op3;\n      }\n    putOwnByIndex : {\n      tmpHandle = HermesValue::encodeDoubleValue(idVal);\n      CAPTURE_IP(JSObject::defineOwnComputedPrimitive(\n          Handle<JSObject>::vmcast(&O1REG(PutOwnByIndex)),\n          runtime,\n          tmpHandle,\n          DefinePropertyFlags::getDefaultNewPropertyFlags(),\n          Handle<>(&O2REG(PutOwnByIndex))));\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      tmpHandle.clear();\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(GetPNameList) {\n        CAPTURE_IP_ASSIGN(\n            auto pRes, handleGetPNameList(runtime, frameRegs, ip));\n        if (LLVM_UNLIKELY(pRes == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(GetPNameList);\n        DISPATCH;\n      }\n\n      CASE(GetNextPName) {\n        {\n          assert(\n              vmisa<BigStorage>(O2REG(GetNextPName)) &&\n              \"GetNextPName's second op must be BigStorage\");\n          auto obj = Handle<JSObject>::vmcast(&O3REG(GetNextPName));\n          auto arr = Handle<BigStorage>::vmcast(&O2REG(GetNextPName));\n          uint32_t idx = O4REG(GetNextPName).getNumber();\n          uint32_t size = O5REG(GetNextPName).getNumber();\n          MutableHandle<JSObject> propObj{runtime};\n          // Loop until we find a property which is present.\n          while (idx < size) {\n            tmpHandle = arr->at(idx);\n            ComputedPropertyDescriptor desc;\n            CAPTURE_IP(JSObject::getComputedPrimitiveDescriptor(\n                obj, runtime, tmpHandle, propObj, desc));\n            if (LLVM_LIKELY(propObj))\n              break;\n            ++idx;\n          }\n          if (idx < size) {\n            // We must return the property as a string\n            if (tmpHandle->isNumber()) {\n              CAPTURE_IP_ASSIGN(auto status, toString_RJS(runtime, tmpHandle));\n              assert(\n                  status == ExecutionStatus::RETURNED &&\n                  \"toString on number cannot fail\");\n              tmpHandle = status->getHermesValue();\n            }\n            O1REG(GetNextPName) = tmpHandle.get();\n            O4REG(GetNextPName) = HermesValue::encodeNumberValue(idx + 1);\n          } else {\n            O1REG(GetNextPName) = HermesValue::encodeUndefinedValue();\n          }\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(GetNextPName);\n        DISPATCH;\n      }\n\n      CASE(ToNumber) {\n        if (LLVM_LIKELY(O2REG(ToNumber).isNumber())) {\n          O1REG(ToNumber) = O2REG(ToNumber);\n          ip = NEXTINST(ToNumber);\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res, toNumber_RJS(runtime, Handle<>(&O2REG(ToNumber))));\n          if (res == ExecutionStatus::EXCEPTION)\n            goto exception;\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(ToNumber) = res.getValue();\n          ip = NEXTINST(ToNumber);\n        }\n        DISPATCH;\n      }\n\n      CASE(ToInt32) {\n        CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(ToInt32))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n          goto exception;\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(ToInt32) = res.getValue();\n        ip = NEXTINST(ToInt32);\n        DISPATCH;\n      }\n\n      CASE(AddEmptyString) {\n        if (LLVM_LIKELY(O2REG(AddEmptyString).isString())) {\n          O1REG(AddEmptyString) = O2REG(AddEmptyString);\n          ip = NEXTINST(AddEmptyString);\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res,\n              toPrimitive_RJS(\n                  runtime,\n                  Handle<>(&O2REG(AddEmptyString)),\n                  PreferredType::NONE));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION))\n            goto exception;\n          tmpHandle = res.getValue();\n          CAPTURE_IP_ASSIGN(auto strRes, toString_RJS(runtime, tmpHandle));\n          if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION))\n            goto exception;\n          tmpHandle.clear();\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(AddEmptyString) = strRes->getHermesValue();\n          ip = NEXTINST(AddEmptyString);\n        }\n        DISPATCH;\n      }\n\n      CASE(Jmp) {\n        ip = IPADD(ip->iJmp.op1);\n        DISPATCH;\n      }\n      CASE(JmpLong) {\n        ip = IPADD(ip->iJmpLong.op1);\n        DISPATCH;\n      }\n      CASE(JmpTrue) {\n        if (toBoolean(O2REG(JmpTrue)))\n          ip = IPADD(ip->iJmpTrue.op1);\n        else\n          ip = NEXTINST(JmpTrue);\n        DISPATCH;\n      }\n      CASE(JmpTrueLong) {\n        if (toBoolean(O2REG(JmpTrueLong)))\n          ip = IPADD(ip->iJmpTrueLong.op1);\n        else\n          ip = NEXTINST(JmpTrueLong);\n        DISPATCH;\n      }\n      CASE(JmpFalse) {\n        if (!toBoolean(O2REG(JmpFalse)))\n          ip = IPADD(ip->iJmpFalse.op1);\n        else\n          ip = NEXTINST(JmpFalse);\n        DISPATCH;\n      }\n      CASE(JmpFalseLong) {\n        if (!toBoolean(O2REG(JmpFalseLong)))\n          ip = IPADD(ip->iJmpFalseLong.op1);\n        else\n          ip = NEXTINST(JmpFalseLong);\n        DISPATCH;\n      }\n      CASE(JmpUndefined) {\n        if (O2REG(JmpUndefined).isUndefined())\n          ip = IPADD(ip->iJmpUndefined.op1);\n        else\n          ip = NEXTINST(JmpUndefined);\n        DISPATCH;\n      }\n      CASE(JmpUndefinedLong) {\n        if (O2REG(JmpUndefinedLong).isUndefined())\n          ip = IPADD(ip->iJmpUndefinedLong.op1);\n        else\n          ip = NEXTINST(JmpUndefinedLong);\n        DISPATCH;\n      }\n      CASE(Add) {\n        if (LLVM_LIKELY(\n                O2REG(Add).isNumber() &&\n                O3REG(Add).isNumber())) { /* Fast-path. */\n          CASE(AddN) {\n            O1REG(Add) = HermesValue::encodeDoubleValue(\n                O2REG(Add).getNumber() + O3REG(Add).getNumber());\n            ip = NEXTINST(Add);\n            DISPATCH;\n          }\n        }\n        CAPTURE_IP_ASSIGN(\n            res,\n            addOp_RJS(runtime, Handle<>(&O2REG(Add)), Handle<>(&O3REG(Add))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(Add) = res.getValue();\n        ip = NEXTINST(Add);\n        DISPATCH;\n      }\n\n      CASE(BitNot) {\n        if (LLVM_LIKELY(O2REG(BitNot).isNumber())) { /* Fast-path. */\n          O1REG(BitNot) = HermesValue::encodeDoubleValue(\n              ~hermes::truncateToInt32(O2REG(BitNot).getNumber()));\n          ip = NEXTINST(BitNot);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(res, toInt32_RJS(runtime, Handle<>(&O2REG(BitNot))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(BitNot) = HermesValue::encodeDoubleValue(\n            ~static_cast<int32_t>(res->getNumber()));\n        ip = NEXTINST(BitNot);\n        DISPATCH;\n      }\n\n      CASE(GetArgumentsLength) {\n        // If the arguments object hasn't been created yet.\n        if (O2REG(GetArgumentsLength).isUndefined()) {\n          O1REG(GetArgumentsLength) =\n              HermesValue::encodeNumberValue(FRAME.getArgCount());\n          ip = NEXTINST(GetArgumentsLength);\n          DISPATCH;\n        }\n        // The arguments object has been created, so this is a regular property\n        // get.\n        assert(\n            O2REG(GetArgumentsLength).isObject() &&\n            \"arguments lazy register is not an object\");\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            JSObject::getNamed_RJS(\n                Handle<JSObject>::vmcast(&O2REG(GetArgumentsLength)),\n                runtime,\n                Predefined::getSymbolID(Predefined::length)));\n        if (resPH == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetArgumentsLength) = resPH->get();\n        ip = NEXTINST(GetArgumentsLength);\n        DISPATCH;\n      }\n\n      CASE(GetArgumentsPropByVal) {\n        // If the arguments object hasn't been created yet and we have a\n        // valid integer index, we use the fast path.\n        if (O3REG(GetArgumentsPropByVal).isUndefined()) {\n          // If this is an integer index.\n          if (auto index = toArrayIndexFastPath(O2REG(GetArgumentsPropByVal))) {\n            // Is this an existing argument?\n            if (*index < FRAME.getArgCount()) {\n              O1REG(GetArgumentsPropByVal) = FRAME.getArgRef(*index);\n              ip = NEXTINST(GetArgumentsPropByVal);\n              DISPATCH;\n            }\n          }\n        }\n        // Slow path.\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            getArgumentsPropByValSlowPath_RJS(\n                runtime,\n                &O3REG(GetArgumentsPropByVal),\n                &O2REG(GetArgumentsPropByVal),\n                FRAME.getCalleeClosureHandleUnsafe(),\n                strictMode));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(GetArgumentsPropByVal) = res->getHermesValue();\n        ip = NEXTINST(GetArgumentsPropByVal);\n        DISPATCH;\n      }\n\n      CASE(ReifyArguments) {\n        // If the arguments object was already created, do nothing.\n        if (!O1REG(ReifyArguments).isUndefined()) {\n          assert(\n              O1REG(ReifyArguments).isObject() &&\n              \"arguments lazy register is not an object\");\n          ip = NEXTINST(ReifyArguments);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(\n            resArgs,\n            reifyArgumentsSlowPath(\n                runtime, FRAME.getCalleeClosureHandleUnsafe(), strictMode));\n        if (LLVM_UNLIKELY(resArgs == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(ReifyArguments) = resArgs->getHermesValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(ReifyArguments);\n        DISPATCH;\n      }\n\n      CASE(NewObject) {\n        // Create a new object using the built-in constructor. Note that the\n        // built-in constructor is empty, so we don't actually need to call\n        // it.\n        CAPTURE_IP_ASSIGN(\n            O1REG(NewObject), JSObject::create(runtime).getHermesValue());\n        assert(\n            gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n            \"Should not create handles.\");\n        ip = NEXTINST(NewObject);\n        DISPATCH;\n      }\n      CASE(NewObjectWithParent) {\n        CAPTURE_IP_ASSIGN(\n            O1REG(NewObjectWithParent),\n            JSObject::create(\n                runtime,\n                O2REG(NewObjectWithParent).isObject()\n                    ? Handle<JSObject>::vmcast(&O2REG(NewObjectWithParent))\n                    : O2REG(NewObjectWithParent).isNull()\n                        ? Runtime::makeNullHandle<JSObject>()\n                        : Handle<JSObject>::vmcast(&runtime->objectPrototype))\n                .getHermesValue());\n        assert(\n            gcScope.getHandleCountDbg() == KEEP_HANDLES &&\n            \"Should not create handles.\");\n        ip = NEXTINST(NewObjectWithParent);\n        DISPATCH;\n      }\n\n      CASE(NewObjectWithBuffer) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createObjectFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewObjectWithBuffer.op3,\n                ip->iNewObjectWithBuffer.op4,\n                ip->iNewObjectWithBuffer.op5));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewObjectWithBuffer) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewObjectWithBuffer);\n        DISPATCH;\n      }\n\n      CASE(NewObjectWithBufferLong) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createObjectFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewObjectWithBufferLong.op3,\n                ip->iNewObjectWithBufferLong.op4,\n                ip->iNewObjectWithBufferLong.op5));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewObjectWithBufferLong) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewObjectWithBufferLong);\n        DISPATCH;\n      }\n\n      CASE(NewArray) {\n        // Create a new array using the built-in constructor. Note that the\n        // built-in constructor is empty, so we don't actually need to call\n        // it.\n        CAPTURE_IP_ASSIGN(\n            auto createRes,\n            JSArray::create(runtime, ip->iNewArray.op2, ip->iNewArray.op2));\n        if (createRes == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        O1REG(NewArray) = createRes->getHermesValue();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(NewArray);\n        DISPATCH;\n      }\n\n      CASE(NewArrayWithBuffer) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createArrayFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewArrayWithBuffer.op2,\n                ip->iNewArrayWithBuffer.op3,\n                ip->iNewArrayWithBuffer.op4));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewArrayWithBuffer) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(NewArrayWithBuffer);\n        DISPATCH;\n      }\n\n      CASE(NewArrayWithBufferLong) {\n        CAPTURE_IP_ASSIGN(\n            resPH,\n            Interpreter::createArrayFromBuffer(\n                runtime,\n                curCodeBlock,\n                ip->iNewArrayWithBufferLong.op2,\n                ip->iNewArrayWithBufferLong.op3,\n                ip->iNewArrayWithBufferLong.op4));\n        if (LLVM_UNLIKELY(resPH == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(NewArrayWithBufferLong) = resPH->get();\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(NewArrayWithBufferLong);\n        DISPATCH;\n      }\n\n      CASE(CreateThis) {\n        // Registers: output, prototype, closure.\n        if (LLVM_UNLIKELY(!vmisa<Callable>(O3REG(CreateThis)))) {\n          CAPTURE_IP(runtime->raiseTypeError(\"constructor is not callable\"));\n          goto exception;\n        }\n        CAPTURE_IP_ASSIGN(\n            auto res,\n            Callable::newObject(\n                Handle<Callable>::vmcast(&O3REG(CreateThis)),\n                runtime,\n                Handle<JSObject>::vmcast(\n                    O2REG(CreateThis).isObject() ? &O2REG(CreateThis)\n                                                 : &runtime->objectPrototype)));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(CreateThis) = res->getHermesValue();\n        ip = NEXTINST(CreateThis);\n        DISPATCH;\n      }\n\n      CASE(SelectObject) {\n        // Registers: output, thisObject, constructorReturnValue.\n        O1REG(SelectObject) = O3REG(SelectObject).isObject()\n            ? O3REG(SelectObject)\n            : O2REG(SelectObject);\n        ip = NEXTINST(SelectObject);\n        DISPATCH;\n      }\n\n      CASE(Eq)\n      CASE(Neq) {\n        CAPTURE_IP_ASSIGN(\n            res,\n            abstractEqualityTest_RJS(\n                runtime, Handle<>(&O2REG(Eq)), Handle<>(&O3REG(Eq))));\n        if (res == ExecutionStatus::EXCEPTION) {\n          goto exception;\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        O1REG(Eq) = ip->opCode == OpCode::Eq\n            ? res.getValue()\n            : HermesValue::encodeBoolValue(!res->getBool());\n        ip = NEXTINST(Eq);\n        DISPATCH;\n      }\n      CASE(StrictEq) {\n        O1REG(StrictEq) = HermesValue::encodeBoolValue(\n            strictEqualityTest(O2REG(StrictEq), O3REG(StrictEq)));\n        ip = NEXTINST(StrictEq);\n        DISPATCH;\n      }\n      CASE(StrictNeq) {\n        O1REG(StrictNeq) = HermesValue::encodeBoolValue(\n            !strictEqualityTest(O2REG(StrictNeq), O3REG(StrictNeq)));\n        ip = NEXTINST(StrictNeq);\n        DISPATCH;\n      }\n      CASE(Not) {\n        O1REG(Not) = HermesValue::encodeBoolValue(!toBoolean(O2REG(Not)));\n        ip = NEXTINST(Not);\n        DISPATCH;\n      }\n      CASE(Negate) {\n        if (LLVM_LIKELY(O2REG(Negate).isNumber())) {\n          O1REG(Negate) =\n              HermesValue::encodeDoubleValue(-O2REG(Negate).getNumber());\n        } else {\n          CAPTURE_IP_ASSIGN(\n              res, toNumber_RJS(runtime, Handle<>(&O2REG(Negate))));\n          if (res == ExecutionStatus::EXCEPTION)\n            goto exception;\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n          O1REG(Negate) = HermesValue::encodeDoubleValue(-res->getNumber());\n        }\n        ip = NEXTINST(Negate);\n        DISPATCH;\n      }\n      CASE(TypeOf) {\n        CAPTURE_IP_ASSIGN(\n            O1REG(TypeOf), typeOf(runtime, Handle<>(&O2REG(TypeOf))));\n        ip = NEXTINST(TypeOf);\n        DISPATCH;\n      }\n      CASE(Mod) {\n        // We use fmod here for simplicity. Theoretically fmod behaves slightly\n        // differently than the ECMAScript Spec. fmod applies round-towards-zero\n        // for the remainder when it's not representable by a double; while the\n        // spec requires round-to-nearest. As an example, 5 % 0.7 will give\n        // 0.10000000000000031 using fmod, but using the rounding style\n        // described\n        // by the spec, the output should really be 0.10000000000000053.\n        // Such difference can be ignored in practice.\n        if (LLVM_LIKELY(O2REG(Mod).isNumber() && O3REG(Mod).isNumber())) {\n          /* Fast-path. */\n          O1REG(Mod) = HermesValue::encodeDoubleValue(\n              std::fmod(O2REG(Mod).getNumber(), O3REG(Mod).getNumber()));\n          ip = NEXTINST(Mod);\n          DISPATCH;\n        }\n        CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O2REG(Mod))));\n        if (res == ExecutionStatus::EXCEPTION)\n          goto exception;\n        double left = res->getDouble();\n        CAPTURE_IP_ASSIGN(res, toNumber_RJS(runtime, Handle<>(&O3REG(Mod))));\n        if (res == ExecutionStatus::EXCEPTION)\n          goto exception;\n        O1REG(Mod) =\n            HermesValue::encodeDoubleValue(std::fmod(left, res->getDouble()));\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(Mod);\n        DISPATCH;\n      }\n      CASE(InstanceOf) {\n        CAPTURE_IP_ASSIGN(\n            auto result,\n            instanceOfOperator_RJS(\n                runtime,\n                Handle<>(&O2REG(InstanceOf)),\n                Handle<>(&O3REG(InstanceOf))));\n        if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(InstanceOf) = HermesValue::encodeBoolValue(*result);\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(InstanceOf);\n        DISPATCH;\n      }\n      CASE(IsIn) {\n        {\n          if (LLVM_UNLIKELY(!O3REG(IsIn).isObject())) {\n            CAPTURE_IP(runtime->raiseTypeError(\n                \"right operand of 'in' is not an object\"));\n            goto exception;\n          }\n          CAPTURE_IP_ASSIGN(\n              auto cr,\n              JSObject::hasComputed(\n                  Handle<JSObject>::vmcast(&O3REG(IsIn)),\n                  runtime,\n                  Handle<>(&O2REG(IsIn))));\n          if (cr == ExecutionStatus::EXCEPTION) {\n            goto exception;\n          }\n          O1REG(IsIn) = HermesValue::encodeBoolValue(*cr);\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(IsIn);\n        DISPATCH;\n      }\n\n      CASE(PutNewOwnByIdShort) {\n        nextIP = NEXTINST(PutNewOwnByIdShort);\n        idVal = ip->iPutNewOwnByIdShort.op3;\n        goto putOwnById;\n      }\n      CASE(PutNewOwnNEByIdLong)\n      CASE(PutNewOwnByIdLong) {\n        nextIP = NEXTINST(PutNewOwnByIdLong);\n        idVal = ip->iPutNewOwnByIdLong.op3;\n        goto putOwnById;\n      }\n      CASE(PutNewOwnNEById)\n      CASE(PutNewOwnById) {\n        nextIP = NEXTINST(PutNewOwnById);\n        idVal = ip->iPutNewOwnById.op3;\n      }\n    putOwnById : {\n      assert(\n          O1REG(PutNewOwnById).isObject() &&\n          \"Object argument of PutNewOwnById must be an object\");\n      CAPTURE_IP_ASSIGN(\n          auto res,\n          JSObject::defineNewOwnProperty(\n              Handle<JSObject>::vmcast(&O1REG(PutNewOwnById)),\n              runtime,\n              ID(idVal),\n              ip->opCode <= OpCode::PutNewOwnByIdLong\n                  ? PropertyFlags::defaultNewNamedPropertyFlags()\n                  : PropertyFlags::nonEnumerablePropertyFlags(),\n              Handle<>(&O2REG(PutNewOwnById))));\n      if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n        goto exception;\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(DelByIdLong) {\n        idVal = ip->iDelByIdLong.op3;\n        nextIP = NEXTINST(DelByIdLong);\n        goto DelById;\n      }\n\n      CASE(DelById) {\n        idVal = ip->iDelById.op3;\n        nextIP = NEXTINST(DelById);\n      }\n    DelById : {\n      if (LLVM_LIKELY(O2REG(DelById).isObject())) {\n        CAPTURE_IP_ASSIGN(\n            auto status,\n            JSObject::deleteNamed(\n                Handle<JSObject>::vmcast(&O2REG(DelById)),\n                runtime,\n                ID(idVal),\n                defaultPropOpFlags));\n        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());\n      } else {\n        // This is the \"slow path\".\n        CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelById))));\n        if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n          // If an exception is thrown, likely we are trying to convert\n          // undefined/null to an object. Passing over the name of the property\n          // so that we could emit more meaningful error messages.\n          CAPTURE_IP(amendPropAccessErrorMsgWithPropName(\n              runtime, Handle<>(&O2REG(DelById)), \"delete\", ID(idVal)));\n          goto exception;\n        }\n        tmpHandle = res.getValue();\n        CAPTURE_IP_ASSIGN(\n            auto status,\n            JSObject::deleteNamed(\n                Handle<JSObject>::vmcast(tmpHandle),\n                runtime,\n                ID(idVal),\n                defaultPropOpFlags));\n        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n          goto exception;\n        }\n        O1REG(DelById) = HermesValue::encodeBoolValue(status.getValue());\n        tmpHandle.clear();\n      }\n      gcScope.flushToSmallCount(KEEP_HANDLES);\n      ip = nextIP;\n      DISPATCH;\n    }\n\n      CASE(DelByVal) {\n        if (LLVM_LIKELY(O2REG(DelByVal).isObject())) {\n          CAPTURE_IP_ASSIGN(\n              auto status,\n              JSObject::deleteComputed(\n                  Handle<JSObject>::vmcast(&O2REG(DelByVal)),\n                  runtime,\n                  Handle<>(&O3REG(DelByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());\n        } else {\n          // This is the \"slow path\".\n          CAPTURE_IP_ASSIGN(res, toObject(runtime, Handle<>(&O2REG(DelByVal))));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          tmpHandle = res.getValue();\n          CAPTURE_IP_ASSIGN(\n              auto status,\n              JSObject::deleteComputed(\n                  Handle<JSObject>::vmcast(tmpHandle),\n                  runtime,\n                  Handle<>(&O3REG(DelByVal)),\n                  defaultPropOpFlags));\n          if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          O1REG(DelByVal) = HermesValue::encodeBoolValue(status.getValue());\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        tmpHandle.clear();\n        ip = NEXTINST(DelByVal);\n        DISPATCH;\n      }\n      CASE(CreateRegExp) {\n        {\n          // Create the RegExp object.\n          CAPTURE_IP_ASSIGN(auto re, JSRegExp::create(runtime));\n          // Initialize the regexp.\n          CAPTURE_IP_ASSIGN(\n              auto pattern,\n              runtime->makeHandle(curCodeBlock->getRuntimeModule()\n                                      ->getStringPrimFromStringIDMayAllocate(\n                                          ip->iCreateRegExp.op2)));\n          CAPTURE_IP_ASSIGN(\n              auto flags,\n              runtime->makeHandle(curCodeBlock->getRuntimeModule()\n                                      ->getStringPrimFromStringIDMayAllocate(\n                                          ip->iCreateRegExp.op3)));\n          CAPTURE_IP_ASSIGN(\n              auto bytecode,\n              curCodeBlock->getRuntimeModule()->getRegExpBytecodeFromRegExpID(\n                  ip->iCreateRegExp.op4));\n          CAPTURE_IP_ASSIGN(\n              auto initRes,\n              JSRegExp::initialize(re, runtime, pattern, flags, bytecode));\n          if (LLVM_UNLIKELY(initRes == ExecutionStatus::EXCEPTION)) {\n            goto exception;\n          }\n          // Done, return the new object.\n          O1REG(CreateRegExp) = re.getHermesValue();\n        }\n        gcScope.flushToSmallCount(KEEP_HANDLES);\n        ip = NEXTINST(CreateRegExp);\n        DISPATCH;\n      }\n\n      CASE(SwitchImm) {\n        if (LLVM_LIKELY(O1REG(SwitchImm).isNumber())) {\n          double numVal = O1REG(SwitchImm).getNumber();\n          uint32_t uintVal = (uint32_t)numVal;\n          if (LLVM_LIKELY(numVal == uintVal) && // Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && // Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) // Bounds checking.\n          {\n            // Calculate the offset into the bytecode where the jump table for\n            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            // Must be signed to account for backwards branching.\n            const int32_t *loc =\n                (const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        // Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(\n          LoadConstUInt8,\n          HermesValue::encodeDoubleValue(ip->iLoadConstUInt8.op2));\n      LOAD_CONST(\n          LoadConstInt, HermesValue::encodeDoubleValue(ip->iLoadConstInt.op2));\n      LOAD_CONST(\n          LoadConstDouble,\n          HermesValue::encodeDoubleValue(ip->iLoadConstDouble.op2));\n      LOAD_CONST_CAPTURE_IP(\n          LoadConstString,\n          HermesValue::encodeStringValue(\n              curCodeBlock->getRuntimeModule()\n                  ->getStringPrimFromStringIDMayAllocate(\n                      ip->iLoadConstString.op2)));\n      LOAD_CONST_CAPTURE_IP(\n          LoadConstStringLongIndex,\n          HermesValue::encodeStringValue(\n              curCodeBlock->getRuntimeModule()\n                  ->getStringPrimFromStringIDMayAllocate(\n                      ip->iLoadConstStringLongIndex.op2)));\n      LOAD_CONST(LoadConstUndefined, HermesValue::encodeUndefinedValue());\n      LOAD_CONST(LoadConstNull, HermesValue::encodeNullValue());\n      LOAD_CONST(LoadConstTrue, HermesValue::encodeBoolValue(true));\n      LOAD_CONST(LoadConstFalse, HermesValue::encodeBoolValue(false));\n      LOAD_CONST(LoadConstZero, HermesValue::encodeDoubleValue(0));\n      BINOP(Sub, doSub);\n      BINOP(Mul, doMult);\n      BINOP(Div, doDiv);\n      BITWISEBINOP(BitAnd, &);\n      BITWISEBINOP(BitOr, |);\n      BITWISEBINOP(BitXor, ^);\n      // For LShift, we need to use toUInt32 first because lshift on negative\n      // numbers is undefined behavior in theory.\n      SHIFTOP(LShift, <<, toUInt32_RJS, uint32_t, int32_t);\n      SHIFTOP(RShift, >>, toInt32_RJS, int32_t, int32_t);\n      SHIFTOP(URshift, >>, toUInt32_RJS, uint32_t, uint32_t);\n      CONDOP(Less, <, lessOp_RJS);\n      CONDOP(LessEq, <=, lessEqualOp_RJS);\n      CONDOP(Greater, >, greaterOp_RJS);\n      CONDOP(GreaterEq, >=, greaterEqualOp_RJS);\n      JCOND(Less, <, lessOp_RJS);\n      JCOND(LessEqual, <=, lessEqualOp_RJS);\n      JCOND(Greater, >, greaterOp_RJS);\n      JCOND(GreaterEqual, >=, greaterEqualOp_RJS);\n\n      JCOND_STRICT_EQ_IMPL(\n          JStrictEqual, , IPADD(ip->iJStrictEqual.op1), NEXTINST(JStrictEqual));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictEqual,\n          Long,\n          IPADD(ip->iJStrictEqualLong.op1),\n          NEXTINST(JStrictEqualLong));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictNotEqual,\n          ,\n          NEXTINST(JStrictNotEqual),\n          IPADD(ip->iJStrictNotEqual.op1));\n      JCOND_STRICT_EQ_IMPL(\n          JStrictNotEqual,\n          Long,\n          NEXTINST(JStrictNotEqualLong),\n          IPADD(ip->iJStrictNotEqualLong.op1));\n\n      JCOND_EQ_IMPL(JEqual, , IPADD(ip->iJEqual.op1), NEXTINST(JEqual));\n      JCOND_EQ_IMPL(\n          JEqual, Long, IPADD(ip->iJEqualLong.op1), NEXTINST(JEqualLong));\n      JCOND_EQ_IMPL(\n          JNotEqual, , NEXTINST(JNotEqual), IPADD(ip->iJNotEqual.op1));\n      JCOND_EQ_IMPL(\n          JNotEqual,\n          Long,\n          NEXTINST(JNotEqualLong),\n          IPADD(ip->iJNotEqualLong.op1));\n\n      CASE_OUTOFLINE(PutOwnByVal);\n      CASE_OUTOFLINE(PutOwnGetterSetterByVal);\n      CASE_OUTOFLINE(DirectEval);\n\n      CASE_OUTOFLINE(IteratorBegin);\n      CASE_OUTOFLINE(IteratorNext);\n      CASE(IteratorClose) {\n        if (LLVM_UNLIKELY(O1REG(IteratorClose).isObject())) {\n          // The iterator must be closed if it's still an object.\n          // That means it was never an index and is not done iterating (a state\n          // which is indicated by `undefined`).\n          CAPTURE_IP_ASSIGN(\n              auto res,\n              iteratorClose(\n                  runtime,\n                  Handle<JSObject>::vmcast(&O1REG(IteratorClose)),\n                  Runtime::getEmptyValue()));\n          if (LLVM_UNLIKELY(res == ExecutionStatus::EXCEPTION)) {\n            if (ip->iIteratorClose.op2 &&\n                !isUncatchableError(runtime->thrownValue_)) {\n              // Ignore inner exception.\n              runtime->clearThrownValue();\n            } else {\n              goto exception;\n            }\n          }\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n        ip = NEXTINST(IteratorClose);\n        DISPATCH;\n      }\n\n      CASE(_last) {\n        llvm_unreachable(\"Invalid opcode _last\");\n      }\n    }\n\n    llvm_unreachable(\"unreachable\");\n\n  // We arrive here if we couldn't allocate the registers for the current frame.\n  stackOverflow:\n    CAPTURE_IP(runtime->raiseStackOverflow(\n        Runtime::StackOverflowKind::JSRegisterStack));\n\n  // We arrive here when we raised an exception in a callee, but we don't want\n  // the callee to be able to handle it.\n  handleExceptionInParent:\n    // Restore the caller code block and IP.\n    curCodeBlock = FRAME.getSavedCodeBlock();\n    ip = FRAME.getSavedIP();\n\n    // Pop to the previous frame where technically the error happened.\n    frameRegs =\n        &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n    // If we are coming from native code, return.\n    if (!curCodeBlock)\n      return ExecutionStatus::EXCEPTION;\n\n// Return because of recursive calling structure\n#ifdef HERMESVM_PROFILER_EXTERN\n    return ExecutionStatus::EXCEPTION;\n#endif\n  // Handle the exception.\n  exception:\n    UPDATE_OPCODE_TIME_SPENT;\n    assert(\n        !runtime->thrownValue_.isEmpty() &&\n        \"thrownValue unavailable at exception\");\n\n    bool catchable = true;\n    // If this is an Error object that was thrown internally, it didn't have\n    // access to the current codeblock and IP, so collect the stack trace here.\n    if (auto *jsError = dyn_vmcast<JSError>(runtime->thrownValue_)) {\n      catchable = jsError->catchable();\n      if (!jsError->getStackTrace()) {\n        // Temporarily clear the thrown value for following operations.\n        CAPTURE_IP_ASSIGN(\n            auto errorHandle,\n            runtime->makeHandle(vmcast<JSError>(runtime->thrownValue_)));\n        runtime->clearThrownValue();\n\n        CAPTURE_IP(JSError::recordStackTrace(\n            errorHandle, runtime, false, curCodeBlock, ip));\n\n        // Restore the thrown value.\n        runtime->setThrownValue(errorHandle.getHermesValue());\n      }\n    }\n\n    gcScope.flushToSmallCount(KEEP_HANDLES);\n    tmpHandle.clear();\n\n#ifdef HERMES_ENABLE_DEBUGGER\n    if (SingleStep) {\n      // If we're single stepping, don't bother with any more checks,\n      // and simply signal that we should continue execution with an exception.\n      state.codeBlock = curCodeBlock;\n      state.offset = CUROFFSET;\n      return ExecutionStatus::EXCEPTION;\n    }\n\n    using PauseOnThrowMode = facebook::hermes::debugger::PauseOnThrowMode;\n    auto mode = runtime->debugger_.getPauseOnThrowMode();\n    if (mode != PauseOnThrowMode::None) {\n      if (!runtime->debugger_.isDebugging()) {\n        // Determine whether the PauseOnThrowMode requires us to stop here.\n        bool caught =\n            runtime->debugger_\n                .findCatchTarget(InterpreterState(curCodeBlock, CUROFFSET))\n                .hasValue();\n        bool shouldStop = mode == PauseOnThrowMode::All ||\n            (mode == PauseOnThrowMode::Uncaught && !caught);\n        if (shouldStop) {\n          // When runDebugger is invoked after an exception,\n          // stepping should never happen internally.\n          // Any step is a step to an exception handler, which we do\n          // directly here in the interpreter.\n          // Thus, the result state should be the same as the input state.\n          InterpreterState tmpState{curCodeBlock, (uint32_t)CUROFFSET};\n          CAPTURE_IP_ASSIGN(\n              ExecutionStatus resultStatus,\n              runtime->debugger_.runDebugger(\n                  Debugger::RunReason::Exception, tmpState));\n          (void)resultStatus;\n          assert(\n              tmpState == InterpreterState(curCodeBlock, CUROFFSET) &&\n              \"not allowed to step internally in a pauseOnThrow\");\n          gcScope.flushToSmallCount(KEEP_HANDLES);\n        }\n      }\n    }\n#endif\n\n    int32_t handlerOffset = 0;\n\n    // If the exception is not catchable, skip found catch blocks.\n    while (((handlerOffset = curCodeBlock->findCatchTargetOffset(CUROFFSET)) ==\n            -1) ||\n           !catchable) {\n      PROFILER_EXIT_FUNCTION(curCodeBlock);\n\n#ifdef HERMES_ENABLE_ALLOCATION_LOCATION_TRACES\n      runtime->popCallStack();\n#endif\n\n      // Restore the code block and IP.\n      curCodeBlock = FRAME.getSavedCodeBlock();\n      ip = FRAME.getSavedIP();\n\n      // Pop a stack frame.\n      frameRegs =\n          &runtime->restoreStackAndPreviousFrame(FRAME).getFirstLocalRef();\n\n      SLOW_DEBUG(\n          dbgs() << \"function exit with exception: restored stackLevel=\"\n                 << runtime->getStackLevel() << \"\\n\");\n\n      // Are we returning to native code?\n      if (!curCodeBlock) {\n        SLOW_DEBUG(\n            dbgs()\n            << \"function exit with exception: returning to native code\\n\");\n        return ExecutionStatus::EXCEPTION;\n      }\n\n      assert(\n          isCallType(ip->opCode) &&\n          \"return address is not Call-type instruction\");\n\n// Return because of recursive calling structure\n#ifdef HERMESVM_PROFILER_EXTERN\n      return ExecutionStatus::EXCEPTION;\n#endif\n    }\n\n    INIT_STATE_FOR_CODEBLOCK(curCodeBlock);\n\n    ip = IPADD(handlerOffset - CUROFFSET);\n  }\n}\n\n} // namespace vm\n} // namespace hermes\n", "/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// RUN: %hermes %s | %FileCheck --match-full-lines %s\n// RUN: %hermes -O %s | %FileCheck --match-full-lines %s\n\nfunction show(iterResult) {\n  print(iterResult.value, '|', iterResult.done);\n}\n\nprint('generators');;\n// CHECK-LABEL: generators\n\nfunction* simple() {\n  yield 1;\n}\n\nvar it = simple();\nshow(it.next());\n// CHECK-NEXT: 1 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\ntry {\n  new simple();\n  print('must throw');\n} catch (e) {\n  print('caught', e.name);\n}\n// CHECK-NEXT: caught TypeError\n\nfunction *useArgs(x, y) {\n  yield x;\n  yield x + 1;\n  ++x;\n  yield x + y;\n}\n\nvar it = useArgs(100, 10);\nshow(it.next());\n// CHECK-NEXT: 100 | false\nshow(it.next());\n// CHECK-NEXT: 101 | false\nshow(it.next());\n// CHECK-NEXT: 111 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *locals(x,y) {\n  var a,b,c;\n  a = 4;\n  yield a;\n  b = a + 5;\n  yield b;\n  c = b + 6;\n  yield c;\n}\n\nvar it = locals(10, 42);\nshow(it.next());\n// CHECK-NEXT: 4 | false\nshow(it.next());\n// CHECK-NEXT: 9 | false\nshow(it.next());\n// CHECK-NEXT: 15 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *args() {\n  yield arguments[0];\n  yield arguments[1];\n}\n\nvar it = args(184, 457);\nshow(it.next());\n// CHECK-NEXT: 184 | false\nshow(it.next());\n// CHECK-NEXT: 457 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction* thrower(x, y) {\n  try {\n    print('in try');\n    yield 1;\n  } catch (e) {\n    print('in catch');\n    yield e;\n    return x;\n  } finally {\n    print('in finally');\n    return y;\n  }\n}\n\nvar it = thrower(10, 20);\nshow(it.next(15));\n// CHECK-NEXT: in try\n// CHECK-NEXT: 1 | false\nshow(it.throw('MY ERROR'));\n// CHECK-NEXT: in catch\n// CHECK-NEXT: MY ERROR | false\nshow(it.throw());\n// CHECK-NEXT: in finally\n// CHECK-NEXT: 20 | true\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *returning(x, y) {\n  try {\n    print('try');\n    yield x;\n  } finally {\n    print('finally');\n    yield y;\n  }\n}\n\nvar it = returning(10, 20);\nshow(it.next(15));\n// CHECK-NEXT: try\n// CHECK-NEXT: 10 | false\nshow(it.return('MY RETVAL'));\n// CHECK-NEXT: finally\n// CHECK-NEXT: 20 | false\nshow(it.next());\n// CHECK-NEXT: MY RETVAL | true\n\n// Ensures that the StartGenerator instruction is moved to the start\n// of the function after optimizations.\nfunction *localsTry() {\n  var x = 0;\n  try {\n    yield x;\n  } catch (e) {\n  }\n}\n\nvar it = localsTry();\nshow(it.next());\n// CHECK-NEXT: 0 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *simpleDelegate() {\n  yield* [1,2,3];\n}\n\nvar it = simpleDelegate();\nshow(it.next());\n// CHECK-NEXT: 1 | false\nshow(it.next());\n// CHECK-NEXT: 2 | false\nshow(it.next());\n// CHECK-NEXT: 3 | false\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nfunction *tryCatchDelegate() {\n  function *gen() {\n    try {\n      yield 1;\n      yield 2;\n      yield 3;\n    } catch (e) {\n      print('gen caught', e);\n      return 292;\n    } finally {\n      print('gen finally');\n    }\n  }\n\n  try {\n    var x = yield* gen();\n  } catch (e) {\n    print('outer caught', e);\n    return 193;\n  } finally {\n    print('outer finally');\n  }\n  print('out of the try', x);\n  return 1092;\n}\n\nvar it = tryCatchDelegate()\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.return('c'));\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: c | true\n\nvar it = tryCatchDelegate()\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.throw('c'));\n// CHECK-NEXT: gen caught c\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: out of the try 292\n// CHECK-NEXT: 1092 | true\n\nfunction *complexDelegate() {\n  function *gen() {\n    try {\n      yield 1;\n      yield 2;\n      yield 3;\n    } catch (e) {\n      print('gen caught', e);\n      return 292;\n    } finally {\n      print('gen finally');\n      yield 919;\n      return 100;\n    }\n  }\n\n  try {\n    var x = yield* gen();\n  } catch (e) {\n    print('outer caught', e);\n    return 193;\n  } finally {\n    print('outer finally');\n    return 101;\n  }\n  print(x);\n}\n\nvar it = complexDelegate();\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.return('c'));\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: 919 | false\nshow(it.next('d'));\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: 101 | true\nshow(it.next('e'));\n// CHECK-NEXT: undefined | true\n\nvar it = complexDelegate();\nshow(it.next('a'));\n// CHECK-NEXT: 1 | false\nshow(it.next('b'));\n// CHECK-NEXT: 2 | false\nshow(it.throw('c'));\n// CHECK-NEXT: gen caught c\n// CHECK-NEXT: gen finally\n// CHECK-NEXT: 919 | false\nshow(it.next('d'));\n// CHECK-NEXT: outer finally\n// CHECK-NEXT: 101 | true\nshow(it.next('e'));\n// CHECK-NEXT: undefined | true\n\n// Ensure that we don't unwrap/rewrap the value/done properties\n// of the results of .next(), and make sure that abrupt .return() works.\nfunction *iterDelegateWithSecret() {\n  var count = 0;\n  var iterable = {};\n  iterable[Symbol.iterator] = function() {\n    return {\n      next(x) {\n        print('from inside:', x, arguments.length);\n        count++;\n        return { value: count, done: count > 1, SECRET: 42 };\n      },\n      return() {\n        print('closing iterator');\n        return {};\n      }\n    }\n  }\n  yield* iterable;\n}\n\nvar it = iterDelegateWithSecret();\nvar result = it.next(1234);\n// CHECK-NEXT: from inside: undefined 1\nshow(result);\n// CHECK-NEXT: 1 | false\nprint(result.SECRET);\n// CHECK-NEXT: 42\nshow(it.next(1234));\n// CHECK-NEXT: from inside: 1234 1\n// CHECK-NEXT: undefined | true\nshow(it.next());\n// CHECK-NEXT: undefined | true\n\nvar it = iterDelegateWithSecret();\nshow(it.next());\n// CHECK-NEXT: from inside: undefined 1\n// CHECK-NEXT: 1 | false\ntry { it.throw() } catch(e) { print(e.name, e.message) }\n// CHECK-NEXT: closing iterator\n// CHECK-NEXT: TypeError yield* delegate must have a .throw() method\n\nvar iter = {\n  [Symbol.iterator]: function() {\n    print('OPEN')\n    return {\n      next: function() {\n        return { value: 42, done: false };\n      }\n    };\n  }\n};\n\nvar callCount = 0;\nvar f = function*([x]) {\n  print('START', x)\n  return 5;\n};\nprint(f.length);\n// CHECK-NEXT: 1\nvar it = f(iter);\n// CHECK-NEXT: OPEN\nshow(it.next())\n// CHECK-NEXT: START 42\n// CHECK-NEXT: 5 | true\n\nvar iterable = {\n  next() {\n    return { value: 1, done: false };\n  },\n  get return() {\n    print('get return');\n    return null;\n  },\n  [Symbol.iterator]() {\n    return iterable;\n  },\n};\n\nfunction* generator() {\n  yield* iterable;\n}\n\n// GetMethod returns undefined, so there shouldn't be an attempt to call.\nvar iterator = generator();\nprint(iterator.next().value);\niterator.return(123);\n// CHECK-NEXT: 1\n// CHECK-NEXT: get return\n\n// Make sure using SaveGeneratorLong works.\nfunction* saveGeneratorLong() {\n    yield* [1];\n    // Waste some registers, to change SaveGenerator to SaveGeneratorLong.\n    [].push(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n}\nprint(saveGeneratorLong().next().value);\n// CHECK-NEXT: 1\n"], "filenames": ["include/hermes/VM/Interpreter.h", "lib/VM/Interpreter-slowpaths.cpp", "lib/VM/Interpreter.cpp", "test/hermes/es6/generator.js"], "buggy_code_start_loc": [38, 11, 1002, 356], "buggy_code_end_loc": [38, 19, 1819, 356], "fixing_code_start_loc": [39, 12, 1003, 357], "fixing_code_end_loc": [47, 31, 1822, 372], "type": "CWE-670", "message": "A logic vulnerability when handling the SaveGeneratorLong instruction in Facebook Hermes prior to commit b2021df620824627f5a8c96615edbd1eb7fdddfc allows attackers to potentially read out of bounds or theoretically execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2020-1914", "sourceIdentifier": "cve-assign@fb.com", "published": "2020-10-08T19:15:12.080", "lastModified": "2020-10-20T18:28:34.340", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A logic vulnerability when handling the SaveGeneratorLong instruction in Facebook Hermes prior to commit b2021df620824627f5a8c96615edbd1eb7fdddfc allows attackers to potentially read out of bounds or theoretically execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una vulnerabilidad l\u00f3gica al manejar la instrucci\u00f3n SaveGeneratorLong en Facebook Hermes antes del commit b2021df620824627f5a8c96615edbd1eb7fdddfc, permite a atacantes leer potencialmente fuera de l\u00edmites o, te\u00f3ricamente, ejecutar c\u00f3digo arbitrario por medio de JavaScript dise\u00f1ado.&#xa0;Tome en cuenta que esto solo es explotable si la aplicaci\u00f3n que utiliza Hermes permite una evaluaci\u00f3n de un JavaScript que no es confiable.&#xa0;Por lo tanto, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1119"}, {"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-10-01", "matchCriteriaId": "0B207EF9-C6DF-4130-9607-BF7D986FE1AA"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/b2021df620824627f5a8c96615edbd1eb7fdddfc", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2020-1914", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/b2021df620824627f5a8c96615edbd1eb7fdddfc"}}