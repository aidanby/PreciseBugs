{"buggy_code": ["/*\n * nf_nat_snmp_basic.c\n *\n * Basic SNMP Application Layer Gateway\n *\n * This IP NAT module is intended for use with SNMP network\n * discovery and monitoring applications where target networks use\n * conflicting private address realms.\n *\n * Static NAT is used to remap the networks from the view of the network\n * management system at the IP layer, and this module remaps some application\n * layer addresses to match.\n *\n * The simplest form of ALG is performed, where only tagged IP addresses\n * are modified.  The module does not need to be MIB aware and only scans\n * messages at the ASN.1/BER level.\n *\n * Currently, only SNMPv1 and SNMPv2 are supported.\n *\n * More information on ALG and associated issues can be found in\n * RFC 2962\n *\n * The ASB.1/BER parsing code is derived from the gxsnmp package by Gregory\n * McLean & Jochen Friedrich, stripped down for use in the kernel.\n *\n * Copyright (c) 2000 RP Internet (www.rpi.net.au).\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: James Morris <jmorris@intercode.com.au>\n *\n * Copyright (c) 2006-2010 Patrick McHardy <kaber@trash.net>\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_snmp.h>\n#include \"nf_nat_snmp_basic.asn1.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\nMODULE_DESCRIPTION(\"Basic SNMP Application Layer Gateway\");\nMODULE_ALIAS(\"ip_nat_snmp_basic\");\nMODULE_ALIAS_NFCT_HELPER(\"snmp_trap\");\n\n#define SNMP_PORT 161\n#define SNMP_TRAP_PORT 162\n\nstatic DEFINE_SPINLOCK(snmp_lock);\n\nstruct snmp_ctx {\n\tunsigned char *begin;\n\t__sum16 *check;\n\t__be32 from;\n\t__be32 to;\n};\n\nstatic void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n{\n\tunsigned char s[12] = {0,};\n\tint size;\n\n\tif (offset & 1) {\n\t\tmemcpy(&s[1], &ctx->from, 4);\n\t\tmemcpy(&s[7], &ctx->to, 4);\n\t\ts[0] = ~0;\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\ts[4] = ~s[4];\n\t\ts[5] = ~0;\n\t\tsize = 12;\n\t} else {\n\t\tmemcpy(&s[0], &ctx->from, 4);\n\t\tmemcpy(&s[4], &ctx->to, 4);\n\t\ts[0] = ~s[0];\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\tsize = 8;\n\t}\n\t*ctx->check = csum_fold(csum_partial(s, size,\n\t\t\t\t\t     ~csum_unfold(*ctx->check)));\n}\n\nint snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}\n\nint snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}\n\nstatic int snmp_translate(struct nf_conn *ct, int dir, struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\tu16 datalen = ntohs(udph->len) - sizeof(struct udphdr);\n\tchar *data = (unsigned char *)udph + sizeof(struct udphdr);\n\tstruct snmp_ctx ctx;\n\tint ret;\n\n\tif (dir == IP_CT_DIR_ORIGINAL) {\n\t\tctx.from = ct->tuplehash[dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[!dir].tuple.dst.u3.ip;\n\t} else {\n\t\tctx.from = ct->tuplehash[!dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[dir].tuple.dst.u3.ip;\n\t}\n\n\tif (ctx.from == ctx.to)\n\t\treturn NF_ACCEPT;\n\n\tctx.begin = (unsigned char *)udph + sizeof(struct udphdr);\n\tctx.check = &udph->check;\n\tret = asn1_ber_decoder(&nf_nat_snmp_basic_decoder, &ctx, data, datalen);\n\tif (ret < 0) {\n\t\tnf_ct_helper_log(skb, ct, \"parser failed\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n/* We don't actually set up expectations, just adjust internal IP\n * addresses if this is being NATted\n */\nstatic int help(struct sk_buff *skb, unsigned int protoff,\n\t\tstruct nf_conn *ct,\n\t\tenum ip_conntrack_info ctinfo)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tunsigned int ret;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\n\t/* SNMP replies and originating SNMP traps get mangled */\n\tif (udph->source == htons(SNMP_PORT) && dir != IP_CT_DIR_REPLY)\n\t\treturn NF_ACCEPT;\n\tif (udph->dest == htons(SNMP_TRAP_PORT) && dir != IP_CT_DIR_ORIGINAL)\n\t\treturn NF_ACCEPT;\n\n\t/* No NAT? */\n\tif (!(ct->status & IPS_NAT_MASK))\n\t\treturn NF_ACCEPT;\n\n\t/* Make sure the packet length is ok.  So far, we were only guaranteed\n\t * to have a valid length IP header plus 8 bytes, which means we have\n\t * enough room for a UDP header.  Just verify the UDP length field so we\n\t * can mess around with the payload.\n\t */\n\tif (ntohs(udph->len) != skb->len - (iph->ihl << 2)) {\n\t\tnf_ct_helper_log(skb, ct, \"dropping malformed packet\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (!skb_make_writable(skb, skb->len)) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\treturn NF_DROP;\n\t}\n\n\tspin_lock_bh(&snmp_lock);\n\tret = snmp_translate(ct, dir, skb);\n\tspin_unlock_bh(&snmp_lock);\n\treturn ret;\n}\n\nstatic const struct nf_conntrack_expect_policy snmp_exp_policy = {\n\t.max_expected\t= 0,\n\t.timeout\t= 180,\n};\n\nstatic struct nf_conntrack_helper snmp_trap_helper __read_mostly = {\n\t.me\t\t\t= THIS_MODULE,\n\t.help\t\t\t= help,\n\t.expect_policy\t\t= &snmp_exp_policy,\n\t.name\t\t\t= \"snmp_trap\",\n\t.tuple.src.l3num\t= AF_INET,\n\t.tuple.src.u.udp.port\t= cpu_to_be16(SNMP_TRAP_PORT),\n\t.tuple.dst.protonum\t= IPPROTO_UDP,\n};\n\nstatic int __init nf_nat_snmp_basic_init(void)\n{\n\tBUG_ON(nf_nat_snmp_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, help);\n\n\treturn nf_conntrack_helper_register(&snmp_trap_helper);\n}\n\nstatic void __exit nf_nat_snmp_basic_fini(void)\n{\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, NULL);\n\tsynchronize_rcu();\n\tnf_conntrack_helper_unregister(&snmp_trap_helper);\n}\n\nmodule_init(nf_nat_snmp_basic_init);\nmodule_exit(nf_nat_snmp_basic_fini);\n"], "fixing_code": ["/*\n * nf_nat_snmp_basic.c\n *\n * Basic SNMP Application Layer Gateway\n *\n * This IP NAT module is intended for use with SNMP network\n * discovery and monitoring applications where target networks use\n * conflicting private address realms.\n *\n * Static NAT is used to remap the networks from the view of the network\n * management system at the IP layer, and this module remaps some application\n * layer addresses to match.\n *\n * The simplest form of ALG is performed, where only tagged IP addresses\n * are modified.  The module does not need to be MIB aware and only scans\n * messages at the ASN.1/BER level.\n *\n * Currently, only SNMPv1 and SNMPv2 are supported.\n *\n * More information on ALG and associated issues can be found in\n * RFC 2962\n *\n * The ASB.1/BER parsing code is derived from the gxsnmp package by Gregory\n * McLean & Jochen Friedrich, stripped down for use in the kernel.\n *\n * Copyright (c) 2000 RP Internet (www.rpi.net.au).\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, see <http://www.gnu.org/licenses/>.\n *\n * Author: James Morris <jmorris@intercode.com.au>\n *\n * Copyright (c) 2006-2010 Patrick McHardy <kaber@trash.net>\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <net/checksum.h>\n#include <net/udp.h>\n\n#include <net/netfilter/nf_nat.h>\n#include <net/netfilter/nf_conntrack_expect.h>\n#include <net/netfilter/nf_conntrack_helper.h>\n#include <linux/netfilter/nf_conntrack_snmp.h>\n#include \"nf_nat_snmp_basic.asn1.h\"\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\nMODULE_DESCRIPTION(\"Basic SNMP Application Layer Gateway\");\nMODULE_ALIAS(\"ip_nat_snmp_basic\");\nMODULE_ALIAS_NFCT_HELPER(\"snmp_trap\");\n\n#define SNMP_PORT 161\n#define SNMP_TRAP_PORT 162\n\nstatic DEFINE_SPINLOCK(snmp_lock);\n\nstruct snmp_ctx {\n\tunsigned char *begin;\n\t__sum16 *check;\n\t__be32 from;\n\t__be32 to;\n};\n\nstatic void fast_csum(struct snmp_ctx *ctx, unsigned char offset)\n{\n\tunsigned char s[12] = {0,};\n\tint size;\n\n\tif (offset & 1) {\n\t\tmemcpy(&s[1], &ctx->from, 4);\n\t\tmemcpy(&s[7], &ctx->to, 4);\n\t\ts[0] = ~0;\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\ts[4] = ~s[4];\n\t\ts[5] = ~0;\n\t\tsize = 12;\n\t} else {\n\t\tmemcpy(&s[0], &ctx->from, 4);\n\t\tmemcpy(&s[4], &ctx->to, 4);\n\t\ts[0] = ~s[0];\n\t\ts[1] = ~s[1];\n\t\ts[2] = ~s[2];\n\t\ts[3] = ~s[3];\n\t\tsize = 8;\n\t}\n\t*ctx->check = csum_fold(csum_partial(s, size,\n\t\t\t\t\t     ~csum_unfold(*ctx->check)));\n}\n\nint snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}\n\nint snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}\n\nstatic int snmp_translate(struct nf_conn *ct, int dir, struct sk_buff *skb)\n{\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\tu16 datalen = ntohs(udph->len) - sizeof(struct udphdr);\n\tchar *data = (unsigned char *)udph + sizeof(struct udphdr);\n\tstruct snmp_ctx ctx;\n\tint ret;\n\n\tif (dir == IP_CT_DIR_ORIGINAL) {\n\t\tctx.from = ct->tuplehash[dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[!dir].tuple.dst.u3.ip;\n\t} else {\n\t\tctx.from = ct->tuplehash[!dir].tuple.src.u3.ip;\n\t\tctx.to = ct->tuplehash[dir].tuple.dst.u3.ip;\n\t}\n\n\tif (ctx.from == ctx.to)\n\t\treturn NF_ACCEPT;\n\n\tctx.begin = (unsigned char *)udph + sizeof(struct udphdr);\n\tctx.check = &udph->check;\n\tret = asn1_ber_decoder(&nf_nat_snmp_basic_decoder, &ctx, data, datalen);\n\tif (ret < 0) {\n\t\tnf_ct_helper_log(skb, ct, \"parser failed\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\treturn NF_ACCEPT;\n}\n\n/* We don't actually set up expectations, just adjust internal IP\n * addresses if this is being NATted\n */\nstatic int help(struct sk_buff *skb, unsigned int protoff,\n\t\tstruct nf_conn *ct,\n\t\tenum ip_conntrack_info ctinfo)\n{\n\tint dir = CTINFO2DIR(ctinfo);\n\tunsigned int ret;\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tconst struct udphdr *udph = (struct udphdr *)((__be32 *)iph + iph->ihl);\n\n\t/* SNMP replies and originating SNMP traps get mangled */\n\tif (udph->source == htons(SNMP_PORT) && dir != IP_CT_DIR_REPLY)\n\t\treturn NF_ACCEPT;\n\tif (udph->dest == htons(SNMP_TRAP_PORT) && dir != IP_CT_DIR_ORIGINAL)\n\t\treturn NF_ACCEPT;\n\n\t/* No NAT? */\n\tif (!(ct->status & IPS_NAT_MASK))\n\t\treturn NF_ACCEPT;\n\n\t/* Make sure the packet length is ok.  So far, we were only guaranteed\n\t * to have a valid length IP header plus 8 bytes, which means we have\n\t * enough room for a UDP header.  Just verify the UDP length field so we\n\t * can mess around with the payload.\n\t */\n\tif (ntohs(udph->len) != skb->len - (iph->ihl << 2)) {\n\t\tnf_ct_helper_log(skb, ct, \"dropping malformed packet\\n\");\n\t\treturn NF_DROP;\n\t}\n\n\tif (!skb_make_writable(skb, skb->len)) {\n\t\tnf_ct_helper_log(skb, ct, \"cannot mangle packet\");\n\t\treturn NF_DROP;\n\t}\n\n\tspin_lock_bh(&snmp_lock);\n\tret = snmp_translate(ct, dir, skb);\n\tspin_unlock_bh(&snmp_lock);\n\treturn ret;\n}\n\nstatic const struct nf_conntrack_expect_policy snmp_exp_policy = {\n\t.max_expected\t= 0,\n\t.timeout\t= 180,\n};\n\nstatic struct nf_conntrack_helper snmp_trap_helper __read_mostly = {\n\t.me\t\t\t= THIS_MODULE,\n\t.help\t\t\t= help,\n\t.expect_policy\t\t= &snmp_exp_policy,\n\t.name\t\t\t= \"snmp_trap\",\n\t.tuple.src.l3num\t= AF_INET,\n\t.tuple.src.u.udp.port\t= cpu_to_be16(SNMP_TRAP_PORT),\n\t.tuple.dst.protonum\t= IPPROTO_UDP,\n};\n\nstatic int __init nf_nat_snmp_basic_init(void)\n{\n\tBUG_ON(nf_nat_snmp_hook != NULL);\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, help);\n\n\treturn nf_conntrack_helper_register(&snmp_trap_helper);\n}\n\nstatic void __exit nf_nat_snmp_basic_fini(void)\n{\n\tRCU_INIT_POINTER(nf_nat_snmp_hook, NULL);\n\tsynchronize_rcu();\n\tnf_conntrack_helper_unregister(&snmp_trap_helper);\n}\n\nmodule_init(nf_nat_snmp_basic_init);\nmodule_exit(nf_nat_snmp_basic_fini);\n"], "filenames": ["net/ipv4/netfilter/nf_nat_snmp_basic_main.c"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [119], "fixing_code_start_loc": [108], "fixing_code_end_loc": [124], "type": "CWE-787", "message": "In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper.", "other": {"cve": {"id": "CVE-2019-9162", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-25T23:29:01.330", "lastModified": "2022-04-05T20:46:50.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper."}, {"lang": "es", "value": "En el kernel de Linux, en versiones anteriores a la 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c en el m\u00f3dulo SNMP NAT tiene comprobaciones de longitud ASN.1 insuficientes (conocido como error de \u00edndice de arrays), lo que hace que las operaciones de lectura y escritura fuera de l\u00edmites sean posibles y conduciendo a un OOPS o al escalado de privilegios locales. Esto afecta a snmp_version y snmp_helper."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.25", "matchCriteriaId": "EC63428E-1B75-4342-B016-1C3150E0A325"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "4.20.12", "matchCriteriaId": "3C078F94-1B1E-4975-A4D3-60E303B4CFB4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapprotect:-:*:*:*:*:*:*:*", "matchCriteriaId": "F74F467A-0C81-40D9-BA06-40FB8EF02C04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:cn1610_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "EB30733E-68FC-49C4-86C0-7FEE75C366BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:cn1610:-:*:*:*:*:*:*:*", "matchCriteriaId": "6361DAC6-600F-4B15-8797-D67F298F46FB"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/107159", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1776", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.19.25", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.20.12", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190327-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K31864522", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46477/", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c4c07b4d6fa1f11880eab8e076d3d060ef3f55fc"}}