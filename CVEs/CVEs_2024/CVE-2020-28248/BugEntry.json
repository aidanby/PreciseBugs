{"buggy_code": ["#include \"./PngImg.h\"\n#include \"./PngStructs.h\"\n\n#include <png.h>\n#include <string.h>\n#include <memory>\n#include <algorithm>\n\nusing namespace std;\n\nstruct BufPtr {\n    const char* ptr;\n    size_t len;\n};\n\n///\nvoid readFromBuf(png_structp pngPtr, png_bytep data, png_size_t length) {\n    BufPtr* bufPtr = (BufPtr*)png_get_io_ptr(pngPtr);\n\n    memcpy((char*)data, bufPtr->ptr, length);\n    bufPtr->ptr += length;\n    bufPtr->len -= length;\n}\n\n///\nPngImg::PngImg(const char* buf, const size_t bufLen)\n    : data_(nullptr)\n{\n    memset(&info_, 0, sizeof(info_));\n    PngReadStruct rs;\n    if(rs.Valid()) {\n        BufPtr bufPtr = {buf, bufLen};\n        png_set_read_fn(rs.pngPtr, (png_voidp)&bufPtr, readFromBuf);\n        ReadInfo_(rs);\n\n        InitStorage_();\n        png_read_image(rs.pngPtr, &rowPtrs_[0]);\n    }\n}\n\n///\nPngImg::~PngImg() {\n    if(data_) delete [] data_;\n}\n\n///\nvoid PngImg::ReadInfo_(PngReadStruct& rs) {\n    png_read_info(rs.pngPtr, rs.infoPtr);\n    info_.width = png_get_image_width(rs.pngPtr, rs.infoPtr);\n    info_.height = png_get_image_height(rs.pngPtr, rs.infoPtr);\n    info_.bit_depth = png_get_bit_depth(rs.pngPtr, rs.infoPtr);\n    info_.color_type = png_get_color_type(rs.pngPtr, rs.infoPtr);\n    info_.interlace_type = png_get_interlace_type(rs.pngPtr, rs.infoPtr);\n    info_.compression_type = png_get_compression_type(rs.pngPtr, rs.infoPtr);\n    info_.filter_type = png_get_filter_type(rs.pngPtr, rs.infoPtr);\n    info_.rowbytes = png_get_rowbytes(rs.pngPtr, rs.infoPtr);\n    info_.pxlsize = info_.rowbytes / info_.width;\n}\n\n///\nvoid PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}\n\n///\nunique_ptr<Pxl> PngImg::Get(png_uint_32 x, png_uint_32 y) const\n{\n    if(x >= info_.width || y >= info_.height)\n    {\n        error_ = \"Out of the bounds\";\n        return nullptr;\n    }\n\n    png_bytep p = rowPtrs_[y] + info_.pxlsize * x;\n    unique_ptr<Pxl> pPxl(new Pxl{0, 0, 0, 0});\n    pPxl->r = p[0];\n    pPxl->g = p[1];\n    pPxl->b = p[2];\n    pPxl->a = info_.pxlsize > 3 ? p[3] : 255;\n\n    return pPxl;\n}\n\n///\nbool PngImg::Fill(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height, const Pxl& pxl)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n\n    for(size_t i = 0; i < height; ++i) {\n        for(size_t j = 0; j < width; ++j) {\n            Set_(offsetX + j, offsetY + i, pxl);\n        }\n    }\n\n    return true;\n}\n\n///\nvoid PngImg::Set_(png_uint_32 x, png_uint_32 y, const Pxl& pxl)\n{\n    png_bytep p = rowPtrs_[y] + info_.pxlsize * x;\n    p[0] = pxl.r;\n    p[1] = pxl.g;\n    p[2] = pxl.b;\n    if(info_.pxlsize > 3) {\n        p[3] = pxl.a;\n    }\n}\n\n///\nbool PngImg::Crop(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n\n    for(size_t i = 0; i < height; ++i) {\n        rowPtrs_[i] = rowPtrs_[i + offsetY] + offsetX * info_.pxlsize;\n    }\n    rowPtrs_.resize(height);\n\n    info_.width = width;\n    info_.height = height;\n    info_.rowbytes = info_.pxlsize * width;\n    return true;\n}\n\n///\nbool PngImg::InBounds_(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height) const\n{\n    return width != 0\n        && height != 0\n        && width <= info_.width\n        && height <= info_.height\n        && offsetX < info_.width\n        && offsetY < info_.height\n        && offsetX + width <= info_.width\n        && offsetY + height <= info_.height;\n}\n\n///\nvoid PngImg::SetSize(png_uint_32 width, png_uint_32 height)\n{\n    const ImgInfo oldInfo = info_;\n    const unique_ptr<png_byte[]> oldData{data_};\n    const vector<png_bytep> oldRowPtrs{rowPtrs_};\n\n    info_.width = width;\n    info_.height = height;\n    info_.rowbytes = info_.pxlsize * width;\n\n    InitStorage_();\n    memset(data_, 0, info_.height * info_.rowbytes);\n    CopyRows_(oldRowPtrs, min(height, oldInfo.height), min(oldInfo.rowbytes, info_.rowbytes));\n}\n\n///\nvoid PngImg::Insert(const PngImg& img, png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    if(info_.pxlsize == img.info_.pxlsize) {\n        CopyRows_(img.rowPtrs_, img.info_.height, img.info_.rowbytes, offsetX, offsetY);\n    } else {\n        CopyPxlByPxl_(img, offsetX, offsetY);\n    }\n}\n\n///\nvoid PngImg::CopyPxlByPxl_(const PngImg& img, png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    for(size_t x = 0; x < img.info_.width; ++x) {\n        for(size_t y = 0; y < img.info_.height; ++y) {\n            Set_(offsetX + x, offsetY + y, *img.Get(x, y));\n        }\n    }\n}\n\n///\nvoid PngImg::CopyRows_(const vector<png_bytep>& rowPtrs, const size_t numRows, const size_t rowLen,\n    png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    for(size_t y = 0; y < numRows; ++y) {\n        memcpy(rowPtrs_[y + offsetY] + offsetX * info_.pxlsize, rowPtrs[y], rowLen);\n    }\n}\n\n///\nvoid PngImg::RotateRight() {\n    Rotate_([](const Point& p, const ImgInfo& img) {\n        return Point{img.height - p.y - 1, p.x};\n    });\n}\n\n///\nvoid PngImg::RotateLeft() {\n    Rotate_([](const Point& p, const ImgInfo& img) {\n        return Point{p.y, img.width - p.x - 1};\n    });\n}\n\n///\nvoid PngImg::Rotate_(function<Point(const Point&, const ImgInfo&)> moveFn) {\n    const ImgInfo oldInfo = info_;\n    const unique_ptr<png_byte[]> oldData{data_};\n    const vector<png_bytep> oldRowPtrs{rowPtrs_};\n\n    info_.width = oldInfo.height;\n    info_.height = oldInfo.width;\n    info_.rowbytes = info_.pxlsize * info_.width;\n\n    InitStorage_();\n\n    for(size_t x = 0; x < oldInfo.width; ++x) {\n        for(size_t y = 0; y < oldInfo.height; ++y) {\n            auto newPoint = moveFn({x, y}, oldInfo);\n\n            png_bytep p = oldRowPtrs[y] + oldInfo.pxlsize * x;\n            png_bytep newP = rowPtrs_[newPoint.y] + info_.pxlsize * newPoint.x;\n\n            copy(p, p + info_.pxlsize, newP);\n        }\n    }\n}\n\n///\nbool PngImg::Write(const string& file) {\n    auto fileClose = [](FILE* fp){ if(fp) fclose(fp); };\n    unique_ptr<FILE, decltype(fileClose)> fp(fopen(file.c_str(), \"wb\"), fileClose);\n    if(!fp) {\n        error_ = \"Can't open file for writing\";\n        return false;\n    }\n\n    PngWriteStruct pws;\n    if(!pws.Valid()) {\n        error_ = \"Can't create png structs\";\n        return false;\n    }\n\n    if(setjmp(png_jmpbuf(pws.pngPtr))) {\n        error_ = \"Can't write file\";\n        return false;\n    }\n\n    png_init_io(pws.pngPtr, fp.get());\n    png_set_IHDR(pws.pngPtr, pws.infoPtr,\n        info_.width,\n        info_.height,\n        info_.bit_depth,\n        info_.color_type,\n        info_.interlace_type,\n        info_.compression_type,\n        info_.filter_type\n    );\n    png_set_rows(pws.pngPtr, pws.infoPtr, &rowPtrs_[0]);\n    png_write_png(pws.pngPtr, pws.infoPtr, PNG_TRANSFORM_IDENTITY, NULL);\n\n    return true;\n}\n"], "fixing_code": ["#include \"./PngImg.h\"\n#include \"./PngStructs.h\"\n\n#include <png.h>\n#include <string.h>\n#include <memory>\n#include <algorithm>\n\nusing namespace std;\n\nstruct BufPtr {\n    const char* ptr;\n    size_t len;\n};\n\n///\nvoid readFromBuf(png_structp pngPtr, png_bytep data, png_size_t length) {\n    BufPtr* bufPtr = (BufPtr*)png_get_io_ptr(pngPtr);\n\n    memcpy((char*)data, bufPtr->ptr, length);\n    bufPtr->ptr += length;\n    bufPtr->len -= length;\n}\n\n///\nPngImg::PngImg(const char* buf, const size_t bufLen)\n    : data_(nullptr)\n{\n    memset(&info_, 0, sizeof(info_));\n    PngReadStruct rs;\n    if(rs.Valid()) {\n        BufPtr bufPtr = {buf, bufLen};\n        png_set_read_fn(rs.pngPtr, (png_voidp)&bufPtr, readFromBuf);\n        ReadInfo_(rs);\n\n        InitStorage_();\n        png_read_image(rs.pngPtr, &rowPtrs_[0]);\n    }\n}\n\n///\nPngImg::~PngImg() {\n    if(data_) delete [] data_;\n}\n\n///\nvoid PngImg::ReadInfo_(PngReadStruct& rs) {\n    png_read_info(rs.pngPtr, rs.infoPtr);\n    info_.width = png_get_image_width(rs.pngPtr, rs.infoPtr);\n    info_.height = png_get_image_height(rs.pngPtr, rs.infoPtr);\n    info_.bit_depth = png_get_bit_depth(rs.pngPtr, rs.infoPtr);\n    info_.color_type = png_get_color_type(rs.pngPtr, rs.infoPtr);\n    info_.interlace_type = png_get_interlace_type(rs.pngPtr, rs.infoPtr);\n    info_.compression_type = png_get_compression_type(rs.pngPtr, rs.infoPtr);\n    info_.filter_type = png_get_filter_type(rs.pngPtr, rs.infoPtr);\n    info_.rowbytes = png_get_rowbytes(rs.pngPtr, rs.infoPtr);\n    info_.pxlsize = info_.rowbytes / info_.width;\n}\n\n///\nvoid PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    // Extend height and rowbytes from uint32_t to size_t to avoid multiplication overflow when size_t is larger\n    size_t h = info_.height;\n    size_t rb = info_.rowbytes;\n    // We need to make sure that info_.height * info_.rowbytes will not overflow size_t\n    // Unfotunately, there's no simple and portable way to do this in C++\n    // For integer division of positive numbers a * b > c <==> a > c / b holds\n    if (h > std::numeric_limits<size_t>::max() / rb) {\n        // TODO Propagate this exception to JS, and test it\n        throw std::runtime_error(\"Image is too large to allocate single buffer\");\n    }\n    data_ = new png_byte[h * rb];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * rb;\n    }\n}\n\n///\nunique_ptr<Pxl> PngImg::Get(png_uint_32 x, png_uint_32 y) const\n{\n    if(x >= info_.width || y >= info_.height)\n    {\n        error_ = \"Out of the bounds\";\n        return nullptr;\n    }\n\n    png_bytep p = rowPtrs_[y] + info_.pxlsize * x;\n    unique_ptr<Pxl> pPxl(new Pxl{0, 0, 0, 0});\n    pPxl->r = p[0];\n    pPxl->g = p[1];\n    pPxl->b = p[2];\n    pPxl->a = info_.pxlsize > 3 ? p[3] : 255;\n\n    return pPxl;\n}\n\n///\nbool PngImg::Fill(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height, const Pxl& pxl)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n\n    for(size_t i = 0; i < height; ++i) {\n        for(size_t j = 0; j < width; ++j) {\n            Set_(offsetX + j, offsetY + i, pxl);\n        }\n    }\n\n    return true;\n}\n\n///\nvoid PngImg::Set_(png_uint_32 x, png_uint_32 y, const Pxl& pxl)\n{\n    png_bytep p = rowPtrs_[y] + info_.pxlsize * x;\n    p[0] = pxl.r;\n    p[1] = pxl.g;\n    p[2] = pxl.b;\n    if(info_.pxlsize > 3) {\n        p[3] = pxl.a;\n    }\n}\n\n///\nbool PngImg::Crop(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n\n    for(size_t i = 0; i < height; ++i) {\n        rowPtrs_[i] = rowPtrs_[i + offsetY] + offsetX * info_.pxlsize;\n    }\n    rowPtrs_.resize(height);\n\n    info_.width = width;\n    info_.height = height;\n    info_.rowbytes = info_.pxlsize * width;\n    return true;\n}\n\n///\nbool PngImg::InBounds_(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height) const\n{\n    return width != 0\n        && height != 0\n        && width <= info_.width\n        && height <= info_.height\n        && offsetX < info_.width\n        && offsetY < info_.height\n        && offsetX + width <= info_.width\n        && offsetY + height <= info_.height;\n}\n\n///\nvoid PngImg::SetSize(png_uint_32 width, png_uint_32 height)\n{\n    const ImgInfo oldInfo = info_;\n    const unique_ptr<png_byte[]> oldData{data_};\n    const vector<png_bytep> oldRowPtrs{rowPtrs_};\n\n    info_.width = width;\n    info_.height = height;\n    info_.rowbytes = info_.pxlsize * width;\n\n    InitStorage_();\n    memset(data_, 0, info_.height * info_.rowbytes);\n    CopyRows_(oldRowPtrs, min(height, oldInfo.height), min(oldInfo.rowbytes, info_.rowbytes));\n}\n\n///\nvoid PngImg::Insert(const PngImg& img, png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    if(info_.pxlsize == img.info_.pxlsize) {\n        CopyRows_(img.rowPtrs_, img.info_.height, img.info_.rowbytes, offsetX, offsetY);\n    } else {\n        CopyPxlByPxl_(img, offsetX, offsetY);\n    }\n}\n\n///\nvoid PngImg::CopyPxlByPxl_(const PngImg& img, png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    for(size_t x = 0; x < img.info_.width; ++x) {\n        for(size_t y = 0; y < img.info_.height; ++y) {\n            Set_(offsetX + x, offsetY + y, *img.Get(x, y));\n        }\n    }\n}\n\n///\nvoid PngImg::CopyRows_(const vector<png_bytep>& rowPtrs, const size_t numRows, const size_t rowLen,\n    png_uint_32 offsetX, png_uint_32 offsetY)\n{\n    for(size_t y = 0; y < numRows; ++y) {\n        memcpy(rowPtrs_[y + offsetY] + offsetX * info_.pxlsize, rowPtrs[y], rowLen);\n    }\n}\n\n///\nvoid PngImg::RotateRight() {\n    Rotate_([](const Point& p, const ImgInfo& img) {\n        return Point{img.height - p.y - 1, p.x};\n    });\n}\n\n///\nvoid PngImg::RotateLeft() {\n    Rotate_([](const Point& p, const ImgInfo& img) {\n        return Point{p.y, img.width - p.x - 1};\n    });\n}\n\n///\nvoid PngImg::Rotate_(function<Point(const Point&, const ImgInfo&)> moveFn) {\n    const ImgInfo oldInfo = info_;\n    const unique_ptr<png_byte[]> oldData{data_};\n    const vector<png_bytep> oldRowPtrs{rowPtrs_};\n\n    info_.width = oldInfo.height;\n    info_.height = oldInfo.width;\n    info_.rowbytes = info_.pxlsize * info_.width;\n\n    InitStorage_();\n\n    for(size_t x = 0; x < oldInfo.width; ++x) {\n        for(size_t y = 0; y < oldInfo.height; ++y) {\n            auto newPoint = moveFn({x, y}, oldInfo);\n\n            png_bytep p = oldRowPtrs[y] + oldInfo.pxlsize * x;\n            png_bytep newP = rowPtrs_[newPoint.y] + info_.pxlsize * newPoint.x;\n\n            copy(p, p + info_.pxlsize, newP);\n        }\n    }\n}\n\n///\nbool PngImg::Write(const string& file) {\n    auto fileClose = [](FILE* fp){ if(fp) fclose(fp); };\n    unique_ptr<FILE, decltype(fileClose)> fp(fopen(file.c_str(), \"wb\"), fileClose);\n    if(!fp) {\n        error_ = \"Can't open file for writing\";\n        return false;\n    }\n\n    PngWriteStruct pws;\n    if(!pws.Valid()) {\n        error_ = \"Can't create png structs\";\n        return false;\n    }\n\n    if(setjmp(png_jmpbuf(pws.pngPtr))) {\n        error_ = \"Can't write file\";\n        return false;\n    }\n\n    png_init_io(pws.pngPtr, fp.get());\n    png_set_IHDR(pws.pngPtr, pws.infoPtr,\n        info_.width,\n        info_.height,\n        info_.bit_depth,\n        info_.color_type,\n        info_.interlace_type,\n        info_.compression_type,\n        info_.filter_type\n    );\n    png_set_rows(pws.pngPtr, pws.infoPtr, &rowPtrs_[0]);\n    png_write_png(pws.pngPtr, pws.infoPtr, PNG_TRANSFORM_IDENTITY, NULL);\n\n    return true;\n}\n"], "filenames": ["src/PngImg.cc"], "buggy_code_start_loc": [63], "buggy_code_end_loc": [67], "fixing_code_start_loc": [63], "fixing_code_end_loc": [77], "type": "CWE-190", "message": "An integer overflow in the PngImg::InitStorage_() function of png-img before 3.1.0 leads to an under-allocation of heap memory and subsequently an exploitable heap-based buffer overflow when loading a crafted PNG file.", "other": {"cve": {"id": "CVE-2020-28248", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-20T00:15:12.483", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An integer overflow in the PngImg::InitStorage_() function of png-img before 3.1.0 leads to an under-allocation of heap memory and subsequently an exploitable heap-based buffer overflow when loading a crafted PNG file."}, {"lang": "es", "value": "Un desbordamiento de enteros en la funci\u00f3n PngImg::InitStorage_ () de png-img versiones anteriores a 3.1.0, conlleva a una subasignaci\u00f3n de la memoria de la pila y, posteriormente, a un desbordamiento del b\u00fafer explotable en la regi\u00f3n heap de la memoria al cargar un archivo PNG dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:png-img_project:png-img:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.0", "matchCriteriaId": "433F356A-CB84-4159-866E-2837E32994C7"}]}]}], "references": [{"url": "https://github.com/gemini-testing/png-img", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://github.com/gemini-testing/png-img/commit/14ac462a32ca4b3b78f56502ac976d5b0222ce3d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gemini-testing/png-img/compare/v3.0.0...v3.1.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://securitylab.github.com/advisories/GHSL-2020-142-gemini-png-img", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gemini-testing/png-img/commit/14ac462a32ca4b3b78f56502ac976d5b0222ce3d"}}