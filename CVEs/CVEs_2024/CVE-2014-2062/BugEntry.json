{"buggy_code": ["package jenkins.security;\n\nimport hudson.model.User;\nimport hudson.security.ACL;\nimport hudson.util.Scrambler;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * {@link Filter} that performs HTTP basic authentication based on API token.\n *\n * <p>\n * Normally the filter chain would also contain another filter that handles BASIC\n * auth with the real password. Care must be taken to ensure that this doesn't\n * interfere with the other.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class ApiTokenFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }\n\n    public void destroy() {\n    }\n}\n"], "fixing_code": ["package jenkins.security;\n\nimport hudson.model.User;\nimport hudson.security.ACL;\nimport hudson.security.UserMayOrMayNotExistException;\nimport hudson.util.Scrambler;\nimport jenkins.model.Jenkins;\nimport org.acegisecurity.context.SecurityContext;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.springframework.dao.DataAccessException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * {@link Filter} that performs HTTP basic authentication based on API token.\n *\n * <p>\n * Normally the filter chain would also contain another filter that handles BASIC\n * auth with the real password. Care must be taken to ensure that this doesn't\n * interfere with the other.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class ApiTokenFilter implements Filter {\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpServletResponse rsp = (HttpServletResponse) response;\n        String authorization = req.getHeader(\"Authorization\");\n\n        if (authorization!=null) {\n            // authenticate the user\n            String uidpassword = Scrambler.descramble(authorization.substring(6));\n            int idx = uidpassword.indexOf(':');\n            if (idx >= 0) {\n                String username = uidpassword.substring(0, idx);\n                try {\n                    Jenkins.getInstance().getSecurityRealm().loadUserByUsername(username);\n                } catch (UserMayOrMayNotExistException x) {\n                    // OK, give them the benefit of the doubt.\n                } catch (UsernameNotFoundException x) {\n                    // Not/no longer a user; deny the API token. (But do not leak the information that this happened.)\n                    chain.doFilter(request, response);\n                    return;\n                } catch (DataAccessException x) {\n                    throw new ServletException(x);\n                }\n                String password = uidpassword.substring(idx+1);\n\n                // attempt to authenticate as API token\n                User u = User.get(username);\n                ApiTokenProperty t = u.getProperty(ApiTokenProperty.class);\n                if (t!=null && t.matchesPassword(password)) {\n                    // even if we fail to match the password, we aren't rejecting it.\n                    // as the user might be passing in a real password.\n                    SecurityContext oldContext = ACL.impersonate(u.impersonate());\n                    try {\n                        request.setAttribute(ApiTokenProperty.class.getName(), u);\n                        chain.doFilter(request,response);\n                        return;\n                    } finally {\n                        SecurityContextHolder.setContext(oldContext);\n                    }\n                }\n            }\n        }\n\n        chain.doFilter(request,response);\n    }\n\n    public void destroy() {\n    }\n}\n"], "filenames": ["core/src/main/java/jenkins/security/ApiTokenFilter.java"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [43], "fixing_code_start_loc": [5], "fixing_code_end_loc": [59], "type": "CWE-287", "message": "Jenkins before 1.551 and LTS before 1.532.2 does not invalidate the API token when a user is deleted, which allows remote authenticated users to retain access via the token.", "other": {"cve": {"id": "CVE-2014-2062", "sourceIdentifier": "security@debian.org", "published": "2014-10-17T15:55:05.650", "lastModified": "2016-06-13T23:36:16.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jenkins before 1.551 and LTS before 1.532.2 does not invalidate the API token when a user is deleted, which allows remote authenticated users to retain access via the token."}, {"lang": "es", "value": "Jenkins en versiones anteriores a 1.551 y LTS en versiones anteriores a 1.532.2 no invalida el token de la API cuando es eliminado un usuario, lo que permite a usuarios remotos autenticados conservar el acceso a trav\u00e9s del token."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndIncluding": "1.532.1", "matchCriteriaId": "F5EDE52E-F7BE-457D-8E56-F24800F02241"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.550", "matchCriteriaId": "07E4FEB5-A7D9-49FE-839A-0D650CC19C42"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/02/21/2", "source": "security@debian.org"}, {"url": "https://github.com/jenkinsci/jenkins/commit/5548b5220cfd496831b5721124189ff18fbb12a3", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2014-02-14", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/5548b5220cfd496831b5721124189ff18fbb12a3"}}