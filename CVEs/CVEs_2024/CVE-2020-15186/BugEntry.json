{"buggy_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/plugin\"\n)\n\nconst (\n\tpluginStaticCompletionFile        = \"completion.yaml\"\n\tpluginDynamicCompletionExecutable = \"plugin.complete\"\n)\n\ntype pluginError struct {\n\terror\n\tcode int\n}\n\n// loadPlugins loads plugins into the command list.\n//\n// This follows a different pattern than the other commands because it has\n// to inspect its environment and then add commands to the base command\n// as it finds them.\nfunc loadPlugins(baseCmd *cobra.Command, out io.Writer) {\n\n\t// If HELM_NO_PLUGINS is set to 1, do not load plugins.\n\tif os.Getenv(\"HELM_NO_PLUGINS\") == \"1\" {\n\t\treturn\n\t}\n\n\tfound, err := plugin.FindPlugins(settings.PluginsDirectory)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"failed to load plugins: %s\", err)\n\t\treturn\n\t}\n\n\t// Now we create commands for all of these.\n\tfor _, plug := range found {\n\t\tplug := plug\n\t\tmd := plug.Metadata\n\t\tif md.Usage == \"\" {\n\t\t\tmd.Usage = fmt.Sprintf(\"the %q plugin\", md.Name)\n\t\t}\n\n\t\tc := &cobra.Command{\n\t\t\tUse:   md.Name,\n\t\t\tShort: md.Usage,\n\t\t\tLong:  md.Description,\n\t\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t\tu, err := processParent(cmd, args)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// Call setupEnv before PrepareCommand because\n\t\t\t\t// PrepareCommand uses os.ExpandEnv and expects the\n\t\t\t\t// setupEnv vars.\n\t\t\t\tplugin.SetupPluginEnv(settings, md.Name, plug.Dir)\n\t\t\t\tmain, argv, prepCmdErr := plug.PrepareCommand(u)\n\t\t\t\tif prepCmdErr != nil {\n\t\t\t\t\tos.Stderr.WriteString(prepCmdErr.Error())\n\t\t\t\t\treturn errors.Errorf(\"plugin %q exited with error\", md.Name)\n\t\t\t\t}\n\n\t\t\t\treturn callPluginExecutable(md.Name, main, argv, out)\n\t\t\t},\n\t\t\t// This passes all the flags to the subcommand.\n\t\t\tDisableFlagParsing: true,\n\t\t}\n\n\t\t// TODO: Make sure a command with this name does not already exist.\n\t\tbaseCmd.AddCommand(c)\n\n\t\t// For completion, we try to load more details about the plugins so as to allow for command and\n\t\t// flag completion of the plugin itself.\n\t\t// We only do this when necessary (for the \"completion\" and \"__complete\" commands) to avoid the\n\t\t// risk of a rogue plugin affecting Helm's normal behavior.\n\t\tsubCmd, _, err := baseCmd.Find(os.Args[1:])\n\t\tif (err == nil &&\n\t\t\t((subCmd.HasParent() && subCmd.Parent().Name() == \"completion\") || subCmd.Name() == cobra.ShellCompRequestCmd)) ||\n\t\t\t/* for the tests */ subCmd == baseCmd.Root() {\n\t\t\tloadCompletionForPlugin(c, plug)\n\t\t}\n\t}\n}\n\nfunc processParent(cmd *cobra.Command, args []string) ([]string, error) {\n\tk, u := manuallyProcessArgs(args)\n\tif err := cmd.Parent().ParseFlags(k); err != nil {\n\t\treturn nil, err\n\t}\n\treturn u, nil\n}\n\n// This function is used to setup the environment for the plugin and then\n// call the executable specified by the parameter 'main'\nfunc callPluginExecutable(pluginName string, main string, argv []string, out io.Writer) error {\n\tenv := os.Environ()\n\tfor k, v := range settings.EnvVars() {\n\t\tenv = append(env, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\n\tprog := exec.Command(main, argv...)\n\tprog.Env = env\n\tprog.Stdin = os.Stdin\n\tprog.Stdout = out\n\tprog.Stderr = os.Stderr\n\tif err := prog.Run(); err != nil {\n\t\tif eerr, ok := err.(*exec.ExitError); ok {\n\t\t\tos.Stderr.Write(eerr.Stderr)\n\t\t\tstatus := eerr.Sys().(syscall.WaitStatus)\n\t\t\treturn pluginError{\n\t\t\t\terror: errors.Errorf(\"plugin %q exited with error\", pluginName),\n\t\t\t\tcode:  status.ExitStatus(),\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// manuallyProcessArgs processes an arg array, removing special args.\n//\n// Returns two sets of args: known and unknown (in that order)\nfunc manuallyProcessArgs(args []string) ([]string, []string) {\n\tknown := []string{}\n\tunknown := []string{}\n\tkvargs := []string{\"--kube-context\", \"--namespace\", \"-n\", \"--kubeconfig\", \"--kube-apiserver\", \"--kube-token\", \"--kube-as-user\", \"--kube-as-group\", \"--registry-config\", \"--repository-cache\", \"--repository-config\"}\n\tknownArg := func(a string) bool {\n\t\tfor _, pre := range kvargs {\n\t\t\tif strings.HasPrefix(a, pre+\"=\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tisKnown := func(v string) string {\n\t\tfor _, i := range kvargs {\n\t\t\tif i == v {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tfor i := 0; i < len(args); i++ {\n\t\tswitch a := args[i]; a {\n\t\tcase \"--debug\":\n\t\t\tknown = append(known, a)\n\t\tcase isKnown(a):\n\t\t\tknown = append(known, a)\n\t\t\ti++\n\t\t\tif i < len(args) {\n\t\t\t\tknown = append(known, args[i])\n\t\t\t}\n\t\tdefault:\n\t\t\tif knownArg(a) {\n\t\t\t\tknown = append(known, a)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tunknown = append(unknown, a)\n\t\t}\n\t}\n\treturn known, unknown\n}\n\n// pluginCommand represents the optional completion.yaml file of a plugin\ntype pluginCommand struct {\n\tName      string          `json:\"name\"`\n\tValidArgs []string        `json:\"validArgs\"`\n\tFlags     []string        `json:\"flags\"`\n\tCommands  []pluginCommand `json:\"commands\"`\n}\n\n// loadCompletionForPlugin will load and parse any completion.yaml provided by the plugin\n// and add the dynamic completion hook to call the optional plugin.complete\nfunc loadCompletionForPlugin(pluginCmd *cobra.Command, plugin *plugin.Plugin) {\n\t// Parse the yaml file providing the plugin's sub-commands and flags\n\tcmds, err := loadFile(strings.Join(\n\t\t[]string{plugin.Dir, pluginStaticCompletionFile}, string(filepath.Separator)))\n\n\tif err != nil {\n\t\t// The file could be missing or invalid.  No static completion for this plugin.\n\t\tif settings.Debug {\n\t\t\tlog.Output(2, fmt.Sprintf(\"[info] %s\\n\", err.Error()))\n\t\t}\n\t\t// Continue to setup dynamic completion.\n\t\tcmds = &pluginCommand{}\n\t}\n\n\t// Preserve the Usage string specified for the plugin\n\tcmds.Name = pluginCmd.Use\n\n\taddPluginCommands(plugin, pluginCmd, cmds)\n}\n\n// addPluginCommands is a recursive method that adds each different level\n// of sub-commands and flags for the plugins that have provided such information\nfunc addPluginCommands(plugin *plugin.Plugin, baseCmd *cobra.Command, cmds *pluginCommand) {\n\tif cmds == nil {\n\t\treturn\n\t}\n\n\tif len(cmds.Name) == 0 {\n\t\t// Missing name for a command\n\t\tif settings.Debug {\n\t\t\tlog.Output(2, fmt.Sprintf(\"[info] sub-command name field missing for %s\", baseCmd.CommandPath()))\n\t\t}\n\t\treturn\n\t}\n\n\tbaseCmd.Use = cmds.Name\n\tbaseCmd.ValidArgs = cmds.ValidArgs\n\t// Setup the same dynamic completion for each plugin sub-command.\n\t// This is because if dynamic completion is triggered, there is a single executable\n\t// to call (plugin.complete), so every sub-commands calls it in the same fashion.\n\tif cmds.Commands == nil {\n\t\t// Only setup dynamic completion if there are no sub-commands.  This avoids\n\t\t// calling plugin.complete at every completion, which greatly simplifies\n\t\t// development of plugin.complete for plugin developers.\n\t\tbaseCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\treturn pluginDynamicComp(plugin, cmd, args, toComplete)\n\t\t}\n\t}\n\n\t// Create fake flags.\n\tif len(cmds.Flags) > 0 {\n\t\t// The flags can be created with any type, since we only need them for completion.\n\t\t// pflag does not allow to create short flags without a corresponding long form\n\t\t// so we look for all short flags and match them to any long flag.  This will allow\n\t\t// plugins to provide short flags without a long form.\n\t\t// If there are more short-flags than long ones, we'll create an extra long flag with\n\t\t// the same single letter as the short form.\n\t\tshorts := []string{}\n\t\tlongs := []string{}\n\t\tfor _, flag := range cmds.Flags {\n\t\t\tif len(flag) == 1 {\n\t\t\t\tshorts = append(shorts, flag)\n\t\t\t} else {\n\t\t\t\tlongs = append(longs, flag)\n\t\t\t}\n\t\t}\n\n\t\tf := baseCmd.Flags()\n\t\tif len(longs) >= len(shorts) {\n\t\t\tfor i := range longs {\n\t\t\t\tif i < len(shorts) {\n\t\t\t\t\tf.BoolP(longs[i], shorts[i], false, \"\")\n\t\t\t\t} else {\n\t\t\t\t\tf.Bool(longs[i], false, \"\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := range shorts {\n\t\t\t\tif i < len(longs) {\n\t\t\t\t\tf.BoolP(longs[i], shorts[i], false, \"\")\n\t\t\t\t} else {\n\t\t\t\t\t// Create a long flag with the same name as the short flag.\n\t\t\t\t\t// Not a perfect solution, but its better than ignoring the extra short flags.\n\t\t\t\t\tf.BoolP(shorts[i], shorts[i], false, \"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Recursively add any sub-commands\n\tfor _, cmd := range cmds.Commands {\n\t\t// Create a fake command so that completion can be done for the sub-commands of the plugin\n\t\tsubCmd := &cobra.Command{\n\t\t\t// This prevents Cobra from removing the flags.  We want to keep the flags to pass them\n\t\t\t// to the dynamic completion script of the plugin.\n\t\t\tDisableFlagParsing: true,\n\t\t\t// A Run is required for it to be a valid command without subcommands\n\t\t\tRun: func(cmd *cobra.Command, args []string) {},\n\t\t}\n\t\tbaseCmd.AddCommand(subCmd)\n\t\taddPluginCommands(plugin, subCmd, &cmd)\n\t}\n}\n\n// loadFile takes a yaml file at the given path, parses it and returns a pluginCommand object\nfunc loadFile(path string) (*pluginCommand, error) {\n\tcmds := new(pluginCommand)\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn cmds, errors.New(fmt.Sprintf(\"File (%s) not provided by plugin. No plugin auto-completion possible.\", path))\n\t}\n\n\terr = yaml.Unmarshal(b, cmds)\n\treturn cmds, err\n}\n\n// pluginDynamicComp call the plugin.complete script of the plugin (if available)\n// to obtain the dynamic completion choices.  It must pass all the flags and sub-commands\n// specified in the command-line to the plugin.complete executable (except helm's global flags)\nfunc pluginDynamicComp(plug *plugin.Plugin, cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\tmd := plug.Metadata\n\n\tu, err := processParent(cmd, args)\n\tif err != nil {\n\t\treturn nil, cobra.ShellCompDirectiveError\n\t}\n\n\t// We will call the dynamic completion script of the plugin\n\tmain := strings.Join([]string{plug.Dir, pluginDynamicCompletionExecutable}, string(filepath.Separator))\n\n\t// We must include all sub-commands passed on the command-line.\n\t// To do that, we pass-in the entire CommandPath, except the first two elements\n\t// which are 'helm' and 'pluginName'.\n\targv := strings.Split(cmd.CommandPath(), \" \")[2:]\n\tif !md.IgnoreFlags {\n\t\targv = append(argv, u...)\n\t\targv = append(argv, toComplete)\n\t}\n\tplugin.SetupPluginEnv(settings, md.Name, plug.Dir)\n\n\tcobra.CompDebugln(fmt.Sprintf(\"calling %s with args %v\", main, argv), settings.Debug)\n\tbuf := new(bytes.Buffer)\n\tif err := callPluginExecutable(md.Name, main, argv, buf); err != nil {\n\t\t// The dynamic completion file is optional for a plugin, so this error is ok.\n\t\tcobra.CompDebugln(fmt.Sprintf(\"Unable to call %s: %v\", main, err.Error()), settings.Debug)\n\t\treturn nil, cobra.ShellCompDirectiveDefault\n\t}\n\n\tvar completions []string\n\tfor _, comp := range strings.Split(buf.String(), \"\\n\") {\n\t\t// Remove any empty lines\n\t\tif len(comp) > 0 {\n\t\t\tcompletions = append(completions, comp)\n\t\t}\n\t}\n\n\t// Check if the last line of output is of the form :<integer>, which\n\t// indicates the BashCompletionDirective.\n\tdirective := cobra.ShellCompDirectiveDefault\n\tif len(completions) > 0 {\n\t\tlastLine := completions[len(completions)-1]\n\t\tif len(lastLine) > 1 && lastLine[0] == ':' {\n\t\t\tif strInt, err := strconv.Atoi(lastLine[1:]); err == nil {\n\t\t\t\tdirective = cobra.ShellCompDirective(strInt)\n\t\t\t\tcompletions = completions[:len(completions)-1]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn completions, directive\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/spf13/cobra\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/plugin\"\n\t\"helm.sh/helm/v3/pkg/plugin/installer\"\n)\n\ntype pluginInstallOptions struct {\n\tsource  string\n\tversion string\n}\n\nconst pluginInstallDesc = `\nThis command allows you to install a plugin from a url to a VCS repo or a local path.\n`\n\nfunc newPluginInstallCmd(out io.Writer) *cobra.Command {\n\to := &pluginInstallOptions{}\n\tcmd := &cobra.Command{\n\t\tUse:     \"install [options] <path|url>...\",\n\t\tShort:   \"install one or more Helm plugins\",\n\t\tLong:    pluginInstallDesc,\n\t\tAliases: []string{\"add\"},\n\t\tArgs:    require.ExactArgs(1),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\tif len(args) == 0 {\n\t\t\t\t// We do file completion, in case the plugin is local\n\t\t\t\treturn nil, cobra.ShellCompDirectiveDefault\n\t\t\t}\n\t\t\t// No more completion once the plugin path has been specified\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn o.complete(args)\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn o.run(out)\n\t\t},\n\t}\n\tcmd.Flags().StringVar(&o.version, \"version\", \"\", \"specify a version constraint. If this is not specified, the latest version is installed\")\n\treturn cmd\n}\n\nfunc (o *pluginInstallOptions) complete(args []string) error {\n\to.source = args[0]\n\treturn nil\n}\n\nfunc (o *pluginInstallOptions) run(out io.Writer) error {\n\tinstaller.Debug = settings.Debug\n\n\ti, err := installer.NewForSource(o.source, o.version)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := installer.Install(i); err != nil {\n\t\treturn err\n\t}\n\n\tdebug(\"loading plugin from %s\", i.Path())\n\tp, err := plugin.LoadDir(i.Path())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := runHook(p, plugin.Install); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(out, \"Installed plugin: %s\\n\", p.Metadata.Name)\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage plugin // import \"helm.sh/helm/v3/pkg/plugin\"\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n)\n\nconst PluginFileName = \"plugin.yaml\"\n\n// Downloaders represents the plugins capability if it can retrieve\n// charts from special sources\ntype Downloaders struct {\n\t// Protocols are the list of schemes from the charts URL.\n\tProtocols []string `json:\"protocols\"`\n\t// Command is the executable path with which the plugin performs\n\t// the actual download for the corresponding Protocols\n\tCommand string `json:\"command\"`\n}\n\n// PlatformCommand represents a command for a particular operating system and architecture\ntype PlatformCommand struct {\n\tOperatingSystem string `json:\"os\"`\n\tArchitecture    string `json:\"arch\"`\n\tCommand         string `json:\"command\"`\n}\n\n// Metadata describes a plugin.\n//\n// This is the plugin equivalent of a chart.Metadata.\ntype Metadata struct {\n\t// Name is the name of the plugin\n\tName string `json:\"name\"`\n\n\t// Version is a SemVer 2 version of the plugin.\n\tVersion string `json:\"version\"`\n\n\t// Usage is the single-line usage text shown in help\n\tUsage string `json:\"usage\"`\n\n\t// Description is a long description shown in places like `helm help`\n\tDescription string `json:\"description\"`\n\n\t// Command is the command, as a single string.\n\t//\n\t// The command will be passed through environment expansion, so env vars can\n\t// be present in this command. Unless IgnoreFlags is set, this will\n\t// also merge the flags passed from Helm.\n\t//\n\t// Note that command is not executed in a shell. To do so, we suggest\n\t// pointing the command to a shell script.\n\t//\n\t// The following rules will apply to processing commands:\n\t// - If platformCommand is present, it will be searched first\n\t// - If both OS and Arch match the current platform, search will stop and the command will be executed\n\t// - If OS matches and there is no more specific match, the command will be executed\n\t// - If no OS/Arch match is found, the default command will be executed\n\t// - If no command is present and no matches are found in platformCommand, Helm will exit with an error\n\tPlatformCommand []PlatformCommand `json:\"platformCommand\"`\n\tCommand         string            `json:\"command\"`\n\n\t// IgnoreFlags ignores any flags passed in from Helm\n\t//\n\t// For example, if the plugin is invoked as `helm --debug myplugin`, if this\n\t// is false, `--debug` will be appended to `--command`. If this is true,\n\t// the `--debug` flag will be discarded.\n\tIgnoreFlags bool `json:\"ignoreFlags\"`\n\n\t// Hooks are commands that will run on events.\n\tHooks Hooks\n\n\t// Downloaders field is used if the plugin supply downloader mechanism\n\t// for special protocols.\n\tDownloaders []Downloaders `json:\"downloaders\"`\n}\n\n// Plugin represents a plugin.\ntype Plugin struct {\n\t// Metadata is a parsed representation of a plugin.yaml\n\tMetadata *Metadata\n\t// Dir is the string path to the directory that holds the plugin.\n\tDir string\n}\n\n// The following rules will apply to processing the Plugin.PlatformCommand.Command:\n// - If both OS and Arch match the current platform, search will stop and the command will be prepared for execution\n// - If OS matches and there is no more specific match, the command will be prepared for execution\n// - If no OS/Arch match is found, return nil\nfunc getPlatformCommand(cmds []PlatformCommand) []string {\n\tvar command []string\n\teq := strings.EqualFold\n\tfor _, c := range cmds {\n\t\tif eq(c.OperatingSystem, runtime.GOOS) {\n\t\t\tcommand = strings.Split(os.ExpandEnv(c.Command), \" \")\n\t\t}\n\t\tif eq(c.OperatingSystem, runtime.GOOS) && eq(c.Architecture, runtime.GOARCH) {\n\t\t\treturn strings.Split(os.ExpandEnv(c.Command), \" \")\n\t\t}\n\t}\n\treturn command\n}\n\n// PrepareCommand takes a Plugin.PlatformCommand.Command, a Plugin.Command and will applying the following processing:\n// - If platformCommand is present, it will be searched first\n// - If both OS and Arch match the current platform, search will stop and the command will be prepared for execution\n// - If OS matches and there is no more specific match, the command will be prepared for execution\n// - If no OS/Arch match is found, the default command will be prepared for execution\n// - If no command is present and no matches are found in platformCommand, will exit with an error\n//\n// It merges extraArgs into any arguments supplied in the plugin. It\n// returns the name of the command and an args array.\n//\n// The result is suitable to pass to exec.Command.\nfunc (p *Plugin) PrepareCommand(extraArgs []string) (string, []string, error) {\n\tvar parts []string\n\tplatCmdLen := len(p.Metadata.PlatformCommand)\n\tif platCmdLen > 0 {\n\t\tparts = getPlatformCommand(p.Metadata.PlatformCommand)\n\t}\n\tif platCmdLen == 0 || parts == nil {\n\t\tparts = strings.Split(os.ExpandEnv(p.Metadata.Command), \" \")\n\t}\n\tif len(parts) == 0 || parts[0] == \"\" {\n\t\treturn \"\", nil, fmt.Errorf(\"No plugin command is applicable\")\n\t}\n\n\tmain := parts[0]\n\tbaseArgs := []string{}\n\tif len(parts) > 1 {\n\t\tbaseArgs = parts[1:]\n\t}\n\tif !p.Metadata.IgnoreFlags {\n\t\tbaseArgs = append(baseArgs, extraArgs...)\n\t}\n\treturn main, baseArgs, nil\n}\n\n// LoadDir loads a plugin from the given directory.\nfunc LoadDir(dirname string) (*Plugin, error) {\n\tdata, err := ioutil.ReadFile(filepath.Join(dirname, PluginFileName))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tplug := &Plugin{Dir: dirname}\n\tif err := yaml.Unmarshal(data, &plug.Metadata); err != nil {\n\t\treturn nil, err\n\t}\n\treturn plug, nil\n}\n\n// LoadAll loads all plugins found beneath the base directory.\n//\n// This scans only one directory level.\nfunc LoadAll(basedir string) ([]*Plugin, error) {\n\tplugins := []*Plugin{}\n\t// We want basedir/*/plugin.yaml\n\tscanpath := filepath.Join(basedir, \"*\", PluginFileName)\n\tmatches, err := filepath.Glob(scanpath)\n\tif err != nil {\n\t\treturn plugins, err\n\t}\n\n\tif matches == nil {\n\t\treturn plugins, nil\n\t}\n\n\tfor _, yaml := range matches {\n\t\tdir := filepath.Dir(yaml)\n\t\tp, err := LoadDir(dir)\n\t\tif err != nil {\n\t\t\treturn plugins, err\n\t\t}\n\t\tplugins = append(plugins, p)\n\t}\n\treturn plugins, nil\n}\n\n// FindPlugins returns a list of YAML files that describe plugins.\nfunc FindPlugins(plugdirs string) ([]*Plugin, error) {\n\tfound := []*Plugin{}\n\t// Let's get all UNIXy and allow path separators\n\tfor _, p := range filepath.SplitList(plugdirs) {\n\t\tmatches, err := LoadAll(p)\n\t\tif err != nil {\n\t\t\treturn matches, err\n\t\t}\n\t\tfound = append(found, matches...)\n\t}\n\treturn found, nil\n}\n\n// SetupPluginEnv prepares os.Env for plugins. It operates on os.Env because\n// the plugin subsystem itself needs access to the environment variables\n// created here.\nfunc SetupPluginEnv(settings *cli.EnvSettings, name, base string) {\n\tenv := settings.EnvVars()\n\tenv[\"HELM_PLUGIN_NAME\"] = name\n\tenv[\"HELM_PLUGIN_DIR\"] = base\n\tfor key, val := range env {\n\t\tos.Setenv(key, val)\n\t}\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage plugin // import \"helm.sh/helm/v3/pkg/plugin\"\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n)\n\nfunc checkCommand(p *Plugin, extraArgs []string, osStrCmp string, t *testing.T) {\n\tcmd, args, err := p.PrepareCommand(extraArgs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif cmd != \"echo\" {\n\t\tt.Fatalf(\"Expected echo, got %q\", cmd)\n\t}\n\n\tif l := len(args); l != 5 {\n\t\tt.Fatalf(\"expected 5 args, got %d\", l)\n\t}\n\n\texpect := []string{\"-n\", osStrCmp, \"--debug\", \"--foo\", \"bar\"}\n\tfor i := 0; i < len(args); i++ {\n\t\tif expect[i] != args[i] {\n\t\t\tt.Errorf(\"Expected arg=%q, got %q\", expect[i], args[i])\n\t\t}\n\t}\n\n\t// Test with IgnoreFlags. This should omit --debug, --foo, bar\n\tp.Metadata.IgnoreFlags = true\n\tcmd, args, err = p.PrepareCommand(extraArgs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif cmd != \"echo\" {\n\t\tt.Fatalf(\"Expected echo, got %q\", cmd)\n\t}\n\tif l := len(args); l != 2 {\n\t\tt.Fatalf(\"expected 2 args, got %d\", l)\n\t}\n\texpect = []string{\"-n\", osStrCmp}\n\tfor i := 0; i < len(args); i++ {\n\t\tif expect[i] != args[i] {\n\t\t\tt.Errorf(\"Expected arg=%q, got %q\", expect[i], args[i])\n\t\t}\n\t}\n}\n\nfunc TestPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n foo\",\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\tcheckCommand(p, argv, \"foo\", t)\n}\n\nfunc TestPlatformPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n os-arch\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"i386\", Command: \"echo -n linux-i386\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"amd64\", Command: \"echo -n linux-amd64\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"arm64\", Command: \"echo -n linux-arm64\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"ppc64le\", Command: \"echo -n linux-ppc64le\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"s390x\", Command: \"echo -n linux-s390x\"},\n\t\t\t\t{OperatingSystem: \"windows\", Architecture: \"amd64\", Command: \"echo -n win-64\"},\n\t\t\t},\n\t\t},\n\t}\n\tvar osStrCmp string\n\tos := runtime.GOOS\n\tarch := runtime.GOARCH\n\tif os == \"linux\" && arch == \"i386\" {\n\t\tosStrCmp = \"linux-i386\"\n\t} else if os == \"linux\" && arch == \"amd64\" {\n\t\tosStrCmp = \"linux-amd64\"\n\t} else if os == \"linux\" && arch == \"arm64\" {\n\t\tosStrCmp = \"linux-arm64\"\n\t} else if os == \"linux\" && arch == \"ppc64le\" {\n\t\tosStrCmp = \"linux-ppc64le\"\n\t} else if os == \"linux\" && arch == \"s390x\" {\n\t\tosStrCmp = \"linux-s390x\"\n\t} else if os == \"windows\" && arch == \"amd64\" {\n\t\tosStrCmp = \"win-64\"\n\t} else {\n\t\tosStrCmp = \"os-arch\"\n\t}\n\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\tcheckCommand(p, argv, osStrCmp, t)\n}\n\nfunc TestPartialPlatformPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n os-arch\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"i386\", Command: \"echo -n linux-i386\"},\n\t\t\t\t{OperatingSystem: \"windows\", Architecture: \"amd64\", Command: \"echo -n win-64\"},\n\t\t\t},\n\t\t},\n\t}\n\tvar osStrCmp string\n\tos := runtime.GOOS\n\tarch := runtime.GOARCH\n\tif os == \"linux\" {\n\t\tosStrCmp = \"linux-i386\"\n\t} else if os == \"windows\" && arch == \"amd64\" {\n\t\tosStrCmp = \"win-64\"\n\t} else {\n\t\tosStrCmp = \"os-arch\"\n\t}\n\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\tcheckCommand(p, argv, osStrCmp, t)\n}\n\nfunc TestNoPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName: \"test\",\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\t_, _, err := p.PrepareCommand(argv)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error to be returned\")\n\t}\n}\n\nfunc TestNoMatchPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName: \"test\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"no-os\", Architecture: \"amd64\", Command: \"echo -n linux-i386\"},\n\t\t\t},\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\tif _, _, err := p.PrepareCommand(argv); err == nil {\n\t\tt.Fatalf(\"Expected error to be returned\")\n\t}\n}\n\nfunc TestLoadDir(t *testing.T) {\n\tdirname := \"testdata/plugdir/hello\"\n\tplug, err := LoadDir(dirname)\n\tif err != nil {\n\t\tt.Fatalf(\"error loading Hello plugin: %s\", err)\n\t}\n\n\tif plug.Dir != dirname {\n\t\tt.Fatalf(\"Expected dir %q, got %q\", dirname, plug.Dir)\n\t}\n\n\texpect := &Metadata{\n\t\tName:        \"hello\",\n\t\tVersion:     \"0.1.0\",\n\t\tUsage:       \"usage\",\n\t\tDescription: \"description\",\n\t\tCommand:     \"$HELM_PLUGIN_SELF/hello.sh\",\n\t\tIgnoreFlags: true,\n\t\tHooks: map[string]string{\n\t\t\tInstall: \"echo installing...\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(expect, plug.Metadata) {\n\t\tt.Fatalf(\"Expected plugin metadata %v, got %v\", expect, plug.Metadata)\n\t}\n}\n\nfunc TestDownloader(t *testing.T) {\n\tdirname := \"testdata/plugdir/downloader\"\n\tplug, err := LoadDir(dirname)\n\tif err != nil {\n\t\tt.Fatalf(\"error loading Hello plugin: %s\", err)\n\t}\n\n\tif plug.Dir != dirname {\n\t\tt.Fatalf(\"Expected dir %q, got %q\", dirname, plug.Dir)\n\t}\n\n\texpect := &Metadata{\n\t\tName:        \"downloader\",\n\t\tVersion:     \"1.2.3\",\n\t\tUsage:       \"usage\",\n\t\tDescription: \"download something\",\n\t\tCommand:     \"echo Hello\",\n\t\tDownloaders: []Downloaders{\n\t\t\t{\n\t\t\t\tProtocols: []string{\"myprotocol\", \"myprotocols\"},\n\t\t\t\tCommand:   \"echo Download\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(expect, plug.Metadata) {\n\t\tt.Fatalf(\"Expected metadata %v, got %v\", expect, plug.Metadata)\n\t}\n}\n\nfunc TestLoadAll(t *testing.T) {\n\n\t// Verify that empty dir loads:\n\tif plugs, err := LoadAll(\"testdata\"); err != nil {\n\t\tt.Fatalf(\"error loading dir with no plugins: %s\", err)\n\t} else if len(plugs) > 0 {\n\t\tt.Fatalf(\"expected empty dir to have 0 plugins\")\n\t}\n\n\tbasedir := \"testdata/plugdir\"\n\tplugs, err := LoadAll(basedir)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not load %q: %s\", basedir, err)\n\t}\n\n\tif l := len(plugs); l != 3 {\n\t\tt.Fatalf(\"expected 3 plugins, found %d\", l)\n\t}\n\n\tif plugs[0].Metadata.Name != \"downloader\" {\n\t\tt.Errorf(\"Expected first plugin to be echo, got %q\", plugs[0].Metadata.Name)\n\t}\n\tif plugs[1].Metadata.Name != \"echo\" {\n\t\tt.Errorf(\"Expected first plugin to be echo, got %q\", plugs[0].Metadata.Name)\n\t}\n\tif plugs[2].Metadata.Name != \"hello\" {\n\t\tt.Errorf(\"Expected second plugin to be hello, got %q\", plugs[1].Metadata.Name)\n\t}\n}\n\nfunc TestFindPlugins(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tplugdirs string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"plugdirs is empty\",\n\t\t\tplugdirs: \"\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"plugdirs isn't dir\",\n\t\t\tplugdirs: \"./plugin_test.go\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"plugdirs doens't have plugin\",\n\t\t\tplugdirs: \".\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal\",\n\t\t\tplugdirs: \"./testdata/plugdir\",\n\t\t\texpected: 3,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(t.Name(), func(t *testing.T) {\n\t\t\tplugin, _ := FindPlugins(c.plugdirs)\n\t\t\tif len(plugin) != c.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", c.expected, len(plugin))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetupEnv(t *testing.T) {\n\tname := \"pequod\"\n\tbase := filepath.Join(\"testdata/helmhome/helm/plugins\", name)\n\n\ts := cli.New()\n\ts.PluginsDirectory = \"testdata/helmhome/helm/plugins\"\n\n\tSetupPluginEnv(s, name, base)\n\tfor _, tt := range []struct {\n\t\tname, expect string\n\t}{\n\t\t{\"HELM_PLUGIN_NAME\", name},\n\t\t{\"HELM_PLUGIN_DIR\", base},\n\t} {\n\t\tif got := os.Getenv(tt.name); got != tt.expect {\n\t\t\tt.Errorf(\"Expected $%s=%q, got %q\", tt.name, tt.expect, got)\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/plugin\"\n)\n\nconst (\n\tpluginStaticCompletionFile        = \"completion.yaml\"\n\tpluginDynamicCompletionExecutable = \"plugin.complete\"\n)\n\ntype pluginError struct {\n\terror\n\tcode int\n}\n\n// loadPlugins loads plugins into the command list.\n//\n// This follows a different pattern than the other commands because it has\n// to inspect its environment and then add commands to the base command\n// as it finds them.\nfunc loadPlugins(baseCmd *cobra.Command, out io.Writer) {\n\n\t// If HELM_NO_PLUGINS is set to 1, do not load plugins.\n\tif os.Getenv(\"HELM_NO_PLUGINS\") == \"1\" {\n\t\treturn\n\t}\n\n\tfound, err := plugin.FindPlugins(settings.PluginsDirectory)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"failed to load plugins: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Now we create commands for all of these.\n\tfor _, plug := range found {\n\t\tplug := plug\n\t\tmd := plug.Metadata\n\t\tif md.Usage == \"\" {\n\t\t\tmd.Usage = fmt.Sprintf(\"the %q plugin\", md.Name)\n\t\t}\n\n\t\tc := &cobra.Command{\n\t\t\tUse:   md.Name,\n\t\t\tShort: md.Usage,\n\t\t\tLong:  md.Description,\n\t\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t\tu, err := processParent(cmd, args)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t// Call setupEnv before PrepareCommand because\n\t\t\t\t// PrepareCommand uses os.ExpandEnv and expects the\n\t\t\t\t// setupEnv vars.\n\t\t\t\tplugin.SetupPluginEnv(settings, md.Name, plug.Dir)\n\t\t\t\tmain, argv, prepCmdErr := plug.PrepareCommand(u)\n\t\t\t\tif prepCmdErr != nil {\n\t\t\t\t\tos.Stderr.WriteString(prepCmdErr.Error())\n\t\t\t\t\treturn errors.Errorf(\"plugin %q exited with error\", md.Name)\n\t\t\t\t}\n\n\t\t\t\treturn callPluginExecutable(md.Name, main, argv, out)\n\t\t\t},\n\t\t\t// This passes all the flags to the subcommand.\n\t\t\tDisableFlagParsing: true,\n\t\t}\n\n\t\t// TODO: Make sure a command with this name does not already exist.\n\t\tbaseCmd.AddCommand(c)\n\n\t\t// For completion, we try to load more details about the plugins so as to allow for command and\n\t\t// flag completion of the plugin itself.\n\t\t// We only do this when necessary (for the \"completion\" and \"__complete\" commands) to avoid the\n\t\t// risk of a rogue plugin affecting Helm's normal behavior.\n\t\tsubCmd, _, err := baseCmd.Find(os.Args[1:])\n\t\tif (err == nil &&\n\t\t\t((subCmd.HasParent() && subCmd.Parent().Name() == \"completion\") || subCmd.Name() == cobra.ShellCompRequestCmd)) ||\n\t\t\t/* for the tests */ subCmd == baseCmd.Root() {\n\t\t\tloadCompletionForPlugin(c, plug)\n\t\t}\n\t}\n}\n\nfunc processParent(cmd *cobra.Command, args []string) ([]string, error) {\n\tk, u := manuallyProcessArgs(args)\n\tif err := cmd.Parent().ParseFlags(k); err != nil {\n\t\treturn nil, err\n\t}\n\treturn u, nil\n}\n\n// This function is used to setup the environment for the plugin and then\n// call the executable specified by the parameter 'main'\nfunc callPluginExecutable(pluginName string, main string, argv []string, out io.Writer) error {\n\tenv := os.Environ()\n\tfor k, v := range settings.EnvVars() {\n\t\tenv = append(env, fmt.Sprintf(\"%s=%s\", k, v))\n\t}\n\n\tprog := exec.Command(main, argv...)\n\tprog.Env = env\n\tprog.Stdin = os.Stdin\n\tprog.Stdout = out\n\tprog.Stderr = os.Stderr\n\tif err := prog.Run(); err != nil {\n\t\tif eerr, ok := err.(*exec.ExitError); ok {\n\t\t\tos.Stderr.Write(eerr.Stderr)\n\t\t\tstatus := eerr.Sys().(syscall.WaitStatus)\n\t\t\treturn pluginError{\n\t\t\t\terror: errors.Errorf(\"plugin %q exited with error\", pluginName),\n\t\t\t\tcode:  status.ExitStatus(),\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// manuallyProcessArgs processes an arg array, removing special args.\n//\n// Returns two sets of args: known and unknown (in that order)\nfunc manuallyProcessArgs(args []string) ([]string, []string) {\n\tknown := []string{}\n\tunknown := []string{}\n\tkvargs := []string{\"--kube-context\", \"--namespace\", \"-n\", \"--kubeconfig\", \"--kube-apiserver\", \"--kube-token\", \"--kube-as-user\", \"--kube-as-group\", \"--registry-config\", \"--repository-cache\", \"--repository-config\"}\n\tknownArg := func(a string) bool {\n\t\tfor _, pre := range kvargs {\n\t\t\tif strings.HasPrefix(a, pre+\"=\") {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tisKnown := func(v string) string {\n\t\tfor _, i := range kvargs {\n\t\t\tif i == v {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tfor i := 0; i < len(args); i++ {\n\t\tswitch a := args[i]; a {\n\t\tcase \"--debug\":\n\t\t\tknown = append(known, a)\n\t\tcase isKnown(a):\n\t\t\tknown = append(known, a)\n\t\t\ti++\n\t\t\tif i < len(args) {\n\t\t\t\tknown = append(known, args[i])\n\t\t\t}\n\t\tdefault:\n\t\t\tif knownArg(a) {\n\t\t\t\tknown = append(known, a)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tunknown = append(unknown, a)\n\t\t}\n\t}\n\treturn known, unknown\n}\n\n// pluginCommand represents the optional completion.yaml file of a plugin\ntype pluginCommand struct {\n\tName      string          `json:\"name\"`\n\tValidArgs []string        `json:\"validArgs\"`\n\tFlags     []string        `json:\"flags\"`\n\tCommands  []pluginCommand `json:\"commands\"`\n}\n\n// loadCompletionForPlugin will load and parse any completion.yaml provided by the plugin\n// and add the dynamic completion hook to call the optional plugin.complete\nfunc loadCompletionForPlugin(pluginCmd *cobra.Command, plugin *plugin.Plugin) {\n\t// Parse the yaml file providing the plugin's sub-commands and flags\n\tcmds, err := loadFile(strings.Join(\n\t\t[]string{plugin.Dir, pluginStaticCompletionFile}, string(filepath.Separator)))\n\n\tif err != nil {\n\t\t// The file could be missing or invalid.  No static completion for this plugin.\n\t\tif settings.Debug {\n\t\t\tlog.Output(2, fmt.Sprintf(\"[info] %s\\n\", err.Error()))\n\t\t}\n\t\t// Continue to setup dynamic completion.\n\t\tcmds = &pluginCommand{}\n\t}\n\n\t// Preserve the Usage string specified for the plugin\n\tcmds.Name = pluginCmd.Use\n\n\taddPluginCommands(plugin, pluginCmd, cmds)\n}\n\n// addPluginCommands is a recursive method that adds each different level\n// of sub-commands and flags for the plugins that have provided such information\nfunc addPluginCommands(plugin *plugin.Plugin, baseCmd *cobra.Command, cmds *pluginCommand) {\n\tif cmds == nil {\n\t\treturn\n\t}\n\n\tif len(cmds.Name) == 0 {\n\t\t// Missing name for a command\n\t\tif settings.Debug {\n\t\t\tlog.Output(2, fmt.Sprintf(\"[info] sub-command name field missing for %s\", baseCmd.CommandPath()))\n\t\t}\n\t\treturn\n\t}\n\n\tbaseCmd.Use = cmds.Name\n\tbaseCmd.ValidArgs = cmds.ValidArgs\n\t// Setup the same dynamic completion for each plugin sub-command.\n\t// This is because if dynamic completion is triggered, there is a single executable\n\t// to call (plugin.complete), so every sub-commands calls it in the same fashion.\n\tif cmds.Commands == nil {\n\t\t// Only setup dynamic completion if there are no sub-commands.  This avoids\n\t\t// calling plugin.complete at every completion, which greatly simplifies\n\t\t// development of plugin.complete for plugin developers.\n\t\tbaseCmd.ValidArgsFunction = func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\treturn pluginDynamicComp(plugin, cmd, args, toComplete)\n\t\t}\n\t}\n\n\t// Create fake flags.\n\tif len(cmds.Flags) > 0 {\n\t\t// The flags can be created with any type, since we only need them for completion.\n\t\t// pflag does not allow to create short flags without a corresponding long form\n\t\t// so we look for all short flags and match them to any long flag.  This will allow\n\t\t// plugins to provide short flags without a long form.\n\t\t// If there are more short-flags than long ones, we'll create an extra long flag with\n\t\t// the same single letter as the short form.\n\t\tshorts := []string{}\n\t\tlongs := []string{}\n\t\tfor _, flag := range cmds.Flags {\n\t\t\tif len(flag) == 1 {\n\t\t\t\tshorts = append(shorts, flag)\n\t\t\t} else {\n\t\t\t\tlongs = append(longs, flag)\n\t\t\t}\n\t\t}\n\n\t\tf := baseCmd.Flags()\n\t\tif len(longs) >= len(shorts) {\n\t\t\tfor i := range longs {\n\t\t\t\tif i < len(shorts) {\n\t\t\t\t\tf.BoolP(longs[i], shorts[i], false, \"\")\n\t\t\t\t} else {\n\t\t\t\t\tf.Bool(longs[i], false, \"\")\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := range shorts {\n\t\t\t\tif i < len(longs) {\n\t\t\t\t\tf.BoolP(longs[i], shorts[i], false, \"\")\n\t\t\t\t} else {\n\t\t\t\t\t// Create a long flag with the same name as the short flag.\n\t\t\t\t\t// Not a perfect solution, but its better than ignoring the extra short flags.\n\t\t\t\t\tf.BoolP(shorts[i], shorts[i], false, \"\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Recursively add any sub-commands\n\tfor _, cmd := range cmds.Commands {\n\t\t// Create a fake command so that completion can be done for the sub-commands of the plugin\n\t\tsubCmd := &cobra.Command{\n\t\t\t// This prevents Cobra from removing the flags.  We want to keep the flags to pass them\n\t\t\t// to the dynamic completion script of the plugin.\n\t\t\tDisableFlagParsing: true,\n\t\t\t// A Run is required for it to be a valid command without subcommands\n\t\t\tRun: func(cmd *cobra.Command, args []string) {},\n\t\t}\n\t\tbaseCmd.AddCommand(subCmd)\n\t\taddPluginCommands(plugin, subCmd, &cmd)\n\t}\n}\n\n// loadFile takes a yaml file at the given path, parses it and returns a pluginCommand object\nfunc loadFile(path string) (*pluginCommand, error) {\n\tcmds := new(pluginCommand)\n\tb, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn cmds, errors.New(fmt.Sprintf(\"File (%s) not provided by plugin. No plugin auto-completion possible.\", path))\n\t}\n\n\terr = yaml.Unmarshal(b, cmds)\n\treturn cmds, err\n}\n\n// pluginDynamicComp call the plugin.complete script of the plugin (if available)\n// to obtain the dynamic completion choices.  It must pass all the flags and sub-commands\n// specified in the command-line to the plugin.complete executable (except helm's global flags)\nfunc pluginDynamicComp(plug *plugin.Plugin, cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\tmd := plug.Metadata\n\n\tu, err := processParent(cmd, args)\n\tif err != nil {\n\t\treturn nil, cobra.ShellCompDirectiveError\n\t}\n\n\t// We will call the dynamic completion script of the plugin\n\tmain := strings.Join([]string{plug.Dir, pluginDynamicCompletionExecutable}, string(filepath.Separator))\n\n\t// We must include all sub-commands passed on the command-line.\n\t// To do that, we pass-in the entire CommandPath, except the first two elements\n\t// which are 'helm' and 'pluginName'.\n\targv := strings.Split(cmd.CommandPath(), \" \")[2:]\n\tif !md.IgnoreFlags {\n\t\targv = append(argv, u...)\n\t\targv = append(argv, toComplete)\n\t}\n\tplugin.SetupPluginEnv(settings, md.Name, plug.Dir)\n\n\tcobra.CompDebugln(fmt.Sprintf(\"calling %s with args %v\", main, argv), settings.Debug)\n\tbuf := new(bytes.Buffer)\n\tif err := callPluginExecutable(md.Name, main, argv, buf); err != nil {\n\t\t// The dynamic completion file is optional for a plugin, so this error is ok.\n\t\tcobra.CompDebugln(fmt.Sprintf(\"Unable to call %s: %v\", main, err.Error()), settings.Debug)\n\t\treturn nil, cobra.ShellCompDirectiveDefault\n\t}\n\n\tvar completions []string\n\tfor _, comp := range strings.Split(buf.String(), \"\\n\") {\n\t\t// Remove any empty lines\n\t\tif len(comp) > 0 {\n\t\t\tcompletions = append(completions, comp)\n\t\t}\n\t}\n\n\t// Check if the last line of output is of the form :<integer>, which\n\t// indicates the BashCompletionDirective.\n\tdirective := cobra.ShellCompDirectiveDefault\n\tif len(completions) > 0 {\n\t\tlastLine := completions[len(completions)-1]\n\t\tif len(lastLine) > 1 && lastLine[0] == ':' {\n\t\t\tif strInt, err := strconv.Atoi(lastLine[1:]); err == nil {\n\t\t\t\tdirective = cobra.ShellCompDirective(strInt)\n\t\t\t\tcompletions = completions[:len(completions)-1]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn completions, directive\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/pkg/errors\"\n\t\"github.com/spf13/cobra\"\n\n\t\"helm.sh/helm/v3/cmd/helm/require\"\n\t\"helm.sh/helm/v3/pkg/plugin\"\n\t\"helm.sh/helm/v3/pkg/plugin/installer\"\n)\n\ntype pluginInstallOptions struct {\n\tsource  string\n\tversion string\n}\n\nconst pluginInstallDesc = `\nThis command allows you to install a plugin from a url to a VCS repo or a local path.\n`\n\nfunc newPluginInstallCmd(out io.Writer) *cobra.Command {\n\to := &pluginInstallOptions{}\n\tcmd := &cobra.Command{\n\t\tUse:     \"install [options] <path|url>...\",\n\t\tShort:   \"install one or more Helm plugins\",\n\t\tLong:    pluginInstallDesc,\n\t\tAliases: []string{\"add\"},\n\t\tArgs:    require.ExactArgs(1),\n\t\tValidArgsFunction: func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {\n\t\t\tif len(args) == 0 {\n\t\t\t\t// We do file completion, in case the plugin is local\n\t\t\t\treturn nil, cobra.ShellCompDirectiveDefault\n\t\t\t}\n\t\t\t// No more completion once the plugin path has been specified\n\t\t\treturn nil, cobra.ShellCompDirectiveNoFileComp\n\t\t},\n\t\tPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn o.complete(args)\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\treturn o.run(out)\n\t\t},\n\t}\n\tcmd.Flags().StringVar(&o.version, \"version\", \"\", \"specify a version constraint. If this is not specified, the latest version is installed\")\n\treturn cmd\n}\n\nfunc (o *pluginInstallOptions) complete(args []string) error {\n\to.source = args[0]\n\treturn nil\n}\n\nfunc (o *pluginInstallOptions) run(out io.Writer) error {\n\tinstaller.Debug = settings.Debug\n\n\ti, err := installer.NewForSource(o.source, o.version)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := installer.Install(i); err != nil {\n\t\treturn err\n\t}\n\n\tdebug(\"loading plugin from %s\", i.Path())\n\tp, err := plugin.LoadDir(i.Path())\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"plugin is installed but unusable\")\n\t}\n\n\tif err := runHook(p, plugin.Install); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(out, \"Installed plugin: %s\\n\", p.Metadata.Name)\n\treturn nil\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage plugin // import \"helm.sh/helm/v3/pkg/plugin\"\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\t\"sigs.k8s.io/yaml\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n)\n\nconst PluginFileName = \"plugin.yaml\"\n\n// Downloaders represents the plugins capability if it can retrieve\n// charts from special sources\ntype Downloaders struct {\n\t// Protocols are the list of schemes from the charts URL.\n\tProtocols []string `json:\"protocols\"`\n\t// Command is the executable path with which the plugin performs\n\t// the actual download for the corresponding Protocols\n\tCommand string `json:\"command\"`\n}\n\n// PlatformCommand represents a command for a particular operating system and architecture\ntype PlatformCommand struct {\n\tOperatingSystem string `json:\"os\"`\n\tArchitecture    string `json:\"arch\"`\n\tCommand         string `json:\"command\"`\n}\n\n// Metadata describes a plugin.\n//\n// This is the plugin equivalent of a chart.Metadata.\ntype Metadata struct {\n\t// Name is the name of the plugin\n\tName string `json:\"name\"`\n\n\t// Version is a SemVer 2 version of the plugin.\n\tVersion string `json:\"version\"`\n\n\t// Usage is the single-line usage text shown in help\n\tUsage string `json:\"usage\"`\n\n\t// Description is a long description shown in places like `helm help`\n\tDescription string `json:\"description\"`\n\n\t// Command is the command, as a single string.\n\t//\n\t// The command will be passed through environment expansion, so env vars can\n\t// be present in this command. Unless IgnoreFlags is set, this will\n\t// also merge the flags passed from Helm.\n\t//\n\t// Note that command is not executed in a shell. To do so, we suggest\n\t// pointing the command to a shell script.\n\t//\n\t// The following rules will apply to processing commands:\n\t// - If platformCommand is present, it will be searched first\n\t// - If both OS and Arch match the current platform, search will stop and the command will be executed\n\t// - If OS matches and there is no more specific match, the command will be executed\n\t// - If no OS/Arch match is found, the default command will be executed\n\t// - If no command is present and no matches are found in platformCommand, Helm will exit with an error\n\tPlatformCommand []PlatformCommand `json:\"platformCommand\"`\n\tCommand         string            `json:\"command\"`\n\n\t// IgnoreFlags ignores any flags passed in from Helm\n\t//\n\t// For example, if the plugin is invoked as `helm --debug myplugin`, if this\n\t// is false, `--debug` will be appended to `--command`. If this is true,\n\t// the `--debug` flag will be discarded.\n\tIgnoreFlags bool `json:\"ignoreFlags\"`\n\n\t// Hooks are commands that will run on events.\n\tHooks Hooks\n\n\t// Downloaders field is used if the plugin supply downloader mechanism\n\t// for special protocols.\n\tDownloaders []Downloaders `json:\"downloaders\"`\n}\n\n// Plugin represents a plugin.\ntype Plugin struct {\n\t// Metadata is a parsed representation of a plugin.yaml\n\tMetadata *Metadata\n\t// Dir is the string path to the directory that holds the plugin.\n\tDir string\n}\n\n// The following rules will apply to processing the Plugin.PlatformCommand.Command:\n// - If both OS and Arch match the current platform, search will stop and the command will be prepared for execution\n// - If OS matches and there is no more specific match, the command will be prepared for execution\n// - If no OS/Arch match is found, return nil\nfunc getPlatformCommand(cmds []PlatformCommand) []string {\n\tvar command []string\n\teq := strings.EqualFold\n\tfor _, c := range cmds {\n\t\tif eq(c.OperatingSystem, runtime.GOOS) {\n\t\t\tcommand = strings.Split(os.ExpandEnv(c.Command), \" \")\n\t\t}\n\t\tif eq(c.OperatingSystem, runtime.GOOS) && eq(c.Architecture, runtime.GOARCH) {\n\t\t\treturn strings.Split(os.ExpandEnv(c.Command), \" \")\n\t\t}\n\t}\n\treturn command\n}\n\n// PrepareCommand takes a Plugin.PlatformCommand.Command, a Plugin.Command and will applying the following processing:\n// - If platformCommand is present, it will be searched first\n// - If both OS and Arch match the current platform, search will stop and the command will be prepared for execution\n// - If OS matches and there is no more specific match, the command will be prepared for execution\n// - If no OS/Arch match is found, the default command will be prepared for execution\n// - If no command is present and no matches are found in platformCommand, will exit with an error\n//\n// It merges extraArgs into any arguments supplied in the plugin. It\n// returns the name of the command and an args array.\n//\n// The result is suitable to pass to exec.Command.\nfunc (p *Plugin) PrepareCommand(extraArgs []string) (string, []string, error) {\n\tvar parts []string\n\tplatCmdLen := len(p.Metadata.PlatformCommand)\n\tif platCmdLen > 0 {\n\t\tparts = getPlatformCommand(p.Metadata.PlatformCommand)\n\t}\n\tif platCmdLen == 0 || parts == nil {\n\t\tparts = strings.Split(os.ExpandEnv(p.Metadata.Command), \" \")\n\t}\n\tif len(parts) == 0 || parts[0] == \"\" {\n\t\treturn \"\", nil, fmt.Errorf(\"No plugin command is applicable\")\n\t}\n\n\tmain := parts[0]\n\tbaseArgs := []string{}\n\tif len(parts) > 1 {\n\t\tbaseArgs = parts[1:]\n\t}\n\tif !p.Metadata.IgnoreFlags {\n\t\tbaseArgs = append(baseArgs, extraArgs...)\n\t}\n\treturn main, baseArgs, nil\n}\n\n// validPluginName is a regular expression that validates plugin names.\n//\n// Plugin names can only contain the ASCII characters a-z, A-Z, 0-9, \u200b_\u200b and \u200b-.\nvar validPluginName = regexp.MustCompile(\"^[A-Za-z0-9_-]+$\")\n\n// validatePluginData validates a plugin's YAML data.\nfunc validatePluginData(plug *Plugin, filepath string) error {\n\tif !validPluginName.MatchString(plug.Metadata.Name) {\n\t\treturn fmt.Errorf(\"invalid plugin name at %q\", filepath)\n\t}\n\t// We could also validate SemVer, executable, and other fields should we so choose.\n\treturn nil\n}\n\nfunc detectDuplicates(plugs []*Plugin) error {\n\tnames := map[string]string{}\n\n\tfor _, plug := range plugs {\n\t\tif oldpath, ok := names[plug.Metadata.Name]; ok {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"two plugins claim the name %q at %q and %q\",\n\t\t\t\tplug.Metadata.Name,\n\t\t\t\toldpath,\n\t\t\t\tplug.Dir,\n\t\t\t)\n\t\t}\n\t\tnames[plug.Metadata.Name] = plug.Dir\n\t}\n\n\treturn nil\n}\n\n// LoadDir loads a plugin from the given directory.\nfunc LoadDir(dirname string) (*Plugin, error) {\n\tpluginfile := filepath.Join(dirname, PluginFileName)\n\tdata, err := ioutil.ReadFile(pluginfile)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to read plugin at %q\", pluginfile)\n\t}\n\n\tplug := &Plugin{Dir: dirname}\n\tif err := yaml.Unmarshal(data, &plug.Metadata); err != nil {\n\t\treturn nil, errors.Wrapf(err, \"failed to load plugin at %q\", pluginfile)\n\t}\n\treturn plug, validatePluginData(plug, pluginfile)\n}\n\n// LoadAll loads all plugins found beneath the base directory.\n//\n// This scans only one directory level.\nfunc LoadAll(basedir string) ([]*Plugin, error) {\n\tplugins := []*Plugin{}\n\t// We want basedir/*/plugin.yaml\n\tscanpath := filepath.Join(basedir, \"*\", PluginFileName)\n\tmatches, err := filepath.Glob(scanpath)\n\tif err != nil {\n\t\treturn plugins, errors.Wrapf(err, \"failed to find plugins in %q\", scanpath)\n\t}\n\n\tif matches == nil {\n\t\treturn plugins, nil\n\t}\n\n\tfor _, yaml := range matches {\n\t\tdir := filepath.Dir(yaml)\n\t\tp, err := LoadDir(dir)\n\t\tif err != nil {\n\t\t\treturn plugins, err\n\t\t}\n\t\tplugins = append(plugins, p)\n\t}\n\treturn plugins, detectDuplicates(plugins)\n}\n\n// FindPlugins returns a list of YAML files that describe plugins.\nfunc FindPlugins(plugdirs string) ([]*Plugin, error) {\n\tfound := []*Plugin{}\n\t// Let's get all UNIXy and allow path separators\n\tfor _, p := range filepath.SplitList(plugdirs) {\n\t\tmatches, err := LoadAll(p)\n\t\tif err != nil {\n\t\t\treturn matches, err\n\t\t}\n\t\tfound = append(found, matches...)\n\t}\n\treturn found, nil\n}\n\n// SetupPluginEnv prepares os.Env for plugins. It operates on os.Env because\n// the plugin subsystem itself needs access to the environment variables\n// created here.\nfunc SetupPluginEnv(settings *cli.EnvSettings, name, base string) {\n\tenv := settings.EnvVars()\n\tenv[\"HELM_PLUGIN_NAME\"] = name\n\tenv[\"HELM_PLUGIN_DIR\"] = base\n\tfor key, val := range env {\n\t\tos.Setenv(key, val)\n\t}\n}\n", "/*\nCopyright The Helm Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage plugin // import \"helm.sh/helm/v3/pkg/plugin\"\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"helm.sh/helm/v3/pkg/cli\"\n)\n\nfunc checkCommand(p *Plugin, extraArgs []string, osStrCmp string, t *testing.T) {\n\tcmd, args, err := p.PrepareCommand(extraArgs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif cmd != \"echo\" {\n\t\tt.Fatalf(\"Expected echo, got %q\", cmd)\n\t}\n\n\tif l := len(args); l != 5 {\n\t\tt.Fatalf(\"expected 5 args, got %d\", l)\n\t}\n\n\texpect := []string{\"-n\", osStrCmp, \"--debug\", \"--foo\", \"bar\"}\n\tfor i := 0; i < len(args); i++ {\n\t\tif expect[i] != args[i] {\n\t\t\tt.Errorf(\"Expected arg=%q, got %q\", expect[i], args[i])\n\t\t}\n\t}\n\n\t// Test with IgnoreFlags. This should omit --debug, --foo, bar\n\tp.Metadata.IgnoreFlags = true\n\tcmd, args, err = p.PrepareCommand(extraArgs)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif cmd != \"echo\" {\n\t\tt.Fatalf(\"Expected echo, got %q\", cmd)\n\t}\n\tif l := len(args); l != 2 {\n\t\tt.Fatalf(\"expected 2 args, got %d\", l)\n\t}\n\texpect = []string{\"-n\", osStrCmp}\n\tfor i := 0; i < len(args); i++ {\n\t\tif expect[i] != args[i] {\n\t\t\tt.Errorf(\"Expected arg=%q, got %q\", expect[i], args[i])\n\t\t}\n\t}\n}\n\nfunc TestPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n foo\",\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\tcheckCommand(p, argv, \"foo\", t)\n}\n\nfunc TestPlatformPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n os-arch\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"i386\", Command: \"echo -n linux-i386\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"amd64\", Command: \"echo -n linux-amd64\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"arm64\", Command: \"echo -n linux-arm64\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"ppc64le\", Command: \"echo -n linux-ppc64le\"},\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"s390x\", Command: \"echo -n linux-s390x\"},\n\t\t\t\t{OperatingSystem: \"windows\", Architecture: \"amd64\", Command: \"echo -n win-64\"},\n\t\t\t},\n\t\t},\n\t}\n\tvar osStrCmp string\n\tos := runtime.GOOS\n\tarch := runtime.GOARCH\n\tif os == \"linux\" && arch == \"i386\" {\n\t\tosStrCmp = \"linux-i386\"\n\t} else if os == \"linux\" && arch == \"amd64\" {\n\t\tosStrCmp = \"linux-amd64\"\n\t} else if os == \"linux\" && arch == \"arm64\" {\n\t\tosStrCmp = \"linux-arm64\"\n\t} else if os == \"linux\" && arch == \"ppc64le\" {\n\t\tosStrCmp = \"linux-ppc64le\"\n\t} else if os == \"linux\" && arch == \"s390x\" {\n\t\tosStrCmp = \"linux-s390x\"\n\t} else if os == \"windows\" && arch == \"amd64\" {\n\t\tosStrCmp = \"win-64\"\n\t} else {\n\t\tosStrCmp = \"os-arch\"\n\t}\n\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\tcheckCommand(p, argv, osStrCmp, t)\n}\n\nfunc TestPartialPlatformPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName:    \"test\",\n\t\t\tCommand: \"echo -n os-arch\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"linux\", Architecture: \"i386\", Command: \"echo -n linux-i386\"},\n\t\t\t\t{OperatingSystem: \"windows\", Architecture: \"amd64\", Command: \"echo -n win-64\"},\n\t\t\t},\n\t\t},\n\t}\n\tvar osStrCmp string\n\tos := runtime.GOOS\n\tarch := runtime.GOARCH\n\tif os == \"linux\" {\n\t\tosStrCmp = \"linux-i386\"\n\t} else if os == \"windows\" && arch == \"amd64\" {\n\t\tosStrCmp = \"win-64\"\n\t} else {\n\t\tosStrCmp = \"os-arch\"\n\t}\n\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\tcheckCommand(p, argv, osStrCmp, t)\n}\n\nfunc TestNoPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName: \"test\",\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\t_, _, err := p.PrepareCommand(argv)\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error to be returned\")\n\t}\n}\n\nfunc TestNoMatchPrepareCommand(t *testing.T) {\n\tp := &Plugin{\n\t\tDir: \"/tmp\", // Unused\n\t\tMetadata: &Metadata{\n\t\t\tName: \"test\",\n\t\t\tPlatformCommand: []PlatformCommand{\n\t\t\t\t{OperatingSystem: \"no-os\", Architecture: \"amd64\", Command: \"echo -n linux-i386\"},\n\t\t\t},\n\t\t},\n\t}\n\targv := []string{\"--debug\", \"--foo\", \"bar\"}\n\n\tif _, _, err := p.PrepareCommand(argv); err == nil {\n\t\tt.Fatalf(\"Expected error to be returned\")\n\t}\n}\n\nfunc TestLoadDir(t *testing.T) {\n\tdirname := \"testdata/plugdir/hello\"\n\tplug, err := LoadDir(dirname)\n\tif err != nil {\n\t\tt.Fatalf(\"error loading Hello plugin: %s\", err)\n\t}\n\n\tif plug.Dir != dirname {\n\t\tt.Fatalf(\"Expected dir %q, got %q\", dirname, plug.Dir)\n\t}\n\n\texpect := &Metadata{\n\t\tName:        \"hello\",\n\t\tVersion:     \"0.1.0\",\n\t\tUsage:       \"usage\",\n\t\tDescription: \"description\",\n\t\tCommand:     \"$HELM_PLUGIN_SELF/hello.sh\",\n\t\tIgnoreFlags: true,\n\t\tHooks: map[string]string{\n\t\t\tInstall: \"echo installing...\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(expect, plug.Metadata) {\n\t\tt.Fatalf(\"Expected plugin metadata %v, got %v\", expect, plug.Metadata)\n\t}\n}\n\nfunc TestDownloader(t *testing.T) {\n\tdirname := \"testdata/plugdir/downloader\"\n\tplug, err := LoadDir(dirname)\n\tif err != nil {\n\t\tt.Fatalf(\"error loading Hello plugin: %s\", err)\n\t}\n\n\tif plug.Dir != dirname {\n\t\tt.Fatalf(\"Expected dir %q, got %q\", dirname, plug.Dir)\n\t}\n\n\texpect := &Metadata{\n\t\tName:        \"downloader\",\n\t\tVersion:     \"1.2.3\",\n\t\tUsage:       \"usage\",\n\t\tDescription: \"download something\",\n\t\tCommand:     \"echo Hello\",\n\t\tDownloaders: []Downloaders{\n\t\t\t{\n\t\t\t\tProtocols: []string{\"myprotocol\", \"myprotocols\"},\n\t\t\t\tCommand:   \"echo Download\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(expect, plug.Metadata) {\n\t\tt.Fatalf(\"Expected metadata %v, got %v\", expect, plug.Metadata)\n\t}\n}\n\nfunc TestLoadAll(t *testing.T) {\n\n\t// Verify that empty dir loads:\n\tif plugs, err := LoadAll(\"testdata\"); err != nil {\n\t\tt.Fatalf(\"error loading dir with no plugins: %s\", err)\n\t} else if len(plugs) > 0 {\n\t\tt.Fatalf(\"expected empty dir to have 0 plugins\")\n\t}\n\n\tbasedir := \"testdata/plugdir\"\n\tplugs, err := LoadAll(basedir)\n\tif err != nil {\n\t\tt.Fatalf(\"Could not load %q: %s\", basedir, err)\n\t}\n\n\tif l := len(plugs); l != 3 {\n\t\tt.Fatalf(\"expected 3 plugins, found %d\", l)\n\t}\n\n\tif plugs[0].Metadata.Name != \"downloader\" {\n\t\tt.Errorf(\"Expected first plugin to be echo, got %q\", plugs[0].Metadata.Name)\n\t}\n\tif plugs[1].Metadata.Name != \"echo\" {\n\t\tt.Errorf(\"Expected first plugin to be echo, got %q\", plugs[0].Metadata.Name)\n\t}\n\tif plugs[2].Metadata.Name != \"hello\" {\n\t\tt.Errorf(\"Expected second plugin to be hello, got %q\", plugs[1].Metadata.Name)\n\t}\n}\n\nfunc TestFindPlugins(t *testing.T) {\n\tcases := []struct {\n\t\tname     string\n\t\tplugdirs string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"plugdirs is empty\",\n\t\t\tplugdirs: \"\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"plugdirs isn't dir\",\n\t\t\tplugdirs: \"./plugin_test.go\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"plugdirs doens't have plugin\",\n\t\t\tplugdirs: \".\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal\",\n\t\t\tplugdirs: \"./testdata/plugdir\",\n\t\t\texpected: 3,\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tt.Run(t.Name(), func(t *testing.T) {\n\t\t\tplugin, _ := FindPlugins(c.plugdirs)\n\t\t\tif len(plugin) != c.expected {\n\t\t\t\tt.Errorf(\"expected: %v, got: %v\", c.expected, len(plugin))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetupEnv(t *testing.T) {\n\tname := \"pequod\"\n\tbase := filepath.Join(\"testdata/helmhome/helm/plugins\", name)\n\n\ts := cli.New()\n\ts.PluginsDirectory = \"testdata/helmhome/helm/plugins\"\n\n\tSetupPluginEnv(s, name, base)\n\tfor _, tt := range []struct {\n\t\tname, expect string\n\t}{\n\t\t{\"HELM_PLUGIN_NAME\", name},\n\t\t{\"HELM_PLUGIN_DIR\", base},\n\t} {\n\t\tif got := os.Getenv(tt.name); got != tt.expect {\n\t\t\tt.Errorf(\"Expected $%s=%q, got %q\", tt.name, tt.expect, got)\n\t\t}\n\t}\n}\n\nfunc TestValidatePluginData(t *testing.T) {\n\tfor i, item := range []struct {\n\t\tpass bool\n\t\tplug *Plugin\n\t}{\n\t\t{true, mockPlugin(\"abcdefghijklmnopqrstuvwxyz0123456789_-ABC\")},\n\t\t{true, mockPlugin(\"foo-bar-FOO-BAR_1234\")},\n\t\t{false, mockPlugin(\"foo -bar\")},\n\t\t{false, mockPlugin(\"$foo -bar\")}, // Test leading chars\n\t\t{false, mockPlugin(\"foo -bar \")}, // Test trailing chars\n\t\t{false, mockPlugin(\"foo\\nbar\")},  // Test newline\n\t} {\n\t\terr := validatePluginData(item.plug, fmt.Sprintf(\"test-%d\", i))\n\t\tif item.pass && err != nil {\n\t\t\tt.Errorf(\"failed to validate case %d: %s\", i, err)\n\t\t} else if !item.pass && err == nil {\n\t\t\tt.Errorf(\"expected case %d to fail\", i)\n\t\t}\n\t}\n}\n\nfunc TestDetectDuplicates(t *testing.T) {\n\tplugs := []*Plugin{\n\t\tmockPlugin(\"foo\"),\n\t\tmockPlugin(\"bar\"),\n\t}\n\tif err := detectDuplicates(plugs); err != nil {\n\t\tt.Error(\"no duplicates in the first set\")\n\t}\n\tplugs = append(plugs, mockPlugin(\"foo\"))\n\tif err := detectDuplicates(plugs); err == nil {\n\t\tt.Error(\"duplicates in the second set\")\n\t}\n}\n\nfunc mockPlugin(name string) *Plugin {\n\treturn &Plugin{\n\t\tMetadata: &Metadata{\n\t\t\tName:        name,\n\t\t\tVersion:     \"v0.1.2\",\n\t\t\tUsage:       \"Mock plugin\",\n\t\t\tDescription: \"Mock plugin for testing\",\n\t\t\tCommand:     \"echo mock plugin\",\n\t\t},\n\t\tDir: \"no-such-dir\",\n\t}\n}\n"], "filenames": ["cmd/helm/load_plugins.go", "cmd/helm/plugin_install.go", "pkg/plugin/plugin.go", "pkg/plugin/plugin_test.go"], "buggy_code_start_loc": [62, 21, 22, 18], "buggy_code_end_loc": [63, 85, 199, 322], "fixing_code_start_loc": [62, 22, 23, 19], "fixing_code_end_loc": [63, 86, 234, 372], "type": "CWE-74", "message": "In Helm before versions 2.16.11 and 3.3.2 plugin names are not sanitized properly. As a result, a malicious plugin author could use characters in a plugin name that would result in unexpected behavior, such as duplicating the name of another plugin or spoofing the output to `helm --help`. This issue has been patched in Helm 3.3.2. A possible workaround is to not install untrusted Helm plugins. Examine the `name` field in the `plugin.yaml` file for a plugin, looking for characters outside of the [a-zA-Z0-9._-] range.", "other": {"cve": {"id": "CVE-2020-15186", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-17T22:15:12.520", "lastModified": "2021-11-18T17:50:44.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Helm before versions 2.16.11 and 3.3.2 plugin names are not sanitized properly. As a result, a malicious plugin author could use characters in a plugin name that would result in unexpected behavior, such as duplicating the name of another plugin or spoofing the output to `helm --help`. This issue has been patched in Helm 3.3.2. A possible workaround is to not install untrusted Helm plugins. Examine the `name` field in the `plugin.yaml` file for a plugin, looking for characters outside of the [a-zA-Z0-9._-] range."}, {"lang": "es", "value": "En Helm versiones anteriores a 2.16.11 y 3.3.2, los nombres de los plugins no son saneados apropiadamente.&#xa0;Como resultado, un autor de plugin malicioso podr\u00eda usar caracteres en un nombre de plugin que resultar\u00eda en un comportamiento inesperado, como duplicar el nombre de otro plugin o falsificar la salida en \"helm --help\".&#xa0;Este problema ha sido corregido en Helm versi\u00f3n 3.3.2.&#xa0;Una posible soluci\u00f3n es no instalar plugins de Helm que no son de confianza.&#xa0;Examine el campo \"name\" en el archivo \"plugin.yaml\" en busca de un plugin, buscando caracteres fuera del rango [a-zA-Z0-9 ._-]"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.4, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.16.11", "matchCriteriaId": "455BCCE5-1D43-4E59-9591-E84B52DAAF0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:helm:helm:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.3.2", "matchCriteriaId": "B462D769-3FC0-4079-8B48-863F013662EF"}]}]}], "references": [{"url": "https://github.com/helm/helm/commit/809e2d999e2c33e20e77f6bff30652d79c287542", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/helm/helm/security/advisories/GHSA-m54r-vrmv-hw33", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/helm/helm/commit/809e2d999e2c33e20e77f6bff30652d79c287542"}}