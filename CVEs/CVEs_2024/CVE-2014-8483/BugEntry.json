{"buggy_code": ["/*\n  This file has been derived from Konversation, the KDE IRC client.\n  You can redistribute it and/or modify it under the terms of the\n  GNU General Public License as published by the Free Software Foundation;\n  either version 2 of the License, or (at your option) any later version.\n*/\n\n/*\n  Copyright (C) 1997 Robey Pointer <robeypointer@gmail.com>\n  Copyright (C) 2005 Ismail Donmez <ismail@kde.org>\n  Copyright (C) 2009 Travis McHenry <tmchenryaz@cox.net>\n  Copyright (C) 2009 Johannes Huber <johu@gmx.de>\n*/\n\n#include \"cipher.h\"\n#include \"logger.h\"\n\nCipher::Cipher()\n{\n    m_primeNum = QCA::BigInteger(\"12745216229761186769575009943944198619149164746831579719941140425076456621824834322853258804883232842877311723249782818608677050956745409379781245497526069657222703636504651898833151008222772087491045206203033063108075098874712912417029101508315117935752962862335062591404043092163187352352197487303798807791605274487594646923\");\n    setType(\"blowfish\");\n}\n\n\nCipher::Cipher(QByteArray key, QString cipherType)\n{\n    m_primeNum = QCA::BigInteger(\"12745216229761186769575009943944198619149164746831579719941140425076456621824834322853258804883232842877311723249782818608677050956745409379781245497526069657222703636504651898833151008222772087491045206203033063108075098874712912417029101508315117935752962862335062591404043092163187352352197487303798807791605274487594646923\");\n    setKey(key);\n    setType(cipherType);\n}\n\n\nCipher::~Cipher()\n{}\n\nbool Cipher::setKey(QByteArray key)\n{\n    if (key.isEmpty()) {\n        m_key.clear();\n        return false;\n    }\n\n    if (key.mid(0, 4).toLower() == \"ecb:\")\n    {\n        m_cbc = false;\n        m_key = key.mid(4);\n    }\n    //strip cbc: if included\n    else if (key.mid(0, 4).toLower() == \"cbc:\")\n    {\n        m_cbc = true;\n        m_key = key.mid(4);\n    }\n    else\n    {\n//    if(Preferences::self()->encryptionType())\n//      m_cbc = true;\n//    else\n        m_cbc = false;\n        m_key = key;\n    }\n    return true;\n}\n\n\nbool Cipher::setType(const QString &type)\n{\n    //TODO check QCA::isSupported()\n    m_type = type;\n    return true;\n}\n\n\nQByteArray Cipher::decrypt(QByteArray cipherText)\n{\n    QByteArray pfx = \"\";\n    bool error = false; // used to flag non cbc, seems like good practice not to parse w/o regard for set encryption type\n\n    //if we get cbc\n    if (cipherText.mid(0, 5) == \"+OK *\")\n    {\n        //if we have cbc\n        if (m_cbc)\n            cipherText = cipherText.mid(5);\n        //if we don't\n        else\n        {\n            cipherText = cipherText.mid(5);\n            pfx = \"ERROR_NONECB: \";\n            error = true;\n        }\n    }\n    //if we get ecb\n    else if (cipherText.mid(0, 4) == \"+OK \" || cipherText.mid(0, 5) == \"mcps \")\n    {\n        //if we had cbc\n        if (m_cbc)\n        {\n            cipherText = (cipherText.mid(0, 4) == \"+OK \") ? cipherText.mid(4) : cipherText.mid(5);\n            pfx = \"ERROR_NONCBC: \";\n            error = true;\n        }\n        //if we don't\n        else\n        {\n            if (cipherText.mid(0, 4) == \"+OK \")\n                cipherText = cipherText.mid(4);\n            else\n                cipherText = cipherText.mid(5);\n        }\n    }\n    //all other cases we fail\n    else\n        return cipherText;\n\n    QByteArray temp;\n    // (if cbc and no error we parse cbc) || (if ecb and error we parse cbc)\n    if ((m_cbc && !error) || (!m_cbc && error))\n    {\n        cipherText = cipherText;\n        temp = blowfishCBC(cipherText, false);\n\n        if (temp == cipherText)\n        {\n            // kDebug(\"Decryption from CBC Failed\");\n            return cipherText+' '+'\\n';\n        }\n        else\n            cipherText = temp;\n    }\n    else\n    {\n        temp = blowfishECB(cipherText, false);\n\n        if (temp == cipherText)\n        {\n            // kDebug(\"Decryption from ECB Failed\");\n            return cipherText+' '+'\\n';\n        }\n        else\n            cipherText = temp;\n    }\n    // TODO FIXME the proper fix for this is to show encryption differently e.g. [nick] instead of <nick>\n    // don't hate me for the mircryption reference there.\n    if (cipherText.at(0) == 1)\n        pfx = \"\\x0\";\n    cipherText = pfx+cipherText+' '+'\\n'; // FIXME(??) why is there an added space here?\n    return cipherText;\n}\n\n\nQByteArray Cipher::initKeyExchange()\n{\n    QCA::Initializer init;\n    m_tempKey = QCA::KeyGenerator().createDH(QCA::DLGroup(m_primeNum, QCA::BigInteger(2))).toDH();\n\n    if (m_tempKey.isNull())\n        return QByteArray();\n\n    QByteArray publicKey = m_tempKey.toPublicKey().toDH().y().toArray().toByteArray();\n\n    //remove leading 0\n    if (publicKey.length() > 135 && publicKey.at(0) == '\\0')\n        publicKey = publicKey.mid(1);\n\n    return publicKey.toBase64().append('A');\n}\n\n\nQByteArray Cipher::parseInitKeyX(QByteArray key)\n{\n    QCA::Initializer init;\n    bool isCBC = false;\n\n    if (key.endsWith(\" CBC\"))\n    {\n        isCBC = true;\n        key.chop(4);\n    }\n\n    if (key.length() != 181)\n        return QByteArray();\n\n    QCA::SecureArray remoteKey = QByteArray::fromBase64(key.left(180));\n    QCA::DLGroup group(m_primeNum, QCA::BigInteger(2));\n    QCA::DHPrivateKey privateKey = QCA::KeyGenerator().createDH(group).toDH();\n\n    if (privateKey.isNull())\n        return QByteArray();\n\n    QByteArray publicKey = privateKey.y().toArray().toByteArray();\n\n    //remove leading 0\n    if (publicKey.length() > 135 && publicKey.at(0) == '\\0')\n        publicKey = publicKey.mid(1);\n\n    QCA::DHPublicKey remotePub(group, remoteKey);\n\n    if (remotePub.isNull())\n        return QByteArray();\n\n    QByteArray sharedKey = privateKey.deriveKey(remotePub).toByteArray();\n    sharedKey = QCA::Hash(\"sha256\").hash(sharedKey).toByteArray().toBase64();\n\n    //remove trailing = because mircryption and fish think it's a swell idea.\n    while (sharedKey.endsWith('=')) sharedKey.chop(1);\n\n    if (isCBC)\n        sharedKey.prepend(\"cbc:\");\n\n    bool success = setKey(sharedKey);\n\n    if (!success)\n        return QByteArray();\n\n    return publicKey.toBase64().append('A');\n}\n\n\nbool Cipher::parseFinishKeyX(QByteArray key)\n{\n    QCA::Initializer init;\n\n    if (key.length() != 181)\n        return false;\n\n    QCA::SecureArray remoteKey = QByteArray::fromBase64(key.left(180));\n    QCA::DLGroup group(m_primeNum, QCA::BigInteger(2));\n\n    QCA::DHPublicKey remotePub(group, remoteKey);\n\n    if (remotePub.isNull())\n        return false;\n\n    if (m_tempKey.isNull())\n        return false;\n\n    QByteArray sharedKey = m_tempKey.deriveKey(remotePub).toByteArray();\n    sharedKey = QCA::Hash(\"sha256\").hash(sharedKey).toByteArray().toBase64();\n\n    //remove trailng = because mircryption and fish think it's a swell idea.\n    while (sharedKey.endsWith('=')) sharedKey.chop(1);\n\n    bool success = setKey(sharedKey);\n\n    return success;\n}\n\n\nQByteArray Cipher::decryptTopic(QByteArray cipherText)\n{\n    if (cipherText.mid(0, 4) == \"+OK \") // FiSH style topic\n        cipherText = cipherText.mid(4);\n    else if (cipherText.left(5) == \"\u00abm\u00ab\")\n        cipherText = cipherText.mid(5, cipherText.length()-10);\n    else\n        return cipherText;\n\n    QByteArray temp;\n    //TODO currently no backwards sanity checks for topic, it seems to use different standards\n    //if somebody figures them out they can enable it and add \"ERROR_NONECB/CBC\" warnings\n    if (m_cbc)\n        temp = blowfishCBC(cipherText.mid(1), false);\n    else\n        temp = blowfishECB(cipherText, false);\n\n    if (temp == cipherText)\n    {\n        return cipherText;\n    }\n    else\n        cipherText = temp;\n\n    if (cipherText.mid(0, 2) == \"@@\")\n        cipherText = cipherText.mid(2);\n\n    return cipherText;\n}\n\n\nbool Cipher::encrypt(QByteArray &cipherText)\n{\n    if (cipherText.left(3) == \"+p \") //don't encode if...?\n        cipherText = cipherText.mid(3);\n    else\n    {\n        if (m_cbc) //encode in ecb or cbc decide how to determine later\n        {\n            QByteArray temp = blowfishCBC(cipherText, true);\n\n            if (temp == cipherText)\n            {\n                // kDebug(\"CBC Encoding Failed\");\n                return false;\n            }\n\n            cipherText = \"+OK *\" + temp;\n        }\n        else\n        {\n            QByteArray temp = blowfishECB(cipherText, true);\n\n            if (temp == cipherText)\n            {\n                // kDebug(\"ECB Encoding Failed\");\n                return false;\n            }\n\n            cipherText = \"+OK \" + temp;\n        }\n    }\n    return true;\n}\n\n\n//THE BELOW WORKS AKA DO NOT TOUCH UNLESS YOU KNOW WHAT YOU'RE DOING\nQByteArray Cipher::blowfishCBC(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        // make sure cipherText is an interval of 8 bits. We do this before so that we\n        // know there's at least 8 bytes to en/decryption this ensures QCA doesn't fail\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n\n        QCA::InitializationVector iv(8);\n        temp.prepend(iv.toByteArray()); // prefix with 8bits of IV for mircryptions *CUSTOM* cbc implementation\n    }\n    else\n    {\n        temp = QByteArray::fromBase64(temp);\n        //supposedly nescessary if we get a truncated message also allows for decryption of 'crazy'\n        //en/decoding clients that use STANDARDIZED PADDING TECHNIQUES\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::CBC, QCA::Cipher::NoPadding, dir, m_key, QCA::InitializationVector(QByteArray(\"0\")));\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction) //send in base64\n        temp2 = temp2.toBase64();\n    else //cut off the 8bits of IV\n        temp2 = temp2.remove(0, 8);\n\n    return temp2;\n}\n\n\nQByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction)\n        temp2 = byteToB64(temp2);\n\n    return temp2;\n}\n\n\n//Custom non RFC 2045 compliant Base64 enc/dec code for mircryption / FiSH compatibility\nQByteArray Cipher::byteToB64(QByteArray text)\n{\n    int left = 0;\n    int right = 0;\n    int k = -1;\n    int v;\n    QString base64 = \"./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    QByteArray encoded;\n    while (k < (text.length() - 1)) {\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left = v << 24;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v << 16;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v << 8;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v;\n\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right = v << 24;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v << 16;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v << 8;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v;\n\n        for (int i = 0; i < 6; i++) {\n            encoded.append(base64.at(right & 0x3F).toAscii());\n            right = right >> 6;\n        }\n\n        //TODO make sure the .toascii doesn't break anything\n        for (int i = 0; i < 6; i++) {\n            encoded.append(base64.at(left & 0x3F).toAscii());\n            left = left >> 6;\n        }\n    }\n    return encoded;\n}\n\n\nQByteArray Cipher::b64ToByte(QByteArray text)\n{\n    QString base64 = \"./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    QByteArray decoded;\n    int k = -1;\n    while (k < (text.length() - 1)) {\n        int right = 0;\n        int left = 0;\n        int v = 0;\n        int w = 0;\n        int z = 0;\n\n        for (int i = 0; i < 6; i++) {\n            k++;\n            v = base64.indexOf(text.at(k));\n            right |= v << (i * 6);\n        }\n\n        for (int i = 0; i < 6; i++) {\n            k++;\n            v = base64.indexOf(text.at(k));\n            left |= v << (i * 6);\n        }\n\n        for (int i = 0; i < 4; i++) {\n            w = ((left & (0xFF << ((3 - i) * 8))));\n            z = w >> ((3 - i) * 8);\n            if (z < 0) { z = z + 256; }\n            decoded.append(z);\n        }\n\n        for (int i = 0; i < 4; i++) {\n            w = ((right & (0xFF << ((3 - i) * 8))));\n            z = w >> ((3 - i) * 8);\n            if (z < 0) { z = z + 256; }\n            decoded.append(z);\n        }\n    }\n    return decoded;\n}\n\n\nbool Cipher::neededFeaturesAvailable()\n{\n    QCA::Initializer init;\n\n    if (QCA::isSupported(\"blowfish-ecb\") && QCA::isSupported(\"blowfish-cbc\") && QCA::isSupported(\"dh\"))\n        return true;\n\n    return false;\n}\n"], "fixing_code": ["/*\n  This file has been derived from Konversation, the KDE IRC client.\n  You can redistribute it and/or modify it under the terms of the\n  GNU General Public License as published by the Free Software Foundation;\n  either version 2 of the License, or (at your option) any later version.\n*/\n\n/*\n  Copyright (C) 1997 Robey Pointer <robeypointer@gmail.com>\n  Copyright (C) 2005 Ismail Donmez <ismail@kde.org>\n  Copyright (C) 2009 Travis McHenry <tmchenryaz@cox.net>\n  Copyright (C) 2009 Johannes Huber <johu@gmx.de>\n*/\n\n#include \"cipher.h\"\n#include \"logger.h\"\n\nCipher::Cipher()\n{\n    m_primeNum = QCA::BigInteger(\"12745216229761186769575009943944198619149164746831579719941140425076456621824834322853258804883232842877311723249782818608677050956745409379781245497526069657222703636504651898833151008222772087491045206203033063108075098874712912417029101508315117935752962862335062591404043092163187352352197487303798807791605274487594646923\");\n    setType(\"blowfish\");\n}\n\n\nCipher::Cipher(QByteArray key, QString cipherType)\n{\n    m_primeNum = QCA::BigInteger(\"12745216229761186769575009943944198619149164746831579719941140425076456621824834322853258804883232842877311723249782818608677050956745409379781245497526069657222703636504651898833151008222772087491045206203033063108075098874712912417029101508315117935752962862335062591404043092163187352352197487303798807791605274487594646923\");\n    setKey(key);\n    setType(cipherType);\n}\n\n\nCipher::~Cipher()\n{}\n\nbool Cipher::setKey(QByteArray key)\n{\n    if (key.isEmpty()) {\n        m_key.clear();\n        return false;\n    }\n\n    if (key.mid(0, 4).toLower() == \"ecb:\")\n    {\n        m_cbc = false;\n        m_key = key.mid(4);\n    }\n    //strip cbc: if included\n    else if (key.mid(0, 4).toLower() == \"cbc:\")\n    {\n        m_cbc = true;\n        m_key = key.mid(4);\n    }\n    else\n    {\n//    if(Preferences::self()->encryptionType())\n//      m_cbc = true;\n//    else\n        m_cbc = false;\n        m_key = key;\n    }\n    return true;\n}\n\n\nbool Cipher::setType(const QString &type)\n{\n    //TODO check QCA::isSupported()\n    m_type = type;\n    return true;\n}\n\n\nQByteArray Cipher::decrypt(QByteArray cipherText)\n{\n    QByteArray pfx = \"\";\n    bool error = false; // used to flag non cbc, seems like good practice not to parse w/o regard for set encryption type\n\n    //if we get cbc\n    if (cipherText.mid(0, 5) == \"+OK *\")\n    {\n        //if we have cbc\n        if (m_cbc)\n            cipherText = cipherText.mid(5);\n        //if we don't\n        else\n        {\n            cipherText = cipherText.mid(5);\n            pfx = \"ERROR_NONECB: \";\n            error = true;\n        }\n    }\n    //if we get ecb\n    else if (cipherText.mid(0, 4) == \"+OK \" || cipherText.mid(0, 5) == \"mcps \")\n    {\n        //if we had cbc\n        if (m_cbc)\n        {\n            cipherText = (cipherText.mid(0, 4) == \"+OK \") ? cipherText.mid(4) : cipherText.mid(5);\n            pfx = \"ERROR_NONCBC: \";\n            error = true;\n        }\n        //if we don't\n        else\n        {\n            if (cipherText.mid(0, 4) == \"+OK \")\n                cipherText = cipherText.mid(4);\n            else\n                cipherText = cipherText.mid(5);\n        }\n    }\n    //all other cases we fail\n    else\n        return cipherText;\n\n    QByteArray temp;\n    // (if cbc and no error we parse cbc) || (if ecb and error we parse cbc)\n    if ((m_cbc && !error) || (!m_cbc && error))\n    {\n        cipherText = cipherText;\n        temp = blowfishCBC(cipherText, false);\n\n        if (temp == cipherText)\n        {\n            // kDebug(\"Decryption from CBC Failed\");\n            return cipherText+' '+'\\n';\n        }\n        else\n            cipherText = temp;\n    }\n    else\n    {\n        temp = blowfishECB(cipherText, false);\n\n        if (temp == cipherText)\n        {\n            // kDebug(\"Decryption from ECB Failed\");\n            return cipherText+' '+'\\n';\n        }\n        else\n            cipherText = temp;\n    }\n    // TODO FIXME the proper fix for this is to show encryption differently e.g. [nick] instead of <nick>\n    // don't hate me for the mircryption reference there.\n    if (cipherText.at(0) == 1)\n        pfx = \"\\x0\";\n    cipherText = pfx+cipherText+' '+'\\n'; // FIXME(??) why is there an added space here?\n    return cipherText;\n}\n\n\nQByteArray Cipher::initKeyExchange()\n{\n    QCA::Initializer init;\n    m_tempKey = QCA::KeyGenerator().createDH(QCA::DLGroup(m_primeNum, QCA::BigInteger(2))).toDH();\n\n    if (m_tempKey.isNull())\n        return QByteArray();\n\n    QByteArray publicKey = m_tempKey.toPublicKey().toDH().y().toArray().toByteArray();\n\n    //remove leading 0\n    if (publicKey.length() > 135 && publicKey.at(0) == '\\0')\n        publicKey = publicKey.mid(1);\n\n    return publicKey.toBase64().append('A');\n}\n\n\nQByteArray Cipher::parseInitKeyX(QByteArray key)\n{\n    QCA::Initializer init;\n    bool isCBC = false;\n\n    if (key.endsWith(\" CBC\"))\n    {\n        isCBC = true;\n        key.chop(4);\n    }\n\n    if (key.length() != 181)\n        return QByteArray();\n\n    QCA::SecureArray remoteKey = QByteArray::fromBase64(key.left(180));\n    QCA::DLGroup group(m_primeNum, QCA::BigInteger(2));\n    QCA::DHPrivateKey privateKey = QCA::KeyGenerator().createDH(group).toDH();\n\n    if (privateKey.isNull())\n        return QByteArray();\n\n    QByteArray publicKey = privateKey.y().toArray().toByteArray();\n\n    //remove leading 0\n    if (publicKey.length() > 135 && publicKey.at(0) == '\\0')\n        publicKey = publicKey.mid(1);\n\n    QCA::DHPublicKey remotePub(group, remoteKey);\n\n    if (remotePub.isNull())\n        return QByteArray();\n\n    QByteArray sharedKey = privateKey.deriveKey(remotePub).toByteArray();\n    sharedKey = QCA::Hash(\"sha256\").hash(sharedKey).toByteArray().toBase64();\n\n    //remove trailing = because mircryption and fish think it's a swell idea.\n    while (sharedKey.endsWith('=')) sharedKey.chop(1);\n\n    if (isCBC)\n        sharedKey.prepend(\"cbc:\");\n\n    bool success = setKey(sharedKey);\n\n    if (!success)\n        return QByteArray();\n\n    return publicKey.toBase64().append('A');\n}\n\n\nbool Cipher::parseFinishKeyX(QByteArray key)\n{\n    QCA::Initializer init;\n\n    if (key.length() != 181)\n        return false;\n\n    QCA::SecureArray remoteKey = QByteArray::fromBase64(key.left(180));\n    QCA::DLGroup group(m_primeNum, QCA::BigInteger(2));\n\n    QCA::DHPublicKey remotePub(group, remoteKey);\n\n    if (remotePub.isNull())\n        return false;\n\n    if (m_tempKey.isNull())\n        return false;\n\n    QByteArray sharedKey = m_tempKey.deriveKey(remotePub).toByteArray();\n    sharedKey = QCA::Hash(\"sha256\").hash(sharedKey).toByteArray().toBase64();\n\n    //remove trailng = because mircryption and fish think it's a swell idea.\n    while (sharedKey.endsWith('=')) sharedKey.chop(1);\n\n    bool success = setKey(sharedKey);\n\n    return success;\n}\n\n\nQByteArray Cipher::decryptTopic(QByteArray cipherText)\n{\n    if (cipherText.mid(0, 4) == \"+OK \") // FiSH style topic\n        cipherText = cipherText.mid(4);\n    else if (cipherText.left(5) == \"\u00abm\u00ab\")\n        cipherText = cipherText.mid(5, cipherText.length()-10);\n    else\n        return cipherText;\n\n    QByteArray temp;\n    //TODO currently no backwards sanity checks for topic, it seems to use different standards\n    //if somebody figures them out they can enable it and add \"ERROR_NONECB/CBC\" warnings\n    if (m_cbc)\n        temp = blowfishCBC(cipherText.mid(1), false);\n    else\n        temp = blowfishECB(cipherText, false);\n\n    if (temp == cipherText)\n    {\n        return cipherText;\n    }\n    else\n        cipherText = temp;\n\n    if (cipherText.mid(0, 2) == \"@@\")\n        cipherText = cipherText.mid(2);\n\n    return cipherText;\n}\n\n\nbool Cipher::encrypt(QByteArray &cipherText)\n{\n    if (cipherText.left(3) == \"+p \") //don't encode if...?\n        cipherText = cipherText.mid(3);\n    else\n    {\n        if (m_cbc) //encode in ecb or cbc decide how to determine later\n        {\n            QByteArray temp = blowfishCBC(cipherText, true);\n\n            if (temp == cipherText)\n            {\n                // kDebug(\"CBC Encoding Failed\");\n                return false;\n            }\n\n            cipherText = \"+OK *\" + temp;\n        }\n        else\n        {\n            QByteArray temp = blowfishECB(cipherText, true);\n\n            if (temp == cipherText)\n            {\n                // kDebug(\"ECB Encoding Failed\");\n                return false;\n            }\n\n            cipherText = \"+OK \" + temp;\n        }\n    }\n    return true;\n}\n\n\n//THE BELOW WORKS AKA DO NOT TOUCH UNLESS YOU KNOW WHAT YOU'RE DOING\nQByteArray Cipher::blowfishCBC(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        // make sure cipherText is an interval of 8 bits. We do this before so that we\n        // know there's at least 8 bytes to en/decryption this ensures QCA doesn't fail\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n\n        QCA::InitializationVector iv(8);\n        temp.prepend(iv.toByteArray()); // prefix with 8bits of IV for mircryptions *CUSTOM* cbc implementation\n    }\n    else\n    {\n        temp = QByteArray::fromBase64(temp);\n        //supposedly nescessary if we get a truncated message also allows for decryption of 'crazy'\n        //en/decoding clients that use STANDARDIZED PADDING TECHNIQUES\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::CBC, QCA::Cipher::NoPadding, dir, m_key, QCA::InitializationVector(QByteArray(\"0\")));\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction) //send in base64\n        temp2 = temp2.toBase64();\n    else //cut off the 8bits of IV\n        temp2 = temp2.remove(0, 8);\n\n    return temp2;\n}\n\n\nQByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n\n    //do padding ourselves\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        // ECB Blowfish encodes in blocks of 12 chars, so anything else is malformed input\n        if ((temp.length() % 12) != 0)\n            return cipherText;\n\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n\n    if (!cipher.ok())\n        return cipherText;\n\n    if (direction) {\n        // Sanity check\n        if ((temp2.length() % 8) != 0)\n            return cipherText;\n\n        temp2 = byteToB64(temp2);\n    }\n\n    return temp2;\n}\n\n\n//Custom non RFC 2045 compliant Base64 enc/dec code for mircryption / FiSH compatibility\nQByteArray Cipher::byteToB64(QByteArray text)\n{\n    int left = 0;\n    int right = 0;\n    int k = -1;\n    int v;\n    QString base64 = \"./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    QByteArray encoded;\n    while (k < (text.length() - 1)) {\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left = v << 24;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v << 16;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v << 8;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        left += v;\n\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right = v << 24;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v << 16;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v << 8;\n        k++;\n        v = text.at(k); if (v < 0) v += 256;\n        right += v;\n\n        for (int i = 0; i < 6; i++) {\n            encoded.append(base64.at(right & 0x3F).toAscii());\n            right = right >> 6;\n        }\n\n        //TODO make sure the .toascii doesn't break anything\n        for (int i = 0; i < 6; i++) {\n            encoded.append(base64.at(left & 0x3F).toAscii());\n            left = left >> 6;\n        }\n    }\n    return encoded;\n}\n\n\nQByteArray Cipher::b64ToByte(QByteArray text)\n{\n    QString base64 = \"./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    QByteArray decoded;\n    int k = -1;\n    while (k < (text.length() - 1)) {\n        int right = 0;\n        int left = 0;\n        int v = 0;\n        int w = 0;\n        int z = 0;\n\n        for (int i = 0; i < 6; i++) {\n            k++;\n            v = base64.indexOf(text.at(k));\n            right |= v << (i * 6);\n        }\n\n        for (int i = 0; i < 6; i++) {\n            k++;\n            v = base64.indexOf(text.at(k));\n            left |= v << (i * 6);\n        }\n\n        for (int i = 0; i < 4; i++) {\n            w = ((left & (0xFF << ((3 - i) * 8))));\n            z = w >> ((3 - i) * 8);\n            if (z < 0) { z = z + 256; }\n            decoded.append(z);\n        }\n\n        for (int i = 0; i < 4; i++) {\n            w = ((right & (0xFF << ((3 - i) * 8))));\n            z = w >> ((3 - i) * 8);\n            if (z < 0) { z = z + 256; }\n            decoded.append(z);\n        }\n    }\n    return decoded;\n}\n\n\nbool Cipher::neededFeaturesAvailable()\n{\n    QCA::Initializer init;\n\n    if (QCA::isSupported(\"blowfish-ecb\") && QCA::isSupported(\"blowfish-cbc\") && QCA::isSupported(\"dh\"))\n        return true;\n\n    return false;\n}\n"], "filenames": ["src/core/cipher.cpp"], "buggy_code_start_loc": [366], "buggy_code_end_loc": [380], "fixing_code_start_loc": [367], "fixing_code_end_loc": [390], "type": "CWE-125", "message": "The blowfishECB function in core/cipher.cpp in Quassel IRC 0.10.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a malformed string.", "other": {"cve": {"id": "CVE-2014-8483", "sourceIdentifier": "cve@mitre.org", "published": "2014-11-06T15:55:09.523", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Analyzed", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/125.html\">CWE-125: Out-of-bounds Read</a>", "descriptions": [{"lang": "en", "value": "The blowfishECB function in core/cipher.cpp in Quassel IRC 0.10.0 allows remote attackers to cause a denial of service (out-of-bounds read) via a malformed string."}, {"lang": "es", "value": "La funci\u00f3n blowfishECB en core/cipher.cpp en Quassel IRC 0.10.0 permite a atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de rango) a trav\u00e9s de una cadena malformada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quassel-irc:quassel_irc:0.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "D62A66D6-7508-4333-A414-4102CBB072F8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:12.3:*:*:*:*:*:*:*", "matchCriteriaId": "DFBF430B-0832-44B0-AA0E-BA9E467F7668"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://bugs.quassel-irc.org/issues/1314", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-11/msg00028.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2014-11/msg00046.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-03/msg00068.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/61932", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "http://secunia.com/advisories/62035", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "http://secunia.com/advisories/62261", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3063", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3068", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2401-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/quassel/quassel/commit/8b5ecd226f9208af3074b33d3b7cf5e14f55b138", "source": "cve@mitre.org", "tags": ["Patch", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/quassel/quassel/commit/8b5ecd226f9208af3074b33d3b7cf5e14f55b138"}}