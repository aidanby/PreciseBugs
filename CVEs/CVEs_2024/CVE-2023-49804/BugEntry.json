{"buggy_code": ["import legacy from \"@vitejs/plugin-legacy\";\nimport vue from \"@vitejs/plugin-vue\";\nimport { defineConfig } from \"vite\";\nimport visualizer from \"rollup-plugin-visualizer\";\nimport viteCompression from \"vite-plugin-compression\";\nimport commonjs from \"vite-plugin-commonjs\";\n\nconst postCssScss = require(\"postcss-scss\");\nconst postcssRTLCSS = require(\"postcss-rtlcss\");\n\nconst viteCompressionFilter = /\\.(js|mjs|json|css|html|svg)$/i;\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n    server: {\n        port: 3000,\n    },\n    define: {\n        \"FRONTEND_VERSION\": JSON.stringify(process.env.npm_package_version),\n        \"DEVCONTAINER\": JSON.stringify(process.env.DEVCONTAINER),\n        \"GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN\": JSON.stringify(process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN),\n        \"CODESPACE_NAME\": JSON.stringify(process.env.CODESPACE_NAME),\n    },\n    plugins: [\n        commonjs(),\n        vue(),\n        legacy({\n            targets: [ \"since 2015\" ],\n        }),\n        visualizer({\n            filename: \"tmp/dist-stats.html\"\n        }),\n        viteCompression({\n            algorithm: \"gzip\",\n            filter: viteCompressionFilter,\n        }),\n        viteCompression({\n            algorithm: \"brotliCompress\",\n            filter: viteCompressionFilter,\n        }),\n    ],\n    css: {\n        postcss: {\n            \"parser\": postCssScss,\n            \"map\": false,\n            \"plugins\": [ postcssRTLCSS ]\n        }\n    },\n    build: {\n        commonjsOptions: {\n            include: [ /.js$/ ],\n        },\n        rollupOptions: {\n            output: {\n                manualChunks(id, { getModuleInfo, getModuleIds }) {\n\n                }\n            }\n        },\n    }\n});\n", "/*\n * \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Due to the weird issue in Portainer that the healthcheck script is still pointing to this script for unknown reason.\n * IT CANNOT BE DROPPED, even though it looks like it is not used.\n * See more: https://github.com/louislam/uptime-kuma/issues/2774#issuecomment-1429092359\n *\n * \u26a0\ufe0f Deprecated: Changed to healthcheck.go, it will be deleted in the future.\n * This script should be run after a period of time (180s), because the server may need some time to prepare.\n */\nconst { FBSD } = require(\"../server/util-server\");\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n\nlet client;\n\nconst sslKey = process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\nconst sslCert = process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\n\nif (sslKey && sslCert) {\n    client = require(\"https\");\n} else {\n    client = require(\"http\");\n}\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\nlet hostname = process.env.UPTIME_KUMA_HOST;\n\n// Also read HOST if not *BSD, as HOST is a system environment variable in FreeBSD\nif (!hostname && !FBSD) {\n    hostname = process.env.HOST;\n}\n\nconst port = parseInt(process.env.UPTIME_KUMA_PORT || process.env.PORT || 3001);\n\nlet options = {\n    host: hostname || \"127.0.0.1\",\n    port: port,\n    timeout: 28 * 1000,\n};\n\nlet request = client.request(options, (res) => {\n    console.log(`Health Check OK [Res Code: ${res.statusCode}]`);\n    if (res.statusCode === 302) {\n        process.exit(0);\n    } else {\n        process.exit(1);\n    }\n});\n\nrequest.on(\"error\", function (err) {\n    console.error(\"Health Check ERROR\");\n    process.exit(1);\n});\n\nrequest.end();\n", "console.log(\"== Uptime Kuma Reset Password Tool ==\");\n\nconst Database = require(\"../server/database\");\nconst { R } = require(\"redbean-node\");\nconst readline = require(\"readline\");\nconst { initJWTSecret } = require(\"../server/util-server\");\nconst User = require(\"../server/model/user\");\nconst args = require(\"args-parser\")(process.argv);\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst main = async () => {\n    console.log(\"Connecting the database\");\n    Database.init(args);\n    await Database.connect(false, false, true);\n\n    try {\n        // No need to actually reset the password for testing, just make sure no connection problem. It is ok for now.\n        if (!process.env.TEST_BACKEND) {\n            const user = await R.findOne(\"user\");\n            if (! user) {\n                throw new Error(\"user not found, have you installed?\");\n            }\n\n            console.log(\"Found user: \" + user.username);\n\n            while (true) {\n                let password = await question(\"New Password: \");\n                let confirmPassword = await question(\"Confirm New Password: \");\n\n                if (password === confirmPassword) {\n                    await User.resetPassword(user.id, password);\n\n                    // Reset all sessions by reset jwt secret\n                    await initJWTSecret();\n\n                    break;\n                } else {\n                    console.log(\"Passwords do not match, please try again.\");\n                }\n            }\n            console.log(\"Password reset successfully.\");\n        }\n    } catch (e) {\n        console.error(\"Error: \" + e.message);\n    }\n\n    await Database.close();\n    rl.close();\n\n    console.log(\"Finished.\");\n};\n\n/**\n * Ask question of user\n * @param {string} question Question to ask\n * @returns {Promise<string>} Users response\n */\nfunction question(question) {\n    return new Promise((resolve) => {\n        rl.question(question, (answer) => {\n            resolve(answer);\n        });\n    });\n}\n\nif (!process.env.TEST_BACKEND) {\n    main();\n}\n\nmodule.exports = {\n    main,\n};\n", "{\n    \"name\": \"uptime-kuma\",\n    \"version\": \"1.23.8\",\n    \"license\": \"MIT\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/louislam/uptime-kuma.git\"\n    },\n    \"engines\": {\n        \"node\": \"14 || 16 || 18 || >= 20.4.0\"\n    },\n    \"scripts\": {\n        \"install-legacy\": \"npm install\",\n        \"update-legacy\": \"npm update\",\n        \"lint:js\": \"eslint --ext \\\".js,.vue\\\" --ignore-path .gitignore .\",\n        \"lint:js-prod\": \"npm run lint:js -- --max-warnings 0\",\n        \"lint-fix:js\": \"eslint --ext \\\".js,.vue\\\" --fix --ignore-path .gitignore .\",\n        \"lint:style\": \"stylelint \\\"**/*.{vue,css,scss}\\\" --ignore-path .gitignore\",\n        \"lint-fix:style\": \"stylelint \\\"**/*.{vue,css,scss}\\\" --fix --ignore-path .gitignore\",\n        \"lint\": \"npm run lint:js && npm run lint:style\",\n        \"lint:prod\": \"npm run lint:js-prod && npm run lint:style\",\n        \"dev\": \"concurrently -k -r \\\"wait-on tcp:3000 && npm run start-server-dev \\\" \\\"npm run start-frontend-dev\\\"\",\n        \"start-frontend-dev\": \"cross-env NODE_ENV=development vite --host --config ./config/vite.config.js\",\n        \"start-frontend-devcontainer\": \"cross-env NODE_ENV=development DEVCONTAINER=1 vite --host --config ./config/vite.config.js\",\n        \"start\": \"npm run start-server\",\n        \"start-server\": \"node server/server.js\",\n        \"start-server-dev\": \"cross-env NODE_ENV=development node server/server.js\",\n        \"build\": \"vite build --config ./config/vite.config.js\",\n        \"test\": \"node test/prepare-test-server.js && npm run jest-backend\",\n        \"test-with-build\": \"npm run build && npm test\",\n        \"jest-backend\": \"cross-env TEST_BACKEND=1 jest --runInBand --detectOpenHandles --forceExit --config=./config/jest-backend.config.js\",\n        \"tsc\": \"tsc\",\n        \"vite-preview-dist\": \"vite preview --host --config ./config/vite.config.js\",\n        \"build-docker\": \"npm run build && npm run build-docker-debian && npm run build-docker-alpine\",\n        \"build-docker-alpine-base\": \"docker buildx build -f docker/alpine-base.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:base-alpine . --push\",\n        \"build-docker-debian-base\": \"docker buildx build -f docker/debian-base.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:base-debian . --push\",\n        \"build-docker-builder-go\": \"docker buildx build -f docker/builder-go.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:builder-go . --push\",\n        \"build-docker-alpine\": \"node ./extra/env2arg.js docker buildx build -f docker/dockerfile-alpine --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:alpine -t louislam/uptime-kuma:1-alpine -t louislam/uptime-kuma:$VERSION-alpine --target release . --push\",\n        \"build-docker-debian\": \"node ./extra/env2arg.js docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma -t louislam/uptime-kuma:1 -t louislam/uptime-kuma:$VERSION -t louislam/uptime-kuma:debian -t louislam/uptime-kuma:1-debian -t louislam/uptime-kuma:$VERSION-debian --target release . --push\",\n        \"build-docker-nightly\": \"node ./extra/test-docker.js && npm run build && docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:nightly --target nightly . --push\",\n        \"build-docker-nightly-alpine\": \"docker buildx build -f docker/dockerfile-alpine --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:nightly-alpine --target nightly . --push\",\n        \"build-docker-nightly-amd64\": \"docker buildx build -f docker/dockerfile --platform linux/amd64 -t louislam/uptime-kuma:nightly-amd64 --target nightly . --push --progress plain\",\n        \"build-docker-pr-test\": \"docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64 -t louislam/uptime-kuma:pr-test --target pr-test . --push\",\n        \"upload-artifacts\": \"docker buildx build -f docker/dockerfile --platform linux/amd64 -t louislam/uptime-kuma:upload-artifact --build-arg VERSION --build-arg GITHUB_TOKEN --target upload-artifact . --progress plain\",\n        \"setup\": \"git checkout 1.23.8 && npm ci --production && npm run download-dist\",\n        \"download-dist\": \"node extra/download-dist.js\",\n        \"mark-as-nightly\": \"node extra/mark-as-nightly.js\",\n        \"reset-password\": \"node extra/reset-password.js\",\n        \"remove-2fa\": \"node extra/remove-2fa.js\",\n        \"compile-install-script\": \"@powershell -NoProfile -ExecutionPolicy Unrestricted -Command ./extra/compile-install-script.ps1\",\n        \"test-install-script-rockylinux\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/rockylinux.dockerfile .\",\n        \"test-install-script-centos7\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/centos7.dockerfile .\",\n        \"test-install-script-alpine3\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/alpine3.dockerfile .\",\n        \"test-install-script-debian\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/debian.dockerfile .\",\n        \"test-install-script-debian-buster\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/debian-buster.dockerfile .\",\n        \"test-install-script-ubuntu\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu.dockerfile .\",\n        \"test-install-script-ubuntu1804\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu1804.dockerfile .\",\n        \"test-install-script-ubuntu1604\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu1604.dockerfile .\",\n        \"simple-dns-server\": \"node extra/simple-dns-server.js\",\n        \"simple-mqtt-server\": \"node extra/simple-mqtt-server.js\",\n        \"simple-mongo\": \"docker run --rm -p 27017:27017 mongo\",\n        \"simple-postgres\": \"docker run --rm -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\",\n        \"simple-mariadb\": \"docker run --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=mariadb# mariadb\",\n        \"update-language-files\": \"cd extra/update-language-files && node index.js && cross-env-shell eslint ../../src/languages/$npm_config_language.js --fix\",\n        \"ncu-patch\": \"npm-check-updates -u -t patch\",\n        \"release-final\": \"node ./extra/test-docker.js && node extra/update-version.js && npm run build-docker && node ./extra/press-any-key.js && npm run upload-artifacts && node ./extra/update-wiki-version.js\",\n        \"release-beta\": \"node ./extra/test-docker.js && node extra/beta/update-version.js && npm run build && node ./extra/env2arg.js docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:$VERSION -t louislam/uptime-kuma:beta .  --target release --push && node ./extra/press-any-key.js && npm run upload-artifacts\",\n        \"git-remove-tag\": \"git tag -d\",\n        \"build-dist-and-restart\": \"npm run build && npm run start-server-dev\",\n        \"start-pr-test\": \"node extra/checkout-pr.js && npm install && npm run dev\",\n        \"cy:test\": \"node test/prepare-test-server.js && node server/server.js --port=3002 --data-dir=./data/test/ --e2e\",\n        \"cy:run\": \"npx cypress run --browser chrome --headless --config-file ./config/cypress.config.js\",\n        \"cy:run:unit\": \"npx cypress run --browser chrome --headless --config-file ./config/cypress.frontend.config.js\",\n        \"cypress-open\": \"concurrently -k -r \\\"node test/prepare-test-server.js && node server/server.js --port=3002 --data-dir=./data/test/\\\" \\\"cypress open --config-file ./config/cypress.config.js\\\"\",\n        \"build-healthcheck-armv7\": \"cross-env GOOS=linux GOARCH=arm GOARM=7 go build -x -o ./extra/healthcheck-armv7 ./extra/healthcheck.go\",\n        \"deploy-demo-server\": \"node extra/deploy-demo-server.js\",\n        \"sort-contributors\": \"node extra/sort-contributors.js\",\n        \"start-server-node14-win\": \"private\\\\node14\\\\node.exe server/server.js\"\n    },\n    \"dependencies\": {\n        \"@grpc/grpc-js\": \"~1.7.3\",\n        \"@louislam/ping\": \"~0.4.4-mod.1\",\n        \"@louislam/sqlite3\": \"15.1.6\",\n        \"args-parser\": \"~1.3.0\",\n        \"axios\": \"~0.27.0\",\n        \"axios-ntlm\": \"1.3.0\",\n        \"badge-maker\": \"~3.3.1\",\n        \"bcryptjs\": \"~2.4.3\",\n        \"cacheable-lookup\": \"~6.0.4\",\n        \"chardet\": \"~1.4.0\",\n        \"check-password-strength\": \"^2.0.5\",\n        \"cheerio\": \"~1.0.0-rc.12\",\n        \"chroma-js\": \"~2.4.2\",\n        \"command-exists\": \"~1.2.9\",\n        \"compare-versions\": \"~3.6.0\",\n        \"compression\": \"~1.7.4\",\n        \"croner\": \"~6.0.5\",\n        \"dayjs\": \"~1.11.5\",\n        \"dotenv\": \"~16.0.3\",\n        \"express\": \"~4.17.3\",\n        \"express-basic-auth\": \"~1.2.1\",\n        \"express-static-gzip\": \"~2.1.7\",\n        \"form-data\": \"~4.0.0\",\n        \"gamedig\": \"^4.2.0\",\n        \"html-escaper\": \"^3.0.3\",\n        \"http-graceful-shutdown\": \"~3.1.7\",\n        \"http-proxy-agent\": \"~5.0.0\",\n        \"https-proxy-agent\": \"~5.0.1\",\n        \"iconv-lite\": \"~0.6.3\",\n        \"isomorphic-ws\": \"^5.0.0\",\n        \"jsesc\": \"~3.0.2\",\n        \"jsonata\": \"^2.0.3\",\n        \"jsonwebtoken\": \"~9.0.0\",\n        \"jwt-decode\": \"~3.1.2\",\n        \"kafkajs\": \"^2.2.4\",\n        \"limiter\": \"~2.1.0\",\n        \"liquidjs\": \"^10.7.0\",\n        \"mongodb\": \"~4.17.1\",\n        \"mqtt\": \"~4.3.7\",\n        \"mssql\": \"~8.1.4\",\n        \"mysql2\": \"~3.6.2\",\n        \"nanoid\": \"~3.3.4\",\n        \"node-cloudflared-tunnel\": \"~1.0.9\",\n        \"node-radius-client\": \"~1.0.0\",\n        \"nodemailer\": \"~6.6.5\",\n        \"nostr-tools\": \"^1.13.1\",\n        \"notp\": \"~2.0.3\",\n        \"openid-client\": \"^5.4.2\",\n        \"password-hash\": \"~1.2.2\",\n        \"pg\": \"~8.11.3\",\n        \"pg-connection-string\": \"~2.6.2\",\n        \"playwright-core\": \"~1.35.1\",\n        \"prom-client\": \"~13.2.0\",\n        \"prometheus-api-metrics\": \"~3.2.1\",\n        \"promisify-child-process\": \"~4.1.2\",\n        \"protobufjs\": \"~7.2.4\",\n        \"qs\": \"~6.10.4\",\n        \"redbean-node\": \"~0.3.0\",\n        \"redis\": \"~4.5.1\",\n        \"semver\": \"~7.5.4\",\n        \"socket.io\": \"~4.6.1\",\n        \"socket.io-client\": \"~4.6.1\",\n        \"socks-proxy-agent\": \"6.1.1\",\n        \"tar\": \"~6.1.11\",\n        \"tcp-ping\": \"~0.1.1\",\n        \"thirty-two\": \"~1.0.2\",\n        \"ws\": \"^8.13.0\"\n    },\n    \"devDependencies\": {\n        \"@actions/github\": \"~5.0.1\",\n        \"@babel/eslint-parser\": \"^7.22.7\",\n        \"@babel/preset-env\": \"^7.15.8\",\n        \"@fortawesome/fontawesome-svg-core\": \"~1.2.36\",\n        \"@fortawesome/free-regular-svg-icons\": \"~5.15.4\",\n        \"@fortawesome/free-solid-svg-icons\": \"~5.15.4\",\n        \"@fortawesome/vue-fontawesome\": \"~3.0.0-5\",\n        \"@popperjs/core\": \"~2.10.2\",\n        \"@types/bootstrap\": \"~5.1.9\",\n        \"@vitejs/plugin-legacy\": \"~4.1.0\",\n        \"@vitejs/plugin-vue\": \"~4.2.3\",\n        \"@vue/compiler-sfc\": \"~3.3.4\",\n        \"@vuepic/vue-datepicker\": \"~3.4.8\",\n        \"aedes\": \"^0.46.3\",\n        \"bootstrap\": \"5.1.3\",\n        \"chart.js\": \"~4.2.1\",\n        \"chartjs-adapter-dayjs-4\": \"~1.0.4\",\n        \"concurrently\": \"^7.1.0\",\n        \"core-js\": \"~3.26.1\",\n        \"cronstrue\": \"~2.24.0\",\n        \"cross-env\": \"~7.0.3\",\n        \"cypress\": \"^13.2.0\",\n        \"delay\": \"^5.0.0\",\n        \"dns2\": \"~2.0.1\",\n        \"dompurify\": \"~2.4.3\",\n        \"eslint\": \"~8.14.0\",\n        \"eslint-plugin-vue\": \"~8.7.1\",\n        \"favico.js\": \"~0.3.10\",\n        \"jest\": \"~29.6.1\",\n        \"marked\": \"~4.2.5\",\n        \"node-ssh\": \"~13.1.0\",\n        \"postcss-html\": \"~1.5.0\",\n        \"postcss-rtlcss\": \"~3.7.2\",\n        \"postcss-scss\": \"~4.0.4\",\n        \"prismjs\": \"~1.29.0\",\n        \"qrcode\": \"~1.5.0\",\n        \"rollup-plugin-visualizer\": \"^5.6.0\",\n        \"sass\": \"~1.42.1\",\n        \"stylelint\": \"^15.10.1\",\n        \"stylelint-config-standard\": \"~25.0.0\",\n        \"terser\": \"~5.15.0\",\n        \"timezones-list\": \"~3.0.1\",\n        \"typescript\": \"~4.4.4\",\n        \"v-pagination-3\": \"~0.1.7\",\n        \"vite\": \"~4.4.1\",\n        \"vite-plugin-commonjs\": \"^0.8.0\",\n        \"vite-plugin-compression\": \"^0.5.1\",\n        \"vue\": \"~3.3.4\",\n        \"vue-chartjs\": \"~5.2.0\",\n        \"vue-confirm-dialog\": \"~1.0.2\",\n        \"vue-contenteditable\": \"~3.0.4\",\n        \"vue-i18n\": \"~9.2.2\",\n        \"vue-image-crop-upload\": \"~3.0.3\",\n        \"vue-multiselect\": \"~3.0.0-alpha.2\",\n        \"vue-prism-editor\": \"~2.0.0-alpha.2\",\n        \"vue-qrcode\": \"~1.0.0\",\n        \"vue-router\": \"~4.0.14\",\n        \"vue-toastification\": \"~2.0.0-rc.5\",\n        \"vuedraggable\": \"~4.1.0\",\n        \"wait-on\": \"^7.2.0\",\n        \"whatwg-url\": \"~12.0.1\"\n    }\n}\n", "// Interop with browser\nconst args = (typeof process !== \"undefined\") ? require(\"args-parser\")(process.argv) : {};\nconst demoMode = args[\"demo\"] || false;\n\nconst badgeConstants = {\n    naColor: \"#999\",\n    defaultUpColor: \"#66c20a\",\n    defaultWarnColor: \"#eed202\",\n    defaultDownColor: \"#c2290a\",\n    defaultPendingColor: \"#f8a306\",\n    defaultMaintenanceColor: \"#1747f5\",\n    defaultPingColor: \"blue\",  // as defined by badge-maker / shields.io\n    defaultStyle: \"flat\",\n    defaultPingValueSuffix: \"ms\",\n    defaultPingLabelSuffix: \"h\",\n    defaultUptimeValueSuffix: \"%\",\n    defaultUptimeLabelSuffix: \"h\",\n    defaultCertExpValueSuffix: \" days\",\n    defaultCertExpLabelSuffix: \"h\",\n    // Values Come From Default Notification Times\n    defaultCertExpireWarnDays: \"14\",\n    defaultCertExpireDownDays: \"7\"\n};\n\nmodule.exports = {\n    args,\n    demoMode,\n    badgeConstants,\n};\n", "let express = require(\"express\");\nconst {\n    setting,\n    allowDevAllOrigin,\n    allowAllOrigin,\n    percentageToColor,\n    filterAndJoin,\n    sendHttpError,\n} = require(\"../util-server\");\nconst { R } = require(\"redbean-node\");\nconst apicache = require(\"../modules/apicache\");\nconst Monitor = require(\"../model/monitor\");\nconst dayjs = require(\"dayjs\");\nconst { UP, MAINTENANCE, DOWN, PENDING, flipStatus, log } = require(\"../../src/util\");\nconst StatusPage = require(\"../model/status_page\");\nconst { UptimeKumaServer } = require(\"../uptime-kuma-server\");\nconst { UptimeCacheList } = require(\"../uptime-cache-list\");\nconst { makeBadge } = require(\"badge-maker\");\nconst { badgeConstants } = require(\"../config\");\nconst { Prometheus } = require(\"../prometheus\");\n\nlet router = express.Router();\n\nlet cache = apicache.middleware;\nconst server = UptimeKumaServer.getInstance();\nlet io = server.io;\n\nrouter.get(\"/api/entry-page\", async (request, response) => {\n    allowDevAllOrigin(response);\n\n    let result = { };\n    let hostname = request.hostname;\n    if ((await setting(\"trustProxy\")) && request.headers[\"x-forwarded-host\"]) {\n        hostname = request.headers[\"x-forwarded-host\"];\n    }\n\n    if (hostname in StatusPage.domainMappingList) {\n        result.type = \"statusPageMatchedDomain\";\n        result.statusPageSlug = StatusPage.domainMappingList[hostname];\n    } else {\n        result.type = \"entryPage\";\n        result.entryPage = server.entryPage;\n    }\n    response.json(result);\n});\n\nrouter.get(\"/api/push/:pushToken\", async (request, response) => {\n    try {\n\n        let pushToken = request.params.pushToken;\n        let msg = request.query.msg || \"OK\";\n        let ping = parseFloat(request.query.ping) || null;\n        let statusString = request.query.status || \"up\";\n        let status = (statusString === \"up\") ? UP : DOWN;\n\n        let monitor = await R.findOne(\"monitor\", \" push_token = ? AND active = 1 \", [\n            pushToken\n        ]);\n\n        if (! monitor) {\n            throw new Error(\"Monitor not found or not active.\");\n        }\n\n        const previousHeartbeat = await Monitor.getPreviousHeartbeat(monitor.id);\n\n        if (monitor.isUpsideDown()) {\n            status = flipStatus(status);\n        }\n\n        let isFirstBeat = true;\n        let previousStatus = status;\n        let duration = 0;\n\n        let bean = R.dispense(\"heartbeat\");\n        bean.time = R.isoDateTimeMillis(dayjs.utc());\n\n        if (previousHeartbeat) {\n            isFirstBeat = false;\n            previousStatus = previousHeartbeat.status;\n            duration = dayjs(bean.time).diff(dayjs(previousHeartbeat.time), \"second\");\n        }\n\n        if (await Monitor.isUnderMaintenance(monitor.id)) {\n            msg = \"Monitor under maintenance\";\n            status = MAINTENANCE;\n        }\n\n        log.debug(\"router\", `/api/push/ called at ${dayjs().format(\"YYYY-MM-DD HH:mm:ss.SSS\")}`);\n        log.debug(\"router\", \"PreviousStatus: \" + previousStatus);\n        log.debug(\"router\", \"Current Status: \" + status);\n\n        bean.important = Monitor.isImportantBeat(isFirstBeat, previousStatus, status);\n        bean.monitor_id = monitor.id;\n        bean.status = status;\n        bean.msg = msg;\n        bean.ping = ping;\n        bean.duration = duration;\n\n        await R.store(bean);\n\n        io.to(monitor.user_id).emit(\"heartbeat\", bean.toJSON());\n        UptimeCacheList.clearCache(monitor.id);\n        Monitor.sendStats(io, monitor.id, monitor.user_id);\n        new Prometheus(monitor).update(bean, undefined);\n\n        response.json({\n            ok: true,\n        });\n\n        if (Monitor.isImportantForNotification(isFirstBeat, previousStatus, status)) {\n            await Monitor.sendNotification(isFirstBeat, monitor, bean);\n        }\n\n    } catch (e) {\n        response.status(404).json({\n            ok: false,\n            msg: e.message\n        });\n    }\n});\n\nrouter.get(\"/api/badge/:id/status\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        upLabel = \"Up\",\n        downLabel = \"Down\",\n        pendingLabel = \"Pending\",\n        maintenanceLabel = \"Maintenance\",\n        upColor = badgeConstants.defaultUpColor,\n        downColor = badgeConstants.defaultDownColor,\n        pendingColor = badgeConstants.defaultPendingColor,\n        maintenanceColor = badgeConstants.defaultMaintenanceColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n        const overrideValue = value !== undefined ? parseInt(value) : undefined;\n\n        let publicMonitor = await R.getRow(`\n                SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND monitor_group.monitor_id = ?\n                AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const heartbeat = await Monitor.getPreviousHeartbeat(requestedMonitorId);\n            const state = overrideValue !== undefined ? overrideValue : heartbeat.status;\n\n            if (label === undefined) {\n                badgeValues.label = \"Status\";\n            } else {\n                badgeValues.label = label;\n            }\n            switch (state) {\n                case DOWN:\n                    badgeValues.color = downColor;\n                    badgeValues.message = downLabel;\n                    break;\n                case UP:\n                    badgeValues.color = upColor;\n                    badgeValues.message = upLabel;\n                    break;\n                case PENDING:\n                    badgeValues.color = pendingColor;\n                    badgeValues.message = pendingLabel;\n                    break;\n                case MAINTENANCE:\n                    badgeValues.color = maintenanceColor;\n                    badgeValues.message = maintenanceLabel;\n                    break;\n                default:\n                    badgeValues.color = badgeConstants.naColor;\n                    badgeValues.message = \"N/A\";\n            }\n        }\n\n        // build the svg based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/uptime/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix = badgeConstants.defaultUptimeLabelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultUptimeValueSuffix,\n        color,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n        // if no duration is given, set value to 24 (h)\n        const requestedDuration = request.params.duration !== undefined ? parseInt(request.params.duration, 10) : 24;\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n                SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND monitor_group.monitor_id = ?\n                AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const uptime = overrideValue ?? await Monitor.calcUptime(\n                requestedDuration,\n                requestedMonitorId\n            );\n\n            // limit the displayed uptime percentage to four (two, when displayed as percent) decimal digits\n            const cleanUptime = (uptime * 100).toPrecision(4);\n\n            // use a given, custom color or calculate one based on the uptime value\n            badgeValues.color = color ?? percentageToColor(uptime);\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a label string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([\n                labelPrefix,\n                label ?? `Uptime (${requestedDuration}${labelSuffix})`,\n            ]);\n            badgeValues.message = filterAndJoin([ prefix, cleanUptime, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/ping/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix = badgeConstants.defaultPingLabelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        // Default duration is 24 (h) if not defined in queryParam, limited to 720h (30d)\n        const requestedDuration = Math.min(request.params.duration ? parseInt(request.params.duration, 10) : 24, 720);\n        const overrideValue = value && parseFloat(value);\n\n        const publicAvgPing = parseInt(await R.getCell(`\n                SELECT AVG(ping) FROM monitor_group, \\`group\\`, heartbeat\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND heartbeat.time > DATETIME('now', ? || ' hours')\n                AND heartbeat.ping IS NOT NULL\n                AND public = 1\n                AND heartbeat.monitor_id = ?\n            `,\n        [ -requestedDuration, requestedMonitorId ]\n        ));\n\n        const badgeValues = { style };\n\n        if (!publicAvgPing) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const avgPing = parseInt(overrideValue ?? publicAvgPing);\n\n            badgeValues.color = color;\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a lable string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([ labelPrefix, label ?? `Avg. Ping (${requestedDuration}${labelSuffix})` ]);\n            badgeValues.message = filterAndJoin([ prefix, avgPing, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/avg-response/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        // Default duration is 24 (h) if not defined in queryParam, limited to 720h (30d)\n        const requestedDuration = Math.min(\n            request.params.duration\n                ? parseInt(request.params.duration, 10)\n                : 24,\n            720\n        );\n        const overrideValue = value && parseFloat(value);\n\n        const publicAvgPing = parseInt(await R.getCell(`\n            SELECT AVG(ping) FROM monitor_group, \\`group\\`, heartbeat\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND heartbeat.time > DATETIME('now', ? || ' hours')\n            AND heartbeat.ping IS NOT NULL\n            AND public = 1\n            AND heartbeat.monitor_id = ?\n            `,\n        [ -requestedDuration, requestedMonitorId ]\n        ));\n\n        const badgeValues = { style };\n\n        if (!publicAvgPing) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const avgPing = parseInt(overrideValue ?? publicAvgPing);\n\n            badgeValues.color = color;\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a label string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([\n                labelPrefix,\n                label ?? `Avg. Response (${requestedDuration}h)`,\n                labelSuffix,\n            ]);\n            badgeValues.message = filterAndJoin([ prefix, avgPing, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/cert-exp\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const date = request.query.date;\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = date ? \"\" : badgeConstants.defaultCertExpValueSuffix,\n        upColor = badgeConstants.defaultUpColor,\n        warnColor = badgeConstants.defaultWarnColor,\n        downColor = badgeConstants.defaultDownColor,\n        warnDays = badgeConstants.defaultCertExpireWarnDays,\n        downDays = badgeConstants.defaultCertExpireDownDays,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND monitor_group.monitor_id = ?\n            AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const tlsInfoBean = await R.findOne(\"monitor_tls_info\", \"monitor_id = ?\", [\n                requestedMonitorId,\n            ]);\n\n            if (!tlsInfoBean) {\n                // return a \"No/Bad Cert\" badge in naColor (grey), if no cert saved (does not save bad certs?)\n                badgeValues.message = \"No/Bad Cert\";\n                badgeValues.color = badgeConstants.naColor;\n            } else {\n                const tlsInfo = JSON.parse(tlsInfoBean.info_json);\n\n                if (!tlsInfo.valid) {\n                    // return a \"Bad Cert\" badge in naColor (grey), when cert is not valid\n                    badgeValues.message = \"Bad Cert\";\n                    badgeValues.color = downColor;\n                } else {\n                    const daysRemaining = parseInt(overrideValue ?? tlsInfo.certInfo.daysRemaining);\n\n                    if (daysRemaining > warnDays) {\n                        badgeValues.color = upColor;\n                    } else if (daysRemaining > downDays) {\n                        badgeValues.color = warnColor;\n                    } else {\n                        badgeValues.color = downColor;\n                    }\n                    // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n                    badgeValues.labelColor = labelColor ?? \"\";\n                    // build a label string. If a custom label is given, override the default one\n                    badgeValues.label = filterAndJoin([\n                        labelPrefix,\n                        label ?? \"Cert Exp.\",\n                        labelSuffix,\n                    ]);\n                    badgeValues.message = filterAndJoin([ prefix, date ? tlsInfo.certInfo.validTo : daysRemaining, suffix ]);\n                }\n            }\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/response\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND monitor_group.monitor_id = ?\n            AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const heartbeat = await Monitor.getPreviousHeartbeat(\n                requestedMonitorId\n            );\n\n            if (!heartbeat.ping) {\n                // return a \"N/A\" badge in naColor (grey), if previous heartbeat has no ping\n\n                badgeValues.message = \"N/A\";\n                badgeValues.color = badgeConstants.naColor;\n            } else {\n                const ping = parseInt(overrideValue ?? heartbeat.ping);\n\n                badgeValues.color = color;\n                // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n                badgeValues.labelColor = labelColor ?? \"\";\n                // build a label string. If a custom label is given, override the default one\n                badgeValues.label = filterAndJoin([\n                    labelPrefix,\n                    label ?? \"Response\",\n                    labelSuffix,\n                ]);\n                badgeValues.message = filterAndJoin([ prefix, ping, suffix ]);\n            }\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nmodule.exports = router;\n", "let express = require(\"express\");\nconst apicache = require(\"../modules/apicache\");\nconst { UptimeKumaServer } = require(\"../uptime-kuma-server\");\nconst StatusPage = require(\"../model/status_page\");\nconst { allowDevAllOrigin, sendHttpError } = require(\"../util-server\");\nconst { R } = require(\"redbean-node\");\nconst Monitor = require(\"../model/monitor\");\nconst { badgeConstants } = require(\"../config\");\nconst { makeBadge } = require(\"badge-maker\");\n\nlet router = express.Router();\n\nlet cache = apicache.middleware;\nconst server = UptimeKumaServer.getInstance();\n\nrouter.get(\"/status/:slug\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = request.params.slug;\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\nrouter.get(\"/status\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = \"default\";\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\nrouter.get(\"/status-page\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = \"default\";\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\n// Status page config, incident, monitor list\nrouter.get(\"/api/status-page/:slug\", cache(\"5 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    let slug = request.params.slug;\n\n    try {\n        // Get Status Page\n        let statusPage = await R.findOne(\"status_page\", \" slug = ? \", [\n            slug\n        ]);\n\n        if (!statusPage) {\n            return null;\n        }\n\n        let statusPageData = await StatusPage.getStatusPageData(statusPage);\n\n        if (!statusPageData) {\n            sendHttpError(response, \"Not Found\");\n            return;\n        }\n\n        // Response\n        response.json(statusPageData);\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// Status Page Polling Data\n// Can fetch only if published\nrouter.get(\"/api/status-page/heartbeat/:slug\", cache(\"1 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n\n    try {\n        let heartbeatList = {};\n        let uptimeList = {};\n\n        let slug = request.params.slug;\n        let statusPageID = await StatusPage.slugToID(slug);\n\n        let monitorIDList = await R.getCol(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND public = 1\n            AND \\`group\\`.status_page_id = ?\n        `, [\n            statusPageID\n        ]);\n\n        for (let monitorID of monitorIDList) {\n            let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ?\n                    ORDER BY time DESC\n                    LIMIT 50\n            `, [\n                monitorID,\n            ]);\n\n            list = R.convertToBeans(\"heartbeat\", list);\n            heartbeatList[monitorID] = list.reverse().map(row => row.toPublicJSON());\n\n            const type = 24;\n            uptimeList[`${monitorID}_${type}`] = await Monitor.calcUptime(type, monitorID);\n        }\n\n        response.json({\n            heartbeatList,\n            uptimeList\n        });\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// Status page's manifest.json\nrouter.get(\"/api/status-page/:slug/manifest.json\", cache(\"1440 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    let slug = request.params.slug;\n\n    try {\n        // Get Status Page\n        let statusPage = await R.findOne(\"status_page\", \" slug = ? \", [\n            slug\n        ]);\n\n        if (!statusPage) {\n            sendHttpError(response, \"Not Found\");\n            return;\n        }\n\n        // Response\n        response.json({\n            \"name\": statusPage.title,\n            \"start_url\": \"/status/\" + statusPage.slug,\n            \"display\": \"standalone\",\n            \"icons\": [\n                {\n                    \"src\": statusPage.icon,\n                    \"sizes\": \"128x128\",\n                    \"type\": \"image/png\"\n                }\n            ]\n        });\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// overall status-page status badge\nrouter.get(\"/api/status-page/:slug/badge\", cache(\"5 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    const slug = request.params.slug;\n    const statusPageID = await StatusPage.slugToID(slug);\n    const {\n        label,\n        upColor = badgeConstants.defaultUpColor,\n        downColor = badgeConstants.defaultDownColor,\n        partialColor = \"#F6BE00\",\n        maintenanceColor = \"#808080\",\n        style = badgeConstants.defaultStyle\n    } = request.query;\n\n    try {\n        let monitorIDList = await R.getCol(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND public = 1\n            AND \\`group\\`.status_page_id = ?\n        `, [\n            statusPageID\n        ]);\n\n        let hasUp = false;\n        let hasDown = false;\n        let hasMaintenance = false;\n\n        for (let monitorID of monitorIDList) {\n            // retrieve the latest heartbeat\n            let beat = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ?\n                    ORDER BY time DESC\n                    LIMIT 1\n            `, [\n                monitorID,\n            ]);\n\n            // to be sure, when corresponding monitor not found\n            if (beat.length === 0) {\n                continue;\n            }\n            // handle status of beat\n            if (beat[0].status === 3) {\n                hasMaintenance = true;\n            } else if (beat[0].status === 2) {\n                // ignored\n            } else if (beat[0].status === 1) {\n                hasUp = true;\n            } else {\n                hasDown = true;\n            }\n\n        }\n\n        const badgeValues = { style };\n\n        if (!hasUp && !hasDown && !hasMaintenance) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n\n        } else {\n            if (hasMaintenance) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = maintenanceColor;\n                badgeValues.message = \"Maintenance\";\n            } else if (hasUp && !hasDown) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = upColor;\n                badgeValues.message = \"Up\";\n            } else if (hasUp && hasDown) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = partialColor;\n                badgeValues.message = \"Degraded\";\n            } else {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = downColor;\n                badgeValues.message = \"Down\";\n            }\n\n        }\n\n        // build the svg based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nmodule.exports = router;\n", "/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nif (!process.env.UPTIME_KUMA_WS_ORIGIN_CHECK) {\n    process.env.UPTIME_KUMA_WS_ORIGIN_CHECK = \"cors-like\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\nlog.info(\"server\", \"WebSocket Origin Check: \" + process.env.UPTIME_KUMA_WS_ORIGIN_CHECK);\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance(args);\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nconst User = require(\"./model/user\");\n\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, FBSD, doubleCheckPassword, startE2eTests, shake256, SHAKE256_LENGTH\n} = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = FBSD ? null : process.env.HOST;\nlet hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                if (user) {\n                    // Check if the password changed\n                    if (decoded.h !== shake256(user.password, SHAKE256_LENGTH)) {\n                        throw new Error(\"The token is invalid due to password change or old token\");\n                    }\n\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n                if (error.message) {\n                    log.error(\"auth\", error.message, `IP=${clientIP}`);\n                }\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: User.createJWT(user, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: User.createJWT(user, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.kafkaProducerSsl = monitor.kafkaProducerSsl;\n                bean.kafkaProducerAllowAutoTopicCreation =\n                    monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        await server.startNSCDServices();\n                    } else {\n                        await server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n        server.monitorList[monitorID].active = 0;\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nlet unexpectedErrorHandler = (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n};\nprocess.addListener(\"unhandledRejection\", unexpectedErrorHandler);\nprocess.addListener(\"uncaughtException\", unexpectedErrorHandler);\n", "const { log } = require(\"../../src/util\");\nconst { Settings } = require(\"../settings\");\nconst { sendInfo } = require(\"../client\");\nconst { checkLogin } = require(\"../util-server\");\nconst GameResolver = require(\"gamedig/lib/GameResolver\");\nconst { testChrome } = require(\"../monitor-types/real-browser-monitor-type\");\n\nlet gameResolver = new GameResolver();\nlet gameList = null;\n\n/**\n * Get a game list via GameDig\n * @returns {Object[]} list of games supported by GameDig\n */\nfunction getGameList() {\n    if (gameList == null) {\n        gameList = gameResolver._readGames().games.sort((a, b) => {\n            if ( a.pretty < b.pretty ) {\n                return -1;\n            }\n            if ( a.pretty > b.pretty ) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    return gameList;\n}\n\nmodule.exports.generalSocketHandler = (socket, server) => {\n\n    socket.on(\"initServerTimezone\", async (timezone) => {\n        try {\n            checkLogin(socket);\n            log.debug(\"generalSocketHandler\", \"Timezone: \" + timezone);\n            await Settings.set(\"initServerTimezone\", true);\n            await server.setTimezone(timezone);\n            await sendInfo(socket);\n        } catch (e) {\n            log.warn(\"initServerTimezone\", e.message);\n        }\n    });\n\n    socket.on(\"getGameList\", async (callback) => {\n        try {\n            checkLogin(socket);\n            callback({\n                ok: true,\n                gameList: getGameList(),\n            });\n        } catch (e) {\n            callback({\n                ok: false,\n                msg: e.message,\n            });\n        }\n    });\n\n    socket.on(\"testChrome\", (executable, callback) => {\n        try {\n            checkLogin(socket);\n            // Just noticed that await call could block the whole socket.io server!!! Use pure promise instead.\n            testChrome(executable).then((version) => {\n                callback({\n                    ok: true,\n                    msg: \"Found Chromium/Chrome. Version: \" + version,\n                });\n            }).catch((e) => {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            });\n        } catch (e) {\n            callback({\n                ok: false,\n                msg: e.message,\n            });\n        }\n    });\n};\n", "const express = require(\"express\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst { R } = require(\"redbean-node\");\nconst { log, isDev } = require(\"../src/util\");\nconst Database = require(\"./database\");\nconst util = require(\"util\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst { Settings } = require(\"./settings\");\nconst dayjs = require(\"dayjs\");\nconst childProcessAsync = require(\"promisify-child-process\");\nconst path = require(\"path\");\n// DO NOT IMPORT HERE IF THE MODULES USED `UptimeKumaServer.getInstance()`, put at the bottom of this file instead.\n\n/**\n * `module.exports` (alias: `server`) should be inside this class, in order to avoid circular dependency issue.\n * @type {UptimeKumaServer}\n */\nclass UptimeKumaServer {\n    /**\n     *\n     * @type {UptimeKumaServer}\n     */\n    static instance = null;\n\n    /**\n     * Main monitor list\n     * @type {{}}\n     */\n    monitorList = {};\n\n    /**\n     * Main maintenance list\n     * @type {{}}\n     */\n    maintenanceList = {};\n\n    entryPage = \"dashboard\";\n    app = undefined;\n    httpServer = undefined;\n    io = undefined;\n\n    /**\n     * Cache Index HTML\n     * @type {string}\n     */\n    indexHTML = \"\";\n\n    /**\n     *\n     * @type {{}}\n     */\n    static monitorTypeList = {\n\n    };\n\n    /**\n     * Use for decode the auth object\n     * @type {null}\n     */\n    jwtSecret = null;\n\n    static getInstance(args) {\n        if (UptimeKumaServer.instance == null) {\n            UptimeKumaServer.instance = new UptimeKumaServer(args);\n        }\n        return UptimeKumaServer.instance;\n    }\n\n    constructor(args) {\n        // SSL\n        const sslKey = args[\"ssl-key\"] || process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\n        const sslCert = args[\"ssl-cert\"] || process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\n        const sslKeyPassphrase = args[\"ssl-key-passphrase\"] || process.env.UPTIME_KUMA_SSL_KEY_PASSPHRASE || process.env.SSL_KEY_PASSPHRASE || undefined;\n\n        log.info(\"server\", \"Creating express and socket.io instance\");\n        this.app = express();\n        if (sslKey && sslCert) {\n            log.info(\"server\", \"Server Type: HTTPS\");\n            this.httpServer = https.createServer({\n                key: fs.readFileSync(sslKey),\n                cert: fs.readFileSync(sslCert),\n                passphrase: sslKeyPassphrase,\n            }, this.app);\n        } else {\n            log.info(\"server\", \"Server Type: HTTP\");\n            this.httpServer = http.createServer(this.app);\n        }\n\n        try {\n            this.indexHTML = fs.readFileSync(\"./dist/index.html\").toString();\n        } catch (e) {\n            // \"dist/index.html\" is not necessary for development\n            if (process.env.NODE_ENV !== \"development\") {\n                log.error(\"server\", \"Error: Cannot find 'dist/index.html', did you install correctly?\");\n                process.exit(1);\n            }\n        }\n\n        // Set Monitor Types\n        UptimeKumaServer.monitorTypeList[\"real-browser\"] = new RealBrowserMonitorType();\n        UptimeKumaServer.monitorTypeList[\"tailscale-ping\"] = new TailscalePing();\n\n        this.io = new Server(this.httpServer, {\n            allowRequest: (req, callback) => {\n                let isOriginValid = true;\n                const bypass = isDev || process.env.UPTIME_KUMA_WS_ORIGIN_CHECK === \"bypass\";\n\n                if (!bypass) {\n                    let host = req.headers.host;\n\n                    // If this is set, it means the request is from the browser\n                    let origin = req.headers.origin;\n\n                    // If this is from the browser, check if the origin is allowed\n                    if (origin) {\n                        try {\n                            let originURL = new URL(origin);\n\n                            if (host !== originURL.host) {\n                                isOriginValid = false;\n                                log.error(\"auth\", `Origin (${origin}) does not match host (${host}), IP: ${req.socket.remoteAddress}`);\n                            }\n                        } catch (e) {\n                            // Invalid origin url, probably not from browser\n                            isOriginValid = false;\n                            log.error(\"auth\", `Invalid origin url (${origin}), IP: ${req.socket.remoteAddress}`);\n                        }\n                    } else {\n                        log.info(\"auth\", `Origin is not set, IP: ${req.socket.remoteAddress}`);\n                    }\n                } else {\n                    log.debug(\"auth\", \"Origin check is bypassed\");\n                }\n\n                callback(null, isOriginValid);\n            }\n        });\n    }\n\n    /** Initialise app after the database has been set up */\n    async initAfterDatabaseReady() {\n        // Static\n        this.app.use(\"/screenshots\", express.static(Database.screenshotDir));\n\n        await CacheableDnsHttpAgent.update();\n\n        process.env.TZ = await this.getTimezone();\n        dayjs.tz.setDefault(process.env.TZ);\n        log.debug(\"DEBUG\", \"Timezone: \" + process.env.TZ);\n        log.debug(\"DEBUG\", \"Current Time: \" + dayjs.tz().format());\n\n        await this.loadMaintenanceList();\n    }\n\n    /**\n     * Send list of monitors to client\n     * @param {Socket} socket\n     * @returns {Object} List of monitors\n     */\n    async sendMonitorList(socket) {\n        let list = await this.getMonitorJSONList(socket.userID);\n        this.io.to(socket.userID).emit(\"monitorList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of monitors for the given user.\n     * @param {string} userID - The ID of the user to get monitors for.\n     * @returns {Promise<Object>} A promise that resolves to an object with monitor IDs as keys and monitor objects as values.\n     *\n     * Generated by Trelent\n     */\n    async getMonitorJSONList(userID) {\n        let result = {};\n\n        let monitorList = await R.find(\"monitor\", \" user_id = ? ORDER BY weight DESC, name\", [\n            userID,\n        ]);\n\n        for (let monitor of monitorList) {\n            result[monitor.id] = await monitor.toJSON();\n        }\n\n        return result;\n    }\n\n    /**\n     * Send maintenance list to client\n     * @param {Socket} socket Socket.io instance to send to\n     * @returns {Object}\n     */\n    async sendMaintenanceList(socket) {\n        return await this.sendMaintenanceListByUserID(socket.userID);\n    }\n\n    /**\n     * Send list of maintenances to user\n     * @param {number} userID\n     * @returns {Object}\n     */\n    async sendMaintenanceListByUserID(userID) {\n        let list = await this.getMaintenanceJSONList(userID);\n        this.io.to(userID).emit(\"maintenanceList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of maintenances for the given user.\n     * @param {string} userID - The ID of the user to get maintenances for.\n     * @returns {Promise<Object>} A promise that resolves to an object with maintenance IDs as keys and maintenances objects as values.\n     */\n    async getMaintenanceJSONList(userID) {\n        let result = {};\n        for (let maintenanceID in this.maintenanceList) {\n            result[maintenanceID] = await this.maintenanceList[maintenanceID].toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Load maintenance list and run\n     * @param userID\n     * @returns {Promise<void>}\n     */\n    async loadMaintenanceList(userID) {\n        let maintenanceList = await R.findAll(\"maintenance\", \" ORDER BY end_date DESC, title\", [\n\n        ]);\n\n        for (let maintenance of maintenanceList) {\n            this.maintenanceList[maintenance.id] = maintenance;\n            maintenance.run(this);\n        }\n    }\n\n    getMaintenance(maintenanceID) {\n        if (this.maintenanceList[maintenanceID]) {\n            return this.maintenanceList[maintenanceID];\n        }\n        return null;\n    }\n\n    /**\n     * Write error to log file\n     * @param {any} error The error to write\n     * @param {boolean} outputToConsole Should the error also be output to console?\n     */\n    static errorLog(error, outputToConsole = true) {\n        const errorLogStream = fs.createWriteStream(path.join(Database.dataDir, \"/error.log\"), {\n            flags: \"a\"\n        });\n\n        errorLogStream.on(\"error\", () => {\n            log.info(\"\", \"Cannot write to error.log\");\n        });\n\n        if (errorLogStream) {\n            const dateTime = R.isoDateTime();\n            errorLogStream.write(`[${dateTime}] ` + util.format(error) + \"\\n\");\n\n            if (outputToConsole) {\n                console.error(error);\n            }\n        }\n\n        errorLogStream.end();\n    }\n\n    /**\n     * Get the IP of the client connected to the socket\n     * @param {Socket} socket\n     * @returns {string}\n     */\n    async getClientIP(socket) {\n        let clientIP = socket.client.conn.remoteAddress;\n\n        if (clientIP === undefined) {\n            clientIP = \"\";\n        }\n\n        if (await Settings.get(\"trustProxy\")) {\n            const forwardedFor = socket.client.conn.request.headers[\"x-forwarded-for\"];\n\n            return (typeof forwardedFor === \"string\" ? forwardedFor.split(\",\")[0].trim() : null)\n                || socket.client.conn.request.headers[\"x-real-ip\"]\n                || clientIP.replace(/^::ffff:/, \"\");\n        } else {\n            return clientIP.replace(/^::ffff:/, \"\");\n        }\n    }\n\n    /**\n     * Attempt to get the current server timezone\n     * If this fails, fall back to environment variables and then make a\n     * guess.\n     * @returns {Promise<string>}\n     */\n    async getTimezone() {\n        // From process.env.TZ\n        try {\n            if (process.env.TZ) {\n                this.checkTimezone(process.env.TZ);\n                return process.env.TZ;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in process.env.TZ\");\n        }\n\n        let timezone = await Settings.get(\"serverTimezone\");\n\n        // From Settings\n        try {\n            log.debug(\"timezone\", \"Using timezone from settings: \" + timezone);\n            if (timezone) {\n                this.checkTimezone(timezone);\n                return timezone;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in settings\");\n        }\n\n        // Guess\n        try {\n            let guess = dayjs.tz.guess();\n            log.debug(\"timezone\", \"Guessing timezone: \" + guess);\n            if (guess) {\n                this.checkTimezone(guess);\n                return guess;\n            } else {\n                return \"UTC\";\n            }\n        } catch (e) {\n            // Guess failed, fall back to UTC\n            log.debug(\"timezone\", \"Guessed an invalid timezone. Use UTC as fallback\");\n            return \"UTC\";\n        }\n    }\n\n    /**\n     * Get the current offset\n     * @returns {string}\n     */\n    getTimezoneOffset() {\n        return dayjs().format(\"Z\");\n    }\n\n    /**\n     * Throw an error if the timezone is invalid\n     * @param timezone\n     */\n    checkTimezone(timezone) {\n        try {\n            dayjs.utc(\"2013-11-18 11:55\").tz(timezone).format();\n        } catch (e) {\n            throw new Error(\"Invalid timezone:\" + timezone);\n        }\n    }\n\n    /**\n     * Set the current server timezone and environment variables\n     * @param {string} timezone\n     */\n    async setTimezone(timezone) {\n        this.checkTimezone(timezone);\n        await Settings.set(\"serverTimezone\", timezone, \"general\");\n        process.env.TZ = timezone;\n        dayjs.tz.setDefault(timezone);\n    }\n\n    /**\n     * TODO: Listen logic should be moved to here\n     * @returns {Promise<void>}\n     */\n    async start() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.startNSCDServices();\n        }\n    }\n\n    /**\n     * Stop the server\n     * @returns {Promise<void>}\n     */\n    async stop() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.stopNSCDServices();\n        }\n    }\n\n    /**\n     * Start all system services (e.g. nscd)\n     * For now, only used in Docker\n     */\n    async startNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Starting nscd\");\n                await childProcessAsync.exec(\"sudo service nscd start\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to start nscd\");\n            }\n        }\n    }\n\n    /**\n     * Stop all system services\n     */\n    async stopNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Stopping nscd\");\n                await childProcessAsync.exec(\"sudo service nscd stop\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to stop nscd\");\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    UptimeKumaServer\n};\n\n// Must be at the end to avoid circular dependencies\nconst { RealBrowserMonitorType } = require(\"./monitor-types/real-browser-monitor-type\");\nconst { TailscalePing } = require(\"./monitor-types/tailscale-ping\");\n", "const tcpp = require(\"tcp-ping\");\nconst ping = require(\"@louislam/ping\");\nconst { R } = require(\"redbean-node\");\nconst { log, genSecret } = require(\"../src/util\");\nconst passwordHash = require(\"./password-hash\");\nconst { Resolver } = require(\"dns\");\nconst childProcess = require(\"child_process\");\nconst iconv = require(\"iconv-lite\");\nconst chardet = require(\"chardet\");\nconst mqtt = require(\"mqtt\");\nconst chroma = require(\"chroma-js\");\nconst { badgeConstants } = require(\"./config\");\nconst mssql = require(\"mssql\");\nconst { Client } = require(\"pg\");\nconst postgresConParse = require(\"pg-connection-string\").parse;\nconst mysql = require(\"mysql2\");\nconst { MongoClient } = require(\"mongodb\");\nconst { NtlmClient } = require(\"axios-ntlm\");\nconst { Settings } = require(\"./settings\");\nconst grpc = require(\"@grpc/grpc-js\");\nconst protojs = require(\"protobufjs\");\nconst radiusClient = require(\"node-radius-client\");\nconst redis = require(\"redis\");\nconst oidc = require(\"openid-client\");\nconst tls = require(\"tls\");\n\nconst {\n    dictionaries: {\n        rfc2865: { file, attributes },\n    },\n} = require(\"node-radius-utils\");\nconst dayjs = require(\"dayjs\");\n\n// SASLOptions used in JSDoc\n// eslint-disable-next-line no-unused-vars\nconst { Kafka, SASLOptions } = require(\"kafkajs\");\nconst crypto = require(\"crypto\");\n\nconst isWindows = process.platform === /^win/.test(process.platform);\n/**\n * Init or reset JWT secret\n * @returns {Promise<Bean>}\n */\nexports.initJWTSecret = async () => {\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (!jwtSecretBean) {\n        jwtSecretBean = R.dispense(\"setting\");\n        jwtSecretBean.key = \"jwtSecret\";\n    }\n\n    jwtSecretBean.value = passwordHash.generate(genSecret());\n    await R.store(jwtSecretBean);\n    return jwtSecretBean;\n};\n\n/**\n * Decodes a jwt and returns the payload portion without verifying the jqt.\n * @param {string} jwt The input jwt as a string\n * @returns {Object} Decoded jwt payload object\n */\nexports.decodeJwt = (jwt) => {\n    return JSON.parse(Buffer.from(jwt.split(\".\")[1], \"base64\").toString());\n};\n\n/**\n * Gets a Access Token form a oidc/oauth2 provider\n * @param {string} tokenEndpoint The token URI form the auth service provider\n * @param {string} clientId The oidc/oauth application client id\n * @param {string} clientSecret The oidc/oauth application client secret\n * @param {string} scope The scope the for which the token should be issued for\n * @param {string} authMethod The method on how to sent the credentials. Default client_secret_basic\n * @returns {Promise<oidc.TokenSet>} TokenSet promise if the token request was successful\n */\nexports.getOidcTokenClientCredentials = async (tokenEndpoint, clientId, clientSecret, scope, authMethod = \"client_secret_basic\") => {\n    const oauthProvider = new oidc.Issuer({ token_endpoint: tokenEndpoint });\n    let client = new oauthProvider.Client({\n        client_id: clientId,\n        client_secret: clientSecret,\n        token_endpoint_auth_method: authMethod\n    });\n\n    // Increase default timeout and clock tolerance\n    client[oidc.custom.http_options] = () => ({ timeout: 10000 });\n    client[oidc.custom.clock_tolerance] = 5;\n\n    let grantParams = { grant_type: \"client_credentials\" };\n    if (scope) {\n        grantParams.scope = scope;\n    }\n    return await client.grant(grantParams);\n};\n\n/**\n * Send TCP request to specified hostname and port\n * @param {string} hostname Hostname / address of machine\n * @param {number} port TCP port to test\n * @returns {Promise<number>} Maximum time in ms rounded to nearest integer\n */\nexports.tcping = function (hostname, port) {\n    return new Promise((resolve, reject) => {\n        tcpp.ping({\n            address: hostname,\n            port: port,\n            attempts: 1,\n        }, function (err, data) {\n\n            if (err) {\n                reject(err);\n            }\n\n            if (data.results.length >= 1 && data.results[0].err) {\n                reject(data.results[0].err);\n            }\n\n            resolve(Math.round(data.max));\n        });\n    });\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine\n * @param {number} [size=56] Size of packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.ping = async (hostname, size = 56) => {\n    try {\n        return await exports.pingAsync(hostname, false, size);\n    } catch (e) {\n        // If the host cannot be resolved, try again with ipv6\n        console.debug(\"ping\", \"IPv6 error message: \" + e.message);\n\n        // As node-ping does not report a specific error for this, try again if it is an empty message with ipv6 no matter what.\n        if (!e.message) {\n            return await exports.pingAsync(hostname, true, size);\n        } else {\n            throw e;\n        }\n    }\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine to ping\n * @param {boolean} ipv6 Should IPv6 be used?\n * @param {number} [size = 56] Size of ping packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.pingAsync = function (hostname, ipv6 = false, size = 56) {\n    return new Promise((resolve, reject) => {\n        ping.promise.probe(hostname, {\n            v6: ipv6,\n            min_reply: 1,\n            deadline: 10,\n            packetSize: size,\n        }).then((res) => {\n            // If ping failed, it will set field to unknown\n            if (res.alive) {\n                resolve(res.time);\n            } else {\n                if (isWindows) {\n                    reject(new Error(exports.convertToUTF8(res.output)));\n                } else {\n                    reject(new Error(res.output));\n                }\n            }\n        }).catch((err) => {\n            reject(err);\n        });\n    });\n};\n\n/**\n * MQTT Monitor\n * @param {string} hostname Hostname / address of machine to test\n * @param {string} topic MQTT topic\n * @param {string} okMessage Expected result\n * @param {Object} [options={}] MQTT options. Contains port, username,\n * password and interval (interval defaults to 20)\n * @returns {Promise<string>}\n */\nexports.mqttAsync = function (hostname, topic, okMessage, options = {}) {\n    return new Promise((resolve, reject) => {\n        const { port, username, password, interval = 20 } = options;\n\n        // Adds MQTT protocol to the hostname if not already present\n        if (!/^(?:http|mqtt|ws)s?:\\/\\//.test(hostname)) {\n            hostname = \"mqtt://\" + hostname;\n        }\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"mqtt\", \"MQTT timeout triggered\");\n            client.end();\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        const mqttUrl = `${hostname}:${port}`;\n\n        log.debug(\"mqtt\", `MQTT connecting to ${mqttUrl}`);\n\n        let client = mqtt.connect(mqttUrl, {\n            username,\n            password\n        });\n\n        client.on(\"connect\", () => {\n            log.debug(\"mqtt\", \"MQTT connected\");\n\n            try {\n                log.debug(\"mqtt\", \"MQTT subscribe topic\");\n                client.subscribe(topic);\n            } catch (e) {\n                client.end();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Cannot subscribe topic\"));\n            }\n        });\n\n        client.on(\"error\", (error) => {\n            client.end();\n            clearTimeout(timeoutID);\n            reject(error);\n        });\n\n        client.on(\"message\", (messageTopic, message) => {\n            if (messageTopic === topic) {\n                client.end();\n                clearTimeout(timeoutID);\n                if (okMessage != null && okMessage !== \"\" && message.toString() !== okMessage) {\n                    reject(new Error(`Message Mismatch - Topic: ${messageTopic}; Message: ${message.toString()}`));\n                } else {\n                    resolve(`Topic: ${messageTopic}; Message: ${message.toString()}`);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Monitor Kafka using Producer\n * @param {string} topic Topic name to produce into\n * @param {string} message Message to produce\n * @param {Object} [options={interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\"}]\n * Kafka client options. Contains ssl, clientId, allowAutoTopicCreation and\n * interval (interval defaults to 20, allowAutoTopicCreation defaults to false, clientId defaults to \"Uptime-Kuma\"\n * and ssl defaults to false)\n * @param {string[]} brokers List of kafka brokers to connect, host and port joined by ':'\n * @param {SASLOptions} [saslOptions={}] Options for kafka client Authentication (SASL) (defaults to\n * {})\n * @returns {Promise<string>}\n */\nexports.kafkaProducerAsync = function (brokers, topic, message, options = {}, saslOptions = {}) {\n    return new Promise((resolve, reject) => {\n        const { interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\" } = options;\n\n        let connectedToKafka = false;\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"kafkaProducer\", \"KafkaProducer timeout triggered\");\n            connectedToKafka = true;\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        if (saslOptions.mechanism === \"None\") {\n            saslOptions = undefined;\n        }\n\n        let client = new Kafka({\n            brokers: brokers,\n            clientId: clientId,\n            sasl: saslOptions,\n            retry: {\n                retries: 0,\n            },\n            ssl: ssl,\n        });\n\n        let producer = client.producer({\n            allowAutoTopicCreation: allowAutoTopicCreation,\n            retry: {\n                retries: 0,\n            }\n        });\n\n        producer.connect().then(\n            () => {\n                producer.send({\n                    topic: topic,\n                    messages: [{\n                        value: message,\n                    }],\n                }).then((_) => {\n                    resolve(\"Message sent successfully\");\n                }).catch((e) => {\n                    connectedToKafka = true;\n                    producer.disconnect();\n                    clearTimeout(timeoutID);\n                    reject(new Error(\"Error sending message: \" + e.message));\n                }).finally(() => {\n                    connectedToKafka = true;\n                    clearTimeout(timeoutID);\n                });\n            }\n        ).catch(\n            (e) => {\n                connectedToKafka = true;\n                producer.disconnect();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Error in producer connection: \" + e.message));\n            }\n        );\n\n        producer.on(\"producer.network.request_timeout\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.network.request_timeout\"));\n            }\n        });\n\n        producer.on(\"producer.disconnect\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.disconnect\"));\n            }\n        });\n    });\n};\n\n/**\n * Use NTLM Auth for a http request.\n * @param {Object} options The http request options\n * @param {Object} ntlmOptions The auth options\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.httpNtlm = function (options, ntlmOptions) {\n    return new Promise((resolve, reject) => {\n        let client = NtlmClient(ntlmOptions);\n\n        client(options)\n            .then((resp) => {\n                resolve(resp);\n            })\n            .catch((err) => {\n                reject(err);\n            });\n    });\n};\n\n/**\n * Resolves a given record using the specified DNS server\n * @param {string} hostname The hostname of the record to lookup\n * @param {string} resolverServer The DNS server to use\n * @param {string} resolverPort Port the DNS server is listening on\n * @param {string} rrtype The type of record to request\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.dnsResolve = function (hostname, resolverServer, resolverPort, rrtype) {\n    const resolver = new Resolver();\n    // Remove brackets from IPv6 addresses so we can re-add them to\n    // prevent issues with ::1:5300 (::1 port 5300)\n    resolverServer = resolverServer.replace(\"[\", \"\").replace(\"]\", \"\");\n    resolver.setServers([ `[${resolverServer}]:${resolverPort}` ]);\n    return new Promise((resolve, reject) => {\n        if (rrtype === \"PTR\") {\n            resolver.reverse(hostname, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        } else {\n            resolver.resolve(hostname, rrtype, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        }\n    });\n};\n\n/**\n * Run a query on SQL Server\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mssqlQuery = async function (connectionString, query) {\n    let pool;\n    try {\n        pool = new mssql.ConnectionPool(connectionString);\n        await pool.connect();\n        if (!query) {\n            query = \"SELECT 1\";\n        }\n        await pool.request().query(query);\n        pool.close();\n    } catch (e) {\n        if (pool) {\n            pool.close();\n        }\n        throw e;\n    }\n};\n\n/**\n * Run a query on Postgres\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.postgresQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const config = postgresConParse(connectionString);\n\n        // Fix #3868, which true/false is not parsed to boolean\n        if (typeof config.ssl === \"string\") {\n            config.ssl = config.ssl === \"true\";\n        }\n\n        if (config.password === \"\") {\n            // See https://github.com/brianc/node-postgres/issues/1927\n            reject(new Error(\"Password is undefined.\"));\n            return;\n        }\n        const client = new Client(config);\n\n        client.on(\"error\", (error) => {\n            log.debug(\"postgres\", \"Error caught in the error event handler.\");\n            reject(error);\n        });\n\n        client.connect((err) => {\n            if (err) {\n                reject(err);\n                client.end();\n            } else {\n                // Connected here\n                try {\n                    // No query provided by user, use SELECT 1\n                    if (!query || (typeof query === \"string\" && query.trim() === \"\")) {\n                        query = \"SELECT 1\";\n                    }\n\n                    client.query(query, (err, res) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(res);\n                        }\n                        client.end();\n                    });\n                } catch (e) {\n                    reject(e);\n                    client.end();\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Run a query on MySQL/MariaDB\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @param {?string} password The password to use\n * @returns {Promise<(string)>}\n */\nexports.mysqlQuery = function (connectionString, query, password = undefined) {\n    return new Promise((resolve, reject) => {\n        const connection = mysql.createConnection({\n            uri: connectionString,\n            password\n        });\n\n        connection.on(\"error\", (err) => {\n            reject(err);\n        });\n\n        connection.query(query, (err, res) => {\n            if (err) {\n                reject(err);\n            } else {\n                if (Array.isArray(res)) {\n                    resolve(\"Rows: \" + res.length);\n                } else {\n                    resolve(\"No Error, but the result is not an array. Type: \" + typeof res);\n                }\n            }\n\n            try {\n                connection.end();\n            } catch (_) {\n                connection.destroy();\n            }\n        });\n    });\n};\n\n/**\n * Connect to and Ping a MongoDB database\n * @param {string} connectionString The database connection string\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mongodbPing = async function (connectionString) {\n    let client = await MongoClient.connect(connectionString);\n    let dbPing = await client.db().command({ ping: 1 });\n    await client.close();\n\n    if (dbPing[\"ok\"] === 1) {\n        return \"UP\";\n    } else {\n        throw Error(\"failed\");\n    }\n};\n\n/**\n * Query radius server\n * @param {string} hostname Hostname of radius server\n * @param {string} username Username to use\n * @param {string} password Password to use\n * @param {string} calledStationId ID of called station\n * @param {string} callingStationId ID of calling station\n * @param {string} secret Secret to use\n * @param {number} [port=1812] Port to contact radius server on\n * @param {number} [timeout=2500] Timeout for connection to use\n * @returns {Promise<any>}\n */\nexports.radius = function (\n    hostname,\n    username,\n    password,\n    calledStationId,\n    callingStationId,\n    secret,\n    port = 1812,\n    timeout = 2500,\n) {\n    const client = new radiusClient({\n        host: hostname,\n        hostPort: port,\n        timeout: timeout,\n        retries: 1,\n        dictionaries: [ file ],\n    });\n\n    return client.accessRequest({\n        secret: secret,\n        attributes: [\n            [ attributes.USER_NAME, username ],\n            [ attributes.USER_PASSWORD, password ],\n            [ attributes.CALLING_STATION_ID, callingStationId ],\n            [ attributes.CALLED_STATION_ID, calledStationId ],\n        ],\n    }).catch((error) => {\n        if (error.response?.code) {\n            throw Error(error.response.code);\n        } else {\n            throw Error(error.message);\n        }\n    });\n};\n\n/**\n * Redis server ping\n * @param {string} dsn The redis connection string\n */\nexports.redisPingAsync = function (dsn) {\n    return new Promise((resolve, reject) => {\n        const client = redis.createClient({\n            url: dsn\n        });\n        client.on(\"error\", (err) => {\n            if (client.isOpen) {\n                client.disconnect();\n            }\n            reject(err);\n        });\n        client.connect().then(() => {\n            if (!client.isOpen) {\n                client.emit(\"error\", new Error(\"connection isn't open\"));\n            }\n            client.ping().then((res, err) => {\n                if (client.isOpen) {\n                    client.disconnect();\n                }\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            }).catch(error => reject(error));\n        });\n    });\n};\n\n/**\n * Retrieve value of setting based on key\n * @param {string} key Key of setting to retrieve\n * @returns {Promise<any>} Value\n * @deprecated Use await Settings.get(key)\n */\nexports.setting = async function (key) {\n    return await Settings.get(key);\n};\n\n/**\n * Sets the specified setting to specifed value\n * @param {string} key Key of setting to set\n * @param {any} value Value to set to\n * @param {?string} type Type of setting\n * @returns {Promise<void>}\n */\nexports.setSetting = async function (key, value, type = null) {\n    await Settings.set(key, value, type);\n};\n\n/**\n * Get settings based on type\n * @param {string} type The type of setting\n * @returns {Promise<Bean>}\n */\nexports.getSettings = async function (type) {\n    return await Settings.getSettings(type);\n};\n\n/**\n * Set settings based on type\n * @param {string} type Type of settings to set\n * @param {Object} data Values of settings\n * @returns {Promise<void>}\n */\nexports.setSettings = async function (type, data) {\n    await Settings.setSettings(type, data);\n};\n\n// ssl-checker by @dyaa\n//https://github.com/dyaa/ssl-checker/blob/master/src/index.ts\n\n/**\n * Get number of days between two dates\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysBetween = (validFrom, validTo) =>\n    Math.round(Math.abs(+validFrom - +validTo) / 8.64e7);\n\n/**\n * Get days remaining from a time range\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysRemaining = (validFrom, validTo) => {\n    const daysRemaining = getDaysBetween(validFrom, validTo);\n    if (new Date(validTo).getTime() < new Date().getTime()) {\n        return -daysRemaining;\n    }\n    return daysRemaining;\n};\n\n/**\n * Fix certificate info for display\n * @param {Object} info The chain obtained from getPeerCertificate()\n * @returns {Object} An object representing certificate information\n */\nconst parseCertificateInfo = function (info) {\n    let link = info;\n    let i = 0;\n\n    const existingList = {};\n\n    while (link) {\n        log.debug(\"cert\", `[${i}] ${link.fingerprint}`);\n\n        if (!link.valid_from || !link.valid_to) {\n            break;\n        }\n        link.validTo = new Date(link.valid_to);\n        link.validFor = link.subjectaltname?.replace(/DNS:|IP Address:/g, \"\").split(\", \");\n        link.daysRemaining = getDaysRemaining(new Date(), link.validTo);\n\n        existingList[link.fingerprint] = true;\n\n        // Move up the chain until loop is encountered\n        if (link.issuerCertificate == null) {\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            break;\n        } else if (link.issuerCertificate.fingerprint in existingList) {\n            // a root CA certificate is typically \"signed by itself\"  (=> \"self signed certificate\") and thus the \"issuerCertificate\" is a reference to itself.\n            log.debug(\"cert\", `[Last] ${link.issuerCertificate.fingerprint}`);\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            link.issuerCertificate = null;\n            break;\n        } else {\n            link.certType = (i === 0) ? \"server\" : \"intermediate CA\";\n            link = link.issuerCertificate;\n        }\n\n        // Should be no use, but just in case.\n        if (i > 500) {\n            throw new Error(\"Dead loop occurred in parseCertificateInfo\");\n        }\n        i++;\n    }\n\n    return info;\n};\n\n/**\n * Check if certificate is valid\n * @param {Object} res Response object from axios\n * @returns {Object} Object containing certificate information\n */\nexports.checkCertificate = function (res) {\n    if (!res.request.res.socket) {\n        throw new Error(\"No socket found\");\n    }\n\n    const info = res.request.res.socket.getPeerCertificate(true);\n    const valid = res.request.res.socket.authorized || false;\n\n    log.debug(\"cert\", \"Parsing Certificate Info\");\n    const parsedInfo = parseCertificateInfo(info);\n\n    return {\n        valid: valid,\n        certInfo: parsedInfo\n    };\n};\n\n/**\n * Check if the provided status code is within the accepted ranges\n * @param {number} status The status code to check\n * @param {string[]} acceptedCodes An array of accepted status codes\n * @returns {boolean} True if status code within range, false otherwise\n */\nexports.checkStatusCode = function (status, acceptedCodes) {\n    if (acceptedCodes == null || acceptedCodes.length === 0) {\n        return false;\n    }\n\n    for (const codeRange of acceptedCodes) {\n        if (typeof codeRange !== \"string\") {\n            log.error(\"monitor\", `Accepted status code not a string. ${codeRange} is of type ${typeof codeRange}`);\n            continue;\n        }\n\n        const codeRangeSplit = codeRange.split(\"-\").map(string => parseInt(string));\n        if (codeRangeSplit.length === 1) {\n            if (status === codeRangeSplit[0]) {\n                return true;\n            }\n        } else if (codeRangeSplit.length === 2) {\n            if (status >= codeRangeSplit[0] && status <= codeRangeSplit[1]) {\n                return true;\n            }\n        } else {\n            log.error(\"monitor\", `${codeRange} is not a valid status code range`);\n            continue;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Get total number of clients in room\n * @param {Server} io Socket server instance\n * @param {string} roomName Name of room to check\n * @returns {number}\n */\nexports.getTotalClientInRoom = (io, roomName) => {\n\n    const sockets = io.sockets;\n\n    if (!sockets) {\n        return 0;\n    }\n\n    const adapter = sockets.adapter;\n\n    if (!adapter) {\n        return 0;\n    }\n\n    const room = adapter.rooms.get(roomName);\n\n    if (room) {\n        return room.size;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Allow CORS all origins if development\n * @param {Object} res Response object from axios\n */\nexports.allowDevAllOrigin = (res) => {\n    if (process.env.NODE_ENV === \"development\") {\n        exports.allowAllOrigin(res);\n    }\n};\n\n/**\n * Allow CORS all origins\n * @param {Object} res Response object from axios\n */\nexports.allowAllOrigin = (res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n};\n\n/**\n * Check if a user is logged in\n * @param {Socket} socket Socket instance\n */\nexports.checkLogin = (socket) => {\n    if (!socket.userID) {\n        throw new Error(\"You are not logged in.\");\n    }\n};\n\n/**\n * For logged-in users, double-check the password\n * @param {Socket} socket Socket.io instance\n * @param {string} currentPassword\n * @returns {Promise<Bean>}\n */\nexports.doubleCheckPassword = async (socket, currentPassword) => {\n    if (typeof currentPassword !== \"string\") {\n        throw new Error(\"Wrong data type?\");\n    }\n\n    let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n        socket.userID,\n    ]);\n\n    if (!user || !passwordHash.verify(currentPassword, user.password)) {\n        throw new Error(\"Incorrect current password\");\n    }\n\n    return user;\n};\n\n/** Start Unit tests */\nexports.startUnitTest = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"jest-backend\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/** Start end-to-end tests */\nexports.startE2eTests = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"cy:run\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/**\n * Convert unknown string to UTF8\n * @param {Uint8Array} body Buffer\n * @returns {string}\n */\nexports.convertToUTF8 = (body) => {\n    const guessEncoding = chardet.detect(body);\n    const str = iconv.decode(body, guessEncoding);\n    return str.toString();\n};\n\n/**\n * Returns a color code in hex format based on a given percentage:\n * 0% => hue = 10 => red\n * 100% => hue = 90 => green\n *\n * @param {number} percentage float, 0 to 1\n * @param {number} maxHue\n * @param {number} minHue, int\n * @returns {string}, hex value\n */\nexports.percentageToColor = (percentage, maxHue = 90, minHue = 10) => {\n    const hue = percentage * (maxHue - minHue) + minHue;\n    try {\n        return chroma(`hsl(${hue}, 90%, 40%)`).hex();\n    } catch (err) {\n        return badgeConstants.naColor;\n    }\n};\n\n/**\n * Joins and array of string to one string after filtering out empty values\n *\n * @param {string[]} parts\n * @param {string} connector\n * @returns {string}\n */\nexports.filterAndJoin = (parts, connector = \"\") => {\n    return parts.filter((part) => !!part && part !== \"\").join(connector);\n};\n\n/**\n * Send an Error response\n * @param {Object} res Express response object\n * @param {string} [msg=\"\"] Message to send\n */\nmodule.exports.sendHttpError = (res, msg = \"\") => {\n    if (msg.includes(\"SQLITE_BUSY\") || msg.includes(\"SQLITE_LOCKED\")) {\n        res.status(503).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else if (msg.toLowerCase().includes(\"not found\")) {\n        res.status(404).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else {\n        res.status(403).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    }\n};\n\nfunction timeObjectConvertTimezone(obj, timezone, timeObjectToUTC = true) {\n    let offsetString;\n\n    if (timezone) {\n        offsetString = dayjs().tz(timezone).format(\"Z\");\n    } else {\n        offsetString = dayjs().format(\"Z\");\n    }\n\n    let hours = parseInt(offsetString.substring(1, 3));\n    let minutes = parseInt(offsetString.substring(4, 6));\n\n    if (\n        (timeObjectToUTC && offsetString.startsWith(\"+\")) ||\n        (!timeObjectToUTC && offsetString.startsWith(\"-\"))\n    ) {\n        hours *= -1;\n        minutes *= -1;\n    }\n\n    obj.hours += hours;\n    obj.minutes += minutes;\n\n    // Handle out of bound\n    if (obj.minutes < 0) {\n        obj.minutes += 60;\n        obj.hours--;\n    } else if (obj.minutes > 60) {\n        obj.minutes -= 60;\n        obj.hours++;\n    }\n\n    if (obj.hours < 0) {\n        obj.hours += 24;\n    } else if (obj.hours > 24) {\n        obj.hours -= 24;\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToUTC = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, true);\n};\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToLocal = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, false);\n};\n\n/**\n * Create gRPC client stib\n * @param {Object} options from gRPC client\n */\nmodule.exports.grpcQuery = async (options) => {\n    const { grpcUrl, grpcProtobufData, grpcServiceName, grpcEnableTls, grpcMethod, grpcBody } = options;\n    const protocObject = protojs.parse(grpcProtobufData);\n    const protoServiceObject = protocObject.root.lookupService(grpcServiceName);\n    const Client = grpc.makeGenericClientConstructor({});\n    const credentials = grpcEnableTls ? grpc.credentials.createSsl() : grpc.credentials.createInsecure();\n    const client = new Client(\n        grpcUrl,\n        credentials\n    );\n    const grpcService = protoServiceObject.create(function (method, requestData, cb) {\n        const fullServiceName = method.fullName;\n        const serviceFQDN = fullServiceName.split(\".\");\n        const serviceMethod = serviceFQDN.pop();\n        const serviceMethodClientImpl = `/${serviceFQDN.slice(1).join(\".\")}/${serviceMethod}`;\n        log.debug(\"monitor\", `gRPC method ${serviceMethodClientImpl}`);\n        client.makeUnaryRequest(\n            serviceMethodClientImpl,\n            arg => arg,\n            arg => arg,\n            requestData,\n            cb);\n    }, false, false);\n    return new Promise((resolve, _) => {\n        try {\n            return grpcService[`${grpcMethod}`](JSON.parse(grpcBody), function (err, response) {\n                const responseData = JSON.stringify(response);\n                if (err) {\n                    return resolve({\n                        code: err.code,\n                        errorMessage: err.details,\n                        data: \"\"\n                    });\n                } else {\n                    log.debug(\"monitor:\", `gRPC response: ${JSON.stringify(response)}`);\n                    return resolve({\n                        code: 1,\n                        errorMessage: \"\",\n                        data: responseData\n                    });\n                }\n            });\n        } catch (err) {\n            return resolve({\n                code: -1,\n                errorMessage: `Error ${err}. Please review your gRPC configuration option. The service name must not include package name value, and the method name must follow camelCase format`,\n                data: \"\"\n            });\n        }\n\n    });\n};\n\n/**\n * Returns an array of SHA256 fingerprints for all known root certificates.\n * @returns {Set} A set of SHA256 fingerprints.\n */\nmodule.exports.rootCertificatesFingerprints = () => {\n    let fingerprints = tls.rootCertificates.map(cert => {\n        let certLines = cert.split(\"\\n\");\n        certLines.shift();\n        certLines.pop();\n        let certBody = certLines.join(\"\");\n        let buf = Buffer.from(certBody, \"base64\");\n\n        const shasum = crypto.createHash(\"sha256\");\n        shasum.update(buf);\n\n        return shasum.digest(\"hex\").toUpperCase().replace(/(.{2})(?!$)/g, \"$1:\");\n    });\n\n    fingerprints.push(\"6D:99:FB:26:5E:B1:C5:B3:74:47:65:FC:BC:64:8F:3C:D8:E1:BF:FA:FD:C4:C2:F9:9B:9D:47:CF:7F:F1:C2:4F\"); // ISRG X1 cross-signed with DST X3\n    fingerprints.push(\"8B:05:B6:8C:C6:59:E5:ED:0F:CB:38:F2:C9:42:FB:FD:20:0E:6F:2F:F9:F8:5D:63:C6:99:4E:F5:E0:B0:27:01\"); // ISRG X2 cross-signed with ISRG X1\n\n    return new Set(fingerprints);\n};\n\nmodule.exports.SHAKE256_LENGTH = 16;\n\n/**\n *\n * @param {string} data\n * @param {number} len\n * @return {string}\n */\nmodule.exports.shake256 = (data, len) => {\n    if (!data) {\n        return \"\";\n    }\n    return crypto.createHash(\"shake256\", { outputLength: len })\n        .update(data)\n        .digest(\"hex\");\n};\n\n// For unit test, export functions\nif (process.env.TEST_BACKEND) {\n    module.exports.__test = {\n        parseCertificateInfo,\n    };\n    module.exports.__getPrivateFunction = (functionName) => {\n        return module.exports.__test[functionName];\n    };\n}\n\n/**\n * Generates an abort signal with the specified timeout.\n * @param {number} timeoutMs - The timeout in milliseconds.\n * @returns {AbortSignal | null} - The generated abort signal, or null if not supported.\n */\nmodule.exports.axiosAbortSignal = (timeoutMs) => {\n    try {\n        // Just in case, as 0 timeout here will cause the request to be aborted immediately\n        if (!timeoutMs || timeoutMs <= 0) {\n            timeoutMs = 5000;\n        }\n        return AbortSignal.timeout(timeoutMs);\n    } catch (_) {\n        // v16-: AbortSignal.timeout is not supported\n        try {\n            const abortController = new AbortController();\n            setTimeout(() => abortController.abort(), timeoutMs);\n\n            return abortController.signal;\n        } catch (_) {\n            // v15-: AbortController is not supported\n            return null;\n        }\n    }\n};\n", "<template>\n    <div ref=\"BadgeGeneratorModal\" class=\"modal fade\" tabindex=\"-1\" data-bs-backdrop=\"static\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">\n                        {{ $t(\"Badge Generator\", [monitor.name]) }}\n                    </h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\" />\n                </div>\n                <div class=\"modal-body\">\n                    <div class=\"mb-3\">\n                        <label for=\"type\" class=\"form-label\">{{ $t(\"Badge Type\") }}</label>\n                        <select id=\"type\" v-model=\"badge.type\" class=\"form-select\">\n                            <option value=\"status\">status</option>\n                            <option value=\"uptime\">uptime</option>\n                            <option value=\"ping\">ping</option>\n                            <option value=\"avg-response\">avg-response</option>\n                            <option value=\"cert-exp\">cert-exp</option>\n                            <option value=\"response\">response</option>\n                        </select>\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('duration') \" class=\"mb-3\">\n                        <label for=\"duration\" class=\"form-label\">{{ $t(\"Badge Duration (in hours)\") }}</label>\n                        <input id=\"duration\" v-model=\"badge.duration\" type=\"number\" min=\"0\" placeholder=\"24\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('label') \" class=\"mb-3\">\n                        <label for=\"label\" class=\"form-label\">{{ $t(\"Badge Label\") }}</label>\n                        <input id=\"label\" v-model=\"badge.label\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('prefix') \" class=\"mb-3\">\n                        <label for=\"prefix\" class=\"form-label\">{{ $t(\"Badge Prefix\") }}</label>\n                        <input id=\"prefix\" v-model=\"badge.prefix\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('suffix') \" class=\"mb-3\">\n                        <label for=\"suffix\" class=\"form-label\">{{ $t(\"Badge Suffix\") }}</label>\n                        <input id=\"suffix\" v-model=\"badge.suffix\" type=\"text\" placeholder=\"%\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelColor') \" class=\"mb-3\">\n                        <label for=\"labelColor\" class=\"form-label\">{{ $t(\"Badge Label Color\") }}</label>\n                        <input id=\"labelColor\" v-model=\"badge.labelColor\" type=\"text\" placeholder=\"#555\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('color') \" class=\"mb-3\">\n                        <label for=\"color\" class=\"form-label\">{{ $t(\"Badge Color\") }}</label>\n                        <input id=\"color\" v-model=\"badge.color\" type=\"text\" :placeholder=\"badgeConstants.defaultUpColor\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelPrefix') \" class=\"mb-3\">\n                        <label for=\"labelPrefix\" class=\"form-label\">{{ $t(\"Badge Label Prefix\") }}</label>\n                        <input id=\"labelPrefix\" v-model=\"badge.labelPrefix\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelSuffix') \" class=\"mb-3\">\n                        <label for=\"labelSuffix\" class=\"form-label\">{{ $t(\"Badge Label Suffix\") }}</label>\n                        <input id=\"labelSuffix\" v-model=\"badge.labelSuffix\" type=\"text\" placeholder=\"h\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('upColor') \" class=\"mb-3\">\n                        <label for=\"upColor\" class=\"form-label\">{{ $t(\"Badge Up Color\") }}</label>\n                        <input id=\"upColor\" v-model=\"badge.upColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultUpColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('downColor') \" class=\"mb-3\">\n                        <label for=\"downColor\" class=\"form-label\">{{ $t(\"Badge Down Color\") }}</label>\n                        <input id=\"downColor\" v-model=\"badge.downColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultDownColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('pendingColor') \" class=\"mb-3\">\n                        <label for=\"pendingColor\" class=\"form-label\">{{ $t(\"Badge Pending Color\") }}</label>\n                        <input id=\"pendingColor\" v-model=\"badge.pendingColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultPendingColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('maintenanceColor') \" class=\"mb-3\">\n                        <label for=\"maintenanceColor\" class=\"form-label\">{{ $t(\"Badge Maintenance Color\") }}</label>\n                        <input id=\"maintenanceColor\" v-model=\"badge.maintenanceColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultMaintenanceColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('warnColor') \" class=\"mb-3\">\n                        <label for=\"warnColor\" class=\"form-label\">{{ $t(\"Badge Warn Color\") }}</label>\n                        <input id=\"warnColor\" v-model=\"badge.warnColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultMaintenanceColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('warnDays') \" class=\"mb-3\">\n                        <label for=\"warnDays\" class=\"form-label\">{{ $t(\"Badge Warn Days\") }}</label>\n                        <input id=\"warnDays\" v-model=\"badge.warnDays\" type=\"number\" min=\"0\" class=\"form-control\" :placeholder=\"badgeConstants.defaultCertExpireWarnDays\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('downDays') \" class=\"mb-3\">\n                        <label for=\"downDays\" class=\"form-label\">{{ $t(\"Badge Down Days\") }}</label>\n                        <input id=\"downDays\" v-model=\"badge.downDays\" type=\"number\" min=\"0\" class=\"form-control\" :placeholder=\"badgeConstants.defaultCertExpireDownDays\">\n                    </div>\n\n                    <div class=\"mb-3\">\n                        <label for=\"style\" class=\"form-label\">{{ $t(\"Badge Style\") }}</label>\n                        <select id=\"style\" v-model=\"badge.style\" class=\"form-select\">\n                            <option value=\"plastic\">plastic</option>\n                            <option value=\"flat\">flat</option>\n                            <option value=\"flat-square\">flat-square</option>\n                            <option value=\"for-the-badge\">for-the-badge</option>\n                            <option value=\"social\">social</option>\n                        </select>\n                    </div>\n\n                    <div class=\"mb-3\">\n                        <label for=\"value\" class=\"form-label\">{{ $t(\"Badge value (For Testing only.)\") }}</label>\n                        <input id=\"value\" v-model=\"badge.value\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div class=\"mb-3 pt-3 d-flex justify-content-center\">\n                        <img :src=\"badgeURL\" :alt=\"$t('Badge Preview')\">\n                    </div>\n\n                    <div class=\"my-3\">\n                        <label for=\"badge-url\" class=\"form-label\">{{ $t(\"Badge URL\") }}</label>\n                        <CopyableInput id=\"badge-url\" v-model=\"badgeURL\" type=\"url\" disabled=\"disabled\" />\n                    </div>\n                </div>\n\n                <div class=\"modal-footer\">\n                    <button type=\"submit\" class=\"btn btn-danger\" data-bs-dismiss=\"modal\">\n                        {{ $t(\"Close\") }}\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { Modal } from \"bootstrap\";\nimport CopyableInput from \"./CopyableInput.vue\";\nimport { default as serverConfig } from \"../../server/config.js\";\n\nexport default {\n    components: {\n        CopyableInput\n    },\n    props: {},\n    emits: [],\n    data() {\n        return {\n            model: null,\n            processing: false,\n            monitor: {\n                id: null,\n                name: null,\n            },\n            badge: {\n                type: \"status\",\n                duration: null,\n                label: null,\n                prefix: null,\n                suffix: null,\n                labelColor: null,\n                color: null,\n                labelPrefix: null,\n                labelSuffix: null,\n                upColor: null,\n                downColor: null,\n                pendingColor: null,\n                maintenanceColor: null,\n                warnColor: null,\n                warnDays: null,\n                downDays: null,\n                style: \"flat\",\n                value: null,\n            },\n            parameters: {\n                status: [\n                    \"upLabel\",\n                    \"downLabel\",\n                    \"pendingLabel\",\n                    \"maintenanceLabel\",\n                    \"upColor\",\n                    \"downColor\",\n                    \"pendingColor\",\n                    \"maintenanceColor\",\n                ],\n                uptime: [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                ping: [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                \"avg-response\": [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                \"cert-exp\": [\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"upColor\",\n                    \"warnColor\",\n                    \"downColor\",\n                    \"warnDays\",\n                    \"downDays\",\n                    \"labelColor\",\n                ],\n                response: [\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n            },\n            badgeConstants: serverConfig.badgeConstants,\n        };\n    },\n\n    computed: {\n        badgeURL() {\n            if (!this.monitor.id || !this.badge.type) {\n                return;\n            }\n            let badgeURL = this.$root.baseURL + \"/api/badge/\" + this.monitor.id + \"/\" + this.badge.type;\n\n            let parameterList = {};\n\n            for (let parameter of this.parameters[this.badge.type] || []) {\n                if (parameter === \"duration\" && this.badge.duration) {\n                    badgeURL += \"/\" + this.badge.duration;\n                    continue;\n                }\n\n                if (this.badge[parameter]) {\n                    parameterList[parameter] = this.badge[parameter];\n                }\n            }\n\n            for (let parameter of [ \"label\", \"style\", \"value\" ]) {\n                if (parameter === \"style\" && this.badge.style === \"flat\") {\n                    continue;\n                }\n\n                if (this.badge[parameter]) {\n                    parameterList[parameter] = this.badge[parameter];\n                }\n            }\n\n            if (Object.keys(parameterList).length > 0) {\n                return badgeURL + \"?\" + new URLSearchParams(parameterList);\n            }\n\n            return badgeURL;\n        },\n    },\n\n    mounted() {\n        this.BadgeGeneratorModal = new Modal(this.$refs.BadgeGeneratorModal);\n    },\n\n    methods: {\n        /**\n         * Setting monitor\n         * @param {number} monitorId    ID of monitor\n         * @param {string} monitorName  Name of monitor\n         */\n        show(monitorId, monitorName) {\n            this.monitor = {\n                id: monitorId,\n                name: monitorName,\n            };\n\n            this.BadgeGeneratorModal.show();\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../assets/vars.scss\";\n\n.dark {\n    .modal-dialog .form-text, .modal-dialog p {\n        color: $dark-font-color;\n    }\n}\n</style>\n", "import { io } from \"socket.io-client\";\nimport { useToast } from \"vue-toastification\";\nimport jwtDecode from \"jwt-decode\";\nimport Favico from \"favico.js\";\nimport dayjs from \"dayjs\";\nimport { DOWN, MAINTENANCE, PENDING, UP } from \"../util.ts\";\nimport { getDevContainerServerHostname, isDevContainer } from \"../util-frontend.js\";\nconst toast = useToast();\n\nlet socket;\n\nconst noSocketIOPages = [\n    /^\\/status-page$/,  //  /status-page\n    /^\\/status/,    // /status**\n    /^\\/$/      //  /\n];\n\nconst favicon = new Favico({\n    animation: \"none\"\n});\n\nexport default {\n\n    data() {\n        return {\n            info: { },\n            socket: {\n                token: null,\n                firstConnect: true,\n                connected: false,\n                connectCount: 0,\n                initedSocketIO: false,\n            },\n            username: null,\n            remember: (localStorage.remember !== \"0\"),\n            allowLoginDialog: false,        // Allowed to show login dialog, but \"loggedIn\" have to be true too. This exists because prevent the login dialog show 0.1s in first before the socket server auth-ed.\n            loggedIn: false,\n            monitorList: { },\n            maintenanceList: {},\n            apiKeyList: {},\n            heartbeatList: { },\n            importantHeartbeatList: { },\n            avgPingList: { },\n            uptimeList: { },\n            tlsInfoList: {},\n            notificationList: [],\n            dockerHostList: [],\n            statusPageListLoaded: false,\n            statusPageList: [],\n            proxyList: [],\n            connectionErrorMsg: `${this.$t(\"Cannot connect to the socket server.\")} ${this.$t(\"Reconnecting...\")}`,\n            showReverseProxyGuide: true,\n            cloudflared: {\n                cloudflareTunnelToken: \"\",\n                installed: null,\n                running: false,\n                message: \"\",\n                errorMessage: \"\",\n                currentPassword: \"\",\n            },\n            faviconUpdateDebounce: null,\n        };\n    },\n\n    created() {\n        this.initSocketIO();\n    },\n\n    methods: {\n\n        /**\n         * Initialize connection to socket server\n         * @param {boolean} [bypass = false] Should the check for if we\n         * are on a status page be bypassed?\n         * @returns {(void|null)}\n         */\n        initSocketIO(bypass = false) {\n            // No need to re-init\n            if (this.socket.initedSocketIO) {\n                return;\n            }\n\n            // No need to connect to the socket.io for status page\n            if (! bypass && location.pathname) {\n                for (let page of noSocketIOPages) {\n                    if (location.pathname.match(page)) {\n                        return;\n                    }\n                }\n            }\n\n            this.socket.initedSocketIO = true;\n\n            let protocol = (location.protocol === \"https:\") ? \"wss://\" : \"ws://\";\n\n            let wsHost;\n            const env = process.env.NODE_ENV || \"production\";\n            if (env === \"development\" && isDevContainer()) {\n                wsHost = protocol + getDevContainerServerHostname();\n            } else if (env === \"development\" || localStorage.dev === \"dev\") {\n                wsHost = protocol + location.hostname + \":3001\";\n            } else {\n                wsHost = protocol + location.host;\n            }\n\n            socket = io(wsHost, {\n                transports: [ \"websocket\" ],\n            });\n\n            socket.on(\"info\", (info) => {\n                this.info = info;\n            });\n\n            socket.on(\"setup\", (monitorID, data) => {\n                this.$router.push(\"/setup\");\n            });\n\n            socket.on(\"autoLogin\", (monitorID, data) => {\n                this.loggedIn = true;\n                this.storage().token = \"autoLogin\";\n                this.socket.token = \"autoLogin\";\n                this.allowLoginDialog = false;\n            });\n\n            socket.on(\"monitorList\", (data) => {\n                // Add Helper function\n                Object.entries(data).forEach(([ monitorID, monitor ]) => {\n                    monitor.getUrl = () => {\n                        try {\n                            return new URL(monitor.url);\n                        } catch (_) {\n                            return null;\n                        }\n                    };\n                });\n                this.monitorList = data;\n            });\n\n            socket.on(\"maintenanceList\", (data) => {\n                this.maintenanceList = data;\n            });\n\n            socket.on(\"apiKeyList\", (data) => {\n                this.apiKeyList = data;\n            });\n\n            socket.on(\"notificationList\", (data) => {\n                this.notificationList = data;\n            });\n\n            socket.on(\"statusPageList\", (data) => {\n                this.statusPageListLoaded = true;\n                this.statusPageList = data;\n            });\n\n            socket.on(\"proxyList\", (data) => {\n                this.proxyList = data.map(item => {\n                    item.auth = !!item.auth;\n                    item.active = !!item.active;\n                    item.default = !!item.default;\n\n                    return item;\n                });\n            });\n\n            socket.on(\"dockerHostList\", (data) => {\n                this.dockerHostList = data;\n            });\n\n            socket.on(\"heartbeat\", (data) => {\n                if (! (data.monitorID in this.heartbeatList)) {\n                    this.heartbeatList[data.monitorID] = [];\n                }\n\n                this.heartbeatList[data.monitorID].push(data);\n\n                if (this.heartbeatList[data.monitorID].length >= 150) {\n                    this.heartbeatList[data.monitorID].shift();\n                }\n\n                // Add to important list if it is important\n                // Also toast\n                if (data.important) {\n\n                    if (this.monitorList[data.monitorID] !== undefined) {\n                        if (data.status === 0) {\n                            toast.error(`[${this.monitorList[data.monitorID].name}] [DOWN] ${data.msg}`, {\n                                timeout: false,\n                            });\n                        } else if (data.status === 1) {\n                            toast.success(`[${this.monitorList[data.monitorID].name}] [Up] ${data.msg}`, {\n                                timeout: 20000,\n                            });\n                        } else {\n                            toast(`[${this.monitorList[data.monitorID].name}] ${data.msg}`);\n                        }\n                    }\n\n                    if (! (data.monitorID in this.importantHeartbeatList)) {\n                        this.importantHeartbeatList[data.monitorID] = [];\n                    }\n\n                    this.importantHeartbeatList[data.monitorID].unshift(data);\n                }\n            });\n\n            socket.on(\"heartbeatList\", (monitorID, data, overwrite = false) => {\n                if (! (monitorID in this.heartbeatList) || overwrite) {\n                    this.heartbeatList[monitorID] = data;\n                } else {\n                    this.heartbeatList[monitorID] = data.concat(this.heartbeatList[monitorID]);\n                }\n            });\n\n            socket.on(\"avgPing\", (monitorID, data) => {\n                this.avgPingList[monitorID] = data;\n            });\n\n            socket.on(\"uptime\", (monitorID, type, data) => {\n                this.uptimeList[`${monitorID}_${type}`] = data;\n            });\n\n            socket.on(\"certInfo\", (monitorID, data) => {\n                this.tlsInfoList[monitorID] = JSON.parse(data);\n            });\n\n            socket.on(\"importantHeartbeatList\", (monitorID, data, overwrite) => {\n                if (! (monitorID in this.importantHeartbeatList) || overwrite) {\n                    this.importantHeartbeatList[monitorID] = data;\n                } else {\n                    this.importantHeartbeatList[monitorID] = data.concat(this.importantHeartbeatList[monitorID]);\n                }\n            });\n\n            socket.on(\"connect_error\", (err) => {\n                console.error(`Failed to connect to the backend. Socket.io connect_error: ${err.message}`);\n                this.connectionErrorMsg = `${this.$t(\"Cannot connect to the socket server.\")} [${err}] ${this.$t(\"Reconnecting...\")}`;\n                this.showReverseProxyGuide = true;\n                this.socket.connected = false;\n                this.socket.firstConnect = false;\n            });\n\n            socket.on(\"disconnect\", () => {\n                console.log(\"disconnect\");\n                this.connectionErrorMsg = \"Lost connection to the socket server. Reconnecting...\";\n                this.socket.connected = false;\n            });\n\n            socket.on(\"connect\", () => {\n                console.log(\"Connected to the socket server\");\n                this.socket.connectCount++;\n                this.socket.connected = true;\n                this.showReverseProxyGuide = false;\n\n                // Reset Heartbeat list if it is re-connect\n                if (this.socket.connectCount >= 2) {\n                    this.clearData();\n                }\n\n                let token = this.storage().token;\n\n                if (token) {\n                    if (token !== \"autoLogin\") {\n                        this.loginByToken(token);\n                    } else {\n                        // Timeout if it is not actually auto login\n                        setTimeout(() => {\n                            if (! this.loggedIn) {\n                                this.allowLoginDialog = true;\n                                this.$root.storage().removeItem(\"token\");\n                            }\n                        }, 5000);\n                    }\n                } else {\n                    this.allowLoginDialog = true;\n                }\n\n                this.socket.firstConnect = false;\n            });\n\n            // cloudflared\n            socket.on(\"cloudflared_installed\", (res) => this.cloudflared.installed = res);\n            socket.on(\"cloudflared_running\", (res) => this.cloudflared.running = res);\n            socket.on(\"cloudflared_message\", (res) => this.cloudflared.message = res);\n            socket.on(\"cloudflared_errorMessage\", (res) => this.cloudflared.errorMessage = res);\n            socket.on(\"cloudflared_token\", (res) => this.cloudflared.cloudflareTunnelToken = res);\n\n            socket.on(\"initServerTimezone\", () => {\n                socket.emit(\"initServerTimezone\", dayjs.tz.guess());\n            });\n        },\n\n        /**\n         * The storage currently in use\n         * @returns {Storage}\n         */\n        storage() {\n            return (this.remember) ? localStorage : sessionStorage;\n        },\n\n        /**\n         * Get payload of JWT cookie\n         * @returns {(Object|undefined)}\n         */\n        getJWTPayload() {\n            const jwtToken = this.$root.storage().token;\n\n            if (jwtToken && jwtToken !== \"autoLogin\") {\n                return jwtDecode(jwtToken);\n            }\n            return undefined;\n        },\n\n        /**\n         * Get current socket\n         * @returns {Socket}\n         */\n        getSocket() {\n            return socket;\n        },\n\n        /**\n         * Show success or error toast dependant on response status code\n         * @param {Object} res Response object\n         */\n        toastRes(res) {\n            if (res.ok) {\n                toast.success(res.msg);\n            } else {\n                toast.error(res.msg);\n            }\n        },\n\n        /**\n         * Show a success toast\n         * @param {string} msg Message to show\n         */\n        toastSuccess(msg) {\n            toast.success(msg);\n        },\n\n        /**\n         * Show an error toast\n         * @param {string} msg Message to show\n         */\n        toastError(msg) {\n            toast.error(msg);\n        },\n\n        /**\n         * Callback for login\n         * @callback loginCB\n         * @param {Object} res Response object\n         */\n\n        /**\n         * Send request to log user in\n         * @param {string} username Username to log in with\n         * @param {string} password Password to log in with\n         * @param {string} token User token\n         * @param {loginCB} callback Callback to call with result\n         */\n        login(username, password, token, callback) {\n            socket.emit(\"login\", {\n                username,\n                password,\n                token,\n            }, (res) => {\n                if (res.tokenRequired) {\n                    callback(res);\n                }\n\n                if (res.ok) {\n                    this.storage().token = res.token;\n                    this.socket.token = res.token;\n                    this.loggedIn = true;\n                    this.username = this.getJWTPayload()?.username;\n\n                    // Trigger Chrome Save Password\n                    history.pushState({}, \"\");\n                }\n\n                callback(res);\n            });\n        },\n\n        /**\n         * Log in using a token\n         * @param {string} token Token to log in with\n         */\n        loginByToken(token) {\n            socket.emit(\"loginByToken\", token, (res) => {\n                this.allowLoginDialog = true;\n\n                if (! res.ok) {\n                    this.logout();\n                } else {\n                    this.loggedIn = true;\n                    this.username = this.getJWTPayload()?.username;\n                }\n            });\n        },\n\n        /** Log out of the web application */\n        logout() {\n            socket.emit(\"logout\", () => { });\n            this.storage().removeItem(\"token\");\n            this.socket.token = null;\n            this.loggedIn = false;\n            this.username = null;\n            this.clearData();\n        },\n\n        /**\n         * Callback for general socket requests\n         * @callback socketCB\n         * @param {Object} res Result of operation\n         */\n        /** Prepare 2FA configuration */\n        prepare2FA(callback) {\n            socket.emit(\"prepare2FA\", callback);\n        },\n\n        /**\n         * Save the current 2FA configuration\n         * @param {any} secret Unused\n         * @param {socketCB} callback\n         */\n        save2FA(secret, callback) {\n            socket.emit(\"save2FA\", callback);\n        },\n\n        /**\n         * Disable 2FA for this user\n         * @param {socketCB} callback\n         */\n        disable2FA(callback) {\n            socket.emit(\"disable2FA\", callback);\n        },\n\n        /**\n         * Verify the provided 2FA token\n         * @param {string} token Token to verify\n         * @param {socketCB} callback\n         */\n        verifyToken(token, callback) {\n            socket.emit(\"verifyToken\", token, callback);\n        },\n\n        /**\n         * Get current 2FA status\n         * @param {socketCB} callback\n         */\n        twoFAStatus(callback) {\n            socket.emit(\"twoFAStatus\", callback);\n        },\n\n        /**\n         * Get list of monitors\n         * @param {socketCB} callback\n         */\n        getMonitorList(callback) {\n            if (! callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getMonitorList\", callback);\n        },\n\n        /**\n         * Get list of maintenances\n         * @param {socketCB} callback\n         */\n        getMaintenanceList(callback) {\n            if (! callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getMaintenanceList\", callback);\n        },\n\n        /**\n         * Send list of API keys\n         * @param {socketCB} callback\n         */\n        getAPIKeyList(callback) {\n            if (!callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getAPIKeyList\", callback);\n        },\n\n        /**\n         * Add a monitor\n         * @param {Object} monitor Object representing monitor to add\n         * @param {socketCB} callback\n         */\n        add(monitor, callback) {\n            socket.emit(\"add\", monitor, callback);\n        },\n\n        /**\n         * Adds a maintenace\n         * @param {Object} maintenance\n         * @param {socketCB} callback\n         */\n        addMaintenance(maintenance, callback) {\n            socket.emit(\"addMaintenance\", maintenance, callback);\n        },\n\n        /**\n         * Add monitors to maintenance\n         * @param {number} maintenanceID\n         * @param {number[]} monitors\n         * @param {socketCB} callback\n         */\n        addMonitorMaintenance(maintenanceID, monitors, callback) {\n            socket.emit(\"addMonitorMaintenance\", maintenanceID, monitors, callback);\n        },\n\n        /**\n         * Add status page to maintenance\n         * @param {number} maintenanceID\n         * @param {number} statusPages\n         * @param {socketCB} callback\n         */\n        addMaintenanceStatusPage(maintenanceID, statusPages, callback) {\n            socket.emit(\"addMaintenanceStatusPage\", maintenanceID, statusPages, callback);\n        },\n\n        /**\n         * Get monitors affected by maintenance\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        getMonitorMaintenance(maintenanceID, callback) {\n            socket.emit(\"getMonitorMaintenance\", maintenanceID, callback);\n        },\n\n        /**\n         * Get status pages where maintenance is shown\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        getMaintenanceStatusPage(maintenanceID, callback) {\n            socket.emit(\"getMaintenanceStatusPage\", maintenanceID, callback);\n        },\n\n        /**\n         * Delete monitor by ID\n         * @param {number} monitorID ID of monitor to delete\n         * @param {socketCB} callback\n         */\n        deleteMonitor(monitorID, callback) {\n            socket.emit(\"deleteMonitor\", monitorID, callback);\n        },\n\n        /**\n         * Delete specified maintenance\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        deleteMaintenance(maintenanceID, callback) {\n            socket.emit(\"deleteMaintenance\", maintenanceID, callback);\n        },\n\n        /**\n         * Add an API key\n         * @param {Object} key API key to add\n         * @param {socketCB} callback\n         */\n        addAPIKey(key, callback) {\n            socket.emit(\"addAPIKey\", key, callback);\n        },\n\n        /**\n         * Delete specified API key\n         * @param {int} keyID ID of key to delete\n         * @param {socketCB} callback\n         */\n        deleteAPIKey(keyID, callback) {\n            socket.emit(\"deleteAPIKey\", keyID, callback);\n        },\n\n        /** Clear the hearbeat list */\n        clearData() {\n            console.log(\"reset heartbeat list\");\n            this.heartbeatList = {};\n            this.importantHeartbeatList = {};\n        },\n\n        /**\n         * Upload the provided backup\n         * @param {string} uploadedJSON JSON to upload\n         * @param {string} importHandle Type of import. If set to\n         * most data in database will be replaced\n         * @param {socketCB} callback\n         */\n        uploadBackup(uploadedJSON, importHandle, callback) {\n            socket.emit(\"uploadBackup\", uploadedJSON, importHandle, callback);\n        },\n\n        /**\n         * Clear events for a specified monitor\n         * @param {number} monitorID ID of monitor to clear\n         * @param {socketCB} callback\n         */\n        clearEvents(monitorID, callback) {\n            socket.emit(\"clearEvents\", monitorID, callback);\n        },\n\n        /**\n         * Clear the heartbeats of a specified monitor\n         * @param {number} monitorID Id of monitor to clear\n         * @param {socketCB} callback\n         */\n        clearHeartbeats(monitorID, callback) {\n            socket.emit(\"clearHeartbeats\", monitorID, callback);\n        },\n\n        /**\n         * Clear all statistics\n         * @param {socketCB} callback\n         */\n        clearStatistics(callback) {\n            socket.emit(\"clearStatistics\", callback);\n        },\n\n        /**\n         * Get monitor beats for a specific monitor in a time range\n         * @param {number} monitorID ID of monitor to fetch\n         * @param {number} period Time in hours from now\n         * @param {socketCB} callback\n         */\n        getMonitorBeats(monitorID, period, callback) {\n            socket.emit(\"getMonitorBeats\", monitorID, period, callback);\n        }\n    },\n\n    computed: {\n\n        usernameFirstChar() {\n            if (typeof this.username == \"string\" && this.username.length >= 1) {\n                return this.username.charAt(0).toUpperCase();\n            } else {\n                return \"\ud83d\udc3b\";\n            }\n        },\n\n        lastHeartbeatList() {\n            let result = {};\n\n            for (let monitorID in this.heartbeatList) {\n                let index = this.heartbeatList[monitorID].length - 1;\n                result[monitorID] = this.heartbeatList[monitorID][index];\n            }\n\n            return result;\n        },\n\n        statusList() {\n            let result = {};\n\n            let unknown = {\n                text: this.$t(\"Unknown\"),\n                color: \"secondary\",\n            };\n\n            for (let monitorID in this.lastHeartbeatList) {\n                let lastHeartBeat = this.lastHeartbeatList[monitorID];\n\n                if (! lastHeartBeat) {\n                    result[monitorID] = unknown;\n                } else if (lastHeartBeat.status === UP) {\n                    result[monitorID] = {\n                        text: this.$t(\"Up\"),\n                        color: \"primary\",\n                    };\n                } else if (lastHeartBeat.status === DOWN) {\n                    result[monitorID] = {\n                        text: this.$t(\"Down\"),\n                        color: \"danger\",\n                    };\n                } else if (lastHeartBeat.status === PENDING) {\n                    result[monitorID] = {\n                        text: this.$t(\"Pending\"),\n                        color: \"warning\",\n                    };\n                } else if (lastHeartBeat.status === MAINTENANCE) {\n                    result[monitorID] = {\n                        text: this.$t(\"statusMaintenance\"),\n                        color: \"maintenance\",\n                    };\n                } else {\n                    result[monitorID] = unknown;\n                }\n            }\n\n            return result;\n        },\n\n        stats() {\n            let result = {\n                active: 0,\n                up: 0,\n                down: 0,\n                maintenance: 0,\n                pending: 0,\n                unknown: 0,\n                pause: 0,\n            };\n\n            for (let monitorID in this.$root.monitorList) {\n                let beat = this.$root.lastHeartbeatList[monitorID];\n                let monitor = this.$root.monitorList[monitorID];\n\n                if (monitor && ! monitor.active) {\n                    result.pause++;\n                } else if (beat) {\n                    result.active++;\n                    if (beat.status === UP) {\n                        result.up++;\n                    } else if (beat.status === DOWN) {\n                        result.down++;\n                    } else if (beat.status === PENDING) {\n                        result.pending++;\n                    } else if (beat.status === MAINTENANCE) {\n                        result.maintenance++;\n                    } else {\n                        result.unknown++;\n                    }\n                } else {\n                    result.unknown++;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         *  Frontend Version\n         *  It should be compiled to a static value while building the frontend.\n         *  Please see ./config/vite.config.js, it is defined via vite.js\n         * @returns {string}\n         */\n        frontendVersion() {\n            // eslint-disable-next-line no-undef\n            return FRONTEND_VERSION;\n        },\n\n        /**\n         * Are both frontend and backend in the same version?\n         * @returns {boolean}\n         */\n        isFrontendBackendVersionMatched() {\n            if (!this.info.version) {\n                return true;\n            }\n            return this.info.version === this.frontendVersion;\n        }\n    },\n\n    watch: {\n\n        // Update Badge\n        \"stats.down\"(to, from) {\n            if (to !== from) {\n                if (this.faviconUpdateDebounce != null) {\n                    clearTimeout(this.faviconUpdateDebounce);\n                }\n                this.faviconUpdateDebounce = setTimeout(() => {\n                    favicon.badge(to);\n                }, 1000);\n            }\n        },\n\n        // Reload the SPA if the server version is changed.\n        \"info.version\"(to, from) {\n            if (from && from !== to) {\n                window.location.reload();\n            }\n        },\n\n        remember() {\n            localStorage.remember = (this.remember) ? \"1\" : \"0\";\n        },\n\n        // Reconnect the socket io, if status-page to dashboard\n        \"$route.fullPath\"(newValue, oldValue) {\n\n            if (newValue) {\n                for (let page of noSocketIOPages) {\n                    if (newValue.match(page)) {\n                        return;\n                    }\n                }\n            }\n\n            this.initSocketIO();\n        },\n\n    },\n\n};\n", "<template>\n    <transition name=\"slide-fade\" appear>\n        <div>\n            <h1 class=\"mb-3\">{{ pageName }}</h1>\n            <form @submit.prevent=\"submit\">\n                <div class=\"shadow-box shadow-box-with-fixed-bottom-bar\">\n                    <div class=\"row\">\n                        <div class=\"col-md-6\">\n                            <h2 class=\"mb-2\">{{ $t(\"General\") }}</h2>\n\n                            <div class=\"my-3\">\n                                <label for=\"type\" class=\"form-label\">{{ $t(\"Monitor Type\") }}</label>\n                                <select id=\"type\" v-model=\"monitor.type\" class=\"form-select\">\n                                    <optgroup :label=\"$t('General Monitor Type')\">\n                                        <option value=\"group\">\n                                            {{ $t(\"Group\") }}\n                                        </option>\n                                        <option value=\"http\">\n                                            HTTP(s)\n                                        </option>\n                                        <option value=\"port\">\n                                            TCP Port\n                                        </option>\n                                        <option value=\"ping\">\n                                            Ping\n                                        </option>\n                                        <option value=\"keyword\">\n                                            HTTP(s) - {{ $t(\"Keyword\") }}\n                                        </option>\n                                        <option value=\"json-query\">\n                                            HTTP(s) - {{ $t(\"Json Query\") }}\n                                        </option>\n                                        <option value=\"grpc-keyword\">\n                                            gRPC(s) - {{ $t(\"Keyword\") }}\n                                        </option>\n                                        <option value=\"dns\">\n                                            DNS\n                                        </option>\n                                        <option value=\"docker\">\n                                            {{ $t(\"Docker Container\") }}\n                                        </option>\n\n                                        <option value=\"real-browser\">\n                                            HTTP(s) - Browser Engine (Chrome/Chromium) (Beta)\n                                        </option>\n                                    </optgroup>\n\n                                    <optgroup :label=\"$t('Passive Monitor Type')\">\n                                        <option value=\"push\">\n                                            Push\n                                        </option>\n                                    </optgroup>\n\n                                    <optgroup :label=\"$t('Specific Monitor Type')\">\n                                        <option value=\"steam\">\n                                            {{ $t(\"Steam Game Server\") }}\n                                        </option>\n                                        <option value=\"gamedig\">\n                                            GameDig\n                                        </option>\n                                        <option value=\"mqtt\">\n                                            MQTT\n                                        </option>\n                                        <option value=\"kafka-producer\">\n                                            Kafka Producer\n                                        </option>\n                                        <option value=\"sqlserver\">\n                                            Microsoft SQL Server\n                                        </option>\n                                        <option value=\"postgres\">\n                                            PostgreSQL\n                                        </option>\n                                        <option value=\"mysql\">\n                                            MySQL/MariaDB\n                                        </option>\n                                        <option value=\"mongodb\">\n                                            MongoDB\n                                        </option>\n                                        <option value=\"radius\">\n                                            Radius\n                                        </option>\n                                        <option value=\"redis\">\n                                            Redis\n                                        </option>\n                                        <option v-if=\"!$root.info.isContainer\" value=\"tailscale-ping\">\n                                            Tailscale Ping\n                                        </option>\n                                    </optgroup>\n                                </select>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'tailscale-ping'\" class=\"alert alert-warning\" role=\"alert\">\n                                {{ $t(\"tailscalePingWarning\") }}\n                            </div>\n\n                            <!-- Friendly Name -->\n                            <div class=\"my-3\">\n                                <label for=\"name\" class=\"form-label\">{{ $t(\"Friendly Name\") }}</label>\n                                <input id=\"name\" v-model=\"monitor.name\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- URL -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' || monitor.type === 'real-browser' \" class=\"my-3\">\n                                <label for=\"url\" class=\"form-label\">{{ $t(\"URL\") }}</label>\n                                <input id=\"url\" v-model=\"monitor.url\" type=\"url\" class=\"form-control\" pattern=\"https?://.+\" required>\n                            </div>\n\n                            <!-- gRPC URL -->\n                            <div v-if=\"monitor.type === 'grpc-keyword' \" class=\"my-3\">\n                                <label for=\"grpc-url\" class=\"form-label\">{{ $t(\"URL\") }}</label>\n                                <input id=\"grpc-url\" v-model=\"monitor.grpcUrl\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Push URL -->\n                            <div v-if=\"monitor.type === 'push' \" class=\"my-3\">\n                                <label for=\"push-url\" class=\"form-label\">{{ $t(\"PushUrl\") }}</label>\n                                <CopyableInput id=\"push-url\" v-model=\"pushURL\" type=\"url\" disabled=\"disabled\" />\n                                <div class=\"form-text\">\n                                    {{ $t(\"needPushEvery\", [monitor.interval]) }}<br />\n                                    {{ $t(\"pushOptionalParams\", [\"status, msg, ping\"]) }}\n                                </div>\n                            </div>\n\n                            <!-- Keyword -->\n                            <div v-if=\"monitor.type === 'keyword' || monitor.type === 'grpc-keyword'\" class=\"my-3\">\n                                <label for=\"keyword\" class=\"form-label\">{{ $t(\"Keyword\") }}</label>\n                                <input id=\"keyword\" v-model=\"monitor.keyword\" type=\"text\" class=\"form-control\" required>\n                                <div class=\"form-text\">\n                                    {{ $t(\"keywordDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Invert keyword -->\n                            <div v-if=\"monitor.type === 'keyword' || monitor.type === 'grpc-keyword'\" class=\"my-3 form-check\">\n                                <input id=\"invert-keyword\" v-model=\"monitor.invertKeyword\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"invert-keyword\">\n                                    {{ $t(\"Invert Keyword\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"invertKeywordDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Json Query -->\n                            <div v-if=\"monitor.type === 'json-query'\" class=\"my-3\">\n                                <label for=\"jsonPath\" class=\"form-label\">{{ $t(\"Json Query\") }}</label>\n                                <input id=\"jsonPath\" v-model=\"monitor.jsonPath\" type=\"text\" class=\"form-control\" required>\n\n                                <!-- eslint-disable-next-line vue/no-v-html -->\n                                <div class=\"form-text\" v-html=\"$t('jsonQueryDescription')\">\n                                </div>\n                                <br>\n\n                                <label for=\"expectedValue\" class=\"form-label\">{{ $t(\"Expected Value\") }}</label>\n                                <input id=\"expectedValue\" v-model=\"monitor.expectedValue\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Game -->\n                            <!-- GameDig only -->\n                            <div v-if=\"monitor.type === 'gamedig'\" class=\"my-3\">\n                                <label for=\"game\" class=\"form-label\"> {{ $t(\"Game\") }} </label>\n                                <select id=\"game\" v-model=\"monitor.game\" class=\"form-select\" required>\n                                    <option v-for=\"game in gameList\" :key=\"game.keys[0]\" :value=\"game.keys[0]\">\n                                        {{ game.pretty }}\n                                    </option>\n                                </select>\n                            </div>\n\n                            <template v-if=\"monitor.type === 'kafka-producer'\">\n                                <!-- Kafka Brokers List -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerBrokers\" class=\"form-label\">{{ $t(\"Kafka Brokers\") }}</label>\n                                    <VueMultiselect\n                                        id=\"kafkaProducerBrokers\"\n                                        v-model=\"monitor.kafkaProducerBrokers\"\n                                        :multiple=\"true\"\n                                        :options=\"[]\"\n                                        :placeholder=\"$t('Enter the list of brokers')\"\n                                        :tag-placeholder=\"$t('Press Enter to add broker')\"\n                                        :max-height=\"500\"\n                                        :taggable=\"true\"\n                                        :show-no-options=\"false\"\n                                        :close-on-select=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :preselect-first=\"false\"\n                                        @tag=\"addKafkaProducerBroker\"\n                                    ></VueMultiselect>\n                                </div>\n\n                                <!-- Kafka Topic Name -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerTopic\" class=\"form-label\">{{ $t(\"Kafka Topic Name\") }}</label>\n                                    <input id=\"kafkaProducerTopic\" v-model=\"monitor.kafkaProducerTopic\" type=\"text\" class=\"form-control\" required>\n                                </div>\n\n                                <!-- Kafka Producer Message -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerMessage\" class=\"form-label\">{{ $t(\"Kafka Producer Message\") }}</label>\n                                    <input id=\"kafkaProducerMessage\" v-model=\"monitor.kafkaProducerMessage\" type=\"text\" class=\"form-control\" required>\n                                </div>\n\n                                <!-- Kafka SSL -->\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"kafkaProducerSsl\" v-model=\"monitor.kafkaProducerSsl\" class=\"form-check-input\" type=\"checkbox\">\n                                    <label class=\"form-check-label\" for=\"kafkaProducerSsl\">\n                                        {{ $t(\"Enable Kafka SSL\") }}\n                                    </label>\n                                </div>\n\n                                <!-- Kafka SSL -->\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"kafkaProducerAllowAutoTopicCreation\" v-model=\"monitor.kafkaProducerAllowAutoTopicCreation\" class=\"form-check-input\" type=\"checkbox\">\n                                    <label class=\"form-check-label\" for=\"kafkaProducerAllowAutoTopicCreation\">\n                                        {{ $t(\"Enable Kafka Producer Auto Topic Creation\") }}\n                                    </label>\n                                </div>\n                            </template>\n\n                            <!-- Hostname -->\n                            <!-- TCP Port / Ping / DNS / Steam / MQTT / Radius / Tailscale Ping only -->\n                            <div v-if=\"monitor.type === 'port' || monitor.type === 'ping' || monitor.type === 'dns' || monitor.type === 'steam' || monitor.type === 'gamedig' ||monitor.type === 'mqtt' || monitor.type === 'radius' || monitor.type === 'tailscale-ping'\" class=\"my-3\">\n                                <label for=\"hostname\" class=\"form-label\">{{ $t(\"Hostname\") }}</label>\n                                <input id=\"hostname\" v-model=\"monitor.hostname\" type=\"text\" class=\"form-control\" :pattern=\"`${monitor.type === 'mqtt' ? mqttIpOrHostnameRegexPattern : ipOrHostnameRegexPattern}`\" required>\n                            </div>\n\n                            <!-- Port -->\n                            <!-- For TCP Port / Steam / MQTT / Radius Type -->\n                            <div v-if=\"monitor.type === 'port' || monitor.type === 'steam' || monitor.type === 'gamedig' || monitor.type === 'mqtt' || monitor.type === 'radius'\" class=\"my-3\">\n                                <label for=\"port\" class=\"form-label\">{{ $t(\"Port\") }}</label>\n                                <input id=\"port\" v-model=\"monitor.port\" type=\"number\" class=\"form-control\" required min=\"0\" max=\"65535\" step=\"1\">\n                            </div>\n\n                            <!-- DNS Resolver Server -->\n                            <!-- For DNS Type -->\n                            <template v-if=\"monitor.type === 'dns'\">\n                                <div class=\"my-3\">\n                                    <label for=\"dns_resolve_server\" class=\"form-label\">{{ $t(\"Resolver Server\") }}</label>\n                                    <input id=\"dns_resolve_server\" v-model=\"monitor.dns_resolve_server\" type=\"text\" class=\"form-control\" :pattern=\"ipRegex\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"resolverserverDescription\") }}\n                                    </div>\n                                </div>\n\n                                <!-- Port -->\n                                <div class=\"my-3\">\n                                    <label for=\"port\" class=\"form-label\">{{ $t(\"Port\") }}</label>\n                                    <input id=\"port\" v-model=\"monitor.port\" type=\"number\" class=\"form-control\" required min=\"0\" max=\"65535\" step=\"1\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"dnsPortDescription\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"dns_resolve_type\" class=\"form-label\">{{ $t(\"Resource Record Type\") }}</label>\n\n                                    <!-- :allow-empty=\"false\" is not working, set a default value instead https://github.com/shentao/vue-multiselect/issues/336   -->\n                                    <VueMultiselect\n                                        id=\"dns_resolve_type\"\n                                        v-model=\"monitor.dns_resolve_type\"\n                                        :options=\"dnsresolvetypeOptions\"\n                                        :multiple=\"false\"\n                                        :close-on-select=\"true\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :placeholder=\"$t('Pick a RR-Type...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"500\"\n                                        :taggable=\"false\"\n                                    ></VueMultiselect>\n\n                                    <div class=\"form-text\">\n                                        {{ $t(\"rrtypeDescription\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- Docker Container Name / ID -->\n                            <!-- For Docker Type -->\n                            <div v-if=\"monitor.type === 'docker'\" class=\"my-3\">\n                                <label for=\"docker_container\" class=\"form-label\">{{ $t(\"Container Name / ID\") }}</label>\n                                <input id=\"docker_container\" v-model=\"monitor.docker_container\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Docker Host -->\n                            <!-- For Docker Type -->\n                            <div v-if=\"monitor.type === 'docker'\" class=\"my-3\">\n                                <div class=\"mb-3\">\n                                    <label for=\"docker-host\" class=\"form-label\">{{ $t(\"Docker Host\") }}</label>\n                                    <ActionSelect\n                                        id=\"docker-host\"\n                                        v-model=\"monitor.docker_host\"\n                                        :action-aria-label=\"$t('openModalTo', $t('Setup Docker Host'))\"\n                                        :options=\"dockerHostOptionsList\"\n                                        :disabled=\"$root.dockerHostList == null || $root.dockerHostList.length === 0\"\n                                        :icon=\"'plus'\"\n                                        :action=\"() => $refs.dockerHostDialog.show()\"\n                                        :required=\"true\"\n                                    />\n                                </div>\n                            </div>\n\n                            <!-- MQTT -->\n                            <!-- For MQTT Type -->\n                            <template v-if=\"monitor.type === 'mqtt'\">\n                                <div class=\"my-3\">\n                                    <label for=\"mqttUsername\" class=\"form-label\">MQTT {{ $t(\"Username\") }}</label>\n                                    <input id=\"mqttUsername\" v-model=\"monitor.mqttUsername\" type=\"text\" class=\"form-control\">\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttPassword\" class=\"form-label\">MQTT {{ $t(\"Password\") }}</label>\n                                    <input id=\"mqttPassword\" v-model=\"monitor.mqttPassword\" type=\"password\" class=\"form-control\">\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttTopic\" class=\"form-label\">MQTT {{ $t(\"Topic\") }}</label>\n                                    <input id=\"mqttTopic\" v-model=\"monitor.mqttTopic\" type=\"text\" class=\"form-control\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"topicExplanation\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttSuccessMessage\" class=\"form-label\">MQTT {{ $t(\"successMessage\") }}</label>\n                                    <input id=\"mqttSuccessMessage\" v-model=\"monitor.mqttSuccessMessage\" type=\"text\" class=\"form-control\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"successMessageExplanation\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <template v-if=\"monitor.type === 'radius'\">\n                                <div class=\"my-3\">\n                                    <label for=\"radius_username\" class=\"form-label\">Radius {{ $t(\"Username\") }}</label>\n                                    <input id=\"radius_username\" v-model=\"monitor.radiusUsername\" type=\"text\" class=\"form-control\" required />\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_password\" class=\"form-label\">Radius {{ $t(\"Password\") }}</label>\n                                    <input id=\"radius_password\" v-model=\"monitor.radiusPassword\" type=\"password\" class=\"form-control\" required />\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_secret\" class=\"form-label\">{{ $t(\"RadiusSecret\") }}</label>\n                                    <input id=\"radius_secret\" v-model=\"monitor.radiusSecret\" type=\"password\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusSecretDescription\") }} </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_called_station_id\" class=\"form-label\">{{ $t(\"RadiusCalledStationId\") }}</label>\n                                    <input id=\"radius_called_station_id\" v-model=\"monitor.radiusCalledStationId\" type=\"text\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusCalledStationIdDescription\") }} </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_calling_station_id\" class=\"form-label\">{{ $t(\"RadiusCallingStationId\") }}</label>\n                                    <input id=\"radius_calling_station_id\" v-model=\"monitor.radiusCallingStationId\" type=\"text\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusCallingStationIdDescription\") }} </div>\n                                </div>\n                            </template>\n\n                            <!-- SQL Server / PostgreSQL / MySQL / Redis / MongoDB -->\n                            <template v-if=\"monitor.type === 'sqlserver' || monitor.type === 'postgres' || monitor.type === 'mysql' || monitor.type === 'redis' || monitor.type === 'mongodb'\">\n                                <div class=\"my-3\">\n                                    <label for=\"connectionString\" class=\"form-label\">{{ $t(\"Connection String\") }}</label>\n                                    <input id=\"connectionString\" v-model=\"monitor.databaseConnectionString\" type=\"text\" class=\"form-control\" required>\n                                </div>\n                            </template>\n\n                            <template v-if=\"monitor.type === 'mysql'\">\n                                <div class=\"my-3\">\n                                    <label for=\"mysql-password\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                    <!-- TODO: Rename monitor.radiusPassword to monitor.password for general use -->\n                                    <HiddenInput id=\"mysql-password\" v-model=\"monitor.radiusPassword\" autocomplete=\"false\"></HiddenInput>\n                                </div>\n                            </template>\n\n                            <!-- SQL Server / PostgreSQL / MySQL -->\n                            <template v-if=\"monitor.type === 'sqlserver' || monitor.type === 'postgres' || monitor.type === 'mysql'\">\n                                <div class=\"my-3\">\n                                    <label for=\"sqlQuery\" class=\"form-label\">{{ $t(\"Query\") }}</label>\n                                    <textarea id=\"sqlQuery\" v-model=\"monitor.databaseQuery\" class=\"form-control\" :placeholder=\"$t('Example:', [ 'SELECT 1' ])\"></textarea>\n                                </div>\n                            </template>\n\n                            <!-- Interval -->\n                            <div class=\"my-3\">\n                                <label for=\"interval\" class=\"form-label\">{{ $t(\"Heartbeat Interval\") }} ({{ $t(\"checkEverySecond\", [ monitor.interval ]) }})</label>\n                                <input id=\"interval\" v-model=\"monitor.interval\" type=\"number\" class=\"form-control\" required :min=\"minInterval\" step=\"1\" :max=\"maxInterval\" @blur=\"finishUpdateInterval\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"maxRetries\" class=\"form-label\">{{ $t(\"Retries\") }}</label>\n                                <input id=\"maxRetries\" v-model=\"monitor.maxretries\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                                <div class=\"form-text\">\n                                    {{ $t(\"retriesDescription\") }}\n                                </div>\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"retry-interval\" class=\"form-label\">\n                                    {{ $t(\"Heartbeat Retry Interval\") }}\n                                    <span>({{ $t(\"retryCheckEverySecond\", [ monitor.retryInterval ]) }})</span>\n                                </label>\n                                <input id=\"retry-interval\" v-model=\"monitor.retryInterval\" type=\"number\" class=\"form-control\" required :min=\"minInterval\" step=\"1\">\n                            </div>\n\n                            <!-- Timeout: HTTP / Keyword only -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query'\" class=\"my-3\">\n                                <label for=\"timeout\" class=\"form-label\">{{ $t(\"Request Timeout\") }} ({{ $t(\"timeoutAfter\", [ monitor.timeout || clampTimeout(monitor.interval) ]) }})</label>\n                                <input id=\"timeout\" v-model=\"monitor.timeout\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"0.1\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"resend-interval\" class=\"form-label\">\n                                    {{ $t(\"Resend Notification if Down X times consecutively\") }}\n                                    <span v-if=\"monitor.resendInterval > 0\">({{ $t(\"resendEveryXTimes\", [ monitor.resendInterval ]) }})</span>\n                                    <span v-else>({{ $t(\"resendDisabled\") }})</span>\n                                </label>\n                                <input id=\"resend-interval\" v-model=\"monitor.resendInterval\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                            </div>\n\n                            <h2 v-if=\"monitor.type !== 'push'\" class=\"mt-5 mb-2\">{{ $t(\"Advanced\") }}</h2>\n\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \" class=\"my-3 form-check\">\n                                <input id=\"expiry-notification\" v-model=\"monitor.expiryNotification\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"expiry-notification\">\n                                    {{ $t(\"Certificate Expiry Notification\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                </div>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \" class=\"my-3 form-check\">\n                                <input id=\"ignore-tls\" v-model=\"monitor.ignoreTls\" class=\"form-check-input\" type=\"checkbox\" value=\"\">\n                                <label class=\"form-check-label\" for=\"ignore-tls\">\n                                    {{ $t(\"ignoreTLSError\") }}\n                                </label>\n                            </div>\n\n                            <div class=\"my-3 form-check\">\n                                <input id=\"upside-down\" v-model=\"monitor.upsideDown\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"upside-down\">\n                                    {{ $t(\"Upside Down Mode\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"upsideDownModeDescription\") }}\n                                </div>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'gamedig'\" class=\"my-3 form-check\">\n                                <input id=\"gamedig-guess-port\" v-model=\"monitor.gamedigGivenPortOnly\" :true-value=\"false\" :false-value=\"true\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"gamedig-guess-port\">\n                                    {{ $t(\"gamedigGuessPort\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"gamedigGuessPortDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Ping packet size -->\n                            <div v-if=\"monitor.type === 'ping'\" class=\"my-3\">\n                                <label for=\"packet-size\" class=\"form-label\">{{ $t(\"Packet Size\") }}</label>\n                                <input id=\"packet-size\" v-model=\"monitor.packetSize\" type=\"number\" class=\"form-control\" required min=\"1\" max=\"65500\" step=\"1\">\n                            </div>\n\n                            <!-- HTTP / Keyword only -->\n                            <template v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' || monitor.type === 'grpc-keyword' \">\n                                <div class=\"my-3\">\n                                    <label for=\"maxRedirects\" class=\"form-label\">{{ $t(\"Max. Redirects\") }}</label>\n                                    <input id=\"maxRedirects\" v-model=\"monitor.maxredirects\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"maxRedirectDescription\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"acceptedStatusCodes\" class=\"form-label\">{{ $t(\"Accepted Status Codes\") }}</label>\n\n                                    <VueMultiselect\n                                        id=\"acceptedStatusCodes\"\n                                        v-model=\"monitor.accepted_statuscodes\"\n                                        :options=\"acceptedStatusCodeOptions\"\n                                        :multiple=\"true\"\n                                        :close-on-select=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"true\"\n                                        :placeholder=\"$t('Pick Accepted Status Codes...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"600\"\n                                        :taggable=\"true\"\n                                    ></VueMultiselect>\n\n                                    <div class=\"form-text\">\n                                        {{ $t(\"acceptedStatusCodesDescription\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- Parent Monitor -->\n                            <div class=\"my-3\">\n                                <label for=\"monitorGroupSelector\" class=\"form-label\">{{ $t(\"Monitor Group\") }}</label>\n                                <ActionSelect\n                                    id=\"monitorGroupSelector\"\n                                    v-model=\"monitor.parent\"\n                                    :action-aria-label=\"$t('openModalTo', 'setup a new monitor group')\"\n                                    :options=\"parentMonitorOptionsList\"\n                                    :disabled=\"sortedGroupMonitorList.length === 0 && draftGroupName == null\"\n                                    :icon=\"'plus'\"\n                                    :action=\"() => $refs.createGroupDialog.show()\"\n                                />\n                            </div>\n\n                            <!-- Description -->\n                            <div class=\"my-3\">\n                                <label for=\"description\" class=\"form-label\">{{ $t(\"Description\") }}</label>\n                                <input id=\"description\" v-model=\"monitor.description\" type=\"text\" class=\"form-control\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <tags-manager ref=\"tagsManager\" :pre-selected-tags=\"monitor.tags\"></tags-manager>\n                            </div>\n                        </div>\n\n                        <div class=\"col-md-6\">\n                            <div v-if=\"$root.isMobile\" class=\"mt-3\" />\n\n                            <!-- Notifications -->\n                            <h2 class=\"mb-2\">{{ $t(\"Notifications\") }}</h2>\n                            <p v-if=\"$root.notificationList.length === 0\">\n                                {{ $t(\"Not available, please setup.\") }}\n                            </p>\n\n                            <div v-for=\"notification in $root.notificationList\" :key=\"notification.id\" class=\"form-check form-switch my-3\">\n                                <input :id=\" 'notification' + notification.id\" v-model=\"monitor.notificationIDList[notification.id]\" class=\"form-check-input\" type=\"checkbox\">\n\n                                <label class=\"form-check-label\" :for=\" 'notification' + notification.id\">\n                                    {{ notification.name }}\n                                    <a href=\"#\" @click=\"$refs.notificationDialog.show(notification.id)\">{{ $t(\"Edit\") }}</a>\n                                </label>\n\n                                <span v-if=\"notification.isDefault == true\" class=\"badge bg-primary ms-2\">{{ $t(\"Default\") }}</span>\n                            </div>\n\n                            <button class=\"btn btn-primary me-2\" type=\"button\" @click=\"$refs.notificationDialog.show()\">\n                                {{ $t(\"Setup Notification\") }}\n                            </button>\n\n                            <!-- Proxies -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query'\">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"Proxy\") }}</h2>\n                                <p v-if=\"$root.proxyList.length === 0\">\n                                    {{ $t(\"Not available, please setup.\") }}\n                                </p>\n\n                                <div v-if=\"$root.proxyList.length > 0\" class=\"form-check my-3\">\n                                    <input id=\"proxy-disable\" v-model=\"monitor.proxyId\" :value=\"null\" name=\"proxy\" class=\"form-check-input\" type=\"radio\">\n                                    <label class=\"form-check-label\" for=\"proxy-disable\">{{ $t(\"No Proxy\") }}</label>\n                                </div>\n\n                                <div v-for=\"proxy in $root.proxyList\" :key=\"proxy.id\" class=\"form-check my-3\">\n                                    <input :id=\"`proxy-${proxy.id}`\" v-model=\"monitor.proxyId\" :value=\"proxy.id\" name=\"proxy\" class=\"form-check-input\" type=\"radio\">\n\n                                    <label class=\"form-check-label\" :for=\"`proxy-${proxy.id}`\">\n                                        {{ proxy.host }}:{{ proxy.port }} ({{ proxy.protocol }})\n                                        <a href=\"#\" @click=\"$refs.proxyDialog.show(proxy.id)\">{{ $t(\"Edit\") }}</a>\n                                    </label>\n\n                                    <span v-if=\"proxy.default === true\" class=\"badge bg-primary ms-2\">{{ $t(\"default\") }}</span>\n                                </div>\n\n                                <button class=\"btn btn-primary me-2\" type=\"button\" @click=\"$refs.proxyDialog.show()\">\n                                    {{ $t(\"Setup Proxy\") }}\n                                </button>\n                            </div>\n\n                            <!-- Kafka SASL Options -->\n                            <!-- Kafka Producer only -->\n                            <template v-if=\"monitor.type === 'kafka-producer'\">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"Kafka SASL Options\") }}</h2>\n                                <div class=\"my-3\">\n                                    <label class=\"form-label\" for=\"kafkaProducerSaslMechanism\">\n                                        {{ $t(\"Mechanism\") }}\n                                    </label>\n                                    <VueMultiselect\n                                        id=\"kafkaProducerSaslMechanism\"\n                                        v-model=\"monitor.kafkaProducerSaslOptions.mechanism\"\n                                        :options=\"kafkaSaslMechanismOptions\"\n                                        :multiple=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :placeholder=\"$t('Pick a SASL Mechanism...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"500\"\n                                        :allow-empty=\"false\"\n                                        :taggable=\"false\"\n                                    ></VueMultiselect>\n                                </div>\n                                <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'None'\">\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslUsername\" class=\"form-label\">{{ $t(\"Username\") }}</label>\n                                        <input id=\"kafkaProducerSaslUsername\" v-model=\"monitor.kafkaProducerSaslOptions.username\" type=\"text\" autocomplete=\"kafkaProducerSaslUsername\" class=\"form-control\">\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslPassword\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                        <input id=\"kafkaProducerSaslPassword\" v-model=\"monitor.kafkaProducerSaslOptions.password\" type=\"password\" autocomplete=\"kafkaProducerSaslPassword\" class=\"form-control\">\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslAuthorizationIdentity\" class=\"form-label\">{{ $t(\"Authorization Identity\") }}</label>\n                                        <input id=\"kafkaProducerSaslAuthorizationIdentity\" v-model=\"monitor.kafkaProducerSaslOptions.authorizationIdentity\" type=\"text\" autocomplete=\"kafkaProducerSaslAuthorizationIdentity\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslAccessKeyId\" class=\"form-label\">{{ $t(\"AccessKey Id\") }}</label>\n                                        <input id=\"kafkaProducerSaslAccessKeyId\" v-model=\"monitor.kafkaProducerSaslOptions.accessKeyId\" type=\"text\" autocomplete=\"kafkaProducerSaslAccessKeyId\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslSecretAccessKey\" class=\"form-label\">{{ $t(\"Secret AccessKey\") }}</label>\n                                        <input id=\"kafkaProducerSaslSecretAccessKey\" v-model=\"monitor.kafkaProducerSaslOptions.secretAccessKey\" type=\"password\" autocomplete=\"kafkaProducerSaslSecretAccessKey\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslSessionToken\" class=\"form-label\">{{ $t(\"Session Token\") }}</label>\n                                        <input id=\"kafkaProducerSaslSessionToken\" v-model=\"monitor.kafkaProducerSaslOptions.sessionToken\" type=\"password\" autocomplete=\"kafkaProducerSaslSessionToken\" class=\"form-control\">\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- HTTP Options -->\n                            <template v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"HTTP Options\") }}</h2>\n\n                                <!-- Method -->\n                                <div class=\"my-3\">\n                                    <label for=\"method\" class=\"form-label\">{{ $t(\"Method\") }}</label>\n                                    <select id=\"method\" v-model=\"monitor.method\" class=\"form-select\">\n                                        <option value=\"GET\">\n                                            GET\n                                        </option>\n                                        <option value=\"POST\">\n                                            POST\n                                        </option>\n                                        <option value=\"PUT\">\n                                            PUT\n                                        </option>\n                                        <option value=\"PATCH\">\n                                            PATCH\n                                        </option>\n                                        <option value=\"DELETE\">\n                                            DELETE\n                                        </option>\n                                        <option value=\"HEAD\">\n                                            HEAD\n                                        </option>\n                                        <option value=\"OPTIONS\">\n                                            OPTIONS\n                                        </option>\n                                    </select>\n                                </div>\n\n                                <!-- Encoding -->\n                                <div class=\"my-3\">\n                                    <label for=\"httpBodyEncoding\" class=\"form-label\">{{ $t(\"Body Encoding\") }}</label>\n                                    <select id=\"httpBodyEncoding\" v-model=\"monitor.httpBodyEncoding\" class=\"form-select\">\n                                        <option value=\"json\">JSON</option>\n                                        <option value=\"xml\">XML</option>\n                                    </select>\n                                </div>\n\n                                <!-- Body -->\n                                <div class=\"my-3\">\n                                    <label for=\"body\" class=\"form-label\">{{ $t(\"Body\") }}</label>\n                                    <textarea id=\"body\" v-model=\"monitor.body\" class=\"form-control\" :placeholder=\"bodyPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Headers -->\n                                <div class=\"my-3\">\n                                    <label for=\"headers\" class=\"form-label\">{{ $t(\"Headers\") }}</label>\n                                    <textarea id=\"headers\" v-model=\"monitor.headers\" class=\"form-control\" :placeholder=\"headersPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- HTTP Auth -->\n                                <h4 class=\"mt-5 mb-2\">{{ $t(\"Authentication\") }}</h4>\n\n                                <!-- Method -->\n                                <div class=\"my-3\">\n                                    <label for=\"method\" class=\"form-label\">{{ $t(\"Method\") }}</label>\n                                    <select id=\"method\" v-model=\"monitor.authMethod\" class=\"form-select\">\n                                        <option :value=\"null\">\n                                            {{ $t(\"None\") }}\n                                        </option>\n                                        <option value=\"basic\">\n                                            {{ $t(\"HTTP Basic Auth\") }}\n                                        </option>\n                                        <option value=\"oauth2-cc\">\n                                            {{ $t(\"OAuth2: Client Credentials\") }}\n                                        </option>\n                                        <option value=\"ntlm\">\n                                            NTLM\n                                        </option>\n                                        <option value=\"mtls\">\n                                            mTLS\n                                        </option>\n                                    </select>\n                                </div>\n                                <template v-if=\"monitor.authMethod && monitor.authMethod !== null \">\n                                    <template v-if=\"monitor.authMethod === 'mtls' \">\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-cert\" class=\"form-label\">{{ $t(\"Cert\") }}</label>\n                                            <textarea id=\"tls-cert\" v-model=\"monitor.tlsCert\" class=\"form-control\" :placeholder=\"$t('Cert body')\" required></textarea>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-key\" class=\"form-label\">{{ $t(\"Key\") }}</label>\n                                            <textarea id=\"tls-key\" v-model=\"monitor.tlsKey\" class=\"form-control\" :placeholder=\"$t('Key body')\" required></textarea>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-ca\" class=\"form-label\">{{ $t(\"CA\") }}</label>\n                                            <textarea id=\"tls-ca\" v-model=\"monitor.tlsCa\" class=\"form-control\" :placeholder=\"$t('Server CA')\"></textarea>\n                                        </div>\n                                    </template>\n                                    <template v-else-if=\"monitor.authMethod === 'oauth2-cc' \">\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_auth_method\" class=\"form-label\">{{ $t(\"Authentication Method\") }}</label>\n                                            <select id=\"oauth_auth_method\" v-model=\"monitor.oauth_auth_method\" class=\"form-select\">\n                                                <option value=\"client_secret_basic\">\n                                                    {{ $t(\"Authorization Header\") }}\n                                                </option>\n                                                <option value=\"client_secret_post\">\n                                                    {{ $t(\"Form Data Body\") }}\n                                                </option>\n                                            </select>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_token_url\" class=\"form-label\">{{ $t(\"OAuth Token URL\") }}</label>\n                                            <input id=\"oauth_token_url\" v-model=\"monitor.oauth_token_url\" type=\"text\" class=\"form-control\" :placeholder=\"$t('OAuth Token URL')\" required>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_client_id\" class=\"form-label\">{{ $t(\"Client ID\") }}</label>\n                                            <input id=\"oauth_client_id\" v-model=\"monitor.oauth_client_id\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Client ID')\" required>\n                                        </div>\n                                        <template v-if=\"monitor.oauth_auth_method === 'client_secret_post' || monitor.oauth_auth_method === 'client_secret_basic'\">\n                                            <div class=\"my-3\">\n                                                <label for=\"oauth_client_secret\" class=\"form-label\">{{ $t(\"Client Secret\") }}</label>\n                                                <input id=\"oauth_client_secret\" v-model=\"monitor.oauth_client_secret\" type=\"password\" class=\"form-control\" :placeholder=\"$t('Client Secret')\" required>\n                                            </div>\n                                            <div class=\"my-3\">\n                                                <label for=\"oauth_scopes\" class=\"form-label\">{{ $t(\"OAuth Scope\") }}</label>\n                                                <input id=\"oauth_scopes\" v-model=\"monitor.oauth_scopes\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Optional: Space separated list of scopes')\">\n                                            </div>\n                                        </template>\n                                    </template>\n                                    <template v-else>\n                                        <div class=\"my-3\">\n                                            <label for=\"basicauth-user\" class=\"form-label\">{{ $t(\"Username\") }}</label>\n                                            <input id=\"basicauth-user\" v-model=\"monitor.basic_auth_user\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Username')\">\n                                        </div>\n\n                                        <div class=\"my-3\">\n                                            <label for=\"basicauth-pass\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                            <input id=\"basicauth-pass\" v-model=\"monitor.basic_auth_pass\" type=\"password\" autocomplete=\"new-password\" class=\"form-control\" :placeholder=\"$t('Password')\">\n                                        </div>\n                                        <template v-if=\"monitor.authMethod === 'ntlm' \">\n                                            <div class=\"my-3\">\n                                                <label for=\"ntlm-domain\" class=\"form-label\">{{ $t(\"Domain\") }}</label>\n                                                <input id=\"ntlm-domain\" v-model=\"monitor.authDomain\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Domain')\">\n                                            </div>\n\n                                            <div class=\"my-3\">\n                                                <label for=\"ntlm-workstation\" class=\"form-label\">{{ $t(\"Workstation\") }}</label>\n                                                <input id=\"ntlm-workstation\" v-model=\"monitor.authWorkstation\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Workstation')\">\n                                            </div>\n                                        </template>\n                                    </template>\n                                </template>\n                            </template>\n\n                            <!-- gRPC Options -->\n                            <template v-if=\"monitor.type === 'grpc-keyword' \">\n                                <!-- Proto service enable TLS -->\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"GRPC Options\") }}</h2>\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"grpc-enable-tls\" v-model=\"monitor.grpcEnableTls\" class=\"form-check-input\" type=\"checkbox\" value=\"\">\n                                    <label class=\"form-check-label\" for=\"grpc-enable-tls\">\n                                        {{ $t(\"Enable TLS\") }}\n                                    </label>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"enableGRPCTls\") }}\n                                    </div>\n                                </div>\n                                <!-- Proto service name data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Service Name\") }}</label>\n                                    <input id=\"name\" v-model=\"monitor.grpcServiceName\" type=\"text\" class=\"form-control\" :placeholder=\"protoServicePlaceholder\" required>\n                                </div>\n\n                                <!-- Proto method data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Method\") }}</label>\n                                    <input id=\"name\" v-model=\"monitor.grpcMethod\" type=\"text\" class=\"form-control\" :placeholder=\"protoMethodPlaceholder\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"grpcMethodDescription\") }}\n                                    </div>\n                                </div>\n\n                                <!-- Proto data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Content\") }}</label>\n                                    <textarea id=\"protobuf\" v-model=\"monitor.grpcProtobuf\" class=\"form-control\" :placeholder=\"protoBufDataPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Body -->\n                                <div class=\"my-3\">\n                                    <label for=\"body\" class=\"form-label\">{{ $t(\"Body\") }}</label>\n                                    <textarea id=\"body\" v-model=\"monitor.grpcBody\" class=\"form-control\" :placeholder=\"bodyPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Metadata: temporary disable waiting for next PR allow to send gRPC with metadata -->\n                                <template v-if=\"false\">\n                                    <div class=\"my-3\">\n                                        <label for=\"metadata\" class=\"form-label\">{{ $t(\"Metadata\") }}</label>\n                                        <textarea id=\"metadata\" v-model=\"monitor.grpcMetadata\" class=\"form-control\" :placeholder=\"headersPlaceholder\"></textarea>\n                                    </div>\n                                </template>\n                            </template>\n                        </div>\n                    </div>\n\n                    <div class=\"fixed-bottom-bar p-3\">\n                        <button id=\"monitor-submit-btn\" class=\"btn btn-primary\" type=\"submit\" :disabled=\"processing\">{{ $t(\"Save\") }}</button>\n                    </div>\n                </div>\n            </form>\n\n            <NotificationDialog ref=\"notificationDialog\" @added=\"addedNotification\" />\n            <DockerHostDialog ref=\"dockerHostDialog\" @added=\"addedDockerHost\" />\n            <ProxyDialog ref=\"proxyDialog\" @added=\"addedProxy\" />\n            <CreateGroupDialog ref=\"createGroupDialog\" @added=\"addedDraftGroup\" />\n        </div>\n    </transition>\n</template>\n\n<script>\nimport VueMultiselect from \"vue-multiselect\";\nimport { useToast } from \"vue-toastification\";\nimport ActionSelect from \"../components/ActionSelect.vue\";\nimport CopyableInput from \"../components/CopyableInput.vue\";\nimport CreateGroupDialog from \"../components/CreateGroupDialog.vue\";\nimport NotificationDialog from \"../components/NotificationDialog.vue\";\nimport DockerHostDialog from \"../components/DockerHostDialog.vue\";\nimport ProxyDialog from \"../components/ProxyDialog.vue\";\nimport TagsManager from \"../components/TagsManager.vue\";\nimport { genSecret, isDev, MAX_INTERVAL_SECOND, MIN_INTERVAL_SECOND } from \"../util.ts\";\nimport { hostNameRegexPattern } from \"../util-frontend\";\nimport { sleep } from \"../util\";\nimport HiddenInput from \"../components/HiddenInput.vue\";\n\nconst toast = useToast();\n\nconst monitorDefaults = {\n    type: \"http\",\n    name: \"\",\n    parent: null,\n    url: \"https://\",\n    method: \"GET\",\n    interval: 60,\n    retryInterval: 60,\n    resendInterval: 0,\n    maxretries: 0,\n    timeout: 48,\n    notificationIDList: {},\n    ignoreTls: false,\n    upsideDown: false,\n    packetSize: 56,\n    expiryNotification: false,\n    maxredirects: 10,\n    accepted_statuscodes: [ \"200-299\" ],\n    dns_resolve_type: \"A\",\n    dns_resolve_server: \"1.1.1.1\",\n    docker_container: \"\",\n    docker_host: null,\n    proxyId: null,\n    mqttUsername: \"\",\n    mqttPassword: \"\",\n    mqttTopic: \"\",\n    mqttSuccessMessage: \"\",\n    authMethod: null,\n    oauth_auth_method: \"client_secret_basic\",\n    httpBodyEncoding: \"json\",\n    kafkaProducerBrokers: [],\n    kafkaProducerSaslOptions: {\n        mechanism: \"None\",\n    },\n    kafkaProducerSsl: false,\n    kafkaProducerAllowAutoTopicCreation: false,\n    gamedigGivenPortOnly: true,\n};\n\nexport default {\n    components: {\n        HiddenInput,\n        ActionSelect,\n        ProxyDialog,\n        CopyableInput,\n        CreateGroupDialog,\n        NotificationDialog,\n        DockerHostDialog,\n        TagsManager,\n        VueMultiselect,\n    },\n\n    data() {\n        return {\n            minInterval: MIN_INTERVAL_SECOND,\n            maxInterval: MAX_INTERVAL_SECOND,\n            processing: false,\n            monitor: {\n                notificationIDList: {},\n                // Do not add default value here, please check init() method\n            },\n            acceptedStatusCodeOptions: [],\n            dnsresolvetypeOptions: [],\n            kafkaSaslMechanismOptions: [],\n            ipOrHostnameRegexPattern: hostNameRegexPattern(),\n            mqttIpOrHostnameRegexPattern: hostNameRegexPattern(true),\n            gameList: null,\n            connectionStringTemplates: {\n                \"sqlserver\": \"Server=<hostname>,<port>;Database=<your database>;User Id=<your user id>;Password=<your password>;Encrypt=<true/false>;TrustServerCertificate=<Yes/No>;Connection Timeout=<int>\",\n                \"postgres\": \"postgres://username:password@host:port/database\",\n                \"mysql\": \"mysql://username:password@host:port/database\",\n                \"redis\": \"redis://user:password@host:port\",\n                \"mongodb\": \"mongodb://username:password@host:port/database\",\n            },\n            draftGroupName: null,\n        };\n    },\n\n    computed: {\n\n        ipRegex() {\n\n            // Allow to test with simple dns server with port (127.0.0.1:5300)\n            if (! isDev) {\n                return this.ipRegexPattern;\n            }\n            return null;\n        },\n\n        pageName() {\n            let name = \"Add New Monitor\";\n            if (this.isClone) {\n                name = \"Clone Monitor\";\n            } else if (this.isEdit) {\n                name = \"Edit\";\n            }\n            return this.$t(name);\n        },\n\n        isAdd() {\n            return this.$route.path === \"/add\";\n        },\n\n        isClone() {\n            return this.$route.path.startsWith(\"/clone\");\n        },\n\n        isEdit() {\n            return this.$route.path.startsWith(\"/edit\");\n        },\n\n        pushURL() {\n            return this.$root.baseURL + \"/api/push/\" + this.monitor.pushToken + \"?status=up&msg=OK&ping=\";\n        },\n\n        protoServicePlaceholder() {\n            return this.$t(\"Example:\", [ \"Health\" ]);\n        },\n\n        protoMethodPlaceholder() {\n            return this.$t(\"Example:\", [ \"check\" ]);\n        },\n\n        protoBufDataPlaceholder() {\n            return this.$t(\"Example:\", [ `\nsyntax = \"proto3\";\n\npackage grpc.health.v1;\n\nservice Health {\n  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);\n  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);\n}\n\nmessage HealthCheckRequest {\n  string service = 1;\n}\n\nmessage HealthCheckResponse {\n  enum ServingStatus {\n    UNKNOWN = 0;\n    SERVING = 1;\n    NOT_SERVING = 2;\n    SERVICE_UNKNOWN = 3;  // Used only by the Watch method.\n  }\n  ServingStatus status = 1;\n}\n            ` ]);\n        },\n        bodyPlaceholder() {\n            if (this.monitor && this.monitor.httpBodyEncoding && this.monitor.httpBodyEncoding === \"xml\") {\n                return this.$t(\"Example:\", [ `\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soap:Body>\n    <Uptime>Kuma</Uptime>\n  </soap:Body>\n</soap:Envelope>` ]);\n            }\n            return this.$t(\"Example:\", [ `\n{\n    \"key\": \"value\"\n}` ]);\n        },\n\n        headersPlaceholder() {\n            return this.$t(\"Example:\", [ `\n{\n    \"HeaderName\": \"HeaderValue\"\n}` ]);\n        },\n\n        currentGameObject() {\n            if (this.gameList) {\n                for (let game of this.gameList) {\n                    if (game.keys[0] === this.monitor.game) {\n                        return game;\n                    }\n                }\n            }\n            return null;\n        },\n\n        // Filter result by active state, weight and alphabetical\n        // Only return groups which arent't itself and one of its decendants\n        sortedGroupMonitorList() {\n            let result = Object.values(this.$root.monitorList);\n\n            // Only groups, not itself, not a decendant\n            result = result.filter(\n                monitor => monitor.type === \"group\" &&\n\t\t\t\tmonitor.id !== this.monitor.id &&\n\t\t\t\t!this.monitor.childrenIDs?.includes(monitor.id)\n            );\n\n            // Filter result by active state, weight and alphabetical\n            result.sort((m1, m2) => {\n\n                if (m1.active !== m2.active) {\n                    if (m1.active === 0) {\n                        return 1;\n                    }\n\n                    if (m2.active === 0) {\n                        return -1;\n                    }\n                }\n\n                if (m1.weight !== m2.weight) {\n                    if (m1.weight > m2.weight) {\n                        return -1;\n                    }\n\n                    if (m1.weight < m2.weight) {\n                        return 1;\n                    }\n                }\n\n                return m1.pathName.localeCompare(m2.pathName);\n            });\n\n            return result;\n        },\n\n        /**\n         * Generates the parent monitor options list based on the sorted group monitor list and draft group name.\n         *\n         * @return {Array} The parent monitor options list.\n         */\n        parentMonitorOptionsList() {\n            let list = [];\n            if (this.sortedGroupMonitorList.length === 0 && this.draftGroupName == null) {\n                list = [\n                    {\n                        label: this.$t(\"noGroupMonitorMsg\"),\n                        value: null\n                    }\n                ];\n            } else {\n                list = [\n                    {\n                        label: this.$t(\"None\"),\n                        value: null\n                    },\n                    ... this.sortedGroupMonitorList.map(monitor => {\n                        return {\n                            label: monitor.pathName,\n                            value: monitor.id,\n                        };\n                    }),\n                ];\n            }\n\n            if (this.draftGroupName != null) {\n                list = [{\n                    label: this.draftGroupName,\n                    value: -1,\n                }].concat(list);\n            }\n\n            return list;\n        },\n\n        dockerHostOptionsList() {\n            if (this.$root.dockerHostList && this.$root.dockerHostList.length > 0) {\n                return this.$root.dockerHostList.map((host) => {\n                    return {\n                        label: host.name,\n                        value: host.id\n                    };\n                });\n            } else {\n                return [{\n                    label: this.$t(\"noDockerHostMsg\"),\n                    value: null,\n                }];\n            }\n        }\n    },\n    watch: {\n        \"$root.proxyList\"() {\n            if (this.isAdd) {\n                if (this.$root.proxyList && !this.monitor.proxyId) {\n                    const proxy = this.$root.proxyList.find(proxy => proxy.default);\n\n                    if (proxy) {\n                        this.monitor.proxyId = proxy.id;\n                    }\n                }\n            }\n        },\n\n        \"$route.fullPath\"() {\n            this.init();\n        },\n\n        \"monitor.interval\"(value, oldValue) {\n            // Link interval and retryInterval if they are the same value.\n            if (this.monitor.retryInterval === oldValue) {\n                this.monitor.retryInterval = value;\n            }\n        },\n\n        \"monitor.timeout\"(value, oldValue) {\n            // keep timeout within 80% range\n            if (value && value !== oldValue) {\n                this.monitor.timeout = this.clampTimeout(value);\n            }\n        },\n\n        \"monitor.type\"() {\n            if (this.monitor.type === \"push\") {\n                if (! this.monitor.pushToken) {\n                    this.monitor.pushToken = genSecret(10);\n                }\n            }\n\n            // Set default port for DNS if not already defined\n            if (! this.monitor.port || this.monitor.port === \"53\" || this.monitor.port === \"1812\") {\n                if (this.monitor.type === \"dns\") {\n                    this.monitor.port = \"53\";\n                } else if (this.monitor.type === \"radius\") {\n                    this.monitor.port = \"1812\";\n                } else {\n                    this.monitor.port = undefined;\n                }\n            }\n\n            // Get the game list from server\n            if (this.monitor.type === \"gamedig\") {\n                this.$root.getSocket().emit(\"getGameList\", (res) => {\n                    if (res.ok) {\n                        this.gameList = res.gameList;\n                    } else {\n                        toast.error(res.msg);\n                    }\n                });\n            }\n\n            // Set default database connection string if empty or it is a template from another database monitor type\n            for (let monitorType in this.connectionStringTemplates) {\n                if (this.monitor.type === monitorType) {\n                    let isTemplate = false;\n                    for (let key in this.connectionStringTemplates) {\n                        if (this.monitor.databaseConnectionString === this.connectionStringTemplates[key]) {\n                            isTemplate = true;\n                            break;\n                        }\n                    }\n                    if (!this.monitor.databaseConnectionString || isTemplate) {\n                        this.monitor.databaseConnectionString = this.connectionStringTemplates[monitorType];\n                    }\n                    break;\n                }\n            }\n\n        },\n\n        currentGameObject(newGameObject, previousGameObject) {\n            if (!this.monitor.port || (previousGameObject && previousGameObject.options.port === this.monitor.port)) {\n                this.monitor.port = newGameObject.options.port;\n            }\n            this.monitor.game = newGameObject.keys[0];\n        },\n    },\n    mounted() {\n        this.init();\n\n        let acceptedStatusCodeOptions = [\n            \"100-199\",\n            \"200-299\",\n            \"300-399\",\n            \"400-499\",\n            \"500-599\",\n        ];\n\n        let dnsresolvetypeOptions = [\n            \"A\",\n            \"AAAA\",\n            \"CAA\",\n            \"CNAME\",\n            \"MX\",\n            \"NS\",\n            \"PTR\",\n            \"SOA\",\n            \"SRV\",\n            \"TXT\",\n        ];\n\n        let kafkaSaslMechanismOptions = [\n            \"None\",\n            \"plain\",\n            \"scram-sha-256\",\n            \"scram-sha-512\",\n            \"aws\",\n        ];\n\n        for (let i = 100; i <= 999; i++) {\n            acceptedStatusCodeOptions.push(i.toString());\n        }\n\n        this.acceptedStatusCodeOptions = acceptedStatusCodeOptions;\n        this.dnsresolvetypeOptions = dnsresolvetypeOptions;\n        this.kafkaSaslMechanismOptions = kafkaSaslMechanismOptions;\n    },\n    methods: {\n        /** Initialize the edit monitor form */\n        init() {\n            if (this.isAdd) {\n\n                this.monitor = {\n                    ...monitorDefaults\n                };\n\n                if (this.$root.proxyList && !this.monitor.proxyId) {\n                    const proxy = this.$root.proxyList.find(proxy => proxy.default);\n\n                    if (proxy) {\n                        this.monitor.proxyId = proxy.id;\n                    }\n                }\n\n                for (let i = 0; i < this.$root.notificationList.length; i++) {\n                    if (this.$root.notificationList[i].isDefault === true) {\n                        this.monitor.notificationIDList[this.$root.notificationList[i].id] = true;\n                    }\n                }\n            } else if (this.isEdit || this.isClone) {\n                this.$root.getSocket().emit(\"getMonitor\", this.$route.params.id, (res) => {\n                    if (res.ok) {\n\n                        if (this.isClone) {\n                            // Reset push token for cloned monitors\n                            if (res.monitor.type === \"push\") {\n                                res.monitor.pushToken = undefined;\n                            }\n                        }\n\n                        this.monitor = res.monitor;\n\n                        if (this.isClone) {\n                            /*\n                            * Cloning a monitor will include properties that can not be posted to backend\n                            * as they are not valid columns in the SQLite table.\n                            */\n                            this.monitor.id = undefined; // Remove id when cloning as we want a new id\n                            this.monitor.includeSensitiveData = undefined;\n                            this.monitor.maintenance = undefined;\n                            // group monitor fields\n                            this.monitor.childrenIDs = undefined;\n                            this.monitor.forceInactive = undefined;\n                            this.monitor.pathName = undefined;\n                            this.monitor.screenshot = undefined;\n\n                            this.monitor.name = this.$t(\"cloneOf\", [ this.monitor.name ]);\n                            this.$refs.tagsManager.newTags = this.monitor.tags.map((monitorTag) => {\n                                return {\n                                    id: monitorTag.tag_id,\n                                    name: monitorTag.name,\n                                    color: monitorTag.color,\n                                    value: monitorTag.value,\n                                    new: true,\n                                };\n                            });\n                            this.monitor.tags = undefined;\n                        }\n\n                        // Handling for monitors that are created before 1.7.0\n                        if (this.monitor.retryInterval === 0) {\n                            this.monitor.retryInterval = this.monitor.interval;\n                        }\n                        // Handling for monitors that are missing/zeroed timeout\n                        if (!this.monitor.timeout) {\n                            this.monitor.timeout = ~~(this.monitor.interval * 8) / 10;\n                        }\n                    } else {\n                        toast.error(res.msg);\n                    }\n                });\n            }\n\n            this.draftGroupName = null;\n\n        },\n\n        addKafkaProducerBroker(newBroker) {\n            this.monitor.kafkaProducerBrokers.push(newBroker);\n        },\n\n        /**\n         * Validate form input\n         * @returns {boolean} Is the form input valid?\n         */\n        isInputValid() {\n            if (this.monitor.body && (!this.monitor.httpBodyEncoding || this.monitor.httpBodyEncoding === \"json\")) {\n                try {\n                    JSON.parse(this.monitor.body);\n                } catch (err) {\n                    toast.error(this.$t(\"BodyInvalidFormat\") + err.message);\n                    return false;\n                }\n            }\n            if (this.monitor.headers) {\n                try {\n                    JSON.parse(this.monitor.headers);\n                } catch (err) {\n                    toast.error(this.$t(\"HeadersInvalidFormat\") + err.message);\n                    return false;\n                }\n            }\n            if (this.monitor.type === \"docker\") {\n                if (this.monitor.docker_host == null) {\n                    toast.error(this.$t(\"DockerHostRequired\"));\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Submit the form data for processing\n         * @returns {void}\n         */\n        async submit() {\n\n            this.processing = true;\n\n            if (!this.isInputValid()) {\n                this.processing = false;\n                return;\n            }\n\n            // Beautify the JSON format (only if httpBodyEncoding is not set or === json)\n            if (this.monitor.body && (!this.monitor.httpBodyEncoding || this.monitor.httpBodyEncoding === \"json\")) {\n                this.monitor.body = JSON.stringify(JSON.parse(this.monitor.body), null, 4);\n            }\n\n            const monitorTypesWithEncodingAllowed = [ \"http\", \"keyword\", \"json-query\" ];\n            if (this.monitor.type && !monitorTypesWithEncodingAllowed.includes(this.monitor.type)) {\n                this.monitor.httpBodyEncoding = null;\n            }\n\n            if (this.monitor.headers) {\n                this.monitor.headers = JSON.stringify(JSON.parse(this.monitor.headers), null, 4);\n            }\n\n            if (this.monitor.hostname) {\n                this.monitor.hostname = this.monitor.hostname.trim();\n            }\n\n            if (this.monitor.url) {\n                this.monitor.url = this.monitor.url.trim();\n            }\n\n            let createdNewParent = false;\n\n            if (this.draftGroupName && this.monitor.parent === -1) {\n                // Create Monitor with name of draft group\n                const res = await new Promise((resolve) => {\n                    this.$root.add({\n                        ...monitorDefaults,\n                        type: \"group\",\n                        name: this.draftGroupName,\n                        interval: this.monitor.interval,\n                        active: false,\n                    }, resolve);\n                });\n\n                if (res.ok) {\n                    createdNewParent = true;\n                    this.monitor.parent = res.monitorID;\n                } else {\n                    toast.error(res.msg);\n                    this.processing = false;\n                    return;\n                }\n            }\n\n            if (this.isAdd || this.isClone) {\n                this.$root.add(this.monitor, async (res) => {\n\n                    if (res.ok) {\n                        await this.$refs.tagsManager.submit(res.monitorID);\n\n                        // Start the new parent monitor after edit is done\n                        if (createdNewParent) {\n                            this.startParentGroupMonitor();\n                        }\n\n                        toast.success(res.msg);\n                        this.processing = false;\n                        this.$root.getMonitorList();\n                        this.$router.push(\"/dashboard/\" + res.monitorID);\n\n                    } else {\n                        toast.error(res.msg);\n                        this.processing = false;\n                    }\n\n                });\n            } else {\n                await this.$refs.tagsManager.submit(this.monitor.id);\n\n                this.$root.getSocket().emit(\"editMonitor\", this.monitor, (res) => {\n                    this.processing = false;\n                    this.$root.toastRes(res);\n                    this.init();\n\n                    // Start the new parent monitor after edit is done\n                    if (createdNewParent) {\n                        this.startParentGroupMonitor();\n                    }\n                });\n            }\n        },\n\n        async startParentGroupMonitor() {\n            await sleep(2000);\n            await this.$root.getSocket().emit(\"resumeMonitor\", this.monitor.parent, () => {});\n        },\n\n        /**\n         * Added a Notification Event\n         * Enable it if the notification is added in EditMonitor.vue\n         * @param {number} id ID of notification to add\n         */\n        addedNotification(id) {\n            this.monitor.notificationIDList[id] = true;\n        },\n\n        /**\n         * Added a Proxy Event\n         * Enable it if the proxy is added in EditMonitor.vue\n         * @param {number} id ID of proxy to add\n         */\n        addedProxy(id) {\n            this.monitor.proxyId = id;\n        },\n\n        // Added a Docker Host Event\n        // Enable it if the Docker Host is added in EditMonitor.vue\n        addedDockerHost(id) {\n            this.monitor.docker_host = id;\n        },\n\n        /**\n         * Adds a draft group.\n         *\n         * @param {string} draftGroupName - The name of the draft group.\n         */\n        addedDraftGroup(draftGroupName) {\n            this.draftGroupName = draftGroupName;\n            this.monitor.parent = -1;\n        },\n\n        // Clamp timeout\n        clampTimeout(timeout) {\n            // limit to 80% of interval, narrowly avoiding epsilon bug\n            const maxTimeout = ~~(this.monitor.interval * 8 ) / 10;\n            const clamped = Math.max(0, Math.min(timeout, maxTimeout));\n\n            // 0 will be treated as 80% of interval\n            return Number.isFinite(clamped) ? clamped : maxTimeout;\n        },\n\n        finishUpdateInterval() {\n            // Update timeout if it is greater than the clamp timeout\n            let clampedValue = this.clampTimeout(this.monitor.interval);\n            if (this.monitor.timeout > clampedValue) {\n                this.monitor.timeout = clampedValue;\n            }\n        },\n\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n    @import \"../assets/vars.scss\";\n\n    textarea {\n        min-height: 200px;\n    }\n</style>\n", "\"use strict\";\n// Common Util for frontend and backend\n//\n// DOT NOT MODIFY util.js!\n// Need to run \"tsc\" to compile if there are any changes.\n//\n// Backend uses the compiled file util.js\n// Frontend uses util.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.localToUTC = exports.utcToLocal = exports.utcToISODateTime = exports.isoToUTCDateTime = exports.parseTimeFromTimeObject = exports.parseTimeObject = exports.getMaintenanceRelativeURL = exports.getMonitorRelativeURL = exports.genSecret = exports.getCryptoRandomInt = exports.getRandomInt = exports.getRandomArbitrary = exports.TimeLogger = exports.polyfill = exports.log = exports.debug = exports.ucfirst = exports.sleep = exports.flipStatus = exports.MIN_INTERVAL_SECOND = exports.MAX_INTERVAL_SECOND = exports.SQL_DATETIME_FORMAT_WITHOUT_SECOND = exports.SQL_DATETIME_FORMAT = exports.SQL_DATE_FORMAT = exports.STATUS_PAGE_MAINTENANCE = exports.STATUS_PAGE_PARTIAL_DOWN = exports.STATUS_PAGE_ALL_UP = exports.STATUS_PAGE_ALL_DOWN = exports.MAINTENANCE = exports.PENDING = exports.UP = exports.DOWN = exports.appName = exports.isDev = void 0;\nconst dayjs = require(\"dayjs\");\nexports.isDev = process.env.NODE_ENV === \"development\";\nexports.appName = \"Uptime Kuma\";\nexports.DOWN = 0;\nexports.UP = 1;\nexports.PENDING = 2;\nexports.MAINTENANCE = 3;\nexports.STATUS_PAGE_ALL_DOWN = 0;\nexports.STATUS_PAGE_ALL_UP = 1;\nexports.STATUS_PAGE_PARTIAL_DOWN = 2;\nexports.STATUS_PAGE_MAINTENANCE = 3;\nexports.SQL_DATE_FORMAT = \"YYYY-MM-DD\";\nexports.SQL_DATETIME_FORMAT = \"YYYY-MM-DD HH:mm:ss\";\nexports.SQL_DATETIME_FORMAT_WITHOUT_SECOND = \"YYYY-MM-DD HH:mm\";\nexports.MAX_INTERVAL_SECOND = 2073600; // 24 days\nexports.MIN_INTERVAL_SECOND = 20; // 20 seconds\n/** Flip the status of s */\nfunction flipStatus(s) {\n    if (s === exports.UP) {\n        return exports.DOWN;\n    }\n    if (s === exports.DOWN) {\n        return exports.UP;\n    }\n    return s;\n}\nexports.flipStatus = flipStatus;\n/**\n * Delays for specified number of seconds\n * @param ms Number of milliseconds to sleep for\n */\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.sleep = sleep;\n/**\n * PHP's ucfirst\n * @param str\n */\nfunction ucfirst(str) {\n    if (!str) {\n        return str;\n    }\n    const firstLetter = str.substr(0, 1);\n    return firstLetter.toUpperCase() + str.substr(1);\n}\nexports.ucfirst = ucfirst;\n/**\n * @deprecated Use log.debug\n * @since https://github.com/louislam/uptime-kuma/pull/910\n * @param msg\n */\nfunction debug(msg) {\n    exports.log.log(\"\", msg, \"debug\");\n}\nexports.debug = debug;\nclass Logger {\n    constructor() {\n        /**\n         * UPTIME_KUMA_HIDE_LOG=debug_monitor,info_monitor\n         *\n         * Example:\n         *  [\n         *     \"debug_monitor\",          // Hide all logs that level is debug and the module is monitor\n         *     \"info_monitor\",\n         *  ]\n         */\n        this.hideLog = {\n            info: [],\n            warn: [],\n            error: [],\n            debug: [],\n        };\n        if (typeof process !== \"undefined\" && process.env.UPTIME_KUMA_HIDE_LOG) {\n            let list = process.env.UPTIME_KUMA_HIDE_LOG.split(\",\").map(v => v.toLowerCase());\n            for (let pair of list) {\n                // split first \"_\" only\n                let values = pair.split(/_(.*)/s);\n                if (values.length >= 2) {\n                    this.hideLog[values[0]].push(values[1]);\n                }\n            }\n            this.debug(\"server\", \"UPTIME_KUMA_HIDE_LOG is set\");\n            this.debug(\"server\", this.hideLog);\n        }\n    }\n    /**\n     * Write a message to the log\n     * @param module The module the log comes from\n     * @param msg Message to write\n     * @param level Log level. One of INFO, WARN, ERROR, DEBUG or can be customized.\n     */\n    log(module, msg, level) {\n        if (level === \"DEBUG\" && !exports.isDev) {\n            return;\n        }\n        if (this.hideLog[level] && this.hideLog[level].includes(module.toLowerCase())) {\n            return;\n        }\n        module = module.toUpperCase();\n        level = level.toUpperCase();\n        let now;\n        if (dayjs.tz) {\n            now = dayjs.tz(new Date()).format();\n        }\n        else {\n            now = dayjs().format();\n        }\n        const formattedMessage = (typeof msg === \"string\") ? `${now} [${module}] ${level}: ${msg}` : msg;\n        if (level === \"INFO\") {\n            console.info(formattedMessage);\n        }\n        else if (level === \"WARN\") {\n            console.warn(formattedMessage);\n        }\n        else if (level === \"ERROR\") {\n            console.error(formattedMessage);\n        }\n        else if (level === \"DEBUG\") {\n            if (exports.isDev) {\n                console.log(formattedMessage);\n            }\n        }\n        else {\n            console.log(formattedMessage);\n        }\n    }\n    /**\n     * Log an INFO message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    info(module, msg) {\n        this.log(module, msg, \"info\");\n    }\n    /**\n     * Log a WARN message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    warn(module, msg) {\n        this.log(module, msg, \"warn\");\n    }\n    /**\n     * Log an ERROR message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    error(module, msg) {\n        this.log(module, msg, \"error\");\n    }\n    /**\n     * Log a DEBUG message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    debug(module, msg) {\n        this.log(module, msg, \"debug\");\n    }\n    /**\n     * Log an exeption as an ERROR\n     * @param module Module log comes from\n     * @param exception The exeption to include\n     * @param msg The message to write\n     */\n    exception(module, exception, msg) {\n        let finalMessage = exception;\n        if (msg) {\n            finalMessage = `${msg}: ${exception}`;\n        }\n        this.log(module, finalMessage, \"error\");\n    }\n}\nexports.log = new Logger();\n/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\nfunction polyfill() {\n    if (!String.prototype.replaceAll) {\n        String.prototype.replaceAll = function (str, newStr) {\n            // If a regex pattern\n            if (Object.prototype.toString.call(str).toLowerCase() === \"[object regexp]\") {\n                return this.replace(str, newStr);\n            }\n            // If a string\n            return this.replace(new RegExp(str, \"g\"), newStr);\n        };\n    }\n}\nexports.polyfill = polyfill;\nclass TimeLogger {\n    constructor() {\n        this.startTime = dayjs().valueOf();\n    }\n    /**\n     * Output time since start of monitor\n     * @param name Name of monitor\n     */\n    print(name) {\n        if (exports.isDev && process.env.TIMELOGGER === \"1\") {\n            console.log(name + \": \" + (dayjs().valueOf() - this.startTime) + \"ms\");\n        }\n    }\n}\nexports.TimeLogger = TimeLogger;\n/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nfunction getRandomArbitrary(min, max) {\n    return Math.random() * (max - min) + min;\n}\nexports.getRandomArbitrary = getRandomArbitrary;\n/**\n * From: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range\n *\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nexports.getRandomInt = getRandomInt;\n/**\n * Returns either the NodeJS crypto.randomBytes() function or its\n * browser equivalent implemented via window.crypto.getRandomValues()\n */\nlet getRandomBytes = ((typeof window !== 'undefined' && window.crypto)\n    // Browsers\n    ? function () {\n        return (numBytes) => {\n            let randomBytes = new Uint8Array(numBytes);\n            for (let i = 0; i < numBytes; i += 65536) {\n                window.crypto.getRandomValues(randomBytes.subarray(i, i + Math.min(numBytes - i, 65536)));\n            }\n            return randomBytes;\n        };\n    }\n    // Node\n    : function () {\n        return require(\"crypto\").randomBytes;\n    })();\n/**\n * Get a random integer suitable for use in cryptography between upper\n * and lower bounds.\n * @param min Minimum value of integer\n * @param max Maximum value of integer\n * @returns Cryptographically suitable random integer\n */\nfunction getCryptoRandomInt(min, max) {\n    // synchronous version of: https://github.com/joepie91/node-random-number-csprng\n    const range = max - min;\n    if (range >= Math.pow(2, 32))\n        console.log(\"Warning! Range is too large.\");\n    let tmpRange = range;\n    let bitsNeeded = 0;\n    let bytesNeeded = 0;\n    let mask = 1;\n    while (tmpRange > 0) {\n        if (bitsNeeded % 8 === 0)\n            bytesNeeded += 1;\n        bitsNeeded += 1;\n        mask = mask << 1 | 1;\n        tmpRange = tmpRange >>> 1;\n    }\n    const randomBytes = getRandomBytes(bytesNeeded);\n    let randomValue = 0;\n    for (let i = 0; i < bytesNeeded; i++) {\n        randomValue |= randomBytes[i] << 8 * i;\n    }\n    randomValue = randomValue & mask;\n    if (randomValue <= range) {\n        return min + randomValue;\n    }\n    else {\n        return getCryptoRandomInt(min, max);\n    }\n}\nexports.getCryptoRandomInt = getCryptoRandomInt;\n/**\n * Generate a random alphanumeric string of fixed length\n * @param length Length of string to generate\n * @returns string\n */\nfunction genSecret(length = 64) {\n    let secret = \"\";\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const charsLength = chars.length;\n    for (let i = 0; i < length; i++) {\n        secret += chars.charAt(getCryptoRandomInt(0, charsLength - 1));\n    }\n    return secret;\n}\nexports.genSecret = genSecret;\n/**\n * Get the path of a monitor\n * @param id ID of monitor\n * @returns Formatted relative path\n */\nfunction getMonitorRelativeURL(id) {\n    return \"/dashboard/\" + id;\n}\nexports.getMonitorRelativeURL = getMonitorRelativeURL;\n/**\n * Get relative path for maintenance\n * @param id ID of maintenance\n * @returns Formatted relative path\n */\nfunction getMaintenanceRelativeURL(id) {\n    return \"/maintenance/\" + id;\n}\nexports.getMaintenanceRelativeURL = getMaintenanceRelativeURL;\n/**\n * Parse to Time Object that used in VueDatePicker\n * @param {string} time E.g. 12:00\n * @returns object\n */\nfunction parseTimeObject(time) {\n    if (!time) {\n        return {\n            hours: 0,\n            minutes: 0,\n        };\n    }\n    let array = time.split(\":\");\n    if (array.length < 2) {\n        throw new Error(\"parseVueDatePickerTimeFormat: Invalid Time\");\n    }\n    let obj = {\n        hours: parseInt(array[0]),\n        minutes: parseInt(array[1]),\n        seconds: 0,\n    };\n    if (array.length >= 3) {\n        obj.seconds = parseInt(array[2]);\n    }\n    return obj;\n}\nexports.parseTimeObject = parseTimeObject;\n/**\n * @returns string e.g. 12:00\n */\nfunction parseTimeFromTimeObject(obj) {\n    if (!obj) {\n        return obj;\n    }\n    let result = \"\";\n    result += obj.hours.toString().padStart(2, \"0\") + \":\" + obj.minutes.toString().padStart(2, \"0\");\n    if (obj.seconds) {\n        result += \":\" + obj.seconds.toString().padStart(2, \"0\");\n    }\n    return result;\n}\nexports.parseTimeFromTimeObject = parseTimeFromTimeObject;\n/**\n * Convert ISO date to UTC\n * @param input Date\n * @returns ISO Date time\n */\nfunction isoToUTCDateTime(input) {\n    return dayjs(input).utc().format(exports.SQL_DATETIME_FORMAT);\n}\nexports.isoToUTCDateTime = isoToUTCDateTime;\n/**\n * @param input\n */\nfunction utcToISODateTime(input) {\n    return dayjs.utc(input).toISOString();\n}\nexports.utcToISODateTime = utcToISODateTime;\n/**\n * For SQL_DATETIME_FORMAT\n */\nfunction utcToLocal(input, format = exports.SQL_DATETIME_FORMAT) {\n    return dayjs.utc(input).local().format(format);\n}\nexports.utcToLocal = utcToLocal;\n/**\n * Convert local datetime to UTC\n * @param input Local date\n * @param format Format to return\n * @returns Date in requested format\n */\nfunction localToUTC(input, format = exports.SQL_DATETIME_FORMAT) {\n    return dayjs(input).utc().format(format);\n}\nexports.localToUTC = localToUTC;\n", "// Common Util for frontend and backend\n//\n// DOT NOT MODIFY util.js!\n// Need to run \"tsc\" to compile if there are any changes.\n//\n// Backend uses the compiled file util.js\n// Frontend uses util.ts\n\nimport * as dayjs  from \"dayjs\";\nimport * as timezone from \"dayjs/plugin/timezone\";\nimport * as utc from \"dayjs/plugin/utc\";\n\nexport const isDev = process.env.NODE_ENV === \"development\";\nexport const appName = \"Uptime Kuma\";\nexport const DOWN = 0;\nexport const UP = 1;\nexport const PENDING = 2;\nexport const MAINTENANCE = 3;\n\nexport const STATUS_PAGE_ALL_DOWN = 0;\nexport const STATUS_PAGE_ALL_UP = 1;\nexport const STATUS_PAGE_PARTIAL_DOWN = 2;\nexport const STATUS_PAGE_MAINTENANCE = 3;\n\nexport const SQL_DATE_FORMAT = \"YYYY-MM-DD\";\nexport const SQL_DATETIME_FORMAT = \"YYYY-MM-DD HH:mm:ss\";\nexport const SQL_DATETIME_FORMAT_WITHOUT_SECOND = \"YYYY-MM-DD HH:mm\";\n\nexport const MAX_INTERVAL_SECOND = 2073600; // 24 days\nexport const MIN_INTERVAL_SECOND = 20; // 20 seconds\n\n/** Flip the status of s */\nexport function flipStatus(s: number) {\n    if (s === UP) {\n        return DOWN;\n    }\n\n    if (s === DOWN) {\n        return UP;\n    }\n\n    return s;\n}\n\n/**\n * Delays for specified number of seconds\n * @param ms Number of milliseconds to sleep for\n */\nexport function sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * PHP's ucfirst\n * @param str\n */\nexport function ucfirst(str: string) {\n    if (!str) {\n        return str;\n    }\n\n    const firstLetter = str.substr(0, 1);\n    return firstLetter.toUpperCase() + str.substr(1);\n}\n\n/**\n * @deprecated Use log.debug\n * @since https://github.com/louislam/uptime-kuma/pull/910\n * @param msg\n */\nexport function debug(msg: any) {\n    log.log(\"\", msg, \"debug\");\n}\n\nclass Logger {\n\n    /**\n     * UPTIME_KUMA_HIDE_LOG=debug_monitor,info_monitor\n     *\n     * Example:\n     *  [\n     *     \"debug_monitor\",          // Hide all logs that level is debug and the module is monitor\n     *     \"info_monitor\",\n     *  ]\n     */\n    hideLog : any = {\n        info: [],\n        warn: [],\n        error: [],\n        debug: [],\n    };\n\n    constructor() {\n        if (typeof process !== \"undefined\" && process.env.UPTIME_KUMA_HIDE_LOG) {\n            let list = process.env.UPTIME_KUMA_HIDE_LOG.split(\",\").map(v => v.toLowerCase());\n\n            for (let pair of list) {\n                // split first \"_\" only\n                let values = pair.split(/_(.*)/s);\n\n                if (values.length >= 2) {\n                    this.hideLog[values[0]].push(values[1]);\n                }\n            }\n\n            this.debug(\"server\", \"UPTIME_KUMA_HIDE_LOG is set\");\n            this.debug(\"server\", this.hideLog);\n        }\n    }\n\n    /**\n     * Write a message to the log\n     * @param module The module the log comes from\n     * @param msg Message to write\n     * @param level Log level. One of INFO, WARN, ERROR, DEBUG or can be customized.\n     */\n    log(module: string, msg: any, level: string) {\n        if (level === \"DEBUG\" && !isDev) {\n            return;\n        }\n\n        if (this.hideLog[level] && this.hideLog[level].includes(module.toLowerCase())) {\n            return;\n        }\n\n        module = module.toUpperCase();\n        level = level.toUpperCase();\n\n        let now;\n        if (dayjs.tz) {\n            now = dayjs.tz(new Date()).format();\n        } else {\n            now = dayjs().format();\n        }\n        const formattedMessage = (typeof msg === \"string\") ? `${now} [${module}] ${level}: ${msg}` : msg;\n\n        if (level === \"INFO\") {\n            console.info(formattedMessage);\n        } else if (level === \"WARN\") {\n            console.warn(formattedMessage);\n        } else if (level === \"ERROR\") {\n            console.error(formattedMessage);\n        } else if (level === \"DEBUG\") {\n            if (isDev) {\n                console.log(formattedMessage);\n            }\n        } else {\n            console.log(formattedMessage);\n        }\n    }\n\n    /**\n     * Log an INFO message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    info(module: string, msg: any) {\n        this.log(module, msg, \"info\");\n    }\n\n    /**\n     * Log a WARN message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    warn(module: string, msg: any) {\n        this.log(module, msg, \"warn\");\n    }\n\n    /**\n     * Log an ERROR message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    error(module: string, msg: any) {\n       this.log(module, msg, \"error\");\n    }\n\n    /**\n     * Log a DEBUG message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    debug(module: string, msg: any) {\n       this.log(module, msg, \"debug\");\n    }\n\n    /**\n     * Log an exeption as an ERROR\n     * @param module Module log comes from\n     * @param exception The exeption to include\n     * @param msg The message to write\n     */\n    exception(module: string, exception: any, msg: any) {\n        let finalMessage = exception\n\n        if (msg) {\n            finalMessage = `${msg}: ${exception}`\n        }\n\n        this.log(module, finalMessage , \"error\");\n    }\n}\n\nexport const log = new Logger();\n\ndeclare global { interface String { replaceAll(str: string, newStr: string): string; } }\n\n/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\nexport function polyfill() {\n    if (!String.prototype.replaceAll) {\n        String.prototype.replaceAll = function (str: string, newStr: string) {\n            // If a regex pattern\n            if (Object.prototype.toString.call(str).toLowerCase() === \"[object regexp]\") {\n                return this.replace(str, newStr);\n            }\n\n            // If a string\n            return this.replace(new RegExp(str, \"g\"), newStr);\n        };\n    }\n}\n\nexport class TimeLogger {\n    startTime: number;\n\n    constructor() {\n        this.startTime = dayjs().valueOf();\n    }\n    /**\n     * Output time since start of monitor\n     * @param name Name of monitor\n     */\n    print(name: string) {\n        if (isDev && process.env.TIMELOGGER === \"1\") {\n            console.log(name + \": \" + (dayjs().valueOf() - this.startTime) + \"ms\")\n        }\n    }\n}\n\n/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nexport function getRandomArbitrary(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n}\n\n/**\n * From: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range\n *\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nexport function getRandomInt(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Returns either the NodeJS crypto.randomBytes() function or its\n * browser equivalent implemented via window.crypto.getRandomValues()\n */\nlet getRandomBytes = (\n    (typeof window !== 'undefined' && window.crypto)\n\n        // Browsers\n        ? function () {\n            return (numBytes: number) => {\n                let randomBytes = new Uint8Array(numBytes);\n                for (let i = 0; i < numBytes; i += 65536) {\n                    window.crypto.getRandomValues(randomBytes.subarray(i, i + Math.min(numBytes - i, 65536)));\n                }\n                return randomBytes;\n            };\n        }\n\n         // Node\n        : function() {\n            return require(\"crypto\").randomBytes;\n        }\n)();\n\n/**\n * Get a random integer suitable for use in cryptography between upper\n * and lower bounds.\n * @param min Minimum value of integer\n * @param max Maximum value of integer\n * @returns Cryptographically suitable random integer\n */\nexport function getCryptoRandomInt(min: number, max: number):number {\n\n    // synchronous version of: https://github.com/joepie91/node-random-number-csprng\n\n    const range = max - min\n    if (range >= Math.pow(2, 32))\n        console.log(\"Warning! Range is too large.\")\n\n    let tmpRange = range\n    let bitsNeeded = 0\n    let bytesNeeded = 0\n    let mask = 1\n\n    while (tmpRange > 0) {\n        if (bitsNeeded % 8 === 0) bytesNeeded += 1\n        bitsNeeded += 1\n        mask = mask << 1 | 1\n        tmpRange = tmpRange >>> 1\n    }\n\n    const randomBytes = getRandomBytes(bytesNeeded)\n    let randomValue = 0\n\n    for (let i = 0; i < bytesNeeded; i++) {\n\t    randomValue |= randomBytes[i] << 8 * i\n    }\n\n    randomValue = randomValue & mask;\n\n    if (randomValue <= range) {\n        return min + randomValue\n    } else {\n        return getCryptoRandomInt(min, max)\n    }\n}\n\n/**\n * Generate a random alphanumeric string of fixed length\n * @param length Length of string to generate\n * @returns string\n */\nexport function genSecret(length = 64) {\n    let secret = \"\";\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const charsLength = chars.length;\n    for ( let i = 0; i < length; i++ ) {\n        secret += chars.charAt(getCryptoRandomInt(0, charsLength - 1));\n    }\n    return secret;\n}\n\n/**\n * Get the path of a monitor\n * @param id ID of monitor\n * @returns Formatted relative path\n */\nexport function getMonitorRelativeURL(id: string) {\n    return \"/dashboard/\" + id;\n}\n\n/**\n * Get relative path for maintenance\n * @param id ID of maintenance\n * @returns Formatted relative path\n */\nexport function getMaintenanceRelativeURL(id: string) {\n    return \"/maintenance/\" + id;\n}\n\n/**\n * Parse to Time Object that used in VueDatePicker\n * @param {string} time E.g. 12:00\n * @returns object\n */\nexport function parseTimeObject(time: string) {\n    if (!time) {\n        return {\n            hours: 0,\n            minutes: 0,\n        };\n    }\n\n    let array = time.split(\":\");\n\n    if (array.length < 2) {\n        throw new Error(\"parseVueDatePickerTimeFormat: Invalid Time\");\n    }\n\n    let obj =  {\n        hours: parseInt(array[0]),\n        minutes: parseInt(array[1]),\n        seconds: 0,\n    }\n    if (array.length >= 3) {\n        obj.seconds = parseInt(array[2]);\n    }\n    return obj;\n}\n\n/**\n * @returns string e.g. 12:00\n */\nexport function parseTimeFromTimeObject(obj : any) {\n    if (!obj) {\n        return obj;\n    }\n\n    let result = \"\";\n\n    result += obj.hours.toString().padStart(2, \"0\") + \":\" + obj.minutes.toString().padStart(2, \"0\")\n\n    if (obj.seconds) {\n        result += \":\" +  obj.seconds.toString().padStart(2, \"0\")\n    }\n\n    return result;\n}\n\n/**\n * Convert ISO date to UTC\n * @param input Date\n * @returns ISO Date time\n */\nexport function isoToUTCDateTime(input : string) {\n    return dayjs(input).utc().format(SQL_DATETIME_FORMAT);\n}\n\n/**\n * @param input\n */\nexport function utcToISODateTime(input : string) {\n    return dayjs.utc(input).toISOString();\n}\n\n/**\n * For SQL_DATETIME_FORMAT\n */\nexport function utcToLocal(input : string, format = SQL_DATETIME_FORMAT) {\n    return dayjs.utc(input).local().format(format);\n}\n\n/**\n * Convert local datetime to UTC\n * @param input Local date\n * @param format Format to return\n * @returns Date in requested format\n */\nexport function localToUTC(input : string, format = SQL_DATETIME_FORMAT) {\n    return dayjs(input).utc().format(format);\n}\n"], "fixing_code": ["import legacy from \"@vitejs/plugin-legacy\";\nimport vue from \"@vitejs/plugin-vue\";\nimport { defineConfig } from \"vite\";\nimport visualizer from \"rollup-plugin-visualizer\";\nimport viteCompression from \"vite-plugin-compression\";\n\nconst postCssScss = require(\"postcss-scss\");\nconst postcssRTLCSS = require(\"postcss-rtlcss\");\n\nconst viteCompressionFilter = /\\.(js|mjs|json|css|html|svg)$/i;\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n    server: {\n        port: 3000,\n    },\n    define: {\n        \"FRONTEND_VERSION\": JSON.stringify(process.env.npm_package_version),\n        \"DEVCONTAINER\": JSON.stringify(process.env.DEVCONTAINER),\n        \"GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN\": JSON.stringify(process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN),\n        \"CODESPACE_NAME\": JSON.stringify(process.env.CODESPACE_NAME),\n    },\n    plugins: [\n        vue(),\n        legacy({\n            targets: [ \"since 2015\" ],\n        }),\n        visualizer({\n            filename: \"tmp/dist-stats.html\"\n        }),\n        viteCompression({\n            algorithm: \"gzip\",\n            filter: viteCompressionFilter,\n        }),\n        viteCompression({\n            algorithm: \"brotliCompress\",\n            filter: viteCompressionFilter,\n        }),\n    ],\n    css: {\n        postcss: {\n            \"parser\": postCssScss,\n            \"map\": false,\n            \"plugins\": [ postcssRTLCSS ]\n        }\n    },\n    build: {\n        commonjsOptions: {\n            include: [ /.js$/ ],\n        },\n        rollupOptions: {\n            output: {\n                manualChunks(id, { getModuleInfo, getModuleIds }) {\n\n                }\n            }\n        },\n    }\n});\n", "/*\n * \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Due to the weird issue in Portainer that the healthcheck script is still pointing to this script for unknown reason.\n * IT CANNOT BE DROPPED, even though it looks like it is not used.\n * See more: https://github.com/louislam/uptime-kuma/issues/2774#issuecomment-1429092359\n *\n * \u26a0\ufe0f Deprecated: Changed to healthcheck.go, it will be deleted in the future.\n * This script should be run after a period of time (180s), because the server may need some time to prepare.\n */\nconst FBSD = /^freebsd/.test(process.platform);\n\nprocess.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\";\n\nlet client;\n\nconst sslKey = process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\nconst sslCert = process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\n\nif (sslKey && sslCert) {\n    client = require(\"https\");\n} else {\n    client = require(\"http\");\n}\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\nlet hostname = process.env.UPTIME_KUMA_HOST;\n\n// Also read HOST if not *BSD, as HOST is a system environment variable in FreeBSD\nif (!hostname && !FBSD) {\n    hostname = process.env.HOST;\n}\n\nconst port = parseInt(process.env.UPTIME_KUMA_PORT || process.env.PORT || 3001);\n\nlet options = {\n    host: hostname || \"127.0.0.1\",\n    port: port,\n    timeout: 28 * 1000,\n};\n\nlet request = client.request(options, (res) => {\n    console.log(`Health Check OK [Res Code: ${res.statusCode}]`);\n    if (res.statusCode === 302) {\n        process.exit(0);\n    } else {\n        process.exit(1);\n    }\n});\n\nrequest.on(\"error\", function (err) {\n    console.error(\"Health Check ERROR\");\n    process.exit(1);\n});\n\nrequest.end();\n", "console.log(\"== Uptime Kuma Reset Password Tool ==\");\n\nconst Database = require(\"../server/database\");\nconst { R } = require(\"redbean-node\");\nconst readline = require(\"readline\");\nconst { initJWTSecret } = require(\"../server/util-server\");\nconst User = require(\"../server/model/user\");\nconst { io } = require(\"socket.io-client\");\nconst { localWebSocketURL } = require(\"../server/config\");\nconst args = require(\"args-parser\")(process.argv);\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst main = async () => {\n    console.log(\"Connecting the database\");\n    Database.init(args);\n    await Database.connect(false, false, true);\n\n    try {\n        // No need to actually reset the password for testing, just make sure no connection problem. It is ok for now.\n        if (!process.env.TEST_BACKEND) {\n            const user = await R.findOne(\"user\");\n            if (! user) {\n                throw new Error(\"user not found, have you installed?\");\n            }\n\n            console.log(\"Found user: \" + user.username);\n\n            while (true) {\n                let password = await question(\"New Password: \");\n                let confirmPassword = await question(\"Confirm New Password: \");\n\n                if (password === confirmPassword) {\n                    await User.resetPassword(user.id, password);\n\n                    // Reset all sessions by reset jwt secret\n                    await initJWTSecret();\n\n                    // Disconnect all other socket clients of the user\n                    await disconnectAllSocketClients(user.username, password);\n\n                    break;\n                } else {\n                    console.log(\"Passwords do not match, please try again.\");\n                }\n            }\n            console.log(\"Password reset successfully.\");\n\n        }\n    } catch (e) {\n        console.error(\"Error: \" + e.message);\n    }\n\n    await Database.close();\n    rl.close();\n\n    console.log(\"Finished.\");\n};\n\n/**\n * Ask question of user\n * @param {string} question Question to ask\n * @returns {Promise<string>} Users response\n */\nfunction question(question) {\n    return new Promise((resolve) => {\n        rl.question(question, (answer) => {\n            resolve(answer);\n        });\n    });\n}\n\nfunction disconnectAllSocketClients(username, password) {\n    return new Promise((resolve) => {\n        console.log(\"Connecting to \" + localWebSocketURL + \" to disconnect all other socket clients\");\n\n        // Disconnect all socket connections\n        const socket = io(localWebSocketURL, {\n            transports: [ \"websocket\" ],\n            reconnection: false,\n            timeout: 5000,\n        });\n        socket.on(\"connect\", () => {\n            socket.emit(\"login\", {\n                username,\n                password,\n            }, (res) => {\n                if (res.ok) {\n                    console.log(\"Logged in.\");\n                    socket.emit(\"disconnectOtherSocketClients\");\n                } else {\n                    console.warn(\"Login failed.\");\n                    console.warn(\"Please restart the server to disconnect all sessions.\");\n                }\n                socket.close();\n            });\n        });\n\n        socket.on(\"connect_error\", function () {\n            // The localWebSocketURL is not guaranteed to be working for some complicated Uptime Kuma setup\n            // Ask the user to restart the server manually\n            console.warn(\"Failed to connect to \" + localWebSocketURL);\n            console.warn(\"Please restart the server to disconnect all sessions manually.\");\n            resolve();\n        });\n        socket.on(\"disconnect\", () => {\n            resolve();\n        });\n    });\n}\n\nif (!process.env.TEST_BACKEND) {\n    main();\n}\n\nmodule.exports = {\n    main,\n};\n", "{\n    \"name\": \"uptime-kuma\",\n    \"version\": \"1.23.8\",\n    \"license\": \"MIT\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/louislam/uptime-kuma.git\"\n    },\n    \"engines\": {\n        \"node\": \"14 || 16 || 18 || >= 20.4.0\"\n    },\n    \"scripts\": {\n        \"install-legacy\": \"npm install\",\n        \"update-legacy\": \"npm update\",\n        \"lint:js\": \"eslint --ext \\\".js,.vue\\\" --ignore-path .gitignore .\",\n        \"lint:js-prod\": \"npm run lint:js -- --max-warnings 0\",\n        \"lint-fix:js\": \"eslint --ext \\\".js,.vue\\\" --fix --ignore-path .gitignore .\",\n        \"lint:style\": \"stylelint \\\"**/*.{vue,css,scss}\\\" --ignore-path .gitignore\",\n        \"lint-fix:style\": \"stylelint \\\"**/*.{vue,css,scss}\\\" --fix --ignore-path .gitignore\",\n        \"lint\": \"npm run lint:js && npm run lint:style\",\n        \"lint:prod\": \"npm run lint:js-prod && npm run lint:style\",\n        \"dev\": \"concurrently -k -r \\\"wait-on tcp:3000 && npm run start-server-dev \\\" \\\"npm run start-frontend-dev\\\"\",\n        \"start-frontend-dev\": \"cross-env NODE_ENV=development vite --host --config ./config/vite.config.js\",\n        \"start-frontend-devcontainer\": \"cross-env NODE_ENV=development DEVCONTAINER=1 vite --host --config ./config/vite.config.js\",\n        \"start\": \"npm run start-server\",\n        \"start-server\": \"node server/server.js\",\n        \"start-server-dev\": \"cross-env NODE_ENV=development node server/server.js\",\n        \"build\": \"vite build --config ./config/vite.config.js\",\n        \"test\": \"node test/prepare-test-server.js && npm run jest-backend\",\n        \"test-with-build\": \"npm run build && npm test\",\n        \"jest-backend\": \"cross-env TEST_BACKEND=1 jest --runInBand --detectOpenHandles --forceExit --config=./config/jest-backend.config.js\",\n        \"tsc\": \"tsc\",\n        \"vite-preview-dist\": \"vite preview --host --config ./config/vite.config.js\",\n        \"build-docker\": \"npm run build && npm run build-docker-debian && npm run build-docker-alpine\",\n        \"build-docker-alpine-base\": \"docker buildx build -f docker/alpine-base.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:base-alpine . --push\",\n        \"build-docker-debian-base\": \"docker buildx build -f docker/debian-base.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:base-debian . --push\",\n        \"build-docker-builder-go\": \"docker buildx build -f docker/builder-go.dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:builder-go . --push\",\n        \"build-docker-alpine\": \"node ./extra/env2arg.js docker buildx build -f docker/dockerfile-alpine --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:alpine -t louislam/uptime-kuma:1-alpine -t louislam/uptime-kuma:$VERSION-alpine --target release . --push\",\n        \"build-docker-debian\": \"node ./extra/env2arg.js docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma -t louislam/uptime-kuma:1 -t louislam/uptime-kuma:$VERSION -t louislam/uptime-kuma:debian -t louislam/uptime-kuma:1-debian -t louislam/uptime-kuma:$VERSION-debian --target release . --push\",\n        \"build-docker-nightly\": \"node ./extra/test-docker.js && npm run build && docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:nightly --target nightly . --push\",\n        \"build-docker-nightly-alpine\": \"docker buildx build -f docker/dockerfile-alpine --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:nightly-alpine --target nightly . --push\",\n        \"build-docker-nightly-amd64\": \"docker buildx build -f docker/dockerfile --platform linux/amd64 -t louislam/uptime-kuma:nightly-amd64 --target nightly . --push --progress plain\",\n        \"build-docker-pr-test\": \"docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64 -t louislam/uptime-kuma:pr-test --target pr-test . --push\",\n        \"upload-artifacts\": \"docker buildx build -f docker/dockerfile --platform linux/amd64 -t louislam/uptime-kuma:upload-artifact --build-arg VERSION --build-arg GITHUB_TOKEN --target upload-artifact . --progress plain\",\n        \"setup\": \"git checkout 1.23.8 && npm ci --production && npm run download-dist\",\n        \"download-dist\": \"node extra/download-dist.js\",\n        \"mark-as-nightly\": \"node extra/mark-as-nightly.js\",\n        \"reset-password\": \"node extra/reset-password.js\",\n        \"remove-2fa\": \"node extra/remove-2fa.js\",\n        \"compile-install-script\": \"@powershell -NoProfile -ExecutionPolicy Unrestricted -Command ./extra/compile-install-script.ps1\",\n        \"test-install-script-rockylinux\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/rockylinux.dockerfile .\",\n        \"test-install-script-centos7\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/centos7.dockerfile .\",\n        \"test-install-script-alpine3\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/alpine3.dockerfile .\",\n        \"test-install-script-debian\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/debian.dockerfile .\",\n        \"test-install-script-debian-buster\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/debian-buster.dockerfile .\",\n        \"test-install-script-ubuntu\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu.dockerfile .\",\n        \"test-install-script-ubuntu1804\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu1804.dockerfile .\",\n        \"test-install-script-ubuntu1604\": \"npm run compile-install-script && docker build --progress plain -f test/test_install_script/ubuntu1604.dockerfile .\",\n        \"simple-dns-server\": \"node extra/simple-dns-server.js\",\n        \"simple-mqtt-server\": \"node extra/simple-mqtt-server.js\",\n        \"simple-mongo\": \"docker run --rm -p 27017:27017 mongo\",\n        \"simple-postgres\": \"docker run --rm -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres\",\n        \"simple-mariadb\": \"docker run --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD=mariadb# mariadb\",\n        \"update-language-files\": \"cd extra/update-language-files && node index.js && cross-env-shell eslint ../../src/languages/$npm_config_language.js --fix\",\n        \"ncu-patch\": \"npm-check-updates -u -t patch\",\n        \"release-final\": \"node ./extra/test-docker.js && node extra/update-version.js && npm run build-docker && node ./extra/press-any-key.js && npm run upload-artifacts && node ./extra/update-wiki-version.js\",\n        \"release-beta\": \"node ./extra/test-docker.js && node extra/beta/update-version.js && npm run build && node ./extra/env2arg.js docker buildx build -f docker/dockerfile --platform linux/amd64,linux/arm64,linux/arm/v7 -t louislam/uptime-kuma:$VERSION -t louislam/uptime-kuma:beta .  --target release --push && node ./extra/press-any-key.js && npm run upload-artifacts\",\n        \"git-remove-tag\": \"git tag -d\",\n        \"build-dist-and-restart\": \"npm run build && npm run start-server-dev\",\n        \"start-pr-test\": \"node extra/checkout-pr.js && npm install && npm run dev\",\n        \"cy:test\": \"node test/prepare-test-server.js && node server/server.js --port=3002 --data-dir=./data/test/ --e2e\",\n        \"cy:run\": \"npx cypress run --browser chrome --headless --config-file ./config/cypress.config.js\",\n        \"cy:run:unit\": \"npx cypress run --browser chrome --headless --config-file ./config/cypress.frontend.config.js\",\n        \"cypress-open\": \"concurrently -k -r \\\"node test/prepare-test-server.js && node server/server.js --port=3002 --data-dir=./data/test/\\\" \\\"cypress open --config-file ./config/cypress.config.js\\\"\",\n        \"build-healthcheck-armv7\": \"cross-env GOOS=linux GOARCH=arm GOARM=7 go build -x -o ./extra/healthcheck-armv7 ./extra/healthcheck.go\",\n        \"deploy-demo-server\": \"node extra/deploy-demo-server.js\",\n        \"sort-contributors\": \"node extra/sort-contributors.js\",\n        \"start-server-node14-win\": \"private\\\\node14\\\\node.exe server/server.js\"\n    },\n    \"dependencies\": {\n        \"@grpc/grpc-js\": \"~1.7.3\",\n        \"@louislam/ping\": \"~0.4.4-mod.1\",\n        \"@louislam/sqlite3\": \"15.1.6\",\n        \"args-parser\": \"~1.3.0\",\n        \"axios\": \"~0.27.0\",\n        \"axios-ntlm\": \"1.3.0\",\n        \"badge-maker\": \"~3.3.1\",\n        \"bcryptjs\": \"~2.4.3\",\n        \"cacheable-lookup\": \"~6.0.4\",\n        \"chardet\": \"~1.4.0\",\n        \"check-password-strength\": \"^2.0.5\",\n        \"cheerio\": \"~1.0.0-rc.12\",\n        \"chroma-js\": \"~2.4.2\",\n        \"command-exists\": \"~1.2.9\",\n        \"compare-versions\": \"~3.6.0\",\n        \"compression\": \"~1.7.4\",\n        \"croner\": \"~6.0.5\",\n        \"dayjs\": \"~1.11.5\",\n        \"dotenv\": \"~16.0.3\",\n        \"express\": \"~4.17.3\",\n        \"express-basic-auth\": \"~1.2.1\",\n        \"express-static-gzip\": \"~2.1.7\",\n        \"form-data\": \"~4.0.0\",\n        \"gamedig\": \"^4.2.0\",\n        \"html-escaper\": \"^3.0.3\",\n        \"http-graceful-shutdown\": \"~3.1.7\",\n        \"http-proxy-agent\": \"~5.0.0\",\n        \"https-proxy-agent\": \"~5.0.1\",\n        \"iconv-lite\": \"~0.6.3\",\n        \"isomorphic-ws\": \"^5.0.0\",\n        \"jsesc\": \"~3.0.2\",\n        \"jsonata\": \"^2.0.3\",\n        \"jsonwebtoken\": \"~9.0.0\",\n        \"jwt-decode\": \"~3.1.2\",\n        \"kafkajs\": \"^2.2.4\",\n        \"limiter\": \"~2.1.0\",\n        \"liquidjs\": \"^10.7.0\",\n        \"mongodb\": \"~4.17.1\",\n        \"mqtt\": \"~4.3.7\",\n        \"mssql\": \"~8.1.4\",\n        \"mysql2\": \"~3.6.2\",\n        \"nanoid\": \"~3.3.4\",\n        \"node-cloudflared-tunnel\": \"~1.0.9\",\n        \"node-radius-client\": \"~1.0.0\",\n        \"nodemailer\": \"~6.6.5\",\n        \"nostr-tools\": \"^1.13.1\",\n        \"notp\": \"~2.0.3\",\n        \"openid-client\": \"^5.4.2\",\n        \"password-hash\": \"~1.2.2\",\n        \"pg\": \"~8.11.3\",\n        \"pg-connection-string\": \"~2.6.2\",\n        \"playwright-core\": \"~1.35.1\",\n        \"prom-client\": \"~13.2.0\",\n        \"prometheus-api-metrics\": \"~3.2.1\",\n        \"promisify-child-process\": \"~4.1.2\",\n        \"protobufjs\": \"~7.2.4\",\n        \"qs\": \"~6.10.4\",\n        \"redbean-node\": \"~0.3.0\",\n        \"redis\": \"~4.5.1\",\n        \"semver\": \"~7.5.4\",\n        \"socket.io\": \"~4.6.1\",\n        \"socket.io-client\": \"~4.6.1\",\n        \"socks-proxy-agent\": \"6.1.1\",\n        \"tar\": \"~6.1.11\",\n        \"tcp-ping\": \"~0.1.1\",\n        \"thirty-two\": \"~1.0.2\",\n        \"ws\": \"^8.13.0\"\n    },\n    \"devDependencies\": {\n        \"@actions/github\": \"~5.0.1\",\n        \"@babel/eslint-parser\": \"^7.22.7\",\n        \"@babel/preset-env\": \"^7.15.8\",\n        \"@fortawesome/fontawesome-svg-core\": \"~1.2.36\",\n        \"@fortawesome/free-regular-svg-icons\": \"~5.15.4\",\n        \"@fortawesome/free-solid-svg-icons\": \"~5.15.4\",\n        \"@fortawesome/vue-fontawesome\": \"~3.0.0-5\",\n        \"@popperjs/core\": \"~2.10.2\",\n        \"@types/bootstrap\": \"~5.1.9\",\n        \"@vitejs/plugin-legacy\": \"~4.1.0\",\n        \"@vitejs/plugin-vue\": \"~4.2.3\",\n        \"@vue/compiler-sfc\": \"~3.3.4\",\n        \"@vuepic/vue-datepicker\": \"~3.4.8\",\n        \"aedes\": \"^0.46.3\",\n        \"bootstrap\": \"5.1.3\",\n        \"chart.js\": \"~4.2.1\",\n        \"chartjs-adapter-dayjs-4\": \"~1.0.4\",\n        \"concurrently\": \"^7.1.0\",\n        \"core-js\": \"~3.26.1\",\n        \"cronstrue\": \"~2.24.0\",\n        \"cross-env\": \"~7.0.3\",\n        \"cypress\": \"^13.2.0\",\n        \"delay\": \"^5.0.0\",\n        \"dns2\": \"~2.0.1\",\n        \"dompurify\": \"~2.4.3\",\n        \"eslint\": \"~8.14.0\",\n        \"eslint-plugin-vue\": \"~8.7.1\",\n        \"favico.js\": \"~0.3.10\",\n        \"jest\": \"~29.6.1\",\n        \"marked\": \"~4.2.5\",\n        \"node-ssh\": \"~13.1.0\",\n        \"postcss-html\": \"~1.5.0\",\n        \"postcss-rtlcss\": \"~3.7.2\",\n        \"postcss-scss\": \"~4.0.4\",\n        \"prismjs\": \"~1.29.0\",\n        \"qrcode\": \"~1.5.0\",\n        \"rollup-plugin-visualizer\": \"^5.6.0\",\n        \"sass\": \"~1.42.1\",\n        \"stylelint\": \"^15.10.1\",\n        \"stylelint-config-standard\": \"~25.0.0\",\n        \"terser\": \"~5.15.0\",\n        \"timezones-list\": \"~3.0.1\",\n        \"typescript\": \"~4.4.4\",\n        \"v-pagination-3\": \"~0.1.7\",\n        \"vite\": \"~4.4.1\",\n        \"vite-plugin-compression\": \"^0.5.1\",\n        \"vue\": \"~3.3.4\",\n        \"vue-chartjs\": \"~5.2.0\",\n        \"vue-confirm-dialog\": \"~1.0.2\",\n        \"vue-contenteditable\": \"~3.0.4\",\n        \"vue-i18n\": \"~9.2.2\",\n        \"vue-image-crop-upload\": \"~3.0.3\",\n        \"vue-multiselect\": \"~3.0.0-alpha.2\",\n        \"vue-prism-editor\": \"~2.0.0-alpha.2\",\n        \"vue-qrcode\": \"~1.0.0\",\n        \"vue-router\": \"~4.0.14\",\n        \"vue-toastification\": \"~2.0.0-rc.5\",\n        \"vuedraggable\": \"~4.1.0\",\n        \"wait-on\": \"^7.2.0\",\n        \"whatwg-url\": \"~12.0.1\"\n    }\n}\n", "const isFreeBSD = /^freebsd/.test(process.platform);\n\n// Interop with browser\nconst args = (typeof process !== \"undefined\") ? require(\"args-parser\")(process.argv) : {};\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = isFreeBSD ? null : process.env.HOST;\nconst hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst sslKey = args[\"ssl-key\"] || process.env.UPTIME_KUMA_SSL_KEY || process.env.SSL_KEY || undefined;\nconst sslCert = args[\"ssl-cert\"] || process.env.UPTIME_KUMA_SSL_CERT || process.env.SSL_CERT || undefined;\nconst sslKeyPassphrase = args[\"ssl-key-passphrase\"] || process.env.UPTIME_KUMA_SSL_KEY_PASSPHRASE || process.env.SSL_KEY_PASSPHRASE || undefined;\n\nconst isSSL = sslKey && sslCert;\n\nfunction getLocalWebSocketURL() {\n    const protocol = isSSL ? \"wss\" : \"ws\";\n    const host = hostname || \"localhost\";\n    return `${protocol}://${host}:${port}`;\n}\n\nconst localWebSocketURL = getLocalWebSocketURL();\n\nconst demoMode = args[\"demo\"] || false;\n\nmodule.exports = {\n    args,\n    hostname,\n    port,\n    sslKey,\n    sslCert,\n    sslKeyPassphrase,\n    isSSL,\n    localWebSocketURL,\n    demoMode,\n};\n", "let express = require(\"express\");\nconst {\n    setting,\n    allowDevAllOrigin,\n    allowAllOrigin,\n    percentageToColor,\n    filterAndJoin,\n    sendHttpError,\n} = require(\"../util-server\");\nconst { R } = require(\"redbean-node\");\nconst apicache = require(\"../modules/apicache\");\nconst Monitor = require(\"../model/monitor\");\nconst dayjs = require(\"dayjs\");\nconst { UP, MAINTENANCE, DOWN, PENDING, flipStatus, log, badgeConstants } = require(\"../../src/util\");\nconst StatusPage = require(\"../model/status_page\");\nconst { UptimeKumaServer } = require(\"../uptime-kuma-server\");\nconst { UptimeCacheList } = require(\"../uptime-cache-list\");\nconst { makeBadge } = require(\"badge-maker\");\nconst { Prometheus } = require(\"../prometheus\");\n\nlet router = express.Router();\n\nlet cache = apicache.middleware;\nconst server = UptimeKumaServer.getInstance();\nlet io = server.io;\n\nrouter.get(\"/api/entry-page\", async (request, response) => {\n    allowDevAllOrigin(response);\n\n    let result = { };\n    let hostname = request.hostname;\n    if ((await setting(\"trustProxy\")) && request.headers[\"x-forwarded-host\"]) {\n        hostname = request.headers[\"x-forwarded-host\"];\n    }\n\n    if (hostname in StatusPage.domainMappingList) {\n        result.type = \"statusPageMatchedDomain\";\n        result.statusPageSlug = StatusPage.domainMappingList[hostname];\n    } else {\n        result.type = \"entryPage\";\n        result.entryPage = server.entryPage;\n    }\n    response.json(result);\n});\n\nrouter.get(\"/api/push/:pushToken\", async (request, response) => {\n    try {\n\n        let pushToken = request.params.pushToken;\n        let msg = request.query.msg || \"OK\";\n        let ping = parseFloat(request.query.ping) || null;\n        let statusString = request.query.status || \"up\";\n        let status = (statusString === \"up\") ? UP : DOWN;\n\n        let monitor = await R.findOne(\"monitor\", \" push_token = ? AND active = 1 \", [\n            pushToken\n        ]);\n\n        if (! monitor) {\n            throw new Error(\"Monitor not found or not active.\");\n        }\n\n        const previousHeartbeat = await Monitor.getPreviousHeartbeat(monitor.id);\n\n        if (monitor.isUpsideDown()) {\n            status = flipStatus(status);\n        }\n\n        let isFirstBeat = true;\n        let previousStatus = status;\n        let duration = 0;\n\n        let bean = R.dispense(\"heartbeat\");\n        bean.time = R.isoDateTimeMillis(dayjs.utc());\n\n        if (previousHeartbeat) {\n            isFirstBeat = false;\n            previousStatus = previousHeartbeat.status;\n            duration = dayjs(bean.time).diff(dayjs(previousHeartbeat.time), \"second\");\n        }\n\n        if (await Monitor.isUnderMaintenance(monitor.id)) {\n            msg = \"Monitor under maintenance\";\n            status = MAINTENANCE;\n        }\n\n        log.debug(\"router\", `/api/push/ called at ${dayjs().format(\"YYYY-MM-DD HH:mm:ss.SSS\")}`);\n        log.debug(\"router\", \"PreviousStatus: \" + previousStatus);\n        log.debug(\"router\", \"Current Status: \" + status);\n\n        bean.important = Monitor.isImportantBeat(isFirstBeat, previousStatus, status);\n        bean.monitor_id = monitor.id;\n        bean.status = status;\n        bean.msg = msg;\n        bean.ping = ping;\n        bean.duration = duration;\n\n        await R.store(bean);\n\n        io.to(monitor.user_id).emit(\"heartbeat\", bean.toJSON());\n        UptimeCacheList.clearCache(monitor.id);\n        Monitor.sendStats(io, monitor.id, monitor.user_id);\n        new Prometheus(monitor).update(bean, undefined);\n\n        response.json({\n            ok: true,\n        });\n\n        if (Monitor.isImportantForNotification(isFirstBeat, previousStatus, status)) {\n            await Monitor.sendNotification(isFirstBeat, monitor, bean);\n        }\n\n    } catch (e) {\n        response.status(404).json({\n            ok: false,\n            msg: e.message\n        });\n    }\n});\n\nrouter.get(\"/api/badge/:id/status\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        upLabel = \"Up\",\n        downLabel = \"Down\",\n        pendingLabel = \"Pending\",\n        maintenanceLabel = \"Maintenance\",\n        upColor = badgeConstants.defaultUpColor,\n        downColor = badgeConstants.defaultDownColor,\n        pendingColor = badgeConstants.defaultPendingColor,\n        maintenanceColor = badgeConstants.defaultMaintenanceColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n        const overrideValue = value !== undefined ? parseInt(value) : undefined;\n\n        let publicMonitor = await R.getRow(`\n                SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND monitor_group.monitor_id = ?\n                AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const heartbeat = await Monitor.getPreviousHeartbeat(requestedMonitorId);\n            const state = overrideValue !== undefined ? overrideValue : heartbeat.status;\n\n            if (label === undefined) {\n                badgeValues.label = \"Status\";\n            } else {\n                badgeValues.label = label;\n            }\n            switch (state) {\n                case DOWN:\n                    badgeValues.color = downColor;\n                    badgeValues.message = downLabel;\n                    break;\n                case UP:\n                    badgeValues.color = upColor;\n                    badgeValues.message = upLabel;\n                    break;\n                case PENDING:\n                    badgeValues.color = pendingColor;\n                    badgeValues.message = pendingLabel;\n                    break;\n                case MAINTENANCE:\n                    badgeValues.color = maintenanceColor;\n                    badgeValues.message = maintenanceLabel;\n                    break;\n                default:\n                    badgeValues.color = badgeConstants.naColor;\n                    badgeValues.message = \"N/A\";\n            }\n        }\n\n        // build the svg based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/uptime/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix = badgeConstants.defaultUptimeLabelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultUptimeValueSuffix,\n        color,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n        // if no duration is given, set value to 24 (h)\n        const requestedDuration = request.params.duration !== undefined ? parseInt(request.params.duration, 10) : 24;\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n                SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND monitor_group.monitor_id = ?\n                AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const uptime = overrideValue ?? await Monitor.calcUptime(\n                requestedDuration,\n                requestedMonitorId\n            );\n\n            // limit the displayed uptime percentage to four (two, when displayed as percent) decimal digits\n            const cleanUptime = (uptime * 100).toPrecision(4);\n\n            // use a given, custom color or calculate one based on the uptime value\n            badgeValues.color = color ?? percentageToColor(uptime);\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a label string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([\n                labelPrefix,\n                label ?? `Uptime (${requestedDuration}${labelSuffix})`,\n            ]);\n            badgeValues.message = filterAndJoin([ prefix, cleanUptime, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/ping/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix = badgeConstants.defaultPingLabelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        // Default duration is 24 (h) if not defined in queryParam, limited to 720h (30d)\n        const requestedDuration = Math.min(request.params.duration ? parseInt(request.params.duration, 10) : 24, 720);\n        const overrideValue = value && parseFloat(value);\n\n        const publicAvgPing = parseInt(await R.getCell(`\n                SELECT AVG(ping) FROM monitor_group, \\`group\\`, heartbeat\n                WHERE monitor_group.group_id = \\`group\\`.id\n                AND heartbeat.time > DATETIME('now', ? || ' hours')\n                AND heartbeat.ping IS NOT NULL\n                AND public = 1\n                AND heartbeat.monitor_id = ?\n            `,\n        [ -requestedDuration, requestedMonitorId ]\n        ));\n\n        const badgeValues = { style };\n\n        if (!publicAvgPing) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const avgPing = parseInt(overrideValue ?? publicAvgPing);\n\n            badgeValues.color = color;\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a lable string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([ labelPrefix, label ?? `Avg. Ping (${requestedDuration}${labelSuffix})` ]);\n            badgeValues.message = filterAndJoin([ prefix, avgPing, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/avg-response/:duration?\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        // Default duration is 24 (h) if not defined in queryParam, limited to 720h (30d)\n        const requestedDuration = Math.min(\n            request.params.duration\n                ? parseInt(request.params.duration, 10)\n                : 24,\n            720\n        );\n        const overrideValue = value && parseFloat(value);\n\n        const publicAvgPing = parseInt(await R.getCell(`\n            SELECT AVG(ping) FROM monitor_group, \\`group\\`, heartbeat\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND heartbeat.time > DATETIME('now', ? || ' hours')\n            AND heartbeat.ping IS NOT NULL\n            AND public = 1\n            AND heartbeat.monitor_id = ?\n            `,\n        [ -requestedDuration, requestedMonitorId ]\n        ));\n\n        const badgeValues = { style };\n\n        if (!publicAvgPing) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const avgPing = parseInt(overrideValue ?? publicAvgPing);\n\n            badgeValues.color = color;\n            // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n            badgeValues.labelColor = labelColor ?? \"\";\n            // build a label string. If a custom label is given, override the default one (requestedDuration)\n            badgeValues.label = filterAndJoin([\n                labelPrefix,\n                label ?? `Avg. Response (${requestedDuration}h)`,\n                labelSuffix,\n            ]);\n            badgeValues.message = filterAndJoin([ prefix, avgPing, suffix ]);\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/cert-exp\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const date = request.query.date;\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = date ? \"\" : badgeConstants.defaultCertExpValueSuffix,\n        upColor = badgeConstants.defaultUpColor,\n        warnColor = badgeConstants.defaultWarnColor,\n        downColor = badgeConstants.defaultDownColor,\n        warnDays = badgeConstants.defaultCertExpireWarnDays,\n        downDays = badgeConstants.defaultCertExpireDownDays,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND monitor_group.monitor_id = ?\n            AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const tlsInfoBean = await R.findOne(\"monitor_tls_info\", \"monitor_id = ?\", [\n                requestedMonitorId,\n            ]);\n\n            if (!tlsInfoBean) {\n                // return a \"No/Bad Cert\" badge in naColor (grey), if no cert saved (does not save bad certs?)\n                badgeValues.message = \"No/Bad Cert\";\n                badgeValues.color = badgeConstants.naColor;\n            } else {\n                const tlsInfo = JSON.parse(tlsInfoBean.info_json);\n\n                if (!tlsInfo.valid) {\n                    // return a \"Bad Cert\" badge in naColor (grey), when cert is not valid\n                    badgeValues.message = \"Bad Cert\";\n                    badgeValues.color = downColor;\n                } else {\n                    const daysRemaining = parseInt(overrideValue ?? tlsInfo.certInfo.daysRemaining);\n\n                    if (daysRemaining > warnDays) {\n                        badgeValues.color = upColor;\n                    } else if (daysRemaining > downDays) {\n                        badgeValues.color = warnColor;\n                    } else {\n                        badgeValues.color = downColor;\n                    }\n                    // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n                    badgeValues.labelColor = labelColor ?? \"\";\n                    // build a label string. If a custom label is given, override the default one\n                    badgeValues.label = filterAndJoin([\n                        labelPrefix,\n                        label ?? \"Cert Exp.\",\n                        labelSuffix,\n                    ]);\n                    badgeValues.message = filterAndJoin([ prefix, date ? tlsInfo.certInfo.validTo : daysRemaining, suffix ]);\n                }\n            }\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nrouter.get(\"/api/badge/:id/response\", cache(\"5 minutes\"), async (request, response) => {\n    allowAllOrigin(response);\n\n    const {\n        label,\n        labelPrefix,\n        labelSuffix,\n        prefix,\n        suffix = badgeConstants.defaultPingValueSuffix,\n        color = badgeConstants.defaultPingColor,\n        labelColor,\n        style = badgeConstants.defaultStyle,\n        value, // for demo purpose only\n    } = request.query;\n\n    try {\n        const requestedMonitorId = parseInt(request.params.id, 10);\n\n        const overrideValue = value && parseFloat(value);\n\n        let publicMonitor = await R.getRow(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND monitor_group.monitor_id = ?\n            AND public = 1\n            `,\n        [ requestedMonitorId ]\n        );\n\n        const badgeValues = { style };\n\n        if (!publicMonitor) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non existent\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n        } else {\n            const heartbeat = await Monitor.getPreviousHeartbeat(\n                requestedMonitorId\n            );\n\n            if (!heartbeat.ping) {\n                // return a \"N/A\" badge in naColor (grey), if previous heartbeat has no ping\n\n                badgeValues.message = \"N/A\";\n                badgeValues.color = badgeConstants.naColor;\n            } else {\n                const ping = parseInt(overrideValue ?? heartbeat.ping);\n\n                badgeValues.color = color;\n                // use a given, custom labelColor or use the default badge label color (defined by badge-maker)\n                badgeValues.labelColor = labelColor ?? \"\";\n                // build a label string. If a custom label is given, override the default one\n                badgeValues.label = filterAndJoin([\n                    labelPrefix,\n                    label ?? \"Response\",\n                    labelSuffix,\n                ]);\n                badgeValues.message = filterAndJoin([ prefix, ping, suffix ]);\n            }\n        }\n\n        // build the SVG based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nmodule.exports = router;\n", "let express = require(\"express\");\nconst apicache = require(\"../modules/apicache\");\nconst { UptimeKumaServer } = require(\"../uptime-kuma-server\");\nconst StatusPage = require(\"../model/status_page\");\nconst { allowDevAllOrigin, sendHttpError } = require(\"../util-server\");\nconst { R } = require(\"redbean-node\");\nconst Monitor = require(\"../model/monitor\");\nconst { badgeConstants } = require(\"../../src/util\");\nconst { makeBadge } = require(\"badge-maker\");\n\nlet router = express.Router();\n\nlet cache = apicache.middleware;\nconst server = UptimeKumaServer.getInstance();\n\nrouter.get(\"/status/:slug\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = request.params.slug;\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\nrouter.get(\"/status\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = \"default\";\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\nrouter.get(\"/status-page\", cache(\"5 minutes\"), async (request, response) => {\n    let slug = \"default\";\n    await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n});\n\n// Status page config, incident, monitor list\nrouter.get(\"/api/status-page/:slug\", cache(\"5 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    let slug = request.params.slug;\n\n    try {\n        // Get Status Page\n        let statusPage = await R.findOne(\"status_page\", \" slug = ? \", [\n            slug\n        ]);\n\n        if (!statusPage) {\n            return null;\n        }\n\n        let statusPageData = await StatusPage.getStatusPageData(statusPage);\n\n        if (!statusPageData) {\n            sendHttpError(response, \"Not Found\");\n            return;\n        }\n\n        // Response\n        response.json(statusPageData);\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// Status Page Polling Data\n// Can fetch only if published\nrouter.get(\"/api/status-page/heartbeat/:slug\", cache(\"1 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n\n    try {\n        let heartbeatList = {};\n        let uptimeList = {};\n\n        let slug = request.params.slug;\n        let statusPageID = await StatusPage.slugToID(slug);\n\n        let monitorIDList = await R.getCol(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND public = 1\n            AND \\`group\\`.status_page_id = ?\n        `, [\n            statusPageID\n        ]);\n\n        for (let monitorID of monitorIDList) {\n            let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ?\n                    ORDER BY time DESC\n                    LIMIT 50\n            `, [\n                monitorID,\n            ]);\n\n            list = R.convertToBeans(\"heartbeat\", list);\n            heartbeatList[monitorID] = list.reverse().map(row => row.toPublicJSON());\n\n            const type = 24;\n            uptimeList[`${monitorID}_${type}`] = await Monitor.calcUptime(type, monitorID);\n        }\n\n        response.json({\n            heartbeatList,\n            uptimeList\n        });\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// Status page's manifest.json\nrouter.get(\"/api/status-page/:slug/manifest.json\", cache(\"1440 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    let slug = request.params.slug;\n\n    try {\n        // Get Status Page\n        let statusPage = await R.findOne(\"status_page\", \" slug = ? \", [\n            slug\n        ]);\n\n        if (!statusPage) {\n            sendHttpError(response, \"Not Found\");\n            return;\n        }\n\n        // Response\n        response.json({\n            \"name\": statusPage.title,\n            \"start_url\": \"/status/\" + statusPage.slug,\n            \"display\": \"standalone\",\n            \"icons\": [\n                {\n                    \"src\": statusPage.icon,\n                    \"sizes\": \"128x128\",\n                    \"type\": \"image/png\"\n                }\n            ]\n        });\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\n// overall status-page status badge\nrouter.get(\"/api/status-page/:slug/badge\", cache(\"5 minutes\"), async (request, response) => {\n    allowDevAllOrigin(response);\n    const slug = request.params.slug;\n    const statusPageID = await StatusPage.slugToID(slug);\n    const {\n        label,\n        upColor = badgeConstants.defaultUpColor,\n        downColor = badgeConstants.defaultDownColor,\n        partialColor = \"#F6BE00\",\n        maintenanceColor = \"#808080\",\n        style = badgeConstants.defaultStyle\n    } = request.query;\n\n    try {\n        let monitorIDList = await R.getCol(`\n            SELECT monitor_group.monitor_id FROM monitor_group, \\`group\\`\n            WHERE monitor_group.group_id = \\`group\\`.id\n            AND public = 1\n            AND \\`group\\`.status_page_id = ?\n        `, [\n            statusPageID\n        ]);\n\n        let hasUp = false;\n        let hasDown = false;\n        let hasMaintenance = false;\n\n        for (let monitorID of monitorIDList) {\n            // retrieve the latest heartbeat\n            let beat = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ?\n                    ORDER BY time DESC\n                    LIMIT 1\n            `, [\n                monitorID,\n            ]);\n\n            // to be sure, when corresponding monitor not found\n            if (beat.length === 0) {\n                continue;\n            }\n            // handle status of beat\n            if (beat[0].status === 3) {\n                hasMaintenance = true;\n            } else if (beat[0].status === 2) {\n                // ignored\n            } else if (beat[0].status === 1) {\n                hasUp = true;\n            } else {\n                hasDown = true;\n            }\n\n        }\n\n        const badgeValues = { style };\n\n        if (!hasUp && !hasDown && !hasMaintenance) {\n            // return a \"N/A\" badge in naColor (grey), if monitor is not public / not available / non exsitant\n\n            badgeValues.message = \"N/A\";\n            badgeValues.color = badgeConstants.naColor;\n\n        } else {\n            if (hasMaintenance) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = maintenanceColor;\n                badgeValues.message = \"Maintenance\";\n            } else if (hasUp && !hasDown) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = upColor;\n                badgeValues.message = \"Up\";\n            } else if (hasUp && hasDown) {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = partialColor;\n                badgeValues.message = \"Degraded\";\n            } else {\n                badgeValues.label = label ? label : \"\";\n                badgeValues.color = downColor;\n                badgeValues.message = \"Down\";\n            }\n\n        }\n\n        // build the svg based on given values\n        const svg = makeBadge(badgeValues);\n\n        response.type(\"image/svg+xml\");\n        response.send(svg);\n\n    } catch (error) {\n        sendHttpError(response, error.message);\n    }\n});\n\nmodule.exports = router;\n", "/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nif (!process.env.UPTIME_KUMA_WS_ORIGIN_CHECK) {\n    process.env.UPTIME_KUMA_WS_ORIGIN_CHECK = \"cors-like\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\nlog.info(\"server\", \"WebSocket Origin Check: \" + process.env.UPTIME_KUMA_WS_ORIGIN_CHECK);\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance();\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nconst User = require(\"./model/user\");\n\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, doubleCheckPassword, startE2eTests, shake256, SHAKE256_LENGTH\n} = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\nconst hostname = config.hostname;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = config.port;\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                if (user) {\n                    // Check if the password changed\n                    if (decoded.h !== shake256(user.password, SHAKE256_LENGTH)) {\n                        throw new Error(\"The token is invalid due to password change or old token\");\n                    }\n\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n                if (error.message) {\n                    log.error(\"auth\", error.message, `IP=${clientIP}`);\n                }\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: User.createJWT(user, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: User.createJWT(user, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.kafkaProducerSsl = monitor.kafkaProducerSsl;\n                bean.kafkaProducerAllowAutoTopicCreation =\n                    monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                server.disconnectAllSocketClient(user.id, socket.id);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        await server.startNSCDServices();\n                    } else {\n                        await server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n        server.monitorList[monitorID].active = 0;\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nlet unexpectedErrorHandler = (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n};\nprocess.addListener(\"unhandledRejection\", unexpectedErrorHandler);\nprocess.addListener(\"uncaughtException\", unexpectedErrorHandler);\n", "const { log } = require(\"../../src/util\");\nconst { Settings } = require(\"../settings\");\nconst { sendInfo } = require(\"../client\");\nconst { checkLogin } = require(\"../util-server\");\nconst GameResolver = require(\"gamedig/lib/GameResolver\");\nconst { testChrome } = require(\"../monitor-types/real-browser-monitor-type\");\n\nlet gameResolver = new GameResolver();\nlet gameList = null;\n\n/**\n * Get a game list via GameDig\n * @returns {Object[]} list of games supported by GameDig\n */\nfunction getGameList() {\n    if (gameList == null) {\n        gameList = gameResolver._readGames().games.sort((a, b) => {\n            if ( a.pretty < b.pretty ) {\n                return -1;\n            }\n            if ( a.pretty > b.pretty ) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    return gameList;\n}\n\nmodule.exports.generalSocketHandler = (socket, server) => {\n\n    socket.on(\"initServerTimezone\", async (timezone) => {\n        try {\n            checkLogin(socket);\n            log.debug(\"generalSocketHandler\", \"Timezone: \" + timezone);\n            await Settings.set(\"initServerTimezone\", true);\n            await server.setTimezone(timezone);\n            await sendInfo(socket);\n        } catch (e) {\n            log.warn(\"initServerTimezone\", e.message);\n        }\n    });\n\n    socket.on(\"getGameList\", async (callback) => {\n        try {\n            checkLogin(socket);\n            callback({\n                ok: true,\n                gameList: getGameList(),\n            });\n        } catch (e) {\n            callback({\n                ok: false,\n                msg: e.message,\n            });\n        }\n    });\n\n    socket.on(\"testChrome\", (executable, callback) => {\n        try {\n            checkLogin(socket);\n            // Just noticed that await call could block the whole socket.io server!!! Use pure promise instead.\n            testChrome(executable).then((version) => {\n                callback({\n                    ok: true,\n                    msg: \"Found Chromium/Chrome. Version: \" + version,\n                });\n            }).catch((e) => {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            });\n        } catch (e) {\n            callback({\n                ok: false,\n                msg: e.message,\n            });\n        }\n    });\n\n    // Disconnect all other socket clients of the user\n    socket.on(\"disconnectOtherSocketClients\", async () => {\n        try {\n            checkLogin(socket);\n            server.disconnectAllSocketClients(socket.userID, socket.id);\n        } catch (e) {\n            log.warn(\"disconnectAllSocketClients\", e.message);\n        }\n    });\n};\n", "const express = require(\"express\");\nconst https = require(\"https\");\nconst fs = require(\"fs\");\nconst http = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst { R } = require(\"redbean-node\");\nconst { log, isDev } = require(\"../src/util\");\nconst Database = require(\"./database\");\nconst util = require(\"util\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst { Settings } = require(\"./settings\");\nconst dayjs = require(\"dayjs\");\nconst childProcessAsync = require(\"promisify-child-process\");\nconst path = require(\"path\");\nconst { isSSL, sslKey, sslCert, sslKeyPassphrase } = require(\"./config\");\n// DO NOT IMPORT HERE IF THE MODULES USED `UptimeKumaServer.getInstance()`, put at the bottom of this file instead.\n\n/**\n * `module.exports` (alias: `server`) should be inside this class, in order to avoid circular dependency issue.\n * @type {UptimeKumaServer}\n */\nclass UptimeKumaServer {\n    /**\n     *\n     * @type {UptimeKumaServer}\n     */\n    static instance = null;\n\n    /**\n     * Main monitor list\n     * @type {{}}\n     */\n    monitorList = {};\n\n    /**\n     * Main maintenance list\n     * @type {{}}\n     */\n    maintenanceList = {};\n\n    entryPage = \"dashboard\";\n    app = undefined;\n    httpServer = undefined;\n    io = undefined;\n\n    /**\n     * Cache Index HTML\n     * @type {string}\n     */\n    indexHTML = \"\";\n\n    /**\n     *\n     * @type {{}}\n     */\n    static monitorTypeList = {\n\n    };\n\n    /**\n     * Use for decode the auth object\n     * @type {null}\n     */\n    jwtSecret = null;\n\n    static getInstance() {\n        if (UptimeKumaServer.instance == null) {\n            UptimeKumaServer.instance = new UptimeKumaServer();\n        }\n        return UptimeKumaServer.instance;\n    }\n\n    constructor() {\n        log.info(\"server\", \"Creating express and socket.io instance\");\n        this.app = express();\n        if (isSSL) {\n            log.info(\"server\", \"Server Type: HTTPS\");\n            this.httpServer = https.createServer({\n                key: fs.readFileSync(sslKey),\n                cert: fs.readFileSync(sslCert),\n                passphrase: sslKeyPassphrase,\n            }, this.app);\n        } else {\n            log.info(\"server\", \"Server Type: HTTP\");\n            this.httpServer = http.createServer(this.app);\n        }\n\n        try {\n            this.indexHTML = fs.readFileSync(\"./dist/index.html\").toString();\n        } catch (e) {\n            // \"dist/index.html\" is not necessary for development\n            if (process.env.NODE_ENV !== \"development\") {\n                log.error(\"server\", \"Error: Cannot find 'dist/index.html', did you install correctly?\");\n                process.exit(1);\n            }\n        }\n\n        // Set Monitor Types\n        UptimeKumaServer.monitorTypeList[\"real-browser\"] = new RealBrowserMonitorType();\n        UptimeKumaServer.monitorTypeList[\"tailscale-ping\"] = new TailscalePing();\n\n        this.io = new Server(this.httpServer, {\n            allowRequest: (req, callback) => {\n                let isOriginValid = true;\n                const bypass = isDev || process.env.UPTIME_KUMA_WS_ORIGIN_CHECK === \"bypass\";\n\n                if (!bypass) {\n                    let host = req.headers.host;\n\n                    // If this is set, it means the request is from the browser\n                    let origin = req.headers.origin;\n\n                    // If this is from the browser, check if the origin is allowed\n                    if (origin) {\n                        try {\n                            let originURL = new URL(origin);\n\n                            if (host !== originURL.host) {\n                                isOriginValid = false;\n                                log.error(\"auth\", `Origin (${origin}) does not match host (${host}), IP: ${req.socket.remoteAddress}`);\n                            }\n                        } catch (e) {\n                            // Invalid origin url, probably not from browser\n                            isOriginValid = false;\n                            log.error(\"auth\", `Invalid origin url (${origin}), IP: ${req.socket.remoteAddress}`);\n                        }\n                    } else {\n                        log.info(\"auth\", `Origin is not set, IP: ${req.socket.remoteAddress}`);\n                    }\n                } else {\n                    log.debug(\"auth\", \"Origin check is bypassed\");\n                }\n\n                callback(null, isOriginValid);\n            }\n        });\n    }\n\n    /** Initialise app after the database has been set up */\n    async initAfterDatabaseReady() {\n        // Static\n        this.app.use(\"/screenshots\", express.static(Database.screenshotDir));\n\n        await CacheableDnsHttpAgent.update();\n\n        process.env.TZ = await this.getTimezone();\n        dayjs.tz.setDefault(process.env.TZ);\n        log.debug(\"DEBUG\", \"Timezone: \" + process.env.TZ);\n        log.debug(\"DEBUG\", \"Current Time: \" + dayjs.tz().format());\n\n        await this.loadMaintenanceList();\n    }\n\n    /**\n     * Send list of monitors to client\n     * @param {Socket} socket\n     * @returns {Object} List of monitors\n     */\n    async sendMonitorList(socket) {\n        let list = await this.getMonitorJSONList(socket.userID);\n        this.io.to(socket.userID).emit(\"monitorList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of monitors for the given user.\n     * @param {string} userID - The ID of the user to get monitors for.\n     * @returns {Promise<Object>} A promise that resolves to an object with monitor IDs as keys and monitor objects as values.\n     *\n     * Generated by Trelent\n     */\n    async getMonitorJSONList(userID) {\n        let result = {};\n\n        let monitorList = await R.find(\"monitor\", \" user_id = ? ORDER BY weight DESC, name\", [\n            userID,\n        ]);\n\n        for (let monitor of monitorList) {\n            result[monitor.id] = await monitor.toJSON();\n        }\n\n        return result;\n    }\n\n    /**\n     * Send maintenance list to client\n     * @param {Socket} socket Socket.io instance to send to\n     * @returns {Object}\n     */\n    async sendMaintenanceList(socket) {\n        return await this.sendMaintenanceListByUserID(socket.userID);\n    }\n\n    /**\n     * Send list of maintenances to user\n     * @param {number} userID\n     * @returns {Object}\n     */\n    async sendMaintenanceListByUserID(userID) {\n        let list = await this.getMaintenanceJSONList(userID);\n        this.io.to(userID).emit(\"maintenanceList\", list);\n        return list;\n    }\n\n    /**\n     * Get a list of maintenances for the given user.\n     * @param {string} userID - The ID of the user to get maintenances for.\n     * @returns {Promise<Object>} A promise that resolves to an object with maintenance IDs as keys and maintenances objects as values.\n     */\n    async getMaintenanceJSONList(userID) {\n        let result = {};\n        for (let maintenanceID in this.maintenanceList) {\n            result[maintenanceID] = await this.maintenanceList[maintenanceID].toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Load maintenance list and run\n     * @param userID\n     * @returns {Promise<void>}\n     */\n    async loadMaintenanceList(userID) {\n        let maintenanceList = await R.findAll(\"maintenance\", \" ORDER BY end_date DESC, title\", [\n\n        ]);\n\n        for (let maintenance of maintenanceList) {\n            this.maintenanceList[maintenance.id] = maintenance;\n            maintenance.run(this);\n        }\n    }\n\n    getMaintenance(maintenanceID) {\n        if (this.maintenanceList[maintenanceID]) {\n            return this.maintenanceList[maintenanceID];\n        }\n        return null;\n    }\n\n    /**\n     * Write error to log file\n     * @param {any} error The error to write\n     * @param {boolean} outputToConsole Should the error also be output to console?\n     */\n    static errorLog(error, outputToConsole = true) {\n        const errorLogStream = fs.createWriteStream(path.join(Database.dataDir, \"/error.log\"), {\n            flags: \"a\"\n        });\n\n        errorLogStream.on(\"error\", () => {\n            log.info(\"\", \"Cannot write to error.log\");\n        });\n\n        if (errorLogStream) {\n            const dateTime = R.isoDateTime();\n            errorLogStream.write(`[${dateTime}] ` + util.format(error) + \"\\n\");\n\n            if (outputToConsole) {\n                console.error(error);\n            }\n        }\n\n        errorLogStream.end();\n    }\n\n    /**\n     * Get the IP of the client connected to the socket\n     * @param {Socket} socket\n     * @returns {string}\n     */\n    async getClientIP(socket) {\n        let clientIP = socket.client.conn.remoteAddress;\n\n        if (clientIP === undefined) {\n            clientIP = \"\";\n        }\n\n        if (await Settings.get(\"trustProxy\")) {\n            const forwardedFor = socket.client.conn.request.headers[\"x-forwarded-for\"];\n\n            return (typeof forwardedFor === \"string\" ? forwardedFor.split(\",\")[0].trim() : null)\n                || socket.client.conn.request.headers[\"x-real-ip\"]\n                || clientIP.replace(/^::ffff:/, \"\");\n        } else {\n            return clientIP.replace(/^::ffff:/, \"\");\n        }\n    }\n\n    /**\n     * Attempt to get the current server timezone\n     * If this fails, fall back to environment variables and then make a\n     * guess.\n     * @returns {Promise<string>}\n     */\n    async getTimezone() {\n        // From process.env.TZ\n        try {\n            if (process.env.TZ) {\n                this.checkTimezone(process.env.TZ);\n                return process.env.TZ;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in process.env.TZ\");\n        }\n\n        let timezone = await Settings.get(\"serverTimezone\");\n\n        // From Settings\n        try {\n            log.debug(\"timezone\", \"Using timezone from settings: \" + timezone);\n            if (timezone) {\n                this.checkTimezone(timezone);\n                return timezone;\n            }\n        } catch (e) {\n            log.warn(\"timezone\", e.message + \" in settings\");\n        }\n\n        // Guess\n        try {\n            let guess = dayjs.tz.guess();\n            log.debug(\"timezone\", \"Guessing timezone: \" + guess);\n            if (guess) {\n                this.checkTimezone(guess);\n                return guess;\n            } else {\n                return \"UTC\";\n            }\n        } catch (e) {\n            // Guess failed, fall back to UTC\n            log.debug(\"timezone\", \"Guessed an invalid timezone. Use UTC as fallback\");\n            return \"UTC\";\n        }\n    }\n\n    /**\n     * Get the current offset\n     * @returns {string}\n     */\n    getTimezoneOffset() {\n        return dayjs().format(\"Z\");\n    }\n\n    /**\n     * Throw an error if the timezone is invalid\n     * @param timezone\n     */\n    checkTimezone(timezone) {\n        try {\n            dayjs.utc(\"2013-11-18 11:55\").tz(timezone).format();\n        } catch (e) {\n            throw new Error(\"Invalid timezone:\" + timezone);\n        }\n    }\n\n    /**\n     * Set the current server timezone and environment variables\n     * @param {string} timezone\n     */\n    async setTimezone(timezone) {\n        this.checkTimezone(timezone);\n        await Settings.set(\"serverTimezone\", timezone, \"general\");\n        process.env.TZ = timezone;\n        dayjs.tz.setDefault(timezone);\n    }\n\n    /**\n     * TODO: Listen logic should be moved to here\n     * @returns {Promise<void>}\n     */\n    async start() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.startNSCDServices();\n        }\n    }\n\n    /**\n     * Stop the server\n     * @returns {Promise<void>}\n     */\n    async stop() {\n        let enable = await Settings.get(\"nscd\");\n\n        if (enable || enable === null) {\n            await this.stopNSCDServices();\n        }\n    }\n\n    /**\n     * Start all system services (e.g. nscd)\n     * For now, only used in Docker\n     */\n    async startNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Starting nscd\");\n                await childProcessAsync.exec(\"sudo service nscd start\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to start nscd\");\n            }\n        }\n    }\n\n    /**\n     * Stop all system services\n     */\n    async stopNSCDServices() {\n        if (process.env.UPTIME_KUMA_IS_CONTAINER) {\n            try {\n                log.info(\"services\", \"Stopping nscd\");\n                await childProcessAsync.exec(\"sudo service nscd stop\");\n            } catch (e) {\n                log.info(\"services\", \"Failed to stop nscd\");\n            }\n        }\n    }\n\n    /**\n     * Force connected sockets of a user to refresh and disconnect.\n     * Used for resetting password.\n     * @param {string} userID\n     * @param {string?} currentSocketID\n     */\n    disconnectAllSocketClients(userID, currentSocketID = undefined) {\n        for (const socket of this.io.sockets.sockets.values()) {\n            if (socket.userID === userID && socket.id !== currentSocketID) {\n                try {\n                    socket.emit(\"refresh\");\n                    socket.disconnect();\n                } catch (e) {\n\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    UptimeKumaServer\n};\n\n// Must be at the end to avoid circular dependencies\nconst { RealBrowserMonitorType } = require(\"./monitor-types/real-browser-monitor-type\");\nconst { TailscalePing } = require(\"./monitor-types/tailscale-ping\");\n", "const tcpp = require(\"tcp-ping\");\nconst ping = require(\"@louislam/ping\");\nconst { R } = require(\"redbean-node\");\nconst { log, genSecret, badgeConstants } = require(\"../src/util\");\nconst passwordHash = require(\"./password-hash\");\nconst { Resolver } = require(\"dns\");\nconst childProcess = require(\"child_process\");\nconst iconv = require(\"iconv-lite\");\nconst chardet = require(\"chardet\");\nconst mqtt = require(\"mqtt\");\nconst chroma = require(\"chroma-js\");\nconst mssql = require(\"mssql\");\nconst { Client } = require(\"pg\");\nconst postgresConParse = require(\"pg-connection-string\").parse;\nconst mysql = require(\"mysql2\");\nconst { MongoClient } = require(\"mongodb\");\nconst { NtlmClient } = require(\"axios-ntlm\");\nconst { Settings } = require(\"./settings\");\nconst grpc = require(\"@grpc/grpc-js\");\nconst protojs = require(\"protobufjs\");\nconst radiusClient = require(\"node-radius-client\");\nconst redis = require(\"redis\");\nconst oidc = require(\"openid-client\");\nconst tls = require(\"tls\");\n\nconst {\n    dictionaries: {\n        rfc2865: { file, attributes },\n    },\n} = require(\"node-radius-utils\");\nconst dayjs = require(\"dayjs\");\n\n// SASLOptions used in JSDoc\n// eslint-disable-next-line no-unused-vars\nconst { Kafka, SASLOptions } = require(\"kafkajs\");\nconst crypto = require(\"crypto\");\n\nconst isWindows = process.platform === /^win/.test(process.platform);\n/**\n * Init or reset JWT secret\n * @returns {Promise<Bean>}\n */\nexports.initJWTSecret = async () => {\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (!jwtSecretBean) {\n        jwtSecretBean = R.dispense(\"setting\");\n        jwtSecretBean.key = \"jwtSecret\";\n    }\n\n    jwtSecretBean.value = passwordHash.generate(genSecret());\n    await R.store(jwtSecretBean);\n    return jwtSecretBean;\n};\n\n/**\n * Decodes a jwt and returns the payload portion without verifying the jqt.\n * @param {string} jwt The input jwt as a string\n * @returns {Object} Decoded jwt payload object\n */\nexports.decodeJwt = (jwt) => {\n    return JSON.parse(Buffer.from(jwt.split(\".\")[1], \"base64\").toString());\n};\n\n/**\n * Gets a Access Token form a oidc/oauth2 provider\n * @param {string} tokenEndpoint The token URI form the auth service provider\n * @param {string} clientId The oidc/oauth application client id\n * @param {string} clientSecret The oidc/oauth application client secret\n * @param {string} scope The scope the for which the token should be issued for\n * @param {string} authMethod The method on how to sent the credentials. Default client_secret_basic\n * @returns {Promise<oidc.TokenSet>} TokenSet promise if the token request was successful\n */\nexports.getOidcTokenClientCredentials = async (tokenEndpoint, clientId, clientSecret, scope, authMethod = \"client_secret_basic\") => {\n    const oauthProvider = new oidc.Issuer({ token_endpoint: tokenEndpoint });\n    let client = new oauthProvider.Client({\n        client_id: clientId,\n        client_secret: clientSecret,\n        token_endpoint_auth_method: authMethod\n    });\n\n    // Increase default timeout and clock tolerance\n    client[oidc.custom.http_options] = () => ({ timeout: 10000 });\n    client[oidc.custom.clock_tolerance] = 5;\n\n    let grantParams = { grant_type: \"client_credentials\" };\n    if (scope) {\n        grantParams.scope = scope;\n    }\n    return await client.grant(grantParams);\n};\n\n/**\n * Send TCP request to specified hostname and port\n * @param {string} hostname Hostname / address of machine\n * @param {number} port TCP port to test\n * @returns {Promise<number>} Maximum time in ms rounded to nearest integer\n */\nexports.tcping = function (hostname, port) {\n    return new Promise((resolve, reject) => {\n        tcpp.ping({\n            address: hostname,\n            port: port,\n            attempts: 1,\n        }, function (err, data) {\n\n            if (err) {\n                reject(err);\n            }\n\n            if (data.results.length >= 1 && data.results[0].err) {\n                reject(data.results[0].err);\n            }\n\n            resolve(Math.round(data.max));\n        });\n    });\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine\n * @param {number} [size=56] Size of packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.ping = async (hostname, size = 56) => {\n    try {\n        return await exports.pingAsync(hostname, false, size);\n    } catch (e) {\n        // If the host cannot be resolved, try again with ipv6\n        console.debug(\"ping\", \"IPv6 error message: \" + e.message);\n\n        // As node-ping does not report a specific error for this, try again if it is an empty message with ipv6 no matter what.\n        if (!e.message) {\n            return await exports.pingAsync(hostname, true, size);\n        } else {\n            throw e;\n        }\n    }\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine to ping\n * @param {boolean} ipv6 Should IPv6 be used?\n * @param {number} [size = 56] Size of ping packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.pingAsync = function (hostname, ipv6 = false, size = 56) {\n    return new Promise((resolve, reject) => {\n        ping.promise.probe(hostname, {\n            v6: ipv6,\n            min_reply: 1,\n            deadline: 10,\n            packetSize: size,\n        }).then((res) => {\n            // If ping failed, it will set field to unknown\n            if (res.alive) {\n                resolve(res.time);\n            } else {\n                if (isWindows) {\n                    reject(new Error(exports.convertToUTF8(res.output)));\n                } else {\n                    reject(new Error(res.output));\n                }\n            }\n        }).catch((err) => {\n            reject(err);\n        });\n    });\n};\n\n/**\n * MQTT Monitor\n * @param {string} hostname Hostname / address of machine to test\n * @param {string} topic MQTT topic\n * @param {string} okMessage Expected result\n * @param {Object} [options={}] MQTT options. Contains port, username,\n * password and interval (interval defaults to 20)\n * @returns {Promise<string>}\n */\nexports.mqttAsync = function (hostname, topic, okMessage, options = {}) {\n    return new Promise((resolve, reject) => {\n        const { port, username, password, interval = 20 } = options;\n\n        // Adds MQTT protocol to the hostname if not already present\n        if (!/^(?:http|mqtt|ws)s?:\\/\\//.test(hostname)) {\n            hostname = \"mqtt://\" + hostname;\n        }\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"mqtt\", \"MQTT timeout triggered\");\n            client.end();\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        const mqttUrl = `${hostname}:${port}`;\n\n        log.debug(\"mqtt\", `MQTT connecting to ${mqttUrl}`);\n\n        let client = mqtt.connect(mqttUrl, {\n            username,\n            password\n        });\n\n        client.on(\"connect\", () => {\n            log.debug(\"mqtt\", \"MQTT connected\");\n\n            try {\n                log.debug(\"mqtt\", \"MQTT subscribe topic\");\n                client.subscribe(topic);\n            } catch (e) {\n                client.end();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Cannot subscribe topic\"));\n            }\n        });\n\n        client.on(\"error\", (error) => {\n            client.end();\n            clearTimeout(timeoutID);\n            reject(error);\n        });\n\n        client.on(\"message\", (messageTopic, message) => {\n            if (messageTopic === topic) {\n                client.end();\n                clearTimeout(timeoutID);\n                if (okMessage != null && okMessage !== \"\" && message.toString() !== okMessage) {\n                    reject(new Error(`Message Mismatch - Topic: ${messageTopic}; Message: ${message.toString()}`));\n                } else {\n                    resolve(`Topic: ${messageTopic}; Message: ${message.toString()}`);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Monitor Kafka using Producer\n * @param {string} topic Topic name to produce into\n * @param {string} message Message to produce\n * @param {Object} [options={interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\"}]\n * Kafka client options. Contains ssl, clientId, allowAutoTopicCreation and\n * interval (interval defaults to 20, allowAutoTopicCreation defaults to false, clientId defaults to \"Uptime-Kuma\"\n * and ssl defaults to false)\n * @param {string[]} brokers List of kafka brokers to connect, host and port joined by ':'\n * @param {SASLOptions} [saslOptions={}] Options for kafka client Authentication (SASL) (defaults to\n * {})\n * @returns {Promise<string>}\n */\nexports.kafkaProducerAsync = function (brokers, topic, message, options = {}, saslOptions = {}) {\n    return new Promise((resolve, reject) => {\n        const { interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\" } = options;\n\n        let connectedToKafka = false;\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"kafkaProducer\", \"KafkaProducer timeout triggered\");\n            connectedToKafka = true;\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        if (saslOptions.mechanism === \"None\") {\n            saslOptions = undefined;\n        }\n\n        let client = new Kafka({\n            brokers: brokers,\n            clientId: clientId,\n            sasl: saslOptions,\n            retry: {\n                retries: 0,\n            },\n            ssl: ssl,\n        });\n\n        let producer = client.producer({\n            allowAutoTopicCreation: allowAutoTopicCreation,\n            retry: {\n                retries: 0,\n            }\n        });\n\n        producer.connect().then(\n            () => {\n                producer.send({\n                    topic: topic,\n                    messages: [{\n                        value: message,\n                    }],\n                }).then((_) => {\n                    resolve(\"Message sent successfully\");\n                }).catch((e) => {\n                    connectedToKafka = true;\n                    producer.disconnect();\n                    clearTimeout(timeoutID);\n                    reject(new Error(\"Error sending message: \" + e.message));\n                }).finally(() => {\n                    connectedToKafka = true;\n                    clearTimeout(timeoutID);\n                });\n            }\n        ).catch(\n            (e) => {\n                connectedToKafka = true;\n                producer.disconnect();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Error in producer connection: \" + e.message));\n            }\n        );\n\n        producer.on(\"producer.network.request_timeout\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.network.request_timeout\"));\n            }\n        });\n\n        producer.on(\"producer.disconnect\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.disconnect\"));\n            }\n        });\n    });\n};\n\n/**\n * Use NTLM Auth for a http request.\n * @param {Object} options The http request options\n * @param {Object} ntlmOptions The auth options\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.httpNtlm = function (options, ntlmOptions) {\n    return new Promise((resolve, reject) => {\n        let client = NtlmClient(ntlmOptions);\n\n        client(options)\n            .then((resp) => {\n                resolve(resp);\n            })\n            .catch((err) => {\n                reject(err);\n            });\n    });\n};\n\n/**\n * Resolves a given record using the specified DNS server\n * @param {string} hostname The hostname of the record to lookup\n * @param {string} resolverServer The DNS server to use\n * @param {string} resolverPort Port the DNS server is listening on\n * @param {string} rrtype The type of record to request\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.dnsResolve = function (hostname, resolverServer, resolverPort, rrtype) {\n    const resolver = new Resolver();\n    // Remove brackets from IPv6 addresses so we can re-add them to\n    // prevent issues with ::1:5300 (::1 port 5300)\n    resolverServer = resolverServer.replace(\"[\", \"\").replace(\"]\", \"\");\n    resolver.setServers([ `[${resolverServer}]:${resolverPort}` ]);\n    return new Promise((resolve, reject) => {\n        if (rrtype === \"PTR\") {\n            resolver.reverse(hostname, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        } else {\n            resolver.resolve(hostname, rrtype, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        }\n    });\n};\n\n/**\n * Run a query on SQL Server\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mssqlQuery = async function (connectionString, query) {\n    let pool;\n    try {\n        pool = new mssql.ConnectionPool(connectionString);\n        await pool.connect();\n        if (!query) {\n            query = \"SELECT 1\";\n        }\n        await pool.request().query(query);\n        pool.close();\n    } catch (e) {\n        if (pool) {\n            pool.close();\n        }\n        throw e;\n    }\n};\n\n/**\n * Run a query on Postgres\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.postgresQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const config = postgresConParse(connectionString);\n\n        // Fix #3868, which true/false is not parsed to boolean\n        if (typeof config.ssl === \"string\") {\n            config.ssl = config.ssl === \"true\";\n        }\n\n        if (config.password === \"\") {\n            // See https://github.com/brianc/node-postgres/issues/1927\n            reject(new Error(\"Password is undefined.\"));\n            return;\n        }\n        const client = new Client(config);\n\n        client.on(\"error\", (error) => {\n            log.debug(\"postgres\", \"Error caught in the error event handler.\");\n            reject(error);\n        });\n\n        client.connect((err) => {\n            if (err) {\n                reject(err);\n                client.end();\n            } else {\n                // Connected here\n                try {\n                    // No query provided by user, use SELECT 1\n                    if (!query || (typeof query === \"string\" && query.trim() === \"\")) {\n                        query = \"SELECT 1\";\n                    }\n\n                    client.query(query, (err, res) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(res);\n                        }\n                        client.end();\n                    });\n                } catch (e) {\n                    reject(e);\n                    client.end();\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Run a query on MySQL/MariaDB\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @param {?string} password The password to use\n * @returns {Promise<(string)>}\n */\nexports.mysqlQuery = function (connectionString, query, password = undefined) {\n    return new Promise((resolve, reject) => {\n        const connection = mysql.createConnection({\n            uri: connectionString,\n            password\n        });\n\n        connection.on(\"error\", (err) => {\n            reject(err);\n        });\n\n        connection.query(query, (err, res) => {\n            if (err) {\n                reject(err);\n            } else {\n                if (Array.isArray(res)) {\n                    resolve(\"Rows: \" + res.length);\n                } else {\n                    resolve(\"No Error, but the result is not an array. Type: \" + typeof res);\n                }\n            }\n\n            try {\n                connection.end();\n            } catch (_) {\n                connection.destroy();\n            }\n        });\n    });\n};\n\n/**\n * Connect to and Ping a MongoDB database\n * @param {string} connectionString The database connection string\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mongodbPing = async function (connectionString) {\n    let client = await MongoClient.connect(connectionString);\n    let dbPing = await client.db().command({ ping: 1 });\n    await client.close();\n\n    if (dbPing[\"ok\"] === 1) {\n        return \"UP\";\n    } else {\n        throw Error(\"failed\");\n    }\n};\n\n/**\n * Query radius server\n * @param {string} hostname Hostname of radius server\n * @param {string} username Username to use\n * @param {string} password Password to use\n * @param {string} calledStationId ID of called station\n * @param {string} callingStationId ID of calling station\n * @param {string} secret Secret to use\n * @param {number} [port=1812] Port to contact radius server on\n * @param {number} [timeout=2500] Timeout for connection to use\n * @returns {Promise<any>}\n */\nexports.radius = function (\n    hostname,\n    username,\n    password,\n    calledStationId,\n    callingStationId,\n    secret,\n    port = 1812,\n    timeout = 2500,\n) {\n    const client = new radiusClient({\n        host: hostname,\n        hostPort: port,\n        timeout: timeout,\n        retries: 1,\n        dictionaries: [ file ],\n    });\n\n    return client.accessRequest({\n        secret: secret,\n        attributes: [\n            [ attributes.USER_NAME, username ],\n            [ attributes.USER_PASSWORD, password ],\n            [ attributes.CALLING_STATION_ID, callingStationId ],\n            [ attributes.CALLED_STATION_ID, calledStationId ],\n        ],\n    }).catch((error) => {\n        if (error.response?.code) {\n            throw Error(error.response.code);\n        } else {\n            throw Error(error.message);\n        }\n    });\n};\n\n/**\n * Redis server ping\n * @param {string} dsn The redis connection string\n */\nexports.redisPingAsync = function (dsn) {\n    return new Promise((resolve, reject) => {\n        const client = redis.createClient({\n            url: dsn\n        });\n        client.on(\"error\", (err) => {\n            if (client.isOpen) {\n                client.disconnect();\n            }\n            reject(err);\n        });\n        client.connect().then(() => {\n            if (!client.isOpen) {\n                client.emit(\"error\", new Error(\"connection isn't open\"));\n            }\n            client.ping().then((res, err) => {\n                if (client.isOpen) {\n                    client.disconnect();\n                }\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            }).catch(error => reject(error));\n        });\n    });\n};\n\n/**\n * Retrieve value of setting based on key\n * @param {string} key Key of setting to retrieve\n * @returns {Promise<any>} Value\n * @deprecated Use await Settings.get(key)\n */\nexports.setting = async function (key) {\n    return await Settings.get(key);\n};\n\n/**\n * Sets the specified setting to specifed value\n * @param {string} key Key of setting to set\n * @param {any} value Value to set to\n * @param {?string} type Type of setting\n * @returns {Promise<void>}\n */\nexports.setSetting = async function (key, value, type = null) {\n    await Settings.set(key, value, type);\n};\n\n/**\n * Get settings based on type\n * @param {string} type The type of setting\n * @returns {Promise<Bean>}\n */\nexports.getSettings = async function (type) {\n    return await Settings.getSettings(type);\n};\n\n/**\n * Set settings based on type\n * @param {string} type Type of settings to set\n * @param {Object} data Values of settings\n * @returns {Promise<void>}\n */\nexports.setSettings = async function (type, data) {\n    await Settings.setSettings(type, data);\n};\n\n// ssl-checker by @dyaa\n//https://github.com/dyaa/ssl-checker/blob/master/src/index.ts\n\n/**\n * Get number of days between two dates\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysBetween = (validFrom, validTo) =>\n    Math.round(Math.abs(+validFrom - +validTo) / 8.64e7);\n\n/**\n * Get days remaining from a time range\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysRemaining = (validFrom, validTo) => {\n    const daysRemaining = getDaysBetween(validFrom, validTo);\n    if (new Date(validTo).getTime() < new Date().getTime()) {\n        return -daysRemaining;\n    }\n    return daysRemaining;\n};\n\n/**\n * Fix certificate info for display\n * @param {Object} info The chain obtained from getPeerCertificate()\n * @returns {Object} An object representing certificate information\n */\nconst parseCertificateInfo = function (info) {\n    let link = info;\n    let i = 0;\n\n    const existingList = {};\n\n    while (link) {\n        log.debug(\"cert\", `[${i}] ${link.fingerprint}`);\n\n        if (!link.valid_from || !link.valid_to) {\n            break;\n        }\n        link.validTo = new Date(link.valid_to);\n        link.validFor = link.subjectaltname?.replace(/DNS:|IP Address:/g, \"\").split(\", \");\n        link.daysRemaining = getDaysRemaining(new Date(), link.validTo);\n\n        existingList[link.fingerprint] = true;\n\n        // Move up the chain until loop is encountered\n        if (link.issuerCertificate == null) {\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            break;\n        } else if (link.issuerCertificate.fingerprint in existingList) {\n            // a root CA certificate is typically \"signed by itself\"  (=> \"self signed certificate\") and thus the \"issuerCertificate\" is a reference to itself.\n            log.debug(\"cert\", `[Last] ${link.issuerCertificate.fingerprint}`);\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            link.issuerCertificate = null;\n            break;\n        } else {\n            link.certType = (i === 0) ? \"server\" : \"intermediate CA\";\n            link = link.issuerCertificate;\n        }\n\n        // Should be no use, but just in case.\n        if (i > 500) {\n            throw new Error(\"Dead loop occurred in parseCertificateInfo\");\n        }\n        i++;\n    }\n\n    return info;\n};\n\n/**\n * Check if certificate is valid\n * @param {Object} res Response object from axios\n * @returns {Object} Object containing certificate information\n */\nexports.checkCertificate = function (res) {\n    if (!res.request.res.socket) {\n        throw new Error(\"No socket found\");\n    }\n\n    const info = res.request.res.socket.getPeerCertificate(true);\n    const valid = res.request.res.socket.authorized || false;\n\n    log.debug(\"cert\", \"Parsing Certificate Info\");\n    const parsedInfo = parseCertificateInfo(info);\n\n    return {\n        valid: valid,\n        certInfo: parsedInfo\n    };\n};\n\n/**\n * Check if the provided status code is within the accepted ranges\n * @param {number} status The status code to check\n * @param {string[]} acceptedCodes An array of accepted status codes\n * @returns {boolean} True if status code within range, false otherwise\n */\nexports.checkStatusCode = function (status, acceptedCodes) {\n    if (acceptedCodes == null || acceptedCodes.length === 0) {\n        return false;\n    }\n\n    for (const codeRange of acceptedCodes) {\n        if (typeof codeRange !== \"string\") {\n            log.error(\"monitor\", `Accepted status code not a string. ${codeRange} is of type ${typeof codeRange}`);\n            continue;\n        }\n\n        const codeRangeSplit = codeRange.split(\"-\").map(string => parseInt(string));\n        if (codeRangeSplit.length === 1) {\n            if (status === codeRangeSplit[0]) {\n                return true;\n            }\n        } else if (codeRangeSplit.length === 2) {\n            if (status >= codeRangeSplit[0] && status <= codeRangeSplit[1]) {\n                return true;\n            }\n        } else {\n            log.error(\"monitor\", `${codeRange} is not a valid status code range`);\n            continue;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Get total number of clients in room\n * @param {Server} io Socket server instance\n * @param {string} roomName Name of room to check\n * @returns {number}\n */\nexports.getTotalClientInRoom = (io, roomName) => {\n\n    const sockets = io.sockets;\n\n    if (!sockets) {\n        return 0;\n    }\n\n    const adapter = sockets.adapter;\n\n    if (!adapter) {\n        return 0;\n    }\n\n    const room = adapter.rooms.get(roomName);\n\n    if (room) {\n        return room.size;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Allow CORS all origins if development\n * @param {Object} res Response object from axios\n */\nexports.allowDevAllOrigin = (res) => {\n    if (process.env.NODE_ENV === \"development\") {\n        exports.allowAllOrigin(res);\n    }\n};\n\n/**\n * Allow CORS all origins\n * @param {Object} res Response object from axios\n */\nexports.allowAllOrigin = (res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n};\n\n/**\n * Check if a user is logged in\n * @param {Socket} socket Socket instance\n */\nexports.checkLogin = (socket) => {\n    if (!socket.userID) {\n        throw new Error(\"You are not logged in.\");\n    }\n};\n\n/**\n * For logged-in users, double-check the password\n * @param {Socket} socket Socket.io instance\n * @param {string} currentPassword\n * @returns {Promise<Bean>}\n */\nexports.doubleCheckPassword = async (socket, currentPassword) => {\n    if (typeof currentPassword !== \"string\") {\n        throw new Error(\"Wrong data type?\");\n    }\n\n    let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n        socket.userID,\n    ]);\n\n    if (!user || !passwordHash.verify(currentPassword, user.password)) {\n        throw new Error(\"Incorrect current password\");\n    }\n\n    return user;\n};\n\n/** Start Unit tests */\nexports.startUnitTest = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"jest-backend\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/** Start end-to-end tests */\nexports.startE2eTests = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"cy:run\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/**\n * Convert unknown string to UTF8\n * @param {Uint8Array} body Buffer\n * @returns {string}\n */\nexports.convertToUTF8 = (body) => {\n    const guessEncoding = chardet.detect(body);\n    const str = iconv.decode(body, guessEncoding);\n    return str.toString();\n};\n\n/**\n * Returns a color code in hex format based on a given percentage:\n * 0% => hue = 10 => red\n * 100% => hue = 90 => green\n *\n * @param {number} percentage float, 0 to 1\n * @param {number} maxHue\n * @param {number} minHue, int\n * @returns {string}, hex value\n */\nexports.percentageToColor = (percentage, maxHue = 90, minHue = 10) => {\n    const hue = percentage * (maxHue - minHue) + minHue;\n    try {\n        return chroma(`hsl(${hue}, 90%, 40%)`).hex();\n    } catch (err) {\n        return badgeConstants.naColor;\n    }\n};\n\n/**\n * Joins and array of string to one string after filtering out empty values\n *\n * @param {string[]} parts\n * @param {string} connector\n * @returns {string}\n */\nexports.filterAndJoin = (parts, connector = \"\") => {\n    return parts.filter((part) => !!part && part !== \"\").join(connector);\n};\n\n/**\n * Send an Error response\n * @param {Object} res Express response object\n * @param {string} [msg=\"\"] Message to send\n */\nmodule.exports.sendHttpError = (res, msg = \"\") => {\n    if (msg.includes(\"SQLITE_BUSY\") || msg.includes(\"SQLITE_LOCKED\")) {\n        res.status(503).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else if (msg.toLowerCase().includes(\"not found\")) {\n        res.status(404).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else {\n        res.status(403).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    }\n};\n\nfunction timeObjectConvertTimezone(obj, timezone, timeObjectToUTC = true) {\n    let offsetString;\n\n    if (timezone) {\n        offsetString = dayjs().tz(timezone).format(\"Z\");\n    } else {\n        offsetString = dayjs().format(\"Z\");\n    }\n\n    let hours = parseInt(offsetString.substring(1, 3));\n    let minutes = parseInt(offsetString.substring(4, 6));\n\n    if (\n        (timeObjectToUTC && offsetString.startsWith(\"+\")) ||\n        (!timeObjectToUTC && offsetString.startsWith(\"-\"))\n    ) {\n        hours *= -1;\n        minutes *= -1;\n    }\n\n    obj.hours += hours;\n    obj.minutes += minutes;\n\n    // Handle out of bound\n    if (obj.minutes < 0) {\n        obj.minutes += 60;\n        obj.hours--;\n    } else if (obj.minutes > 60) {\n        obj.minutes -= 60;\n        obj.hours++;\n    }\n\n    if (obj.hours < 0) {\n        obj.hours += 24;\n    } else if (obj.hours > 24) {\n        obj.hours -= 24;\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToUTC = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, true);\n};\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToLocal = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, false);\n};\n\n/**\n * Create gRPC client stib\n * @param {Object} options from gRPC client\n */\nmodule.exports.grpcQuery = async (options) => {\n    const { grpcUrl, grpcProtobufData, grpcServiceName, grpcEnableTls, grpcMethod, grpcBody } = options;\n    const protocObject = protojs.parse(grpcProtobufData);\n    const protoServiceObject = protocObject.root.lookupService(grpcServiceName);\n    const Client = grpc.makeGenericClientConstructor({});\n    const credentials = grpcEnableTls ? grpc.credentials.createSsl() : grpc.credentials.createInsecure();\n    const client = new Client(\n        grpcUrl,\n        credentials\n    );\n    const grpcService = protoServiceObject.create(function (method, requestData, cb) {\n        const fullServiceName = method.fullName;\n        const serviceFQDN = fullServiceName.split(\".\");\n        const serviceMethod = serviceFQDN.pop();\n        const serviceMethodClientImpl = `/${serviceFQDN.slice(1).join(\".\")}/${serviceMethod}`;\n        log.debug(\"monitor\", `gRPC method ${serviceMethodClientImpl}`);\n        client.makeUnaryRequest(\n            serviceMethodClientImpl,\n            arg => arg,\n            arg => arg,\n            requestData,\n            cb);\n    }, false, false);\n    return new Promise((resolve, _) => {\n        try {\n            return grpcService[`${grpcMethod}`](JSON.parse(grpcBody), function (err, response) {\n                const responseData = JSON.stringify(response);\n                if (err) {\n                    return resolve({\n                        code: err.code,\n                        errorMessage: err.details,\n                        data: \"\"\n                    });\n                } else {\n                    log.debug(\"monitor:\", `gRPC response: ${JSON.stringify(response)}`);\n                    return resolve({\n                        code: 1,\n                        errorMessage: \"\",\n                        data: responseData\n                    });\n                }\n            });\n        } catch (err) {\n            return resolve({\n                code: -1,\n                errorMessage: `Error ${err}. Please review your gRPC configuration option. The service name must not include package name value, and the method name must follow camelCase format`,\n                data: \"\"\n            });\n        }\n\n    });\n};\n\n/**\n * Returns an array of SHA256 fingerprints for all known root certificates.\n * @returns {Set} A set of SHA256 fingerprints.\n */\nmodule.exports.rootCertificatesFingerprints = () => {\n    let fingerprints = tls.rootCertificates.map(cert => {\n        let certLines = cert.split(\"\\n\");\n        certLines.shift();\n        certLines.pop();\n        let certBody = certLines.join(\"\");\n        let buf = Buffer.from(certBody, \"base64\");\n\n        const shasum = crypto.createHash(\"sha256\");\n        shasum.update(buf);\n\n        return shasum.digest(\"hex\").toUpperCase().replace(/(.{2})(?!$)/g, \"$1:\");\n    });\n\n    fingerprints.push(\"6D:99:FB:26:5E:B1:C5:B3:74:47:65:FC:BC:64:8F:3C:D8:E1:BF:FA:FD:C4:C2:F9:9B:9D:47:CF:7F:F1:C2:4F\"); // ISRG X1 cross-signed with DST X3\n    fingerprints.push(\"8B:05:B6:8C:C6:59:E5:ED:0F:CB:38:F2:C9:42:FB:FD:20:0E:6F:2F:F9:F8:5D:63:C6:99:4E:F5:E0:B0:27:01\"); // ISRG X2 cross-signed with ISRG X1\n\n    return new Set(fingerprints);\n};\n\nmodule.exports.SHAKE256_LENGTH = 16;\n\n/**\n *\n * @param {string} data\n * @param {number} len\n * @return {string}\n */\nmodule.exports.shake256 = (data, len) => {\n    if (!data) {\n        return \"\";\n    }\n    return crypto.createHash(\"shake256\", { outputLength: len })\n        .update(data)\n        .digest(\"hex\");\n};\n\n// For unit test, export functions\nif (process.env.TEST_BACKEND) {\n    module.exports.__test = {\n        parseCertificateInfo,\n    };\n    module.exports.__getPrivateFunction = (functionName) => {\n        return module.exports.__test[functionName];\n    };\n}\n\n/**\n * Generates an abort signal with the specified timeout.\n * @param {number} timeoutMs - The timeout in milliseconds.\n * @returns {AbortSignal | null} - The generated abort signal, or null if not supported.\n */\nmodule.exports.axiosAbortSignal = (timeoutMs) => {\n    try {\n        // Just in case, as 0 timeout here will cause the request to be aborted immediately\n        if (!timeoutMs || timeoutMs <= 0) {\n            timeoutMs = 5000;\n        }\n        return AbortSignal.timeout(timeoutMs);\n    } catch (_) {\n        // v16-: AbortSignal.timeout is not supported\n        try {\n            const abortController = new AbortController();\n            setTimeout(() => abortController.abort(), timeoutMs);\n\n            return abortController.signal;\n        } catch (_) {\n            // v15-: AbortController is not supported\n            return null;\n        }\n    }\n};\n", "<template>\n    <div ref=\"BadgeGeneratorModal\" class=\"modal fade\" tabindex=\"-1\" data-bs-backdrop=\"static\">\n        <div class=\"modal-dialog\">\n            <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">\n                        {{ $t(\"Badge Generator\", [monitor.name]) }}\n                    </h5>\n                    <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\" />\n                </div>\n                <div class=\"modal-body\">\n                    <div class=\"mb-3\">\n                        <label for=\"type\" class=\"form-label\">{{ $t(\"Badge Type\") }}</label>\n                        <select id=\"type\" v-model=\"badge.type\" class=\"form-select\">\n                            <option value=\"status\">status</option>\n                            <option value=\"uptime\">uptime</option>\n                            <option value=\"ping\">ping</option>\n                            <option value=\"avg-response\">avg-response</option>\n                            <option value=\"cert-exp\">cert-exp</option>\n                            <option value=\"response\">response</option>\n                        </select>\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('duration') \" class=\"mb-3\">\n                        <label for=\"duration\" class=\"form-label\">{{ $t(\"Badge Duration (in hours)\") }}</label>\n                        <input id=\"duration\" v-model=\"badge.duration\" type=\"number\" min=\"0\" placeholder=\"24\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('label') \" class=\"mb-3\">\n                        <label for=\"label\" class=\"form-label\">{{ $t(\"Badge Label\") }}</label>\n                        <input id=\"label\" v-model=\"badge.label\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('prefix') \" class=\"mb-3\">\n                        <label for=\"prefix\" class=\"form-label\">{{ $t(\"Badge Prefix\") }}</label>\n                        <input id=\"prefix\" v-model=\"badge.prefix\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('suffix') \" class=\"mb-3\">\n                        <label for=\"suffix\" class=\"form-label\">{{ $t(\"Badge Suffix\") }}</label>\n                        <input id=\"suffix\" v-model=\"badge.suffix\" type=\"text\" placeholder=\"%\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelColor') \" class=\"mb-3\">\n                        <label for=\"labelColor\" class=\"form-label\">{{ $t(\"Badge Label Color\") }}</label>\n                        <input id=\"labelColor\" v-model=\"badge.labelColor\" type=\"text\" placeholder=\"#555\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('color') \" class=\"mb-3\">\n                        <label for=\"color\" class=\"form-label\">{{ $t(\"Badge Color\") }}</label>\n                        <input id=\"color\" v-model=\"badge.color\" type=\"text\" :placeholder=\"badgeConstants.defaultUpColor\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelPrefix') \" class=\"mb-3\">\n                        <label for=\"labelPrefix\" class=\"form-label\">{{ $t(\"Badge Label Prefix\") }}</label>\n                        <input id=\"labelPrefix\" v-model=\"badge.labelPrefix\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('labelSuffix') \" class=\"mb-3\">\n                        <label for=\"labelSuffix\" class=\"form-label\">{{ $t(\"Badge Label Suffix\") }}</label>\n                        <input id=\"labelSuffix\" v-model=\"badge.labelSuffix\" type=\"text\" placeholder=\"h\" class=\"form-control\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('upColor') \" class=\"mb-3\">\n                        <label for=\"upColor\" class=\"form-label\">{{ $t(\"Badge Up Color\") }}</label>\n                        <input id=\"upColor\" v-model=\"badge.upColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultUpColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('downColor') \" class=\"mb-3\">\n                        <label for=\"downColor\" class=\"form-label\">{{ $t(\"Badge Down Color\") }}</label>\n                        <input id=\"downColor\" v-model=\"badge.downColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultDownColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('pendingColor') \" class=\"mb-3\">\n                        <label for=\"pendingColor\" class=\"form-label\">{{ $t(\"Badge Pending Color\") }}</label>\n                        <input id=\"pendingColor\" v-model=\"badge.pendingColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultPendingColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('maintenanceColor') \" class=\"mb-3\">\n                        <label for=\"maintenanceColor\" class=\"form-label\">{{ $t(\"Badge Maintenance Color\") }}</label>\n                        <input id=\"maintenanceColor\" v-model=\"badge.maintenanceColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultMaintenanceColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('warnColor') \" class=\"mb-3\">\n                        <label for=\"warnColor\" class=\"form-label\">{{ $t(\"Badge Warn Color\") }}</label>\n                        <input id=\"warnColor\" v-model=\"badge.warnColor\" type=\"text\" class=\"form-control\" :placeholder=\"badgeConstants.defaultMaintenanceColor\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('warnDays') \" class=\"mb-3\">\n                        <label for=\"warnDays\" class=\"form-label\">{{ $t(\"Badge Warn Days\") }}</label>\n                        <input id=\"warnDays\" v-model=\"badge.warnDays\" type=\"number\" min=\"0\" class=\"form-control\" :placeholder=\"badgeConstants.defaultCertExpireWarnDays\">\n                    </div>\n\n                    <div v-if=\" (parameters[badge.type || 'null'] || [] ).includes('downDays') \" class=\"mb-3\">\n                        <label for=\"downDays\" class=\"form-label\">{{ $t(\"Badge Down Days\") }}</label>\n                        <input id=\"downDays\" v-model=\"badge.downDays\" type=\"number\" min=\"0\" class=\"form-control\" :placeholder=\"badgeConstants.defaultCertExpireDownDays\">\n                    </div>\n\n                    <div class=\"mb-3\">\n                        <label for=\"style\" class=\"form-label\">{{ $t(\"Badge Style\") }}</label>\n                        <select id=\"style\" v-model=\"badge.style\" class=\"form-select\">\n                            <option value=\"plastic\">plastic</option>\n                            <option value=\"flat\">flat</option>\n                            <option value=\"flat-square\">flat-square</option>\n                            <option value=\"for-the-badge\">for-the-badge</option>\n                            <option value=\"social\">social</option>\n                        </select>\n                    </div>\n\n                    <div class=\"mb-3\">\n                        <label for=\"value\" class=\"form-label\">{{ $t(\"Badge value (For Testing only.)\") }}</label>\n                        <input id=\"value\" v-model=\"badge.value\" type=\"text\" class=\"form-control\">\n                    </div>\n\n                    <div class=\"mb-3 pt-3 d-flex justify-content-center\">\n                        <img :src=\"badgeURL\" :alt=\"$t('Badge Preview')\">\n                    </div>\n\n                    <div class=\"my-3\">\n                        <label for=\"badge-url\" class=\"form-label\">{{ $t(\"Badge URL\") }}</label>\n                        <CopyableInput id=\"badge-url\" v-model=\"badgeURL\" type=\"url\" disabled=\"disabled\" />\n                    </div>\n                </div>\n\n                <div class=\"modal-footer\">\n                    <button type=\"submit\" class=\"btn btn-danger\" data-bs-dismiss=\"modal\">\n                        {{ $t(\"Close\") }}\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport { Modal } from \"bootstrap\";\nimport CopyableInput from \"./CopyableInput.vue\";\nimport { badgeConstants } from \"../util.ts\";\n\nexport default {\n    components: {\n        CopyableInput\n    },\n    props: {},\n    emits: [],\n    data() {\n        return {\n            model: null,\n            processing: false,\n            monitor: {\n                id: null,\n                name: null,\n            },\n            badge: {\n                type: \"status\",\n                duration: null,\n                label: null,\n                prefix: null,\n                suffix: null,\n                labelColor: null,\n                color: null,\n                labelPrefix: null,\n                labelSuffix: null,\n                upColor: null,\n                downColor: null,\n                pendingColor: null,\n                maintenanceColor: null,\n                warnColor: null,\n                warnDays: null,\n                downDays: null,\n                style: \"flat\",\n                value: null,\n            },\n            parameters: {\n                status: [\n                    \"upLabel\",\n                    \"downLabel\",\n                    \"pendingLabel\",\n                    \"maintenanceLabel\",\n                    \"upColor\",\n                    \"downColor\",\n                    \"pendingColor\",\n                    \"maintenanceColor\",\n                ],\n                uptime: [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                ping: [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                \"avg-response\": [\n                    \"duration\",\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n                \"cert-exp\": [\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"upColor\",\n                    \"warnColor\",\n                    \"downColor\",\n                    \"warnDays\",\n                    \"downDays\",\n                    \"labelColor\",\n                ],\n                response: [\n                    \"labelPrefix\",\n                    \"labelSuffix\",\n                    \"prefix\",\n                    \"suffix\",\n                    \"color\",\n                    \"labelColor\",\n                ],\n            },\n            badgeConstants,\n        };\n    },\n\n    computed: {\n        badgeURL() {\n            if (!this.monitor.id || !this.badge.type) {\n                return;\n            }\n            let badgeURL = this.$root.baseURL + \"/api/badge/\" + this.monitor.id + \"/\" + this.badge.type;\n\n            let parameterList = {};\n\n            for (let parameter of this.parameters[this.badge.type] || []) {\n                if (parameter === \"duration\" && this.badge.duration) {\n                    badgeURL += \"/\" + this.badge.duration;\n                    continue;\n                }\n\n                if (this.badge[parameter]) {\n                    parameterList[parameter] = this.badge[parameter];\n                }\n            }\n\n            for (let parameter of [ \"label\", \"style\", \"value\" ]) {\n                if (parameter === \"style\" && this.badge.style === \"flat\") {\n                    continue;\n                }\n\n                if (this.badge[parameter]) {\n                    parameterList[parameter] = this.badge[parameter];\n                }\n            }\n\n            if (Object.keys(parameterList).length > 0) {\n                return badgeURL + \"?\" + new URLSearchParams(parameterList);\n            }\n\n            return badgeURL;\n        },\n    },\n\n    mounted() {\n        this.BadgeGeneratorModal = new Modal(this.$refs.BadgeGeneratorModal);\n    },\n\n    methods: {\n        /**\n         * Setting monitor\n         * @param {number} monitorId    ID of monitor\n         * @param {string} monitorName  Name of monitor\n         */\n        show(monitorId, monitorName) {\n            this.monitor = {\n                id: monitorId,\n                name: monitorName,\n            };\n\n            this.BadgeGeneratorModal.show();\n        },\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../assets/vars.scss\";\n\n.dark {\n    .modal-dialog .form-text, .modal-dialog p {\n        color: $dark-font-color;\n    }\n}\n</style>\n", "import { io } from \"socket.io-client\";\nimport { useToast } from \"vue-toastification\";\nimport jwtDecode from \"jwt-decode\";\nimport Favico from \"favico.js\";\nimport dayjs from \"dayjs\";\nimport { DOWN, MAINTENANCE, PENDING, UP } from \"../util.ts\";\nimport { getDevContainerServerHostname, isDevContainer } from \"../util-frontend.js\";\nconst toast = useToast();\n\nlet socket;\n\nconst noSocketIOPages = [\n    /^\\/status-page$/,  //  /status-page\n    /^\\/status/,    // /status**\n    /^\\/$/      //  /\n];\n\nconst favicon = new Favico({\n    animation: \"none\"\n});\n\nexport default {\n\n    data() {\n        return {\n            info: { },\n            socket: {\n                token: null,\n                firstConnect: true,\n                connected: false,\n                connectCount: 0,\n                initedSocketIO: false,\n            },\n            username: null,\n            remember: (localStorage.remember !== \"0\"),\n            allowLoginDialog: false,        // Allowed to show login dialog, but \"loggedIn\" have to be true too. This exists because prevent the login dialog show 0.1s in first before the socket server auth-ed.\n            loggedIn: false,\n            monitorList: { },\n            maintenanceList: {},\n            apiKeyList: {},\n            heartbeatList: { },\n            importantHeartbeatList: { },\n            avgPingList: { },\n            uptimeList: { },\n            tlsInfoList: {},\n            notificationList: [],\n            dockerHostList: [],\n            statusPageListLoaded: false,\n            statusPageList: [],\n            proxyList: [],\n            connectionErrorMsg: `${this.$t(\"Cannot connect to the socket server.\")} ${this.$t(\"Reconnecting...\")}`,\n            showReverseProxyGuide: true,\n            cloudflared: {\n                cloudflareTunnelToken: \"\",\n                installed: null,\n                running: false,\n                message: \"\",\n                errorMessage: \"\",\n                currentPassword: \"\",\n            },\n            faviconUpdateDebounce: null,\n        };\n    },\n\n    created() {\n        this.initSocketIO();\n    },\n\n    methods: {\n\n        /**\n         * Initialize connection to socket server\n         * @param {boolean} [bypass = false] Should the check for if we\n         * are on a status page be bypassed?\n         * @returns {(void|null)}\n         */\n        initSocketIO(bypass = false) {\n            // No need to re-init\n            if (this.socket.initedSocketIO) {\n                return;\n            }\n\n            // No need to connect to the socket.io for status page\n            if (! bypass && location.pathname) {\n                for (let page of noSocketIOPages) {\n                    if (location.pathname.match(page)) {\n                        return;\n                    }\n                }\n            }\n\n            this.socket.initedSocketIO = true;\n\n            let protocol = (location.protocol === \"https:\") ? \"wss://\" : \"ws://\";\n\n            let wsHost;\n            const env = process.env.NODE_ENV || \"production\";\n            if (env === \"development\" && isDevContainer()) {\n                wsHost = protocol + getDevContainerServerHostname();\n            } else if (env === \"development\" || localStorage.dev === \"dev\") {\n                wsHost = protocol + location.hostname + \":3001\";\n            } else {\n                wsHost = protocol + location.host;\n            }\n\n            socket = io(wsHost, {\n                transports: [ \"websocket\" ],\n            });\n\n            socket.on(\"info\", (info) => {\n                this.info = info;\n            });\n\n            socket.on(\"setup\", (monitorID, data) => {\n                this.$router.push(\"/setup\");\n            });\n\n            socket.on(\"autoLogin\", (monitorID, data) => {\n                this.loggedIn = true;\n                this.storage().token = \"autoLogin\";\n                this.socket.token = \"autoLogin\";\n                this.allowLoginDialog = false;\n            });\n\n            socket.on(\"monitorList\", (data) => {\n                // Add Helper function\n                Object.entries(data).forEach(([ monitorID, monitor ]) => {\n                    monitor.getUrl = () => {\n                        try {\n                            return new URL(monitor.url);\n                        } catch (_) {\n                            return null;\n                        }\n                    };\n                });\n                this.monitorList = data;\n            });\n\n            socket.on(\"maintenanceList\", (data) => {\n                this.maintenanceList = data;\n            });\n\n            socket.on(\"apiKeyList\", (data) => {\n                this.apiKeyList = data;\n            });\n\n            socket.on(\"notificationList\", (data) => {\n                this.notificationList = data;\n            });\n\n            socket.on(\"statusPageList\", (data) => {\n                this.statusPageListLoaded = true;\n                this.statusPageList = data;\n            });\n\n            socket.on(\"proxyList\", (data) => {\n                this.proxyList = data.map(item => {\n                    item.auth = !!item.auth;\n                    item.active = !!item.active;\n                    item.default = !!item.default;\n\n                    return item;\n                });\n            });\n\n            socket.on(\"dockerHostList\", (data) => {\n                this.dockerHostList = data;\n            });\n\n            socket.on(\"heartbeat\", (data) => {\n                if (! (data.monitorID in this.heartbeatList)) {\n                    this.heartbeatList[data.monitorID] = [];\n                }\n\n                this.heartbeatList[data.monitorID].push(data);\n\n                if (this.heartbeatList[data.monitorID].length >= 150) {\n                    this.heartbeatList[data.monitorID].shift();\n                }\n\n                // Add to important list if it is important\n                // Also toast\n                if (data.important) {\n\n                    if (this.monitorList[data.monitorID] !== undefined) {\n                        if (data.status === 0) {\n                            toast.error(`[${this.monitorList[data.monitorID].name}] [DOWN] ${data.msg}`, {\n                                timeout: false,\n                            });\n                        } else if (data.status === 1) {\n                            toast.success(`[${this.monitorList[data.monitorID].name}] [Up] ${data.msg}`, {\n                                timeout: 20000,\n                            });\n                        } else {\n                            toast(`[${this.monitorList[data.monitorID].name}] ${data.msg}`);\n                        }\n                    }\n\n                    if (! (data.monitorID in this.importantHeartbeatList)) {\n                        this.importantHeartbeatList[data.monitorID] = [];\n                    }\n\n                    this.importantHeartbeatList[data.monitorID].unshift(data);\n                }\n            });\n\n            socket.on(\"heartbeatList\", (monitorID, data, overwrite = false) => {\n                if (! (monitorID in this.heartbeatList) || overwrite) {\n                    this.heartbeatList[monitorID] = data;\n                } else {\n                    this.heartbeatList[monitorID] = data.concat(this.heartbeatList[monitorID]);\n                }\n            });\n\n            socket.on(\"avgPing\", (monitorID, data) => {\n                this.avgPingList[monitorID] = data;\n            });\n\n            socket.on(\"uptime\", (monitorID, type, data) => {\n                this.uptimeList[`${monitorID}_${type}`] = data;\n            });\n\n            socket.on(\"certInfo\", (monitorID, data) => {\n                this.tlsInfoList[monitorID] = JSON.parse(data);\n            });\n\n            socket.on(\"importantHeartbeatList\", (monitorID, data, overwrite) => {\n                if (! (monitorID in this.importantHeartbeatList) || overwrite) {\n                    this.importantHeartbeatList[monitorID] = data;\n                } else {\n                    this.importantHeartbeatList[monitorID] = data.concat(this.importantHeartbeatList[monitorID]);\n                }\n            });\n\n            socket.on(\"connect_error\", (err) => {\n                console.error(`Failed to connect to the backend. Socket.io connect_error: ${err.message}`);\n                this.connectionErrorMsg = `${this.$t(\"Cannot connect to the socket server.\")} [${err}] ${this.$t(\"Reconnecting...\")}`;\n                this.showReverseProxyGuide = true;\n                this.socket.connected = false;\n                this.socket.firstConnect = false;\n            });\n\n            socket.on(\"disconnect\", () => {\n                console.log(\"disconnect\");\n                this.connectionErrorMsg = \"Lost connection to the socket server. Reconnecting...\";\n                this.socket.connected = false;\n            });\n\n            socket.on(\"connect\", () => {\n                console.log(\"Connected to the socket server\");\n                this.socket.connectCount++;\n                this.socket.connected = true;\n                this.showReverseProxyGuide = false;\n\n                // Reset Heartbeat list if it is re-connect\n                if (this.socket.connectCount >= 2) {\n                    this.clearData();\n                }\n\n                let token = this.storage().token;\n\n                if (token) {\n                    if (token !== \"autoLogin\") {\n                        this.loginByToken(token);\n                    } else {\n                        // Timeout if it is not actually auto login\n                        setTimeout(() => {\n                            if (! this.loggedIn) {\n                                this.allowLoginDialog = true;\n                                this.$root.storage().removeItem(\"token\");\n                            }\n                        }, 5000);\n                    }\n                } else {\n                    this.allowLoginDialog = true;\n                }\n\n                this.socket.firstConnect = false;\n            });\n\n            // cloudflared\n            socket.on(\"cloudflared_installed\", (res) => this.cloudflared.installed = res);\n            socket.on(\"cloudflared_running\", (res) => this.cloudflared.running = res);\n            socket.on(\"cloudflared_message\", (res) => this.cloudflared.message = res);\n            socket.on(\"cloudflared_errorMessage\", (res) => this.cloudflared.errorMessage = res);\n            socket.on(\"cloudflared_token\", (res) => this.cloudflared.cloudflareTunnelToken = res);\n\n            socket.on(\"initServerTimezone\", () => {\n                socket.emit(\"initServerTimezone\", dayjs.tz.guess());\n            });\n\n            socket.on(\"refresh\", () => {\n                location.reload();\n            });\n        },\n\n        /**\n         * The storage currently in use\n         * @returns {Storage}\n         */\n        storage() {\n            return (this.remember) ? localStorage : sessionStorage;\n        },\n\n        /**\n         * Get payload of JWT cookie\n         * @returns {(Object|undefined)}\n         */\n        getJWTPayload() {\n            const jwtToken = this.$root.storage().token;\n\n            if (jwtToken && jwtToken !== \"autoLogin\") {\n                return jwtDecode(jwtToken);\n            }\n            return undefined;\n        },\n\n        /**\n         * Get current socket\n         * @returns {Socket}\n         */\n        getSocket() {\n            return socket;\n        },\n\n        /**\n         * Show success or error toast dependant on response status code\n         * @param {Object} res Response object\n         */\n        toastRes(res) {\n            if (res.ok) {\n                toast.success(res.msg);\n            } else {\n                toast.error(res.msg);\n            }\n        },\n\n        /**\n         * Show a success toast\n         * @param {string} msg Message to show\n         */\n        toastSuccess(msg) {\n            toast.success(msg);\n        },\n\n        /**\n         * Show an error toast\n         * @param {string} msg Message to show\n         */\n        toastError(msg) {\n            toast.error(msg);\n        },\n\n        /**\n         * Callback for login\n         * @callback loginCB\n         * @param {Object} res Response object\n         */\n\n        /**\n         * Send request to log user in\n         * @param {string} username Username to log in with\n         * @param {string} password Password to log in with\n         * @param {string} token User token\n         * @param {loginCB} callback Callback to call with result\n         */\n        login(username, password, token, callback) {\n            socket.emit(\"login\", {\n                username,\n                password,\n                token,\n            }, (res) => {\n                if (res.tokenRequired) {\n                    callback(res);\n                }\n\n                if (res.ok) {\n                    this.storage().token = res.token;\n                    this.socket.token = res.token;\n                    this.loggedIn = true;\n                    this.username = this.getJWTPayload()?.username;\n\n                    // Trigger Chrome Save Password\n                    history.pushState({}, \"\");\n                }\n\n                callback(res);\n            });\n        },\n\n        /**\n         * Log in using a token\n         * @param {string} token Token to log in with\n         */\n        loginByToken(token) {\n            socket.emit(\"loginByToken\", token, (res) => {\n                this.allowLoginDialog = true;\n\n                if (! res.ok) {\n                    this.logout();\n                } else {\n                    this.loggedIn = true;\n                    this.username = this.getJWTPayload()?.username;\n                }\n            });\n        },\n\n        /** Log out of the web application */\n        logout() {\n            socket.emit(\"logout\", () => { });\n            this.storage().removeItem(\"token\");\n            this.socket.token = null;\n            this.loggedIn = false;\n            this.username = null;\n            this.clearData();\n        },\n\n        /**\n         * Callback for general socket requests\n         * @callback socketCB\n         * @param {Object} res Result of operation\n         */\n        /** Prepare 2FA configuration */\n        prepare2FA(callback) {\n            socket.emit(\"prepare2FA\", callback);\n        },\n\n        /**\n         * Save the current 2FA configuration\n         * @param {any} secret Unused\n         * @param {socketCB} callback\n         */\n        save2FA(secret, callback) {\n            socket.emit(\"save2FA\", callback);\n        },\n\n        /**\n         * Disable 2FA for this user\n         * @param {socketCB} callback\n         */\n        disable2FA(callback) {\n            socket.emit(\"disable2FA\", callback);\n        },\n\n        /**\n         * Verify the provided 2FA token\n         * @param {string} token Token to verify\n         * @param {socketCB} callback\n         */\n        verifyToken(token, callback) {\n            socket.emit(\"verifyToken\", token, callback);\n        },\n\n        /**\n         * Get current 2FA status\n         * @param {socketCB} callback\n         */\n        twoFAStatus(callback) {\n            socket.emit(\"twoFAStatus\", callback);\n        },\n\n        /**\n         * Get list of monitors\n         * @param {socketCB} callback\n         */\n        getMonitorList(callback) {\n            if (! callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getMonitorList\", callback);\n        },\n\n        /**\n         * Get list of maintenances\n         * @param {socketCB} callback\n         */\n        getMaintenanceList(callback) {\n            if (! callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getMaintenanceList\", callback);\n        },\n\n        /**\n         * Send list of API keys\n         * @param {socketCB} callback\n         */\n        getAPIKeyList(callback) {\n            if (!callback) {\n                callback = () => { };\n            }\n            socket.emit(\"getAPIKeyList\", callback);\n        },\n\n        /**\n         * Add a monitor\n         * @param {Object} monitor Object representing monitor to add\n         * @param {socketCB} callback\n         */\n        add(monitor, callback) {\n            socket.emit(\"add\", monitor, callback);\n        },\n\n        /**\n         * Adds a maintenace\n         * @param {Object} maintenance\n         * @param {socketCB} callback\n         */\n        addMaintenance(maintenance, callback) {\n            socket.emit(\"addMaintenance\", maintenance, callback);\n        },\n\n        /**\n         * Add monitors to maintenance\n         * @param {number} maintenanceID\n         * @param {number[]} monitors\n         * @param {socketCB} callback\n         */\n        addMonitorMaintenance(maintenanceID, monitors, callback) {\n            socket.emit(\"addMonitorMaintenance\", maintenanceID, monitors, callback);\n        },\n\n        /**\n         * Add status page to maintenance\n         * @param {number} maintenanceID\n         * @param {number} statusPages\n         * @param {socketCB} callback\n         */\n        addMaintenanceStatusPage(maintenanceID, statusPages, callback) {\n            socket.emit(\"addMaintenanceStatusPage\", maintenanceID, statusPages, callback);\n        },\n\n        /**\n         * Get monitors affected by maintenance\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        getMonitorMaintenance(maintenanceID, callback) {\n            socket.emit(\"getMonitorMaintenance\", maintenanceID, callback);\n        },\n\n        /**\n         * Get status pages where maintenance is shown\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        getMaintenanceStatusPage(maintenanceID, callback) {\n            socket.emit(\"getMaintenanceStatusPage\", maintenanceID, callback);\n        },\n\n        /**\n         * Delete monitor by ID\n         * @param {number} monitorID ID of monitor to delete\n         * @param {socketCB} callback\n         */\n        deleteMonitor(monitorID, callback) {\n            socket.emit(\"deleteMonitor\", monitorID, callback);\n        },\n\n        /**\n         * Delete specified maintenance\n         * @param {number} maintenanceID\n         * @param {socketCB} callback\n         */\n        deleteMaintenance(maintenanceID, callback) {\n            socket.emit(\"deleteMaintenance\", maintenanceID, callback);\n        },\n\n        /**\n         * Add an API key\n         * @param {Object} key API key to add\n         * @param {socketCB} callback\n         */\n        addAPIKey(key, callback) {\n            socket.emit(\"addAPIKey\", key, callback);\n        },\n\n        /**\n         * Delete specified API key\n         * @param {int} keyID ID of key to delete\n         * @param {socketCB} callback\n         */\n        deleteAPIKey(keyID, callback) {\n            socket.emit(\"deleteAPIKey\", keyID, callback);\n        },\n\n        /** Clear the hearbeat list */\n        clearData() {\n            console.log(\"reset heartbeat list\");\n            this.heartbeatList = {};\n            this.importantHeartbeatList = {};\n        },\n\n        /**\n         * Upload the provided backup\n         * @param {string} uploadedJSON JSON to upload\n         * @param {string} importHandle Type of import. If set to\n         * most data in database will be replaced\n         * @param {socketCB} callback\n         */\n        uploadBackup(uploadedJSON, importHandle, callback) {\n            socket.emit(\"uploadBackup\", uploadedJSON, importHandle, callback);\n        },\n\n        /**\n         * Clear events for a specified monitor\n         * @param {number} monitorID ID of monitor to clear\n         * @param {socketCB} callback\n         */\n        clearEvents(monitorID, callback) {\n            socket.emit(\"clearEvents\", monitorID, callback);\n        },\n\n        /**\n         * Clear the heartbeats of a specified monitor\n         * @param {number} monitorID Id of monitor to clear\n         * @param {socketCB} callback\n         */\n        clearHeartbeats(monitorID, callback) {\n            socket.emit(\"clearHeartbeats\", monitorID, callback);\n        },\n\n        /**\n         * Clear all statistics\n         * @param {socketCB} callback\n         */\n        clearStatistics(callback) {\n            socket.emit(\"clearStatistics\", callback);\n        },\n\n        /**\n         * Get monitor beats for a specific monitor in a time range\n         * @param {number} monitorID ID of monitor to fetch\n         * @param {number} period Time in hours from now\n         * @param {socketCB} callback\n         */\n        getMonitorBeats(monitorID, period, callback) {\n            socket.emit(\"getMonitorBeats\", monitorID, period, callback);\n        }\n    },\n\n    computed: {\n\n        usernameFirstChar() {\n            if (typeof this.username == \"string\" && this.username.length >= 1) {\n                return this.username.charAt(0).toUpperCase();\n            } else {\n                return \"\ud83d\udc3b\";\n            }\n        },\n\n        lastHeartbeatList() {\n            let result = {};\n\n            for (let monitorID in this.heartbeatList) {\n                let index = this.heartbeatList[monitorID].length - 1;\n                result[monitorID] = this.heartbeatList[monitorID][index];\n            }\n\n            return result;\n        },\n\n        statusList() {\n            let result = {};\n\n            let unknown = {\n                text: this.$t(\"Unknown\"),\n                color: \"secondary\",\n            };\n\n            for (let monitorID in this.lastHeartbeatList) {\n                let lastHeartBeat = this.lastHeartbeatList[monitorID];\n\n                if (! lastHeartBeat) {\n                    result[monitorID] = unknown;\n                } else if (lastHeartBeat.status === UP) {\n                    result[monitorID] = {\n                        text: this.$t(\"Up\"),\n                        color: \"primary\",\n                    };\n                } else if (lastHeartBeat.status === DOWN) {\n                    result[monitorID] = {\n                        text: this.$t(\"Down\"),\n                        color: \"danger\",\n                    };\n                } else if (lastHeartBeat.status === PENDING) {\n                    result[monitorID] = {\n                        text: this.$t(\"Pending\"),\n                        color: \"warning\",\n                    };\n                } else if (lastHeartBeat.status === MAINTENANCE) {\n                    result[monitorID] = {\n                        text: this.$t(\"statusMaintenance\"),\n                        color: \"maintenance\",\n                    };\n                } else {\n                    result[monitorID] = unknown;\n                }\n            }\n\n            return result;\n        },\n\n        stats() {\n            let result = {\n                active: 0,\n                up: 0,\n                down: 0,\n                maintenance: 0,\n                pending: 0,\n                unknown: 0,\n                pause: 0,\n            };\n\n            for (let monitorID in this.$root.monitorList) {\n                let beat = this.$root.lastHeartbeatList[monitorID];\n                let monitor = this.$root.monitorList[monitorID];\n\n                if (monitor && ! monitor.active) {\n                    result.pause++;\n                } else if (beat) {\n                    result.active++;\n                    if (beat.status === UP) {\n                        result.up++;\n                    } else if (beat.status === DOWN) {\n                        result.down++;\n                    } else if (beat.status === PENDING) {\n                        result.pending++;\n                    } else if (beat.status === MAINTENANCE) {\n                        result.maintenance++;\n                    } else {\n                        result.unknown++;\n                    }\n                } else {\n                    result.unknown++;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n         *  Frontend Version\n         *  It should be compiled to a static value while building the frontend.\n         *  Please see ./config/vite.config.js, it is defined via vite.js\n         * @returns {string}\n         */\n        frontendVersion() {\n            // eslint-disable-next-line no-undef\n            return FRONTEND_VERSION;\n        },\n\n        /**\n         * Are both frontend and backend in the same version?\n         * @returns {boolean}\n         */\n        isFrontendBackendVersionMatched() {\n            if (!this.info.version) {\n                return true;\n            }\n            return this.info.version === this.frontendVersion;\n        }\n    },\n\n    watch: {\n\n        // Update Badge\n        \"stats.down\"(to, from) {\n            if (to !== from) {\n                if (this.faviconUpdateDebounce != null) {\n                    clearTimeout(this.faviconUpdateDebounce);\n                }\n                this.faviconUpdateDebounce = setTimeout(() => {\n                    favicon.badge(to);\n                }, 1000);\n            }\n        },\n\n        // Reload the SPA if the server version is changed.\n        \"info.version\"(to, from) {\n            if (from && from !== to) {\n                window.location.reload();\n            }\n        },\n\n        remember() {\n            localStorage.remember = (this.remember) ? \"1\" : \"0\";\n        },\n\n        // Reconnect the socket io, if status-page to dashboard\n        \"$route.fullPath\"(newValue, oldValue) {\n\n            if (newValue) {\n                for (let page of noSocketIOPages) {\n                    if (newValue.match(page)) {\n                        return;\n                    }\n                }\n            }\n\n            this.initSocketIO();\n        },\n\n    },\n\n};\n", "<template>\n    <transition name=\"slide-fade\" appear>\n        <div>\n            <h1 class=\"mb-3\">{{ pageName }}</h1>\n            <form @submit.prevent=\"submit\">\n                <div class=\"shadow-box shadow-box-with-fixed-bottom-bar\">\n                    <div class=\"row\">\n                        <div class=\"col-md-6\">\n                            <h2 class=\"mb-2\">{{ $t(\"General\") }}</h2>\n\n                            <div class=\"my-3\">\n                                <label for=\"type\" class=\"form-label\">{{ $t(\"Monitor Type\") }}</label>\n                                <select id=\"type\" v-model=\"monitor.type\" class=\"form-select\">\n                                    <optgroup :label=\"$t('General Monitor Type')\">\n                                        <option value=\"group\">\n                                            {{ $t(\"Group\") }}\n                                        </option>\n                                        <option value=\"http\">\n                                            HTTP(s)\n                                        </option>\n                                        <option value=\"port\">\n                                            TCP Port\n                                        </option>\n                                        <option value=\"ping\">\n                                            Ping\n                                        </option>\n                                        <option value=\"keyword\">\n                                            HTTP(s) - {{ $t(\"Keyword\") }}\n                                        </option>\n                                        <option value=\"json-query\">\n                                            HTTP(s) - {{ $t(\"Json Query\") }}\n                                        </option>\n                                        <option value=\"grpc-keyword\">\n                                            gRPC(s) - {{ $t(\"Keyword\") }}\n                                        </option>\n                                        <option value=\"dns\">\n                                            DNS\n                                        </option>\n                                        <option value=\"docker\">\n                                            {{ $t(\"Docker Container\") }}\n                                        </option>\n\n                                        <option value=\"real-browser\">\n                                            HTTP(s) - Browser Engine (Chrome/Chromium) (Beta)\n                                        </option>\n                                    </optgroup>\n\n                                    <optgroup :label=\"$t('Passive Monitor Type')\">\n                                        <option value=\"push\">\n                                            Push\n                                        </option>\n                                    </optgroup>\n\n                                    <optgroup :label=\"$t('Specific Monitor Type')\">\n                                        <option value=\"steam\">\n                                            {{ $t(\"Steam Game Server\") }}\n                                        </option>\n                                        <option value=\"gamedig\">\n                                            GameDig\n                                        </option>\n                                        <option value=\"mqtt\">\n                                            MQTT\n                                        </option>\n                                        <option value=\"kafka-producer\">\n                                            Kafka Producer\n                                        </option>\n                                        <option value=\"sqlserver\">\n                                            Microsoft SQL Server\n                                        </option>\n                                        <option value=\"postgres\">\n                                            PostgreSQL\n                                        </option>\n                                        <option value=\"mysql\">\n                                            MySQL/MariaDB\n                                        </option>\n                                        <option value=\"mongodb\">\n                                            MongoDB\n                                        </option>\n                                        <option value=\"radius\">\n                                            Radius\n                                        </option>\n                                        <option value=\"redis\">\n                                            Redis\n                                        </option>\n                                        <option v-if=\"!$root.info.isContainer\" value=\"tailscale-ping\">\n                                            Tailscale Ping\n                                        </option>\n                                    </optgroup>\n                                </select>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'tailscale-ping'\" class=\"alert alert-warning\" role=\"alert\">\n                                {{ $t(\"tailscalePingWarning\") }}\n                            </div>\n\n                            <!-- Friendly Name -->\n                            <div class=\"my-3\">\n                                <label for=\"name\" class=\"form-label\">{{ $t(\"Friendly Name\") }}</label>\n                                <input id=\"name\" v-model=\"monitor.name\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- URL -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' || monitor.type === 'real-browser' \" class=\"my-3\">\n                                <label for=\"url\" class=\"form-label\">{{ $t(\"URL\") }}</label>\n                                <input id=\"url\" v-model=\"monitor.url\" type=\"url\" class=\"form-control\" pattern=\"https?://.+\" required>\n                            </div>\n\n                            <!-- gRPC URL -->\n                            <div v-if=\"monitor.type === 'grpc-keyword' \" class=\"my-3\">\n                                <label for=\"grpc-url\" class=\"form-label\">{{ $t(\"URL\") }}</label>\n                                <input id=\"grpc-url\" v-model=\"monitor.grpcUrl\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Push URL -->\n                            <div v-if=\"monitor.type === 'push' \" class=\"my-3\">\n                                <label for=\"push-url\" class=\"form-label\">{{ $t(\"PushUrl\") }}</label>\n                                <CopyableInput id=\"push-url\" v-model=\"pushURL\" type=\"url\" disabled=\"disabled\" />\n                                <div class=\"form-text\">\n                                    {{ $t(\"needPushEvery\", [monitor.interval]) }}<br />\n                                    {{ $t(\"pushOptionalParams\", [\"status, msg, ping\"]) }}\n                                </div>\n                            </div>\n\n                            <!-- Keyword -->\n                            <div v-if=\"monitor.type === 'keyword' || monitor.type === 'grpc-keyword'\" class=\"my-3\">\n                                <label for=\"keyword\" class=\"form-label\">{{ $t(\"Keyword\") }}</label>\n                                <input id=\"keyword\" v-model=\"monitor.keyword\" type=\"text\" class=\"form-control\" required>\n                                <div class=\"form-text\">\n                                    {{ $t(\"keywordDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Invert keyword -->\n                            <div v-if=\"monitor.type === 'keyword' || monitor.type === 'grpc-keyword'\" class=\"my-3 form-check\">\n                                <input id=\"invert-keyword\" v-model=\"monitor.invertKeyword\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"invert-keyword\">\n                                    {{ $t(\"Invert Keyword\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"invertKeywordDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Json Query -->\n                            <div v-if=\"monitor.type === 'json-query'\" class=\"my-3\">\n                                <label for=\"jsonPath\" class=\"form-label\">{{ $t(\"Json Query\") }}</label>\n                                <input id=\"jsonPath\" v-model=\"monitor.jsonPath\" type=\"text\" class=\"form-control\" required>\n\n                                <!-- eslint-disable-next-line vue/no-v-html -->\n                                <div class=\"form-text\" v-html=\"$t('jsonQueryDescription')\">\n                                </div>\n                                <br>\n\n                                <label for=\"expectedValue\" class=\"form-label\">{{ $t(\"Expected Value\") }}</label>\n                                <input id=\"expectedValue\" v-model=\"monitor.expectedValue\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Game -->\n                            <!-- GameDig only -->\n                            <div v-if=\"monitor.type === 'gamedig'\" class=\"my-3\">\n                                <label for=\"game\" class=\"form-label\"> {{ $t(\"Game\") }} </label>\n                                <select id=\"game\" v-model=\"monitor.game\" class=\"form-select\" required>\n                                    <option v-for=\"game in gameList\" :key=\"game.keys[0]\" :value=\"game.keys[0]\">\n                                        {{ game.pretty }}\n                                    </option>\n                                </select>\n                            </div>\n\n                            <template v-if=\"monitor.type === 'kafka-producer'\">\n                                <!-- Kafka Brokers List -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerBrokers\" class=\"form-label\">{{ $t(\"Kafka Brokers\") }}</label>\n                                    <VueMultiselect\n                                        id=\"kafkaProducerBrokers\"\n                                        v-model=\"monitor.kafkaProducerBrokers\"\n                                        :multiple=\"true\"\n                                        :options=\"[]\"\n                                        :placeholder=\"$t('Enter the list of brokers')\"\n                                        :tag-placeholder=\"$t('Press Enter to add broker')\"\n                                        :max-height=\"500\"\n                                        :taggable=\"true\"\n                                        :show-no-options=\"false\"\n                                        :close-on-select=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :preselect-first=\"false\"\n                                        @tag=\"addKafkaProducerBroker\"\n                                    ></VueMultiselect>\n                                </div>\n\n                                <!-- Kafka Topic Name -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerTopic\" class=\"form-label\">{{ $t(\"Kafka Topic Name\") }}</label>\n                                    <input id=\"kafkaProducerTopic\" v-model=\"monitor.kafkaProducerTopic\" type=\"text\" class=\"form-control\" required>\n                                </div>\n\n                                <!-- Kafka Producer Message -->\n                                <div class=\"my-3\">\n                                    <label for=\"kafkaProducerMessage\" class=\"form-label\">{{ $t(\"Kafka Producer Message\") }}</label>\n                                    <input id=\"kafkaProducerMessage\" v-model=\"monitor.kafkaProducerMessage\" type=\"text\" class=\"form-control\" required>\n                                </div>\n\n                                <!-- Kafka SSL -->\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"kafkaProducerSsl\" v-model=\"monitor.kafkaProducerSsl\" class=\"form-check-input\" type=\"checkbox\">\n                                    <label class=\"form-check-label\" for=\"kafkaProducerSsl\">\n                                        {{ $t(\"Enable Kafka SSL\") }}\n                                    </label>\n                                </div>\n\n                                <!-- Kafka SSL -->\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"kafkaProducerAllowAutoTopicCreation\" v-model=\"monitor.kafkaProducerAllowAutoTopicCreation\" class=\"form-check-input\" type=\"checkbox\">\n                                    <label class=\"form-check-label\" for=\"kafkaProducerAllowAutoTopicCreation\">\n                                        {{ $t(\"Enable Kafka Producer Auto Topic Creation\") }}\n                                    </label>\n                                </div>\n                            </template>\n\n                            <!-- Hostname -->\n                            <!-- TCP Port / Ping / DNS / Steam / MQTT / Radius / Tailscale Ping only -->\n                            <div v-if=\"monitor.type === 'port' || monitor.type === 'ping' || monitor.type === 'dns' || monitor.type === 'steam' || monitor.type === 'gamedig' ||monitor.type === 'mqtt' || monitor.type === 'radius' || monitor.type === 'tailscale-ping'\" class=\"my-3\">\n                                <label for=\"hostname\" class=\"form-label\">{{ $t(\"Hostname\") }}</label>\n                                <input id=\"hostname\" v-model=\"monitor.hostname\" type=\"text\" class=\"form-control\" :pattern=\"`${monitor.type === 'mqtt' ? mqttIpOrHostnameRegexPattern : ipOrHostnameRegexPattern}`\" required>\n                            </div>\n\n                            <!-- Port -->\n                            <!-- For TCP Port / Steam / MQTT / Radius Type -->\n                            <div v-if=\"monitor.type === 'port' || monitor.type === 'steam' || monitor.type === 'gamedig' || monitor.type === 'mqtt' || monitor.type === 'radius'\" class=\"my-3\">\n                                <label for=\"port\" class=\"form-label\">{{ $t(\"Port\") }}</label>\n                                <input id=\"port\" v-model=\"monitor.port\" type=\"number\" class=\"form-control\" required min=\"0\" max=\"65535\" step=\"1\">\n                            </div>\n\n                            <!-- DNS Resolver Server -->\n                            <!-- For DNS Type -->\n                            <template v-if=\"monitor.type === 'dns'\">\n                                <div class=\"my-3\">\n                                    <label for=\"dns_resolve_server\" class=\"form-label\">{{ $t(\"Resolver Server\") }}</label>\n                                    <input id=\"dns_resolve_server\" v-model=\"monitor.dns_resolve_server\" type=\"text\" class=\"form-control\" :pattern=\"ipRegex\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"resolverserverDescription\") }}\n                                    </div>\n                                </div>\n\n                                <!-- Port -->\n                                <div class=\"my-3\">\n                                    <label for=\"port\" class=\"form-label\">{{ $t(\"Port\") }}</label>\n                                    <input id=\"port\" v-model=\"monitor.port\" type=\"number\" class=\"form-control\" required min=\"0\" max=\"65535\" step=\"1\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"dnsPortDescription\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"dns_resolve_type\" class=\"form-label\">{{ $t(\"Resource Record Type\") }}</label>\n\n                                    <!-- :allow-empty=\"false\" is not working, set a default value instead https://github.com/shentao/vue-multiselect/issues/336   -->\n                                    <VueMultiselect\n                                        id=\"dns_resolve_type\"\n                                        v-model=\"monitor.dns_resolve_type\"\n                                        :options=\"dnsresolvetypeOptions\"\n                                        :multiple=\"false\"\n                                        :close-on-select=\"true\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :placeholder=\"$t('Pick a RR-Type...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"500\"\n                                        :taggable=\"false\"\n                                    ></VueMultiselect>\n\n                                    <div class=\"form-text\">\n                                        {{ $t(\"rrtypeDescription\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- Docker Container Name / ID -->\n                            <!-- For Docker Type -->\n                            <div v-if=\"monitor.type === 'docker'\" class=\"my-3\">\n                                <label for=\"docker_container\" class=\"form-label\">{{ $t(\"Container Name / ID\") }}</label>\n                                <input id=\"docker_container\" v-model=\"monitor.docker_container\" type=\"text\" class=\"form-control\" required>\n                            </div>\n\n                            <!-- Docker Host -->\n                            <!-- For Docker Type -->\n                            <div v-if=\"monitor.type === 'docker'\" class=\"my-3\">\n                                <div class=\"mb-3\">\n                                    <label for=\"docker-host\" class=\"form-label\">{{ $t(\"Docker Host\") }}</label>\n                                    <ActionSelect\n                                        id=\"docker-host\"\n                                        v-model=\"monitor.docker_host\"\n                                        :action-aria-label=\"$t('openModalTo', $t('Setup Docker Host'))\"\n                                        :options=\"dockerHostOptionsList\"\n                                        :disabled=\"$root.dockerHostList == null || $root.dockerHostList.length === 0\"\n                                        :icon=\"'plus'\"\n                                        :action=\"() => $refs.dockerHostDialog.show()\"\n                                        :required=\"true\"\n                                    />\n                                </div>\n                            </div>\n\n                            <!-- MQTT -->\n                            <!-- For MQTT Type -->\n                            <template v-if=\"monitor.type === 'mqtt'\">\n                                <div class=\"my-3\">\n                                    <label for=\"mqttUsername\" class=\"form-label\">MQTT {{ $t(\"Username\") }}</label>\n                                    <input id=\"mqttUsername\" v-model=\"monitor.mqttUsername\" type=\"text\" class=\"form-control\">\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttPassword\" class=\"form-label\">MQTT {{ $t(\"Password\") }}</label>\n                                    <input id=\"mqttPassword\" v-model=\"monitor.mqttPassword\" type=\"password\" class=\"form-control\">\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttTopic\" class=\"form-label\">MQTT {{ $t(\"Topic\") }}</label>\n                                    <input id=\"mqttTopic\" v-model=\"monitor.mqttTopic\" type=\"text\" class=\"form-control\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"topicExplanation\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"mqttSuccessMessage\" class=\"form-label\">MQTT {{ $t(\"successMessage\") }}</label>\n                                    <input id=\"mqttSuccessMessage\" v-model=\"monitor.mqttSuccessMessage\" type=\"text\" class=\"form-control\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"successMessageExplanation\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <template v-if=\"monitor.type === 'radius'\">\n                                <div class=\"my-3\">\n                                    <label for=\"radius_username\" class=\"form-label\">Radius {{ $t(\"Username\") }}</label>\n                                    <input id=\"radius_username\" v-model=\"monitor.radiusUsername\" type=\"text\" class=\"form-control\" required />\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_password\" class=\"form-label\">Radius {{ $t(\"Password\") }}</label>\n                                    <input id=\"radius_password\" v-model=\"monitor.radiusPassword\" type=\"password\" class=\"form-control\" required />\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_secret\" class=\"form-label\">{{ $t(\"RadiusSecret\") }}</label>\n                                    <input id=\"radius_secret\" v-model=\"monitor.radiusSecret\" type=\"password\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusSecretDescription\") }} </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_called_station_id\" class=\"form-label\">{{ $t(\"RadiusCalledStationId\") }}</label>\n                                    <input id=\"radius_called_station_id\" v-model=\"monitor.radiusCalledStationId\" type=\"text\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusCalledStationIdDescription\") }} </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"radius_calling_station_id\" class=\"form-label\">{{ $t(\"RadiusCallingStationId\") }}</label>\n                                    <input id=\"radius_calling_station_id\" v-model=\"monitor.radiusCallingStationId\" type=\"text\" class=\"form-control\" required />\n                                    <div class=\"form-text\"> {{ $t( \"RadiusCallingStationIdDescription\") }} </div>\n                                </div>\n                            </template>\n\n                            <!-- SQL Server / PostgreSQL / MySQL / Redis / MongoDB -->\n                            <template v-if=\"monitor.type === 'sqlserver' || monitor.type === 'postgres' || monitor.type === 'mysql' || monitor.type === 'redis' || monitor.type === 'mongodb'\">\n                                <div class=\"my-3\">\n                                    <label for=\"connectionString\" class=\"form-label\">{{ $t(\"Connection String\") }}</label>\n                                    <input id=\"connectionString\" v-model=\"monitor.databaseConnectionString\" type=\"text\" class=\"form-control\" required>\n                                </div>\n                            </template>\n\n                            <template v-if=\"monitor.type === 'mysql'\">\n                                <div class=\"my-3\">\n                                    <label for=\"mysql-password\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                    <!-- TODO: Rename monitor.radiusPassword to monitor.password for general use -->\n                                    <HiddenInput id=\"mysql-password\" v-model=\"monitor.radiusPassword\" autocomplete=\"false\"></HiddenInput>\n                                </div>\n                            </template>\n\n                            <!-- SQL Server / PostgreSQL / MySQL -->\n                            <template v-if=\"monitor.type === 'sqlserver' || monitor.type === 'postgres' || monitor.type === 'mysql'\">\n                                <div class=\"my-3\">\n                                    <label for=\"sqlQuery\" class=\"form-label\">{{ $t(\"Query\") }}</label>\n                                    <textarea id=\"sqlQuery\" v-model=\"monitor.databaseQuery\" class=\"form-control\" :placeholder=\"$t('Example:', [ 'SELECT 1' ])\"></textarea>\n                                </div>\n                            </template>\n\n                            <!-- Interval -->\n                            <div class=\"my-3\">\n                                <label for=\"interval\" class=\"form-label\">{{ $t(\"Heartbeat Interval\") }} ({{ $t(\"checkEverySecond\", [ monitor.interval ]) }})</label>\n                                <input id=\"interval\" v-model=\"monitor.interval\" type=\"number\" class=\"form-control\" required :min=\"minInterval\" step=\"1\" :max=\"maxInterval\" @blur=\"finishUpdateInterval\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"maxRetries\" class=\"form-label\">{{ $t(\"Retries\") }}</label>\n                                <input id=\"maxRetries\" v-model=\"monitor.maxretries\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                                <div class=\"form-text\">\n                                    {{ $t(\"retriesDescription\") }}\n                                </div>\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"retry-interval\" class=\"form-label\">\n                                    {{ $t(\"Heartbeat Retry Interval\") }}\n                                    <span>({{ $t(\"retryCheckEverySecond\", [ monitor.retryInterval ]) }})</span>\n                                </label>\n                                <input id=\"retry-interval\" v-model=\"monitor.retryInterval\" type=\"number\" class=\"form-control\" required :min=\"minInterval\" step=\"1\">\n                            </div>\n\n                            <!-- Timeout: HTTP / Keyword only -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query'\" class=\"my-3\">\n                                <label for=\"timeout\" class=\"form-label\">{{ $t(\"Request Timeout\") }} ({{ $t(\"timeoutAfter\", [ monitor.timeout || clampTimeout(monitor.interval) ]) }})</label>\n                                <input id=\"timeout\" v-model=\"monitor.timeout\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"0.1\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <label for=\"resend-interval\" class=\"form-label\">\n                                    {{ $t(\"Resend Notification if Down X times consecutively\") }}\n                                    <span v-if=\"monitor.resendInterval > 0\">({{ $t(\"resendEveryXTimes\", [ monitor.resendInterval ]) }})</span>\n                                    <span v-else>({{ $t(\"resendDisabled\") }})</span>\n                                </label>\n                                <input id=\"resend-interval\" v-model=\"monitor.resendInterval\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                            </div>\n\n                            <h2 v-if=\"monitor.type !== 'push'\" class=\"mt-5 mb-2\">{{ $t(\"Advanced\") }}</h2>\n\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \" class=\"my-3 form-check\">\n                                <input id=\"expiry-notification\" v-model=\"monitor.expiryNotification\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"expiry-notification\">\n                                    {{ $t(\"Certificate Expiry Notification\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                </div>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \" class=\"my-3 form-check\">\n                                <input id=\"ignore-tls\" v-model=\"monitor.ignoreTls\" class=\"form-check-input\" type=\"checkbox\" value=\"\">\n                                <label class=\"form-check-label\" for=\"ignore-tls\">\n                                    {{ $t(\"ignoreTLSError\") }}\n                                </label>\n                            </div>\n\n                            <div class=\"my-3 form-check\">\n                                <input id=\"upside-down\" v-model=\"monitor.upsideDown\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"upside-down\">\n                                    {{ $t(\"Upside Down Mode\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"upsideDownModeDescription\") }}\n                                </div>\n                            </div>\n\n                            <div v-if=\"monitor.type === 'gamedig'\" class=\"my-3 form-check\">\n                                <input id=\"gamedig-guess-port\" v-model=\"monitor.gamedigGivenPortOnly\" :true-value=\"false\" :false-value=\"true\" class=\"form-check-input\" type=\"checkbox\">\n                                <label class=\"form-check-label\" for=\"gamedig-guess-port\">\n                                    {{ $t(\"gamedigGuessPort\") }}\n                                </label>\n                                <div class=\"form-text\">\n                                    {{ $t(\"gamedigGuessPortDescription\") }}\n                                </div>\n                            </div>\n\n                            <!-- Ping packet size -->\n                            <div v-if=\"monitor.type === 'ping'\" class=\"my-3\">\n                                <label for=\"packet-size\" class=\"form-label\">{{ $t(\"Packet Size\") }}</label>\n                                <input id=\"packet-size\" v-model=\"monitor.packetSize\" type=\"number\" class=\"form-control\" required min=\"1\" max=\"65500\" step=\"1\">\n                            </div>\n\n                            <!-- HTTP / Keyword only -->\n                            <template v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' || monitor.type === 'grpc-keyword' \">\n                                <div class=\"my-3\">\n                                    <label for=\"maxRedirects\" class=\"form-label\">{{ $t(\"Max. Redirects\") }}</label>\n                                    <input id=\"maxRedirects\" v-model=\"monitor.maxredirects\" type=\"number\" class=\"form-control\" required min=\"0\" step=\"1\">\n                                    <div class=\"form-text\">\n                                        {{ $t(\"maxRedirectDescription\") }}\n                                    </div>\n                                </div>\n\n                                <div class=\"my-3\">\n                                    <label for=\"acceptedStatusCodes\" class=\"form-label\">{{ $t(\"Accepted Status Codes\") }}</label>\n\n                                    <VueMultiselect\n                                        id=\"acceptedStatusCodes\"\n                                        v-model=\"monitor.accepted_statuscodes\"\n                                        :options=\"acceptedStatusCodeOptions\"\n                                        :multiple=\"true\"\n                                        :close-on-select=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"true\"\n                                        :placeholder=\"$t('Pick Accepted Status Codes...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"600\"\n                                        :taggable=\"true\"\n                                    ></VueMultiselect>\n\n                                    <div class=\"form-text\">\n                                        {{ $t(\"acceptedStatusCodesDescription\") }}\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- Parent Monitor -->\n                            <div class=\"my-3\">\n                                <label for=\"monitorGroupSelector\" class=\"form-label\">{{ $t(\"Monitor Group\") }}</label>\n                                <ActionSelect\n                                    id=\"monitorGroupSelector\"\n                                    v-model=\"monitor.parent\"\n                                    :action-aria-label=\"$t('openModalTo', 'setup a new monitor group')\"\n                                    :options=\"parentMonitorOptionsList\"\n                                    :disabled=\"sortedGroupMonitorList.length === 0 && draftGroupName == null\"\n                                    :icon=\"'plus'\"\n                                    :action=\"() => $refs.createGroupDialog.show()\"\n                                />\n                            </div>\n\n                            <!-- Description -->\n                            <div class=\"my-3\">\n                                <label for=\"description\" class=\"form-label\">{{ $t(\"Description\") }}</label>\n                                <input id=\"description\" v-model=\"monitor.description\" type=\"text\" class=\"form-control\">\n                            </div>\n\n                            <div class=\"my-3\">\n                                <tags-manager ref=\"tagsManager\" :pre-selected-tags=\"monitor.tags\"></tags-manager>\n                            </div>\n                        </div>\n\n                        <div class=\"col-md-6\">\n                            <div v-if=\"$root.isMobile\" class=\"mt-3\" />\n\n                            <!-- Notifications -->\n                            <h2 class=\"mb-2\">{{ $t(\"Notifications\") }}</h2>\n                            <p v-if=\"$root.notificationList.length === 0\">\n                                {{ $t(\"Not available, please setup.\") }}\n                            </p>\n\n                            <div v-for=\"notification in $root.notificationList\" :key=\"notification.id\" class=\"form-check form-switch my-3\">\n                                <input :id=\" 'notification' + notification.id\" v-model=\"monitor.notificationIDList[notification.id]\" class=\"form-check-input\" type=\"checkbox\">\n\n                                <label class=\"form-check-label\" :for=\" 'notification' + notification.id\">\n                                    {{ notification.name }}\n                                    <a href=\"#\" @click=\"$refs.notificationDialog.show(notification.id)\">{{ $t(\"Edit\") }}</a>\n                                </label>\n\n                                <span v-if=\"notification.isDefault == true\" class=\"badge bg-primary ms-2\">{{ $t(\"Default\") }}</span>\n                            </div>\n\n                            <button class=\"btn btn-primary me-2\" type=\"button\" @click=\"$refs.notificationDialog.show()\">\n                                {{ $t(\"Setup Notification\") }}\n                            </button>\n\n                            <!-- Proxies -->\n                            <div v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query'\">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"Proxy\") }}</h2>\n                                <p v-if=\"$root.proxyList.length === 0\">\n                                    {{ $t(\"Not available, please setup.\") }}\n                                </p>\n\n                                <div v-if=\"$root.proxyList.length > 0\" class=\"form-check my-3\">\n                                    <input id=\"proxy-disable\" v-model=\"monitor.proxyId\" :value=\"null\" name=\"proxy\" class=\"form-check-input\" type=\"radio\">\n                                    <label class=\"form-check-label\" for=\"proxy-disable\">{{ $t(\"No Proxy\") }}</label>\n                                </div>\n\n                                <div v-for=\"proxy in $root.proxyList\" :key=\"proxy.id\" class=\"form-check my-3\">\n                                    <input :id=\"`proxy-${proxy.id}`\" v-model=\"monitor.proxyId\" :value=\"proxy.id\" name=\"proxy\" class=\"form-check-input\" type=\"radio\">\n\n                                    <label class=\"form-check-label\" :for=\"`proxy-${proxy.id}`\">\n                                        {{ proxy.host }}:{{ proxy.port }} ({{ proxy.protocol }})\n                                        <a href=\"#\" @click=\"$refs.proxyDialog.show(proxy.id)\">{{ $t(\"Edit\") }}</a>\n                                    </label>\n\n                                    <span v-if=\"proxy.default === true\" class=\"badge bg-primary ms-2\">{{ $t(\"default\") }}</span>\n                                </div>\n\n                                <button class=\"btn btn-primary me-2\" type=\"button\" @click=\"$refs.proxyDialog.show()\">\n                                    {{ $t(\"Setup Proxy\") }}\n                                </button>\n                            </div>\n\n                            <!-- Kafka SASL Options -->\n                            <!-- Kafka Producer only -->\n                            <template v-if=\"monitor.type === 'kafka-producer'\">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"Kafka SASL Options\") }}</h2>\n                                <div class=\"my-3\">\n                                    <label class=\"form-label\" for=\"kafkaProducerSaslMechanism\">\n                                        {{ $t(\"Mechanism\") }}\n                                    </label>\n                                    <VueMultiselect\n                                        id=\"kafkaProducerSaslMechanism\"\n                                        v-model=\"monitor.kafkaProducerSaslOptions.mechanism\"\n                                        :options=\"kafkaSaslMechanismOptions\"\n                                        :multiple=\"false\"\n                                        :clear-on-select=\"false\"\n                                        :preserve-search=\"false\"\n                                        :placeholder=\"$t('Pick a SASL Mechanism...')\"\n                                        :preselect-first=\"false\"\n                                        :max-height=\"500\"\n                                        :allow-empty=\"false\"\n                                        :taggable=\"false\"\n                                    ></VueMultiselect>\n                                </div>\n                                <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'None'\">\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslUsername\" class=\"form-label\">{{ $t(\"Username\") }}</label>\n                                        <input id=\"kafkaProducerSaslUsername\" v-model=\"monitor.kafkaProducerSaslOptions.username\" type=\"text\" autocomplete=\"kafkaProducerSaslUsername\" class=\"form-control\">\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism !== 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslPassword\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                        <input id=\"kafkaProducerSaslPassword\" v-model=\"monitor.kafkaProducerSaslOptions.password\" type=\"password\" autocomplete=\"kafkaProducerSaslPassword\" class=\"form-control\">\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslAuthorizationIdentity\" class=\"form-label\">{{ $t(\"Authorization Identity\") }}</label>\n                                        <input id=\"kafkaProducerSaslAuthorizationIdentity\" v-model=\"monitor.kafkaProducerSaslOptions.authorizationIdentity\" type=\"text\" autocomplete=\"kafkaProducerSaslAuthorizationIdentity\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslAccessKeyId\" class=\"form-label\">{{ $t(\"AccessKey Id\") }}</label>\n                                        <input id=\"kafkaProducerSaslAccessKeyId\" v-model=\"monitor.kafkaProducerSaslOptions.accessKeyId\" type=\"text\" autocomplete=\"kafkaProducerSaslAccessKeyId\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslSecretAccessKey\" class=\"form-label\">{{ $t(\"Secret AccessKey\") }}</label>\n                                        <input id=\"kafkaProducerSaslSecretAccessKey\" v-model=\"monitor.kafkaProducerSaslOptions.secretAccessKey\" type=\"password\" autocomplete=\"kafkaProducerSaslSecretAccessKey\" class=\"form-control\" required>\n                                    </div>\n                                    <div v-if=\"monitor.kafkaProducerSaslOptions.mechanism === 'aws'\" class=\"my-3\">\n                                        <label for=\"kafkaProducerSaslSessionToken\" class=\"form-label\">{{ $t(\"Session Token\") }}</label>\n                                        <input id=\"kafkaProducerSaslSessionToken\" v-model=\"monitor.kafkaProducerSaslOptions.sessionToken\" type=\"password\" autocomplete=\"kafkaProducerSaslSessionToken\" class=\"form-control\">\n                                    </div>\n                                </div>\n                            </template>\n\n                            <!-- HTTP Options -->\n                            <template v-if=\"monitor.type === 'http' || monitor.type === 'keyword' || monitor.type === 'json-query' \">\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"HTTP Options\") }}</h2>\n\n                                <!-- Method -->\n                                <div class=\"my-3\">\n                                    <label for=\"method\" class=\"form-label\">{{ $t(\"Method\") }}</label>\n                                    <select id=\"method\" v-model=\"monitor.method\" class=\"form-select\">\n                                        <option value=\"GET\">\n                                            GET\n                                        </option>\n                                        <option value=\"POST\">\n                                            POST\n                                        </option>\n                                        <option value=\"PUT\">\n                                            PUT\n                                        </option>\n                                        <option value=\"PATCH\">\n                                            PATCH\n                                        </option>\n                                        <option value=\"DELETE\">\n                                            DELETE\n                                        </option>\n                                        <option value=\"HEAD\">\n                                            HEAD\n                                        </option>\n                                        <option value=\"OPTIONS\">\n                                            OPTIONS\n                                        </option>\n                                    </select>\n                                </div>\n\n                                <!-- Encoding -->\n                                <div class=\"my-3\">\n                                    <label for=\"httpBodyEncoding\" class=\"form-label\">{{ $t(\"Body Encoding\") }}</label>\n                                    <select id=\"httpBodyEncoding\" v-model=\"monitor.httpBodyEncoding\" class=\"form-select\">\n                                        <option value=\"json\">JSON</option>\n                                        <option value=\"xml\">XML</option>\n                                    </select>\n                                </div>\n\n                                <!-- Body -->\n                                <div class=\"my-3\">\n                                    <label for=\"body\" class=\"form-label\">{{ $t(\"Body\") }}</label>\n                                    <textarea id=\"body\" v-model=\"monitor.body\" class=\"form-control\" :placeholder=\"bodyPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Headers -->\n                                <div class=\"my-3\">\n                                    <label for=\"headers\" class=\"form-label\">{{ $t(\"Headers\") }}</label>\n                                    <textarea id=\"headers\" v-model=\"monitor.headers\" class=\"form-control\" :placeholder=\"headersPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- HTTP Auth -->\n                                <h4 class=\"mt-5 mb-2\">{{ $t(\"Authentication\") }}</h4>\n\n                                <!-- Method -->\n                                <div class=\"my-3\">\n                                    <label for=\"method\" class=\"form-label\">{{ $t(\"Method\") }}</label>\n                                    <select id=\"method\" v-model=\"monitor.authMethod\" class=\"form-select\">\n                                        <option :value=\"null\">\n                                            {{ $t(\"None\") }}\n                                        </option>\n                                        <option value=\"basic\">\n                                            {{ $t(\"HTTP Basic Auth\") }}\n                                        </option>\n                                        <option value=\"oauth2-cc\">\n                                            {{ $t(\"OAuth2: Client Credentials\") }}\n                                        </option>\n                                        <option value=\"ntlm\">\n                                            NTLM\n                                        </option>\n                                        <option value=\"mtls\">\n                                            mTLS\n                                        </option>\n                                    </select>\n                                </div>\n                                <template v-if=\"monitor.authMethod && monitor.authMethod !== null \">\n                                    <template v-if=\"monitor.authMethod === 'mtls' \">\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-cert\" class=\"form-label\">{{ $t(\"Cert\") }}</label>\n                                            <textarea id=\"tls-cert\" v-model=\"monitor.tlsCert\" class=\"form-control\" :placeholder=\"$t('Cert body')\" required></textarea>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-key\" class=\"form-label\">{{ $t(\"Key\") }}</label>\n                                            <textarea id=\"tls-key\" v-model=\"monitor.tlsKey\" class=\"form-control\" :placeholder=\"$t('Key body')\" required></textarea>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"tls-ca\" class=\"form-label\">{{ $t(\"CA\") }}</label>\n                                            <textarea id=\"tls-ca\" v-model=\"monitor.tlsCa\" class=\"form-control\" :placeholder=\"$t('Server CA')\"></textarea>\n                                        </div>\n                                    </template>\n                                    <template v-else-if=\"monitor.authMethod === 'oauth2-cc' \">\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_auth_method\" class=\"form-label\">{{ $t(\"Authentication Method\") }}</label>\n                                            <select id=\"oauth_auth_method\" v-model=\"monitor.oauth_auth_method\" class=\"form-select\">\n                                                <option value=\"client_secret_basic\">\n                                                    {{ $t(\"Authorization Header\") }}\n                                                </option>\n                                                <option value=\"client_secret_post\">\n                                                    {{ $t(\"Form Data Body\") }}\n                                                </option>\n                                            </select>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_token_url\" class=\"form-label\">{{ $t(\"OAuth Token URL\") }}</label>\n                                            <input id=\"oauth_token_url\" v-model=\"monitor.oauth_token_url\" type=\"text\" class=\"form-control\" :placeholder=\"$t('OAuth Token URL')\" required>\n                                        </div>\n                                        <div class=\"my-3\">\n                                            <label for=\"oauth_client_id\" class=\"form-label\">{{ $t(\"Client ID\") }}</label>\n                                            <input id=\"oauth_client_id\" v-model=\"monitor.oauth_client_id\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Client ID')\" required>\n                                        </div>\n                                        <template v-if=\"monitor.oauth_auth_method === 'client_secret_post' || monitor.oauth_auth_method === 'client_secret_basic'\">\n                                            <div class=\"my-3\">\n                                                <label for=\"oauth_client_secret\" class=\"form-label\">{{ $t(\"Client Secret\") }}</label>\n                                                <input id=\"oauth_client_secret\" v-model=\"monitor.oauth_client_secret\" type=\"password\" class=\"form-control\" :placeholder=\"$t('Client Secret')\" required>\n                                            </div>\n                                            <div class=\"my-3\">\n                                                <label for=\"oauth_scopes\" class=\"form-label\">{{ $t(\"OAuth Scope\") }}</label>\n                                                <input id=\"oauth_scopes\" v-model=\"monitor.oauth_scopes\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Optional: Space separated list of scopes')\">\n                                            </div>\n                                        </template>\n                                    </template>\n                                    <template v-else>\n                                        <div class=\"my-3\">\n                                            <label for=\"basicauth-user\" class=\"form-label\">{{ $t(\"Username\") }}</label>\n                                            <input id=\"basicauth-user\" v-model=\"monitor.basic_auth_user\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Username')\">\n                                        </div>\n\n                                        <div class=\"my-3\">\n                                            <label for=\"basicauth-pass\" class=\"form-label\">{{ $t(\"Password\") }}</label>\n                                            <input id=\"basicauth-pass\" v-model=\"monitor.basic_auth_pass\" type=\"password\" autocomplete=\"new-password\" class=\"form-control\" :placeholder=\"$t('Password')\">\n                                        </div>\n                                        <template v-if=\"monitor.authMethod === 'ntlm' \">\n                                            <div class=\"my-3\">\n                                                <label for=\"ntlm-domain\" class=\"form-label\">{{ $t(\"Domain\") }}</label>\n                                                <input id=\"ntlm-domain\" v-model=\"monitor.authDomain\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Domain')\">\n                                            </div>\n\n                                            <div class=\"my-3\">\n                                                <label for=\"ntlm-workstation\" class=\"form-label\">{{ $t(\"Workstation\") }}</label>\n                                                <input id=\"ntlm-workstation\" v-model=\"monitor.authWorkstation\" type=\"text\" class=\"form-control\" :placeholder=\"$t('Workstation')\">\n                                            </div>\n                                        </template>\n                                    </template>\n                                </template>\n                            </template>\n\n                            <!-- gRPC Options -->\n                            <template v-if=\"monitor.type === 'grpc-keyword' \">\n                                <!-- Proto service enable TLS -->\n                                <h2 class=\"mt-5 mb-2\">{{ $t(\"GRPC Options\") }}</h2>\n                                <div class=\"my-3 form-check\">\n                                    <input id=\"grpc-enable-tls\" v-model=\"monitor.grpcEnableTls\" class=\"form-check-input\" type=\"checkbox\" value=\"\">\n                                    <label class=\"form-check-label\" for=\"grpc-enable-tls\">\n                                        {{ $t(\"Enable TLS\") }}\n                                    </label>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"enableGRPCTls\") }}\n                                    </div>\n                                </div>\n                                <!-- Proto service name data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Service Name\") }}</label>\n                                    <input id=\"name\" v-model=\"monitor.grpcServiceName\" type=\"text\" class=\"form-control\" :placeholder=\"protoServicePlaceholder\" required>\n                                </div>\n\n                                <!-- Proto method data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Method\") }}</label>\n                                    <input id=\"name\" v-model=\"monitor.grpcMethod\" type=\"text\" class=\"form-control\" :placeholder=\"protoMethodPlaceholder\" required>\n                                    <div class=\"form-text\">\n                                        {{ $t(\"grpcMethodDescription\") }}\n                                    </div>\n                                </div>\n\n                                <!-- Proto data -->\n                                <div class=\"my-3\">\n                                    <label for=\"protobuf\" class=\"form-label\">{{ $t(\"Proto Content\") }}</label>\n                                    <textarea id=\"protobuf\" v-model=\"monitor.grpcProtobuf\" class=\"form-control\" :placeholder=\"protoBufDataPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Body -->\n                                <div class=\"my-3\">\n                                    <label for=\"body\" class=\"form-label\">{{ $t(\"Body\") }}</label>\n                                    <textarea id=\"body\" v-model=\"monitor.grpcBody\" class=\"form-control\" :placeholder=\"bodyPlaceholder\"></textarea>\n                                </div>\n\n                                <!-- Metadata: temporary disable waiting for next PR allow to send gRPC with metadata -->\n                                <template v-if=\"false\">\n                                    <div class=\"my-3\">\n                                        <label for=\"metadata\" class=\"form-label\">{{ $t(\"Metadata\") }}</label>\n                                        <textarea id=\"metadata\" v-model=\"monitor.grpcMetadata\" class=\"form-control\" :placeholder=\"headersPlaceholder\"></textarea>\n                                    </div>\n                                </template>\n                            </template>\n                        </div>\n                    </div>\n\n                    <div class=\"fixed-bottom-bar p-3\">\n                        <button id=\"monitor-submit-btn\" class=\"btn btn-primary\" type=\"submit\" :disabled=\"processing\">{{ $t(\"Save\") }}</button>\n                    </div>\n                </div>\n            </form>\n\n            <NotificationDialog ref=\"notificationDialog\" @added=\"addedNotification\" />\n            <DockerHostDialog ref=\"dockerHostDialog\" @added=\"addedDockerHost\" />\n            <ProxyDialog ref=\"proxyDialog\" @added=\"addedProxy\" />\n            <CreateGroupDialog ref=\"createGroupDialog\" @added=\"addedDraftGroup\" />\n        </div>\n    </transition>\n</template>\n\n<script>\nimport VueMultiselect from \"vue-multiselect\";\nimport { useToast } from \"vue-toastification\";\nimport ActionSelect from \"../components/ActionSelect.vue\";\nimport CopyableInput from \"../components/CopyableInput.vue\";\nimport CreateGroupDialog from \"../components/CreateGroupDialog.vue\";\nimport NotificationDialog from \"../components/NotificationDialog.vue\";\nimport DockerHostDialog from \"../components/DockerHostDialog.vue\";\nimport ProxyDialog from \"../components/ProxyDialog.vue\";\nimport TagsManager from \"../components/TagsManager.vue\";\nimport { genSecret, isDev, MAX_INTERVAL_SECOND, MIN_INTERVAL_SECOND, sleep } from \"../util.ts\";\nimport { hostNameRegexPattern } from \"../util-frontend\";\nimport HiddenInput from \"../components/HiddenInput.vue\";\n\nconst toast = useToast();\n\nconst monitorDefaults = {\n    type: \"http\",\n    name: \"\",\n    parent: null,\n    url: \"https://\",\n    method: \"GET\",\n    interval: 60,\n    retryInterval: 60,\n    resendInterval: 0,\n    maxretries: 0,\n    timeout: 48,\n    notificationIDList: {},\n    ignoreTls: false,\n    upsideDown: false,\n    packetSize: 56,\n    expiryNotification: false,\n    maxredirects: 10,\n    accepted_statuscodes: [ \"200-299\" ],\n    dns_resolve_type: \"A\",\n    dns_resolve_server: \"1.1.1.1\",\n    docker_container: \"\",\n    docker_host: null,\n    proxyId: null,\n    mqttUsername: \"\",\n    mqttPassword: \"\",\n    mqttTopic: \"\",\n    mqttSuccessMessage: \"\",\n    authMethod: null,\n    oauth_auth_method: \"client_secret_basic\",\n    httpBodyEncoding: \"json\",\n    kafkaProducerBrokers: [],\n    kafkaProducerSaslOptions: {\n        mechanism: \"None\",\n    },\n    kafkaProducerSsl: false,\n    kafkaProducerAllowAutoTopicCreation: false,\n    gamedigGivenPortOnly: true,\n};\n\nexport default {\n    components: {\n        HiddenInput,\n        ActionSelect,\n        ProxyDialog,\n        CopyableInput,\n        CreateGroupDialog,\n        NotificationDialog,\n        DockerHostDialog,\n        TagsManager,\n        VueMultiselect,\n    },\n\n    data() {\n        return {\n            minInterval: MIN_INTERVAL_SECOND,\n            maxInterval: MAX_INTERVAL_SECOND,\n            processing: false,\n            monitor: {\n                notificationIDList: {},\n                // Do not add default value here, please check init() method\n            },\n            acceptedStatusCodeOptions: [],\n            dnsresolvetypeOptions: [],\n            kafkaSaslMechanismOptions: [],\n            ipOrHostnameRegexPattern: hostNameRegexPattern(),\n            mqttIpOrHostnameRegexPattern: hostNameRegexPattern(true),\n            gameList: null,\n            connectionStringTemplates: {\n                \"sqlserver\": \"Server=<hostname>,<port>;Database=<your database>;User Id=<your user id>;Password=<your password>;Encrypt=<true/false>;TrustServerCertificate=<Yes/No>;Connection Timeout=<int>\",\n                \"postgres\": \"postgres://username:password@host:port/database\",\n                \"mysql\": \"mysql://username:password@host:port/database\",\n                \"redis\": \"redis://user:password@host:port\",\n                \"mongodb\": \"mongodb://username:password@host:port/database\",\n            },\n            draftGroupName: null,\n        };\n    },\n\n    computed: {\n\n        ipRegex() {\n\n            // Allow to test with simple dns server with port (127.0.0.1:5300)\n            if (! isDev) {\n                return this.ipRegexPattern;\n            }\n            return null;\n        },\n\n        pageName() {\n            let name = \"Add New Monitor\";\n            if (this.isClone) {\n                name = \"Clone Monitor\";\n            } else if (this.isEdit) {\n                name = \"Edit\";\n            }\n            return this.$t(name);\n        },\n\n        isAdd() {\n            return this.$route.path === \"/add\";\n        },\n\n        isClone() {\n            return this.$route.path.startsWith(\"/clone\");\n        },\n\n        isEdit() {\n            return this.$route.path.startsWith(\"/edit\");\n        },\n\n        pushURL() {\n            return this.$root.baseURL + \"/api/push/\" + this.monitor.pushToken + \"?status=up&msg=OK&ping=\";\n        },\n\n        protoServicePlaceholder() {\n            return this.$t(\"Example:\", [ \"Health\" ]);\n        },\n\n        protoMethodPlaceholder() {\n            return this.$t(\"Example:\", [ \"check\" ]);\n        },\n\n        protoBufDataPlaceholder() {\n            return this.$t(\"Example:\", [ `\nsyntax = \"proto3\";\n\npackage grpc.health.v1;\n\nservice Health {\n  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);\n  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);\n}\n\nmessage HealthCheckRequest {\n  string service = 1;\n}\n\nmessage HealthCheckResponse {\n  enum ServingStatus {\n    UNKNOWN = 0;\n    SERVING = 1;\n    NOT_SERVING = 2;\n    SERVICE_UNKNOWN = 3;  // Used only by the Watch method.\n  }\n  ServingStatus status = 1;\n}\n            ` ]);\n        },\n        bodyPlaceholder() {\n            if (this.monitor && this.monitor.httpBodyEncoding && this.monitor.httpBodyEncoding === \"xml\") {\n                return this.$t(\"Example:\", [ `\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\">\n  <soap:Body>\n    <Uptime>Kuma</Uptime>\n  </soap:Body>\n</soap:Envelope>` ]);\n            }\n            return this.$t(\"Example:\", [ `\n{\n    \"key\": \"value\"\n}` ]);\n        },\n\n        headersPlaceholder() {\n            return this.$t(\"Example:\", [ `\n{\n    \"HeaderName\": \"HeaderValue\"\n}` ]);\n        },\n\n        currentGameObject() {\n            if (this.gameList) {\n                for (let game of this.gameList) {\n                    if (game.keys[0] === this.monitor.game) {\n                        return game;\n                    }\n                }\n            }\n            return null;\n        },\n\n        // Filter result by active state, weight and alphabetical\n        // Only return groups which arent't itself and one of its decendants\n        sortedGroupMonitorList() {\n            let result = Object.values(this.$root.monitorList);\n\n            // Only groups, not itself, not a decendant\n            result = result.filter(\n                monitor => monitor.type === \"group\" &&\n\t\t\t\tmonitor.id !== this.monitor.id &&\n\t\t\t\t!this.monitor.childrenIDs?.includes(monitor.id)\n            );\n\n            // Filter result by active state, weight and alphabetical\n            result.sort((m1, m2) => {\n\n                if (m1.active !== m2.active) {\n                    if (m1.active === 0) {\n                        return 1;\n                    }\n\n                    if (m2.active === 0) {\n                        return -1;\n                    }\n                }\n\n                if (m1.weight !== m2.weight) {\n                    if (m1.weight > m2.weight) {\n                        return -1;\n                    }\n\n                    if (m1.weight < m2.weight) {\n                        return 1;\n                    }\n                }\n\n                return m1.pathName.localeCompare(m2.pathName);\n            });\n\n            return result;\n        },\n\n        /**\n         * Generates the parent monitor options list based on the sorted group monitor list and draft group name.\n         *\n         * @return {Array} The parent monitor options list.\n         */\n        parentMonitorOptionsList() {\n            let list = [];\n            if (this.sortedGroupMonitorList.length === 0 && this.draftGroupName == null) {\n                list = [\n                    {\n                        label: this.$t(\"noGroupMonitorMsg\"),\n                        value: null\n                    }\n                ];\n            } else {\n                list = [\n                    {\n                        label: this.$t(\"None\"),\n                        value: null\n                    },\n                    ... this.sortedGroupMonitorList.map(monitor => {\n                        return {\n                            label: monitor.pathName,\n                            value: monitor.id,\n                        };\n                    }),\n                ];\n            }\n\n            if (this.draftGroupName != null) {\n                list = [{\n                    label: this.draftGroupName,\n                    value: -1,\n                }].concat(list);\n            }\n\n            return list;\n        },\n\n        dockerHostOptionsList() {\n            if (this.$root.dockerHostList && this.$root.dockerHostList.length > 0) {\n                return this.$root.dockerHostList.map((host) => {\n                    return {\n                        label: host.name,\n                        value: host.id\n                    };\n                });\n            } else {\n                return [{\n                    label: this.$t(\"noDockerHostMsg\"),\n                    value: null,\n                }];\n            }\n        }\n    },\n    watch: {\n        \"$root.proxyList\"() {\n            if (this.isAdd) {\n                if (this.$root.proxyList && !this.monitor.proxyId) {\n                    const proxy = this.$root.proxyList.find(proxy => proxy.default);\n\n                    if (proxy) {\n                        this.monitor.proxyId = proxy.id;\n                    }\n                }\n            }\n        },\n\n        \"$route.fullPath\"() {\n            this.init();\n        },\n\n        \"monitor.interval\"(value, oldValue) {\n            // Link interval and retryInterval if they are the same value.\n            if (this.monitor.retryInterval === oldValue) {\n                this.monitor.retryInterval = value;\n            }\n        },\n\n        \"monitor.timeout\"(value, oldValue) {\n            // keep timeout within 80% range\n            if (value && value !== oldValue) {\n                this.monitor.timeout = this.clampTimeout(value);\n            }\n        },\n\n        \"monitor.type\"() {\n            if (this.monitor.type === \"push\") {\n                if (! this.monitor.pushToken) {\n                    this.monitor.pushToken = genSecret(10);\n                }\n            }\n\n            // Set default port for DNS if not already defined\n            if (! this.monitor.port || this.monitor.port === \"53\" || this.monitor.port === \"1812\") {\n                if (this.monitor.type === \"dns\") {\n                    this.monitor.port = \"53\";\n                } else if (this.monitor.type === \"radius\") {\n                    this.monitor.port = \"1812\";\n                } else {\n                    this.monitor.port = undefined;\n                }\n            }\n\n            // Get the game list from server\n            if (this.monitor.type === \"gamedig\") {\n                this.$root.getSocket().emit(\"getGameList\", (res) => {\n                    if (res.ok) {\n                        this.gameList = res.gameList;\n                    } else {\n                        toast.error(res.msg);\n                    }\n                });\n            }\n\n            // Set default database connection string if empty or it is a template from another database monitor type\n            for (let monitorType in this.connectionStringTemplates) {\n                if (this.monitor.type === monitorType) {\n                    let isTemplate = false;\n                    for (let key in this.connectionStringTemplates) {\n                        if (this.monitor.databaseConnectionString === this.connectionStringTemplates[key]) {\n                            isTemplate = true;\n                            break;\n                        }\n                    }\n                    if (!this.monitor.databaseConnectionString || isTemplate) {\n                        this.monitor.databaseConnectionString = this.connectionStringTemplates[monitorType];\n                    }\n                    break;\n                }\n            }\n\n        },\n\n        currentGameObject(newGameObject, previousGameObject) {\n            if (!this.monitor.port || (previousGameObject && previousGameObject.options.port === this.monitor.port)) {\n                this.monitor.port = newGameObject.options.port;\n            }\n            this.monitor.game = newGameObject.keys[0];\n        },\n    },\n    mounted() {\n        this.init();\n\n        let acceptedStatusCodeOptions = [\n            \"100-199\",\n            \"200-299\",\n            \"300-399\",\n            \"400-499\",\n            \"500-599\",\n        ];\n\n        let dnsresolvetypeOptions = [\n            \"A\",\n            \"AAAA\",\n            \"CAA\",\n            \"CNAME\",\n            \"MX\",\n            \"NS\",\n            \"PTR\",\n            \"SOA\",\n            \"SRV\",\n            \"TXT\",\n        ];\n\n        let kafkaSaslMechanismOptions = [\n            \"None\",\n            \"plain\",\n            \"scram-sha-256\",\n            \"scram-sha-512\",\n            \"aws\",\n        ];\n\n        for (let i = 100; i <= 999; i++) {\n            acceptedStatusCodeOptions.push(i.toString());\n        }\n\n        this.acceptedStatusCodeOptions = acceptedStatusCodeOptions;\n        this.dnsresolvetypeOptions = dnsresolvetypeOptions;\n        this.kafkaSaslMechanismOptions = kafkaSaslMechanismOptions;\n    },\n    methods: {\n        /** Initialize the edit monitor form */\n        init() {\n            if (this.isAdd) {\n\n                this.monitor = {\n                    ...monitorDefaults\n                };\n\n                if (this.$root.proxyList && !this.monitor.proxyId) {\n                    const proxy = this.$root.proxyList.find(proxy => proxy.default);\n\n                    if (proxy) {\n                        this.monitor.proxyId = proxy.id;\n                    }\n                }\n\n                for (let i = 0; i < this.$root.notificationList.length; i++) {\n                    if (this.$root.notificationList[i].isDefault === true) {\n                        this.monitor.notificationIDList[this.$root.notificationList[i].id] = true;\n                    }\n                }\n            } else if (this.isEdit || this.isClone) {\n                this.$root.getSocket().emit(\"getMonitor\", this.$route.params.id, (res) => {\n                    if (res.ok) {\n\n                        if (this.isClone) {\n                            // Reset push token for cloned monitors\n                            if (res.monitor.type === \"push\") {\n                                res.monitor.pushToken = undefined;\n                            }\n                        }\n\n                        this.monitor = res.monitor;\n\n                        if (this.isClone) {\n                            /*\n                            * Cloning a monitor will include properties that can not be posted to backend\n                            * as they are not valid columns in the SQLite table.\n                            */\n                            this.monitor.id = undefined; // Remove id when cloning as we want a new id\n                            this.monitor.includeSensitiveData = undefined;\n                            this.monitor.maintenance = undefined;\n                            // group monitor fields\n                            this.monitor.childrenIDs = undefined;\n                            this.monitor.forceInactive = undefined;\n                            this.monitor.pathName = undefined;\n                            this.monitor.screenshot = undefined;\n\n                            this.monitor.name = this.$t(\"cloneOf\", [ this.monitor.name ]);\n                            this.$refs.tagsManager.newTags = this.monitor.tags.map((monitorTag) => {\n                                return {\n                                    id: monitorTag.tag_id,\n                                    name: monitorTag.name,\n                                    color: monitorTag.color,\n                                    value: monitorTag.value,\n                                    new: true,\n                                };\n                            });\n                            this.monitor.tags = undefined;\n                        }\n\n                        // Handling for monitors that are created before 1.7.0\n                        if (this.monitor.retryInterval === 0) {\n                            this.monitor.retryInterval = this.monitor.interval;\n                        }\n                        // Handling for monitors that are missing/zeroed timeout\n                        if (!this.monitor.timeout) {\n                            this.monitor.timeout = ~~(this.monitor.interval * 8) / 10;\n                        }\n                    } else {\n                        toast.error(res.msg);\n                    }\n                });\n            }\n\n            this.draftGroupName = null;\n\n        },\n\n        addKafkaProducerBroker(newBroker) {\n            this.monitor.kafkaProducerBrokers.push(newBroker);\n        },\n\n        /**\n         * Validate form input\n         * @returns {boolean} Is the form input valid?\n         */\n        isInputValid() {\n            if (this.monitor.body && (!this.monitor.httpBodyEncoding || this.monitor.httpBodyEncoding === \"json\")) {\n                try {\n                    JSON.parse(this.monitor.body);\n                } catch (err) {\n                    toast.error(this.$t(\"BodyInvalidFormat\") + err.message);\n                    return false;\n                }\n            }\n            if (this.monitor.headers) {\n                try {\n                    JSON.parse(this.monitor.headers);\n                } catch (err) {\n                    toast.error(this.$t(\"HeadersInvalidFormat\") + err.message);\n                    return false;\n                }\n            }\n            if (this.monitor.type === \"docker\") {\n                if (this.monitor.docker_host == null) {\n                    toast.error(this.$t(\"DockerHostRequired\"));\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Submit the form data for processing\n         * @returns {void}\n         */\n        async submit() {\n\n            this.processing = true;\n\n            if (!this.isInputValid()) {\n                this.processing = false;\n                return;\n            }\n\n            // Beautify the JSON format (only if httpBodyEncoding is not set or === json)\n            if (this.monitor.body && (!this.monitor.httpBodyEncoding || this.monitor.httpBodyEncoding === \"json\")) {\n                this.monitor.body = JSON.stringify(JSON.parse(this.monitor.body), null, 4);\n            }\n\n            const monitorTypesWithEncodingAllowed = [ \"http\", \"keyword\", \"json-query\" ];\n            if (this.monitor.type && !monitorTypesWithEncodingAllowed.includes(this.monitor.type)) {\n                this.monitor.httpBodyEncoding = null;\n            }\n\n            if (this.monitor.headers) {\n                this.monitor.headers = JSON.stringify(JSON.parse(this.monitor.headers), null, 4);\n            }\n\n            if (this.monitor.hostname) {\n                this.monitor.hostname = this.monitor.hostname.trim();\n            }\n\n            if (this.monitor.url) {\n                this.monitor.url = this.monitor.url.trim();\n            }\n\n            let createdNewParent = false;\n\n            if (this.draftGroupName && this.monitor.parent === -1) {\n                // Create Monitor with name of draft group\n                const res = await new Promise((resolve) => {\n                    this.$root.add({\n                        ...monitorDefaults,\n                        type: \"group\",\n                        name: this.draftGroupName,\n                        interval: this.monitor.interval,\n                        active: false,\n                    }, resolve);\n                });\n\n                if (res.ok) {\n                    createdNewParent = true;\n                    this.monitor.parent = res.monitorID;\n                } else {\n                    toast.error(res.msg);\n                    this.processing = false;\n                    return;\n                }\n            }\n\n            if (this.isAdd || this.isClone) {\n                this.$root.add(this.monitor, async (res) => {\n\n                    if (res.ok) {\n                        await this.$refs.tagsManager.submit(res.monitorID);\n\n                        // Start the new parent monitor after edit is done\n                        if (createdNewParent) {\n                            this.startParentGroupMonitor();\n                        }\n\n                        toast.success(res.msg);\n                        this.processing = false;\n                        this.$root.getMonitorList();\n                        this.$router.push(\"/dashboard/\" + res.monitorID);\n\n                    } else {\n                        toast.error(res.msg);\n                        this.processing = false;\n                    }\n\n                });\n            } else {\n                await this.$refs.tagsManager.submit(this.monitor.id);\n\n                this.$root.getSocket().emit(\"editMonitor\", this.monitor, (res) => {\n                    this.processing = false;\n                    this.$root.toastRes(res);\n                    this.init();\n\n                    // Start the new parent monitor after edit is done\n                    if (createdNewParent) {\n                        this.startParentGroupMonitor();\n                    }\n                });\n            }\n        },\n\n        async startParentGroupMonitor() {\n            await sleep(2000);\n            await this.$root.getSocket().emit(\"resumeMonitor\", this.monitor.parent, () => {});\n        },\n\n        /**\n         * Added a Notification Event\n         * Enable it if the notification is added in EditMonitor.vue\n         * @param {number} id ID of notification to add\n         */\n        addedNotification(id) {\n            this.monitor.notificationIDList[id] = true;\n        },\n\n        /**\n         * Added a Proxy Event\n         * Enable it if the proxy is added in EditMonitor.vue\n         * @param {number} id ID of proxy to add\n         */\n        addedProxy(id) {\n            this.monitor.proxyId = id;\n        },\n\n        // Added a Docker Host Event\n        // Enable it if the Docker Host is added in EditMonitor.vue\n        addedDockerHost(id) {\n            this.monitor.docker_host = id;\n        },\n\n        /**\n         * Adds a draft group.\n         *\n         * @param {string} draftGroupName - The name of the draft group.\n         */\n        addedDraftGroup(draftGroupName) {\n            this.draftGroupName = draftGroupName;\n            this.monitor.parent = -1;\n        },\n\n        // Clamp timeout\n        clampTimeout(timeout) {\n            // limit to 80% of interval, narrowly avoiding epsilon bug\n            const maxTimeout = ~~(this.monitor.interval * 8 ) / 10;\n            const clamped = Math.max(0, Math.min(timeout, maxTimeout));\n\n            // 0 will be treated as 80% of interval\n            return Number.isFinite(clamped) ? clamped : maxTimeout;\n        },\n\n        finishUpdateInterval() {\n            // Update timeout if it is greater than the clamp timeout\n            let clampedValue = this.clampTimeout(this.monitor.interval);\n            if (this.monitor.timeout > clampedValue) {\n                this.monitor.timeout = clampedValue;\n            }\n        },\n\n    },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n    @import \"../assets/vars.scss\";\n\n    textarea {\n        min-height: 200px;\n    }\n</style>\n", "\"use strict\";\n// Common Util for frontend and backend\n//\n// DOT NOT MODIFY util.js!\n// Need to run \"tsc\" to compile if there are any changes.\n//\n// Backend uses the compiled file util.js\n// Frontend uses util.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.localToUTC = exports.utcToLocal = exports.utcToISODateTime = exports.isoToUTCDateTime = exports.parseTimeFromTimeObject = exports.parseTimeObject = exports.getMaintenanceRelativeURL = exports.getMonitorRelativeURL = exports.genSecret = exports.getCryptoRandomInt = exports.getRandomInt = exports.getRandomArbitrary = exports.TimeLogger = exports.polyfill = exports.log = exports.debug = exports.ucfirst = exports.sleep = exports.flipStatus = exports.badgeConstants = exports.MIN_INTERVAL_SECOND = exports.MAX_INTERVAL_SECOND = exports.SQL_DATETIME_FORMAT_WITHOUT_SECOND = exports.SQL_DATETIME_FORMAT = exports.SQL_DATE_FORMAT = exports.STATUS_PAGE_MAINTENANCE = exports.STATUS_PAGE_PARTIAL_DOWN = exports.STATUS_PAGE_ALL_UP = exports.STATUS_PAGE_ALL_DOWN = exports.MAINTENANCE = exports.PENDING = exports.UP = exports.DOWN = exports.appName = exports.isDev = void 0;\nconst dayjs = require(\"dayjs\");\nexports.isDev = process.env.NODE_ENV === \"development\";\nexports.appName = \"Uptime Kuma\";\nexports.DOWN = 0;\nexports.UP = 1;\nexports.PENDING = 2;\nexports.MAINTENANCE = 3;\nexports.STATUS_PAGE_ALL_DOWN = 0;\nexports.STATUS_PAGE_ALL_UP = 1;\nexports.STATUS_PAGE_PARTIAL_DOWN = 2;\nexports.STATUS_PAGE_MAINTENANCE = 3;\nexports.SQL_DATE_FORMAT = \"YYYY-MM-DD\";\nexports.SQL_DATETIME_FORMAT = \"YYYY-MM-DD HH:mm:ss\";\nexports.SQL_DATETIME_FORMAT_WITHOUT_SECOND = \"YYYY-MM-DD HH:mm\";\nexports.MAX_INTERVAL_SECOND = 2073600; // 24 days\nexports.MIN_INTERVAL_SECOND = 20; // 20 seconds\nexports.badgeConstants = {\n    naColor: \"#999\",\n    defaultUpColor: \"#66c20a\",\n    defaultWarnColor: \"#eed202\",\n    defaultDownColor: \"#c2290a\",\n    defaultPendingColor: \"#f8a306\",\n    defaultMaintenanceColor: \"#1747f5\",\n    defaultPingColor: \"blue\",\n    defaultStyle: \"flat\",\n    defaultPingValueSuffix: \"ms\",\n    defaultPingLabelSuffix: \"h\",\n    defaultUptimeValueSuffix: \"%\",\n    defaultUptimeLabelSuffix: \"h\",\n    defaultCertExpValueSuffix: \" days\",\n    defaultCertExpLabelSuffix: \"h\",\n    // Values Come From Default Notification Times\n    defaultCertExpireWarnDays: \"14\",\n    defaultCertExpireDownDays: \"7\"\n};\n/** Flip the status of s */\nfunction flipStatus(s) {\n    if (s === exports.UP) {\n        return exports.DOWN;\n    }\n    if (s === exports.DOWN) {\n        return exports.UP;\n    }\n    return s;\n}\nexports.flipStatus = flipStatus;\n/**\n * Delays for specified number of seconds\n * @param ms Number of milliseconds to sleep for\n */\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.sleep = sleep;\n/**\n * PHP's ucfirst\n * @param str\n */\nfunction ucfirst(str) {\n    if (!str) {\n        return str;\n    }\n    const firstLetter = str.substr(0, 1);\n    return firstLetter.toUpperCase() + str.substr(1);\n}\nexports.ucfirst = ucfirst;\n/**\n * @deprecated Use log.debug\n * @since https://github.com/louislam/uptime-kuma/pull/910\n * @param msg\n */\nfunction debug(msg) {\n    exports.log.log(\"\", msg, \"debug\");\n}\nexports.debug = debug;\nclass Logger {\n    constructor() {\n        /**\n         * UPTIME_KUMA_HIDE_LOG=debug_monitor,info_monitor\n         *\n         * Example:\n         *  [\n         *     \"debug_monitor\",          // Hide all logs that level is debug and the module is monitor\n         *     \"info_monitor\",\n         *  ]\n         */\n        this.hideLog = {\n            info: [],\n            warn: [],\n            error: [],\n            debug: [],\n        };\n        if (typeof process !== \"undefined\" && process.env.UPTIME_KUMA_HIDE_LOG) {\n            let list = process.env.UPTIME_KUMA_HIDE_LOG.split(\",\").map(v => v.toLowerCase());\n            for (let pair of list) {\n                // split first \"_\" only\n                let values = pair.split(/_(.*)/s);\n                if (values.length >= 2) {\n                    this.hideLog[values[0]].push(values[1]);\n                }\n            }\n            this.debug(\"server\", \"UPTIME_KUMA_HIDE_LOG is set\");\n            this.debug(\"server\", this.hideLog);\n        }\n    }\n    /**\n     * Write a message to the log\n     * @param module The module the log comes from\n     * @param msg Message to write\n     * @param level Log level. One of INFO, WARN, ERROR, DEBUG or can be customized.\n     */\n    log(module, msg, level) {\n        if (level === \"DEBUG\" && !exports.isDev) {\n            return;\n        }\n        if (this.hideLog[level] && this.hideLog[level].includes(module.toLowerCase())) {\n            return;\n        }\n        module = module.toUpperCase();\n        level = level.toUpperCase();\n        let now;\n        if (dayjs.tz) {\n            now = dayjs.tz(new Date()).format();\n        }\n        else {\n            now = dayjs().format();\n        }\n        const formattedMessage = (typeof msg === \"string\") ? `${now} [${module}] ${level}: ${msg}` : msg;\n        if (level === \"INFO\") {\n            console.info(formattedMessage);\n        }\n        else if (level === \"WARN\") {\n            console.warn(formattedMessage);\n        }\n        else if (level === \"ERROR\") {\n            console.error(formattedMessage);\n        }\n        else if (level === \"DEBUG\") {\n            if (exports.isDev) {\n                console.log(formattedMessage);\n            }\n        }\n        else {\n            console.log(formattedMessage);\n        }\n    }\n    /**\n     * Log an INFO message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    info(module, msg) {\n        this.log(module, msg, \"info\");\n    }\n    /**\n     * Log a WARN message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    warn(module, msg) {\n        this.log(module, msg, \"warn\");\n    }\n    /**\n     * Log an ERROR message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    error(module, msg) {\n        this.log(module, msg, \"error\");\n    }\n    /**\n     * Log a DEBUG message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    debug(module, msg) {\n        this.log(module, msg, \"debug\");\n    }\n    /**\n     * Log an exeption as an ERROR\n     * @param module Module log comes from\n     * @param exception The exeption to include\n     * @param msg The message to write\n     */\n    exception(module, exception, msg) {\n        let finalMessage = exception;\n        if (msg) {\n            finalMessage = `${msg}: ${exception}`;\n        }\n        this.log(module, finalMessage, \"error\");\n    }\n}\nexports.log = new Logger();\n/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\nfunction polyfill() {\n    if (!String.prototype.replaceAll) {\n        String.prototype.replaceAll = function (str, newStr) {\n            // If a regex pattern\n            if (Object.prototype.toString.call(str).toLowerCase() === \"[object regexp]\") {\n                return this.replace(str, newStr);\n            }\n            // If a string\n            return this.replace(new RegExp(str, \"g\"), newStr);\n        };\n    }\n}\nexports.polyfill = polyfill;\nclass TimeLogger {\n    constructor() {\n        this.startTime = dayjs().valueOf();\n    }\n    /**\n     * Output time since start of monitor\n     * @param name Name of monitor\n     */\n    print(name) {\n        if (exports.isDev && process.env.TIMELOGGER === \"1\") {\n            console.log(name + \": \" + (dayjs().valueOf() - this.startTime) + \"ms\");\n        }\n    }\n}\nexports.TimeLogger = TimeLogger;\n/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nfunction getRandomArbitrary(min, max) {\n    return Math.random() * (max - min) + min;\n}\nexports.getRandomArbitrary = getRandomArbitrary;\n/**\n * From: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range\n *\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nexports.getRandomInt = getRandomInt;\n/**\n * Returns either the NodeJS crypto.randomBytes() function or its\n * browser equivalent implemented via window.crypto.getRandomValues()\n */\nlet getRandomBytes = ((typeof window !== 'undefined' && window.crypto)\n    // Browsers\n    ? function () {\n        return (numBytes) => {\n            let randomBytes = new Uint8Array(numBytes);\n            for (let i = 0; i < numBytes; i += 65536) {\n                window.crypto.getRandomValues(randomBytes.subarray(i, i + Math.min(numBytes - i, 65536)));\n            }\n            return randomBytes;\n        };\n    }\n    // Node\n    : function () {\n        return require(\"crypto\").randomBytes;\n    })();\n/**\n * Get a random integer suitable for use in cryptography between upper\n * and lower bounds.\n * @param min Minimum value of integer\n * @param max Maximum value of integer\n * @returns Cryptographically suitable random integer\n */\nfunction getCryptoRandomInt(min, max) {\n    // synchronous version of: https://github.com/joepie91/node-random-number-csprng\n    const range = max - min;\n    if (range >= Math.pow(2, 32))\n        console.log(\"Warning! Range is too large.\");\n    let tmpRange = range;\n    let bitsNeeded = 0;\n    let bytesNeeded = 0;\n    let mask = 1;\n    while (tmpRange > 0) {\n        if (bitsNeeded % 8 === 0)\n            bytesNeeded += 1;\n        bitsNeeded += 1;\n        mask = mask << 1 | 1;\n        tmpRange = tmpRange >>> 1;\n    }\n    const randomBytes = getRandomBytes(bytesNeeded);\n    let randomValue = 0;\n    for (let i = 0; i < bytesNeeded; i++) {\n        randomValue |= randomBytes[i] << 8 * i;\n    }\n    randomValue = randomValue & mask;\n    if (randomValue <= range) {\n        return min + randomValue;\n    }\n    else {\n        return getCryptoRandomInt(min, max);\n    }\n}\nexports.getCryptoRandomInt = getCryptoRandomInt;\n/**\n * Generate a random alphanumeric string of fixed length\n * @param length Length of string to generate\n * @returns string\n */\nfunction genSecret(length = 64) {\n    let secret = \"\";\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const charsLength = chars.length;\n    for (let i = 0; i < length; i++) {\n        secret += chars.charAt(getCryptoRandomInt(0, charsLength - 1));\n    }\n    return secret;\n}\nexports.genSecret = genSecret;\n/**\n * Get the path of a monitor\n * @param id ID of monitor\n * @returns Formatted relative path\n */\nfunction getMonitorRelativeURL(id) {\n    return \"/dashboard/\" + id;\n}\nexports.getMonitorRelativeURL = getMonitorRelativeURL;\n/**\n * Get relative path for maintenance\n * @param id ID of maintenance\n * @returns Formatted relative path\n */\nfunction getMaintenanceRelativeURL(id) {\n    return \"/maintenance/\" + id;\n}\nexports.getMaintenanceRelativeURL = getMaintenanceRelativeURL;\n/**\n * Parse to Time Object that used in VueDatePicker\n * @param {string} time E.g. 12:00\n * @returns object\n */\nfunction parseTimeObject(time) {\n    if (!time) {\n        return {\n            hours: 0,\n            minutes: 0,\n        };\n    }\n    let array = time.split(\":\");\n    if (array.length < 2) {\n        throw new Error(\"parseVueDatePickerTimeFormat: Invalid Time\");\n    }\n    let obj = {\n        hours: parseInt(array[0]),\n        minutes: parseInt(array[1]),\n        seconds: 0,\n    };\n    if (array.length >= 3) {\n        obj.seconds = parseInt(array[2]);\n    }\n    return obj;\n}\nexports.parseTimeObject = parseTimeObject;\n/**\n * @returns string e.g. 12:00\n */\nfunction parseTimeFromTimeObject(obj) {\n    if (!obj) {\n        return obj;\n    }\n    let result = \"\";\n    result += obj.hours.toString().padStart(2, \"0\") + \":\" + obj.minutes.toString().padStart(2, \"0\");\n    if (obj.seconds) {\n        result += \":\" + obj.seconds.toString().padStart(2, \"0\");\n    }\n    return result;\n}\nexports.parseTimeFromTimeObject = parseTimeFromTimeObject;\n/**\n * Convert ISO date to UTC\n * @param input Date\n * @returns ISO Date time\n */\nfunction isoToUTCDateTime(input) {\n    return dayjs(input).utc().format(exports.SQL_DATETIME_FORMAT);\n}\nexports.isoToUTCDateTime = isoToUTCDateTime;\n/**\n * @param input\n */\nfunction utcToISODateTime(input) {\n    return dayjs.utc(input).toISOString();\n}\nexports.utcToISODateTime = utcToISODateTime;\n/**\n * For SQL_DATETIME_FORMAT\n */\nfunction utcToLocal(input, format = exports.SQL_DATETIME_FORMAT) {\n    return dayjs.utc(input).local().format(format);\n}\nexports.utcToLocal = utcToLocal;\n/**\n * Convert local datetime to UTC\n * @param input Local date\n * @param format Format to return\n * @returns Date in requested format\n */\nfunction localToUTC(input, format = exports.SQL_DATETIME_FORMAT) {\n    return dayjs(input).utc().format(format);\n}\nexports.localToUTC = localToUTC;\n", "// Common Util for frontend and backend\n//\n// DOT NOT MODIFY util.js!\n// Need to run \"tsc\" to compile if there are any changes.\n//\n// Backend uses the compiled file util.js\n// Frontend uses util.ts\n\nimport * as dayjs  from \"dayjs\";\nimport * as timezone from \"dayjs/plugin/timezone\";\nimport * as utc from \"dayjs/plugin/utc\";\n\nexport const isDev = process.env.NODE_ENV === \"development\";\nexport const appName = \"Uptime Kuma\";\nexport const DOWN = 0;\nexport const UP = 1;\nexport const PENDING = 2;\nexport const MAINTENANCE = 3;\n\nexport const STATUS_PAGE_ALL_DOWN = 0;\nexport const STATUS_PAGE_ALL_UP = 1;\nexport const STATUS_PAGE_PARTIAL_DOWN = 2;\nexport const STATUS_PAGE_MAINTENANCE = 3;\n\nexport const SQL_DATE_FORMAT = \"YYYY-MM-DD\";\nexport const SQL_DATETIME_FORMAT = \"YYYY-MM-DD HH:mm:ss\";\nexport const SQL_DATETIME_FORMAT_WITHOUT_SECOND = \"YYYY-MM-DD HH:mm\";\n\nexport const MAX_INTERVAL_SECOND = 2073600; // 24 days\nexport const MIN_INTERVAL_SECOND = 20; // 20 seconds\n\nexport const badgeConstants = {\n    naColor: \"#999\",\n    defaultUpColor: \"#66c20a\",\n    defaultWarnColor: \"#eed202\",\n    defaultDownColor: \"#c2290a\",\n    defaultPendingColor: \"#f8a306\",\n    defaultMaintenanceColor: \"#1747f5\",\n    defaultPingColor: \"blue\",  // as defined by badge-maker / shields.io\n    defaultStyle: \"flat\",\n    defaultPingValueSuffix: \"ms\",\n    defaultPingLabelSuffix: \"h\",\n    defaultUptimeValueSuffix: \"%\",\n    defaultUptimeLabelSuffix: \"h\",\n    defaultCertExpValueSuffix: \" days\",\n    defaultCertExpLabelSuffix: \"h\",\n    // Values Come From Default Notification Times\n    defaultCertExpireWarnDays: \"14\",\n    defaultCertExpireDownDays: \"7\"\n};\n\n/** Flip the status of s */\nexport function flipStatus(s: number) {\n    if (s === UP) {\n        return DOWN;\n    }\n\n    if (s === DOWN) {\n        return UP;\n    }\n\n    return s;\n}\n\n/**\n * Delays for specified number of seconds\n * @param ms Number of milliseconds to sleep for\n */\nexport function sleep(ms: number) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * PHP's ucfirst\n * @param str\n */\nexport function ucfirst(str: string) {\n    if (!str) {\n        return str;\n    }\n\n    const firstLetter = str.substr(0, 1);\n    return firstLetter.toUpperCase() + str.substr(1);\n}\n\n/**\n * @deprecated Use log.debug\n * @since https://github.com/louislam/uptime-kuma/pull/910\n * @param msg\n */\nexport function debug(msg: any) {\n    log.log(\"\", msg, \"debug\");\n}\n\nclass Logger {\n\n    /**\n     * UPTIME_KUMA_HIDE_LOG=debug_monitor,info_monitor\n     *\n     * Example:\n     *  [\n     *     \"debug_monitor\",          // Hide all logs that level is debug and the module is monitor\n     *     \"info_monitor\",\n     *  ]\n     */\n    hideLog : any = {\n        info: [],\n        warn: [],\n        error: [],\n        debug: [],\n    };\n\n    constructor() {\n        if (typeof process !== \"undefined\" && process.env.UPTIME_KUMA_HIDE_LOG) {\n            let list = process.env.UPTIME_KUMA_HIDE_LOG.split(\",\").map(v => v.toLowerCase());\n\n            for (let pair of list) {\n                // split first \"_\" only\n                let values = pair.split(/_(.*)/s);\n\n                if (values.length >= 2) {\n                    this.hideLog[values[0]].push(values[1]);\n                }\n            }\n\n            this.debug(\"server\", \"UPTIME_KUMA_HIDE_LOG is set\");\n            this.debug(\"server\", this.hideLog);\n        }\n    }\n\n    /**\n     * Write a message to the log\n     * @param module The module the log comes from\n     * @param msg Message to write\n     * @param level Log level. One of INFO, WARN, ERROR, DEBUG or can be customized.\n     */\n    log(module: string, msg: any, level: string) {\n        if (level === \"DEBUG\" && !isDev) {\n            return;\n        }\n\n        if (this.hideLog[level] && this.hideLog[level].includes(module.toLowerCase())) {\n            return;\n        }\n\n        module = module.toUpperCase();\n        level = level.toUpperCase();\n\n        let now;\n        if (dayjs.tz) {\n            now = dayjs.tz(new Date()).format();\n        } else {\n            now = dayjs().format();\n        }\n        const formattedMessage = (typeof msg === \"string\") ? `${now} [${module}] ${level}: ${msg}` : msg;\n\n        if (level === \"INFO\") {\n            console.info(formattedMessage);\n        } else if (level === \"WARN\") {\n            console.warn(formattedMessage);\n        } else if (level === \"ERROR\") {\n            console.error(formattedMessage);\n        } else if (level === \"DEBUG\") {\n            if (isDev) {\n                console.log(formattedMessage);\n            }\n        } else {\n            console.log(formattedMessage);\n        }\n    }\n\n    /**\n     * Log an INFO message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    info(module: string, msg: any) {\n        this.log(module, msg, \"info\");\n    }\n\n    /**\n     * Log a WARN message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    warn(module: string, msg: any) {\n        this.log(module, msg, \"warn\");\n    }\n\n    /**\n     * Log an ERROR message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    error(module: string, msg: any) {\n       this.log(module, msg, \"error\");\n    }\n\n    /**\n     * Log a DEBUG message\n     * @param module Module log comes from\n     * @param msg Message to write\n     */\n    debug(module: string, msg: any) {\n       this.log(module, msg, \"debug\");\n    }\n\n    /**\n     * Log an exeption as an ERROR\n     * @param module Module log comes from\n     * @param exception The exeption to include\n     * @param msg The message to write\n     */\n    exception(module: string, exception: any, msg: any) {\n        let finalMessage = exception\n\n        if (msg) {\n            finalMessage = `${msg}: ${exception}`\n        }\n\n        this.log(module, finalMessage , \"error\");\n    }\n}\n\nexport const log = new Logger();\n\ndeclare global { interface String { replaceAll(str: string, newStr: string): string; } }\n\n/**\n * String.prototype.replaceAll() polyfill\n * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/\n * @author Chris Ferdinandi\n * @license MIT\n */\nexport function polyfill() {\n    if (!String.prototype.replaceAll) {\n        String.prototype.replaceAll = function (str: string, newStr: string) {\n            // If a regex pattern\n            if (Object.prototype.toString.call(str).toLowerCase() === \"[object regexp]\") {\n                return this.replace(str, newStr);\n            }\n\n            // If a string\n            return this.replace(new RegExp(str, \"g\"), newStr);\n        };\n    }\n}\n\nexport class TimeLogger {\n    startTime: number;\n\n    constructor() {\n        this.startTime = dayjs().valueOf();\n    }\n    /**\n     * Output time since start of monitor\n     * @param name Name of monitor\n     */\n    print(name: string) {\n        if (isDev && process.env.TIMELOGGER === \"1\") {\n            console.log(name + \": \" + (dayjs().valueOf() - this.startTime) + \"ms\")\n        }\n    }\n}\n\n/**\n * Returns a random number between min (inclusive) and max (exclusive)\n */\nexport function getRandomArbitrary(min: number, max: number) {\n    return Math.random() * (max - min) + min;\n}\n\n/**\n * From: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range\n *\n * Returns a random integer between min (inclusive) and max (inclusive).\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nexport function getRandomInt(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/**\n * Returns either the NodeJS crypto.randomBytes() function or its\n * browser equivalent implemented via window.crypto.getRandomValues()\n */\nlet getRandomBytes = (\n    (typeof window !== 'undefined' && window.crypto)\n\n        // Browsers\n        ? function () {\n            return (numBytes: number) => {\n                let randomBytes = new Uint8Array(numBytes);\n                for (let i = 0; i < numBytes; i += 65536) {\n                    window.crypto.getRandomValues(randomBytes.subarray(i, i + Math.min(numBytes - i, 65536)));\n                }\n                return randomBytes;\n            };\n        }\n\n         // Node\n        : function() {\n            return require(\"crypto\").randomBytes;\n        }\n)();\n\n/**\n * Get a random integer suitable for use in cryptography between upper\n * and lower bounds.\n * @param min Minimum value of integer\n * @param max Maximum value of integer\n * @returns Cryptographically suitable random integer\n */\nexport function getCryptoRandomInt(min: number, max: number):number {\n\n    // synchronous version of: https://github.com/joepie91/node-random-number-csprng\n\n    const range = max - min\n    if (range >= Math.pow(2, 32))\n        console.log(\"Warning! Range is too large.\")\n\n    let tmpRange = range\n    let bitsNeeded = 0\n    let bytesNeeded = 0\n    let mask = 1\n\n    while (tmpRange > 0) {\n        if (bitsNeeded % 8 === 0) bytesNeeded += 1\n        bitsNeeded += 1\n        mask = mask << 1 | 1\n        tmpRange = tmpRange >>> 1\n    }\n\n    const randomBytes = getRandomBytes(bytesNeeded)\n    let randomValue = 0\n\n    for (let i = 0; i < bytesNeeded; i++) {\n\t    randomValue |= randomBytes[i] << 8 * i\n    }\n\n    randomValue = randomValue & mask;\n\n    if (randomValue <= range) {\n        return min + randomValue\n    } else {\n        return getCryptoRandomInt(min, max)\n    }\n}\n\n/**\n * Generate a random alphanumeric string of fixed length\n * @param length Length of string to generate\n * @returns string\n */\nexport function genSecret(length = 64) {\n    let secret = \"\";\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const charsLength = chars.length;\n    for ( let i = 0; i < length; i++ ) {\n        secret += chars.charAt(getCryptoRandomInt(0, charsLength - 1));\n    }\n    return secret;\n}\n\n/**\n * Get the path of a monitor\n * @param id ID of monitor\n * @returns Formatted relative path\n */\nexport function getMonitorRelativeURL(id: string) {\n    return \"/dashboard/\" + id;\n}\n\n/**\n * Get relative path for maintenance\n * @param id ID of maintenance\n * @returns Formatted relative path\n */\nexport function getMaintenanceRelativeURL(id: string) {\n    return \"/maintenance/\" + id;\n}\n\n/**\n * Parse to Time Object that used in VueDatePicker\n * @param {string} time E.g. 12:00\n * @returns object\n */\nexport function parseTimeObject(time: string) {\n    if (!time) {\n        return {\n            hours: 0,\n            minutes: 0,\n        };\n    }\n\n    let array = time.split(\":\");\n\n    if (array.length < 2) {\n        throw new Error(\"parseVueDatePickerTimeFormat: Invalid Time\");\n    }\n\n    let obj =  {\n        hours: parseInt(array[0]),\n        minutes: parseInt(array[1]),\n        seconds: 0,\n    }\n    if (array.length >= 3) {\n        obj.seconds = parseInt(array[2]);\n    }\n    return obj;\n}\n\n/**\n * @returns string e.g. 12:00\n */\nexport function parseTimeFromTimeObject(obj : any) {\n    if (!obj) {\n        return obj;\n    }\n\n    let result = \"\";\n\n    result += obj.hours.toString().padStart(2, \"0\") + \":\" + obj.minutes.toString().padStart(2, \"0\")\n\n    if (obj.seconds) {\n        result += \":\" +  obj.seconds.toString().padStart(2, \"0\")\n    }\n\n    return result;\n}\n\n/**\n * Convert ISO date to UTC\n * @param input Date\n * @returns ISO Date time\n */\nexport function isoToUTCDateTime(input : string) {\n    return dayjs(input).utc().format(SQL_DATETIME_FORMAT);\n}\n\n/**\n * @param input\n */\nexport function utcToISODateTime(input : string) {\n    return dayjs.utc(input).toISOString();\n}\n\n/**\n * For SQL_DATETIME_FORMAT\n */\nexport function utcToLocal(input : string, format = SQL_DATETIME_FORMAT) {\n    return dayjs.utc(input).local().format(format);\n}\n\n/**\n * Convert local datetime to UTC\n * @param input Local date\n * @param format Format to return\n * @returns Date in requested format\n */\nexport function localToUTC(input : string, format = SQL_DATETIME_FORMAT) {\n    return dayjs(input).utc().format(format);\n}\n"], "filenames": ["config/vite.config.js", "extra/healthcheck.js", "extra/reset-password.js", "package.json", "server/config.js", "server/routers/api-router.js", "server/routers/status-page-router.js", "server/server.js", "server/socket-handlers/general-socket-handler.js", "server/uptime-kuma-server.js", "server/util-server.js", "src/components/BadgeGeneratorDialog.vue", "src/mixins/socket.js", "src/pages/EditMonitor.vue", "src/util.js", "src/util.ts"], "buggy_code_start_loc": [6, 9, 7, 195, 0, 14, 8, 84, 80, 14, 4, 138, 290, 851, 10, 30], "buggy_code_end_loc": [26, 10, 68, 196, 29, 20, 9, 1159, 80, 424, 13, 234, 290, 854, 26, 30], "fixing_code_start_loc": [5, 9, 8, 194, 1, 14, 8, 84, 81, 15, 4, 138, 291, 851, 10, 31], "fixing_code_end_loc": [23, 10, 114, 194, 41, 18, 9, 1156, 91, 440, 11, 234, 295, 852, 46, 51], "type": "CWE-384", "message": "Uptime Kuma is an easy-to-use self-hosted monitoring tool. Prior to version 1.23.9, when a user changes their login password in Uptime Kuma, a previously logged-in user retains access without being logged out. This behavior persists consistently, even after system restarts or browser restarts. This vulnerability allows unauthorized access to user accounts, compromising the security of sensitive information. The same vulnerability was partially fixed in  CVE-2023-44400, but logging existing users out of their accounts was forgotten. To mitigate the risks associated with this vulnerability, the maintainers made the server emit a `refresh` event (clients handle this by reloading) and then disconnecting all clients except the one initiating the password change. It is recommended to update Uptime Kuma to version 1.23.9.", "other": {"cve": {"id": "CVE-2023-49804", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-11T23:15:07.840", "lastModified": "2023-12-14T19:59:50.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Uptime Kuma is an easy-to-use self-hosted monitoring tool. Prior to version 1.23.9, when a user changes their login password in Uptime Kuma, a previously logged-in user retains access without being logged out. This behavior persists consistently, even after system restarts or browser restarts. This vulnerability allows unauthorized access to user accounts, compromising the security of sensitive information. The same vulnerability was partially fixed in  CVE-2023-44400, but logging existing users out of their accounts was forgotten. To mitigate the risks associated with this vulnerability, the maintainers made the server emit a `refresh` event (clients handle this by reloading) and then disconnecting all clients except the one initiating the password change. It is recommended to update Uptime Kuma to version 1.23.9."}, {"lang": "es", "value": "Uptime Kuma es una herramienta de monitorizaci\u00f3n autohospedada y f\u00e1cil de usar. Antes de la versi\u00f3n 1.23.9, cuando un usuario cambia su contrase\u00f1a de inicio de sesi\u00f3n en Uptime Kuma, un usuario que hab\u00eda iniciado sesi\u00f3n anteriormente conserva el acceso sin cerrar la sesi\u00f3n. Este comportamiento persiste constantemente, incluso despu\u00e9s de reiniciar el sistema o el navegador. Esta vulnerabilidad permite el acceso no autorizado a cuentas de usuarios, comprometiendo la seguridad de informaci\u00f3n confidencial. La misma vulnerabilidad se solucion\u00f3 parcialmente en CVE-2023-44400, pero se olvid\u00f3 cerrar la sesi\u00f3n de los usuarios existentes en sus cuentas. Para mitigar los riesgos asociados con esta vulnerabilidad, los mantenedores hicieron que el servidor emitiera un evento de \"actualizaci\u00f3n\" (los clientes manejan esto recargando) y luego desconectaron a todos los clientes excepto el que inici\u00f3 el cambio de contrase\u00f1a. Se recomienda actualizar Uptime Kuma a la versi\u00f3n 1.23.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dockge.kuma:dockge:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.3", "matchCriteriaId": "9AD32927-6407-4711-8521-81C662CD7041"}, {"vulnerable": true, "criteria": "cpe:2.3:a:uptime.kuma:uptime_kuma:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.23.9", "matchCriteriaId": "04F74E4F-6339-4155-BE6A-B10151B8E18D"}]}]}], "references": [{"url": "https://github.com/louislam/uptime-kuma/commit/482049c72b3a650c7bc5c26c2f4d57a21c0e0aa0", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/louislam/uptime-kuma/security/advisories/GHSA-88j4-pcx8-q4q3", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/louislam/uptime-kuma/security/advisories/GHSA-g9v2-wqcj-j99g", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/louislam/uptime-kuma/commit/482049c72b3a650c7bc5c26c2f4d57a21c0e0aa0"}}