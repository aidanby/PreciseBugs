{"buggy_code": ["'use strict';\n\nvar _ = require('lodash');\n\nvar TYPE_DELIMETER = ':'\n  , PATH_REGEX = /^{[A-Za-z0-9_]+}$/\n  , DEFAULT_VAL_DELIMETER = '|='\n  , extraOption;\n\nfunction getValue(req, keyName) {\n  if (req.params && req.params[keyName] !== undefined) {\n    return req.params[keyName];\n  } else if (req.body && req.body[keyName] !== undefined) {\n    return req.body[keyName];\n  } else if (req.query && req.query[keyName] !== undefined) {\n    return req.query[keyName];\n  } else {\n    return undefined;\n  }\n}\n\nfunction getPath(req, keyName) {\n  return req.params[keyName];\n}\n\nfunction getExtra(req, keyName) {\n  return req[extraOption[keyName]];\n}\n\n// type:keyName || type:{keyName}\nfunction getRequiredKeyInfo(param_expression) {\n  var keyInfo = {}\n    , type_tokenized = param_expression.split(TYPE_DELIMETER)\n    , len1 = type_tokenized.length\n    , pathKey\n    , keyName\n    , err;\n\n  if (len1 === 1) {\n    keyInfo.type = 'string';\n\n    pathKey = !(type_tokenized[0].match(PATH_REGEX) === null);\n    keyName = pathKey ? type_tokenized[0].replace('{', '').replace('}', '') : type_tokenized[0];\n  } else if (len1 === 2) {\n    keyInfo.type = type_tokenized[0];\n\n    pathKey = !(type_tokenized[1].match(PATH_REGEX) === null);\n    keyName = pathKey ? type_tokenized[1].replace('{', '').replace('}', '') : type_tokenized[1];\n  } else {\n    err = new Error('Invalid required parameter expression. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  keyInfo.pathKey = pathKey;\n  keyInfo.keyName = keyName;\n\n  return keyInfo;\n}\n\nfunction getOptionalKeyInfo(param_expression) {\n  var keyInfo = {}\n    , type_tokenized = param_expression.split(TYPE_DELIMETER)\n    , len1 = type_tokenized.length\n    , len2\n    , val_tokenized\n    , err;\n\n  if (len1 === 1) { //no type, set type as string\n    keyInfo.type = 'string';\n    val_tokenized = type_tokenized[0].split(DEFAULT_VAL_DELIMETER);\n  } else if (len1 === 2) {\n    keyInfo.type = type_tokenized[0];\n    val_tokenized = type_tokenized[1].split(DEFAULT_VAL_DELIMETER);\n  } else {\n    err = new Error('Invalid parameter expression. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  len2 = val_tokenized.length;\n\n  keyInfo.keyName = val_tokenized[0];\n  if (len2 === 2) keyInfo.defaultVal = val_tokenized[1];\n\n  if (len2 > 2) {\n    err = new Error('Invalid parameter expression. expression have to include \\''\n      + DEFAULT_VAL_DELIMETER + '\\' delimeter one or zero. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  return keyInfo;\n}\n\n//type:key_name|=default_value\nfunction getOptionalParams(req, option_expressions) {\n  var options = {}\n    , getFunc = getValue\n    , err\n    , keyInfo\n    , key\n    , val;\n\n  //possible expression : {type}:keyName|={defaultValue}\n  for (var i = 0, li = option_expressions.length; i < li; i++) {\n    try {\n      keyInfo = getOptionalKeyInfo(option_expressions[i]);\n      key = keyInfo.keyName;\n    } catch (e) {\n      err = e;\n      break;\n    }\n\n    val = getFunc(req, key);\n\n    if (keyInfo.type === 'number') {\n      if (val !== undefined && val !== '')\n        options[key] = parseFloat(val);\n      else if (keyInfo.defaultVal)\n        options[key] = parseFloat(keyInfo.defaultVal);\n      else\n        continue;\n\n      if (isNaN(options[key])) {\n        err = new Error('The parameter value is not a number : ' + key);\n        err.code = 400;\n        break;\n      }\n    } else {\n      options[key] = val !== undefined ? val : keyInfo.defaultVal;\n    }\n\n  }\n\n  return {\n    err: err,\n    params: options\n  };\n}\n\nfunction getDefaultRequestInfo(req, extraOption) {\n  var options = {};\n\n  for (var key in extraOption) {\n    if (extraOption.hasOwnProperty(key)) {\n      if (key == 'access-country') {\n        var geoCountry = req.headers['x-fetcher-geoinfo'] && req.headers['x-fetcher-geoinfo'].country\n          , imsiCountry = req.headers['x-fetcher-imsi'] && req.headers['x-fetcher-imsi'][0] && req.headers['x-fetcher-imsi'][0].country_code;\n\n        options[key] = geoCountry || imsiCountry;\n        continue;\n      }\n\n      var extraOptionList = extraOption[key].split('.')\n        , value = req;\n\n      extraOptionList.forEach(function(extraOpt) {\n        value = value[extraOpt];\n      });\n\n      options[key] = value;\n    }\n  }\n\n  return {\n    params: options\n  }\n}\n\nfunction requiredParameter(req, required_expressions) {\n  var options = {}\n    , getFunc\n    , err\n    , key\n    , val;\n\n  for (var i = 0, li = required_expressions.length; i <li ; i++) {\n    var keyInfo;\n    try {\n      keyInfo = getRequiredKeyInfo(required_expressions[i]);\n      key = keyInfo.keyName;\n    } catch (e) {\n      err = e;\n      break;\n    }\n\n    if (keyInfo.pathKey)\n      getFunc = getPath;\n    else if (extraOption[key])\n      getFunc = getExtra;\n    else\n      getFunc = getValue;\n\n    val = getFunc(req, key);\n    if (keyInfo.type === 'number') {\n      if (isNaN(val)) {\n        err = new Error('The parameter value is not a number : ' + key);\n        err.code = 400;\n        break;\n      }\n      options[key] = parseFloat(val);\n    } else {\n      options[key] = val;\n    }\n\n    if (!options[key]) {\n      err = new Error('No Request Data For Required : ' + key);\n      err.code = 400;\n      break;\n    }\n  }\n\n  return {\n    err: err,\n    params: options\n  };\n}\n\n//required = ['id', 'number:req_id:path'], optional = ['order', 'number:count:10']\nfunction fetchParameter(required, optional) {\n  //\ubb38\uc790\uc5f4 \ubc30\uc5f4\uc778\uc9c0 \uba3c\uc800 \ud655\uc778\ud558\uc790.\n  var requiredResult\n    , optionalResult = {}\n    , extraResult\n    , options = {}\n    , req;\n\n  req = this.req;\n  if (!this.req) {\n    throw Error('insert this express-param middleware into express app!');\n  }\n\n  //req.user value is default\n  extraOption = this.extraOption || {};\n  if (!extraOption.user) extraOption.user = 'user';\n\n  requiredResult = requiredParameter(req, required);\n\n  if (requiredResult.err) {\n    return requiredResult.err;\n  }\n\n  if (Array.isArray(optional)) {\n    optionalResult = getOptionalParams(req, optional);\n    if (optionalResult.err) {\n      return optionalResult.err;\n    }\n  }\n\n  extraResult = getDefaultRequestInfo(req, extraOption);\n\n  var extendOptionVal = _.extend(optionalResult.params, extraResult.params);\n  options.params = _.extend(requiredResult.params, extendOptionVal);\n\n  return options.params;\n}\n\nexports.fetchParameter = fetchParameter;\n"], "fixing_code": ["'use strict';\n\nvar _ = require('lodash');\n\nvar TYPE_DELIMETER = ':'\n  , PATH_REGEX = /^{[A-Za-z0-9_]+}$/\n  , DEFAULT_VAL_DELIMETER = '|='\n  , extraOption;\n\nfunction getValue(req, keyName) {\n  var value;\n\n  if (req.params && req.params[keyName] !== undefined) {\n    value = req.params[keyName];\n  } else if (req.body && req.body[keyName] !== undefined) {\n    value = req.body[keyName];\n  } else if (req.query && req.query[keyName] !== undefined) {\n    value = req.query[keyName];\n  }\n\n  if (Array.isArray(value)) {\n    value = value[value.length - 1];\n  }\n\n  return value;\n}\n\nfunction getPath(req, keyName) {\n  return req.params[keyName];\n}\n\nfunction getExtra(req, keyName) {\n  return req[extraOption[keyName]];\n}\n\n// type:keyName || type:{keyName}\nfunction getRequiredKeyInfo(param_expression) {\n  var keyInfo = {}\n    , type_tokenized = param_expression.split(TYPE_DELIMETER)\n    , len1 = type_tokenized.length\n    , pathKey\n    , keyName\n    , err;\n\n  if (len1 === 1) {\n    keyInfo.type = 'string';\n\n    pathKey = !(type_tokenized[0].match(PATH_REGEX) === null);\n    keyName = pathKey ? type_tokenized[0].replace('{', '').replace('}', '') : type_tokenized[0];\n  } else if (len1 === 2) {\n    keyInfo.type = type_tokenized[0];\n\n    pathKey = !(type_tokenized[1].match(PATH_REGEX) === null);\n    keyName = pathKey ? type_tokenized[1].replace('{', '').replace('}', '') : type_tokenized[1];\n  } else {\n    err = new Error('Invalid required parameter expression. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  keyInfo.pathKey = pathKey;\n  keyInfo.keyName = keyName;\n\n  return keyInfo;\n}\n\nfunction getOptionalKeyInfo(param_expression) {\n  var keyInfo = {}\n    , type_tokenized = param_expression.split(TYPE_DELIMETER)\n    , len1 = type_tokenized.length\n    , len2\n    , val_tokenized\n    , err;\n\n  if (len1 === 1) { //no type, set type as string\n    keyInfo.type = 'string';\n    val_tokenized = type_tokenized[0].split(DEFAULT_VAL_DELIMETER);\n  } else if (len1 === 2) {\n    keyInfo.type = type_tokenized[0];\n    val_tokenized = type_tokenized[1].split(DEFAULT_VAL_DELIMETER);\n  } else {\n    err = new Error('Invalid parameter expression. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  len2 = val_tokenized.length;\n\n  keyInfo.keyName = val_tokenized[0];\n  if (len2 === 2) keyInfo.defaultVal = val_tokenized[1];\n\n  if (len2 > 2) {\n    err = new Error('Invalid parameter expression. expression have to include \\''\n      + DEFAULT_VAL_DELIMETER + '\\' delimeter one or zero. Your Input: ' + param_expression);\n    err.code = 400;\n\n    throw err;\n  }\n\n  return keyInfo;\n}\n\n//type:key_name|=default_value\nfunction getOptionalParams(req, option_expressions) {\n  var options = {}\n    , getFunc = getValue\n    , err\n    , keyInfo\n    , key\n    , val;\n\n  //possible expression : {type}:keyName|={defaultValue}\n  for (var i = 0, li = option_expressions.length; i < li; i++) {\n    try {\n      keyInfo = getOptionalKeyInfo(option_expressions[i]);\n      key = keyInfo.keyName;\n    } catch (e) {\n      err = e;\n      break;\n    }\n\n    val = getFunc(req, key);\n\n    var typeMap = {\n      int: parseInt,\n      float: parseFloat,\n      number: parseFloat\n    };\n\n    var idx = Object.keys(typeMap).indexOf(keyInfo.type);\n    if (idx >= 0) {\n      options[key] = typeMap[keyInfo.type](val);\n    }\n\n    if (keyInfo.type === 'number') {\n      if (val !== undefined && val !== '')\n        options[key] = parseFloat(val);\n      else if (keyInfo.defaultVal)\n        options[key] = parseFloat(keyInfo.defaultVal);\n      else\n        continue;\n\n      if (isNaN(options[key])) {\n        err = new Error('The parameter value is not a number : ' + key);\n        err.code = 400;\n        break;\n      }\n    } else {\n      options[key] = val !== undefined ? val : keyInfo.defaultVal;\n    }\n\n  }\n\n  return {\n    err: err,\n    params: options\n  };\n}\n\nfunction getDefaultRequestInfo(req, extraOption) {\n  var options = {};\n\n  for (var key in extraOption) {\n    if (extraOption.hasOwnProperty(key)) {\n      if (key == 'access-country') {\n        var geoCountry = req.headers['x-fetcher-geoinfo'] && req.headers['x-fetcher-geoinfo'].country\n          , imsiCountry = req.headers['x-fetcher-imsi'] && req.headers['x-fetcher-imsi'][0] && req.headers['x-fetcher-imsi'][0].country_code;\n\n        options[key] = geoCountry || imsiCountry;\n        continue;\n      }\n\n      var extraOptionList = extraOption[key].split('.')\n        , value = req;\n\n      extraOptionList.forEach(function(extraOpt) {\n        value = value[extraOpt];\n      });\n\n      options[key] = value;\n    }\n  }\n\n  return {\n    params: options\n  }\n}\n\nfunction requiredParameter(req, required_expressions) {\n  var options = {}\n    , getFunc\n    , err\n    , key\n    , val;\n\n  for (var i = 0, li = required_expressions.length; i < li; i++) {\n    var keyInfo;\n    try {\n      keyInfo = getRequiredKeyInfo(required_expressions[i]);\n      key = keyInfo.keyName;\n    } catch (e) {\n      err = e;\n      break;\n    }\n\n    if (keyInfo.pathKey)\n      getFunc = getPath;\n    else if (extraOption[key])\n      getFunc = getExtra;\n    else\n      getFunc = getValue;\n\n    val = getFunc(req, key);\n\n    var typeMap = {\n      int: parseInt,\n      float: parseFloat,\n      number: parseFloat\n    };\n\n    var idx = Object.keys(typeMap).indexOf(keyInfo.type);\n    if (idx >= 0) {\n      if (isNaN(val)) {\n        err = new Error('The parameter value is not a number : ' + key);\n        err.code = 400;\n        break;\n      }\n\n      if (keyInfo.type == 'int' && !_.isSafeInteger(val)) {\n        err = new Error('The parameter value is not a integer : ' + key);\n        err.code = 400;\n        break;\n      }\n\n      options[key] = typeMap[keyInfo.type](val);\n    } else {\n      options[key] = val;\n    }\n\n    if (!options[key]) {\n      err = new Error('No Request Data For Required : ' + key);\n      err.code = 400;\n      break;\n    }\n  }\n\n  return {\n    err: err,\n    params: options\n  };\n}\n\n//required = ['id', 'number:req_id:path'], optional = ['order', 'number:count:10']\nfunction fetchParameter(required, optional) {\n  //\ubb38\uc790\uc5f4 \ubc30\uc5f4\uc778\uc9c0 \uba3c\uc800 \ud655\uc778\ud558\uc790.\n  var requiredResult\n    , optionalResult = {}\n    , extraResult\n    , options = {}\n    , req;\n\n  req = this.req;\n  if (!this.req) {\n    throw Error('insert this express-param middleware into express app!');\n  }\n\n  //req.user value is default\n  extraOption = this.extraOption || {};\n  if (!extraOption.user) extraOption.user = 'user';\n\n  requiredResult = requiredParameter(req, required);\n\n  if (requiredResult.err) {\n    return requiredResult.err;\n  }\n\n  if (Array.isArray(optional)) {\n    optionalResult = getOptionalParams(req, optional);\n    if (optionalResult.err) {\n      return optionalResult.err;\n    }\n  }\n\n  extraResult = getDefaultRequestInfo(req, extraOption);\n\n  var extendOptionVal = _.extend(optionalResult.params, extraResult.params);\n  options.params = _.extend(requiredResult.params, extendOptionVal);\n\n  return options.params;\n}\n\nexports.fetchParameter = fetchParameter;\n"], "filenames": ["lib/fetchParams.js"], "buggy_code_start_loc": [10], "buggy_code_end_loc": [206], "fixing_code_start_loc": [11], "fixing_code_end_loc": [238], "type": "CWE-235", "message": "A vulnerability was found in flitto express-param up to 0.x. It has been classified as critical. This affects an unknown part of the file lib/fetchParams.js. The manipulation leads to improper handling of extra parameters. It is possible to initiate the attack remotely. Upgrading to version 1.0.0 is able to address this issue. The name of the patch is db94f7391ad0a16dcfcba8b9be1af385b25c42db. It is recommended to upgrade the affected component. The identifier VDB-217149 was assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2017-20160", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-31T20:15:08.693", "lastModified": "2023-01-09T15:08:53.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in flitto express-param up to 0.x. It has been classified as critical. This affects an unknown part of the file lib/fetchParams.js. The manipulation leads to improper handling of extra parameters. It is possible to initiate the attack remotely. Upgrading to version 1.0.0 is able to address this issue. The name of the patch is db94f7391ad0a16dcfcba8b9be1af385b25c42db. It is recommended to upgrade the affected component. The identifier VDB-217149 was assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-235"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flitto:express-param:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "01624055-DEA3-49DB-9CD2-C31E5C8BC146"}]}]}], "references": [{"url": "https://github.com/flitto/express-param/commit/db94f7391ad0a16dcfcba8b9be1af385b25c42db", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flitto/express-param/pull/19", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flitto/express-param/releases/tag/1.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217149", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217149", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flitto/express-param/commit/db94f7391ad0a16dcfcba8b9be1af385b25c42db"}}