{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"mp4box.h\"\n\n#ifdef GPAC_DISABLE_ISOM\n\n#error \"Cannot compile MP4Box if GPAC is not built with ISO File Format support\"\n\n#else\n\n#if defined(WIN32) && !defined(_WIN32_WCE)\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#include <gpac/media_tools.h>\n#include <gpac/main.h>\n\n/*RTP packetizer flags*/\n#ifndef GPAC_DISABLE_STREAMING\n#include <gpac/ietf.h>\n#endif\n\n#ifndef GPAC_DISABLE_CRYPTO\n#include <gpac/crypt_tools.h>\n#endif\n\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#include <gpac/mpd.h>\n\n#define BUFFSIZE\t8192\n#define DEFAULT_INTERLEAVING_IN_SEC 0.5\n\n//undefine to check validity of defined args' syntax\n//#define TEST_ARGS\n\n\nint mp4boxTerminal(int argc, char **argv);\n\nstatic u32 mp4box_cleanup(u32 ret_code);\n\n/*\n * \t\tSTART OF ARGUMENT VALUES DECLARATION\n */\n\n\n\ntypedef struct\n{\n\tGF_ISOTrackID trackID;\n\tchar *line;\n} SDPLine;\n\ntypedef enum {\n\tMETA_ACTION_SET_TYPE\t\t\t= 0,\n\tMETA_ACTION_ADD_ITEM\t\t\t= 1,\n\tMETA_ACTION_REM_ITEM\t\t\t= 2,\n\tMETA_ACTION_SET_PRIMARY_ITEM\t= 3,\n\tMETA_ACTION_SET_XML\t\t\t\t= 4,\n\tMETA_ACTION_SET_BINARY_XML\t\t= 5,\n\tMETA_ACTION_REM_XML\t\t\t\t= 6,\n\tMETA_ACTION_DUMP_ITEM\t\t\t= 7,\n\tMETA_ACTION_DUMP_XML\t\t\t= 8,\n\tMETA_ACTION_ADD_IMAGE_ITEM\t\t= 9,\n\tMETA_ACTION_ADD_IMAGE_GRID\t\t= 10,\n} MetaActionType;\n\ntypedef struct {\n\tu32 ref_item_id;\n\tu32 ref_type;\n} MetaRef;\n\ntypedef struct\n{\n\tMetaActionType act_type;\n\tBool root_meta, use_dref;\n\tGF_ISOTrackID trackID;\n\tu32 meta_4cc;\n\tchar *szPath, *szName, *mime_type, *enc_type;\n\tu32 item_id;\n\tBool primary;\n\tu32 item_type;\n\tu32 ref_item_id;\n\tGF_List *item_refs;\n\tu32 group_id;\n\tu32 group_type;\n\tGF_ImageItemProperties *image_props;\n} MetaAction;\n\n\ntypedef enum {\n\tTRAC_ACTION_REM_TRACK= 0,\n\tTRAC_ACTION_SET_LANGUAGE,\n\tTRAC_ACTION_SET_DELAY,\n\tTRAC_ACTION_SET_KMS_URI,\n\tTRAC_ACTION_SET_PAR,\n\tTRAC_ACTION_SET_HANDLER_NAME,\n\tTRAC_ACTION_ENABLE,\n\tTRAC_ACTION_DISABLE,\n\tTRAC_ACTION_REFERENCE,\n\tTRAC_ACTION_RAW_EXTRACT,\n\tTRAC_ACTION_REM_NON_RAP,\n\tTRAC_ACTION_SET_KIND,\n\tTRAC_ACTION_REM_KIND,\n\tTRAC_ACTION_SET_ID,\n\tTRAC_ACTION_SET_UDTA,\n\tTRAC_ACTION_SWAP_ID,\n\tTRAC_ACTION_REM_NON_REFS,\n\tTRAC_ACTION_SET_CLAP,\n\tTRAC_ACTION_SET_MX,\n\tTRAC_ACTION_SET_EDITS,\n\tTRAC_ACTION_SET_TIME,\n\tTRAC_ACTION_SET_MEDIA_TIME,\n} TrackActionType;\n\ntypedef struct\n{\n\tTrackActionType act_type;\n\tGF_ISOTrackID trackID;\n\tchar lang[10];\n\tGF_Fraction delay;\n\tconst char *kms;\n\tconst char *hdl_name;\n\ts32 par_num, par_den;\n\tu8 force_par, rewrite_bs;\n\tu32 dump_type, sample_num;\n\tchar *out_name;\n\tchar *src_name;\n\tchar *string;\n\tu32 udta_type;\n\tchar *kind_scheme, *kind_value;\n\tu32 newTrackID;\n\ts32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_honum, clap_hoden, clap_vonum, clap_voden;\n\ts32 mx[9];\n\tu64 time;\n\tu8 dump_track_type;\n} TrackAction;\n\nenum\n{\n\tGF_ISOM_CONV_TYPE_ISMA = 1,\n\tGF_ISOM_CONV_TYPE_ISMA_EX,\n\tGF_ISOM_CONV_TYPE_3GPP,\n\tGF_ISOM_CONV_TYPE_IPOD,\n\tGF_ISOM_CONV_TYPE_PSP,\n\tGF_ISOM_CONV_TYPE_MOV\n};\n\ntypedef enum {\n\tTSEL_ACTION_SET_PARAM = 0,\n\tTSEL_ACTION_REMOVE_TSEL = 1,\n\tTSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP = 2,\n} TSELActionType;\n\ntypedef struct\n{\n\tTSELActionType act_type;\n\tGF_ISOTrackID trackID;\n\n\tGF_ISOTrackID refTrackID;\n\tu32 criteria[30];\n\tu32 nb_criteria;\n\tBool is_switchGroup;\n\tu32 switchGroupID;\n} TSELAction;\n\nGF_FileType get_file_type_by_ext(char *inName);\n\n\nchar outfile[GF_MAX_PATH];\nGF_SMEncodeOptions smenc_opts;\nGF_Fraction import_fps;\n\n//things to free upon cleanup\nMetaAction *metas = NULL;\nTrackAction *tracks = NULL;\nTSELAction *tsel_acts = NULL;\nSDPLine *sdp_lines = NULL;\nu32 *brand_add = NULL;\nu32 *brand_rem = NULL;\nchar **mpd_base_urls = NULL;\nu32 nb_mpd_base_urls = 0;\nGF_DashSegmenterInput *dash_inputs = NULL;\nu32 nb_dash_inputs = 0;\n\n\n\n//all other options values - keep options with assignment other than 0 on a single line\n\nu32 swf_flags = GF_SM_SWF_SPLIT_TIMELINE;\n\nFILE *helpout = NULL;\nu32 help_flags = 0;\n\nDouble interleaving_time=0.0, split_duration=0.0, split_start=-1.0, dash_duration=0.0, dash_subduration=0.0, swf_flatten_angle=0.0;\nBool dash_duration_strict=0, dvbhdemux=0, keep_sys_tracks=0;\n\nu64 initial_tfdt=0;\ns32 subsegs_per_sidx=0, laser_resolution=0, ast_offset_ms=0;\nconst char *split_range_str = NULL;\nGF_DashSwitchingMode bitstream_switching_mode = GF_DASH_BSMODE_DEFAULT;\nu32 stat_level=0, hint_flags=0, info_track_id=0, import_flags=0, nb_add=0, nb_cat=0, crypt=0, agg_samples=0, nb_sdp_ex=0, max_ptime=0, split_size=0, nb_meta_act=0, nb_track_act=0, rtp_rate=0, major_brand=0, nb_alt_brand_add=0, nb_alt_brand_rem=0, old_interleave=0, minor_version=0, conv_type=0, nb_tsel_acts=0, program_number=0, dump_nal=0, time_shift_depth=0, initial_moof_sn=0, dump_std=0, import_subtitle=0, dump_saps=0, dump_saps_mode=0, force_new=0;\nGF_DashDynamicMode dash_mode=GF_DASH_STATIC;\n#ifndef GPAC_DISABLE_SCENE_DUMP\nGF_SceneDumpFormat dump_mode=GF_SM_DUMP_NONE;\n#endif\n\n/*align cat is the new default behavior for -cat*/\nBool align_cat=GF_TRUE;\n\nDouble mpd_live_duration=0;\nBool do_hint=0, do_save=0, full_interleave=0, do_frag=0, hint_interleave=0, dump_rtp=0, regular_iod=0, remove_sys_tracks=0, remove_hint=0, remove_root_od=0;\nBool print_sdp=0, open_edit=0, dump_cr=0, force_ocr=0, encode=0, do_scene_log=0, dump_srt=0, dump_ttxt=0, do_saf=0, dump_m2ts=0, dump_cart=0;\nBool do_hash=0, verbose=0, force_cat=0, pack_wgt=0, single_group=0, clean_groups=0, dash_live=0, no_fragments_defaults=0;\nBool single_traf_per_moof=0, tfdt_per_traf=0, hls_clock=0, do_mpd_rip=0, merge_vtt_cues=0, compress_moov=0, get_nb_tracks=0;\n\nchar *inName=NULL, *outName=NULL, *mediaSource=NULL, *input_ctx=NULL, *output_ctx=NULL, *drm_file=NULL, *avi2raw=NULL, *cprt=NULL;\nchar *chap_file=NULL, *chap_file_qt=NULL, *itunes_tags=NULL, *pack_file=NULL, *raw_cat=NULL, *seg_name=NULL, *dash_ctx_file=NULL;\nchar *compress_top_boxes=NULL, *high_dynamc_range_filename=NULL, *use_init_seg=NULL, *box_patch_filename=NULL, *udp_dest = NULL;\n\nGF_ISOTrackID trackID=0;\nu32 track_dump_type=0, dump_isom=0, dump_timestamps=0, dump_nal_type=0, do_flat=0, box_patch_trackID=0, print_info=0;\nBool no_inplace=0, merge_last_seg=0, freeze_box_order=0, no_odf_conf=0;\nDouble min_buffer = 1.5;\nu32 size_top_box=0, fs_dump_flags=0, dump_chap=0, dump_udta_type=0, dump_udta_track=0, moov_pading=0, sdtp_in_traf=0, segment_marker=0, timescale=0;\n\nu32 dash_scale = 1000;\nGF_ISOFile *file = NULL;\n\nBool insert_utc=0, chunk_mode=0, HintCopy=0, hint_no_offset=0, do_bin_xml=0, frag_real_time=0, force_co64=0, live_scene=0, use_mfra=0;\nBool dump_iod=0, samplegroups_in_traf=0, mvex_after_traks=0, daisy_chain_sidx=0, use_ssix=0, single_segment=0, single_file=0, segment_timeline=0;\nBool has_add_image=0;\n\nchar *do_mpd_conv=NULL;\nu32 MTUSize = 1450;\nchar *dash_start_date=NULL;\nGF_DASH_ContentLocationMode cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;\nDouble mpd_update_time = 0.0;\nGF_MemTrackerType mem_track = GF_MemTrackerNone;\nGF_DASHPSSHMode pssh_mode=0;\n\nGF_DashProfile dash_profile=GF_DASH_PROFILE_AUTO;\nchar *dash_profile_extension = NULL;\nchar *dash_cues = NULL;\nBool strict_cues=0, use_url_template=0, seg_at_rap=0, frag_at_rap=0, adjust_split_end=0, memory_frags=0, keep_utc=0, has_next_arg=0, no_cache=0, no_loop=0;\nchar *do_wget = NULL;\nchar *mux_name = NULL;\nchar *seg_ext = NULL;\nchar *init_seg_ext = NULL;\nchar *dash_title = NULL;\nchar *dash_source = NULL;\nchar *dash_more_info = NULL;\n\nFILE *logfile = NULL;\nu32 run_for=0, dash_cumulated_time=0, dash_prev_time=0, dash_now_time=0;\nGF_DASH_SplitMode dash_split_mode = GF_DASH_SPLIT_OUT;\n\n\ntypedef u32 (*parse_arg_fun)(char *arg_val, u32 param);\ntypedef u32 (*parse_arg_fun2)(char *arg_name, char *arg_val, u32 param);\n\n//other custom option parsing functions definitions are in mp4box.h\nstatic u32 parse_meta_args(char *opts, MetaActionType act_type);\nstatic Bool parse_tsel_args(char *opts, TSELActionType act);\n\n\n\n/*\n * \t\tSTART OF ARGS PARSING AND HELP\n */\n\n\nBool print_version(char *arg_val, u32 param)\n{\n\tfprintf(stderr, \"MP4Box - GPAC version %s\\n\"\n\t        \"%s\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s %s\\n\", gf_gpac_version(), gf_gpac_copyright_cite(), gf_sys_features(GF_FALSE), gf_sys_features(GF_TRUE));\n\treturn GF_TRUE;\n}\n\n//arg will toggle open_edit\n#define ARG_OPEN_EDIT\t\t1\n//arg will toggle do_save\n#define ARG_NEED_SAVE\t\t1<<1\n#define ARG_NO_INPLACE\t\t1<<2\n#define ARG_BIT_MASK\t\t1<<3\n#define ARG_BIT_MASK_REM\t1<<4\n#define ARG_HAS_VALUE\t\t1<<5\n#define ARG_DIV_1000\t\t1<<6\n#define ARG_NON_ZERO\t\t1<<7\n#define ARG_64BITS\t\t\t1<<8\n#define ARG_IS_4CC\t\t\t1<<9\n#define ARG_BOOL_REV\t\t1<<10\n#define ARG_INT_INC\t\t\t1<<11\n#define ARG_IS_FUN\t\t\t1<<12\n#define ARG_EMPTY\t\t\t1<<13\n#define ARG_PUSH_SYSARGS\t1<<14\n#define ARG_IS_FUN2\t\t\t1<<15\n\n\n\ntypedef struct\n{\n\tGF_GPAC_ARG_BASE\n\n\tvoid *arg_ptr;\n\tu32 argv_val;\n\tu16 parse_flags;\n} MP4BoxArg;\n\n#define MP4BOX_ARG(_a, _c, _f, _g, _h, _i, _j) {_a, NULL, _c, NULL, NULL, _f, _g, _h, _i, _j}\n#define MP4BOX_ARG_ALT(_a, _b, _c, _f, _g, _h, _i, _j) {_a, _b, _c, NULL, NULL, _f, _g, _h, _i, _j}\n#define MP4BOX_ARG_S(_a, _s, _c, _g, _h, _i, _j) {_a, NULL, _c, _s, NULL, GF_ARG_CUSTOM, _g, _h, _i, _j}\n#define MP4BOX_ARG_S_ALT(_a, _b, _s, _c, _g, _h, _i, _j) {_a, _b, _c, _s, NULL, GF_ARG_CUSTOM, _g, _h, _i, _j}\n\n\nMP4BoxArg m4b_gen_args[] =\n{\n#ifdef GPAC_MEMORY_TRACKING\n \tMP4BOX_ARG(\"mem-track\", \"enable memory tracker\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n \tMP4BOX_ARG(\"mem-track-stack\", \"enable memory tracker with stack dumping\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n#endif\n \tMP4BOX_ARG(\"p\", \"use indicated profile for the global GPAC config. If not found, config file is created. If a file path is indicated, this will load profile from that file. Otherwise, this will create a directory of the specified name and store new config there. Reserved name `0` means a new profile, not stored to disk. Works using -p=NAME or -p NAME\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n \t{\"inter\", NULL, \"interleave file, producing track chunks with given duration in ms. A value of 0 disables interleaving \", \"0.5\", NULL, GF_ARG_DOUBLE, 0, parse_store_mode, 0, ARG_IS_FUN},\n \tMP4BOX_ARG(\"old-inter\", \"same as [-inter]() but without drift correction\", GF_ARG_DOUBLE, GF_ARG_HINT_EXPERT, parse_store_mode, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"tight\", \"tight interleaving (sample based) of the file. This reduces disk seek operations but increases file size\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &full_interleave, 0, ARG_OPEN_EDIT|ARG_NEED_SAVE),\n \tMP4BOX_ARG(\"flat\", \"store file with all media data first, non-interleaved. This speeds up writing time when creating new files\", GF_ARG_BOOL, 0, &do_flat, 0, ARG_OPEN_EDIT| ARG_NO_INPLACE),\n \tMP4BOX_ARG(\"frag\", \"fragment file, producing track fragments of given duration in ms. This disables interleaving\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"out\", \"specify ISOBMFF output file name. By default input file is overwritten\", GF_ARG_STRING, 0, &outName, 0, 0),\n \tMP4BOX_ARG(\"co64\",\"force usage of 64-bit chunk offsets for ISOBMF files\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_co64, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"new\", \"force creation of a new destination file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_new, 0, 0),\n \tMP4BOX_ARG(\"newfs\", \"force creation of a new destination file without temp file but interleaving support\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, parse_store_mode, 3, ARG_IS_FUN),\n \tMP4BOX_ARG_ALT(\"no-sys\", \"nosys\", \"remove all MPEG-4 Systems info except IOD, kept for profiles. This is the default when creating regular AV content\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &remove_sys_tracks, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"no-iod\", \"remove MPEG-4 InitialObjectDescriptor from file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &remove_root_od, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"mfra\", \"insert movie fragment random offset when fragmenting file (ignored in dash mode)\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &use_mfra, 0, 0),\n \tMP4BOX_ARG(\"isma\", \"rewrite the file as an ISMA 1.0 file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"ismax\", \"same as [-isma]() and remove all clock references\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA_EX, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"3gp\", \"rewrite as 3GPP(2) file (no more MPEG-4 Systems Info), always enabled if destination file extension is `.3gp`, `.3g2` or `.3gpp`. Some tracks may be removed in the process\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_3GPP, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"ipod\", \"rewrite the file for iPod/old iTunes\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_IPOD, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"psp\", \"rewrite the file for PSP devices\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_PSP, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"brand\", \"set major brand of file (`ABCD`) or brand with optional version (`ABCD:v`)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"ab\", \"add given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rb\", \"remove given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"cprt\", \"add copyright string to file\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),\n \tMP4BOX_ARG(\"chap\", \"set chapter information from given file. The following formats are supported (but cannot be mixed) in the chapter text file:\\n\"\n\t\t\"  - ZoomPlayer: `AddChapter(nb_frames,chapter name)`, `AddChapterBySeconds(nb_sec,chapter name)` and `AddChapterByTime(h,m,s,chapter name)` with 1 chapter per line\\n\"\n\t\t\"  - Time codes: `h:m:s chapter_name`, `h:m:s:ms chapter_name` and `h:m:s.ms chapter_name` with 1 chapter per line\\n\"\n\t\t\"  - SMPTE codes: `h:m:s;nb_f/fps chapter_name` and `h:m:s;nb_f chapter_name` with `nb_f` the number of frames and `fps` the framerate with 1 chapter per line\\n\"\n\t\t\"  - Common syntax: `CHAPTERX=h:m:s[:ms or .ms]` on first line and `CHAPTERXNAME=name` on next line (reverse order accepted)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"chapqt\", \"set chapter information from given file, using QT signaling for text tracks\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file_qt, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG_S(\"set-track-id\", \"id1:id2\", \"change id of track with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SET_ID, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"swap-track-id\", \"id1:id2\", \"swap the id between tracks with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SWAP_ID, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rem\", \"remove given track from file\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_REM_TRACK, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rap\", \"remove all non-RAP samples from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"refonly\", \"remove all non-reference pictures from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 1, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"enable\", \"enable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_ENABLE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"disable\", \"disable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_DISABLE, ARG_IS_FUN),\n \t{\"timescale\", NULL, \"set movie timescale to given value (ticks per second)\", \"600\", NULL, GF_ARG_INT, 0, &timescale, 0, ARG_OPEN_EDIT},\n \tMP4BOX_ARG_S(\"lang\", \"[tkID=]LAN\", \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", 0, parse_track_action, TRAC_ACTION_SET_LANGUAGE, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"delay\", \"tkID=TIME\", \"set track start delay in ms or in fractional seconds (`N/D`)\", 0, parse_track_action, TRAC_ACTION_SET_DELAY, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"par\", \"tkID=PAR\", \"set visual track pixel aspect ratio. PAR is:\\n\"\n\t\t\t\t\t\"  - N:D: set PAR to N:D in track, do not modify the bitstream\\n\"\n\t\t\t\t\t\"  - wN:D: set PAR to N:D in track and try to modify the bitstream\\n\"\n\t\t\t\t\t\"  - none: remove PAR info from track, do not modify the bitstream\\n\"\n\t\t\t\t\t\"  - auto: retrieve PAR info from bitstream and set it in track\\n\"\n\t\t\t\t\t\"  - force: force 1:1 PAR in track, do not modify the bitstream\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_PAR, ARG_IS_FUN\n\t\t\t\t\t),\n \tMP4BOX_ARG_S(\"clap\", \"tkID=CLAP\", \"set visual track clean aperture. CLAP is `Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd` or `none`\\n\"\n \t\t\t\"- n, d: numerator, denominator\\n\"\n\t        \"- W, H, HO, VO: clap width, clap height, clap horizontal offset, clap vertical offset\\n\"\n \t\t\t, GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_CLAP, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"mx\", \"tkID=MX\", \"set track matrix, with MX is M1:M2:M3:M4:M5:M6:M7:M8:M9 in 16.16 fixed point intergers or hexa\"\n \t\t\t, GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_MX, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"kind\", \"tkID=schemeURI=value\", \"set kind for the track or for all tracks using `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_SET_KIND, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"kind-rem\", \"tkID=schemeURI=value\", \"remove kind if given schemeID for the track or for all tracks with `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_REM_KIND, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"name\", \"tkID=NAME\", \"set track handler name to NAME (UTF-8 string)\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_HANDLER_NAME, ARG_IS_FUN),\n \tMP4BOX_ARG(\"itags\", \"set iTunes tags to file, see `-h tags`\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &itunes_tags, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"group-add\", \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"\n\t        \"- refTrack=ID: ID of the track used as a group reference. If not set, the track will belong to the same group as the \"\n\t        \"previous trackID specified. If 0 or no previous track specified, a new alternate group will be created\\n\"\n\t        \"- switchID=ID: ID of the switch group to create. If 0, a new ID will be computed for you. If <0, disables SwitchGroup\\n\"\n\t        \"- criteria=string: list of space-separated 4CCs\\n\"\n\t        \"- trackID=ID: ID of the track to add to this group\\n\"\n\t        \"  \\n\"\n\t        \"Warning: Options modify state as they are parsed, `trackID=1:criteria=lang:trackID=2` is different from `criteria=lang:trackID=1:trackID=2`\"\n\t        \"\\n\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_SET_PARAM, ARG_IS_FUN),\n\n\tMP4BOX_ARG(\"group-rem-track\", \"remove given track from its group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_TSEL, ARG_IS_FUN),\n\tMP4BOX_ARG(\"group-rem\", \"remove the track's group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP, ARG_IS_FUN),\n\tMP4BOX_ARG(\"group-clean\", \"remove all group information from all tracks\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &clean_groups, 0, ARG_OPEN_EDIT),\n\tMP4BOX_ARG_S(\"ref\", \"id:XXXX:refID\", \"add a reference of type 4CC from track ID to track refID\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_REFERENCE, ARG_IS_FUN),\n\tMP4BOX_ARG(\"keep-utc\", \"keep UTC timing in the file after edit\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &keep_utc, 0, 0),\n\tMP4BOX_ARG_S(\"udta\", \"tkID:[OPTS]\", \"set udta for given track or movie if tkID is 0. OPTS is a colon separated list of:\\n\"\n\t        \"- type=CODE: 4CC code of the UDTA (not needed for `box=` option)\\n\"\n\t        \"- box=FILE: location of the udta data, formatted as serialized boxes\\n\"\n\t        \"- box=base64,DATA: base64 encoded udta data, formatted as serialized boxes\\n\"\n\t        \"- src=FILE: location of the udta data (will be stored in a single box of type CODE)\\n\"\n\t        \"- src=base64,DATA: base64 encoded udta data (will be stored in a single box of type CODE)\\n\"\n\t        \"- str=STRING: use the given string as payload for the udta box\\n\"\n\t        \"Note: If no source is set, UDTA of type CODE will be removed\\n\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_UDTA, ARG_IS_FUN|ARG_OPEN_EDIT),\n\tMP4BOX_ARG_S(\"patch\", \"[tkID=]FILE\", \"apply box patch described in FILE, for given trackID if set\", GF_ARG_HINT_ADVANCED, parse_boxpatch, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"bo\", \"freeze the order of boxes in input file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &freeze_box_order, 0, 0),\n\tMP4BOX_ARG(\"init-seg\", \"use the given file as an init segment for dumping or for encryption\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &use_init_seg, 0, 0),\n\tMP4BOX_ARG(\"zmov\", \"compress movie box according to ISOBMFF box compression\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &compress_moov, 0, 0),\n \tMP4BOX_ARG_S(\"edits\", \"tkID=EDITS\", \"set edit list. The following syntax is used (no separators between entries):\\n\"\n\t\t\t\" - `r`: removes all edits\\n\"\n\t\t\t\" - `eSTART`: add empty edit with given start time (fractional or milliseconds). START can be\\n\"\n\t\t\t\"   - `VAL`: start time in milliseconds (media duration used as edit duration)\\n\"\n\t\t\t\"   - `VAL-DUR`: start time and duration in milliseconds\\n\"\n\t\t\t\"   - `VAL/NUM`: start time as fractional seconds (media duration used as edit duration)\\n\"\n\t\t\t\"   - `VAL-DUR/NUM`: start time and duration as fractional seconds\\n\"\n\t\t\t\" - `eSTART,MEDIA[,RATE]`: add regular edit with given start, media start time (ms or fraction) and rate (fraction or INT/1000)\\n\"\n\t\t\t\" - Examples: \\n\"\n\t\t\t\"   - `-edits=re0-5/1e5-3/1,100/25`: remove edits, add empty edit at 0s for 5s, then add regular edit at 5s for 3s starting at 4s in media track\\n\"\n\t\t\t\"   - `-edits=re0-4/1,0,2/1`: remove edits, add single edit at 0s for 4s starting at 0s in media track and playing at speed 2\\n\"\n\t\t\t\t, 0, parse_track_action, TRAC_ACTION_SET_EDITS, ARG_IS_FUN),\n \tMP4BOX_ARG(\"moovpad\", \"specify amount of padding to keep after moov box for later inplace editing - if 0, moov padding is disabled\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &moov_pading, 0, ARG_NEED_SAVE),\n \tMP4BOX_ARG(\"no-inplace\", \"disable inplace rewrite\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_inplace, 0, 0),\n \tMP4BOX_ARG(\"hdr\", \"update HDR information based on given XML\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &high_dynamc_range_filename, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG_S(\"time\", \"[tkID=]DAY/MONTH/YEAR-H:M:S\", \"set movie or track creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_TIME, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"mtime\", \"tkID=DAY/MONTH/YEAR-H:M:S\", \"set media creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_MEDIA_TIME, ARG_IS_FUN),\n\t{0}\n};\n\nvoid PrintGeneralUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# General Options\\n\"\n\t\t\"MP4Box is a multimedia packager, with a vast number of functionalities: conversion, splitting, hinting, dumping, DASH-ing, encryption, transcoding and others.\\n\"\n\t\t\"MP4Box provides a large set of options, classified by categories (see [-h]()). These options do not follow any particular ordering.\\n\"\n\t\t\"MP4Box performs in-place rewrite of IsoMedia files (the input file is overwritten). You can change this behavior by using the [-out]() option.\\n\"\n\t\t\"MP4Box stores by default the file with 0.5 second interleaving and meta-data (`moov` ...) at the beginning, making it suitable for HTTP streaming. This may however takes longer to store the file, use [-flat]() to change this behavior.\\n\"\n\t\t\"MP4Box usually generates a temporary file when creating a new IsoMedia file. The location of this temporary file is OS-dependent, and it may happen that the drive/partition the temporary file is created on has not enough space or no write access. In such a case, you can specify a temporary file location with [-tmp]().\\n\"\n\t\t\"Note: Track operations identify tracks through their ID (usually referred to as tkID in the help), not their order.\\n\"\n\t\t\"Option values:\\n\"\n\t\t\"Unless specified otherwise, an option of type `integer` expects a trackID value following it.\"\n\t\t\"An option of type `boolean` expects no following value.\"\n\t\t\"  \\n\"\n\t);\n\n\n\twhile (m4b_gen_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_gen_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-gen\");\n\t}\n}\n\n\nMP4BoxArg m4b_split_args[] =\n{\n \tMP4BOX_ARG(\"split\", \"split in files of given max duration\", GF_ARG_STRING, 0, parse_split, 0, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-rap\", \"splitr\", \"split in files at each new RAP\", GF_ARG_STRING, 0, parse_split, 1, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", GF_ARG_STRING, 0, parse_split, 2, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-chunk\", \"splitx\", \"extract a new file from source. `VAL` can be formatted as:\\n\"\n\t\"- `S:E`: `S` (number of seconds) to `E` with `E` a number (in seconds), `end` or `end-N`, N  number of seconds before the end\\n\"\n\t\"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", GF_ARG_STRING, 0, parse_split, 3, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"splitz\", \"S:E\", \"same as -split-chunk, but adjust the end time to be before the next RAP sample, so that ranges `A:B` and `B:C` share exactly the same boundary `B`\", 0, parse_split, 4, ARG_IS_FUN),\n\t{0}\n};\n\n\nstatic void PrintSplitUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"  \\n\"\n\t\t\"# File splitting\\n\"\n\t\t\"MP4Box can split IsoMedia files by size, duration or extract a given part of the file to new IsoMedia file(s).\\n\"\n\t\t\"This requires that at most one track in the input file has non random-access points (typically one video track at most).\\n\"\n\t\t\"splitting will ignore all MPEG-4 Systems tracks and hint tracks, but will try to split private media tracks.\\n\"\n\t\t\"The input file must have enough random access points in order to be split. If this is not the case, you will have to re-encode the content.\\n\"\n\t\t\"You can add media to a file and split it in the same pass. In this case, the destination file (the one which would be obtained without splitting) will not be stored.\\n\"\n\t\t\"  \\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_split_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_split_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-split\");\n\t}\n\n}\n\n\nMP4BoxArg m4b_dash_args[] =\n{\n \tMP4BOX_ARG (\"dash\", \"create DASH from input files with given segment (subsegment for onDemand profile) duration in ms\", GF_ARG_DOUBLE, 0, &dash_duration, 0, ARG_NON_ZERO),\n \tMP4BOX_ARG(\"dash-live\", \"generate a live DASH session using the given segment duration in ms; using `-dash-live=F` will also write the live context to `F`. MP4Box will run the live session until `q` is pressed or a fatal error occurs\", GF_ARG_DOUBLE, 0, parse_dashlive, 0, ARG_IS_FUN2),\n \tMP4BOX_ARG(\"ddbg-live\", \"same as [-dash-live]() without time regulation for debug purposes\", GF_ARG_DOUBLE, 0, parse_dashlive, 1, ARG_IS_FUN2),\n\tMP4BOX_ARG(\"frag\", \"specify the fragment duration in ms. If not set, this is the DASH duration (one fragment per segment)\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),\n\tMP4BOX_ARG(\"out\", \"specify the output MPD file name\", GF_ARG_STRING, 0, &outName, 0, 0),\n\tMP4BOX_ARG_ALT(\"profile\", \"dash-profile\", \"specify the target DASH profile, and set default options to ensure conformance to the desired profile. Default profile is `full` in static mode, `live` in dynamic mode (old syntax using `:live` instead of `.live` as separator still possible). Defined values are onDemand, live, main, simple, full, hbbtv1.5.live, dashavc264.live, dashavc264.onDemand, dashif.ll\", GF_ARG_STRING, 0, parse_dash_profile, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"profile-ext\", \"specify a list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used\", GF_ARG_STRING, 0, &dash_profile_extension, 0, 0),\n\tMP4BOX_ARG(\"rap\", \"ensure that segments begin with random access points, segment durations might vary depending on the source encoding\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n\tMP4BOX_ARG(\"frag-rap\", \"ensure that all fragments begin with random access points (duration might vary depending on the source encoding)\", GF_ARG_BOOL, 0, &frag_at_rap, 0, 0),\n\tMP4BOX_ARG(\"segment-name\", \"set the segment name for generated segments. If not set (default), segments are concatenated in output file except in `live` profile where `dash_%%s`. Supported replacement strings are:\\n\"\n\t        \"- $Number[%%0Nd]$ is replaced by the segment number, possibly prefixed with 0\\n\"\n\t        \"- $RepresentationID$ is replaced by representation name\\n\"\n\t        \"- $Time$ is replaced by segment start time\\n\"\n\t        \"- $Bandwidth$ is replaced by representation bandwidth\\n\"\n\t        \"- $Init=NAME$ is replaced by NAME for init segment, ignored otherwise\\n\"\n\t        \"- $Index=NAME$ is replaced by NAME for index segments, ignored otherwise\\n\"\n\t        \"- $Path=PATH$ is replaced by PATH when creating segments, ignored otherwise\\n\"\n\t        \"- $Segment=NAME$ is replaced by NAME for media segments, ignored for init segments\", GF_ARG_STRING, 0, &seg_name, 0, 0),\n\t{\"segment-ext\", NULL, \"set the segment extension, `null` means no extension\", \"m4s\", NULL, GF_ARG_STRING, 0, &seg_ext, 0, 0},\n\t{\"init-segment-ext\", NULL, \"set the segment extension for init, index and bitstream switching segments, `null` means no extension\\n\", \"mp4\", NULL, GF_ARG_STRING, 0, &init_seg_ext, 0, 0},\n\tMP4BOX_ARG(\"segment-timeline\", \"use `SegmentTimeline` when generating segments\", GF_ARG_BOOL, 0, &segment_timeline, 0, 0),\n\tMP4BOX_ARG(\"segment-marker\", \"add a box of given type (4CC) at the end of each DASH segment\", GF_ARG_STRING, 0, &segment_marker, 0, ARG_IS_4CC),\n\tMP4BOX_ARG(\"insert-utc\", \"insert UTC clock at the beginning of each ISOBMF segment\", GF_ARG_BOOL, 0, &insert_utc, 0, 0),\n\tMP4BOX_ARG(\"base-url\", \"set Base url at MPD level. Can be used several times.  \\nWarning: this does not  modify generated files location\", GF_ARG_STRING, 0, parse_base_url, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"mpd-title\", \"set MPD title\", GF_ARG_STRING, 0, &dash_title, 0, 0),\n\tMP4BOX_ARG(\"mpd-source\", \"set MPD source\", GF_ARG_STRING, 0, &dash_source, 0, 0),\n\tMP4BOX_ARG(\"mpd-info-url\", \"set MPD info url\", GF_ARG_STRING, 0, &dash_more_info, 0, 0),\n \tMP4BOX_ARG(\"cprt\", \"add copyright string to MPD\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),\n\tMP4BOX_ARG(\"dash-ctx\", \"store/restore DASH timing from indicated file\", GF_ARG_STRING, 0, &dash_ctx_file, 0, 0),\n\tMP4BOX_ARG(\"dynamic\", \"use dynamic MPD type instead of static\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC, 0),\n\tMP4BOX_ARG(\"last-dynamic\", \"same as [-dynamic]() but close the period (insert lmsg brand if needed and update duration)\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC_LAST, 0),\n\tMP4BOX_ARG(\"mpd-duration\", \"set the duration in second of a live session (if `0`, you must use [-mpd-refresh]())\", GF_ARG_DOUBLE, 0, &mpd_live_duration, 0, 0),\n\tMP4BOX_ARG(\"mpd-refresh\", \"specify MPD update time in seconds\", GF_ARG_DOUBLE, 0, &mpd_update_time, 0, 0),\n\tMP4BOX_ARG(\"time-shift\", \"specify MPD time shift buffer depth in seconds, `-1` to keep all files)\", GF_ARG_INT, 0, &time_shift_depth, 0, 0),\n\tMP4BOX_ARG(\"subdur\", \"specify maximum duration in ms of the input file to be dashed in LIVE or context mode. This does not change the segment duration, but stops dashing once segments produced exceeded the duration. If there is not enough samples to finish a segment, data is looped unless [-no-loop]() is used which triggers a period end\", GF_ARG_DOUBLE, 0, &dash_subduration, 0, 0),\n\tMP4BOX_ARG(\"run-for\", \"run for given ms  the dash-live session then exits\", GF_ARG_INT, 0, &run_for, 0, 0),\n\tMP4BOX_ARG(\"min-buffer\", \"specify MPD min buffer time in ms\", GF_ARG_INT, 0, &min_buffer, 0, ARG_DIV_1000),\n\tMP4BOX_ARG(\"ast-offset\", \"specify MPD AvailabilityStartTime offset in ms if positive, or availabilityTimeOffset of each representation if negative\", GF_ARG_INT, 0, &ast_offset_ms, 0, 0),\n\tMP4BOX_ARG(\"dash-scale\", \"specify that timing for [-dash](),  [-dash-live](), [-subdur]() and [-do_frag]() are expressed in given timescale (units per seconds) rather than ms\", GF_ARG_INT, 0, &dash_scale, 0, ARG_NON_ZERO),\n\tMP4BOX_ARG(\"mem-frags\", \"fragmentation happens in memory rather than on disk before flushing to disk\", GF_ARG_BOOL, 0, &memory_frags, 0, 0),\n\tMP4BOX_ARG(\"pssh\", \"set pssh store mode\\n\"\n\t\"- v: initial movie\\n\"\n\t\"- f: movie fragments\\n\"\n\t\"- m: MPD\\n\"\n\t\"- mv, vm: in initial movie and MPD\\n\"\n\t\"- mf, fm: in movie fragments and MPD\", GF_ARG_INT, 0, parse_pssh, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"sample-groups-traf\", \"store sample group descriptions in traf (duplicated for each traf). If not set, sample group descriptions are stored in the initial movie\", GF_ARG_BOOL, 0, &samplegroups_in_traf, 0, 0),\n\tMP4BOX_ARG(\"mvex-after-traks\", \"store `mvex` box after `trak` boxes within the moov box. If not set, `mvex` is before\", GF_ARG_BOOL, 0, &mvex_after_traks, 0, 0),\n\tMP4BOX_ARG(\"sdtp-traf\", \"use `sdtp` box in `traf` (Smooth-like)\\n\"\n\t\"- no: do not use sdtp\\n\"\n\t\"- sdtp: use sdtp box to indicate sample dependencies and do not write info in trun sample flags\\n\"\n\t\"- both: use sdtp box to indicate sample dependencies and also write info in trun sample flags\\n\", GF_ARG_INT, 0, parse_sdtp, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"no-cache\", \"disable file cache for dash inputs\", GF_ARG_BOOL, 0, &no_cache, 0, 0),\n\tMP4BOX_ARG(\"no-loop\", \"disable looping content in live mode and uses period switch instead\", GF_ARG_BOOL, 0, &no_loop, 0, 0),\n\tMP4BOX_ARG(\"hlsc\", \"insert UTC in variant playlists for live HLS\", GF_ARG_BOOL, 0, &hls_clock, 0, 0),\n\tMP4BOX_ARG(\"bound\", \"segmentation will always try to split before or at, but never after, the segment boundary\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_IN, 0),\n\tMP4BOX_ARG(\"closest\", \"segmentation will use the closest frame to the segment boundary (before or after)\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_CLOSEST, 0),\n\tMP4BOX_ARG_ALT(\"subsegs-per-sidx\", \"frags-per-sidx\", \"set the number of subsegments to be written in each SIDX box\\n\"\n\t\"- 0: a single SIDX box is used per segment\\n\"\n\t\"- -1: no SIDX box is used\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &subsegs_per_sidx, 0, 0),\n\tMP4BOX_ARG(\"ssix\", \"enable SubsegmentIndexBox describing 2 ranges, first one from moof to end of first I-frame, second one unmapped. This does not work with daisy chaining mode enabled\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_ssix, 0, 0),\n\tMP4BOX_ARG(\"url-template\", \"use SegmentTemplate instead of explicit sources in segments. Ignored if segments are stored in the output file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 1, 0),\n\tMP4BOX_ARG(\"url-template-sim\", \"use SegmentTemplate simulation while converting HLS to MPD\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 2, 0),\n\tMP4BOX_ARG(\"daisy-chain\", \"use daisy-chain SIDX instead of hierarchical. Ignored if frags/sidx is 0\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &daisy_chain_sidx, 0, 0),\n\tMP4BOX_ARG(\"single-segment\", \"use a single segment for the whole file (OnDemand profile)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_segment, 0, 0),\n\t{\"single-file\", NULL, \"use a single file for the whole file (default)\", \"yes\", NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_file, 0, 0},\n\t{\"bs-switching\", NULL, \"set bitstream switching mode\\n\"\n\t\"- inband: use inband param set and a single init segment\\n\"\n\t\"- merge: try to merge param sets in a single sample description, fallback to `no`\\n\"\n\t\"- multi: use several sample description, one per quality\\n\"\n\t\"- no: use one init segment per quality\\n\"\n\t\"- single: to test with single input\", \"inband\", \"inband|merge|multi|no|single\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_bs_switch, 0, ARG_IS_FUN},\n\tMP4BOX_ARG(\"moof-sn\", \"set sequence number of first moof to given value\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_moof_sn, 0, 0),\n\tMP4BOX_ARG(\"tfdt\", \"set TFDT of first traf to given value in SCALE units (cf -dash-scale)\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_tfdt, 0, ARG_64BITS),\n\tMP4BOX_ARG(\"no-frags-default\", \"disable default fragments flags in trex (required by some dash-if profiles and CMAF/smooth streaming compatibility)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_fragments_defaults, 0, 0),\n\tMP4BOX_ARG(\"single-traf\", \"use a single track fragment per moof (smooth streaming and derived specs may require this)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_traf_per_moof, 0, 0),\n\tMP4BOX_ARG(\"tfdt-traf\", \"use a tfdt per track fragment (when -single-traf is used)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &tfdt_per_traf, 0, 0),\n\tMP4BOX_ARG(\"dash-ts-prog\", \"program_number to be considered in case of an MPTS input file\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &program_number, 0, 0),\n\tMP4BOX_ARG(\"frag-rt\", \"when using fragments in live mode, flush fragments according to their timing\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &frag_real_time, 0, 0),\n\tMP4BOX_ARG(\"cp-location\", \"set ContentProtection element location\\n\"\n\t        \"- as: sets ContentProtection in AdaptationSet element\\n\"\n\t        \"- rep: sets ContentProtection in Representation element\\n\"\n\t        \"- both: sets ContentProtection in both elements\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_cp_loc, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"start-date\", \"for live mode, set start date (as xs:date, eg YYYY-MM-DDTHH:MM:SSZ). Default is current UTC\\n\"\n\t\"Warning: Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_start_date, 0, 0),\n\tMP4BOX_ARG(\"cues\", \"ignore dash duration and segment according to cue times in given XML file (tests/media/dash_cues for examples)\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_cues, 0, 0),\n\tMP4BOX_ARG(\"strict-cues\", \"throw error if something is wrong while parsing cues or applying cue-based segmentation\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &strict_cues, 0, 0),\n\tMP4BOX_ARG(\"merge-last-seg\", \"merge last segment if shorter than half the target duration\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &merge_last_seg, 0, 0),\n\t{0}\n};\n\nvoid PrintDASHUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# DASH Options\\n\"\n\t\t\"Also see:\\n\"\n\t\t\"- the [dasher `gpac -h dash`](dasher) filter documentation\\n\"\n\t\t\"- [[DASH wiki|DASH-intro]].\\n\"\n\t\t\"\\n\"\n\t\t\"# Specifying input files\\n\"\n\t\t\"Input media files to dash can use the following modifiers\\n\"\n\t\t\"- #trackID=N: only use the track ID N from the source file\\n\"\n\t\t\"- #N: only use the track ID N from the source file (mapped to [-tkid](mp4dmx))\\n\"\n\t\t\"- #video: only use the first video track from the source file\\n\"\n\t\t\"- #audio: only use the first audio track from the source file\\n\"\n\t\t\"- :id=NAME: set the representation ID to NAME. Reserved value `NULL` disables representation ID for multiplexed inputs. If not set, a default value is computed and all selected tracks from the source will be in the same output mux.\\n\"\n\t\t\"- :dur=VALUE: process VALUE seconds from the media. If VALUE is longer than media duration, last sample duration is extended.\\n\"\n\t\t\"- :period=NAME: set the representation's period to NAME. Multiple periods may be used. Periods appear in the MPD in the same order as specified with this option\\n\"\n\t\t\"- :BaseURL=NAME: set the BaseURL. Set multiple times for multiple BaseURLs\\nWarning: This does not modify generated files location (see segment template).\\n\"\n\t\t\"- :bandwidth=VALUE: set the representation's bandwidth to a given value\\n\"\n\t\t\"- :pdur=VALUE: increase the duration of this period by the given duration in seconds (alias for period_duration:VALUE). This is only used when no input media is specified (remote period insertion), eg `:period=X:xlink=Z:pdur=Y`\\n\"\n\t\t\"- :duration=VALUE: override target DASH segment duration for this input\\n\"\n\t\t\"- :xlink=VALUE: set the xlink value for the period containing this element. Only the xlink declared on the first rep of a period will be used\\n\"\n\t\t\"- :asID=VALUE: set the AdaptationSet ID to NAME\\n\"\n\t\t\"- :role=VALUE: set the role of this representation (cf DASH spec). Media with different roles belong to different adaptation sets.\\n\"\n\t\t\"- :desc_p=VALUE: add a descriptor at the Period level. Value must be a properly formatted XML element.\\n\"\n\t\t\"- :desc_as=VALUE: add a descriptor at the AdaptationSet level. Value must be a properly formatted XML element. Two input files with different values will be in different AdaptationSet elements.\\n\"\n\t\t\"- :desc_as_c=VALUE: add a descriptor at the AdaptationSet level. Value must be a properly formatted XML element. Value is ignored while creating AdaptationSet elements.\\n\"\n\t\t\"- :desc_rep=VALUE: add a descriptor at the Representation level. Value must be a properly formatted XML element. Value is ignored while creating AdaptationSet elements.\\n\"\n\t\t\"- :sscale: force movie timescale to match media timescale of the first track in the segment.\\n\"\n\t\t\"- :trackID=N: only use the track ID N from the source file\\n\"\n\t\t\"- @f1[:args][@fN:args][@@fK:args]: set a filter chain to insert between the source and the dasher. Each filter in the chain is formatted as a regular filter, see [filter doc `gpac -h doc`](filters_general). If several filters are set:\\n\"\n\t\t\"  - they will be chained in the given order if separated by a single `@`\\n\"\n\t\t\"  - a new filter chain will be created if separated by a double `@@`. In this case, no representation ID is assigned to the source.\\n\"\n\t\t\"EX source.mp4:@enc:c=avc:b=1M@@enc:c=avc:b=500k\\n\"\n\t\t\"This will load a filter chain with two encoders connected to the source and to the dasher.\\n\"\n\t\t\"EX source.mp4:@enc:c=avc:b=1M@enc:c=avc:b=500k\\n\"\n\t\t\"This will load a filter chain with the second encoder connected to the output of the first (!!).\\n\"\n\t\t\"\\n\"\n\t\t\"Note: `@f` must be placed after all other options.\\n\"\n\t\t\"\\n\"\n\t\t\"# Options\\n\"\n\t\t);\n\n\n\twhile (m4b_dash_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_dash_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-dash\");\n\t}\n}\n\n\nMP4BoxArg m4b_imp_args[] =\n{\n \tMP4BOX_ARG(\"add\", \"add given file tracks to file. Multiple inputs can be specified using `+`, eg `-add url1+url2`\", GF_ARG_STRING, 0, &nb_add, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"cat\", \"concatenate given file samples to file, creating tracks if needed. Multiple inputs can be specified using `+`, eg `-cat url1+url2`.  \\nNote: This aligns initial timestamp of the file to be concatenated\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"catx\", \"same as [-cat]() but new tracks can be imported before concatenation by specifying `+ADD_COMMAND` where `ADD_COMMAND` is a regular [-add]() syntax\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"catpl\", \"concatenate files listed in the given playlist file (one file per line, lines starting with # are comments).  \\nNote: Each listed file is concatenated as if called with -cat\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"unalign-cat\", \"do not attempt to align timestamps of samples in-between tracks\", GF_ARG_BOOL, 0, &align_cat, 0, ARG_BOOL_REV),\n \tMP4BOX_ARG(\"force-cat\", \"skip media configuration check when concatenating file.  \\nWarning: THIS MAY BREAK THE CONCATENATED TRACK(S)\", GF_ARG_BOOL, 0, &force_cat, 0, 0),\n \tMP4BOX_ARG(\"keep-sys\", \"keep all MPEG-4 Systems info when using [-add]() and [-cat]() (only used when adding IsoMedia files)\", GF_ARG_BOOL, 0, &keep_sys_tracks, 0, 0),\n \tMP4BOX_ARG(\"dref\", \"keep media data in original file using `data referencing`. The resulting file only contains the meta-data of the presentation (frame sizes, timing, etc...) and references media data in the original file. This is extremely useful when developing content, since importing and storage of the MP4 file is much faster and the resulting file much smaller.  \\nNote: Data referencing may fail on some files because it requires the framed data (eg an IsoMedia sample) to be continuous in the original file, which is not always the case depending on the original interleaving or bitstream format (__AVC__ or __HEVC__ cannot use this option)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_USE_DATAREF, ARG_BIT_MASK),\n \tMP4BOX_ARG_ALT(\"no-drop\", \"nodrop\", \"force constant FPS when importing AVI video\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_NO_FRAME_DROP, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"packed\", \"force packed bitstream when importing raw MPEG-4 part 2 Advanced Simple Profile\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_PACKED, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sbr\", \"backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_IMPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sbrx\", \"non-backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_EXPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"ps\", \"backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_IMPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"psx\", \"non-backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_EXPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"ovsbr\", \"oversample SBR import (SBR AAC, PS AAC and oversampled SBR cannot be detected at import time)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_OVSBR, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"fps\", \"force frame rate for video and SUB subtitles import to the given value, expressed as a number, as `TS-inc` or `TS/inc`.  \\nNote: For raw H263 import, default FPS is `15`, otherwise `25`. This is ignored for ISOBMFF import, use `:rescale` option for that\", GF_ARG_STRING, 0, parse_fps, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mpeg4\", \"force MPEG-4 sample descriptions when possible. For AAC, forces MPEG-4 AAC signaling even if MPEG-2\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"agg\", \"aggregate N audio frames in 1 sample (3GP media only, maximum value is 15)\", GF_ARG_INT, 0, &agg_samples, 0, 0),\n\t{0}\n};\n\n\nstatic MP4BoxArg m4b_imp_fileopt_args [] = {\n\tGF_DEF_ARG(\"dur\", NULL, \"`XC` import only the specified duration from the media. Value can be:\\n\"\n\t\t\"  - positive float: specifies duration in seconds\\n\"\n\t\t\"  - fraction: specifies duration as NUM/DEN fraction\\n\"\n\t\t\"  - negative integer: specifies duration in number of coded frames\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"start\", NULL, \"`C` target start time in source media, may not be supported depending on the source\", NULL, NULL, GF_ARG_DOUBLE, 0),\n\tGF_DEF_ARG(\"lang\", NULL, \"`S` set imported media language code\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"delay\", NULL, \"`S` set imported media initial delay in ms or as fractional seconds (`N/D`)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"par\", NULL, \"`S` set visual pixel aspect ratio (see [-par](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"clap\", NULL, \"`S` set visual clean aperture (see [-clap](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"mx\", NULL, \"`S` set track matrix (see [-mx](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"name\", NULL, \"`S` set track handler name\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"ext\", NULL, \"override file extension when importing\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"hdlr\", NULL, \"`S` set track handler type to the given code point (4CC)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"tkhd\", NULL, \"`S` set track header flags has hex integer. Use `tkhd+=FLAGS` to add flags and `tkhd-=FLAGS` to remove flags\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"disable\", NULL, \"`S` disable imported track(s), use `disable=no` to force enabling a disabled track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"group\", NULL, \"`S` add the track as part of the G alternate group. If G is 0, the first available GroupID will be picked\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"fps\", NULL, \"same as [-fps]()\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"rap\", NULL, \"`DS` import only RAP samples\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"refs\", NULL, \"`DS` import only reference pictures\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"trailing\", NULL, \"keep trailing 0-bytes in AVC/HEVC samples\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"agg\", NULL, \"`X` same as [-agg]()\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"dref\", NULL, \"`XC` same as [-dref]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"keep_refs\", NULL, \"`C` keep track reference when importing a single track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nodrop\", NULL, \"same as [-nodrop]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"packed\", NULL, \"`X` same as [-packed]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"sbr\", NULL, \"same as [-sbr]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"sbrx\", NULL, \"same as [-sbrx]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ovsbr\", NULL, \"same as [-ovsbr]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ps\", NULL, \"same as [-ps]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"psx\", NULL, \"same as [-psx]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"asemode\", NULL, \"`XS` set the mode to create the AudioSampleEntry. Value can be:\\n\"\n\t\t\"  - v0-bs: use MPEG AudioSampleEntry v0 and the channel count from the bitstream (even if greater than 2) - default\\n\"\n\t\t\"  - v0-2: use MPEG AudioSampleEntry v0 and the channel count is forced to 2\\n\"\n\t\t\"  - v1: use MPEG AudioSampleEntry v1 and the channel count from the bitstream\\n\"\n\t\t\"  - v1-qt: use QuickTime Sound Sample Description Version 1 and the channel count from the bitstream (even if greater than 2). This will also trigger using alis data references instead of url, even for non-audio tracks\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"audio_roll\", NULL, \"`S` add a roll sample group with roll_distance `N` for audio tracks\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"roll\", NULL, \"`S` add a roll sample group with roll_distance `N`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"proll\", NULL, \"`S` add a preroll sample group with roll_distance `N`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"mpeg4\", NULL, \"`X` same as [-mpeg4]() option\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nosei\", NULL, \"discard all SEI messages during import\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"svc\", NULL, \"import SVC/LHVC with explicit signaling (no AVC base compatibility)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nosvc\", NULL, \"discard SVC/LHVC data when importing\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"svcmode\", NULL, \"`DS` set SVC/LHVC import mode. Value can be:\\n\"\n\t\t\"  - split: each layer is in its own track\\n\"\n\t\t\"  - merge: all layers are merged in a single track\\n\"\n\t\t\"  - splitbase: all layers are merged in a track, and the AVC base in another\\n\"\n\t\t\"  - splitnox: each layer is in its own track, and no extractors are written\\n\"\n\t\t\"  - splitnoxib: each layer is in its own track, no extractors are written, using inband param set signaling\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"temporal\", NULL, \"`DS` set HEVC/LHVC temporal sublayer import mode. Value can be:\\n\"\n\t\t\"  - split: each sublayer is in its own track\\n\"\n\t\t\"  - splitbase: all sublayers are merged in a track, and the HEVC base in another\\n\"\n\t\t\"  - splitnox: each layer is in its own track, and no extractors are written\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"subsamples\", NULL, \"add SubSample information for AVC+SVC\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"deps\", NULL, \"import sample dependency information for AVC and HEVC\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ccst\", NULL, \"`S` add default HEIF ccst box to visual sample entry\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"forcesync\", NULL, \"force non IDR samples with I slices (OpenGOP or GDR) to be marked as sync points\\n\"\n\t\t\"Warning: RESULTING FILE IS NOT COMPLIANT WITH THE SPEC but will fix seeking in most players\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"xps_inband\", NULL, \"`XC` set xPS inband for AVC/H264 and HEVC (for reverse operation, re-import from raw media)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"xps_inbandx\", NULL, \"`XC` same as xps_inband and also keep first xPS in sample description\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"au_delim\", NULL, \"keep AU delimiter NAL units in the imported file\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"max_lid\", NULL, \"set HEVC max layer ID to be imported to `N` (by default imports all layers)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"max_tid\", NULL, \"set HEVC max temporal ID to be imported to `N` (by default imports all temporal sublayers)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"tiles\", NULL, \"`S` add HEVC tiles signaling and NALU maps without splitting the tiles into different tile tracks\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"split_tiles\", NULL, \"`DS` split HEVC tiles into different tile tracks, one tile (or all tiles of one slice) per track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"negctts\", NULL, \"`S` use negative CTS-DTS offsets (ISO4 brand). Use `negctts=no` to force using positive offset on existing track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"chap\", NULL, \"`S` specify the track is a chapter track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"chapter\", NULL, \"`S` add a single chapter (old nero format) with given name lasting the entire file\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"chapfile\", NULL, \"`S` add a chapter file (old nero format)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"layout\", NULL, \"`S` specify the track layout as `WxH[xXxY][xLAYER]`. If `W` (resp `H`) is 0, the max width (resp height) of the tracks in the file are used\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"rescale\", NULL, \"`S` force media timescale to TS  (int or fraction) and change the media duration\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"sampdur\", NULL, \"`S` force all samples duration (`D`) or sample durations and media timescale (`D/TS`), used to patch CFR files with broken timings\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"timescale\", NULL, \"`S` set imported media timescale to TS\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"moovts\", NULL, \"`S` set movie timescale to TS. A negative value picks the media timescale of the first track imported\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"noedit\", NULL, \"`XS` do not set edit list when importing B-frames video tracks\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"rvc\", NULL, \"`S` set RVC configuration for the media\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"fmt\", NULL, \"override format detection with given format - disable data probing and force `ext` option on source\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"profile\", NULL, \"`S` override AVC profile. Integer value, or `high444`, `high`, `extended`, `main`, `baseline`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"level\", NULL, \"`S` override AVC level, if value < 6, interpreted as decimal expression\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"compat\", NULL, \"`S` force the profile compatibility flags for the H.264 content\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"novpsext\", NULL, \"remove VPS extensions from HEVC VPS\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"keepav1t\", NULL, \"keep AV1 temporal delimiter OBU in samples, might help if source file had losses\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"font\", NULL, \"specify font name for text import (default `Serif`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"size\", NULL, \"specify font size for text import (default `18`)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"text_layout\", NULL, \"specify the track text layout as WxHxXxY\\n\"\n\t\t\"  - if W (resp H) = 0: the max width (resp height) of the tracks in the file are used\\n\"\n\t\t\"  - if Y=-1: the layout is moved to the bottom of the track area\\n\"\n\t\t\"  - X and Y can be omitted: `:layout=WxH`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"swf-global\", NULL, \"all SWF defines are placed in first scene replace rather than when needed\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-ctrl\", NULL, \"use a single stream for movie control and dictionary (this will disable ActionScript)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-text\", NULL, \"remove all SWF text\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-font\", NULL, \"remove all embedded SWF Fonts (local playback host fonts used)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-line\", NULL, \"remove all lines from SWF shapes\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-grad\", NULL, \"remove all gradients from SWF shapes\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-quad\", NULL, \"use quadratic bezier curves instead of cubic ones\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-xlp\", NULL, \"support for lines transparency and scalability\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-ic2d\", NULL, \"use indexed curve 2D hardcoded proto\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-same-app\", NULL, \"appearance nodes are reused\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-flatten\", NULL, \"complementary angle below which 2 lines are merged, `0` means no flattening\", NULL, NULL, GF_ARG_DOUBLE, 0),\n\tGF_DEF_ARG(\"kind\", NULL, \"`S` set kind for the track as `schemeURI=value`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"txtflags\", NULL, \"set display flags (hexa number) of text track. Use `txtflags+=FLAGS` to add flags and `txtflags-=FLAGS` to remove flags\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"rate\", NULL, \"force average rate and max rate to VAL (in bps) in btrt box. If 0, removes btrt box\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"stz2\", NULL, \"`S` use compact size table (for low-bitrates)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"bitdepth\", NULL, \"set bit depth to VAL for imported video content (default is 24)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"colr\", NULL, \"`S` set color profile for imported video content (see ISO/IEC 23001-8). Value is formatted as:\\n\"\n\t\t\"  - nclc,p,t,m: with p colour primary (int or string), t transfer characteristics (int or string) and m matrix coef (int or string)\\n\"\n\t\t\"  - nclx,p,t,m,r: same as `nclx` with r full range flag (`yes`, `on` or `no`, `off`)\\n\"\n\t\t\"  - prof,path: with path indicating the file containing the ICC color profile\\n\"\n\t\t\"  - rICC,path: with path indicating the file containing the restricted ICC color profile\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"dv-profile\", NULL, \"`S` set the Dolby Vision profile\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"fullrange\", NULL, \"`S` force the video fullrange type in VUI for the AVC|H264 content (value `yes`, `on` or `no`, `off`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"videofmt\", NULL, \"`S` force the video format in VUI for AVC|H264 and HEVC content, value can be `component`, `pal`, `ntsc`, `secam`, `mac`, `undef`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colorprim\", NULL, \"`S` force the colour primaries in VUI for AVC|H264 and HEVC (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colortfc\", NULL, \"`S` force transfer characteristics in VUI for AVC|H264 and HEVC (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colormx\", NULL, \"`S` force the matrix coefficients in VUI for the AVC|H264 and HEVC content (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"tc\", NULL, \"`S` inject a single QT timecode. Value is formatted as:\\n\"\n\t\t\"  - [d]FPS[/FPS_den],h,m,s,f[,framespertick]: optional drop flag, framerate (integer or fractional), hours, minutes, seconds and frame number\\n\"\n\t\t\"  - : `d` is an optional flag used to indicate that the counter is in drop-frame format\\n\"\n\t\t\"  - : the `framespertick` is optional and defaults to round(framerate); it indicates the number of frames per counter tick\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"edits\", NULL, \"`S` override edit list, same syntax as [-edits]()\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"lastsampdur\", NULL, \"`S` set duration of the last sample. Value is formatted as:\\n\"\n\t\t\"  - no value: use the previous sample duration\\n\"\n\t\t\"  - integer: indicate the duration in milliseconds\\n\"\n\t\t\"  - N/D: indicate the duration as fractional second\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"fstat\", NULL, \"print filter session stats after import\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"fgraph\", NULL, \"print filter session graph after import\", NULL, NULL, GF_ARG_BOOL, 0),\n\t{\"sopt:[OPTS]\", NULL, \"set `OPTS` as additional arguments to source filter. `OPTS` can be any usual filter argument, see [filter doc `gpac -h doc`](Filters)\"},\n\t{\"dopt:[OPTS]\", NULL, \"`X` set `OPTS` as additional arguments to [destination filter](mp4mx). OPTS can be any usual filter argument, see [filter doc `gpac -h doc`](Filters)\"},\n\t{\"@f1[:args][@fN:args]\", NULL, \"set a filter chain to insert before the muxer. Each filter in the chain is formatted as a regular filter, see [filter doc `gpac -h doc`](Filters). A `@@` separator starts a new chain (see DASH help). The last filter in each chain shall not have any ID specified\"},\n\t{0}\n};\n\nvoid PrintImportUsage()\n{\n\tu32 i;\n\n\tgf_sys_format_help(helpout, help_flags, \"# Importing Options\\n\"\n\t\t\"# File importing\\n\"\n\t\t\"Syntax is [-add]() / [-cat]() `URL[#FRAGMENT][:opt1...:optN=val]`\\n\"\n\t\t\"This process will create the destination file if not existing, and add the track(s) to it. If you wish to always create a new destination file, add [-new](MP4B_GEN).\\n\"\n\t\t\"The supported input media types depend on your installation, check [filters documentation](Filters) for more info.\\n\"\n\t\t\"  \\n\"\n\t\t\"To select a desired media track from a source, a fragment identifier '#' can be specified, before any other options. The following syntax is used:\\n\"\n\t\t\"- `#video`: adds the first video track found in source\\n\"\n\t\t\"- `#audio`: adds the first audio track found in source\\n\"\n\t\t\"- `#auxv`: adds the first auxiliary video track found in source\\n\"\n\t\t\"- `#pict`: adds the first picture track found in source\\n\"\n\t\t\"- `#trackID=ID` or `#ID`: adds the specified track. For IsoMedia files, ID is the track ID. For other media files, ID is the value indicated by `MP4Box -info inputFile`\\n\"\n\t\t\"- `#pid=ID`: number of desired PID for MPEG-2 TS sources\\n\"\n\t\t\"- `#prog_id=ID`: number of desired program for MPEG-2 TS sources\\n\"\n\t\t\"- `#program=NAME`: name of desired program for MPEG-2 TS sources\\n\"\n\t\t\"  \\n\"\n\t\t\"By default all imports are performed sequentially, and final interleaving is done at the end; this however requires a temporary file holding original ISOBMF file (if any) and added files before creating the final output. Since this can become quite large, it is possible to add media to a new file without temporary storage, using [-flat](MP4B_GEN) option, but this disables media interleaving.\\n\"\n\t\t\"  \\n\"\n\t\t\"If you wish to create an interleaved new file with no temporary storage, use the [-newfs](MP4B_GEN) option. The interleaving might not be as precise as when using [-new]() since it is dependent on muxer input scheduling (each execution might lead to a slightly different result). Additionally in this mode: \\n\"\n\t\t\" - Some muxing options (marked with `X` below) will be activated for all inputs (e.g it is not possible to import one AVC track with `xps_inband` and another without).\\n\"\n\t\t\" - Some muxing options (marked as `D` below) cannot be used as they require temporary storage for file edition.\\n\"\n\t\t\" - Usage of [-cat]() is possible, but concatenated sources will not be interleaved in the output. If you wish to perform more complex cat/add operations without temp file, use a [playlist](flist).\\n\"\n\t\t\"  \\n\"\n\t\t\"Source URL can be any URL supported by GPAC, not limited to local files.\\n\"\n\t\t\"  \\n\"\n\t\t\"Note: When importing SRT or SUB files, MP4Box will choose default layout options to make the subtitle appear at the bottom of the video. You SHOULD NOT import such files before any video track is added to the destination file, otherwise the results will likely not be useful (default SRT/SUB importing uses default serif font, fontSize 18 and display size 400x60). For more details, check [TTXT doc](Subtitling-with-GPAC).\\n\"\n\t\t\"  \\n\"\n\t\t\"When importing several tracks/sources in one pass, all options will be applied if relevant to each source. These options are set for all imported streams. If you need to specify these options per stream, set per-file options using the syntax `-add stream[:opt1:...:optN]`.\\n\"\n\t\t\"  \\n\"\n\t\t\"The import file name may be set to empty or `self`, indicating that the import options should be applied to the destination file track(s).\\n\"\n\t\t\"EX -add self:moovts=-1:noedit src.mp4\\n\"\n\t\t\"This will apply `moovts` and `noedit` option to all tracks in src.mp4\\n\"\n\t\t\"EX -add self#2:moovts=-1:noedit src.mp4\\n\"\n\t\t\"This will apply `moovts` and `noedit` option to track with `ID=2` in src.mp4\\n\"\n\t\t\"Only per-file options marked with a `S` are possible in this mode.\\n\"\n\t\t\"  \\n\"\n\t\t\"When importing an ISOBMFF/QT file, only options marked as `C` or `S` can be used.\\n\"\n\t\t\"  \\n\"\n\t\t\"Allowed per-file options:\\n\\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_imp_fileopt_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_fileopt_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags | GF_PRINTARG_NO_DASH, arg, \"mp4box-import\");\n\t}\n\n\tgf_sys_format_help(helpout, help_flags, \"\\n\"\n\t\t\"Note: `sopt`, `dopt` and `@f` must be placed after all other options.\\n\"\n\t\t\"# Global import options\\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_imp_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-import\");\n\t}\n}\n\nBool mp4box_check_isom_fileopt(char *opt)\n{\n\tGF_GPACArg *arg = NULL;\n\tu32 i=0;\n\n\twhile (m4b_imp_fileopt_args[i].name) {\n\t\targ = (GF_GPACArg *) &m4b_imp_fileopt_args[i];\n\t\ti++;\n\t\tif (!stricmp(arg->name, opt)) break;\n\t\targ = NULL;\n\t}\n\tif (!arg) {\n\t\tfprintf(stderr, \"Option %s not described in doc, please report to GPAC devs!\\n\", opt);\n\t\treturn GF_FALSE;\n\t}\n\tif (arg->description[0] != '`')\n\t\treturn GF_FALSE;\n\tconst char *d = arg->description+1;\n\twhile (d[0] != '`') {\n\t\tif (d[0]=='S') return GF_TRUE;\n\t\tif (d[0]=='C') return GF_TRUE;\n\t\td++;\n\t}\n\treturn GF_FALSE;\n}\n\n\nMP4BoxArg m4b_senc_args[] =\n{\n \tMP4BOX_ARG(\"mp4\", \"specify input file is for BIFS/LASeR encoding\", GF_ARG_BOOL, 0, &encode, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"def\", \"encode DEF names in BIFS\", GF_ARG_BOOL, 0, &smenc_opts.flags, GF_SM_ENCODE_USE_NAMES, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sync\", \"force BIFS sync sample generation every given time in ms (cannot be used with [-shadow]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"shadow\", \"force BIFS sync shadow sample generation every given time in ms (cannot be used with [-sync]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"carousel\", \"use BIFS carousel (cannot be used with [-sync]() or [-shadow]() )\", GF_ARG_INT, 0, parse_senc_param, 2, ARG_IS_FUN),\n\n \tMP4BOX_ARG(\"sclog\", \"generate scene codec log file if available\", GF_ARG_BOOL, 0, &do_scene_log, 0, 0),\n \tMP4BOX_ARG(\"ms\", \"import tracks from the given file\", GF_ARG_STRING, 0, &mediaSource, 0, 0),\n \tMP4BOX_ARG(\"ctx-in\", \"specify initial context (MP4/BT/XMT) file for chunk processing. Input file must be a commands-only file\", GF_ARG_STRING, 0, parse_senc_param, 5, ARG_IS_FUN),\n \tMP4BOX_ARG(\"ctx-out\", \"specify storage of updated context (MP4/BT/XMT) file for chunk processing, optional\", GF_ARG_STRING, 0, &output_ctx, 0, 0),\n \tMP4BOX_ARG(\"resolution\", \"resolution factor (-8 to 7, default 0) for LASeR encoding, and all coordinates are multiplied by `2^res` before truncation (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.resolution, 0, 0),\n \tMP4BOX_ARG(\"coord-bits\", \"number of bits used for encoding truncated coordinates (0 to 31, default 12) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.coord_bits, 0, 0),\n \tMP4BOX_ARG(\"scale-bits\", \"extra bits used for encoding truncated scales (0 to 4, default 0) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.scale_bits, 0, 0),\n \tMP4BOX_ARG(\"auto-quant\", \"resolution is given as if using [-resolution]() but coord-bits and scale-bits are infered (LASeR encoding)\", GF_ARG_INT, 0, parse_senc_param, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"global-quant\", \"resolution is given as if using [-resolution]() but the res is inferred (BIFS encoding)\", GF_ARG_INT, 0, parse_senc_param, 4, ARG_IS_FUN),\n \t{0}\n};\n\n\nvoid PrintEncodeUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# MPEG-4 Scene Encoding Options\\n\"\n\t\t\"## General considerations\\n\"\n\t\t\"MP4Box supports encoding and decoding of of BT, XMT, VRML and (partially) X3D formats int MPEG-4 BIFS, and encoding and decoding of XSR and SVG into MPEG-4 LASeR\\n\"\n\t\t\"Any media track specified through a `MuxInfo` element will be imported in the resulting MP4 file.\\n\"\n\t\t\"See https://wiki.gpac.io/MPEG-4-BIFS-Textual-Format and related pages.\\n\"\n\t\t\"## Scene Random Access\\n\"\n\t\t\"MP4Box can encode BIFS or LASeR streams and insert random access points at a given frequency. This is useful when packaging content for broadcast, where users will not turn in the scene at the same time. In MPEG-4 terminology, this is called the __scene carousel__.\"\n\t\t\"## BIFS Chunk Processing\\n\"\n\t\t\"The BIFS chunk encoding mode alows encoding single BIFS access units from an initial context and a set of commands.\\n\"\n\t\t\"The generated AUs are raw BIFS (not SL-packetized), in files called FILE-ESID-AUIDX.bifs, with FILE the basename of the input file.\\n\"\n\t\t\"Commands with a timing of 0 in the input will modify the carousel version only (i.e. output context).\\n\"\n\t\t\"Commands with a timing different from 0 in the input will generate new AUs.\\n\"\n\t\t\"  \\n\"\n\t\t\"Options:\\n\"\n\t);\n\n\twhile (m4b_senc_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_senc_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-senc\");\n\t}\n}\n\nMP4BoxArg m4b_crypt_args[] =\n{\n \tMP4BOX_ARG(\"crypt\", \"encrypt the input file using the given `CryptFile`\", GF_ARG_STRING, 0, parse_cryp, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"decrypt\", \"decrypt the input file, potentially using the given `CryptFile`. If `CryptFile` is not given, will fail if the key management system is not supported\", GF_ARG_STRING, 0, parse_cryp, 1, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG_S(\"set-kms\", \"tkID=kms_uri\", \"change ISMA/OMA KMS location for a given track or for all tracks if `all=` is used\", 0, parse_track_action, TRAC_ACTION_SET_KMS_URI, ARG_IS_FUN),\n \t{0}\n};\n\nvoid PrintEncryptUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Encryption/Decryption Options\\n\"\n\t\"MP4Box supports encryption and decryption of ISMA, OMA and CENC content, see [encryption filter `gpac -h cecrypt`](cecrypt).\\n\"\n\t\"It requires a specific XML file called `CryptFile`, whose syntax is available at https://wiki.gpac.io/Common-Encryption\\n\"\n\t\"Image files (HEIF) can also be crypted / decrypted, using CENC only.\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_crypt_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_crypt_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-crypt\");\n\t}\n}\n\nMP4BoxArg m4b_hint_args[] =\n{\n \tMP4BOX_ARG(\"hint\", \"hint the file for RTP/RTSP\", GF_ARG_BOOL, 0, &do_hint, 0, ARG_OPEN_EDIT),\n \t{\"mtu\", NULL, \"specify RTP MTU (max size) in bytes (this includes 12 bytes RTP header)\", \"1450\", NULL, GF_ARG_INT, 0, &MTUSize, 0, 0},\n \tMP4BOX_ARG(\"copy\", \"copy media data to hint track rather than reference (speeds up server but takes much more space)\", GF_ARG_BOOL, 0, &HintCopy, 0, 0),\n \tMP4BOX_ARG_S(\"multi\", \"[maxptime]\", \"enable frame concatenation in RTP packets if possible (with max duration 100 ms or `maxptime` ms if given)\", 0, parse_multi_rtp, 0, ARG_IS_FUN),\n \t{\"rate\", NULL, \"specify rtp rate in Hz when no default for payload\", \"90000\", NULL, GF_ARG_INT, 0, &rtp_rate, 0, 0},\n \tMP4BOX_ARG(\"mpeg4\", \"force MPEG-4 generic payload whenever possible\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"latm\", \"force MPG4-LATM transport for AAC streams\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_LATM_AAC, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"static\", \"enable static RTP payload IDs whenever possible (by default, dynamic payloads are always used)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_STATIC_ID, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"add-sdp\", \"add given SDP string to hint track (`tkID:string`) or movie (`string`)\", GF_ARG_STRING, 0, parse_sdp_ext, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"no-offset\", \"signal no random offset for sequence number and timestamp (support will depend on server)\", GF_ARG_BOOL, 0, &hint_no_offset, 0, 0),\n \tMP4BOX_ARG(\"unhint\", \"remove all hinting information from file\", GF_ARG_BOOL, 0, &remove_hint, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"group-single\", \"put all tracks in a single hint group\", GF_ARG_BOOL, 0, &single_group, 0, 0),\n \tMP4BOX_ARG(\"ocr\", \"force all MPEG-4 streams to be synchronized (MPEG-4 Systems only)\", GF_ARG_BOOL, 0, &force_ocr, 0, 0),\n \tMP4BOX_ARG(\"rap\", \"signal random access points in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"ts\", \"signal AU Time Stamps in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_TS, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"size\", \"signal AU size in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_SIZE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"idx\", \"signal AU sequence numbers in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_AU_IDX, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"iod\", \"prevent systems tracks embedding in IOD (MPEG-4 Systems), not compatible with [-isma]()\", GF_ARG_BOOL, 0, &regular_iod, 0, 0),\n \t{0}\n};\n\nvoid PrintHintUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Hinting Options\\n\"\n\t\t\"IsoMedia hinting consists in creating special tracks in the file that contain transport protocol specific information and optionally multiplexing information. These tracks are then used by the server to create the actual packets being sent over the network, in other words they provide the server with hints on how to build packets, hence their names `hint tracks`.\\n\"\n\t\t\"MP4Box supports creation of hint tracks for RTSP servers supporting these such as QuickTime Streaming Server, DarwinStreaming Server or 3GPP-compliant RTSP servers.\\n\"\n\t\t\"Note: GPAC streaming tools [rtp output](rtpout) and [rtsp server](rtspout) do not use hint tracks, they use on-the-fly packetization \"\n\t\t\"from any media sources, not just MP4\\n\"\n\t\t\"  \\n\"\n\t\t\"Options:\\n\"\n\t);\n\twhile (m4b_hint_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_hint_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-hint\");\n\t}\n}\n\n\nMP4BoxArg m4b_extr_args[] =\n{\n \tMP4BOX_ARG(\"raw\", \"extract given track in raw format when supported. Use `tkID:output=FileName` to set output file name\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NATIVE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"raws\", \"extract each sample of the given track to a file. Use `tkID:N` to extract the Nth sample\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_RAW_SAMPLES, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nhnt\", \"extract given track to [NHNT](nhntr) format\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NHNT, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nhml\", \"extract given track to [NHML](nhmlr) format. Use `tkID:full` for full NHML dump with all packet properties\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NHML, ARG_IS_FUN),\n \tMP4BOX_ARG(\"webvtt-raw\", \"extract given track as raw media in WebVTT as metadata. Use `tkID:embedded` to include media data in the WebVTT file\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_WEBVTT_META, ARG_IS_FUN),\n \tMP4BOX_ARG(\"single\", \"extract given track to a new mp4 file\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_MP4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"six\", \"extract given track as raw media in **experimental** XML streaming instructions\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_SIX, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mux\", \"mux input to given destination\", GF_ARG_STRING, 0, &mux_name, 0, 0),\n \tMP4BOX_ARG(\"qcp\", \"same as [-raw]() but defaults to QCP file for EVRC/SMV\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_USE_QCP, ARG_IS_FUN),\n \tMP4BOX_ARG(\"saf\", \"remux file to SAF multiplex\", GF_ARG_BOOL, 0, &do_saf, 0, 0),\n \tMP4BOX_ARG(\"dvbhdemux\", \"demux DVB-H file into IP Datagrams sent on the network\", GF_ARG_BOOL, 0, &dvbhdemux, 0, 0),\n \tMP4BOX_ARG(\"raw-layer\", \"same as [-raw]() but skips SVC/MVC/LHVC extractors when extracting\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_SVC_LAYER, ARG_IS_FUN),\n \tMP4BOX_ARG(\"diod\", \"extract file IOD in raw format\", GF_ARG_BOOL, 0, &dump_iod, 0, 0),\n \tMP4BOX_ARG(\"mpd\", \"convert given HLS or smooth manifest (local or remote http) to MPD.  \\nWarning: This is not compatible with other DASH options and does not convert associated segments\", GF_ARG_STRING, 0, &do_mpd_conv, 0, 0),\n \t{0}\n};\n\nvoid PrintExtractUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Extracting Options\\n\"\n\t\"MP4Box can be used to extract media tracks from MP4 files. If you need to convert these tracks however, please check the [filters doc](Filters).\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_extr_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_extr_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_dump_args[] =\n{\n \tMP4BOX_ARG(\"std\", \"dump/write to stdout and assume stdout is opened in binary mode\", GF_ARG_BOOL, 0, &dump_std, 2, 0),\n \tMP4BOX_ARG(\"stdb\", \"dump/write to stdout and try to reopen stdout in binary mode\", GF_ARG_BOOL, 0, &dump_std, 1, 0),\n \tMP4BOX_ARG(\"tracks\", \"print the number of tracks on stdout\", GF_ARG_BOOL, 0, &get_nb_tracks, 0, 0),\n \tMP4BOX_ARG(\"info\", \"print movie info (no parameter) or track info with specified ID\", GF_ARG_STRING, 0, parse_file_info, 0, ARG_IS_FUN|ARG_EMPTY),\n \tMP4BOX_ARG(\"infon\", \"print track info for given track number, 1 being the first track in the file\", GF_ARG_STRING, 0, parse_file_info, 1, ARG_IS_FUN|ARG_EMPTY),\n \tMP4BOX_ARG_ALT(\"diso\", \"dmp4\", \"dump IsoMedia file boxes in XML output\", GF_ARG_BOOL, 0, &dump_isom, 1, 0),\n \tMP4BOX_ARG(\"dxml\", \"dump IsoMedia file boxes and known track samples in XML output\", GF_ARG_BOOL, 0, &dump_isom, 2, 0),\n \tMP4BOX_ARG(\"disox\", \"dump IsoMedia file boxes except sample tables in XML output\", GF_ARG_BOOL, 0, &dump_isom, 3, 0),\n \tMP4BOX_ARG(\"keep-ods\", \"do not translate ISOM ODs and ESDs tags (debug purpose only)\", GF_ARG_BOOL, 0, &no_odf_conf, 0, 0),\n \tMP4BOX_ARG(\"bt\", \"dump scene to BT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_BT, ARG_HAS_VALUE),\n \tMP4BOX_ARG(\"xmt\", \"dump scene to XMT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_XMTA, 0),\n \tMP4BOX_ARG(\"wrl\", \"dump scene to VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_VRML, 0),\n \tMP4BOX_ARG(\"x3d\", \"dump scene to X3D XML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_XML, 0),\n \tMP4BOX_ARG(\"x3dv\", \"dump scene to X3D VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_VRML, 0),\n \tMP4BOX_ARG(\"lsr\", \"dump scene to LASeR XML (XSR) format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_LASER, 0),\n \tMP4BOX_ARG(\"svg\", \"dump scene to SVG\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_SVG, 0),\n \tMP4BOX_ARG(\"drtp\", \"dump rtp hint samples structure to XML output\", GF_ARG_BOOL, 0, &dump_rtp, 0, 0),\n \tMP4BOX_ARG(\"dts\", \"print sample timing, size and position in file to text output\", GF_ARG_BOOL, 0, parse_dump_ts, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dtsx\", \"same as [-dts]() but does not print offset\", GF_ARG_BOOL, 0, &dump_timestamps, 2, 0),\n \tMP4BOX_ARG(\"dtsc\", \"same as [-dts]() but analyses each sample for duplicated dts/cts (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 3, 0),\n \tMP4BOX_ARG(\"dtsxc\", \"same as [-dtsc]() but does not print offset (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 4, 0),\n \tMP4BOX_ARG(\"dnal\", \"print NAL sample info of given track\", GF_ARG_INT, 0, parse_dnal, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnalc\", \"print NAL sample info of given track, adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnald\", \"print NAL sample info of given track without DTS and CTS info\", GF_ARG_INT, 0, parse_dnal, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnalx\", \"print NAL sample info of given track without DTS and CTS info and adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 2|1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"sdp\", \"dump SDP description of hinted file\", GF_ARG_BOOL, 0, &print_sdp, 0, 0),\n \tMP4BOX_ARG(\"dsap\", \"dump DASH SAP cues (see -cues) for a given track\", GF_ARG_INT, 0, parse_dsap, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsaps\", \"same as [-dsap]() but only print sample number\", GF_ARG_INT, 0, parse_dsap, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapc\", \"same as [-dsap]() but only print CTS\", GF_ARG_INT, 0, parse_dsap, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapd\", \"same as [-dsap]() but only print DTS\", GF_ARG_INT, 0, parse_dsap, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapp\", \"same as [-dsap]() but only print presentation time\", GF_ARG_INT, 4, parse_dsap, 4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dcr\", \"dump ISMACryp samples structure to XML output\", GF_ARG_BOOL, 0, &dump_cr, 0, 0),\n \tMP4BOX_ARG(\"dump-cover\", \"extract cover art\", GF_ARG_BOOL, 0, &dump_cart, 0, 0),\n \tMP4BOX_ARG(\"dump-chap\", \"extract chapter file as TTXT format\", GF_ARG_BOOL, 0, &dump_chap, 1, 0),\n \tMP4BOX_ARG(\"dump-chap-ogg\", \"extract chapter file as OGG format\", GF_ARG_BOOL, 0, &dump_chap, 2, 0),\n \tMP4BOX_ARG(\"dump-chap-zoom\", \"extract chapter file as zoom format\", GF_ARG_BOOL, 0, &dump_chap, 3, 0),\n \tMP4BOX_ARG_S(\"dump-udta\", \"[tkID:]4cc\", \"extract user data for the given 4CC. If `tkID` is given, dumps from UDTA of the given track ID, otherwise moov is used\", 0, parse_dump_udta, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mergevtt\", \"merge vtt cues while dumping\", GF_ARG_BOOL, 0, &merge_vtt_cues, 0, 0),\n \tMP4BOX_ARG(\"ttxt\", \"convert input subtitle to GPAC TTXT format if no parameter. Otherwise, dump given text track to GPAC TTXT format\", GF_ARG_INT, 0, parse_ttxt, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"srt\", \"convert input subtitle to SRT format if no parameter. Otherwise, dump given text track to SRT format\", GF_ARG_INT, 0, parse_ttxt, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"stat\", \"generate node/field statistics for scene\", GF_ARG_BOOL, 0, &stat_level, 1, 0),\n \tMP4BOX_ARG(\"stats\", \"generate node/field statistics per Access Unit\", GF_ARG_BOOL, 0, &stat_level, 2, 0),\n \tMP4BOX_ARG(\"statx\", \"generate node/field statistics for scene after each AU\", GF_ARG_BOOL, 0, &stat_level, 3, 0),\n \tMP4BOX_ARG(\"hash\", \"generate SHA-1 Hash of the input file\", GF_ARG_BOOL, 0, &do_hash, 0, 0),\n \tMP4BOX_ARG(\"comp\", \"replace with compressed version all top level box types given as parameter, formatted as `orig_4cc_1=comp_4cc_1[,orig_4cc_2=comp_4cc_2]`\", GF_ARG_STRING, 0, parse_comp_box, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"topcount\", \"print to stdout the number of top-level boxes matching box types given as parameter, formatted as `4cc_1,4cc_2N`\", GF_ARG_STRING, 0, parse_comp_box, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"topsize\", \"print to stdout the number of bytes of top-level boxes matching types given as parameter, formatted as `4cc_1,4cc_2N` or `all` for all boxes\", GF_ARG_STRING, 0, parse_comp_box, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"bin\", \"convert input XML file using NHML bitstream syntax to binary\", GF_ARG_BOOL, 0, &do_bin_xml, 0, 0),\n \tMP4BOX_ARG(\"mpd-rip\", \"fetch MPD and segment to disk\", GF_ARG_BOOL, 0, &do_mpd_rip, 0, 0),\n \tMP4BOX_ARG_S(\"udp-write\", \"IP[:port]\", \"write input name to UDP (default port 2345)\", GF_FS_ARG_HINT_EXPERT, &udp_dest, 0, 0),\n \tMP4BOX_ARG(\"raw-cat\", \"raw concatenation of given file with input file\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &raw_cat, 0, 0),\n \tMP4BOX_ARG(\"wget\", \"fetch resource from http(s) URL\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &do_wget, 0, 0),\n \tMP4BOX_ARG(\"dm2ts\", \"dump timing of an input MPEG-2 TS stream sample timing\", GF_ARG_BOOL, 0, &dump_m2ts, 0, 0),\n \t{0}\n};\n\nvoid PrintDumpUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# File Dumping\\n\"\n\t\"  \\n\"\n\t\"MP4Box has many dump functionalities, from simple track listing to more complete reporting of special tracks.\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_dump_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_dump_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_meta_args[] =\n{\n \tMP4BOX_ARG_S(\"set-meta\", \"ABCD[:tk=tkID]\", \"set meta box type, with `ABCD` the four char meta type (NULL or 0 to remove meta)\\n\"\n\t\t\"- tk not set: use root (file) meta\\n\"\n\t\t\"- tkID == 0: use moov meta\\n\"\n\t\t\"- tkID != 0: use meta of given track\", 0, parse_meta_args, META_ACTION_SET_TYPE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"add-item\", \"add resource to meta, with parameter syntax `file_path[:opt1:optN]`\\n\"\n\t\t\"- file_path `this` or `self`: item is the file itself\\n\"\n\t\t\"- tk=tkID: meta location (file, moov, track)\\n\"\n\t\t\"- name=str: item name\\n\"\n\t\t\"- type=itype: item 4cc type (not needed if mime is provided)\\n\"\n\t\t\"- mime=mtype: item mime type\\n\"\n\t\t\"- encoding=enctype: item content-encoding type\\n\"\n\t\t\"- id=ID: item ID\\n\"\n\t\t\"- ref=4cc,id: reference of type 4cc to an other item (can be set multiple times)\\n\"\n\t\t\"- group=id,type: indicate the id and type of an alternate group for this item\"\n\t\t, GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"add-image\", \"add the given file as HEIF image item, with parameter syntax `file_path[:opt1:optN]`. If `filepath` is omitted, source is the input MP4 file\\n\"\n\t\t\"- name, id, ref: see [-add-item]()\\n\"\n\t\t\"- primary: indicate that this item should be the primary item\\n\"\n\t\t\"- time=t[-e][/i]: use the next sync sample after time t (float, in sec, default 0). A negative time imports ALL intra frames as items\\n\"\n\t\t\" - If `e` is set (float, in sec), import all sync samples between `t` and `e`\\n\"\n\t\t\" - If `i` is set (float, in sec), sets time increment between samples to import\\n\"\n\t\t\"- split_tiles: for an HEVC tiled image, each tile is stored as a separate item\\n\"\n\t\t\"- image-size=wxh: force setting the image size and ignoring the bitstream info, used for grid images also\\n\"\n\t\t\"- rotation=a: set the rotation angle for this image to 90*a degrees anti-clockwise\\n\"\n\t\t\"- mirror-axis=axis: set the mirror axis: vertical, horizontal\\n\"\n\t\t\"- clap=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd: see track clap\\n\"\n\t\t\"- hidden: indicate that this image item should be hidden\\n\"\n\t\t\"- icc_path: path to icc data to add as color info\\n\"\n\t\t\"- alpha: indicate that the image is an alpha image (should use ref=auxl also)\\n\"\n\t\t\"- tk=tkID: indicate the track ID of the source sample. If 0, uses the first video track in the file\\n\"\n\t\t\"- samp=N: indicate the sample number of the source sample\\n\"\n\t\t\"- ref: do not copy the data but refer to the final sample location\\n\"\n\t\t\"- agrid[=AR]: creates an automatic grid from the image items present in the file, in their declaration order. The grid will **try to** have `AR` aspect ratio if specified (float), or the aspect ratio of the source otherwise. The grid will be the primary item and all other images will be hidden\\n\"\n\t\t\"- any other options will be passed as options to the media importer, see [-add]()\"\n\t\t, GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"add-image-grid\", \"create an image grid item, with parameter syntax `grid[:opt1:optN]`\\n\"\n\t\t\"- image-grid-size=rxc: set the number of rows and columns of the grid\\n\"\n\t    \"- any other options from [-add-image]() can be used\\n\", GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_GRID, ARG_IS_FUN),\n\tMP4BOX_ARG_S_ALT(\"rem-item\", \"rem-image\", \"item_ID[:tk=tkID]\", \"remove resource from meta\", 0, parse_meta_args, META_ACTION_REM_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"set-primary\", \"item_ID[:tk=tkID]\", \"set item as primary for meta\", 0, parse_meta_args, META_ACTION_SET_PRIMARY_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"set-xml\", \"xml_file_path[:tk=tkID][:binary]\", \"set meta XML data\", 0, parse_meta_args, META_ACTION_SET_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"rem-xml\", \"[tk=tkID]\", \"remove meta XML data\", 0, parse_meta_args, META_ACTION_REM_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"dump-xml\", \"file_path[:tk=tkID]\", \"dump meta XML to file\", 0, parse_meta_args, META_ACTION_DUMP_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"dump-item\", \"item_ID[:tk=tkID][:path=fileName]\", \"dump item to file\", 0, parse_meta_args, META_ACTION_DUMP_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"package\", \"package input XML file into an ISO container, all media referenced except hyperlinks are added to file\", GF_ARG_STRING, 0, &pack_file, 0, 0),\n\tMP4BOX_ARG(\"mgt\", \"package input XML file into an MPEG-U widget with ISO container, all files contained in the current folder are added to the widget package\", GF_ARG_STRING, 0, parse_mpegu, 0, ARG_IS_FUN),\n\t{0}\n};\n\nvoid PrintMetaUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Meta and HEIF Options\\n\"\n\t\"IsoMedia files can be used as generic meta-data containers, for examples storing XML information and sample images for a movie. The resulting file may not always contain a movie as is the case with some HEIF files or MPEG-21 files.\\n\"\n\t\"  \\n\"\n\t\"These information can be stored at the file root level, as is the case for HEIF/IFF and MPEG-21 file formats, or at the movie or track level for a regular movie.\"\n\t\"  \\n  \\n\");\n\twhile (m4b_meta_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_meta_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_swf_args[] =\n{\n \tMP4BOX_ARG(\"global\", \"all SWF defines are placed in first scene replace rather than when needed\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_STATIC_DICT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-ctrl\", \"use a single stream for movie control and dictionary (this will disable ActionScript)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SPLIT_TIMELINE, ARG_BIT_MASK_REM),\n \tMP4BOX_ARG(\"no-text\", \"remove all SWF text\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_TEXT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-font\", \"remove all embedded SWF Fonts (local playback host fonts used)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_FONT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-line\", \"remove all lines from SWF shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_LINE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-grad\", \"remove all gradients from swf shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_GRADIENT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"quad\", \"use quadratic bezier curves instead of cubic ones\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_QUAD_CURVE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"xlp\", \"support for lines transparency and scalability\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SCALABLE_LINE, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"ic2d\", \"use indexed curve 2D hardcoded proto\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_USE_IC2D, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"same-app\", \"appearance nodes are reused\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_REUSE_APPEARANCE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"flatten\", \"complementary angle below which 2 lines are merged, value `0` means no flattening\", GF_ARG_DOUBLE, 0, &swf_flatten_angle, 0, 0),\n\t{0}\n};\n\nvoid PrintSWFUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# SWF Importer Options\\n\"\n\t        \"\\n\"\n\t        \"MP4Box can import simple Macromedia Flash files (\\\".SWF\\\")\\n\"\n\t        \"You can specify a SWF input file with \\'-bt\\', \\'-xmt\\' and \\'-mp4\\' options\\n\"\n\t        \"  \\n\"\n\t        \"Options:\\n\"\n\t);\n\twhile (m4b_swf_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_swf_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_liveenc_args[] =\n{\n \tMP4BOX_ARG(\"live\", \"enable live BIFS/LASeR encoder\", GF_ARG_BOOL, 0, &live_scene, 0, 0),\n \tGF_DEF_ARG(\"dst\", NULL, \"destination IP\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"port\", NULL, \"destination port\", \"7000\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"mtu\", NULL, \"path MTU for RTP packets\", \"1450\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"ifce\", NULL, \"IP address of the physical interface to use\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"ttl\", NULL, \"time to live for multicast packets\", \"1\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"sdp\", NULL, \"output SDP file\", \"session.sdp\", NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"dims\", NULL, \"turn on DIMS mode for SVG input\", NULL, NULL, GF_ARG_BOOL, 0),\n \tGF_DEF_ARG(\"no-rap\", NULL, \"disable RAP sending and carousel generation\", NULL, NULL, GF_ARG_BOOL, 0),\n \tGF_DEF_ARG(\"src\", NULL, \"source of scene updates\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"rap\", NULL, \"duration in ms of base carousel; you can specify the RAP period of a single ESID (not in DIMS) using `ESID=X:time`\", NULL, NULL, GF_ARG_INT, 0),\n \t{0}\n};\n\nvoid PrintLiveUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Live Scene Encoder Options\\n\"\n\t        \"The options shall be specified as \u00f2pt_name=opt_val.\\n\"\n\t        \"Options:\\n\"\n\t        \"\\n\"\n\t);\n\twhile (m4b_liveenc_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_liveenc_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n\n\tgf_sys_format_help(helpout, help_flags, \"  \\n\"\n\t\t\"Runtime options:\\n\"\n\t\t\"- q: quits\\n\"\n\t\t\"- u: inputs some commands to be sent\\n\"\n\t\t\"- U: same as u but signals the updates as critical\\n\"\n\t\t\"- e: inputs some commands to be sent without being aggregated\\n\"\n\t\t\"- E: same as e but signals the updates as critical\\n\"\n\t\t\"- f: forces RAP sending\\n\"\n\t\t\"- F: forces RAP regeneration and sending\\n\"\n\t\t\"- p: dumps current scene\\n\"\n\t);\n}\n\nvoid PrintCoreUsage()\n{\n\tgf_sys_format_help(helpout, help_flags, \"# libgpac core options\\n\");\n\tgf_sys_print_core_help(helpout, 0, GF_ARGMODE_ALL, 0);\n}\n\nvoid PrintTags()\n{\n\tu32 i = 0;\n\n\tgf_sys_format_help(helpout, help_flags, \"# Tagging support\\n\"\n\t\"Tags are specified as a colon-separated list `tag_name=tag_value[:tag2=val2]`\\n\"\n\t\"Setting a tag with no value or value `NULL` removes the tag.\\n\"\n\t\"Special tag value `clear` (or `reset`) removes all tags.\\n\"\n\t\"Unsupported tags can be added using their four character code as a tag name, and string value will be assumed.\\n\"\n\t\"If the tag name length is 3, the prefix 0xA9 is used to create the four character code.\\n\"\n\t\"  \\n\"\n\t\"Tags can also be loaded from a text file using `-itags filename`. The file must be in UTF8 with:\\n\"\n\t\"- lines starting with `tag_name=value` specify the start of a tag\\n\"\n\t\"- other lines specify the remainder of the last declared tag\\n\"\n\t\"  \\n\"\n\t\"If tag name starts with `WM/`, the tag is added to `Xtra` box (WMA tag, string only).\\n\"\n\t\"  \\n\"\n\t\"Supported tag names, values, types, aliases:\\n\"\n\t);\n\n\twhile (1) {\n\t\ts32 type = gf_itags_get_type(i);\n\t\tif (type<0) break;\n\t\tconst char *name = gf_itags_get_name(i);\n\t\tu32 itag = gf_itags_get_itag(i);\n\t\tgf_sys_format_help(helpout, help_flags | GF_PRINTARG_HIGHLIGHT_FIRST , \"%s\", name);\n\t\tgf_sys_format_help(helpout, help_flags, \" (%s) \", gf_4cc_to_str(itag) );\n\t\tswitch (type) {\n\t\tcase GF_ITAG_STR:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"string\"); break;\n\t\tcase GF_ITAG_INT8:\n\t\tcase GF_ITAG_INT16:\n\t\tcase GF_ITAG_INT32:\n\t\tcase GF_ITAG_INT64:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"integer\"); break;\n\t\tcase GF_ITAG_FRAC6:\n\t\tcase GF_ITAG_FRAC8:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"fraction (syntax: `A/B` or `A`, B will be 0)\"); break;\n\t\tcase GF_ITAG_BOOL:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"bool (`yes` or `no`)\"); break;\n\t\tcase GF_ITAG_ID3_GENRE:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"string (ID3 genre tag)\"); break;\n\t\tcase GF_ITAG_FILE:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"file path\"); break;\n\t\t}\n\t\tname = gf_itags_get_alt_name(i);\n\t\tif (name) {\n\t\t\tgf_sys_format_help(helpout, help_flags, \" (`alias` %s)\", name);\n\t\t}\n\n\t\tgf_sys_format_help(helpout, help_flags, \"\\n\");\n\t\ti++;\n\t}\n}\n\nvoid PrintCICP()\n{\n\tu32 i;\n\tgf_sys_format_help(helpout, help_flags, \"# Video CICP (ISO/IEC 23091-2) Constants\\n\");\n\tgf_sys_format_help(helpout, help_flags, \"CICP Color Primaries:\\n\");\n\tfor (i=0; i<GF_CICP_PRIM_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_primaries_name(i);\n\t\tif (!name || !strcmp(name, \"unknwon\")) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n\tgf_sys_format_help(helpout, help_flags, \"  \\nCICP Color Transfer Characteristics:\\n\");\n\tfor (i=0; i<GF_CICP_TRANSFER_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_transfer_name(i);\n\t\tif (!name) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n\tgf_sys_format_help(helpout, help_flags, \"  \\nCICP Color Matrix Coefficients:\\n\");\n\tfor (i=0; i<GF_CICP_MX_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_matrix_name(i);\n\t\tif (!name) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n}\n\nMP4BoxArg m4b_usage_args[] =\n{\n \tMP4BOX_ARG(\"h\", \"print help\\n\"\n \t\t\"- general: general options help\\n\"\n\t\t\"- hint: hinting options help\\n\"\n\t\t\"- dash: DASH segmenter help\\n\"\n\t\t\"- split: split options help\\n\"\n\t\t\"- import: import options help\\n\"\n\t\t\"- encode: scene descrription encoding options help\\n\"\n\t\t\"- meta: meta (HEIF, MPEG-21) handling options help\\n\"\n\t\t\"- extract: extraction options help\\n\"\n\t\t\"- dump: dump options help\\n\"\n\t\t\"- swf: Flash (SWF) options help\\n\"\n\t\t\"- crypt: ISMA E&A options help\\n\"\n\t\t\"- format: supported formats help\\n\"\n\t\t\"- live: BIFS streamer help\\n\"\n\t\t\"- core: libgpac core options\\n\"\n\t\t\"- all: print all the above help screens\\n\"\n\t\t\"- opts: print all options\\n\"\n\t\t\"- tags: print supported iTunes tags\\n\"\n\t\t\"- cicp: print various CICP code points\\n\"\n\t\t\"- VAL: search for option named `VAL` (without `-` or `--`) in MP4Box, libgpac core and all filters\\n\"\n\t\t, GF_ARG_STRING, 0, parse_help, 0, ARG_IS_FUN | ARG_EMPTY | ARG_PUSH_SYSARGS),\n \tMP4BOX_ARG(\"hx\", \"look for given string in all possible options\"\n\t\t, GF_ARG_STRING, 0, parse_help, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nodes\", \"list supported MPEG4 nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nodex\", \"list supported MPEG4 nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"node\", \"get given MPEG4 node syntax and QP infolist\", GF_ARG_STRING, 0, PrintNode, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnodes\", \"list supported X3D nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnodex\", \"list supported X3D nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnode\", \"get given X3D node syntax\", GF_ARG_STRING, 0, PrintNode, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"snodes\", \"list supported SVG nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"languages\", \"list supported ISO 639 languages\", GF_ARG_BOOL, 0, PrintLanguages, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"boxes\", \"list all supported ISOBMF boxes and their syntax\", GF_ARG_BOOL, 0, PrintBuiltInBoxes, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"boxcov\", \"perform coverage of box IO coode\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, PrintBuiltInBoxes, 1, ARG_IS_FUN|ARG_PUSH_SYSARGS),\n \tMP4BOX_ARG(\"fstat\", \"print filter session statistics (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 1, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"fgraph\", \"print filter session graph (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 2, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"v\", \"verbose mode\", GF_ARG_BOOL, 0, &verbose, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"version\", \"get build version\", GF_ARG_BOOL, 0, print_version, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"genmd\", \"generate MD doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"genman\", \"generate man doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 1, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"--\", \"INPUT\", \"escape option if INPUT starts with `-` character\", 0, NULL, 0, 0),\n \t{0}\n};\n\nvoid PrintUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option]\\n\"\n\t\t\"  \\n\"\n\t\t\"# General Options:\\n\"\n\t);\n\twhile (m4b_usage_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_usage_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-general\");\n\t}\n}\n\n/*\n * \t\tEND OF ARGS PARSING AND HELP\n */\n\n\nenum\n{\n\tSEARCH_ARG_EXACT,\n\tSEARCH_ARG_CLOSE,\n\tSEARCH_DESC,\n};\n\nstatic Bool strstr_nocase(const char *text, const char *subtext, u32 subtext_len)\n{\n\tif (!*text || !subtext || !subtext_len)\n\t\treturn GF_FALSE;\n\n\twhile (*text) {\n\t\tif (tolower(*text) == *subtext) {\n\t\t\tif (!strnicmp(text, subtext, subtext_len))\n\t\t\t\treturn GF_TRUE;\n\n\t\t}\n\t\ttext++;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic u32 PrintHelpForArgs(char *arg_name, MP4BoxArg *args, GF_GPACArg *_args, u32 search_type)\n{\n\tu32 res=0;\n\tu32 i=0;\n\tu32 alen = (u32) strlen(arg_name);\n\n\twhile (1) {\n\t\tu32 flags=0;\n\t\tGF_GPACArg *arg;\n\t\tGF_GPACArg an_arg;\n\t\tBool do_match = GF_FALSE;\n\t\tif (args) {\n\t\t\tif (!args[i].name)\n\t\t\t\tbreak;\n\t\t\targ = (GF_GPACArg *) &args[i];\n\t\t} else {\n\t\t\tif (!_args[i].name)\n\t\t\t\tbreak;\n\t\t\targ = &_args[i];\n\t\t}\n\n\t\tif (args == m4b_imp_fileopt_args) {\n\t\t\tflags = GF_PRINTARG_COLON;\n\t\t\tif (!strncmp(arg_name, arg->name, alen) && ((arg->name[alen]==0) || (arg->name[alen]=='=')))\n\t\t\t\tdo_match = GF_TRUE;\n\t\t}\n\t\telse if (!strcmp(arg_name, arg->name))\n\t\t\tdo_match = GF_TRUE;\n\t\telse if ((alen < (u32) strlen(arg->name)) && (arg->name[alen]==' ') && !strncmp(arg_name, arg->name, alen))\n\t\t\tdo_match = GF_TRUE;\n\n\t\tif (arg_name[0] == '@')\n\t\t\tdo_match = GF_TRUE;\n\n\t\tif ((search_type==SEARCH_ARG_EXACT) && !do_match) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((search_type==SEARCH_ARG_CLOSE) && !gf_sys_word_match(arg_name, arg->name)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((search_type==SEARCH_DESC) && !strstr_nocase(arg->description, arg_name, alen)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tan_arg = *arg;\n\t\tif (search_type!=SEARCH_ARG_EXACT) {\n\t\t\tan_arg.description = NULL;\n\t\t\tan_arg.type = GF_ARG_BOOL;\n\t\t}\n\t\tgf_sys_print_arg(helpout, flags, (GF_GPACArg *) &an_arg, \"\");\n\t\tres++;\n\t\ti++;\n\t}\n\treturn res;\n}\nstatic Bool PrintHelpArg(char *arg_name, u32 search_type, GF_FilterSession *fs)\n{\n\tBool first=GF_TRUE;\n\tGF_GPACArg an_arg;\n\tu32 i, count;\n\tu32 res = 0;\n\tu32 alen = (u32) strlen(arg_name);\n\tres += PrintHelpForArgs(arg_name, m4b_gen_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_split_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_dash_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_imp_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_imp_fileopt_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_senc_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_crypt_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_hint_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_extr_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_dump_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_meta_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_swf_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_liveenc_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_usage_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, NULL, (GF_GPACArg *) gf_sys_get_options(), search_type);\n\n\tif (!fs) return res;\n\n\tmemset(&an_arg, 0, sizeof(GF_GPACArg));\n\tcount = gf_fs_filters_registers_count(fs);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j=0;\n\t\tconst GF_FilterRegister *reg = gf_fs_get_filter_register(fs, i);\n\n\t\twhile (reg->args) {\n\t\t\tu32 len;\n\t\t\tconst GF_FilterArgs *arg = &reg->args[j];\n\t\t\tif (!arg || !arg->arg_name) break;\n\t\t\tj++;\n\t\t\tif ((search_type==SEARCH_ARG_EXACT) && strcmp(arg->arg_name, arg_name)) continue;\n\n\t\t\tif ((search_type==SEARCH_ARG_CLOSE) && !gf_sys_word_match(arg->arg_name, arg_name)) continue;\n\n\t\t\tif (search_type==SEARCH_DESC) {\n\t\t\t\tif (!strstr_nocase(arg->arg_desc, arg_name, alen)) continue;\n\t\t\t}\n\n\t\t\tan_arg.name = arg->arg_name;\n\t\t\tif (search_type==SEARCH_ARG_EXACT) {\n\t\t\t\tan_arg.description = arg->arg_desc;\n\t\t\t\tswitch (arg->arg_type) {\n\t\t\t\tcase GF_PROP_BOOL:\n\t\t\t\t\tan_arg.type = GF_ARG_BOOL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_UINT:\n\t\t\t\tcase GF_PROP_SINT:\n\t\t\t\t\tan_arg.type = GF_ARG_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_DOUBLE:\n\t\t\t\t\tan_arg.type = GF_ARG_DOUBLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\tcase GF_PROP_UINT_LIST:\n\t\t\t\tcase GF_PROP_SINT_LIST:\n\t\t\t\tcase GF_PROP_VEC2I_LIST:\n\t\t\t\t\tan_arg.type = GF_ARG_STRINGS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_4CC:\n\t\t\t\t\tan_arg.type = GF_ARG_4CC;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_4CC_LIST:\n\t\t\t\t\tan_arg.type = GF_ARG_4CCS;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tan_arg.type = GF_ARG_STRING;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t\tgf_sys_format_help(helpout, 0, \"\\nGlobal filter session arguments. Syntax is `--arg` or `--arg=VAL`. `[F]` indicates filter name. See `gpac -h` and `gpac -h F` for more info.\\n\");\n\t\t\t\t}\n\t\t\t\tfprintf(helpout, \"[%s]\", reg->name);\n\t\t\t\tlen = (u32)strlen(reg->name);\n\t\t\t\twhile (len<10) {\n\t\t\t\t\tlen++;\n\t\t\t\t\tfprintf(helpout, \" \");\n\t\t\t\t}\n\t\t\t\tfprintf(helpout, \" \");\n\t\t\t}\n\n\t\t\tgf_sys_print_arg(helpout, GF_PRINTARG_ADD_DASH, &an_arg, \"TEST\");\n\t\t\tres++;\n\t\t}\n\t}\n\tif (res) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic void PrintHelp(char *arg_name, Bool search_desc, Bool no_match)\n{\n\tGF_FilterSession *fs;\n\tBool res;\n\n\tfs = gf_fs_new_defaults(0);\n\n\tif (arg_name[0]=='-')\n\t\targ_name++;\n\n\tif (search_desc) {\n\t\tchar *_arg_name = gf_strdup(arg_name);\n\t\tstrlwr(_arg_name);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Possible options mentionning `%s`:\\n\", arg_name));\n\t\tPrintHelpArg(_arg_name, SEARCH_DESC, fs);\n\t\tgf_free(_arg_name);\n\t} else {\n\t\tres = no_match ? GF_FALSE : PrintHelpArg(arg_name, SEARCH_ARG_EXACT, fs);\n\t\tif (!res) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Option -%s unknown, please check usage.\\n\", arg_name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Possible options are:\\n\"));\n\n\t\t\tPrintHelpArg(arg_name, SEARCH_ARG_CLOSE, fs);\n\t\t}\n\t}\n\tif (fs)\n\t\tgf_fs_del(fs);\n}\n\n\nu32 parse_sdp_ext(char *arg_val, u32 param)\n{\n\tchar *id;\n\tsdp_lines = gf_realloc(sdp_lines, sizeof(SDPLine) * (nb_sdp_ex + 1));\n\tif (!sdp_lines) return 2;\n\tid = strchr(arg_val, ':');\n\tif (id) {\n\t\tid[0] = 0;\n\t\tif (sscanf(arg_val, \"%u\", &sdp_lines[0].trackID) == 1) {\n\t\t\tid[0] = ':';\n\t\t\tsdp_lines[nb_sdp_ex].line = id + 1;\n\t\t}\n\t\telse {\n\t\t\tid[0] = ':';\n\t\t\tsdp_lines[nb_sdp_ex].line = arg_val;\n\t\t\tsdp_lines[nb_sdp_ex].trackID = 0;\n\t\t}\n\t}\n\telse {\n\t\tsdp_lines[nb_sdp_ex].line = arg_val;\n\t\tsdp_lines[nb_sdp_ex].trackID = 0;\n\t}\n\topen_edit = GF_TRUE;\n\tnb_sdp_ex++;\n\treturn GF_FALSE;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 parse_meta_args(char *opts, MetaActionType act_type)\n{\n\tMetaAction *meta;\n\n\tmetas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));\n\tif (!metas) return 2;\n\tmeta = &metas[nb_meta_act];\n\tnb_meta_act ++;\n\n\tmemset(meta, 0, sizeof(MetaAction));\n\tmeta->act_type = act_type;\n\tmeta->trackID = 0;\n\tmeta->root_meta = 1;\n\topen_edit = GF_TRUE;\n\n\tif (!opts) return 2;\n\n\tif (act_type == META_ACTION_ADD_IMAGE_ITEM)\n\t\thas_add_image = GF_TRUE;\n\n\twhile (1) {\n\t\tchar *next;\n\t\tchar *szSlot;\n\t\tif (!opts || !opts[0]) return 0;\n\t\tif (opts[0]==':') opts += 1;\n\n\t\tszSlot = opts;\n\t\tnext = gf_url_colon_suffix(opts);\n\t\tif (next) next[0] = 0;\n\n\t\tif (!strnicmp(szSlot, \"tk=\", 3)) {\n\t\t\tsscanf(szSlot, \"tk=%u\", &meta->trackID);\n\t\t\tmeta->root_meta = 0;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"id=\", 3)) {\n\t\t\tmeta->item_id = atoi(szSlot+3);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"type=\", 5)) {\n\t\t\tmeta->item_type = GF_4CC(szSlot[5], szSlot[6], szSlot[7], szSlot[8]);\n\t\t}\n\t\t//\"ref\" (without '=') is for data reference, \"ref=\" is for item references\n\t\telse if (!strnicmp(szSlot, \"ref=\", 4)) {\n\t\t\tchar type[5];\n\t\t\tMetaRef\t*ref;\n\t\t\tif (!meta->item_refs) {\n\t\t\t\tmeta->item_refs = gf_list_new();\n\t\t\t\tif (!meta->item_refs) return 2;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(ref, MetaRef);\n\t\t\tif (!ref) return 2;\n\t\t\tsscanf(szSlot, \"ref=%4s,%u\", type, &(ref->ref_item_id));\n\t\t\tref->ref_type = GF_4CC(type[0], type[1], type[2], type[3]);\n\t\t\tgf_list_add(meta->item_refs, ref);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"name=\", 5)) {\n\t\t\tmeta->szName = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"path=\", 5)) {\n\t\t\tmeta->szPath = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"mime=\", 5)) {\n\t\t\tmeta->item_type = GF_META_ITEM_TYPE_MIME;\n\t\t\tmeta->mime_type = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"encoding=\", 9)) {\n\t\t\tmeta->enc_type = gf_strdup(szSlot+9);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-size=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->width, &meta->image_props->height);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-grid-size=\", 16)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t}\n\t\t\tsscanf(szSlot+16, \"%dx%d\", &meta->image_props->num_grid_rows, &meta->image_props->num_grid_columns);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-pasp=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->hSpacing, &meta->image_props->vSpacing);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-rloc=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->hOffset, &meta->image_props->vOffset);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"rotation=\", 9)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->angle = atoi(szSlot+9);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"mirror-axis=\", 12)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->mirror = (!strnicmp(szSlot+12, \"vertical\", 8) ? 1 : 2);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"clap=\", 5)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot + 5, \"%d,%d,%d,%d,%d,%d,%d,%d\", &meta->image_props->clap_wnum, &meta->image_props->clap_wden,\n\t\t\t\t\t   &meta->image_props->clap_hnum, &meta->image_props->clap_hden,\n\t\t\t\t\t   &meta->image_props->clap_honum, &meta->image_props->clap_hoden,\n\t\t\t\t\t   &meta->image_props->clap_vonum, &meta->image_props->clap_voden);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"hidden\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->hidden = GF_TRUE;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"alpha\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->alpha = GF_TRUE;\n\t\t}\n\t\t//\"ref\" (without '=') is for data reference, \"ref=\" is for item references\n\t\telse if (!stricmp(szSlot, \"ref\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->use_reference = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"time=\", 5)) {\n\t\t\tFloat s=0, e=0, step=0;\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tif (sscanf(szSlot+5, \"%f-%f/%f\", &s, &e, &step)==3) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->end_time = e;\n\t\t\t\tmeta->image_props->step_time = step;\n\t\t\t} else if (sscanf(szSlot+5, \"%f-%f\", &s, &e)==2) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->end_time = e;\n\t\t\t} else if (sscanf(szSlot+5, \"%f/%f\", &s, &step)==2) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->step_time = step;\n\t\t\t} else if (sscanf(szSlot+5, \"%f\", &s)==1) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"samp=\", 5)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->sample_num = atoi(szSlot+5);\n\t\t\tmeta->root_meta = 1;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"group=\", 6)) {\n\t\t\tchar type[5];\n\t\t\tsscanf(szSlot, \"group=%4s,%u\", type, &meta->group_id);\n\t\t\tmeta->group_type = GF_4CC(type[0], type[1], type[2], type[3]);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"split_tiles\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->tile_mode = TILE_ITEM_ALL_BASE;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"dref\")) {\n\t\t\tmeta->use_dref = 1;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"primary\")) {\n\t\t\tmeta->primary = 1;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"binary\")) {\n\t\t\tif (meta->act_type==META_ACTION_SET_XML) meta->act_type=META_ACTION_SET_BINARY_XML;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"icc_path=\", 9)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tstrcpy(meta->image_props->iccPath, szSlot+9);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"agrid\") || !strnicmp(szSlot, \"agrid=\", 6)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->auto_grid = GF_TRUE;\n\t\t\tif (!strnicmp(szSlot, \"agrid=\", 6))\n\t\t\t\tmeta->image_props->auto_grid_ratio = atof(szSlot+6);\n\t\t}\n\t\telse if (!strchr(szSlot, '=')) {\n\t\t\tswitch (meta->act_type) {\n\t\t\tcase META_ACTION_SET_TYPE:\n\t\t\t\tif (!stricmp(szSlot, \"null\") || !stricmp(szSlot, \"0\")) meta->meta_4cc = 0;\n\t\t\t\telse meta->meta_4cc = GF_4CC(szSlot[0], szSlot[1], szSlot[2], szSlot[3]);\n\t\t\t\tbreak;\n\t\t\tcase META_ACTION_ADD_ITEM:\n\t\t\tcase META_ACTION_ADD_IMAGE_ITEM:\n\t\t\tcase META_ACTION_SET_XML:\n\t\t\tcase META_ACTION_DUMP_XML:\n\t\t\t\tif (!strncmp(szSlot, \"dopt\", 4) || !strncmp(szSlot, \"sopt\", 4) || !strncmp(szSlot, \"@\", 1)) {\n\t\t\t\t\tif (next) next[0]=':';\n\t\t\t\t\tnext=NULL;\n\t\t\t\t}\n\t\t\t\t//cat as -add arg\n\t\t\t\tgf_dynstrcat(&meta->szPath, szSlot, \":\");\n\t\t\t\tif (!meta->szPath) return 2;\n\t\t\t\tbreak;\n\t\t\tcase META_ACTION_REM_ITEM:\n\t\t\tcase META_ACTION_SET_PRIMARY_ITEM:\n\t\t\tcase META_ACTION_DUMP_ITEM:\n\t\t\t\tmeta->item_id = atoi(szSlot);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!next) break;\n\t\topts += strlen(szSlot);\n\t\tnext[0] = ':';\n\t}\n\treturn 0;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic Bool parse_tsel_args(char *opts, TSELActionType act)\n{\n\tGF_ISOTrackID refTrackID = 0;\n\tBool has_switch_id;\n\tu32 switch_id = 0;\n\tu32 criteria[30];\n\tu32 nb_criteria = 0;\n\tTSELAction *tsel_act;\n\tchar szSlot[1024];\n\n\thas_switch_id = 0;\n\n\tif (!opts) return 0;\n\twhile (1) {\n\t\tchar *next;\n\t\tif (!opts || !opts[0]) return 0;\n\t\tif (opts[0]==':') opts += 1;\n\t\tstrcpy(szSlot, opts);\n\t\tnext = gf_url_colon_suffix(szSlot);\n\t\tif (next) next[0] = 0;\n\n\n\t\tif (!strnicmp(szSlot, \"refTrack=\", 9)) refTrackID = atoi(szSlot+9);\n\t\telse if (!strnicmp(szSlot, \"switchID=\", 9)) {\n\t\t\tif (atoi(szSlot+9)<0) {\n\t\t\t\tswitch_id = 0;\n\t\t\t\thas_switch_id = 0;\n\t\t\t} else {\n\t\t\t\tswitch_id = atoi(szSlot+9);\n\t\t\t\thas_switch_id = 1;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"switchID\", 8)) {\n\t\t\tswitch_id = 0;\n\t\t\thas_switch_id = 1;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"criteria=\", 9)) {\n\t\t\tu32 j=9;\n\t\t\tnb_criteria = 0;\n\t\t\twhile (j+3<strlen(szSlot)) {\n\t\t\t\tcriteria[nb_criteria] = GF_4CC(szSlot[j], szSlot[j+1], szSlot[j+2], szSlot[j+3]);\n\t\t\t\tj+=5;\n\t\t\t\tnb_criteria++;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"trackID=\", 8) || !strchr(szSlot, '=') ) {\n\t\t\ttsel_acts = gf_realloc(tsel_acts, sizeof(TSELAction) * (nb_tsel_acts + 1));\n\t\t\tif (!tsel_acts) return 2;\n\n\t\t\ttsel_act = &tsel_acts[nb_tsel_acts];\n\t\t\tnb_tsel_acts++;\n\n\t\t\tmemset(tsel_act, 0, sizeof(TSELAction));\n\t\t\ttsel_act->act_type = act;\n\t\t\ttsel_act->trackID = strchr(szSlot, '=') ? atoi(szSlot+8) : atoi(szSlot);\n\t\t\ttsel_act->refTrackID = refTrackID;\n\t\t\ttsel_act->switchGroupID = switch_id;\n\t\t\ttsel_act->is_switchGroup = has_switch_id;\n\t\t\ttsel_act->nb_criteria = nb_criteria;\n\t\t\tmemcpy(tsel_act->criteria, criteria, sizeof(u32)*nb_criteria);\n\n\t\t\tif (!refTrackID)\n\t\t\t\trefTrackID = tsel_act->trackID;\n\n\t\t\topen_edit = GF_TRUE;\n\t\t}\n\t\topts += strlen(szSlot);\n\t}\n\treturn 0;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\nGF_DashSegmenterInput *set_dash_input(GF_DashSegmenterInput *dash_inputs, char *name, u32 *nb_dash_inputs)\n{\n\tGF_DashSegmenterInput *di;\n\tBool skip_rep_id = GF_FALSE;\n\tchar *other_opts = NULL;\n\tchar *sep = gf_url_colon_suffix(name);\n\n\tdash_inputs = gf_realloc(dash_inputs, sizeof(GF_DashSegmenterInput) * (*nb_dash_inputs + 1) );\n\tmemset(&dash_inputs[*nb_dash_inputs], 0, sizeof(GF_DashSegmenterInput) );\n\tdi = &dash_inputs[*nb_dash_inputs];\n\t(*nb_dash_inputs)++;\n\n\tif (sep) {\n\t\tchar *opts, *first_opt;\n\t\tfirst_opt = sep;\n\t\topts = sep+1;\n\t\twhile (opts) {\n\t\t\tsep = gf_url_colon_suffix(opts);\n\t\t\tif (sep && !strncmp(sep, \"://\", 3) && strncmp(sep, \":@\", 2)) sep = gf_url_colon_suffix(sep+3);\n\t\t\tif (sep) sep[0] = 0;\n\n\t\t\tif (!strnicmp(opts, \"id=\", 3)) {\n\t\t\t\tif (!stricmp(opts+3, \"NULL\"))\n\t\t\t\t\tskip_rep_id = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tdi->representationID = gf_strdup(opts+3);\n\t\t\t\t/*we allow the same repID to be set to force muxed representations*/\n\t\t\t}\n\t\t\telse if (!strnicmp(opts, \"dur=\", 4)) di->media_duration = (Double)atof(opts+4);\n\t\t\telse if (!strnicmp(opts, \"period=\", 7)) di->periodID = gf_strdup(opts+7);\n\t\t\telse if (!strnicmp(opts, \"BaseURL=\", 8)) {\n\t\t\t\tdi->baseURL = (char **)gf_realloc(di->baseURL, (di->nb_baseURL+1)*sizeof(char *));\n\t\t\t\tdi->baseURL[di->nb_baseURL] = gf_strdup(opts+8);\n\t\t\t\tdi->nb_baseURL++;\n\t\t\t} else if (!strnicmp(opts, \"bandwidth=\", 10)) di->bandwidth = atoi(opts+10);\n\t\t\telse if (!strnicmp(opts, \"role=\", 5)) {\n\t\t\t\tdi->roles = gf_realloc(di->roles, sizeof (char *) * (di->nb_roles+1));\n\t\t\t\tdi->roles[di->nb_roles] = gf_strdup(opts+5);\n\t\t\t\tdi->nb_roles++;\n\t\t\t} else if (!strnicmp(opts, \"desc\", 4)) {\n\t\t\t\tu32 *nb_descs=NULL;\n\t\t\t\tchar ***descs=NULL;\n\t\t\t\tu32 opt_offset=0;\n\t\t\t\tu32 len;\n\t\t\t\tif (!strnicmp(opts, \"desc_p=\", 7)) {\n\t\t\t\t\tnb_descs = &di->nb_p_descs;\n\t\t\t\t\tdescs = &di->p_descs;\n\t\t\t\t\topt_offset = 7;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_as=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_as_descs;\n\t\t\t\t\tdescs = &di->as_descs;\n\t\t\t\t\topt_offset = 8;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_as_c=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_as_c_descs;\n\t\t\t\t\tdescs = &di->as_c_descs;\n\t\t\t\t\topt_offset = 10;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_rep=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_rep_descs;\n\t\t\t\t\tdescs = &di->rep_descs;\n\t\t\t\t\topt_offset = 9;\n\t\t\t\t}\n\t\t\t\tif (opt_offset) {\n\t\t\t\t\t(*nb_descs)++;\n\t\t\t\t\topts += opt_offset;\n\t\t\t\t\tlen = (u32) strlen(opts);\n\t\t\t\t\t(*descs) = (char **)gf_realloc((*descs), (*nb_descs)*sizeof(char *));\n\t\t\t\t\t(*descs)[(*nb_descs)-1] = (char *)gf_malloc((len+1)*sizeof(char));\n\t\t\t\t\tmemcpy((*descs)[(*nb_descs)-1], opts, len);\n\t\t\t\t\t(*descs)[(*nb_descs)-1][len] = 0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (!strnicmp(opts, \"xlink=\", 6)) di->xlink = gf_strdup(opts+6);\n\t\t\telse if (!strnicmp(opts, \"sscale\", 6)) di->sscale = GF_TRUE;\n\t\t\telse if (!strnicmp(opts, \"pdur=\", 5)) di->period_duration = (Double) atof(opts+5);\n\t\t\telse if (!strnicmp(opts, \"period_duration=\", 16)) di->period_duration = (Double) atof(opts+16);\n\t\t\telse if (!strnicmp(opts, \"duration=\", 9)) di->dash_duration = (Double) atof(opts+9);\n\t\t\telse if (!strnicmp(opts, \"asID=\", 5)) di->asID = atoi(opts+5);\n\t\t\telse if (!strnicmp(opts, \"sn=\", 3)) di->startNumber = atoi(opts+3);\n\t\t\telse if (!strnicmp(opts, \"tpl=\", 4)) di->seg_template = gf_strdup(opts+4);\n\t\t\telse if (!strnicmp(opts, \"hls=\", 4)) di->hls_pl = gf_strdup(opts+4);\n\t\t\telse if (!strnicmp(opts, \"trackID=\", 8)) di->track_id = atoi(opts+8);\n\t\t\telse if (!strnicmp(opts, \"@\", 1)) {\n\t\t\t\tBool old_syntax = (opts[1]=='@') ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (sep) sep[0] = ':';\n\t\t\t\tdi->filter_chain = gf_strdup(opts + (old_syntax ? 2 : 1) );\n\t\t\t\tsep = NULL;\n\t\t\t\tif (!old_syntax && (strstr(di->filter_chain, \"@@\")!=NULL)) {\n\t\t\t\t\tskip_rep_id = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_dynstrcat(&other_opts, opts, \":\");\n\t\t\t}\n\n\t\t\tif (!sep) break;\n\t\t\tsep[0] = ':';\n\t\t\topts = sep+1;\n\t\t}\n\t\tfirst_opt[0] = '\\0';\n\t}\n\tdi->file_name = name;\n\tdi->source_opts = other_opts;\n\n\tif (!skip_rep_id && !di->representationID) {\n\t\tchar szRep[100];\n\t\tsprintf(szRep, \"%d\", *nb_dash_inputs);\n\t\tdi->representationID = gf_strdup(szRep);\n\t}\n\n\treturn dash_inputs;\n}\n\nstatic Bool create_new_track_action(char *arg_val, u32 act_type, u32 dump_type)\n{\n\tTrackAction *tka;\n\tchar *param = arg_val;\n\ttracks = (TrackAction *)gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act+1));\n\tif (!tracks) return GF_FALSE;\n\n\ttka = & tracks[nb_track_act];\n\tnb_track_act++;\n\n\tmemset(tka, 0, sizeof(TrackAction) );\n\ttka->act_type = act_type;\n\ttka->dump_type = dump_type;\n\tif (act_type != TRAC_ACTION_RAW_EXTRACT) {\n\t\topen_edit = GF_TRUE;\n\t\tdo_save = GF_TRUE;\n\t}\n\n\tif ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) {\n\t\tif (sscanf(param, \"%d:%u\", &tka->trackID, &tka->newTrackID) != 2) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_PAR) {\n\t\tchar *ext;\n\t\text = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\n\t\tif (!stricmp(ext+1, \"none\"))\n\t\t\ttka->par_num = tka->par_den = 0;\n\t\telse if (!stricmp(ext+1, \"auto\")) {\n\t\t\ttka->par_num = tka->par_den = -1;\n\t\t\ttka->force_par = 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, \"force\")) {\n\t\t\ttka->par_num = tka->par_den = 1;\n\t\t\ttka->force_par = 1;\n\t\t}\n\t\telse {\n\t\t\tif (ext[1]=='w') {\n\t\t\t\ttka->rewrite_bs = 1;\n\t\t\t\text++;\n\t\t\t}\n\t\t\tif (sscanf(ext+1, \"%d:%d\", &tka->par_num, &tka->par_den) != 2) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_CLAP) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (stricmp(ext + 1, \"none\")) {\n\t\t\tif (sscanf(ext + 1, \"%d,%d,%d,%d,%d,%d,%d,%d\", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {\n\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (act_type==TRAC_ACTION_SET_MX) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (!stricmp(ext + 1, \"none\")) {\n\t\t\tmemset(tka->mx, 0, sizeof(s32)*9);\n\t\t\ttka->mx[0] = tka->mx[4] = tka->mx[8] = 1;\n\t\t} else {\n\t\t\ts32 res;\n\t\t\tif (strstr(ext+1, \"0x\")) {\n\t\t\t\tres = sscanf(ext + 1, \"0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);\n\t\t\t} else {\n\t\t\t\tres = sscanf(ext + 1, \"%d:%d:%d:%d:%d:%d:%d:%d:%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);\n\t\t\t}\n\t\t\tif (res != 9) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_EDITS) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track edits - expecting ID=EDITS got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\ttka->string = gf_strdup(ext+1);\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_LANGUAGE) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\tstrncpy(tka->lang, param + 4, 10-1);\n\t\t}\n\t\telse if (!ext) {\n\t\t\tstrncpy(tka->lang, param, 10-1);\n\t\t} else {\n\t\t\tstrncpy(tka->lang, ext + 1, 10-1);\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(param);\n\t\t\text[0] = '=';\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif ((act_type==TRAC_ACTION_SET_KIND) || (act_type==TRAC_ACTION_REM_KIND)) {\n\t\tchar *ext;\n\t\tchar *scheme_start = NULL;\n\n\t\t//extract trackID\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\tscheme_start = param + 4;\n\t\t} else {\n\t\t\text = strchr(param, '=');\n\t\t\tif (ext) {\n\t\t\t\text[0] = 0;\n\t\t\t\tif (sscanf(param, \"%d\", &tka->trackID) == 1) {\n\t\t\t\t\tscheme_start = ext + 1;\n\t\t\t\t} else {\n\t\t\t\t\tscheme_start = param;\n\t\t\t\t}\n\t\t\t\text[0] = '=';\n\t\t\t} else {\n\t\t\t\tscheme_start = param;\n\t\t\t}\n\t\t}\n\n\t\t//extract scheme and value - if not, remove kind\n\t\tif (!scheme_start || !scheme_start[0]) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing kind scheme - expecting ID=schemeURI=value got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t} else {\n\t\t\text = strchr(scheme_start, '=');\n\t\t\tif (!ext) {\n\t\t\t\ttka->kind_scheme = gf_strdup(scheme_start);\n\t\t\t} else {\n\t\t\t\text[0] = 0;\n\t\t\t\ttka->kind_scheme = gf_strdup(scheme_start);\n\t\t\t\text[0] = '=';\n\t\t\t\ttka->kind_value = gf_strdup(ext + 1);\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_DELAY) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (sscanf(ext+1, \"%d/%u\", &tka->delay.num, &tka->delay.den) != 2) {\n\t\t\ttka->delay.num = atoi(ext + 1);\n\t\t\ttka->delay.den = 1000;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_REFERENCE) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) ext = strchr(param, ':');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\n\t\tchar *ext2 = strchr(ext, ':');\n\t\tif (!ext2) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text2[0] = 0;\n\t\tstrncpy(tka->lang, ext+1, 9);\n\t\text2[0] = ':';\n\t\ttka->newTrackID = (s32) atoi(ext2 + 1);\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_HANDLER_NAME) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track name - expecting tkID=name got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\ttka->hdl_name = ext + 1;\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_KMS_URI) {\n\t\tchar *ext = strchr(param, '=');\n\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\ttka->kms = param + 4;\n\t\t} else if (!ext) {\n\t\t\ttka->kms = param;\n\t\t} else {\n\t\t\ttka->kms = ext + 1;\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(param);\n\t\t\text[0] = '=';\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif ((act_type==TRAC_ACTION_SET_TIME) || (act_type==TRAC_ACTION_SET_MEDIA_TIME)) {\n\t\tstruct tm time;\n\t\tchar *ext = strchr(arg_val, '=');\n\t\tif (ext) {\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(arg_val);\n\t\t\text[0] = '=';\n\t\t\targ_val = ext+1;\n\t\t}\n\t\tmemset(&time, 0, sizeof(struct tm));\n\t\tsscanf(arg_val, \"%d/%d/%d-%d:%d:%d\", &time.tm_mday, &time.tm_mon, &time.tm_year, &time.tm_hour, &time.tm_min, &time.tm_sec);\n\t\ttime.tm_isdst = 0;\n\t\ttime.tm_year -= 1900;\n\t\ttime.tm_mon -= 1;\n\t\ttka->time = 2082758400;\n\t\ttka->time += mktime(&time);\n\t\treturn GF_TRUE;\n\t}\n\n\twhile (param) {\n\t\tparam = gf_url_colon_suffix(param);\n\t\tif (param) {\n\t\t\t*param = 0;\n\t\t\tparam++;\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\t\t\tif (!strncmp(\"vttnomerge\", param, 10)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_WEBVTT_NOMERGE;\n\t\t\t} else if (!strncmp(\"layer\", param, 5)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_SVC_LAYER;\n\t\t\t} else if (!strncmp(\"full\", param, 4)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_NHML_FULL;\n\t\t\t} else if (!strncmp(\"embedded\", param, 8)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_WEBVTT_META_EMBEDDED;\n\t\t\t} else if (!strncmp(\"output=\", param, 7)) {\n\t\t\t\ttka->out_name = gf_strdup(param+7);\n\t\t\t} else if (!strncmp(\"src=\", param, 4)) {\n\t\t\t\ttka->src_name = gf_strdup(param+4);\n\t\t\t} else if (!strncmp(\"str=\", param, 4)) {\n\t\t\t\ttka->string = gf_strdup(param+4);\n\t\t\t} else if (!strncmp(\"box=\", param, 4)) {\n\t\t\t\ttka->src_name = gf_strdup(param+4);\n\t\t\t\ttka->sample_num = 1;\n\t\t\t} else if (!strncmp(\"type=\", param, 4)) {\n\t\t\t\ttka->udta_type = GF_4CC(param[5], param[6], param[7], param[8]);\n\t\t\t} else if (tka->dump_type == GF_EXPORT_RAW_SAMPLES) {\n\t\t\t\ttka->sample_num = atoi(param);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\tif (arg_val) {\n\t\tif (!strcmp(arg_val, \"*\")) {\n\t\t\ttka->trackID = (u32) -1;\n\t\t} else {\n\t\t\tif (act_type==TRAC_ACTION_RAW_EXTRACT) {\n\t\t\t\tif (!strncmp(arg_val, \"video\", 5)) {\n\t\t\t\t\targ_val += 5;\n\t\t\t\t\ttka->dump_track_type = 1;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(arg_val, \"audio\", 5)) {\n\t\t\t\t\targ_val += 5;\n\t\t\t\t\ttka->dump_track_type = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (arg_val[0])\n\t\t\t\ttka->trackID = atoi(arg_val);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nu32 parse_track_dump(char *arg, u32 dump_type)\n{\n\tif (!create_new_track_action(arg, TRAC_ACTION_RAW_EXTRACT, dump_type))\n\t\treturn 2;\n\ttrack_dump_type = dump_type;\n\treturn 0;\n}\nu32 parse_track_action(char *arg, u32 act_type)\n{\n\tif (!create_new_track_action(arg, act_type, 0)) {\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_comp_box(char *arg_val, u32 opt)\n{\n\tcompress_top_boxes = arg_val;\n\tsize_top_box = opt;\n\treturn 0;\n}\nu32 parse_dnal(char *arg_val, u32 opt)\n{\n\tdump_nal = atoi(arg_val);\n\tdump_nal_type = opt;\n\treturn 0;\n}\nu32 parse_dsap(char *arg_val, u32 opt)\n{\n\tdump_saps = atoi(arg_val);\n\tdump_saps_mode = opt;\n\treturn 0;\n}\n\nu32 parse_bs_switch(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"no\") || !stricmp(arg_val, \"off\")) bitstream_switching_mode = GF_DASH_BSMODE_NONE;\n\telse if (!stricmp(arg_val, \"merge\"))  bitstream_switching_mode = GF_DASH_BSMODE_MERGED;\n\telse if (!stricmp(arg_val, \"multi\"))  bitstream_switching_mode = GF_DASH_BSMODE_MULTIPLE_ENTRIES;\n\telse if (!stricmp(arg_val, \"single\"))  bitstream_switching_mode = GF_DASH_BSMODE_SINGLE;\n\telse if (!stricmp(arg_val, \"inband\"))  bitstream_switching_mode = GF_DASH_BSMODE_INBAND;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized bitstream switching mode \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_cp_loc(char *arg_val, u32 opt)\n{\n\tif (!strcmp(arg_val, \"both\")) cp_location_mode = GF_DASH_CPMODE_BOTH;\n\telse if (!strcmp(arg_val, \"as\")) cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;\n\telse if (!strcmp(arg_val, \"rep\")) cp_location_mode = GF_DASH_CPMODE_REPRESENTATION;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_pssh(char *arg_val, u32 opt)\n{\n\tif (!strcmp(arg_val, \"f\")) pssh_mode = GF_DASH_PSSH_MOOF;\n\telse if (!strcmp(arg_val, \"v\")) pssh_mode = GF_DASH_PSSH_MOOV;\n\telse if (!strcmp(arg_val, \"m\")) pssh_mode = GF_DASH_PSSH_MPD;\n\telse if (!strcmp(arg_val, \"mf\") || !strcmp(arg_val, \"fm\")) pssh_mode = GF_DASH_PSSH_MOOF_MPD;\n\telse if (!strcmp(arg_val, \"mv\") || !strcmp(arg_val, \"vm\")) pssh_mode = GF_DASH_PSSH_MOOV_MPD;\n\telse pssh_mode = GF_DASH_PSSH_MOOV;\n\treturn 0;\n}\nu32 parse_sdtp(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"both\")) sdtp_in_traf = 2;\n\telse if (!stricmp(arg_val, \"sdtp\")) sdtp_in_traf = 1;\n\telse sdtp_in_traf = 0;\n\treturn 0;\n}\n\nu32 parse_rap_ref(char *arg_val, u32 opt)\n{\n\tif (arg_val) {\n\t\tif (sscanf(arg_val, \"%d\", &trackID) == 1) {\n\t\t\tparse_track_action(arg_val, opt ? TRAC_ACTION_REM_NON_REFS : TRAC_ACTION_REM_NON_RAP);\n\t\t}\n\t}\n\thint_flags |= GP_RTP_PCK_SIGNAL_RAP;\n\tseg_at_rap = 1;\n\treturn 0;\n}\nu32 parse_store_mode(char *arg_val, u32 opt)\n{\n\tdo_save = GF_TRUE;\n\tif ((opt == 0) || (opt == 1)) {\n\t\tinterleaving_time = atof(arg_val) / 1000;\n\t\tif (!interleaving_time) do_flat = 2;\n\t\topen_edit = GF_TRUE;\n\t\tno_inplace = GF_TRUE;\n\t\tif (opt==1) old_interleave = 1;\n\t} else if (opt==2) {\n\t\tinterleaving_time = atof(arg_val);\n\t\tdo_frag = GF_TRUE;\n\t} else {\n\t\tforce_new = 2;\n\t\tinterleaving_time = 0.5;\n\t\tdo_flat = 1;\n\t}\n\treturn 0;\n}\nu32 parse_base_url(char *arg_val, u32 opt)\n{\n\tmpd_base_urls = gf_realloc(mpd_base_urls, (nb_mpd_base_urls + 1)*sizeof(char**));\n\tif (!mpd_base_urls) return 2;\n\tmpd_base_urls[nb_mpd_base_urls] = arg_val;\n\tnb_mpd_base_urls++;\n\treturn 0;\n}\nu32 parse_multi_rtp(char *arg_val, u32 opt)\n{\n\thint_flags |= GP_RTP_PCK_USE_MULTI;\n\tif (arg_val)\n\t\tmax_ptime = atoi(arg_val);\n\treturn 0;\n}\n\n\nu32 parse_senc_param(char *arg_val, u32 opt)\n{\n\tswitch (opt) {\n\tcase 0: //-sync\n\t\tsmenc_opts.flags |= GF_SM_ENCODE_RAP_INBAND;\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 1: //-shadow\n\t\tsmenc_opts.flags &= ~GF_SM_ENCODE_RAP_INBAND;\n\t\tsmenc_opts.flags |= GF_SM_ENCODE_RAP_SHADOW;\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 2: //-carousel\n\t\tsmenc_opts.flags &= ~(GF_SM_ENCODE_RAP_INBAND | GF_SM_ENCODE_RAP_SHADOW);\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 3: //-auto-quant\n\t\tsmenc_opts.resolution = atoi(arg_val);\n\t\tsmenc_opts.auto_quant = 1;\n\t\tbreak;\n\tcase 4: //-global-quant\n\t\tsmenc_opts.resolution = atoi(arg_val);\n\t\tsmenc_opts.auto_quant = 2;\n\t\tbreak;\n\tcase 5: //-ctx-in or -inctx\n\t\tchunk_mode = GF_TRUE;\n\t\tinput_ctx = arg_val;\n\t}\n\treturn 0;\n}\nu32 parse_cryp(char *arg_val, u32 opt)\n{\n\topen_edit = GF_TRUE;\n\tif (!opt) {\n\t\tcrypt = 1;\n\t\tdrm_file = arg_val;\n\t\topen_edit = GF_TRUE;\n\t\treturn 0;\n\t}\n\tcrypt = 2;\n\tif (arg_val && get_file_type_by_ext(arg_val) != 1) {\n\t\tdrm_file = arg_val;\n\t\treturn 0;\n\t}\n\treturn 3;\n}\n\nu32 parse_dash_profile(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"live\") || !stricmp(arg_val, \"simple\")) dash_profile = GF_DASH_PROFILE_LIVE;\n\telse if (!stricmp(arg_val, \"onDemand\")) dash_profile = GF_DASH_PROFILE_ONDEMAND;\n\telse if (!stricmp(arg_val, \"hbbtv1.5:live\") || !stricmp(arg_val, \"hbbtv1.5.live\"))\n\t\tdash_profile = GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE;\n\telse if (!stricmp(arg_val, \"dashavc264:live\") || !stricmp(arg_val, \"dashavc264.live\"))\n\t\tdash_profile = GF_DASH_PROFILE_AVC264_LIVE;\n\telse if (!stricmp(arg_val, \"dashavc264:onDemand\") || !stricmp(arg_val, \"dashavc264.onDemand\"))\n\t\tdash_profile = GF_DASH_PROFILE_AVC264_ONDEMAND;\n\telse if (!stricmp(arg_val, \"dashif.ll\")) dash_profile = GF_DASH_PROFILE_DASHIF_LL;\n\telse if (!stricmp(arg_val, \"main\")) dash_profile = GF_DASH_PROFILE_MAIN;\n\telse if (!stricmp(arg_val, \"full\")) dash_profile = GF_DASH_PROFILE_FULL;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized DASH profile \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_fps(char *arg_val, u32 opt)\n{\n\tu32 ticks, dts_inc;\n\tif (!strcmp(arg_val, \"auto\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning, fps=auto option is deprecated\\n\"));\n\t}\n\telse if ((sscanf(arg_val, \"%u-%u\", &ticks, &dts_inc)==2) || (sscanf(arg_val, \"%u/%u\", &ticks, &dts_inc)==2) ) {\n\t\tif (!dts_inc) dts_inc = 1;\n\t\timport_fps.num = ticks;\n\t\timport_fps.den = dts_inc;\n\t} else {\n\t\timport_fps.num = (s32) (1000 * atof(arg_val));\n\t\timport_fps.den = 1000;\n\t}\n\treturn 0;\n}\n\nu32 parse_split(char *arg_val, u32 opt)\n{\n\tswitch (opt) {\n\tcase 0://-split\n\t\tsplit_duration = atof(arg_val);\n\t\tif (split_duration < 0) split_duration = 0;\n\t\tsplit_size = 0;\n\t\tbreak;\n\tcase 1: //-split-rap, -splitr\n\t\tsplit_duration = -1;\n\t\tsplit_size = -1;\n\t\tbreak;\n\tcase 2: //-split-size, -splits\n\t\tsplit_size = (u32)atoi(arg_val);\n\t\tsplit_duration = 0;\n\t\tbreak;\n\tcase 4: //-splitz\n\t\tadjust_split_end = 1;\n\t\t//fallthrough\n\tcase 3: //-split-chunk, -splitx\n\t\tif (!strstr(arg_val, \":\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\tif (strstr(arg_val, \"end\")) {\n\t\t\tif (strstr(arg_val, \"end-\")) {\n\t\t\t\tDouble dur_end=0;\n\t\t\t\tsscanf(arg_val, \"%lf:end-%lf\", &split_start, &dur_end);\n\t\t\t\tsplit_duration = -2 - dur_end;\n\t\t\t} else {\n\t\t\t\tsscanf(arg_val, \"%lf:end\", &split_start);\n\t\t\t\tsplit_duration = -2;\n\t\t\t}\n\t\t} else {\n\t\t\tif (strchr(arg_val, '-')) {\n\t\t\t\tsplit_range_str = arg_val;\n\t\t\t} else {\n\t\t\t\tsscanf(arg_val, \"%lf:%lf\", &split_start, &split_duration);\n\t\t\t\tsplit_duration -= split_start;\n\t\t\t}\n\t\t}\n\t\tsplit_size = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nu32 parse_brand(char *b, u32 opt)\n{\n\topen_edit = GF_TRUE;\n\tswitch (opt) {\n\tcase 0: //-brand\n\t\tmajor_brand = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tif (b[4] == ':') {\n\t\t\tif (!strncmp(b+5, \"0x\", 2))\n\t\t\t\tsscanf(b+5, \"0x%x\", &minor_version);\n\t\t\telse\n\t\t\t\tminor_version = atoi(b + 5);\n\t\t}\n\t\tbreak;\n\tcase 1: //-ab\n\t\tbrand_add = (u32*)gf_realloc(brand_add, sizeof(u32) * (nb_alt_brand_add + 1));\n\t\tif (!brand_add) return 2;\n\t\tbrand_add[nb_alt_brand_add] = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tnb_alt_brand_add++;\n\t\tbreak;\n\tcase 2: //-rb\n\t\tbrand_rem = (u32*)gf_realloc(brand_rem, sizeof(u32) * (nb_alt_brand_rem + 1));\n\t\tif (!brand_rem) return 2;\n\t\tbrand_rem[nb_alt_brand_rem] = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tnb_alt_brand_rem++;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nu32 parse_mpegu(char *arg_val, u32 opt)\n{\n\tpack_file = arg_val;\n\tpack_wgt = GF_TRUE;\n\treturn 0;\n}\n\nu32 parse_file_info(char *arg_val, u32 opt)\n{\n\tprint_info = opt ? 2 : 1;\n\tif (arg_val) {\n\t\tif (sscanf(arg_val, \"%u\", &info_track_id) == 1) {\n\t\t\tchar szTk[20];\n\t\t\tsprintf(szTk, \"%u\", info_track_id);\n\t\t\tif (strcmp(szTk, arg_val)) info_track_id = 0;\n\t\t}\n\t\tif (!info_track_id) return 3;\n\t}\n\treturn 0;\n}\nu32 parse_boxpatch(char *arg_val, u32 opt)\n{\n\tbox_patch_filename = arg_val;\n\tchar *sep = strchr(box_patch_filename, '=');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tbox_patch_trackID = atoi(box_patch_filename);\n\t\tsep[0] = '=';\n\t\tbox_patch_filename = sep+1;\n\t}\n\topen_edit = GF_TRUE;\n\treturn 0;\n}\n\n\nu32 parse_dump_udta(char *code, u32 opt)\n{\n\tchar *sep;\n\tsep = strchr(code, ':');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tdump_udta_track = atoi(code);\n\t\tsep[0] = ':';\n\t\tcode = sep + 1;\n\t}\n\n\tif (strlen(code) == 4) {\n\t\tdump_udta_type = GF_4CC(code[0], code[1], code[2], code[3]);\n\t} else if (strlen(code) == 8) {\n\t\t// hex representation on 8 chars\n\t\tu32 hex1, hex2, hex3, hex4;\n\t\tif (sscanf(code, \"%02x%02x%02x%02x\", &hex1, &hex2, &hex3, &hex4) != 4) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\tdump_udta_type = GF_4CC(hex1, hex2, hex3, hex4);\n\t} else {\n\t\tM4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_dump_ts(char *arg_val, u32 opt)\n{\n\tdump_timestamps = 1;\n\tif (arg_val) {\n\t\tif (isdigit(arg_val[0])) {\n\t\t\tprogram_number = atoi(arg_val);\n\t\t} else {\n\t\t\treturn 3;\n\t\t}\n\t}\n\treturn 0;\n}\n\nu32 parse_ttxt(char *arg_val, u32 opt)\n{\n\tif (opt) //-srt\n\t\tdump_srt = GF_TRUE;\n\telse\n\t\tdump_ttxt = GF_TRUE;\n\n\timport_subtitle = 1;\n\ttrackID = 0;\n\n\tif (arg_val && (!strcmp(arg_val, \"*\") || !strcmp(arg_val, \"@\") || !strcmp(arg_val, \"all\")) ) {\n\t\ttrackID = (u32)-1;\n\t} else if (arg_val) {\n\t\tif (sscanf(arg_val, \"%u\", &trackID) == 1) {\n\t\t\tchar szTk[20];\n\t\t\tsprintf(szTk, \"%d\", trackID);\n\t\t\tif (strcmp(szTk, arg_val))\n\t\t\t\ttrackID = 0;\n\t\t}\n\t\tif (!trackID) return 3;\n\t}\n\treturn 0;\n}\n\nu32 parse_dashlive(char *arg, char *arg_val, u32 opt)\n{\n\tdash_mode = opt ? GF_DASH_DYNAMIC_DEBUG : GF_DASH_DYNAMIC;\n\tdash_live = 1;\n\tif (arg[10] == '=') {\n\t\tdash_ctx_file = arg + 11;\n\t}\n\tdash_duration = atof(arg_val);\n\treturn 0;\n}\n\nu32 parse_help(char *arg_val, u32 opt)\n{\n\tif (!arg_val) PrintUsage();\n\telse if (opt) PrintHelp(arg_val, GF_TRUE, GF_FALSE);\n\telse if (!strcmp(arg_val, \"general\")) PrintGeneralUsage();\n\telse if (!strcmp(arg_val, \"extract\")) PrintExtractUsage();\n\telse if (!strcmp(arg_val, \"split\")) PrintSplitUsage();\n\telse if (!strcmp(arg_val, \"dash\")) PrintDASHUsage();\n\telse if (!strcmp(arg_val, \"dump\")) PrintDumpUsage();\n\telse if (!strcmp(arg_val, \"import\")) PrintImportUsage();\n\telse if (!strcmp(arg_val, \"format\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"deprecated, see [filters documentation](Filters)\\n\"));\n\t}\n\telse if (!strcmp(arg_val, \"hint\")) PrintHintUsage();\n\telse if (!strcmp(arg_val, \"encode\")) PrintEncodeUsage();\n\telse if (!strcmp(arg_val, \"crypt\")) PrintEncryptUsage();\n\telse if (!strcmp(arg_val, \"meta\")) PrintMetaUsage();\n\telse if (!strcmp(arg_val, \"swf\")) PrintSWFUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\telse if (!strcmp(arg_val, \"rtp\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"RTP streaming deprecated in MP4Box, use gpac application\\n\"));\n\t}\n\telse if (!strcmp(arg_val, \"live\")) PrintLiveUsage();\n#endif\n\telse if (!strcmp(arg_val, \"core\")) PrintCoreUsage();\n\telse if (!strcmp(arg_val, \"tags\")) PrintTags();\n\telse if (!strcmp(arg_val, \"cicp\")) PrintCICP();\n\telse if (!strcmp(arg_val, \"all\")) {\n\t\tPrintGeneralUsage();\n\t\tPrintExtractUsage();\n\t\tPrintDASHUsage();\n\t\tPrintSplitUsage();\n\t\tPrintDumpUsage();\n\t\tPrintImportUsage();\n\t\tPrintHintUsage();\n\t\tPrintEncodeUsage();\n\t\tPrintEncryptUsage();\n\t\tPrintMetaUsage();\n\t\tPrintSWFUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\t\tPrintCoreUsage();\n\t\tPrintTags();\n\t\tPrintCICP();\n\t} else if (!strcmp(arg_val, \"opts\")) {\n\t\tPrintHelp(\"@\", GF_FALSE, GF_FALSE);\n\t} else {\n\t\tPrintHelp(arg_val, GF_FALSE, GF_FALSE);\n\t}\n\treturn 1;\n}\n\nu32 parse_gendoc(char *name, u32 opt)\n{\n\tu32 i=0;\n\t//gen MD\n\tif (!opt) {\n\t\thelp_flags = GF_PRINTARG_MD | GF_PRINTARG_IS_APP;\n\t\thelpout = gf_fopen(\"mp4box-gen-opts.md\", \"w\");\n\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb General\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tfprintf(helpout, \"# Syntax\\n\");\n\t\tgf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option] [other_dash_inputs]\\n\"\n\t\t\t\"  \\n\"\n\t\t);\n\t\tPrintGeneralUsage();\n\t\tPrintEncryptUsage();\n\t\tfprintf(helpout, \"# Help Options\\n\");\n\t\twhile (m4b_usage_args[i].name) {\n\t\t\tGF_GPACArg *g_arg = (GF_GPACArg *) &m4b_usage_args[i];\n\t\t\ti++;\n\t\t\tgf_sys_print_arg(helpout, help_flags, g_arg, \"mp4box-general\");\n\t\t}\n\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-import-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Import\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintImportUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-dash-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media DASH\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintDASHUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-dump-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Dump and Export\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintExtractUsage();\n\t\tPrintDumpUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-meta-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Meta and HEIF/IFF\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintMetaUsage();\n\t\tgf_fclose(helpout);\n\n\n\t\thelpout = gf_fopen(\"mp4box-scene-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Scene Description\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintEncodeUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\t\tPrintSWFUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-other-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Other Features\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintHintUsage();\n\t\tPrintTags();\n\t\tgf_fclose(helpout);\n\t}\n\t//gen man\n\telse {\n\t\thelp_flags = GF_PRINTARG_MAN;\n\t\thelpout = gf_fopen(\"mp4box.1\", \"w\");\n\n\n\t\tfprintf(helpout, \".TH MP4Box 1 2019 MP4Box GPAC\\n\");\n\t\tfprintf(helpout, \".\\n.SH NAME\\n.LP\\nMP4Box \\\\- GPAC command-line media packager\\n.SH SYNOPSIS\\n.LP\\n.B MP4Box\\n.RI [options] \\\\ [file] \\\\ [options]\\n.br\\n.\\n\");\n\n\t\tPrintGeneralUsage();\n\t\tPrintExtractUsage();\n\t\tPrintDASHUsage();\n\t\tPrintSplitUsage();\n\t\tPrintDumpUsage();\n\t\tPrintImportUsage();\n\t\tPrintHintUsage();\n\t\tPrintEncodeUsage();\n\t\tPrintEncryptUsage();\n\t\tPrintMetaUsage();\n\t\tPrintSWFUsage();\n\t\tPrintTags();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\n\t\tfprintf(helpout, \".SH EXAMPLES\\n.TP\\nBasic and advanced examples are available at https://wiki.gpac.io/MP4Box\\n\");\n\t\tfprintf(helpout, \".SH MORE\\n.LP\\nAuthors: GPAC developers, see git repo history (-log)\\n\"\n\t\t\".br\\nFor bug reports, feature requests, more information and source code, visit https://github.com/gpac/gpac\\n\"\n\t\t\".br\\nbuild: %s\\n\"\n\t\t\".br\\nCopyright: %s\\n.br\\n\"\n\t\t\".SH SEE ALSO\\n\"\n\t\t\".LP\\ngpac(1), MP4Client(1)\\n\", gf_gpac_version(), gf_gpac_copyright());\n\n\t\tgf_fclose(helpout);\n\t}\n\treturn 1;\n}\n\nstatic Bool arg_parse_res = 0;\nu32 mp4box_parse_single_arg_class(int argc, char **argv, char *arg, u32 *arg_index, MP4BoxArg *arg_class)\n{\n\tMP4BoxArg *arg_desc = NULL;\n\tchar *arg_val = NULL;\n\tu32 i=0;\n\twhile (arg_class[i].name) {\n\t\targ_desc = (MP4BoxArg *) &arg_class[i];\n\t\ti++;\n\n#ifdef TEST_ARGS\n\t\tchar *sep = strchr(arg_desc->name, ' ');\n\t\tif (sep) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid arg %s, space not allowed\\n\", arg_desc->name));\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tif (!strcmp(arg_desc->name, arg+1))\n\t\t\tbreak;\n\t\tif (arg_desc->altname && !strcmp(arg_desc->altname, arg+1))\n\t\t\tbreak;\n\n\t\tif (arg_desc->parse_flags & ARG_IS_FUN2) {\n\t\t\tif (!strncmp(arg_desc->name, arg+1, strlen(arg_desc->name) ))\n\t\t\t\tbreak;\n\t\t}\n\t\targ_desc = NULL;\n\t}\n\tif (!arg_desc)\n\t\treturn GF_FALSE;\n\n\tif (arg_desc->parse_flags & ARG_OPEN_EDIT) open_edit = GF_TRUE;\n\tif (arg_desc->parse_flags & ARG_NEED_SAVE) do_save = GF_TRUE;\n\tif (arg_desc->parse_flags & ARG_NO_INPLACE) no_inplace = GF_TRUE;\n\n\tif (arg_desc->type != GF_ARG_BOOL) {\n\t\tBool has_next = GF_TRUE;\n\t\tif (*arg_index + 1 == (u32) argc)\n\t\t\thas_next = GF_FALSE;\n\t\telse if (argv[*arg_index + 1][0] == '-') {\n\t\t\ts32 v;\n\t\t\tif (sscanf(argv[*arg_index + 1], \"%d\", &v)!=1)\n\t\t\t\thas_next = GF_FALSE;\n\t\t}\n\t\tif (!has_next && ! (arg_desc->parse_flags & ARG_EMPTY) ) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing argument value for %s - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (has_next && (arg_desc->parse_flags & ARG_EMPTY) && (arg_desc->type==GF_ARG_INT)) {\n\t\t\ts32 ival;\n\t\t\tif (sscanf(argv[*arg_index + 1], \"%d\", &ival) != 1) {\n\t\t\t\thas_next = GF_FALSE;\n\t\t\t\targ_val = NULL;\n\t\t\t}\n\t\t}\n\t\tif (has_next) {\n\t\t\thas_next_arg = GF_TRUE;\n\t\t\t*arg_index += 1;\n\t\t\targ_val = argv[*arg_index];\n\t\t}\n\t}\n\tif (!arg_desc->arg_ptr) return GF_TRUE;\n\n\tif (arg_desc->parse_flags & (ARG_IS_FUN|ARG_IS_FUN2) ) {\n\t\tu32 res;\n\t\tif (arg_desc->parse_flags & ARG_PUSH_SYSARGS)\n\t\t\tgf_sys_set_args(argc, (const char**) argv);\n\n\t\tif (arg_desc->parse_flags & ARG_IS_FUN) {\n\t\t\tparse_arg_fun fun = (parse_arg_fun) arg_desc->arg_ptr;\n\t\t\tres = fun(arg_val, arg_desc->argv_val);\n\t\t} else {\n\t\t\tparse_arg_fun2 fun2 = (parse_arg_fun2) arg_desc->arg_ptr;\n\t\t\tres = fun2(arg, arg_val, arg_desc->argv_val);\n\t\t}\n\t\t//rewind, not our arg\n\t\tif ((res==3) && argv) {\n\t\t\t*arg_index -= 1;\n\t\t\tres = 0;\n\t\t}\n\t\targ_parse_res = res;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->parse_flags & ARG_INT_INC) {\n\t\t* (u32 *) arg_desc->arg_ptr += 1;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_BOOL) {\n\t\tif (!arg_desc->parse_flags) {\n\t\t\tif (arg_desc->argv_val) {\n\t\t\t\t* (u32 *) arg_desc->arg_ptr = arg_desc->argv_val;\n\t\t\t} else {\n\t\t\t\t* (Bool *) arg_desc->arg_ptr = GF_TRUE;\n\t\t\t}\n\t\t} else if (arg_desc->parse_flags & ARG_BOOL_REV) {\n\t\t\t* (Bool *) arg_desc->arg_ptr = GF_FALSE;\n\t\t} else if (arg_desc->parse_flags & ARG_HAS_VALUE) {\n\t\t\t* (u32 *) arg_desc->arg_ptr = 0;\n\t\t} else if (arg_desc->parse_flags & ARG_BIT_MASK) {\n\t\t\t* (u32 *) arg_desc->arg_ptr |= arg_desc->argv_val;\n\t\t} else if (arg_desc->parse_flags & ARG_BIT_MASK_REM) {\n\t\t\t* (u32 *) arg_desc->arg_ptr &= ~arg_desc->argv_val;\n\t\t} else if (arg_desc->argv_val) {\n\t\t\t* (u32 *) arg_desc->arg_ptr = arg_desc->argv_val;\n\t\t} else {\n\t\t\t* (u32 *) arg_desc->arg_ptr = GF_TRUE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_STRING) {\n\t\tif (arg_desc->parse_flags & ARG_IS_4CC) {\n\t\t\tu32 alen = arg_val ? (u32) strlen(arg_val) : 0;\n\t\t\tif ((alen<3) || (alen>4)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s must be a 4CC, %s is not - please check usage\\n\", arg, arg_val));\n\t\t\t\targ_parse_res = 2;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\t* (u32 *) arg_desc->arg_ptr = GF_4CC(arg_val[0], arg_val[1], arg_val[2], arg_val[3]);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\t* (char **) arg_desc->arg_ptr = arg_val;\n\t\treturn GF_TRUE;\n\t}\n\tif (!arg_val) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Missing value for %s - please check usage\\n\", arg));\n\t\targ_parse_res = 2;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_DOUBLE) {\n\t\tDouble v = atof(arg_val);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (Double *) arg_desc->arg_ptr = v;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type != GF_ARG_INT) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unsupported argument type for %s - please report to gpac devs\\n\", arg));\n\t\targ_parse_res = 2;\n\t\treturn GF_TRUE;\n\t}\n\tif (arg_desc->parse_flags & ARG_64BITS) {\n\t\tu64 v;\n\t\tsscanf(arg_val, LLU, &v);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (u64 *) arg_desc->arg_ptr = v;\n\t} else {\n\t\tu32 v = atoi(arg_val);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (s32 *) arg_desc->arg_ptr = v;\n\t}\n\treturn GF_TRUE;\n}\n\nBool mp4box_parse_single_arg(int argc, char **argv, char *arg, u32 *arg_index)\n{\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_gen_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_split_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dash_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_imp_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_senc_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_crypt_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_hint_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_extr_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dump_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_meta_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_swf_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_liveenc_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_usage_args)) return GF_TRUE;\n\n\treturn GF_FALSE;\n}\n\n\nu32 mp4box_parse_args(int argc, char **argv)\n{\n\tu32 i;\n\t/*parse our args*/\n\tfor (i = 1; i < (u32)argc; i++) {\n\t\tchar *arg = argv[i];\n\t\t/*input file(s)*/\n\t\tif ((arg[0] != '-') || !stricmp(arg, \"--\")) {\n\t\t\tchar *arg_val = arg;\n\t\t\tif (!stricmp(arg, \"--\")) {\n\t\t\t\tif (i+1==(u32)argc) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing arg for `--` - please check usage\\n\"));\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\thas_next_arg = GF_TRUE;\n\t\t\t\targ_val = argv[i + 1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (argc < 3) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - only one input file found as argument, please check usage\\n\"));\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse if (inName) {\n\t\t\t\tif (dash_duration) {\n\t\t\t\t\tif (!nb_dash_inputs) {\n\t\t\t\t\t\tdash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);\n\t\t\t\t\t}\n\t\t\t\t\tdash_inputs = set_dash_input(dash_inputs, arg_val, &nb_dash_inputs);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - 2 input names specified, please check usage\\n\"));\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinName = arg_val;\n\t\t\t}\n\t\t}\n\t\t//all deprecated options\n\t\telse if (!stricmp(arg, \"-grab-ts\") || !stricmp(arg, \"-atsc\") || !stricmp(arg, \"-rtp\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Deprecated fuctionnality `%s` - use gpac application\\n\", arg));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-write-buffer\")) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"`%s` option deprecated, use `-bs-cache-size`\", arg));\n\t\t\tgf_opts_set_key(\"temp\", \"bs-cache-size\", argv[i + 1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-pssh-moof\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-pssh-moof` option deprecated , use `-pssh` option\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-tag-list\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-tag-list` option deprecated, use `-h tags`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-aviraw\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-aviraw` option deprecated, use `-raw`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-avi\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-avi` option deprecated, use `-mux`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!strncmp(arg, \"-p=\", 3)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//parse argument\n\t\telse if (mp4box_parse_single_arg(argc, argv, arg, &i)) {\n\t\t\tif (arg_parse_res)\n\t\t\t\treturn mp4box_cleanup(arg_parse_res);\n\t\t}\n\t\t//not a MP4Box arg\n\t\telse {\n\t\t\tu32 res = gf_sys_is_gpac_arg(arg);\n\t\t\tif (res==0) {\n\t\t\t\tPrintHelp(arg, GF_FALSE, GF_TRUE);\n\t\t\t\treturn 2;\n\t\t\t} else if (res==2) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t//live scene encoder does not use the unified parsing and should be moved as a scene encoder filter\n\t\tif (live_scene) return 0;\n\t}\n\treturn 0;\n}\n\n/*\n\tEND OF OPTION PARSING CODE\n*/\n\n\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist)\n{\n\tFILE *logs = cbk;\n\tif (log_tool != GF_LOG_CODING) return;\n\tvfprintf(logs, fmt, vlist);\n\tfflush(logs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tMP4 File Hinting\n*/\n\nvoid SetupClockReferences(GF_ISOFile *file)\n{\n\tu32 i, count, ocr_id;\n\tcount = gf_isom_get_track_count(file);\n\tif (count==1) return;\n\tocr_id = 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tocr_id = gf_isom_get_track_id(file, i+1);\n\t\tbreak;\n\t}\n\t/*doesn't look like MP4*/\n\tif (!ocr_id) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd) {\n\t\t\tesd->OCRESID = ocr_id;\n\t\t\tgf_isom_change_mpeg4_description(file, i+1, 1, esd);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t}\n}\n\n/*base RTP payload type used (you can specify your own types if needed)*/\n#define BASE_PAYT\t\t96\n\nGF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, val, res, streamType;\n\tu32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;\n\tGF_Err e;\n\tchar szPayload[30];\n\tGF_RTPHinter *hinter;\n\tBool copy, has_iod, single_av;\n\tu8 init_payt = BASE_PAYT;\n\tu32 mtype;\n\tGF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;\n\tu32 media_group = 0;\n\tu8 media_prio = 0;\n\n\ttot_bw = 0;\n\tprev_ocr = 0;\n\tsingle_ocr = 1;\n\n\thas_iod = 1;\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) has_iod = 0;\n\telse {\n\t\tif (!gf_list_count(iod->ESDescriptors)) has_iod = 0;\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\n\tspec_type = gf_isom_guess_specification(file);\n\tsingle_av = single_group ? 1 : gf_isom_is_single_av(file);\n\n\t/*first make sure we use a systems track as base OCR*/\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tres = gf_isom_get_media_type(file, i+1);\n\t\tif ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {\n\t\t\tif (gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t\tgf_isom_set_default_sync_track(file, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnb_done = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tsl_mode = base_flags;\n\t\tcopy = copy_data;\n\t\t/*skip emty tracks (mainly MPEG-4 interaction streams...*/\n\t\tif (!gf_isom_get_sample_count(file, i+1)) continue;\n\t\tif (!gf_isom_is_track_enabled(file, i+1)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 2;\n\t\t\t}\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 3;\n            }\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 4;\n            }\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*no hinting of systems track on isma*/\n\t\t\tif (spec_type==GF_ISOM_BRAND_ISMA) continue;\n\t\t}\n\t\tmtype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tif ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);\n\n\t\tif (!single_av) {\n\t\t\t/*one media per group only (we should prompt user for group selection)*/\n\t\t\tmedia_group ++;\n\t\t\tmedia_prio = 1;\n\t\t}\n\n\t\tstreamType = 0;\n\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd) {\n\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\tif (!prev_ocr) {\n\t\t\t\tprev_ocr = esd->OCRESID;\n\t\t\t\tif (!esd->OCRESID) prev_ocr = esd->ESID;\n\t\t\t} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {\n\t\t\t\tsingle_ocr = 0;\n\t\t\t}\n\t\t\t/*OD MUST BE WITHOUT REFERENCES*/\n\t\t\tif (streamType==1) copy = 1;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t/*single AU - check if base64 would fit in ESD (consider 33% overhead of base64), otherwise stream*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);\n\t\t\t\tif (streamType) {\n\t\t\t\t\tres = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);\n\t\t\t\t} else {\n\t\t\t\t\t/*not a system track, we shall hint it*/\n\t\t\t\t\tres = 0;\n\t\t\t\t}\n\t\t\t\tif (samp) gf_isom_sample_del(&samp);\n\t\t\t\tif (res) continue;\n\t\t\t}\n\t\t}\n\t\tif (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;\n\n\t\thinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);\n\n\t\tif (!hinter) {\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));\n\t\t\t\tif (!nb_done) return e;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint_no_offset)\n\t\t\tgf_hinter_track_force_no_offsets(hinter);\n\n\t\tbw = gf_hinter_track_get_bandwidth(hinter);\n\t\ttot_bw += bw;\n\t\tflags = gf_hinter_track_get_flags(hinter);\n\n\t\t//set extraction mode for AVC/SVC\n\t\tgf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);\n\n\t\tgf_hinter_track_get_payload_name(hinter, szPayload);\n\t\tM4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));\n\t\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));\n\t\te = gf_hinter_track_process(hinter);\n\n\t\tif (!e) e = gf_hinter_track_finalize(hinter, has_iod);\n\t\tgf_hinter_track_del(hinter);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));\n\t\t\tif (!nb_done) return e;\n\t\t}\n\t\tinit_payt++;\n\t\tnb_done ++;\n\t}\n\n\tif (has_iod) {\n\t\tiod_mode = GF_SDP_IOD_ISMA;\n\t\tif (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;\n\t} else {\n\t\tiod_mode = GF_SDP_IOD_NONE;\n\t}\n\tgf_hinter_finalize(file, iod_mode, tot_bw);\n\n\tif (!single_ocr)\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)\n\nstatic void check_media_profile(GF_ISOFile *file, u32 track)\n{\n\tu8 PL;\n\tGF_ESD *esd = gf_isom_get_esd(file, track, 1);\n\tif (!esd) return;\n\n\tswitch (esd->decoderConfig->streamType) {\n\tcase 0x04:\n\t\tPL = gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL);\n\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tGF_M4VDecSpecInfo vdsi;\n\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &vdsi);\n\t\t\tif (vdsi.VideoPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, vdsi.VideoPL);\n\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0x15);\n\t\t} else if (!PL) {\n\t\t\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase 0x05:\n\t\tPL = gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO);\n\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t{\n\t\t\tGF_M4ADecSpecInfo adsi;\n\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &adsi);\n\t\t\tif (adsi.audioPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, adsi.audioPL);\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFE);\n\t\t}\n\t\tbreak;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n}\nvoid remove_systems_tracks(GF_ISOFile *file)\n{\n\tu32 i, count;\n\n\tcount = gf_isom_get_track_count(file);\n\tif (count==1) return;\n\n\t/*force PL rewrite*/\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 1);\t/*the lib always remove IOD when no profiles are specified..*/\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tswitch (gf_isom_get_media_type(file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tgf_isom_remove_track_from_root_od(file, i+1);\n\t\t\tcheck_media_profile(file, i+1);\n\t\t\tbreak;\n\t\t/*only remove real systems tracks (eg, delaing with scene description & presentation)\n\t\tbut keep meta & all unknown tracks*/\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\t\t\tgf_isom_remove_track_from_root_od(file, i+1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\tgf_isom_remove_track(file, i+1);\n\t\t\ti--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*none required*/\n\tif (!gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO)) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFF);\n\tif (!gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL)) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFF);\n\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_SCENE, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_GRAPHICS, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_INLINE, 0);\n}\n\n#endif /*!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)*/\n\nGF_FileType get_file_type_by_ext(char *inName)\n{\n\tGF_FileType type = GF_FILE_TYPE_NOT_SUPPORTED;\n\tchar *ext = strrchr(inName, '.');\n\tif (ext) {\n\t\tchar *sep;\n\t\tif (!strcmp(ext, \".gz\")) ext = strrchr(ext-1, '.');\n\t\text+=1;\n\t\tsep = strchr(ext, '.');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!stricmp(ext, \"mp4\") || !stricmp(ext, \"3gp\") || !stricmp(ext, \"mov\") || !stricmp(ext, \"3g2\") || !stricmp(ext, \"3gs\")) {\n\t\t\ttype = GF_FILE_TYPE_ISO_MEDIA;\n\t\t} else if (!stricmp(ext, \"bt\") || !stricmp(ext, \"wrl\") || !stricmp(ext, \"x3dv\")) {\n\t\t\ttype = GF_FILE_TYPE_BT_WRL_X3DV;\n\t\t} else if (!stricmp(ext, \"xmt\") || !stricmp(ext, \"x3d\")) {\n\t\t\ttype = GF_FILE_TYPE_XMT_X3D;\n\t\t} else if (!stricmp(ext, \"lsr\") || !stricmp(ext, \"saf\")) {\n\t\t\ttype = GF_FILE_TYPE_LSR_SAF;\n\t\t} else if (!stricmp(ext, \"svg\") || !stricmp(ext, \"xsr\") || !stricmp(ext, \"xml\")) {\n\t\t\ttype = GF_FILE_TYPE_SVG;\n\t\t} else if (!stricmp(ext, \"swf\")) {\n\t\t\ttype = GF_FILE_TYPE_SWF;\n\t\t} else if (!stricmp(ext, \"jp2\")) {\n\t\t\tif (sep) sep[0] = '.';\n\t\t\treturn GF_FILE_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse type = GF_FILE_TYPE_NOT_SUPPORTED;\n\n\t\tif (sep) sep[0] = '.';\n\t}\n\n\n\t/*try open file in read mode*/\n\tif (!type && gf_isom_probe_file(inName)) type = GF_FILE_TYPE_ISO_MEDIA;\n\treturn type;\n}\n\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\nstatic GF_Err xml_bs_to_bin(char *inName, char *outName, u32 dump_std)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu8 *data = NULL;\n\tu32 data_size;\n\n\tGF_DOMParser *dom = gf_xml_dom_new();\n\te = gf_xml_dom_parse(dom, inName, NULL, NULL);\n\tif (e) {\n\t\tgf_xml_dom_del(dom);\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to parse XML file: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root_idx(dom, 0);\n\tif (!root) {\n\t\tgf_xml_dom_del(dom);\n\t\treturn GF_OK;\n\t}\n\n\te = gf_xml_parse_bit_sequence(root, inName, &data, &data_size);\n\tgf_xml_dom_del(dom);\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\n\tif (dump_std) {\n\t\tgf_fwrite(data, data_size, stdout);\n\t} else {\n\t\tFILE *t;\n\t\tchar szFile[GF_MAX_PATH];\n\t\tif (outName) {\n\t\t\tstrcpy(szFile, outName);\n\t\t} else {\n\t\t\tstrcpy(szFile, inName);\n\t\t\tstrcat(szFile, \".bin\");\n\t\t}\n\t\tt = gf_fopen(szFile, \"wb\");\n\t\tif (!t) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", szFile));\n\t\t\te = GF_IO_ERR;\n\t\t} else {\n\t\t\tif (gf_fwrite(data, data_size, t) != data_size) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to write output to file %s\\n\", szFile));\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t\tgf_fclose(t);\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n#endif /*GPAC_DISABLE_CORE_TOOLS*/\n\nstatic u64 do_size_top_boxes(char *inName, char *compress_top_boxes, u32 mode)\n{\n\tFILE *in;\n\tu64 top_size = 0;\n\tBool do_all = GF_FALSE;\n\tGF_BitStream *bs_in;\n\tif (!compress_top_boxes) return GF_BAD_PARAM;\n\tif (!strcmp(compress_top_boxes, \"all\") || !strcmp(compress_top_boxes, \"*\") || !strcmp(compress_top_boxes, \"@\"))\n\t\tdo_all = GF_TRUE;\n\n\tin = gf_fopen(inName, \"rb\");\n\tif (!in) return GF_URL_ERROR;\n\tbs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs_in)) {\n\t\tconst char *stype;\n\t\tu32 hdr_size = 8;\n\t\tu64 lsize = gf_bs_read_u32(bs_in);\n\t\tu32 type = gf_bs_read_u32(bs_in);\n\n\t\tif (lsize==1) {\n\t\t\tlsize = gf_bs_read_u64(bs_in);\n\t\t\thdr_size = 16;\n\t\t} else if (lsize==0) {\n\t\t\tlsize = gf_bs_available(bs_in) + 8;\n\t\t}\n\t\tstype = gf_4cc_to_str(type);\n\t\tif (do_all || strstr(compress_top_boxes, stype)) {\n\t\t\t//only count boxes\n\t\t\tif (mode==2) {\n\t\t\t\ttop_size += 1;\n\t\t\t} else {\n\t\t\t\ttop_size += lsize;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs_in, lsize - hdr_size);\n\t}\n\tgf_bs_del(bs_in);\n\tgf_fclose(in);\n\treturn top_size;\n\n}\n\nstatic GF_Err do_compress_top_boxes(char *inName, char *outName)\n{\n\tFILE *in, *out;\n\tu8 *buf;\n\tu32 buf_alloc, comp_size;\n\ts32 bytes_comp=0;\n\ts32 bytes_uncomp=0;\n\tGF_Err e = GF_OK;\n\tu64 source_size, dst_size;\n\tu32 orig_box_overhead;\n\tu32 final_box_overhead;\n\tu32 nb_added_box_bytes=0;\n\tBool has_mov = GF_FALSE;\n\tBool replace_all = !strcmp(compress_top_boxes, \"*\");\n\tGF_BitStream *bs_in, *bs_out;\n\n\tif (!outName) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Missing output file name\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tin = gf_fopen(inName, \"rb\");\n\tif (!in) return GF_URL_ERROR;\n\tout = gf_fopen(outName, \"wb\");\n\tif (!out) return GF_IO_ERR;\n\n\tbuf_alloc = 4096;\n\tbuf = gf_malloc(buf_alloc);\n\n\tbs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);\n\tsource_size = gf_bs_get_size(bs_in);\n\n\tbs_out = gf_bs_from_file(out, GF_BITSTREAM_WRITE);\n\n\torig_box_overhead = 0;\n\tfinal_box_overhead = 0;\n\twhile (gf_bs_available(bs_in)) {\n\t\tu32 size = gf_bs_read_u32(bs_in);\n\t\tu32 type = gf_bs_read_u32(bs_in);\n\t\tconst char *b4cc = gf_4cc_to_str(type);\n\t\tconst u8 *replace = (const u8 *) strstr(compress_top_boxes, b4cc);\n\t\tif (!strcmp(b4cc, \"moov\")) has_mov = GF_TRUE;\n\n\t\tif (!replace && !replace_all) {\n\t\t\tgf_bs_write_u32(bs_out, size);\n\t\t\tgf_bs_write_u32(bs_out, type);\n\n\t\t\tsize-=8;\n\t\t\twhile (size) {\n\t\t\t\tu32 nbytes = size;\n\t\t\t\tif (nbytes>buf_alloc) nbytes=buf_alloc;\n\t\t\t\tgf_bs_read_data(bs_in, buf, nbytes);\n\t\t\t\tgf_bs_write_data(bs_out, buf, nbytes);\n\t\t\t\tsize-=nbytes;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\torig_box_overhead += size;\n\n\t\tsize-=8;\n\n\t\tif (size>buf_alloc) {\n\t\t\tbuf_alloc = size;\n\t\t\tbuf = gf_realloc(buf, buf_alloc);\n\t\t}\n\t\tgf_bs_read_data(bs_in, buf, size);\n\n\t\treplace+=5;\n\n\t\tcomp_size = buf_alloc;\n\n\t\te = gf_gz_compress_payload(&buf, size, &comp_size);\n\t\tif (e) break;\n\n\t\tif (comp_size>buf_alloc) {\n\t\t\tbuf_alloc = comp_size;\n\t\t}\n\t\tbytes_uncomp += size;\n\t\tbytes_comp += comp_size;\n\n\t\t//write size\n\t\tgf_bs_write_u32(bs_out, comp_size+8);\n\t\t//write type\n\t\tgf_bs_write_data(bs_out, replace, 4);\n\t\t//write data\n\t\tgf_bs_write_data(bs_out, buf, comp_size);\n\n\t\tfinal_box_overhead += 8+comp_size;\n\t}\n\tdst_size = gf_bs_get_position(bs_out);\n\n\tif (buf) gf_free(buf);\n\tgf_bs_del(bs_in);\n\tgf_bs_del(bs_out);\n\tgf_fclose(in);\n\tgf_fclose(out);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error compressing: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\n\tif (has_mov) {\n\t\tu32 i, nb_tracks, nb_samples;\n\t\tGF_ISOFile *mov;\n\t\tDouble rate, new_rate, duration;\n\n\t\tmov = gf_isom_open(inName, GF_ISOM_OPEN_READ, NULL);\n\t\tduration = (Double) gf_isom_get_duration(mov);\n\t\tduration /= gf_isom_get_timescale(mov);\n\n\t\tnb_samples = 0;\n\t\tnb_tracks = gf_isom_get_track_count(mov);\n\t\tfor (i=0; i<nb_tracks; i++) {\n\t\t\tnb_samples += gf_isom_get_sample_count(mov, i+1);\n\t\t}\n\t\tgf_isom_close(mov);\n\n\t\trate = (Double) source_size;\n\t\trate /= duration;\n\t\trate /= 1000;\n\n\t\tnew_rate = (Double) dst_size;\n\t\tnew_rate /= duration;\n\t\tnew_rate /= 1000;\n\n\n\t\tfprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\torate\\tcrate\\tsamples\\tduration\\tobbps\\tcbbps\\n\");\n\t\tfprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\t%g\\t%g\\t%d\\t%g\\t%g\\t%g\\n\", inName, bytes_uncomp, bytes_comp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, nb_samples, duration, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );\n\n\t\tfprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d original rate %g kbps new rate %g kbps, orig %g box bytes/sample final %g bytes/sample\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );\n\n\t} else {\n\t\tfprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\n\");\n\t\tfprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\n\", inName, bytes_uncomp, bytes_comp, ((Double) (bytes_uncomp - bytes_comp)*100)/(bytes_uncomp), nb_added_box_bytes);\n\n\t\tfprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes);\n\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err hash_file(char *name, u32 dump_std)\n{\n\tu32 i;\n\tu8 hash[20];\n\tGF_Err e = gf_media_get_file_hash(name, hash);\n\tif (e) return e;\n\tif (dump_std==2) {\n\t\tgf_fwrite(hash, 20, stdout);\n\t} else if (dump_std==1) {\n\t\tfor (i=0; i<20; i++) fprintf(stdout, \"%02X\", hash[i]);\n\t}\n\tfprintf(stderr, \"File hash (SHA-1): \");\n\tfor (i=0; i<20; i++) fprintf(stderr, \"%02X\", hash[i]);\n\tfprintf(stderr, \"\\n\");\n\n\treturn GF_OK;\n}\n\nstatic u32 do_raw_cat()\n{\n\tchar chunk[4096];\n\tFILE *fin, *fout;\n\ts64 to_copy, done;\n\tfin = gf_fopen(raw_cat, \"rb\");\n\tif (!fin) return mp4box_cleanup(1);\n\n\tfout = gf_fopen(inName, \"a+b\");\n\tif (!fout) {\n\t\tgf_fclose(fin);\n\t\treturn mp4box_cleanup(1);\n\t}\n\tgf_fseek(fin, 0, SEEK_END);\n\tto_copy = gf_ftell(fin);\n\tgf_fseek(fin, 0, SEEK_SET);\n\tdone = 0;\n\twhile (1) {\n\t\tu32 nb_bytes = (u32) gf_fread(chunk, 4096, fin);\n\t\tgf_fwrite(chunk, nb_bytes, fout);\n\t\tdone += nb_bytes;\n\t\tfprintf(stderr, \"Appending file %s - %02.2f done\\r\", raw_cat, 100.0*done/to_copy);\n\t\tif (done >= to_copy) break;\n\t}\n\tgf_fclose(fin);\n\tgf_fclose(fout);\n\treturn mp4box_cleanup(0);\n}\n\nstatic u32 do_write_udp()\n{\n\tGF_Err e;\n\tGF_Socket *sock = gf_sk_new(GF_SOCK_TYPE_UDP);\n\tu16 port = 2345;\n\tchar *sep = strrchr(udp_dest, ':');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tport = atoi(sep+1);\n\t}\n\te = gf_sk_bind( sock, \"127.0.0.1\", 0, udp_dest, port, 0);\n\tif (sep) sep[0] = ':';\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to bind socket to %s: %s\\n\", udp_dest, gf_error_to_string(e) ));\n\t} else {\n\t\te = gf_sk_send(sock, (u8 *) inName, (u32)strlen(inName));\n\t\tif (e)\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to send datagram: %s\\n\", gf_error_to_string(e) ));\n\t}\n\tgf_sk_del(sock);\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_MPD\nstatic u32 convert_mpd()\n{\n\tGF_Err e;\n\tBool remote = GF_FALSE;\n\tGF_MPD *mpd;\n\tchar *mpd_base_url = NULL;\n\tif (!strnicmp(inName, \"http://\", 7) || !strnicmp(inName, \"https://\", 8)) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS)\n\t\te = gf_dm_wget(inName, \"tmp_main.m3u8\", 0, 0, &mpd_base_url);\n\t\tif (e != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot retrieve M3U8 (%s): %s\\n\", inName, gf_error_to_string(e)));\n\t\t\tif (mpd_base_url) gf_free(mpd_base_url);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tremote = GF_TRUE;\n#else\n\t\tgf_free(mpd_base_url);\n\t\tM4_LOG(GF_LOG_ERROR, (\"HTTP Downloader disabled in this build\\n\"));\n\t\treturn mp4box_cleanup(1);\n#endif\n\n\t\tif (outName)\n\t\t\tstrcpy(outfile, outName);\n\t\telse {\n\t\t\tconst char *sep = gf_file_basename(inName);\n\t\t\tchar *ext = gf_file_ext_start(sep);\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tsprintf(outfile, \"%s.mpd\", sep);\n\t\t\tif (ext) ext[0] = '.';\n\t\t}\n\t} else {\n\t\tif (outName)\n\t\t\tstrcpy(outfile, outName);\n\t\telse {\n\t\t\tchar *dst = strdup(inName);\n\t\t\tchar *ext = strstr(dst, \".m3u8\");\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tsprintf(outfile, \"%s.mpd\", dst);\n\t\t\tgf_free(dst);\n\t\t}\n\t}\n\n\tmpd = gf_mpd_new();\n\tif (!mpd) {\n\t\te = GF_OUT_OF_MEM;\n\t\tM4_LOG(GF_LOG_ERROR, (\"[DASH] Error: MPD creation problem %s\\n\", gf_error_to_string(e)));\n\t\tmp4box_cleanup(1);\n\t}\n\tFILE *f = gf_fopen(remote ? \"tmp_main.m3u8\" : inName, \"r\");\n\tu32 manif_type = 0;\n\tif (f) {\n\t\tchar szDATA[1000];\n\t\ts32 read;\n\t\tszDATA[999]=0;\n\t\tread = (s32) gf_fread(szDATA, 999, f);\n\t\tif (read<0) read = 0;\n\t\tszDATA[read]=0;\n\t\tgf_fclose(f);\n\t\tif (strstr(szDATA, \"SmoothStreamingMedia\"))\n\t\t\tmanif_type = 2;\n\t\telse if (strstr(szDATA, \"#EXTM3U\"))\n\t\t\tmanif_type = 1;\n\t}\n\n\tif (manif_type==1) {\n\t\te = gf_m3u8_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd_base_url ? mpd_base_url : inName, outfile, 0, \"video/mp2t\", GF_TRUE, use_url_template, segment_timeline, NULL, mpd, GF_TRUE, GF_TRUE);\n\t} else if (manif_type==2) {\n\t\te = gf_mpd_smooth_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd, mpd_base_url ? mpd_base_url : inName);\n\t} else {\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\tif (!e)\n\t\tgf_mpd_write_file(mpd, outfile);\n\n\tif (mpd)\n\t\tgf_mpd_del(mpd);\n\tif (mpd_base_url)\n\t\tgf_free(mpd_base_url);\n\n\tif (remote) {\n\t\tgf_file_delete(\"tmp_main.m3u8\");\n\t}\n\tif (e != GF_OK) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error converting %s (%s) to MPD (%s): %s\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile, gf_error_to_string(e)));\n\t\treturn mp4box_cleanup(1);\n\t} else {\n\t\tM4_LOG(GF_LOG_INFO, (\"Done converting %s (%s) to MPD (%s)\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile));\n\t\treturn mp4box_cleanup(0);\n\t}\n}\n#endif\n\nstatic u32 do_import_sub()\n{\n\t/* We import the subtitle file,\n\t   i.e. we parse it and store the content as samples of a 3GPP Timed Text track in an ISO file,\n\t   possibly for later export (e.g. when converting SRT to TTXT, ...) */\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\tGF_Err e;\n\tGF_MediaImporter import;\n\t/* Prepare the importer */\n\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\tif (timescale && file) gf_isom_set_timescale(file, timescale);\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\timport.dest = file;\n\timport.in_name = inName;\n\t/* Start the import */\n\te = gf_media_import(&import);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\tgf_isom_delete(file);\n\t\tgf_file_delete(\"ttxt_convert\");\n\t\treturn mp4box_cleanup(1);\n\t}\n\t/* Prepare the export */\n\tstrcpy(outfile, inName);\n\tif (strchr(outfile, '.')) {\n\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\toutfile[strlen(outfile)-1] = 0;\n\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\t/* Start the export of the track #1, in the appropriate dump type, indicating it's a conversion */\n\tdump_isom_timed_text(file, gf_isom_get_track_id(file, 1),\n\t\t\t\t\t\t  dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t  GF_TRUE,\n\t\t\t\t\t\t  (import_subtitle==2) ? GF_TEXTDUMPTYPE_SVG : (dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT));\n#endif\n\t/* Clean the importer */\n\tgf_isom_delete(file);\n\tgf_file_delete(\"ttxt_convert\");\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error converting %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\treturn mp4box_cleanup(1);\n\t}\n\treturn mp4box_cleanup(0);\n#else\n\tM4_LOG(GF_LOG_ERROR, (\"Feature not supported\\n\"));\n\treturn mp4box_cleanup(1);\n#endif\n}\n\n#if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)\nstatic u32 do_add_cat(int argc, char **argv)\n{\n\tGF_Err e;\n\tu32 i, ipass, nb_pass = 1;\n\tchar *mux_args=NULL;\n\tGF_FilterSession *fs = NULL;\n\tif (nb_add) {\n\n\t\tGF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT;\n\t\tif (force_new) {\n\t\t\topen_mode = (do_flat || (force_new==2)) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t} else {\n\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\tif (!test) {\n\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\tif (!outName) outName = inName;\n\t\t\t} else {\n\t\t\t\tgf_fclose(test);\n\t\t\t\tif (! gf_isom_probe_file(inName) ) {\n\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\topen_edit = do_flat ? GF_FALSE : GF_TRUE;\n\t\tfile = gf_isom_open(inName, open_mode, NULL);\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\tif (freeze_box_order)\n\t\t\tgf_isom_freeze_order(file);\n\n\t\tif (do_flat) {\n\t\t\tif (major_brand)\n\t\t\t\tgf_isom_set_brand_info(file, major_brand, minor_version);\n\t\t\tfor (i=0; i<nb_alt_brand_add; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!major_brand && !nb_alt_brand_add && has_add_image) {\n\t\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MIF1, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (file && keep_utc && open_edit) {\n\t\tgf_isom_keep_utc_times(file, 1);\n\t}\n\n\tif (do_flat && interleaving_time) {\n\t\tchar szSubArg[100];\n\t\tgf_isom_set_storage_mode(file, GF_ISOM_STORE_FASTSTART);\n\t\tdo_flat = 2;\n\t\tnb_pass = 2;\n\t\tfs = gf_fs_new_defaults(0);\n\t\tif (!fs) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error creating filter session\\n\"));\n\t\t\tgf_isom_delete(file);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\t//mux args\n\t\tgf_dynstrcat(&mux_args, \"mp4mx:importer:store=fstart\", \":\");\n\n\t\tsprintf(szSubArg, \"file=%p\", file);\n\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t\tsprintf(szSubArg, \"cdur=%g\", interleaving_time);\n\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t}\n\n\tfor (ipass=0; ipass<nb_pass; ipass++) {\n\t\tu32 tk_idx = 1;\n\t\tfor (i=0; i<(u32) argc; i++) {\n\t\t\tchar *margs=NULL;\n\t\t\tif (!strcmp(argv[i], \"-add\")) {\n\t\t\t\tchar *src = argv[i+1];\n\n\t\t\t\twhile (src) {\n\t\t\t\t\tchar *loc_src = src;\n\t\t\t\t\tchar *sep = NULL;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tchar *opt_sep;\n\t\t\t\t\t\tsep = strchr(loc_src, '+');\n\t\t\t\t\t\tif (!sep) break;\n\n\t\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\t\tif (strstr(src, \"://\"))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\topt_sep = gf_url_colon_suffix(src);\n\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\topt_sep[0] = 0;\n\t\t\t\t\t\tif (gf_file_exists(src)) {\n\t\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\t\topt_sep[0] = ':';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\topt_sep[0] = ':';\n\n\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\tloc_src = sep+1;\n\t\t\t\t\t}\n\n\t\t\t\t\te = import_file(file, src, import_flags, import_fps, agg_samples, fs, (fs && (ipass==0)) ? &margs : NULL, tk_idx);\n\t\t\t\t\ttk_idx++;\n\n\t\t\t\t\tif (margs) {\n\t\t\t\t\t\tgf_dynstrcat(&mux_args, margs, \":\");\n\t\t\t\t\t\tgf_free(margs);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", argv[i+1], gf_error_to_string(e)));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tif (fs)\n\t\t\t\t\t\t\tgf_fs_del(fs);\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\tsrc = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(argv[i], \"-cat\") || !strcmp(argv[i], \"-catx\") || !strcmp(argv[i], \"-catpl\")) {\n\t\t\t\tif (nb_pass == 2) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot cat files when using -newfs mode\\n\"));\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t\tif (!file) {\n\t\t\t\t\tu8 open_mode = GF_ISOM_OPEN_EDIT;\n\t\t\t\t\tif (force_new) {\n\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\t\t\t\tif (!test) {\n\t\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse gf_fclose(test);\n\t\t\t\t\t}\n\n\t\t\t\t\topen_edit = GF_TRUE;\n\t\t\t\t\tfile = gf_isom_open(inName, open_mode, NULL);\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\te = cat_isomedia_file(file, argv[i+1], import_flags, import_fps, agg_samples, force_cat, align_cat, !strcmp(argv[i], \"-catx\") ? GF_TRUE : GF_FALSE, !strcmp(argv[i], \"-catpl\") ? GF_TRUE : GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error appending %s: %s\\n\", argv[i+1], gf_error_to_string(e)));\n\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif ((nb_pass == 2) && !ipass) {\n\t\t\tGF_Filter *mux_filter = gf_fs_load_filter(fs, mux_args, NULL);\n\t\t\tgf_free(mux_args);\n\t\t\tif (!mux_filter) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error loadin isobmff mux filter\\n\"));\n\t\t\t\tgf_isom_delete(file);\n\t\t\t\tgf_fs_del(fs);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\n\t\t\te = gf_fs_run(fs);\n\t\t\tif (e==GF_EOS) e = GF_OK;\n\n\t\t\tif (!e) e = gf_fs_get_last_connect_error(fs);\n\t\t\tif (!e) e = gf_fs_get_last_process_error(fs);\n\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing sources: %s\\n\", gf_error_to_string(e)));\n\t\t\t\tgf_isom_delete(file);\n\t\t\t\tgf_fs_del(fs);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (fs) {\n\t\tgf_fs_print_non_connected(fs);\n\t\tif (fs_dump_flags & 1) gf_fs_print_stats(fs);\n\t\tif (fs_dump_flags & 2) gf_fs_print_connections(fs);\n\t\tgf_fs_del(fs);\n\t}\n\n\t/*unless explicitly asked, remove all systems tracks*/\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (!keep_sys_tracks) remove_systems_tracks(file);\n#endif\n\tdo_save = GF_TRUE;\n\n\treturn 0;\n}\n#endif /*!GPAC_DISABLE_MEDIA_IMPORT && !GPAC_DISABLE_ISOM_WRITE*/\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\nstatic GF_Err do_scene_encode()\n{\n\tGF_Err e;\n\tFILE *logs = NULL;\n\tif (do_scene_log) {\n\t\tchar alogfile[GF_MAX_PATH];\n\t\tstrcpy(alogfile, inName);\n\t\tif (strchr(alogfile, '.')) {\n\t\t\twhile (alogfile[strlen(alogfile)-1] != '.') alogfile[strlen(alogfile)-1] = 0;\n\t\t\talogfile[strlen(alogfile)-1] = 0;\n\t\t}\n\t\tstrcat(alogfile, \"_enc.logs\");\n\t\tlogs = gf_fopen(alogfile, \"wt\");\n\t}\n\tstrcpy(outfile, outName ? outName : inName);\n\tif (strchr(outfile, '.')) {\n\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\toutfile[strlen(outfile)-1] = 0;\n\t}\n\tstrcat(outfile, \".mp4\");\n\tfile = gf_isom_open(outfile, GF_ISOM_WRITE_EDIT, NULL);\n\tsmenc_opts.mediaSource = mediaSource ? mediaSource : outfile;\n\te = EncodeFile(inName, file, &smenc_opts, logs);\n\tif (logs) gf_fclose(logs);\n\tif (e) return e;\n\tdo_save = GF_TRUE;\n\tif (do_saf) {\n\t\tdo_save = GF_FALSE;\n\t\topen_edit = GF_FALSE;\n\t}\n\treturn GF_OK;\n}\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n\nstatic GF_Err do_dash()\n{\n\tGF_Err e;\n\tu32 i;\n\tBool del_file = GF_FALSE;\n\tchar szMPD[GF_MAX_PATH], *sep;\n\tchar szStateFile[GF_MAX_PATH];\n\tBool dyn_state_file = GF_FALSE;\n\tu32 do_abort = 0;\n\tGF_DASHSegmenter *dasher=NULL;\n\n\tif (crypt) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"MP4Box cannot use -crypt and -dash in the same pass. Please encrypt your content first, or specify encryption filters on dash sources.\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tstrcpy(outfile, outName ? outName : gf_url_get_resource_name(inName) );\n\tsep = strrchr(outfile, '.');\n\tif (sep) sep[0] = 0;\n\tif (!outName) strcat(outfile, \"_dash\");\n\tstrcpy(szMPD, outfile);\n\tif (outName && sep) {\n\t\tsep[0] = '.';\n\t\tstrcat(szMPD, sep);\n\t} else {\n\t\tstrcat(szMPD, \".mpd\");\n\t}\n\n\tif ((dash_subduration>0) && (dash_duration > dash_subduration)) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: -subdur parameter (%g s) should be greater than segment duration (%g s), using segment duration instead\\n\", dash_subduration, dash_duration));\n\t\tdash_subduration = dash_duration;\n\t}\n\n\tif (dash_mode && dash_live)\n\t\tM4_LOG(GF_LOG_INFO, (\"Live DASH-ing - press 'q' to quit, 's' to save context and quit\\n\"));\n\n\tif (!dash_ctx_file && dash_live) {\n\t\tu32 r1;\n\t\tu64 add = (u64) (intptr_t) &dasher;\n\t\tadd ^= gf_net_get_utc();\n\t\tr1 = (u32) add ^ (u32) (add/0xFFFFFFFF);\n\t\tr1 ^= gf_rand();\n\t\tsprintf(szStateFile, \"%s/dasher_%X.xml\", gf_get_default_cache_directory(), r1 );\n\t\tdash_ctx_file = szStateFile;\n\t\tdyn_state_file = GF_TRUE;\n\t} else if (dash_ctx_file) {\n\t\tif (force_new)\n\t\t\tgf_file_delete(dash_ctx_file);\n\t}\n\n\tif (dash_profile==GF_DASH_PROFILE_AUTO)\n\t\tdash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL;\n\n\tif (!dash_mode) {\n\t\ttime_shift_depth = 0;\n\t\tmpd_update_time = 0;\n\t} else if ((dash_profile>=GF_DASH_PROFILE_MAIN) && !use_url_template && !mpd_update_time) {\n\t\t/*use a default MPD update of dash_duration sec*/\n\t\tmpd_update_time = (Double) (dash_subduration ? dash_subduration : dash_duration);\n\t\tM4_LOG(GF_LOG_INFO, (\"Using default MPD refresh of %g seconds\\n\", mpd_update_time));\n\t}\n\n\tif (file && do_save) {\n\t\tgf_isom_close(file);\n\t\tfile = NULL;\n\t\tdel_file = GF_TRUE;\n\t}\n\n\t/*setup dash*/\n\tdasher = gf_dasher_new(szMPD, dash_profile, NULL, dash_scale, dash_ctx_file);\n\tif (!dasher) {\n\t\treturn mp4box_cleanup(1);\n\t}\n\te = gf_dasher_set_info(dasher, dash_title, cprt, dash_more_info, dash_source, NULL);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));\n\t\tgf_dasher_del(dasher);\n\t\treturn e;\n\t}\n\n\tgf_dasher_set_start_date(dasher, dash_start_date);\n\tgf_dasher_set_location(dasher, dash_source);\n\tfor (i=0; i < nb_mpd_base_urls; i++) {\n\t\te = gf_dasher_add_base_url(dasher, mpd_base_urls[i]);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_dasher_del(dasher);\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tif (segment_timeline && !use_url_template) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"DASH Warning: using -segment-timeline with no -url-template. Forcing URL template.\\n\"));\n\t\tuse_url_template = GF_TRUE;\n\t}\n\n\te = gf_dasher_enable_url_template(dasher, (Bool) use_url_template, seg_name, seg_ext, init_seg_ext);\n\tif (!e) e = gf_dasher_enable_segment_timeline(dasher, segment_timeline);\n\tif (!e) e = gf_dasher_enable_single_segment(dasher, single_segment);\n\tif (!e) e = gf_dasher_enable_single_file(dasher, single_file);\n\tif (!e) e = gf_dasher_set_switch_mode(dasher, bitstream_switching_mode);\n\tif (!e) e = gf_dasher_set_durations(dasher, dash_duration, interleaving_time, dash_subduration);\n\tif (!e) e = gf_dasher_enable_rap_splitting(dasher, seg_at_rap, frag_at_rap);\n\tif (!e) e = gf_dasher_set_segment_marker(dasher, segment_marker);\n\tif (!e) e = gf_dasher_enable_sidx(dasher, (subsegs_per_sidx>=0) ? 1 : 0, (u32) subsegs_per_sidx, daisy_chain_sidx, use_ssix);\n\tif (!e) e = gf_dasher_set_dynamic_mode(dasher, dash_mode, mpd_update_time, time_shift_depth, mpd_live_duration);\n\tif (!e) e = gf_dasher_set_min_buffer(dasher, min_buffer);\n\tif (!e) e = gf_dasher_set_ast_offset(dasher, ast_offset_ms);\n\tif (!e) e = gf_dasher_enable_memory_fragmenting(dasher, memory_frags);\n\tif (!e) e = gf_dasher_set_initial_isobmf(dasher, initial_moof_sn, initial_tfdt);\n\tif (!e) e = gf_dasher_configure_isobmf_default(dasher, no_fragments_defaults, pssh_mode, samplegroups_in_traf, single_traf_per_moof, tfdt_per_traf, mvex_after_traks, sdtp_in_traf);\n\tif (!e) e = gf_dasher_enable_utc_ref(dasher, insert_utc);\n\tif (!e) e = gf_dasher_enable_real_time(dasher, frag_real_time);\n\tif (!e) e = gf_dasher_set_content_protection_location_mode(dasher, cp_location_mode);\n\tif (!e) e = gf_dasher_set_profile_extension(dasher, dash_profile_extension);\n\tif (!e) e = gf_dasher_enable_cached_inputs(dasher, no_cache);\n\tif (!e) e = gf_dasher_enable_loop_inputs(dasher, ! no_loop);\n\tif (!e) e = gf_dasher_set_split_mode(dasher, dash_split_mode);\n\tif (!e) e = gf_dasher_set_last_segment_merge(dasher, merge_last_seg);\n\tif (!e) e = gf_dasher_set_hls_clock(dasher, hls_clock);\n\tif (!e && dash_cues) e = gf_dasher_set_cues(dasher, dash_cues, strict_cues);\n\tif (!e) e = gf_dasher_print_session_info(dasher, fs_dump_flags);\n\tif (!e)  e = gf_dasher_keep_source_utc(dasher, keep_utc);\n\n\tfor (i=0; i < nb_dash_inputs; i++) {\n\t\tif (!e) e = gf_dasher_add_input(dasher, &dash_inputs[i]);\n\t}\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Setup Error: %s\\n\", gf_error_to_string(e)));\n\t\tgf_dasher_del(dasher);\n\t\treturn e;\n\t}\n\n\tdash_cumulated_time=0;\n\n\twhile (1) {\n\t\tif (run_for && (dash_cumulated_time >= run_for)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Done running, computing static MPD\\n\"));\n\t\t\tdo_abort = 3;\n\t\t}\n\n\t\tdash_prev_time=gf_sys_clock();\n\t\tif (do_abort>=2) {\n\t\t\te = gf_dasher_set_dynamic_mode(dasher, GF_DASH_DYNAMIC_LAST, 0, time_shift_depth, mpd_live_duration);\n\t\t}\n\n\t\tif (!e) e = gf_dasher_process(dasher);\n\t\tif (!dash_live && (e==GF_EOS) ) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Nothing to dash, too early ...\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\n\t\tif (do_abort)\n\t\t\tbreak;\n\n\t\t//this happens when reading file while writing them (local playback of the live session ...)\n\t\tif (dash_live && (e==GF_IO_ERR) ) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error dashing file (%s) but continuing ...\\n\", gf_error_to_string(e) ));\n\t\t\te = GF_OK;\n\t\t}\n\n\t\tif (e) break;\n\n\t\tif (dash_live) {\n\t\t\tu64 ms_in_session=0;\n\t\t\tu32 slept = gf_sys_clock();\n\t\t\tu32 sleep_for = gf_dasher_next_update_time(dasher, &ms_in_session);\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Next generation scheduled in %u ms (DASH time \"LLU\" ms)\\r\", sleep_for, ms_in_session));\n\t\t\tif (run_for && (ms_in_session>=run_for)) {\n\t\t\t\tdash_cumulated_time = 1+run_for;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (1) {\n\t\t\t\tif (gf_prompt_has_input()) {\n\t\t\t\t\tchar c = (char) gf_prompt_get_char();\n\t\t\t\t\tif (c=='X') {\n\t\t\t\t\t\tdo_abort = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='q') {\n\t\t\t\t\t\tdo_abort = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='s') {\n\t\t\t\t\t\tdo_abort = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dash_mode == GF_DASH_DYNAMIC_DEBUG) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!sleep_for) break;\n\n\t\t\t\tgf_sleep(sleep_for/10);\n\t\t\t\tsleep_for = gf_dasher_next_update_time(dasher, NULL);\n\t\t\t\tif (sleep_for<=1) {\n\t\t\t\t\tdash_now_time=gf_sys_clock();\n\t\t\t\t\tdash_cumulated_time+=(dash_now_time-dash_prev_time);\n\t\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Slept for %d ms before generation, dash cumulated time %d\\n\", dash_now_time - slept, dash_cumulated_time));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgf_dasher_del(dasher);\n\n\tif (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {\n\t\tchar szName[1024];\n\t\tM4_LOG(GF_LOG_INFO, (\"Enter file name to save dash context:\\n\"));\n\t\tif (scanf(\"%1023s\", szName) == 1) {\n\t\t\tgf_file_move(dash_ctx_file, szName);\n\t\t}\n\t}\n\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error DASHing file: %s\\n\", gf_error_to_string(e)));\n\tif (file) gf_isom_delete(file);\n\tif (del_file)\n\t\tgf_file_delete(inName);\n\n\treturn e;\n}\n\n\nstatic GF_Err do_export_tracks_non_isobmf()\n{\n\tu32 i;\n\n\tGF_MediaExporter mdump;\n\tchar szFile[GF_MAX_PATH+24];\n\tfor (i=0; i<nb_track_act; i++) {\n\t\tGF_Err e;\n\t\tTrackAction *tka = &tracks[i];\n\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.in_name = inName;\n\t\tmdump.flags = tka->dump_type;\n\t\tmdump.trackID = tka->trackID;\n\t\tmdump.track_type = tka->dump_track_type;\n\t\tmdump.sample_num = tka->sample_num;\n\n\t\tif (dump_std) {\n\t\t\tmdump.out_name = \"std\";\n\t\t}\n\t\telse if (outName) {\n\t\t\tmdump.out_name = outName;\n\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t} else if (nb_track_act>1) {\n\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\tmdump.out_name = szFile;\n\t\t} else {\n\t\t\tmdump.out_name = outfile;\n\t\t}\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err do_dump_iod()\n{\n\tGF_Err e = GF_OK;\n\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\tif (!iod) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"File %s has no IOD\\n\", inName));\n\t} else {\n\t\tchar szName[GF_MAX_PATH+10];\n\t\tFILE *iodf;\n\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\tiodf = gf_fopen(szName, \"wb\");\n\t\tif (!iodf) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination %s\\n\", szName));\n\t\t\te = GF_IO_ERR;\n\t\t} else {\n\t\t\tu8 *desc;\n\t\t\tu32 size;\n\t\t\tGF_BitStream *bs = gf_bs_from_file(iodf, GF_BITSTREAM_WRITE);\n\t\t\tif (gf_odf_desc_write((GF_Descriptor *)iod, &desc, &size)==GF_OK) {\n\t\t\t\tgf_fwrite(desc, size, iodf);\n\t\t\t\tgf_free(desc);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error writing IOD %s\\n\", szName));\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_fclose(iodf);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor*)iod);\n\t}\n\treturn e;\n}\n\nstatic GF_Err do_export_tracks()\n{\n\tGF_Err e;\n\tu32 i;\n\tchar szFile[GF_MAX_PATH+24];\n\tGF_MediaExporter mdump;\n\tfor (i=0; i<nb_track_act; i++) {\n\t\tu32 j;\n\t\tTrackAction *tka = &tracks[i];\n\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.file = file;\n\t\tmdump.flags = tka->dump_type;\n\t\tmdump.trackID = tka->trackID;\n\t\tmdump.sample_num = tka->sample_num;\n\t\tif (tka->out_name) {\n\t\t\tmdump.out_name = tka->out_name;\n\t\t} else if (outName) {\n\t\t\tmdump.out_name = outName;\n\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t\t/*don't infer extension on user-given filename*/\n\t\t\tmdump.flags |= GF_EXPORT_NO_FILE_EXT;\n\t\t} else if (mdump.trackID) {\n\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\tmdump.out_name = szFile;\n\t\t} else {\n\t\t\tsprintf(szFile, \"%s_export\", outfile);\n\t\t\tmdump.out_name = szFile;\n\t\t}\n\t\tif (tka->trackID==(u32) -1) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\tmdump.trackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\t\tmdump.out_name = szFile;\n\t\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\t\te = gf_media_export(&mdump);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t} else {\n\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\te = gf_media_export(&mdump);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_meta_act()\n{\n\tu32 i;\n\tfor (i=0; i<nb_meta_act; i++) {\n\t\tGF_Err e = GF_OK;\n\t\tu32 tk = 0;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tBool self_ref;\n#endif\n\t\tMetaAction *meta = &metas[i];\n\n\t\tif (meta->trackID) tk = gf_isom_get_track_by_id(file, meta->trackID);\n\n\t\tswitch (meta->act_type) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tcase META_ACTION_SET_TYPE:\n\t\t\t/*note: we don't handle file brand modification, this is an author stuff and cannot be guessed from meta type*/\n\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);\n\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_ITEM:\n\t\t\tself_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");\n\t\t\te = gf_isom_add_meta_item(file, meta->root_meta, tk, self_ref, self_ref ? NULL : meta->szPath,\n\t\t\t                          meta->szName,\n\t\t\t                          meta->item_id,\n\t\t\t\t\t\t\t\t\t  meta->item_type,\n\t\t\t                          meta->mime_type,\n\t\t\t                          meta->enc_type,\n\t\t\t                          meta->use_dref ? meta->szPath : NULL,  NULL,\n\t\t\t                          meta->image_props);\n\t\t\tif (meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\tu32 ref_i;\n\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_IMAGE_ITEM:\n\t\t{\n\t\t\tu32 old_tk_count = gf_isom_get_track_count(file);\n\t\t\tu32 src_tk_id = 1;\n\t\t\tGF_Fraction _frac = {0,0};\n\t\t\tGF_ISOFile *fsrc = file;\n\t\t\tself_ref = GF_FALSE;\n\n\t\t\ttk = 0;\n\t\t\tif (meta->image_props && meta->image_props->auto_grid) {\n\t\t\t\te = GF_OK;\n\t\t\t\tself_ref = GF_TRUE;\n\t\t\t} else if (!meta->szPath || (meta->image_props && meta->image_props->sample_num && meta->image_props->use_reference)) {\n\t\t\t\te = GF_OK;\n\t\t\t\tself_ref = GF_TRUE;\n\t\t\t\tsrc_tk_id = meta->trackID;\n\t\t\t} else if (meta->szPath) {\n\t\t\t\tif (meta->image_props && gf_isom_probe_file(meta->szPath) && !meta->image_props->tile_mode) {\n\t\t\t\t\tmeta->image_props->src_file = gf_isom_open(meta->szPath, GF_ISOM_OPEN_READ, NULL);\n\t\t\t\t\te = gf_isom_last_error(meta->image_props->src_file);\n\t\t\t\t\tfsrc = meta->image_props->src_file;\n\t\t\t\t} else {\n\t\t\t\t\te = import_file(file, meta->szPath, 0, _frac, 0, NULL, NULL, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing file name to import\\n\"));\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t\tif (e == GF_OK) {\n\t\t\t\tu32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);\n\t\t\t\tif (!meta_type) {\n\t\t\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);\n\t\t\t\t} else {\n\t\t\t\t\tif (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\tif (!meta->item_id) {\n\t\t\t\t\t\te = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);\n\t\t\t\t\t}\n\t\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\t\tif (!src_tk_id) {\n\t\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\t\tfor (j=0; j<gf_isom_get_track_count(fsrc); j++) {\n\t\t\t\t\t\t\t\tif (gf_isom_is_video_handler_type (gf_isom_get_media_type(fsrc, j+1))) {\n\t\t\t\t\t\t\t\t\tsrc_tk_id = gf_isom_get_track_id(fsrc, j+1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!src_tk_id) {\n\t\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"No video track in file, cannot add image from track\\n\"));\n\t\t\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te = gf_isom_iff_create_image_item_from_track(file, meta->root_meta, tk, src_tk_id, meta->szName, meta->item_id, meta->image_props, NULL);\n\t\t\t\t\t\tif (e == GF_OK && meta->primary) {\n\t\t\t\t\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\t\t\t\tu32 ref_i;\n\t\t\t\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e == GF_OK && meta->group_type) {\n\t\t\t\t\t\t\te = gf_isom_meta_add_item_group(file, meta->root_meta, tk, meta->item_id, meta->group_id, meta->group_type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (meta->image_props && meta->image_props->src_file) {\n\t\t\t\tgf_isom_delete(meta->image_props->src_file);\n\t\t\t\tmeta->image_props->src_file = NULL;\n\t\t\t} else if (!self_ref) {\n\t\t\t\tgf_isom_remove_track(file, old_tk_count+1);\n\t\t\t\tif (do_flat) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: -flat storage cannot be used when using -add-image on external file\\n\"));\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_IMAGE_GRID:\n\t\t{\n\t\t\tu32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);\n\t\t\te = GF_OK;\n\t\t\tif (!meta_type) {\n\t\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);\n\t\t\t} else {\n\t\t\t\tif (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e == GF_OK) {\n\t\t\t\tif (!meta->item_id) {\n\t\t\t\t\te = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);\n\t\t\t\t}\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\te = gf_isom_iff_create_image_grid_item(file, meta->root_meta, tk,\n\t\t\t\t\t\t\tmeta->szName && strlen(meta->szName) ? meta->szName : NULL,\n\t\t\t\t\t\t\tmeta->item_id,\n\t\t\t\t\t\t\tmeta->image_props);\n\t\t\t\t\tif (e == GF_OK && meta->primary) {\n\t\t\t\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\t\t\t}\n\t\t\t\t\tif (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\t\t\tu32 ref_i;\n\t\t\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_ITEM:\n\t\t\te = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_PRIMARY_ITEM:\n\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_XML:\n\t\tcase META_ACTION_SET_BINARY_XML:\n\t\t\te = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_XML:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_remove_meta_xml(file, meta->root_meta, tk);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_DUMP_ITEM:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_item(file, meta->root_meta, tk, meta->item_id, meta->szPath && strlen(meta->szPath) ? meta->szPath : NULL);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\t\tcase META_ACTION_DUMP_XML:\n\t\t\tif (gf_isom_has_meta_xml(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (meta->item_refs) {\n\t\t\twhile (gf_list_count(meta->item_refs)) {\n\t\t\t\tgf_free(gf_list_pop_back(meta->item_refs));\n\t\t\t}\n\t\t\tgf_list_del(meta->item_refs);\n\t\t\tmeta->item_refs = NULL;\n\t\t}\n\t\tif (meta->image_props) {\n\t\t\tgf_free(meta->image_props);\n\t\t\tmeta->image_props = NULL;\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_tsel_act()\n{\n\tu32 i;\n\tGF_Err e;\n\tfor (i=0; i<nb_tsel_acts; i++) {\n\t\tswitch (tsel_acts[i].act_type) {\n\t\tcase TSEL_ACTION_SET_PARAM:\n\t\t\te = gf_isom_set_track_switch_parameter(file,\n\t\t\t                                       gf_isom_get_track_by_id(file, tsel_acts[i].trackID),\n\t\t\t                                       tsel_acts[i].refTrackID ? gf_isom_get_track_by_id(file, tsel_acts[i].refTrackID) : 0,\n\t\t\t                                       tsel_acts[i].is_switchGroup ? 1 : 0,\n\t\t\t                                       &tsel_acts[i].switchGroupID,\n\t\t\t                                       tsel_acts[i].criteria, tsel_acts[i].nb_criteria);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tu32 alternateGroupID, nb_groups;\n\t\t\t\tgf_isom_get_track_switch_group_count(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), &alternateGroupID, &nb_groups);\n\t\t\t\tif (alternateGroupID) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - for adding more tracks to group, using: -group-add -refTrack=ID1:[criteria:]trackID=ID2\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - for creating a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_TSEL:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic void do_ipod_conv()\n{\n\tu32 i, ipod_major_brand = 0;\n\tM4_LOG(GF_LOG_INFO, (\"Setting up iTunes/iPod file\\n\"));\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tu32 mType = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\tipod_major_brand = GF_ISOM_BRAND_M4V;\n\t\t\tgf_isom_set_ipod_compatible(file, i+1);\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (!ipod_major_brand) ipod_major_brand = GF_ISOM_BRAND_M4A;\n\t\t\telse gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_M4A, GF_TRUE);\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\t/*this is a text track track*/\n\t\t\tif (gf_isom_get_media_subtype(file, i+1, 1) == GF_ISOM_SUBTYPE_TX3G) {\n\t\t\t\tBool is_chap = 0;\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\t\ts32 count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_CHAP);\n\t\t\t\t\tif (count>0) {\n\t\t\t\t\t\tu32 tk, k;\n\t\t\t\t\t\tfor (k=0; k<(u32) count; k++) {\n\t\t\t\t\t\t\tgf_isom_get_reference(file, j+1, GF_ISOM_REF_CHAP, k+1, &tk);\n\t\t\t\t\t\t\tif (tk==i+1) {\n\t\t\t\t\t\t\t\tis_chap = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_chap) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (is_chap) break;\n\t\t\t\t}\n\t\t\t\t/*this is a subtitle track*/\n\t\t\t\tif (!is_chap)\n\t\t\t\t\tgf_isom_set_media_type(file, i+1, GF_ISOM_MEDIA_SUBT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_isom_set_brand_info(file, ipod_major_brand, 1);\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);\n\tdo_save = GF_TRUE;\n}\n\nstatic GF_Err do_track_act()\n{\n\tu32 j;\n\tfor (j=0; j<nb_track_act; j++) {\n\t\tu32 i;\n\t\tGF_Err e = GF_OK;\n\t\tTrackAction *tka = &tracks[j];\n\t\tu32 track = tka->trackID ? gf_isom_get_track_by_id(file, tka->trackID) : 0;\n\n\t\ttimescale = gf_isom_get_timescale(file);\n\t\tswitch (tka->act_type) {\n\t\tcase TRAC_ACTION_REM_TRACK:\n\t\t\te = gf_isom_remove_track(file, track);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e)));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Removing track ID %d\\n\", tka->trackID));\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_LANGUAGE:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_set_media_language(file, i+1, tka->lang);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_DELAY:\n\t\t\tif (tka->delay.num && tka->delay.den) {\n\t\t\t\tu64 tk_dur;\n\n\t\t\t\te = gf_isom_remove_edits(file, track);\n\t\t\t\tif (e) return e;\n\t\t\t\ttk_dur = gf_isom_get_track_duration(file, track);\n\t\t\t\tif (gf_isom_get_edits_count(file, track))\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\tif (tka->delay.num>0) {\n\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\te = gf_isom_append_edit(file, track, ((u64) tka->delay.num) * timescale / tka->delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\tu64 to_skip = ((u64) -tka->delay.num) * timescale / tka->delay.den;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\t\tu64 media_time = ((u64) -tka->delay.num) * gf_isom_get_media_timescale(file, track) / tka->delay.den;\n\t\t\t\t\t\te = gf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (gf_isom_get_edits_count(file, track)) {\n\t\t\t\te = gf_isom_remove_edits(file, track);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KMS_URI:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\tif (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;\n\t\t\t\tif (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;\n\t\t\t\te = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_ID:\n\t\t\tif (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\"));\n\t\t\t\ttrack = 1;\n\t\t\t}\n\t\t\tif (track) {\n\t\t\t\tu32 newTrack;\n\t\t\t\tnewTrack = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (newTrack != 0) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, track, tka->newTrackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SWAP_ID:\n\t\t\tif (track) {\n\t\t\t\tu32 tk1, tk2;\n\t\t\t\ttk1 = gf_isom_get_track_by_id(file, tka->trackID);\n\t\t\t\ttk2 = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (!tk1 || !tk2) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot swap track IDs because not existing - ignoring\"));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, tk2, 0);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_set_track_id(file, tk1, tka->newTrackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_set_track_id(file, tk2, tka->trackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_PAR:\n\t\t\te = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_CLAP:\n\t\t\te = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_MX:\n\t\t\te = gf_isom_set_track_matrix(file, track, tka->mx);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_HANDLER_NAME:\n\t\t\te = gf_isom_set_handler_name(file, track, tka->hdl_name);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_ENABLE:\n\t\t\tif (!gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_TRUE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_DISABLE:\n\t\t\tif (gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_FALSE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REFERENCE:\n\t\t\te = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_RAP:\n\t\t\te = gf_media_remove_non_rap(file, track, GF_FALSE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_REFS:\n\t\t\te = gf_media_remove_non_rap(file, track, GF_TRUE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_UDTA:\n\t\t\te = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_EDITS:\n\t\t\te = apply_edits(file, track, tka->string);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_TIME:\n\t\t\tif (!tka->trackID) {\n\t\t\t\te = gf_isom_set_creation_time(file, tka->time, tka->time);\n\t\t\t\tif (e) return e;\n\t\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\t\te = gf_isom_set_track_creation_time(file, i+1, tka->time, tka->time);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_track_creation_time(file, track, tka->time, tka->time);\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_MEDIA_TIME:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_set_media_creation_time(file, i+1, tka->time, tka->time);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_itunes_tag()\n{\n\tGF_Err e;\n\tchar *itunes_data = NULL;\n\tchar *tags = itunes_tags;\n\n\tif (gf_file_exists(itunes_tags)) {\n\t\tu32 len;\n\t\te = gf_file_load_data(itunes_tags, (u8 **) &itunes_data, &len);\n\t\tif (e) return e;;\n\t\ttags = itunes_data;\n\t}\n\n\twhile (tags) {\n\t\tchar *val;\n\t\tBool clear = GF_FALSE;\n\t\tBool is_wma = GF_FALSE;\n\t\tu32 tlen, tagtype=0, itag = 0;\n\t\ts32 tag_idx;\n\t\tchar *sep = itunes_data ? strchr(tags, '\\n') : gf_url_colon_suffix(tags);\n\t\twhile (sep) {\n\t\t\tchar *eq = strchr(sep+1, '=');\n\t\t\tif (eq) eq[0] = 0;\n\t\t\ts32 next_tag_idx = gf_itags_find_by_name(sep+1);\n\t\t\tif ((next_tag_idx<0) && strlen(sep+1)==4)\n\t\t\t\tnext_tag_idx = 0;\n\n\t\t\tif (eq) eq[0] = '=';\n\t\t\tif (next_tag_idx>=0) {\n\t\t\t\tsep[0] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = itunes_data ? strchr(sep+1, '\\n') : gf_url_colon_suffix(sep+1);\n\t\t}\n\t\tval = strchr(tags, '=');\n\t\tif (val) val[0] = 0;\n\t\tif (!strcmp(tags, \"clear\") || !strcmp(tags, \"reset\")) {\n\t\t\tclear = GF_TRUE;\n\t\t} else if (!strncmp(tags, \"WM/\", 3) ) {\n\t\t\tis_wma = GF_TRUE;\n\t\t} else {\n\t\t\ttag_idx = gf_itags_find_by_name(tags);\n\t\t\tif (tag_idx<0) {\n\t\t\t\tif (strlen(tags)==4) {\n\t\t\t\t\titag = GF_4CC(tags[0], tags[1], tags[2], tags[3]);\n\t\t\t\t\ttagtype = GF_ITAG_STR;\n\t\t\t\t} else if (strlen(tags)==3) {\n\t\t\t\t\titag = GF_4CC(0xA9, tags[0], tags[1], tags[2]);\n\t\t\t\t\ttagtype = GF_ITAG_STR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (val) {\n\t\t\tval[0] = '=';\n\t\t\tval++;\n\t\t}\n\t\tif (!itag && !clear && !is_wma) {\n\t\t\tif (tag_idx<0) {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Invalid iTune tag name \\\"%s\\\" - ignoring\\n\", tags));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t\ttagtype = gf_itags_get_type(tag_idx);\n\t\t}\n\t\tif (!val || (val[0]==':') || !val[0] || !stricmp(val, \"NULL\") ) val = NULL;\n\n\t\ttlen = val ? (u32) strlen(val) : 0;\n\t\tif (clear) {\n\t\t\te = gf_isom_apple_set_tag(file, GF_ISOM_ITUNE_RESET, NULL, 0, 0, 0);\n\t\t}\n\t\telse if (is_wma) {\n\t\t\tif (val) val[-1] = 0;\n\t\t\te = gf_isom_wma_set_tag(file, tags, val);\n\t\t\tif (val) val[-1] = '=';\n\t\t}\n\t\telse if (val && (tagtype==GF_ITAG_FILE)) {\n\t\t\tu32 flen = (u32) strlen(val);\n\t\t\tu8 *d=NULL;\n\t\t\twhile (flen && val[flen-1]=='\\n') flen--;\n\t\t\tval[flen] = 0;\n\t\t\te = gf_file_load_data(val, (u8 **) &d, &tlen);\n\t\t\tval[flen] = '\\n';\n\n\t\t\tif (!e)\n\t\t\t\te = gf_isom_apple_set_tag(file, itag, d, tlen, 0, 0);\n\n\t\t\tif (d) gf_free(d);\n\t\t} else {\n\t\t\te = gf_isom_apple_set_tag(file, itag, (u8 *) val, tlen, 0, 0);\n\t\t}\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error assigning tag %s: %s\\n\", tags, gf_error_to_string(e) ));\n\t\t}\n\n\t\tdo_save = GF_TRUE;\n\n\t\tif (sep) {\n\t\t\tsep[0] = itunes_data ? '\\n' : ':';\n\t\t\ttags = sep+1;\n\t\t} else {\n\t\t\ttags = NULL;\n\t\t}\n\t}\n\tif (itunes_data) gf_free(itunes_data);\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)\nstatic void set_sdp_ext()\n{\n\tu32 i, j;\n\tfor (i=0; i<nb_sdp_ex; i++) {\n\t\tif (sdp_lines[i].trackID) {\n\t\t\tu32 track = gf_isom_get_track_by_id(file, sdp_lines[i].trackID);\n\t\t\tif (gf_isom_get_media_type(file, track)!=GF_ISOM_MEDIA_HINT) {\n\t\t\t\ts32 ref_count;\n\t\t\t\tu32 k, count = gf_isom_get_track_count(file);\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\tif (gf_isom_get_media_type(file, j+1)!=GF_ISOM_MEDIA_HINT) continue;\n\t\t\t\t\tref_count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_HINT);\n\t\t\t\t\tif (ref_count<0) continue;\n\t\t\t\t\tfor (k=0; k<(u32) ref_count; k++) {\n\t\t\t\t\t\tu32 refTk;\n\t\t\t\t\t\tif (gf_isom_get_reference(file, j+1, GF_ISOM_REF_HINT, k+1, &refTk)) continue;\n\t\t\t\t\t\tif (refTk==track) {\n\t\t\t\t\t\t\ttrack = j+1;\n\t\t\t\t\t\t\tj=count;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);\n\t\t\tdo_save = GF_TRUE;\n\t\t} else {\n\t\t\tgf_isom_sdp_add_line(file, sdp_lines[i].line);\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t}\n}\n#endif /*!defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)*/\n\nstatic GF_Err do_remux_file()\n{\n\tGF_MediaExporter mdump;\n\tmemset(&mdump, 0, sizeof(GF_MediaExporter));\n\tmdump.in_name = inName;\n\tmdump.out_name = mux_name;\n\tmdump.flags = GF_EXPORT_REMUX;\n\tmdump.print_stats_graph = fs_dump_flags;\n\treturn gf_media_export(&mdump);\n}\n\nstatic u32 mp4box_cleanup(u32 ret_code) {\n\tif (mpd_base_urls) {\n\t\tgf_free(mpd_base_urls);\n\t\tmpd_base_urls = NULL;\n\t}\n\tif (sdp_lines) {\n\t\tgf_free(sdp_lines);\n\t\tsdp_lines = NULL;\n\t}\n\tif (metas) {\n\t\tu32 i;\n\t\tfor (i=0; i<nb_meta_act; i++) {\n\t\t\tif (metas[i].enc_type) gf_free(metas[i].enc_type);\n\t\t\tif (metas[i].mime_type) gf_free(metas[i].mime_type);\n\t\t\tif (metas[i].szName) gf_free(metas[i].szName);\n\t\t\tif (metas[i].szPath) gf_free(metas[i].szPath);\n\t\t}\n\t\tgf_free(metas);\n\t\tmetas = NULL;\n\t}\n\tif (tracks) {\n\t\tu32 i;\n\t\tfor (i = 0; i<nb_track_act; i++) {\n\t\t\tif (tracks[i].out_name)\n\t\t\t\tgf_free(tracks[i].out_name);\n\t\t\tif (tracks[i].src_name)\n\t\t\t\tgf_free(tracks[i].src_name);\n\t\t\tif (tracks[i].string)\n\t\t\t\tgf_free(tracks[i].string);\n\t\t\tif (tracks[i].kind_scheme)\n\t\t\t\tgf_free(tracks[i].kind_scheme);\n\t\t\tif (tracks[i].kind_value)\n\t\t\t\tgf_free(tracks[i].kind_value);\n\t\t}\n\t\tgf_free(tracks);\n\t\ttracks = NULL;\n\t}\n\tif (tsel_acts) {\n\t\tgf_free(tsel_acts);\n\t\ttsel_acts = NULL;\n\t}\n\tif (brand_add) {\n\t\tgf_free(brand_add);\n\t\tbrand_add = NULL;\n\t}\n\tif (brand_rem) {\n\t\tgf_free(brand_rem);\n\t\tbrand_rem = NULL;\n\t}\n\tif (dash_inputs) {\n\t\tu32 i, j;\n\t\tfor (i = 0; i<nb_dash_inputs; i++) {\n\t\t\tGF_DashSegmenterInput *di = &dash_inputs[i];\n\t\t\tif (di->nb_baseURL) {\n\t\t\t\tfor (j = 0; j<di->nb_baseURL; j++) {\n\t\t\t\t\tgf_free(di->baseURL[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->baseURL);\n\t\t\t}\n\t\t\tif (di->rep_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_rep_descs; j++) {\n\t\t\t\t\tgf_free(di->rep_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->rep_descs);\n\t\t\t}\n\t\t\tif (di->as_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_as_descs; j++) {\n\t\t\t\t\tgf_free(di->as_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->as_descs);\n\t\t\t}\n\t\t\tif (di->as_c_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_as_c_descs; j++) {\n\t\t\t\t\tgf_free(di->as_c_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->as_c_descs);\n\t\t\t}\n\t\t\tif (di->p_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_p_descs; j++) {\n\t\t\t\t\tgf_free(di->p_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->p_descs);\n\t\t\t}\n\t\t\tif (di->representationID) gf_free(di->representationID);\n\t\t\tif (di->periodID) gf_free(di->periodID);\n\t\t\tif (di->xlink) gf_free(di->xlink);\n\t\t\tif (di->seg_template) gf_free(di->seg_template);\n\t\t\tif (di->hls_pl) gf_free(di->hls_pl);\n\t\t\tif (di->source_opts) gf_free(di->source_opts);\n\t\t\tif (di->filter_chain) gf_free(di->filter_chain);\n\n\t\t\tif (di->roles) {\n\t\t\t\tfor (j = 0; j<di->nb_roles; j++) {\n\t\t\t\t\tgf_free(di->roles[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->roles);\n\t\t\t}\n\t\t}\n\t\tgf_free(dash_inputs);\n\t\tdash_inputs = NULL;\n\t}\n\tif (logfile) gf_fclose(logfile);\n\tgf_sys_close();\n\treturn ret_code;\n}\n\n\n\nint mp4boxMain(int argc, char **argv)\n{\n\tu32 i, j;\n\tconst char *gpac_profile = \"0\";\n\tGF_Err e = GF_OK;\n\n#ifdef TEST_ARGS\n\ti=0;\n\tmp4box_parse_single_arg(argc, argv, \"\", &i);\n#endif\n\n\tfor (i = 1; i < (u32) argc ; i++) {\n\t\tif (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(argv[i], \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", argv[i]));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-p\")) {\n\t\t\tif (i+1<(u32) argc)\n\t\t\t\tgpac_profile = argv[i+1];\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad argument for -p, expecting profile name but no more args\\n\"));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(argv[i], \"-p=\", 3))\n\t\t\tgpac_profile = argv[i]+3;\n\t}\n\n#ifdef _TWO_DIGIT_EXPONENT\n\t_set_output_format(_TWO_DIGIT_EXPONENT);\n#endif\n\n\t/*init libgpac*/\n\tgf_sys_init(mem_track, gpac_profile);\n\tif (argc < 2) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Not enough arguments - check usage with -h\\n\"));\n\t\tM4_LOG(GF_LOG_INFO, (\"MP4Box - GPAC version %s\\n\"\n\t        \"%s\\n\", gf_gpac_version(), gf_gpac_copyright_cite() ));\n\t\tgf_sys_close();\n\t\treturn 0;\n\t}\n\n\thelpout = stdout;\n\n\ti = mp4box_parse_args(argc, argv);\n\tif (i) {\n\t\treturn mp4box_cleanup(i - 1);\n\t}\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\tif (live_scene) {\n\t\tint ret = live_session(argc, argv);\n\t\treturn mp4box_cleanup(ret);\n\t}\n#endif\n\n\tif (!dash_duration && interleaving_time && do_frag)\n\t\tinterleaving_time /= 1000;\n\n\tif (do_mpd_conv) inName = do_mpd_conv;\n\n\tif (import_flags & GF_IMPORT_FORCE_MPEG4)\n\t\thint_flags |= GP_RTP_PCK_FORCE_MPEG4;\n\n\tif (!inName && dump_std)\n\t\tinName = \"std\";\n\n\tif (!dash_duration && cprt)\n\t\topen_edit = GF_TRUE;\n\n\tif (!inName) {\n\t\tif (has_next_arg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Broken argument specifier or file name missing - check usage with -h\\n\"));\n\t\t} else {\n\t\t\tPrintUsage();\n\t\t}\n\t\treturn mp4box_cleanup(1);\n\t}\n\tif (!strcmp(inName, \"std\")) dump_std = 2;\n\tif (!strcmp(inName, \"stdb\")) {\n\t\tinName = \"std\";\n\t\tdump_std = 1;\n\t}\n\n\tif (!interleaving_time) {\n\t\t/*by default use single fragment per dash segment*/\n\t\tif (dash_duration)\n\t\t\tinterleaving_time = dash_duration;\n\t\telse if (!do_flat) {\n\t\t\tinterleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\t}\n\t}\n\n\tif (dump_std)\n\t\toutName = \"std\";\n\n\tif (dump_std==2) {\n#ifdef WIN32\n\t\tif ( _setmode(_fileno(stdout), _O_BINARY) == -1 )\n#else\n\t\tif ( freopen(NULL, \"wb\", stdout) == NULL)\n#endif\n\t\t{\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Fatal error: cannot reopen stdout in binary mode.\\n\"));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t}\n\n\tGF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, level);\n\tgf_log_set_tool_level(GF_LOG_SCENE, level);\n\tgf_log_set_tool_level(GF_LOG_PARSER, level);\n\tgf_log_set_tool_level(GF_LOG_AUTHOR, level);\n\tgf_log_set_tool_level(GF_LOG_CODING, level);\n\tgf_log_set_tool_level(GF_LOG_DASH, level);\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track)\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, level);\n#endif\n\n\te = gf_sys_set_args(argc, (const char **) argv);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error assigning libgpac arguments: %s\\n\", gf_error_to_string(e) ));\n\t\treturn mp4box_cleanup(1);\n\t}\n\n\tif (raw_cat)\n\t\treturn do_raw_cat();\n\n\tif (compress_top_boxes) {\n\t\tif (size_top_box) {\n\t\t\tu64 top_size = do_size_top_boxes(inName, compress_top_boxes, size_top_box);\n\t\t\tfprintf(stdout, LLU\"\\n\", top_size);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t} else {\n\t\t\te = do_compress_top_boxes(inName, outName);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t}\n\t}\n\n\tif (do_mpd_rip) {\n\t\te = rip_mpd(inName, outName);\n\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t}\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_wget != NULL) {\n\t\te = gf_dm_wget(do_wget, inName, 0, 0, NULL);\n\t\tif (e != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot retrieve %s: %s\\n\", do_wget, gf_error_to_string(e) ));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\treturn mp4box_cleanup(0);\n\t}\n#endif\n\n\tif (udp_dest)\n\t\treturn do_write_udp();\n\n#ifndef GPAC_DISABLE_MPD\n\tif (do_mpd_conv)\n\t\treturn convert_mpd();\n#endif\n\n\tif (dash_duration && !nb_dash_inputs) {\n\t\tdash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);\n\t}\n\n\tif (do_saf && !encode) {\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase GF_FILE_TYPE_BT_WRL_X3DV:\n\t\tcase GF_FILE_TYPE_XMT_X3D:\n\t\tcase GF_FILE_TYPE_SVG:\n\t\t\tencode = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_FILE_TYPE_NOT_SUPPORTED:\n\t\tcase GF_FILE_TYPE_ISO_MEDIA:\n\t\tcase GF_FILE_TYPE_SWF:\n\t\tcase GF_FILE_TYPE_LSR_SAF:\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode == GF_SM_DUMP_SVG) {\n\t\tif (strstr(inName, \".srt\") || strstr(inName, \".ttxt\")) import_subtitle = 2;\n\t}\n#endif\n\n\tif (import_subtitle && !trackID)\n\t\treturn do_import_sub();\n\n\n#if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\tif (nb_add || nb_cat) {\n\t\tu32 res = do_add_cat(argc, argv);\n\t\tif (res) return res;\n\t}\n#endif /*!GPAC_DISABLE_MEDIA_IMPORT && !GPAC_DISABLE_ISOM_WRITE*/\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\telse if (chunk_mode) {\n\t\tif (!inName) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"chunk encoding syntax: [-outctx outDump] -inctx inScene auFile\\n\"));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\te = EncodeFileChunk(inName, outName ? outName : inName, input_ctx, output_ctx);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error encoding chunk file %s\\n\", gf_error_to_string(e)));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tgoto exit;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n\telse if (encode) {\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t\te = do_scene_encode();\n\t\tif (e) goto err_exit;\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\telse if (pack_file) {\n\t\tchar *fileName = gf_url_colon_suffix(pack_file);\n\t\tif (fileName && ((fileName - pack_file)==4)) {\n\t\t\tfileName[0] = 0;\n\t\t\tfile = package_file(fileName + 1, pack_file, pack_wgt);\n\t\t\tfileName[0] = ':';\n\t\t} else {\n\t\t\tfile = package_file(pack_file, NULL, pack_wgt);\n\t\t\tif (!file) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to package file\\n\"));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t\tif (!outName) outName = inName;\n\t\tdo_save = GF_TRUE;\n\t\topen_edit = GF_TRUE;\n\t}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\tif (dash_duration) {\n\t\te = do_dash();\n\t\tif (e) return mp4box_cleanup(1);\n\t\tgoto exit;\n\t}\n\n\t//need to open input\n\tif (!file && !do_hash) {\n\t\tFILE *st = gf_fopen(inName, \"rb\");\n\t\tBool file_exists = 0;\n\t\tGF_ISOOpenMode omode;\n\t\tif (st) {\n\t\t\tfile_exists = 1;\n\t\t\tgf_fclose(st);\n\t\t}\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase 1:\n\t\t\tomode =  (u8) (force_new ? GF_ISOM_WRITE_EDIT : (open_edit ? GF_ISOM_OPEN_EDIT : ( ((dump_isom>0) || print_info) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ) ) );\n\n\t\t\tif (crypt) {\n\t\t\t\t//keep fragment signaling in moov\n\t\t\t\tomode = GF_ISOM_OPEN_READ;\n\t\t\t\tif (use_init_seg)\n\t\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ, NULL);\n\t\t\t}\n\t\t\tif (!crypt && use_init_seg) {\n\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ_DUMP, NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\te = gf_isom_open_segment(file, inName, 0, 0, 0);\n\t\t\t\t\tif (e==GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Segment %s: %s\\n\", inName, gf_error_to_string(e) ));\n\t\t\t\t\t} else if (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening segment %s: %s\\n\", inName, gf_error_to_string(e) ));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tfile = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!file)\n\t\t\t\tfile = gf_isom_open(inName, omode, NULL);\n\n\t\t\tif (!file && (gf_isom_last_error(NULL) == GF_ISOM_INCOMPLETE_FILE) && !open_edit) {\n\t\t\t\tu64 missing_bytes;\n\t\t\t\tgf_isom_open_progressive(inName, 0, 0, GF_FALSE, &file, &missing_bytes);\n\t\t\t\tif (missing_bytes)\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Truncated file - missing \"LLD\" bytes\\n\", missing_bytes));\n\t\t\t}\n\n\t\t\tif (!file) {\n\t\t\t\tif (open_edit && nb_meta_act) {\n\t\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, NULL);\n\t\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t\t}\n\n\t\t\t\tif (!file) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL))));\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (freeze_box_order)\n\t\t\t\tgf_isom_freeze_order(file);\n\t\t\tbreak;\n\t\t/*allowed for bt<->xmt*/\n\t\tcase 2:\n\t\tcase 3:\n\t\t/*allowed for svg->lsr**/\n\t\tcase 4:\n\t\t/*allowed for swf->bt, swf->xmt, swf->svg*/\n\t\tcase 5:\n\t\t\tbreak;\n\t\t/*used for .saf / .lsr dump*/\n\t\tcase 6:\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\tif ((dump_mode==GF_SM_DUMP_LASER) || (dump_mode==GF_SM_DUMP_SVG)) {\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\tdefault:\n\t\t\tif (!open_edit && file_exists && !gf_isom_probe_file(inName) && track_dump_type) {\n\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\telse if (!open_edit && file_exists /* && !gf_isom_probe_file(inName) */\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\t         && dump_mode == GF_SM_DUMP_NONE\n#endif //GPAC_DISABLE_SCENE_DUMP\n\t\t\t        ) {\n\t\t\t\t/*************************************************************************************************/\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\tif(dvbhdemux)\n\t\t\t\t{\n\t\t\t\t\tGF_MediaImporter import;\n\t\t\t\t\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\t\t\t\t\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\t\t\t\t\timport.dest = file;\n\t\t\t\t\timport.in_name = inName;\n\t\t\t\t\timport.flags = GF_IMPORT_MPE_DEMUX;\n\t\t\t\t\te = gf_media_import(&import);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tgf_file_delete(\"ttxt_convert\");\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n\t\t\t\tif (dump_m2ts) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, outName, program_number);\n#endif\n\t\t\t\t} else if (dump_timestamps) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, outName, program_number);\n#endif\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\t\t\t\t} else if (do_bin_xml) {\n\t\t\t\t\txml_bs_to_bin(inName, outName, dump_std);\n#endif\n\t\t\t\t} else if (do_hash) {\n\t\t\t\t\thash_file(inName, dump_std);\n\t\t\t\t} else if (print_info) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\t\tconvert_file_info(inName, info_track_id);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (mux_name) {\n\t\t\t\t\t\te = do_remux_file();\n\t\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t\t\tif (file) gf_isom_delete(file);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Input %s is not an MP4 file, operation not allowed\\n\", inName));\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\t\t\telse if (open_edit) {\n\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, NULL);\n\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t} else if (!file_exists) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error %s file %s: %s\\n\", force_new ? \"creating\" : \"opening\", inName, gf_error_to_string(GF_URL_ERROR)));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open %s - extension not supported\\n\", inName));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (high_dynamc_range_filename) {\n\t\te = parse_high_dynamc_range_xml_desc(file, high_dynamc_range_filename);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (file && keep_utc) {\n\t\tgf_isom_keep_utc_times(file, 1);\n\t}\n\n\tif ( gf_strlcpy(outfile, outName ? outName : inName, sizeof(outfile)) >= sizeof(outfile) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Filename too long (limit is %d)\\n\", GF_MAX_PATH));\n\t\treturn mp4box_cleanup(1);\n\t}\n\n\tchar *szExt = gf_file_ext_start(outfile);\n\tif (szExt) {\n\t\t/*turn on 3GP saving*/\n\t\tif (!stricmp(szExt, \".3gp\") || !stricmp(szExt, \".3gpp\") || !stricmp(szExt, \".3g2\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_3GPP;\n\t\telse if (!stricmp(szExt, \".m4a\") || !stricmp(szExt, \".m4v\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_IPOD;\n\t\telse if (!stricmp(szExt, \".psp\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_PSP;\n\t\telse if (!stricmp(szExt, \".mov\") || !stricmp(szExt, \".qt\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_MOV;\n\n\t\t//remove extension from outfile\n\t\t*szExt = 0;\n\t}\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (!open_edit && track_dump_type && !gf_isom_probe_file(inName)) {\n\t\te = do_export_tracks_non_isobmf();\n\t\tif (e) goto err_exit;\n\t\tgoto exit;\n\t}\n\tif (mux_name) {\n\t\te = do_remux_file();\n\t\tif (e) goto err_exit;\n\t\tif (file) gf_isom_delete(file);\n\t\tgoto exit;\n\t}\n\n\n\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode != GF_SM_DUMP_NONE) {\n\t\te = dump_isom_scene(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_mode, do_scene_log, no_odf_conf);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (stat_level) dump_isom_scene_stats(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, stat_level);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (!do_hint && print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\tif (get_nb_tracks) {\n\t\tfprintf(stdout, \"%d\\n\", gf_isom_get_track_count(file));\n\t}\n\tif (print_info) {\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot print info on a non ISOM file (%s)\\n\", inName));\n\t\t} else {\n\t\t\tif (info_track_id) DumpTrackInfo(file, info_track_id, 1, (print_info==2) ? GF_TRUE : GF_FALSE, GF_FALSE);\n\t\t\telse DumpMovieInfo(file);\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\tif (dump_isom) {\n\t\te = dump_isom_xml(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, (dump_isom==2) ? GF_TRUE : GF_FALSE, merge_vtt_cues, use_init_seg ? GF_TRUE : GF_FALSE, (dump_isom==3) ? GF_TRUE : GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (dump_cr) dump_isom_ismacryp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif ((dump_ttxt || dump_srt) && trackID) {\n\n\t\tif (trackID == (u32)-1) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\ttrackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (dump_rtp) dump_isom_rtp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\n#endif\n\n\tif (dump_timestamps) dump_isom_timestamps(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_timestamps);\n\tif (dump_nal) dump_isom_nal(file, dump_nal, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_nal_type);\n\tif (dump_saps) dump_isom_saps(file, dump_saps, dump_saps_mode, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\n\tif (do_hash) {\n\t\te = hash_file(inName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_bin_xml) {\n\t\te = xml_bs_to_bin(inName, outName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\te = do_dump_iod();\n\t\tif (e) goto err_exit;\n\t}\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\tif (split_duration || split_size || split_range_str) {\n\t\tsplit_isomedia_file(file, split_duration, split_size, inName, interleaving_time, split_start, adjust_split_end, outName, seg_at_rap, split_range_str, fs_dump_flags);\n\n\t\t/*never save file when splitting is desired*/\n\t\topen_edit = GF_FALSE;\n\t\tdo_save = GF_FALSE;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (track_dump_type) {\n\t\te = do_export_tracks();\n\t\tif (e) goto err_exit;\n\t} else if (do_saf) {\n\t\tGF_MediaExporter mdump;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.file = file;\n\t\tmdump.flags = GF_EXPORT_SAF;\n\t\tmdump.out_name = outfile;\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\te = do_meta_act();\n\tif (e) goto err_exit;\n\n\tif (!open_edit && !do_save) {\n\t\tif (file) gf_isom_delete(file);\n\t\tgoto exit;\n\t}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (clean_groups) {\n\t\te = gf_isom_reset_switch_parameters(file);\n\t\tif (e) goto err_exit;\n\t\tdo_save = GF_TRUE;\n\t}\n\n\n\te = do_tsel_act();\n\tif (e) goto err_exit;\n\n\tif (remove_sys_tracks) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tremove_systems_tracks(file);\n#endif\n\t\tdo_save = GF_TRUE;\n\t\tif (conv_type < GF_ISOM_CONV_TYPE_ISMA_EX) conv_type = 0;\n\t}\n\tif (remove_root_od) {\n\t\tgf_isom_remove_root_od(file);\n\t\tdo_save = GF_TRUE;\n\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (remove_hint) {\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tif (gf_isom_get_media_type(file, i+1) == GF_ISOM_MEDIA_HINT) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Removing hint track ID %d\\n\", gf_isom_get_track_id(file, i+1)));\n\t\t\t\tgf_isom_remove_track(file, i+1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_clean(file);\n\t\tdo_save = GF_TRUE;\n\t}\n#endif // GPAC_DISABLE_ISOM_HINTING\n\n\tif (timescale && (timescale != gf_isom_get_timescale(file))) {\n\t\tgf_isom_set_timescale(file, timescale);\n\t\tdo_save = GF_TRUE;\n\t}\n\n\tif (!encode) {\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Nothing to do - exiting\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (outName) {\n\t\t\tstrcpy(outfile, outName);\n\t\t} else {\n\t\t\tconst char *tmp_dir = gf_opts_get_key(\"core\", \"tmp\");\n\t\t\tchar *rel_name = strrchr(inName, GF_PATH_SEPARATOR);\n\t\t\tif (!rel_name) rel_name = strrchr(inName, '/');\n\n\t\t\tstrcpy(outfile, \"\");\n\t\t\tif (tmp_dir) {\n\t\t\t\tstrcpy(outfile, tmp_dir);\n\t\t\t\tif (!strchr(\"\\\\/\", tmp_dir[strlen(tmp_dir)-1])) strcat(outfile, \"/\");\n\t\t\t}\n\t\t\tif (!pack_file) strcat(outfile, \"out_\");\n\t\t\tstrcat(outfile, rel_name ? rel_name + 1 : inName);\n\n\t\t\tif (pack_file) {\n\t\t\t\tstrcpy(outfile, rel_name ? rel_name + 1 : inName);\n\t\t\t\trel_name = strrchr(outfile, '.');\n\t\t\t\tif (rel_name) rel_name[0] = 0;\n\t\t\t\tstrcat(outfile, \".m21\");\n\t\t\t}\n\t\t}\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tif ((conv_type == GF_ISOM_CONV_TYPE_ISMA) || (conv_type == GF_ISOM_CONV_TYPE_ISMA_EX)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to ISMA Audio-Video MP4 file\\n\"));\n\t\t\t/*keep ESIDs when doing ISMACryp*/\n\t\t\te = gf_media_make_isma(file, crypt ? 1 : 0, GF_FALSE, (conv_type==GF_ISOM_CONV_TYPE_ISMA_EX) ? 1 : 0);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_3GPP) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to 3GP file\\n\"));\n\t\t\te = gf_media_make_3gpp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_PSP) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to PSP file\\n\"));\n\t\t\te = gf_media_make_psp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_MOV) {\n\t\t\te = gf_media_check_qt_prores(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tif (interleaving_time) interleaving_time = 0.5;\n\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_IPOD) {\n\t\t\tdo_ipod_conv();\n\t\t}\n\n\t} else if (outName) {\n\t\tstrcpy(outfile, outName);\n\t}\n\n\te = do_track_act();\n\tif (e) goto err_exit;\n\n\tif (itunes_tags) {\n\t\te = do_itunes_tag();\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (cprt) {\n\t\te = gf_isom_set_copyright(file, \"und\", cprt);\n\t\tdo_save = GF_TRUE;\n\t\tif (e) goto err_exit;\n\t}\n\tif (chap_file || chap_file_qt) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tBool chap_qt = GF_FALSE;\n\t\tif (chap_file_qt) {\n\t\t\tchap_file = chap_file_qt;\n\t\t\tchap_qt = GF_TRUE;\n\t\t}\n\t\te = gf_media_import_chapters(file, chap_file, import_fps, chap_qt);\n\t\tdo_save = GF_TRUE;\n#else\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (major_brand) {\n\t\tgf_isom_set_brand_info(file, major_brand, minor_version);\n\t\tdo_save = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_add; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);\n\t\tdo_save = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_rem; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_rem[i], GF_FALSE);\n\t\tdo_save = GF_TRUE;\n\t}\n\tif (box_patch_filename) {\n\t\te = gf_isom_apply_box_patch(file, box_patch_trackID, box_patch_filename, GF_FALSE);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) ));\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdo_save = GF_TRUE;\n\t}\n\n#ifndef GPAC_DISABLE_CRYPTO\n\tif (crypt) {\n\t\tif (!drm_file && (crypt==1) ) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing DRM file location - usage '-%s drm_file input_file\\n\", (crypt==1) ? \"crypt\" : \"decrypt\"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (crypt == 1) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_crypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_crypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t} else if (crypt ==2) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_decrypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_decrypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tdo_save = outName ? GF_FALSE : GF_TRUE;\n\n\t\tif (!do_frag && !do_hint && !full_interleave && !force_co64) {\n\t\t\tchar szName[GF_MAX_PATH];\n\t\t\tstrcpy(szName, gf_isom_get_filename(file) );\n\t\t\tgf_isom_delete(file);\n\t\t\tfile = NULL;\n\t\t\tif (!outName) {\n\t\t\t\te = gf_file_move(outfile, szName);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n#endif /*GPAC_DISABLE_CRYPTO*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (do_frag) {\n\t\tif (!interleaving_time) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\tif (do_hint) M4_LOG(GF_LOG_WARNING, (\"Warning: cannot hint and fragment - ignoring hint\\n\"));\n\t\tM4_LOG(GF_LOG_INFO, (\"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time));\n\t\te = gf_media_fragment_file(file, outfile, interleaving_time, use_mfra);\n\t\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error while fragmenting file: %s\\n\", gf_error_to_string(e)));\n\t\tif (!e && !outName) {\n\t\t\tif (gf_file_exists(inName) && gf_file_delete(inName)) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Error removing file %s\\n\", inName));\n\t\t\t}\n\t\t\telse if (gf_file_move(outfile, inName)) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Error renaming file %s to %s\\n\", outfile, inName));\n\t\t\t}\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tgf_isom_delete(file);\n\t\tgoto exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (do_hint) {\n\t\tif (force_ocr) SetupClockReferences(file);\n\t\tMTUSize -= 12;\n\t\te = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, hint_interleave, regular_iod, single_group, hint_no_offset);\n\t\tif (e) goto err_exit;\n\t\tdo_save = GF_TRUE;\n\t\tif (print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\t}\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)\n\tset_sdp_ext();\n#endif /*!defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)*/\n\n\tif (force_co64)\n\t\tgf_isom_force_64bit_chunk_offset(file, GF_TRUE);\n\n\tif (compress_moov)\n\t\tgf_isom_enable_compression(file, GF_ISO_COMP_MOOV, GF_FALSE);\n\n\tif (no_inplace)\n\t\tgf_isom_disable_inplace_rewrite(file);\n\n\tif (moov_pading)\n\t\tgf_isom_set_inplace_padding(file, moov_pading);\n\n\tif (outName) {\n\t\tgf_isom_set_final_name(file, outfile);\n\t} else if (!encode && !force_new && !gf_isom_is_inplace_rewrite(file)) {\n\t\tgf_isom_set_final_name(file, outfile);\n\t}\n\n\tBool is_inplace = gf_isom_is_inplace_rewrite(file);\n\n\n\t/*full interleave (sample-based) if just hinted*/\n\tif (full_interleave) {\n\t\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_TIGHT);\n\t} else if (do_flat) {\n\t\te = gf_isom_set_storage_mode(file, (do_flat==1) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE);\n\t\tdo_save = GF_TRUE;\n\t}\n\t//do not set storage mode unless inplace rewrite is disabled , either by user or due to operations on file\n\telse if (!is_inplace) {\n\t\te = gf_isom_make_interleave(file, interleaving_time);\n\t\tif (!e && old_interleave) e = gf_isom_set_storage_mode(file, GF_ISOM_STORE_INTERLEAVED);\n\t}\n\n\tif (e) goto err_exit;\n\n\n\tif (do_save) {\n\n\t\tif (!gf_sys_is_quiet()) {\n\t\t\tif (outName) {\n\t\t\t} else if (encode || pack_file) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Saving to %s: \", gf_isom_get_filename(file) ));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Saving %s: \", inName));\n\t\t\t}\n\t\t\tif (is_inplace) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"In-place rewrite\\n\"));\n\t\t\t} else if (do_hint && full_interleave) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Hinted file - Full Interleaving\\n\"));\n\t\t\t} else if (full_interleave) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Full Interleaving\\n\"));\n\t\t\t} else if ((force_new==2) && interleaving_time) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Fast-start interleaved storage\\n\"));\n\t\t\t} else if (do_flat || !interleaving_time) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Flat storage\\n\"));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\"));\n\t\t\t}\n\t\t}\n\n\t\te = gf_isom_close(file);\n\t\tfile = NULL;\n\n\t\tif (!e && !outName && !encode && !force_new && !pack_file && !is_inplace) {\n\t\t\tif (gf_file_exists(inName)) {\n\t\t\t\te = gf_file_delete(inName);\n\t\t\t\tif (e) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error removing file %s\\n\", inName));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te = gf_file_move(outfile, inName);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error renaming file %s to %s\\n\", outfile, inName));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_isom_delete(file);\n\t}\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: %s\\n\", gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\tgoto exit;\n\n#else\n\t/*close libgpac*/\n\tgf_isom_delete(file);\n\tM4_LOG(GF_LOG_ERROR, (\"Error: Read-only version of MP4Box.\\n\"));\n\treturn mp4box_cleanup(1);\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nerr_exit:\n\t/*close libgpac*/\n\tif (file) gf_isom_delete(file);\n\tM4_LOG(GF_LOG_ERROR, (\"\\n\\tError: %s\\n\", gf_error_to_string(e)));\n\treturn mp4box_cleanup(1);\n\nexit:\n\tmp4box_cleanup(0);\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\treturn 0;\n}\n\n\nGF_MAIN_FUNC(mp4boxMain)\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / mp4box application\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include \"mp4box.h\"\n\n#ifdef GPAC_DISABLE_ISOM\n\n#error \"Cannot compile MP4Box if GPAC is not built with ISO File Format support\"\n\n#else\n\n#if defined(WIN32) && !defined(_WIN32_WCE)\n#include <io.h>\n#include <fcntl.h>\n#endif\n\n#include <gpac/media_tools.h>\n#include <gpac/main.h>\n\n/*RTP packetizer flags*/\n#ifndef GPAC_DISABLE_STREAMING\n#include <gpac/ietf.h>\n#endif\n\n#ifndef GPAC_DISABLE_CRYPTO\n#include <gpac/crypt_tools.h>\n#endif\n\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#include <gpac/mpd.h>\n\n#define BUFFSIZE\t8192\n#define DEFAULT_INTERLEAVING_IN_SEC 0.5\n\n//undefine to check validity of defined args' syntax\n//#define TEST_ARGS\n\n\nint mp4boxTerminal(int argc, char **argv);\n\nstatic u32 mp4box_cleanup(u32 ret_code);\n\n/*\n * \t\tSTART OF ARGUMENT VALUES DECLARATION\n */\n\n\n\ntypedef struct\n{\n\tGF_ISOTrackID trackID;\n\tchar *line;\n} SDPLine;\n\ntypedef enum {\n\tMETA_ACTION_SET_TYPE\t\t\t= 0,\n\tMETA_ACTION_ADD_ITEM\t\t\t= 1,\n\tMETA_ACTION_REM_ITEM\t\t\t= 2,\n\tMETA_ACTION_SET_PRIMARY_ITEM\t= 3,\n\tMETA_ACTION_SET_XML\t\t\t\t= 4,\n\tMETA_ACTION_SET_BINARY_XML\t\t= 5,\n\tMETA_ACTION_REM_XML\t\t\t\t= 6,\n\tMETA_ACTION_DUMP_ITEM\t\t\t= 7,\n\tMETA_ACTION_DUMP_XML\t\t\t= 8,\n\tMETA_ACTION_ADD_IMAGE_ITEM\t\t= 9,\n\tMETA_ACTION_ADD_IMAGE_GRID\t\t= 10,\n} MetaActionType;\n\ntypedef struct {\n\tu32 ref_item_id;\n\tu32 ref_type;\n} MetaRef;\n\ntypedef struct\n{\n\tMetaActionType act_type;\n\tBool root_meta, use_dref;\n\tGF_ISOTrackID trackID;\n\tu32 meta_4cc;\n\tchar *szPath, *szName, *mime_type, *enc_type;\n\tu32 item_id;\n\tBool primary;\n\tu32 item_type;\n\tu32 ref_item_id;\n\tGF_List *item_refs;\n\tu32 group_id;\n\tu32 group_type;\n\tGF_ImageItemProperties *image_props;\n} MetaAction;\n\n\ntypedef enum {\n\tTRAC_ACTION_REM_TRACK= 0,\n\tTRAC_ACTION_SET_LANGUAGE,\n\tTRAC_ACTION_SET_DELAY,\n\tTRAC_ACTION_SET_KMS_URI,\n\tTRAC_ACTION_SET_PAR,\n\tTRAC_ACTION_SET_HANDLER_NAME,\n\tTRAC_ACTION_ENABLE,\n\tTRAC_ACTION_DISABLE,\n\tTRAC_ACTION_REFERENCE,\n\tTRAC_ACTION_RAW_EXTRACT,\n\tTRAC_ACTION_REM_NON_RAP,\n\tTRAC_ACTION_SET_KIND,\n\tTRAC_ACTION_REM_KIND,\n\tTRAC_ACTION_SET_ID,\n\tTRAC_ACTION_SET_UDTA,\n\tTRAC_ACTION_SWAP_ID,\n\tTRAC_ACTION_REM_NON_REFS,\n\tTRAC_ACTION_SET_CLAP,\n\tTRAC_ACTION_SET_MX,\n\tTRAC_ACTION_SET_EDITS,\n\tTRAC_ACTION_SET_TIME,\n\tTRAC_ACTION_SET_MEDIA_TIME,\n} TrackActionType;\n\ntypedef struct\n{\n\tTrackActionType act_type;\n\tGF_ISOTrackID trackID;\n\tchar lang[10];\n\tGF_Fraction delay;\n\tconst char *kms;\n\tconst char *hdl_name;\n\ts32 par_num, par_den;\n\tu8 force_par, rewrite_bs;\n\tu32 dump_type, sample_num;\n\tchar *out_name;\n\tchar *src_name;\n\tchar *string;\n\tu32 udta_type;\n\tchar *kind_scheme, *kind_value;\n\tu32 newTrackID;\n\ts32 clap_wnum, clap_wden, clap_hnum, clap_hden, clap_honum, clap_hoden, clap_vonum, clap_voden;\n\ts32 mx[9];\n\tu64 time;\n\tu8 dump_track_type;\n} TrackAction;\n\nenum\n{\n\tGF_ISOM_CONV_TYPE_ISMA = 1,\n\tGF_ISOM_CONV_TYPE_ISMA_EX,\n\tGF_ISOM_CONV_TYPE_3GPP,\n\tGF_ISOM_CONV_TYPE_IPOD,\n\tGF_ISOM_CONV_TYPE_PSP,\n\tGF_ISOM_CONV_TYPE_MOV\n};\n\ntypedef enum {\n\tTSEL_ACTION_SET_PARAM = 0,\n\tTSEL_ACTION_REMOVE_TSEL = 1,\n\tTSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP = 2,\n} TSELActionType;\n\ntypedef struct\n{\n\tTSELActionType act_type;\n\tGF_ISOTrackID trackID;\n\n\tGF_ISOTrackID refTrackID;\n\tu32 criteria[30];\n\tu32 nb_criteria;\n\tBool is_switchGroup;\n\tu32 switchGroupID;\n} TSELAction;\n\nGF_FileType get_file_type_by_ext(char *inName);\n\n\nchar outfile[GF_MAX_PATH];\nGF_SMEncodeOptions smenc_opts;\nGF_Fraction import_fps;\n\n//things to free upon cleanup\nMetaAction *metas = NULL;\nTrackAction *tracks = NULL;\nTSELAction *tsel_acts = NULL;\nSDPLine *sdp_lines = NULL;\nu32 *brand_add = NULL;\nu32 *brand_rem = NULL;\nchar **mpd_base_urls = NULL;\nu32 nb_mpd_base_urls = 0;\nGF_DashSegmenterInput *dash_inputs = NULL;\nu32 nb_dash_inputs = 0;\n\n\n\n//all other options values - keep options with assignment other than 0 on a single line\n\nu32 swf_flags = GF_SM_SWF_SPLIT_TIMELINE;\n\nFILE *helpout = NULL;\nu32 help_flags = 0;\n\nDouble interleaving_time=0.0, split_duration=0.0, split_start=-1.0, dash_duration=0.0, dash_subduration=0.0, swf_flatten_angle=0.0;\nBool dash_duration_strict=0, dvbhdemux=0, keep_sys_tracks=0;\n\nu64 initial_tfdt=0;\ns32 subsegs_per_sidx=0, laser_resolution=0, ast_offset_ms=0;\nconst char *split_range_str = NULL;\nGF_DashSwitchingMode bitstream_switching_mode = GF_DASH_BSMODE_DEFAULT;\nu32 stat_level=0, hint_flags=0, info_track_id=0, import_flags=0, nb_add=0, nb_cat=0, crypt=0, agg_samples=0, nb_sdp_ex=0, max_ptime=0, split_size=0, nb_meta_act=0, nb_track_act=0, rtp_rate=0, major_brand=0, nb_alt_brand_add=0, nb_alt_brand_rem=0, old_interleave=0, minor_version=0, conv_type=0, nb_tsel_acts=0, program_number=0, dump_nal=0, time_shift_depth=0, initial_moof_sn=0, dump_std=0, import_subtitle=0, dump_saps=0, dump_saps_mode=0, force_new=0;\nGF_DashDynamicMode dash_mode=GF_DASH_STATIC;\n#ifndef GPAC_DISABLE_SCENE_DUMP\nGF_SceneDumpFormat dump_mode=GF_SM_DUMP_NONE;\n#endif\n\n/*align cat is the new default behavior for -cat*/\nBool align_cat=GF_TRUE;\n\nDouble mpd_live_duration=0;\nBool do_hint=0, do_save=0, full_interleave=0, do_frag=0, hint_interleave=0, dump_rtp=0, regular_iod=0, remove_sys_tracks=0, remove_hint=0, remove_root_od=0;\nBool print_sdp=0, open_edit=0, dump_cr=0, force_ocr=0, encode=0, do_scene_log=0, dump_srt=0, dump_ttxt=0, do_saf=0, dump_m2ts=0, dump_cart=0;\nBool do_hash=0, verbose=0, force_cat=0, pack_wgt=0, single_group=0, clean_groups=0, dash_live=0, no_fragments_defaults=0;\nBool single_traf_per_moof=0, tfdt_per_traf=0, hls_clock=0, do_mpd_rip=0, merge_vtt_cues=0, compress_moov=0, get_nb_tracks=0;\n\nchar *inName=NULL, *outName=NULL, *mediaSource=NULL, *input_ctx=NULL, *output_ctx=NULL, *drm_file=NULL, *avi2raw=NULL, *cprt=NULL;\nchar *chap_file=NULL, *chap_file_qt=NULL, *itunes_tags=NULL, *pack_file=NULL, *raw_cat=NULL, *seg_name=NULL, *dash_ctx_file=NULL;\nchar *compress_top_boxes=NULL, *high_dynamc_range_filename=NULL, *use_init_seg=NULL, *box_patch_filename=NULL, *udp_dest = NULL;\n\nGF_ISOTrackID trackID=0;\nu32 track_dump_type=0, dump_isom=0, dump_timestamps=0, dump_nal_type=0, do_flat=0, box_patch_trackID=0, print_info=0;\nBool no_inplace=0, merge_last_seg=0, freeze_box_order=0, no_odf_conf=0;\nDouble min_buffer = 1.5;\nu32 size_top_box=0, fs_dump_flags=0, dump_chap=0, dump_udta_type=0, dump_udta_track=0, moov_pading=0, sdtp_in_traf=0, segment_marker=0, timescale=0;\n\nu32 dash_scale = 1000;\nGF_ISOFile *file = NULL;\n\nBool insert_utc=0, chunk_mode=0, HintCopy=0, hint_no_offset=0, do_bin_xml=0, frag_real_time=0, force_co64=0, live_scene=0, use_mfra=0;\nBool dump_iod=0, samplegroups_in_traf=0, mvex_after_traks=0, daisy_chain_sidx=0, use_ssix=0, single_segment=0, single_file=0, segment_timeline=0;\nBool has_add_image=0;\n\nchar *do_mpd_conv=NULL;\nu32 MTUSize = 1450;\nchar *dash_start_date=NULL;\nGF_DASH_ContentLocationMode cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;\nDouble mpd_update_time = 0.0;\nGF_MemTrackerType mem_track = GF_MemTrackerNone;\nGF_DASHPSSHMode pssh_mode=0;\n\nGF_DashProfile dash_profile=GF_DASH_PROFILE_AUTO;\nchar *dash_profile_extension = NULL;\nchar *dash_cues = NULL;\nBool strict_cues=0, use_url_template=0, seg_at_rap=0, frag_at_rap=0, adjust_split_end=0, memory_frags=0, keep_utc=0, has_next_arg=0, no_cache=0, no_loop=0;\nchar *do_wget = NULL;\nchar *mux_name = NULL;\nchar *seg_ext = NULL;\nchar *init_seg_ext = NULL;\nchar *dash_title = NULL;\nchar *dash_source = NULL;\nchar *dash_more_info = NULL;\n\nFILE *logfile = NULL;\nu32 run_for=0, dash_cumulated_time=0, dash_prev_time=0, dash_now_time=0;\nGF_DASH_SplitMode dash_split_mode = GF_DASH_SPLIT_OUT;\n\n\ntypedef u32 (*parse_arg_fun)(char *arg_val, u32 param);\ntypedef u32 (*parse_arg_fun2)(char *arg_name, char *arg_val, u32 param);\n\n//other custom option parsing functions definitions are in mp4box.h\nstatic u32 parse_meta_args(char *opts, MetaActionType act_type);\nstatic Bool parse_tsel_args(char *opts, TSELActionType act);\n\n\n\n/*\n * \t\tSTART OF ARGS PARSING AND HELP\n */\n\n\nBool print_version(char *arg_val, u32 param)\n{\n\tfprintf(stderr, \"MP4Box - GPAC version %s\\n\"\n\t        \"%s\\n\"\n\t        \"GPAC Configuration: \" GPAC_CONFIGURATION \"\\n\"\n\t        \"Features: %s %s\\n\", gf_gpac_version(), gf_gpac_copyright_cite(), gf_sys_features(GF_FALSE), gf_sys_features(GF_TRUE));\n\treturn GF_TRUE;\n}\n\n//arg will toggle open_edit\n#define ARG_OPEN_EDIT\t\t1\n//arg will toggle do_save\n#define ARG_NEED_SAVE\t\t1<<1\n#define ARG_NO_INPLACE\t\t1<<2\n#define ARG_BIT_MASK\t\t1<<3\n#define ARG_BIT_MASK_REM\t1<<4\n#define ARG_HAS_VALUE\t\t1<<5\n#define ARG_DIV_1000\t\t1<<6\n#define ARG_NON_ZERO\t\t1<<7\n#define ARG_64BITS\t\t\t1<<8\n#define ARG_IS_4CC\t\t\t1<<9\n#define ARG_BOOL_REV\t\t1<<10\n#define ARG_INT_INC\t\t\t1<<11\n#define ARG_IS_FUN\t\t\t1<<12\n#define ARG_EMPTY\t\t\t1<<13\n#define ARG_PUSH_SYSARGS\t1<<14\n#define ARG_IS_FUN2\t\t\t1<<15\n\n\n\ntypedef struct\n{\n\tGF_GPAC_ARG_BASE\n\n\tvoid *arg_ptr;\n\tu32 argv_val;\n\tu16 parse_flags;\n} MP4BoxArg;\n\n#define MP4BOX_ARG(_a, _c, _f, _g, _h, _i, _j) {_a, NULL, _c, NULL, NULL, _f, _g, _h, _i, _j}\n#define MP4BOX_ARG_ALT(_a, _b, _c, _f, _g, _h, _i, _j) {_a, _b, _c, NULL, NULL, _f, _g, _h, _i, _j}\n#define MP4BOX_ARG_S(_a, _s, _c, _g, _h, _i, _j) {_a, NULL, _c, _s, NULL, GF_ARG_CUSTOM, _g, _h, _i, _j}\n#define MP4BOX_ARG_S_ALT(_a, _b, _s, _c, _g, _h, _i, _j) {_a, _b, _c, _s, NULL, GF_ARG_CUSTOM, _g, _h, _i, _j}\n\n\nMP4BoxArg m4b_gen_args[] =\n{\n#ifdef GPAC_MEMORY_TRACKING\n \tMP4BOX_ARG(\"mem-track\", \"enable memory tracker\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n \tMP4BOX_ARG(\"mem-track-stack\", \"enable memory tracker with stack dumping\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n#endif\n \tMP4BOX_ARG(\"p\", \"use indicated profile for the global GPAC config. If not found, config file is created. If a file path is indicated, this will load profile from that file. Otherwise, this will create a directory of the specified name and store new config there. Reserved name `0` means a new profile, not stored to disk. Works using -p=NAME or -p NAME\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, NULL, 0, 0),\n \t{\"inter\", NULL, \"interleave file, producing track chunks with given duration in ms. A value of 0 disables interleaving \", \"0.5\", NULL, GF_ARG_DOUBLE, 0, parse_store_mode, 0, ARG_IS_FUN},\n \tMP4BOX_ARG(\"old-inter\", \"same as [-inter]() but without drift correction\", GF_ARG_DOUBLE, GF_ARG_HINT_EXPERT, parse_store_mode, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"tight\", \"tight interleaving (sample based) of the file. This reduces disk seek operations but increases file size\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &full_interleave, 0, ARG_OPEN_EDIT|ARG_NEED_SAVE),\n \tMP4BOX_ARG(\"flat\", \"store file with all media data first, non-interleaved. This speeds up writing time when creating new files\", GF_ARG_BOOL, 0, &do_flat, 0, ARG_OPEN_EDIT| ARG_NO_INPLACE),\n \tMP4BOX_ARG(\"frag\", \"fragment file, producing track fragments of given duration in ms. This disables interleaving\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"out\", \"specify ISOBMFF output file name. By default input file is overwritten\", GF_ARG_STRING, 0, &outName, 0, 0),\n \tMP4BOX_ARG(\"co64\",\"force usage of 64-bit chunk offsets for ISOBMF files\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_co64, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"new\", \"force creation of a new destination file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &force_new, 0, 0),\n \tMP4BOX_ARG(\"newfs\", \"force creation of a new destination file without temp file but interleaving support\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, parse_store_mode, 3, ARG_IS_FUN),\n \tMP4BOX_ARG_ALT(\"no-sys\", \"nosys\", \"remove all MPEG-4 Systems info except IOD, kept for profiles. This is the default when creating regular AV content\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &remove_sys_tracks, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"no-iod\", \"remove MPEG-4 InitialObjectDescriptor from file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &remove_root_od, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"mfra\", \"insert movie fragment random offset when fragmenting file (ignored in dash mode)\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &use_mfra, 0, 0),\n \tMP4BOX_ARG(\"isma\", \"rewrite the file as an ISMA 1.0 file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"ismax\", \"same as [-isma]() and remove all clock references\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_ISMA_EX, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"3gp\", \"rewrite as 3GPP(2) file (no more MPEG-4 Systems Info), always enabled if destination file extension is `.3gp`, `.3g2` or `.3gpp`. Some tracks may be removed in the process\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_3GPP, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"ipod\", \"rewrite the file for iPod/old iTunes\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_IPOD, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"psp\", \"rewrite the file for PSP devices\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &conv_type, GF_ISOM_CONV_TYPE_PSP, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"brand\", \"set major brand of file (`ABCD`) or brand with optional version (`ABCD:v`)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"ab\", \"add given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rb\", \"remove given brand to file's alternate brand list\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_brand, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"cprt\", \"add copyright string to file\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),\n \tMP4BOX_ARG(\"chap\", \"set chapter information from given file. The following formats are supported (but cannot be mixed) in the chapter text file:\\n\"\n\t\t\"  - ZoomPlayer: `AddChapter(nb_frames,chapter name)`, `AddChapterBySeconds(nb_sec,chapter name)` and `AddChapterByTime(h,m,s,chapter name)` with 1 chapter per line\\n\"\n\t\t\"  - Time codes: `h:m:s chapter_name`, `h:m:s:ms chapter_name` and `h:m:s.ms chapter_name` with 1 chapter per line\\n\"\n\t\t\"  - SMPTE codes: `h:m:s;nb_f/fps chapter_name` and `h:m:s;nb_f chapter_name` with `nb_f` the number of frames and `fps` the framerate with 1 chapter per line\\n\"\n\t\t\"  - Common syntax: `CHAPTERX=h:m:s[:ms or .ms]` on first line and `CHAPTERXNAME=name` on next line (reverse order accepted)\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"chapqt\", \"set chapter information from given file, using QT signaling for text tracks\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &chap_file_qt, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG_S(\"set-track-id\", \"id1:id2\", \"change id of track with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SET_ID, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"swap-track-id\", \"id1:id2\", \"swap the id between tracks with id1 to id2\", 0, parse_track_action, TRAC_ACTION_SWAP_ID, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rem\", \"remove given track from file\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_REM_TRACK, ARG_IS_FUN),\n \tMP4BOX_ARG(\"rap\", \"remove all non-RAP samples from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"refonly\", \"remove all non-reference pictures from given track\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_rap_ref, 1, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"enable\", \"enable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_ENABLE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"disable\", \"disable given track\", GF_ARG_INT, 0, parse_track_action, TRAC_ACTION_DISABLE, ARG_IS_FUN),\n \t{\"timescale\", NULL, \"set movie timescale to given value (ticks per second)\", \"600\", NULL, GF_ARG_INT, 0, &timescale, 0, ARG_OPEN_EDIT},\n \tMP4BOX_ARG_S(\"lang\", \"[tkID=]LAN\", \"set language. LAN is the BCP-47 code (eng, en-UK, ...). If no track ID is given, sets language to all tracks\", 0, parse_track_action, TRAC_ACTION_SET_LANGUAGE, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"delay\", \"tkID=TIME\", \"set track start delay in ms or in fractional seconds (`N/D`)\", 0, parse_track_action, TRAC_ACTION_SET_DELAY, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"par\", \"tkID=PAR\", \"set visual track pixel aspect ratio. PAR is:\\n\"\n\t\t\t\t\t\"  - N:D: set PAR to N:D in track, do not modify the bitstream\\n\"\n\t\t\t\t\t\"  - wN:D: set PAR to N:D in track and try to modify the bitstream\\n\"\n\t\t\t\t\t\"  - none: remove PAR info from track, do not modify the bitstream\\n\"\n\t\t\t\t\t\"  - auto: retrieve PAR info from bitstream and set it in track\\n\"\n\t\t\t\t\t\"  - force: force 1:1 PAR in track, do not modify the bitstream\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_PAR, ARG_IS_FUN\n\t\t\t\t\t),\n \tMP4BOX_ARG_S(\"clap\", \"tkID=CLAP\", \"set visual track clean aperture. CLAP is `Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd` or `none`\\n\"\n \t\t\t\"- n, d: numerator, denominator\\n\"\n\t        \"- W, H, HO, VO: clap width, clap height, clap horizontal offset, clap vertical offset\\n\"\n \t\t\t, GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_CLAP, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"mx\", \"tkID=MX\", \"set track matrix, with MX is M1:M2:M3:M4:M5:M6:M7:M8:M9 in 16.16 fixed point intergers or hexa\"\n \t\t\t, GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_MX, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"kind\", \"tkID=schemeURI=value\", \"set kind for the track or for all tracks using `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_SET_KIND, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"kind-rem\", \"tkID=schemeURI=value\", \"remove kind if given schemeID for the track or for all tracks with `all=schemeURI=value`\", 0, parse_track_action, TRAC_ACTION_REM_KIND, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"name\", \"tkID=NAME\", \"set track handler name to NAME (UTF-8 string)\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_HANDLER_NAME, ARG_IS_FUN),\n \tMP4BOX_ARG(\"itags\", \"set iTunes tags to file, see `-h tags`\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &itunes_tags, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"group-add\", \"create a new grouping information in the file. Format is a colon-separated list of following options:\\n\"\n\t        \"- refTrack=ID: ID of the track used as a group reference. If not set, the track will belong to the same group as the \"\n\t        \"previous trackID specified. If 0 or no previous track specified, a new alternate group will be created\\n\"\n\t        \"- switchID=ID: ID of the switch group to create. If 0, a new ID will be computed for you. If <0, disables SwitchGroup\\n\"\n\t        \"- criteria=string: list of space-separated 4CCs\\n\"\n\t        \"- trackID=ID: ID of the track to add to this group\\n\"\n\t        \"  \\n\"\n\t        \"Warning: Options modify state as they are parsed, `trackID=1:criteria=lang:trackID=2` is different from `criteria=lang:trackID=1:trackID=2`\"\n\t        \"\\n\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_SET_PARAM, ARG_IS_FUN),\n\n\tMP4BOX_ARG(\"group-rem-track\", \"remove given track from its group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_TSEL, ARG_IS_FUN),\n\tMP4BOX_ARG(\"group-rem\", \"remove the track's group\", GF_ARG_INT, GF_ARG_HINT_ADVANCED, parse_tsel_args, TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP, ARG_IS_FUN),\n\tMP4BOX_ARG(\"group-clean\", \"remove all group information from all tracks\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &clean_groups, 0, ARG_OPEN_EDIT),\n\tMP4BOX_ARG_S(\"ref\", \"id:XXXX:refID\", \"add a reference of type 4CC from track ID to track refID\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_REFERENCE, ARG_IS_FUN),\n\tMP4BOX_ARG(\"keep-utc\", \"keep UTC timing in the file after edit\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &keep_utc, 0, 0),\n\tMP4BOX_ARG_S(\"udta\", \"tkID:[OPTS]\", \"set udta for given track or movie if tkID is 0. OPTS is a colon separated list of:\\n\"\n\t        \"- type=CODE: 4CC code of the UDTA (not needed for `box=` option)\\n\"\n\t        \"- box=FILE: location of the udta data, formatted as serialized boxes\\n\"\n\t        \"- box=base64,DATA: base64 encoded udta data, formatted as serialized boxes\\n\"\n\t        \"- src=FILE: location of the udta data (will be stored in a single box of type CODE)\\n\"\n\t        \"- src=base64,DATA: base64 encoded udta data (will be stored in a single box of type CODE)\\n\"\n\t        \"- str=STRING: use the given string as payload for the udta box\\n\"\n\t        \"Note: If no source is set, UDTA of type CODE will be removed\\n\", GF_ARG_HINT_ADVANCED, parse_track_action, TRAC_ACTION_SET_UDTA, ARG_IS_FUN|ARG_OPEN_EDIT),\n\tMP4BOX_ARG_S(\"patch\", \"[tkID=]FILE\", \"apply box patch described in FILE, for given trackID if set\", GF_ARG_HINT_ADVANCED, parse_boxpatch, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"bo\", \"freeze the order of boxes in input file\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &freeze_box_order, 0, 0),\n\tMP4BOX_ARG(\"init-seg\", \"use the given file as an init segment for dumping or for encryption\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &use_init_seg, 0, 0),\n\tMP4BOX_ARG(\"zmov\", \"compress movie box according to ISOBMFF box compression\", GF_ARG_BOOL, GF_ARG_HINT_ADVANCED, &compress_moov, 0, 0),\n \tMP4BOX_ARG_S(\"edits\", \"tkID=EDITS\", \"set edit list. The following syntax is used (no separators between entries):\\n\"\n\t\t\t\" - `r`: removes all edits\\n\"\n\t\t\t\" - `eSTART`: add empty edit with given start time (fractional or milliseconds). START can be\\n\"\n\t\t\t\"   - `VAL`: start time in milliseconds (media duration used as edit duration)\\n\"\n\t\t\t\"   - `VAL-DUR`: start time and duration in milliseconds\\n\"\n\t\t\t\"   - `VAL/NUM`: start time as fractional seconds (media duration used as edit duration)\\n\"\n\t\t\t\"   - `VAL-DUR/NUM`: start time and duration as fractional seconds\\n\"\n\t\t\t\" - `eSTART,MEDIA[,RATE]`: add regular edit with given start, media start time (ms or fraction) and rate (fraction or INT/1000)\\n\"\n\t\t\t\" - Examples: \\n\"\n\t\t\t\"   - `-edits=re0-5/1e5-3/1,100/25`: remove edits, add empty edit at 0s for 5s, then add regular edit at 5s for 3s starting at 4s in media track\\n\"\n\t\t\t\"   - `-edits=re0-4/1,0,2/1`: remove edits, add single edit at 0s for 4s starting at 0s in media track and playing at speed 2\\n\"\n\t\t\t\t, 0, parse_track_action, TRAC_ACTION_SET_EDITS, ARG_IS_FUN),\n \tMP4BOX_ARG(\"moovpad\", \"specify amount of padding to keep after moov box for later inplace editing - if 0, moov padding is disabled\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &moov_pading, 0, ARG_NEED_SAVE),\n \tMP4BOX_ARG(\"no-inplace\", \"disable inplace rewrite\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_inplace, 0, 0),\n \tMP4BOX_ARG(\"hdr\", \"update HDR information based on given XML\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &high_dynamc_range_filename, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG_S(\"time\", \"[tkID=]DAY/MONTH/YEAR-H:M:S\", \"set movie or track creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_TIME, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"mtime\", \"tkID=DAY/MONTH/YEAR-H:M:S\", \"set media creation time\", GF_ARG_HINT_EXPERT, parse_track_action, TRAC_ACTION_SET_MEDIA_TIME, ARG_IS_FUN),\n\t{0}\n};\n\nvoid PrintGeneralUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# General Options\\n\"\n\t\t\"MP4Box is a multimedia packager, with a vast number of functionalities: conversion, splitting, hinting, dumping, DASH-ing, encryption, transcoding and others.\\n\"\n\t\t\"MP4Box provides a large set of options, classified by categories (see [-h]()). These options do not follow any particular ordering.\\n\"\n\t\t\"MP4Box performs in-place rewrite of IsoMedia files (the input file is overwritten). You can change this behavior by using the [-out]() option.\\n\"\n\t\t\"MP4Box stores by default the file with 0.5 second interleaving and meta-data (`moov` ...) at the beginning, making it suitable for HTTP streaming. This may however takes longer to store the file, use [-flat]() to change this behavior.\\n\"\n\t\t\"MP4Box usually generates a temporary file when creating a new IsoMedia file. The location of this temporary file is OS-dependent, and it may happen that the drive/partition the temporary file is created on has not enough space or no write access. In such a case, you can specify a temporary file location with [-tmp]().\\n\"\n\t\t\"Note: Track operations identify tracks through their ID (usually referred to as tkID in the help), not their order.\\n\"\n\t\t\"Option values:\\n\"\n\t\t\"Unless specified otherwise, an option of type `integer` expects a trackID value following it.\"\n\t\t\"An option of type `boolean` expects no following value.\"\n\t\t\"  \\n\"\n\t);\n\n\n\twhile (m4b_gen_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_gen_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-gen\");\n\t}\n}\n\n\nMP4BoxArg m4b_split_args[] =\n{\n \tMP4BOX_ARG(\"split\", \"split in files of given max duration\", GF_ARG_STRING, 0, parse_split, 0, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-rap\", \"splitr\", \"split in files at each new RAP\", GF_ARG_STRING, 0, parse_split, 1, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-size\", \"splits\", \"split in files of given max size (in kb)\", GF_ARG_STRING, 0, parse_split, 2, ARG_IS_FUN),\n\tMP4BOX_ARG_ALT(\"split-chunk\", \"splitx\", \"extract a new file from source. `VAL` can be formatted as:\\n\"\n\t\"- `S:E`: `S` (number of seconds) to `E` with `E` a number (in seconds), `end` or `end-N`, N  number of seconds before the end\\n\"\n\t\"- `S-E`: start and end dates, each formatted as `HH:MM:SS.ms` or `MM:SS.ms`\", GF_ARG_STRING, 0, parse_split, 3, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"splitz\", \"S:E\", \"same as -split-chunk, but adjust the end time to be before the next RAP sample, so that ranges `A:B` and `B:C` share exactly the same boundary `B`\", 0, parse_split, 4, ARG_IS_FUN),\n\t{0}\n};\n\n\nstatic void PrintSplitUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"  \\n\"\n\t\t\"# File splitting\\n\"\n\t\t\"MP4Box can split IsoMedia files by size, duration or extract a given part of the file to new IsoMedia file(s).\\n\"\n\t\t\"This requires that at most one track in the input file has non random-access points (typically one video track at most).\\n\"\n\t\t\"splitting will ignore all MPEG-4 Systems tracks and hint tracks, but will try to split private media tracks.\\n\"\n\t\t\"The input file must have enough random access points in order to be split. If this is not the case, you will have to re-encode the content.\\n\"\n\t\t\"You can add media to a file and split it in the same pass. In this case, the destination file (the one which would be obtained without splitting) will not be stored.\\n\"\n\t\t\"  \\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_split_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_split_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-split\");\n\t}\n\n}\n\n\nMP4BoxArg m4b_dash_args[] =\n{\n \tMP4BOX_ARG (\"dash\", \"create DASH from input files with given segment (subsegment for onDemand profile) duration in ms\", GF_ARG_DOUBLE, 0, &dash_duration, 0, ARG_NON_ZERO),\n \tMP4BOX_ARG(\"dash-live\", \"generate a live DASH session using the given segment duration in ms; using `-dash-live=F` will also write the live context to `F`. MP4Box will run the live session until `q` is pressed or a fatal error occurs\", GF_ARG_DOUBLE, 0, parse_dashlive, 0, ARG_IS_FUN2),\n \tMP4BOX_ARG(\"ddbg-live\", \"same as [-dash-live]() without time regulation for debug purposes\", GF_ARG_DOUBLE, 0, parse_dashlive, 1, ARG_IS_FUN2),\n\tMP4BOX_ARG(\"frag\", \"specify the fragment duration in ms. If not set, this is the DASH duration (one fragment per segment)\", GF_ARG_DOUBLE, 0, parse_store_mode, 2, ARG_IS_FUN),\n\tMP4BOX_ARG(\"out\", \"specify the output MPD file name\", GF_ARG_STRING, 0, &outName, 0, 0),\n\tMP4BOX_ARG_ALT(\"profile\", \"dash-profile\", \"specify the target DASH profile, and set default options to ensure conformance to the desired profile. Default profile is `full` in static mode, `live` in dynamic mode (old syntax using `:live` instead of `.live` as separator still possible). Defined values are onDemand, live, main, simple, full, hbbtv1.5.live, dashavc264.live, dashavc264.onDemand, dashif.ll\", GF_ARG_STRING, 0, parse_dash_profile, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"profile-ext\", \"specify a list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used\", GF_ARG_STRING, 0, &dash_profile_extension, 0, 0),\n\tMP4BOX_ARG(\"rap\", \"ensure that segments begin with random access points, segment durations might vary depending on the source encoding\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n\tMP4BOX_ARG(\"frag-rap\", \"ensure that all fragments begin with random access points (duration might vary depending on the source encoding)\", GF_ARG_BOOL, 0, &frag_at_rap, 0, 0),\n\tMP4BOX_ARG(\"segment-name\", \"set the segment name for generated segments. If not set (default), segments are concatenated in output file except in `live` profile where `dash_%%s`. Supported replacement strings are:\\n\"\n\t        \"- $Number[%%0Nd]$ is replaced by the segment number, possibly prefixed with 0\\n\"\n\t        \"- $RepresentationID$ is replaced by representation name\\n\"\n\t        \"- $Time$ is replaced by segment start time\\n\"\n\t        \"- $Bandwidth$ is replaced by representation bandwidth\\n\"\n\t        \"- $Init=NAME$ is replaced by NAME for init segment, ignored otherwise\\n\"\n\t        \"- $Index=NAME$ is replaced by NAME for index segments, ignored otherwise\\n\"\n\t        \"- $Path=PATH$ is replaced by PATH when creating segments, ignored otherwise\\n\"\n\t        \"- $Segment=NAME$ is replaced by NAME for media segments, ignored for init segments\", GF_ARG_STRING, 0, &seg_name, 0, 0),\n\t{\"segment-ext\", NULL, \"set the segment extension, `null` means no extension\", \"m4s\", NULL, GF_ARG_STRING, 0, &seg_ext, 0, 0},\n\t{\"init-segment-ext\", NULL, \"set the segment extension for init, index and bitstream switching segments, `null` means no extension\\n\", \"mp4\", NULL, GF_ARG_STRING, 0, &init_seg_ext, 0, 0},\n\tMP4BOX_ARG(\"segment-timeline\", \"use `SegmentTimeline` when generating segments\", GF_ARG_BOOL, 0, &segment_timeline, 0, 0),\n\tMP4BOX_ARG(\"segment-marker\", \"add a box of given type (4CC) at the end of each DASH segment\", GF_ARG_STRING, 0, &segment_marker, 0, ARG_IS_4CC),\n\tMP4BOX_ARG(\"insert-utc\", \"insert UTC clock at the beginning of each ISOBMF segment\", GF_ARG_BOOL, 0, &insert_utc, 0, 0),\n\tMP4BOX_ARG(\"base-url\", \"set Base url at MPD level. Can be used several times.  \\nWarning: this does not  modify generated files location\", GF_ARG_STRING, 0, parse_base_url, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"mpd-title\", \"set MPD title\", GF_ARG_STRING, 0, &dash_title, 0, 0),\n\tMP4BOX_ARG(\"mpd-source\", \"set MPD source\", GF_ARG_STRING, 0, &dash_source, 0, 0),\n\tMP4BOX_ARG(\"mpd-info-url\", \"set MPD info url\", GF_ARG_STRING, 0, &dash_more_info, 0, 0),\n \tMP4BOX_ARG(\"cprt\", \"add copyright string to MPD\", GF_ARG_STRING, GF_ARG_HINT_ADVANCED, &cprt, 0, 0),\n\tMP4BOX_ARG(\"dash-ctx\", \"store/restore DASH timing from indicated file\", GF_ARG_STRING, 0, &dash_ctx_file, 0, 0),\n\tMP4BOX_ARG(\"dynamic\", \"use dynamic MPD type instead of static\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC, 0),\n\tMP4BOX_ARG(\"last-dynamic\", \"same as [-dynamic]() but close the period (insert lmsg brand if needed and update duration)\", GF_ARG_BOOL, 0, &dash_mode, GF_DASH_DYNAMIC_LAST, 0),\n\tMP4BOX_ARG(\"mpd-duration\", \"set the duration in second of a live session (if `0`, you must use [-mpd-refresh]())\", GF_ARG_DOUBLE, 0, &mpd_live_duration, 0, 0),\n\tMP4BOX_ARG(\"mpd-refresh\", \"specify MPD update time in seconds\", GF_ARG_DOUBLE, 0, &mpd_update_time, 0, 0),\n\tMP4BOX_ARG(\"time-shift\", \"specify MPD time shift buffer depth in seconds, `-1` to keep all files)\", GF_ARG_INT, 0, &time_shift_depth, 0, 0),\n\tMP4BOX_ARG(\"subdur\", \"specify maximum duration in ms of the input file to be dashed in LIVE or context mode. This does not change the segment duration, but stops dashing once segments produced exceeded the duration. If there is not enough samples to finish a segment, data is looped unless [-no-loop]() is used which triggers a period end\", GF_ARG_DOUBLE, 0, &dash_subduration, 0, 0),\n\tMP4BOX_ARG(\"run-for\", \"run for given ms  the dash-live session then exits\", GF_ARG_INT, 0, &run_for, 0, 0),\n\tMP4BOX_ARG(\"min-buffer\", \"specify MPD min buffer time in ms\", GF_ARG_INT, 0, &min_buffer, 0, ARG_DIV_1000),\n\tMP4BOX_ARG(\"ast-offset\", \"specify MPD AvailabilityStartTime offset in ms if positive, or availabilityTimeOffset of each representation if negative\", GF_ARG_INT, 0, &ast_offset_ms, 0, 0),\n\tMP4BOX_ARG(\"dash-scale\", \"specify that timing for [-dash](),  [-dash-live](), [-subdur]() and [-do_frag]() are expressed in given timescale (units per seconds) rather than ms\", GF_ARG_INT, 0, &dash_scale, 0, ARG_NON_ZERO),\n\tMP4BOX_ARG(\"mem-frags\", \"fragmentation happens in memory rather than on disk before flushing to disk\", GF_ARG_BOOL, 0, &memory_frags, 0, 0),\n\tMP4BOX_ARG(\"pssh\", \"set pssh store mode\\n\"\n\t\"- v: initial movie\\n\"\n\t\"- f: movie fragments\\n\"\n\t\"- m: MPD\\n\"\n\t\"- mv, vm: in initial movie and MPD\\n\"\n\t\"- mf, fm: in movie fragments and MPD\", GF_ARG_INT, 0, parse_pssh, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"sample-groups-traf\", \"store sample group descriptions in traf (duplicated for each traf). If not set, sample group descriptions are stored in the initial movie\", GF_ARG_BOOL, 0, &samplegroups_in_traf, 0, 0),\n\tMP4BOX_ARG(\"mvex-after-traks\", \"store `mvex` box after `trak` boxes within the moov box. If not set, `mvex` is before\", GF_ARG_BOOL, 0, &mvex_after_traks, 0, 0),\n\tMP4BOX_ARG(\"sdtp-traf\", \"use `sdtp` box in `traf` (Smooth-like)\\n\"\n\t\"- no: do not use sdtp\\n\"\n\t\"- sdtp: use sdtp box to indicate sample dependencies and do not write info in trun sample flags\\n\"\n\t\"- both: use sdtp box to indicate sample dependencies and also write info in trun sample flags\\n\", GF_ARG_INT, 0, parse_sdtp, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"no-cache\", \"disable file cache for dash inputs\", GF_ARG_BOOL, 0, &no_cache, 0, 0),\n\tMP4BOX_ARG(\"no-loop\", \"disable looping content in live mode and uses period switch instead\", GF_ARG_BOOL, 0, &no_loop, 0, 0),\n\tMP4BOX_ARG(\"hlsc\", \"insert UTC in variant playlists for live HLS\", GF_ARG_BOOL, 0, &hls_clock, 0, 0),\n\tMP4BOX_ARG(\"bound\", \"segmentation will always try to split before or at, but never after, the segment boundary\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_IN, 0),\n\tMP4BOX_ARG(\"closest\", \"segmentation will use the closest frame to the segment boundary (before or after)\", GF_ARG_BOOL, 0, &dash_split_mode, GF_DASH_SPLIT_CLOSEST, 0),\n\tMP4BOX_ARG_ALT(\"subsegs-per-sidx\", \"frags-per-sidx\", \"set the number of subsegments to be written in each SIDX box\\n\"\n\t\"- 0: a single SIDX box is used per segment\\n\"\n\t\"- -1: no SIDX box is used\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &subsegs_per_sidx, 0, 0),\n\tMP4BOX_ARG(\"ssix\", \"enable SubsegmentIndexBox describing 2 ranges, first one from moof to end of first I-frame, second one unmapped. This does not work with daisy chaining mode enabled\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_ssix, 0, 0),\n\tMP4BOX_ARG(\"url-template\", \"use SegmentTemplate instead of explicit sources in segments. Ignored if segments are stored in the output file\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 1, 0),\n\tMP4BOX_ARG(\"url-template-sim\", \"use SegmentTemplate simulation while converting HLS to MPD\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &use_url_template, 2, 0),\n\tMP4BOX_ARG(\"daisy-chain\", \"use daisy-chain SIDX instead of hierarchical. Ignored if frags/sidx is 0\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &daisy_chain_sidx, 0, 0),\n\tMP4BOX_ARG(\"single-segment\", \"use a single segment for the whole file (OnDemand profile)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_segment, 0, 0),\n\t{\"single-file\", NULL, \"use a single file for the whole file (default)\", \"yes\", NULL, GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_file, 0, 0},\n\t{\"bs-switching\", NULL, \"set bitstream switching mode\\n\"\n\t\"- inband: use inband param set and a single init segment\\n\"\n\t\"- merge: try to merge param sets in a single sample description, fallback to `no`\\n\"\n\t\"- multi: use several sample description, one per quality\\n\"\n\t\"- no: use one init segment per quality\\n\"\n\t\"- single: to test with single input\", \"inband\", \"inband|merge|multi|no|single\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_bs_switch, 0, ARG_IS_FUN},\n\tMP4BOX_ARG(\"moof-sn\", \"set sequence number of first moof to given value\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_moof_sn, 0, 0),\n\tMP4BOX_ARG(\"tfdt\", \"set TFDT of first traf to given value in SCALE units (cf -dash-scale)\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &initial_tfdt, 0, ARG_64BITS),\n\tMP4BOX_ARG(\"no-frags-default\", \"disable default fragments flags in trex (required by some dash-if profiles and CMAF/smooth streaming compatibility)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &no_fragments_defaults, 0, 0),\n\tMP4BOX_ARG(\"single-traf\", \"use a single track fragment per moof (smooth streaming and derived specs may require this)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &single_traf_per_moof, 0, 0),\n\tMP4BOX_ARG(\"tfdt-traf\", \"use a tfdt per track fragment (when -single-traf is used)\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &tfdt_per_traf, 0, 0),\n\tMP4BOX_ARG(\"dash-ts-prog\", \"program_number to be considered in case of an MPTS input file\", GF_ARG_INT, GF_ARG_HINT_EXPERT, &program_number, 0, 0),\n\tMP4BOX_ARG(\"frag-rt\", \"when using fragments in live mode, flush fragments according to their timing\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &frag_real_time, 0, 0),\n\tMP4BOX_ARG(\"cp-location\", \"set ContentProtection element location\\n\"\n\t        \"- as: sets ContentProtection in AdaptationSet element\\n\"\n\t        \"- rep: sets ContentProtection in Representation element\\n\"\n\t        \"- both: sets ContentProtection in both elements\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, parse_cp_loc, 0, ARG_IS_FUN),\n\tMP4BOX_ARG(\"start-date\", \"for live mode, set start date (as xs:date, eg YYYY-MM-DDTHH:MM:SSZ). Default is current UTC\\n\"\n\t\"Warning: Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_start_date, 0, 0),\n\tMP4BOX_ARG(\"cues\", \"ignore dash duration and segment according to cue times in given XML file (tests/media/dash_cues for examples)\", GF_ARG_STRING, GF_ARG_HINT_EXPERT, &dash_cues, 0, 0),\n\tMP4BOX_ARG(\"strict-cues\", \"throw error if something is wrong while parsing cues or applying cue-based segmentation\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &strict_cues, 0, 0),\n\tMP4BOX_ARG(\"merge-last-seg\", \"merge last segment if shorter than half the target duration\", GF_ARG_BOOL, GF_ARG_HINT_EXPERT, &merge_last_seg, 0, 0),\n\t{0}\n};\n\nvoid PrintDASHUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# DASH Options\\n\"\n\t\t\"Also see:\\n\"\n\t\t\"- the [dasher `gpac -h dash`](dasher) filter documentation\\n\"\n\t\t\"- [[DASH wiki|DASH-intro]].\\n\"\n\t\t\"\\n\"\n\t\t\"# Specifying input files\\n\"\n\t\t\"Input media files to dash can use the following modifiers\\n\"\n\t\t\"- #trackID=N: only use the track ID N from the source file\\n\"\n\t\t\"- #N: only use the track ID N from the source file (mapped to [-tkid](mp4dmx))\\n\"\n\t\t\"- #video: only use the first video track from the source file\\n\"\n\t\t\"- #audio: only use the first audio track from the source file\\n\"\n\t\t\"- :id=NAME: set the representation ID to NAME. Reserved value `NULL` disables representation ID for multiplexed inputs. If not set, a default value is computed and all selected tracks from the source will be in the same output mux.\\n\"\n\t\t\"- :dur=VALUE: process VALUE seconds from the media. If VALUE is longer than media duration, last sample duration is extended.\\n\"\n\t\t\"- :period=NAME: set the representation's period to NAME. Multiple periods may be used. Periods appear in the MPD in the same order as specified with this option\\n\"\n\t\t\"- :BaseURL=NAME: set the BaseURL. Set multiple times for multiple BaseURLs\\nWarning: This does not modify generated files location (see segment template).\\n\"\n\t\t\"- :bandwidth=VALUE: set the representation's bandwidth to a given value\\n\"\n\t\t\"- :pdur=VALUE: increase the duration of this period by the given duration in seconds (alias for period_duration:VALUE). This is only used when no input media is specified (remote period insertion), eg `:period=X:xlink=Z:pdur=Y`\\n\"\n\t\t\"- :duration=VALUE: override target DASH segment duration for this input\\n\"\n\t\t\"- :xlink=VALUE: set the xlink value for the period containing this element. Only the xlink declared on the first rep of a period will be used\\n\"\n\t\t\"- :asID=VALUE: set the AdaptationSet ID to NAME\\n\"\n\t\t\"- :role=VALUE: set the role of this representation (cf DASH spec). Media with different roles belong to different adaptation sets.\\n\"\n\t\t\"- :desc_p=VALUE: add a descriptor at the Period level. Value must be a properly formatted XML element.\\n\"\n\t\t\"- :desc_as=VALUE: add a descriptor at the AdaptationSet level. Value must be a properly formatted XML element. Two input files with different values will be in different AdaptationSet elements.\\n\"\n\t\t\"- :desc_as_c=VALUE: add a descriptor at the AdaptationSet level. Value must be a properly formatted XML element. Value is ignored while creating AdaptationSet elements.\\n\"\n\t\t\"- :desc_rep=VALUE: add a descriptor at the Representation level. Value must be a properly formatted XML element. Value is ignored while creating AdaptationSet elements.\\n\"\n\t\t\"- :sscale: force movie timescale to match media timescale of the first track in the segment.\\n\"\n\t\t\"- :trackID=N: only use the track ID N from the source file\\n\"\n\t\t\"- @f1[:args][@fN:args][@@fK:args]: set a filter chain to insert between the source and the dasher. Each filter in the chain is formatted as a regular filter, see [filter doc `gpac -h doc`](filters_general). If several filters are set:\\n\"\n\t\t\"  - they will be chained in the given order if separated by a single `@`\\n\"\n\t\t\"  - a new filter chain will be created if separated by a double `@@`. In this case, no representation ID is assigned to the source.\\n\"\n\t\t\"EX source.mp4:@enc:c=avc:b=1M@@enc:c=avc:b=500k\\n\"\n\t\t\"This will load a filter chain with two encoders connected to the source and to the dasher.\\n\"\n\t\t\"EX source.mp4:@enc:c=avc:b=1M@enc:c=avc:b=500k\\n\"\n\t\t\"This will load a filter chain with the second encoder connected to the output of the first (!!).\\n\"\n\t\t\"\\n\"\n\t\t\"Note: `@f` must be placed after all other options.\\n\"\n\t\t\"\\n\"\n\t\t\"# Options\\n\"\n\t\t);\n\n\n\twhile (m4b_dash_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_dash_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-dash\");\n\t}\n}\n\n\nMP4BoxArg m4b_imp_args[] =\n{\n \tMP4BOX_ARG(\"add\", \"add given file tracks to file. Multiple inputs can be specified using `+`, eg `-add url1+url2`\", GF_ARG_STRING, 0, &nb_add, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"cat\", \"concatenate given file samples to file, creating tracks if needed. Multiple inputs can be specified using `+`, eg `-cat url1+url2`.  \\nNote: This aligns initial timestamp of the file to be concatenated\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"catx\", \"same as [-cat]() but new tracks can be imported before concatenation by specifying `+ADD_COMMAND` where `ADD_COMMAND` is a regular [-add]() syntax\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"catpl\", \"concatenate files listed in the given playlist file (one file per line, lines starting with # are comments).  \\nNote: Each listed file is concatenated as if called with -cat\", GF_ARG_STRING, 0, &nb_cat, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"unalign-cat\", \"do not attempt to align timestamps of samples in-between tracks\", GF_ARG_BOOL, 0, &align_cat, 0, ARG_BOOL_REV),\n \tMP4BOX_ARG(\"force-cat\", \"skip media configuration check when concatenating file.  \\nWarning: THIS MAY BREAK THE CONCATENATED TRACK(S)\", GF_ARG_BOOL, 0, &force_cat, 0, 0),\n \tMP4BOX_ARG(\"keep-sys\", \"keep all MPEG-4 Systems info when using [-add]() and [-cat]() (only used when adding IsoMedia files)\", GF_ARG_BOOL, 0, &keep_sys_tracks, 0, 0),\n \tMP4BOX_ARG(\"dref\", \"keep media data in original file using `data referencing`. The resulting file only contains the meta-data of the presentation (frame sizes, timing, etc...) and references media data in the original file. This is extremely useful when developing content, since importing and storage of the MP4 file is much faster and the resulting file much smaller.  \\nNote: Data referencing may fail on some files because it requires the framed data (eg an IsoMedia sample) to be continuous in the original file, which is not always the case depending on the original interleaving or bitstream format (__AVC__ or __HEVC__ cannot use this option)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_USE_DATAREF, ARG_BIT_MASK),\n \tMP4BOX_ARG_ALT(\"no-drop\", \"nodrop\", \"force constant FPS when importing AVI video\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_NO_FRAME_DROP, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"packed\", \"force packed bitstream when importing raw MPEG-4 part 2 Advanced Simple Profile\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_PACKED, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sbr\", \"backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_IMPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sbrx\", \"non-backward compatible signaling of AAC-SBR\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_SBR_EXPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"ps\", \"backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_IMPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"psx\", \"non-backward compatible signaling of AAC-PS\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_PS_EXPLICIT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"ovsbr\", \"oversample SBR import (SBR AAC, PS AAC and oversampled SBR cannot be detected at import time)\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_OVSBR, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"fps\", \"force frame rate for video and SUB subtitles import to the given value, expressed as a number, as `TS-inc` or `TS/inc`.  \\nNote: For raw H263 import, default FPS is `15`, otherwise `25`. This is ignored for ISOBMFF import, use `:rescale` option for that\", GF_ARG_STRING, 0, parse_fps, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mpeg4\", \"force MPEG-4 sample descriptions when possible. For AAC, forces MPEG-4 AAC signaling even if MPEG-2\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"agg\", \"aggregate N audio frames in 1 sample (3GP media only, maximum value is 15)\", GF_ARG_INT, 0, &agg_samples, 0, 0),\n\t{0}\n};\n\n\nstatic MP4BoxArg m4b_imp_fileopt_args [] = {\n\tGF_DEF_ARG(\"dur\", NULL, \"`XC` import only the specified duration from the media. Value can be:\\n\"\n\t\t\"  - positive float: specifies duration in seconds\\n\"\n\t\t\"  - fraction: specifies duration as NUM/DEN fraction\\n\"\n\t\t\"  - negative integer: specifies duration in number of coded frames\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"start\", NULL, \"`C` target start time in source media, may not be supported depending on the source\", NULL, NULL, GF_ARG_DOUBLE, 0),\n\tGF_DEF_ARG(\"lang\", NULL, \"`S` set imported media language code\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"delay\", NULL, \"`S` set imported media initial delay in ms or as fractional seconds (`N/D`)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"par\", NULL, \"`S` set visual pixel aspect ratio (see [-par](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"clap\", NULL, \"`S` set visual clean aperture (see [-clap](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"mx\", NULL, \"`S` set track matrix (see [-mx](MP4B_GEN) )\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"name\", NULL, \"`S` set track handler name\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"ext\", NULL, \"override file extension when importing\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"hdlr\", NULL, \"`S` set track handler type to the given code point (4CC)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"tkhd\", NULL, \"`S` set track header flags has hex integer. Use `tkhd+=FLAGS` to add flags and `tkhd-=FLAGS` to remove flags\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"disable\", NULL, \"`S` disable imported track(s), use `disable=no` to force enabling a disabled track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"group\", NULL, \"`S` add the track as part of the G alternate group. If G is 0, the first available GroupID will be picked\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"fps\", NULL, \"same as [-fps]()\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"rap\", NULL, \"`DS` import only RAP samples\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"refs\", NULL, \"`DS` import only reference pictures\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"trailing\", NULL, \"keep trailing 0-bytes in AVC/HEVC samples\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"agg\", NULL, \"`X` same as [-agg]()\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"dref\", NULL, \"`XC` same as [-dref]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"keep_refs\", NULL, \"`C` keep track reference when importing a single track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nodrop\", NULL, \"same as [-nodrop]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"packed\", NULL, \"`X` same as [-packed]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"sbr\", NULL, \"same as [-sbr]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"sbrx\", NULL, \"same as [-sbrx]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ovsbr\", NULL, \"same as [-ovsbr]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ps\", NULL, \"same as [-ps]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"psx\", NULL, \"same as [-psx]()\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"asemode\", NULL, \"`XS` set the mode to create the AudioSampleEntry. Value can be:\\n\"\n\t\t\"  - v0-bs: use MPEG AudioSampleEntry v0 and the channel count from the bitstream (even if greater than 2) - default\\n\"\n\t\t\"  - v0-2: use MPEG AudioSampleEntry v0 and the channel count is forced to 2\\n\"\n\t\t\"  - v1: use MPEG AudioSampleEntry v1 and the channel count from the bitstream\\n\"\n\t\t\"  - v1-qt: use QuickTime Sound Sample Description Version 1 and the channel count from the bitstream (even if greater than 2). This will also trigger using alis data references instead of url, even for non-audio tracks\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"audio_roll\", NULL, \"`S` add a roll sample group with roll_distance `N` for audio tracks\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"roll\", NULL, \"`S` add a roll sample group with roll_distance `N`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"proll\", NULL, \"`S` add a preroll sample group with roll_distance `N`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"mpeg4\", NULL, \"`X` same as [-mpeg4]() option\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nosei\", NULL, \"discard all SEI messages during import\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"svc\", NULL, \"import SVC/LHVC with explicit signaling (no AVC base compatibility)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"nosvc\", NULL, \"discard SVC/LHVC data when importing\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"svcmode\", NULL, \"`DS` set SVC/LHVC import mode. Value can be:\\n\"\n\t\t\"  - split: each layer is in its own track\\n\"\n\t\t\"  - merge: all layers are merged in a single track\\n\"\n\t\t\"  - splitbase: all layers are merged in a track, and the AVC base in another\\n\"\n\t\t\"  - splitnox: each layer is in its own track, and no extractors are written\\n\"\n\t\t\"  - splitnoxib: each layer is in its own track, no extractors are written, using inband param set signaling\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"temporal\", NULL, \"`DS` set HEVC/LHVC temporal sublayer import mode. Value can be:\\n\"\n\t\t\"  - split: each sublayer is in its own track\\n\"\n\t\t\"  - splitbase: all sublayers are merged in a track, and the HEVC base in another\\n\"\n\t\t\"  - splitnox: each layer is in its own track, and no extractors are written\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"subsamples\", NULL, \"add SubSample information for AVC+SVC\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"deps\", NULL, \"import sample dependency information for AVC and HEVC\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"ccst\", NULL, \"`S` add default HEIF ccst box to visual sample entry\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"forcesync\", NULL, \"force non IDR samples with I slices (OpenGOP or GDR) to be marked as sync points\\n\"\n\t\t\"Warning: RESULTING FILE IS NOT COMPLIANT WITH THE SPEC but will fix seeking in most players\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"xps_inband\", NULL, \"`XC` set xPS inband for AVC/H264 and HEVC (for reverse operation, re-import from raw media)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"xps_inbandx\", NULL, \"`XC` same as xps_inband and also keep first xPS in sample description\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"au_delim\", NULL, \"keep AU delimiter NAL units in the imported file\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"max_lid\", NULL, \"set HEVC max layer ID to be imported to `N` (by default imports all layers)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"max_tid\", NULL, \"set HEVC max temporal ID to be imported to `N` (by default imports all temporal sublayers)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"tiles\", NULL, \"`S` add HEVC tiles signaling and NALU maps without splitting the tiles into different tile tracks\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"split_tiles\", NULL, \"`DS` split HEVC tiles into different tile tracks, one tile (or all tiles of one slice) per track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"negctts\", NULL, \"`S` use negative CTS-DTS offsets (ISO4 brand). Use `negctts=no` to force using positive offset on existing track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"chap\", NULL, \"`S` specify the track is a chapter track\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"chapter\", NULL, \"`S` add a single chapter (old nero format) with given name lasting the entire file\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"chapfile\", NULL, \"`S` add a chapter file (old nero format)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"layout\", NULL, \"`S` specify the track layout as `WxH[xXxY][xLAYER]`. If `W` (resp `H`) is 0, the max width (resp height) of the tracks in the file are used\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"rescale\", NULL, \"`S` force media timescale to TS  (int or fraction) and change the media duration\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"sampdur\", NULL, \"`S` force all samples duration (`D`) or sample durations and media timescale (`D/TS`), used to patch CFR files with broken timings\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"timescale\", NULL, \"`S` set imported media timescale to TS\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"moovts\", NULL, \"`S` set movie timescale to TS. A negative value picks the media timescale of the first track imported\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"noedit\", NULL, \"`XS` do not set edit list when importing B-frames video tracks\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"rvc\", NULL, \"`S` set RVC configuration for the media\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"fmt\", NULL, \"override format detection with given format - disable data probing and force `ext` option on source\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"profile\", NULL, \"`S` override AVC profile. Integer value, or `high444`, `high`, `extended`, `main`, `baseline`\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"level\", NULL, \"`S` override AVC level, if value < 6, interpreted as decimal expression\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"compat\", NULL, \"`S` force the profile compatibility flags for the H.264 content\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"novpsext\", NULL, \"remove VPS extensions from HEVC VPS\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"keepav1t\", NULL, \"keep AV1 temporal delimiter OBU in samples, might help if source file had losses\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"font\", NULL, \"specify font name for text import (default `Serif`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"size\", NULL, \"specify font size for text import (default `18`)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"text_layout\", NULL, \"specify the track text layout as WxHxXxY\\n\"\n\t\t\"  - if W (resp H) = 0: the max width (resp height) of the tracks in the file are used\\n\"\n\t\t\"  - if Y=-1: the layout is moved to the bottom of the track area\\n\"\n\t\t\"  - X and Y can be omitted: `:layout=WxH`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"swf-global\", NULL, \"all SWF defines are placed in first scene replace rather than when needed\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-ctrl\", NULL, \"use a single stream for movie control and dictionary (this will disable ActionScript)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-text\", NULL, \"remove all SWF text\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-font\", NULL, \"remove all embedded SWF Fonts (local playback host fonts used)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-line\", NULL, \"remove all lines from SWF shapes\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-no-grad\", NULL, \"remove all gradients from SWF shapes\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-quad\", NULL, \"use quadratic bezier curves instead of cubic ones\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-xlp\", NULL, \"support for lines transparency and scalability\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-ic2d\", NULL, \"use indexed curve 2D hardcoded proto\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-same-app\", NULL, \"appearance nodes are reused\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"swf-flatten\", NULL, \"complementary angle below which 2 lines are merged, `0` means no flattening\", NULL, NULL, GF_ARG_DOUBLE, 0),\n\tGF_DEF_ARG(\"kind\", NULL, \"`S` set kind for the track as `schemeURI=value`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"txtflags\", NULL, \"set display flags (hexa number) of text track. Use `txtflags+=FLAGS` to add flags and `txtflags-=FLAGS` to remove flags\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"rate\", NULL, \"force average rate and max rate to VAL (in bps) in btrt box. If 0, removes btrt box\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"stz2\", NULL, \"`S` use compact size table (for low-bitrates)\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"bitdepth\", NULL, \"set bit depth to VAL for imported video content (default is 24)\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"colr\", NULL, \"`S` set color profile for imported video content (see ISO/IEC 23001-8). Value is formatted as:\\n\"\n\t\t\"  - nclc,p,t,m: with p colour primary (int or string), t transfer characteristics (int or string) and m matrix coef (int or string)\\n\"\n\t\t\"  - nclx,p,t,m,r: same as `nclx` with r full range flag (`yes`, `on` or `no`, `off`)\\n\"\n\t\t\"  - prof,path: with path indicating the file containing the ICC color profile\\n\"\n\t\t\"  - rICC,path: with path indicating the file containing the restricted ICC color profile\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"dv-profile\", NULL, \"`S` set the Dolby Vision profile\", NULL, NULL, GF_ARG_INT, 0),\n\tGF_DEF_ARG(\"fullrange\", NULL, \"`S` force the video fullrange type in VUI for the AVC|H264 content (value `yes`, `on` or `no`, `off`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"videofmt\", NULL, \"`S` force the video format in VUI for AVC|H264 and HEVC content, value can be `component`, `pal`, `ntsc`, `secam`, `mac`, `undef`\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colorprim\", NULL, \"`S` force the colour primaries in VUI for AVC|H264 and HEVC (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colortfc\", NULL, \"`S` force transfer characteristics in VUI for AVC|H264 and HEVC (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"colormx\", NULL, \"`S` force the matrix coefficients in VUI for the AVC|H264 and HEVC content (int or string, cf `-h cicp`)\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"tc\", NULL, \"`S` inject a single QT timecode. Value is formatted as:\\n\"\n\t\t\"  - [d]FPS[/FPS_den],h,m,s,f[,framespertick]: optional drop flag, framerate (integer or fractional), hours, minutes, seconds and frame number\\n\"\n\t\t\"  - : `d` is an optional flag used to indicate that the counter is in drop-frame format\\n\"\n\t\t\"  - : the `framespertick` is optional and defaults to round(framerate); it indicates the number of frames per counter tick\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"edits\", NULL, \"`S` override edit list, same syntax as [-edits]()\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"lastsampdur\", NULL, \"`S` set duration of the last sample. Value is formatted as:\\n\"\n\t\t\"  - no value: use the previous sample duration\\n\"\n\t\t\"  - integer: indicate the duration in milliseconds\\n\"\n\t\t\"  - N/D: indicate the duration as fractional second\", NULL, NULL, GF_ARG_STRING, 0),\n\tGF_DEF_ARG(\"fstat\", NULL, \"print filter session stats after import\", NULL, NULL, GF_ARG_BOOL, 0),\n\tGF_DEF_ARG(\"fgraph\", NULL, \"print filter session graph after import\", NULL, NULL, GF_ARG_BOOL, 0),\n\t{\"sopt:[OPTS]\", NULL, \"set `OPTS` as additional arguments to source filter. `OPTS` can be any usual filter argument, see [filter doc `gpac -h doc`](Filters)\"},\n\t{\"dopt:[OPTS]\", NULL, \"`X` set `OPTS` as additional arguments to [destination filter](mp4mx). OPTS can be any usual filter argument, see [filter doc `gpac -h doc`](Filters)\"},\n\t{\"@f1[:args][@fN:args]\", NULL, \"set a filter chain to insert before the muxer. Each filter in the chain is formatted as a regular filter, see [filter doc `gpac -h doc`](Filters). A `@@` separator starts a new chain (see DASH help). The last filter in each chain shall not have any ID specified\"},\n\t{0}\n};\n\nvoid PrintImportUsage()\n{\n\tu32 i;\n\n\tgf_sys_format_help(helpout, help_flags, \"# Importing Options\\n\"\n\t\t\"# File importing\\n\"\n\t\t\"Syntax is [-add]() / [-cat]() `URL[#FRAGMENT][:opt1...:optN=val]`\\n\"\n\t\t\"This process will create the destination file if not existing, and add the track(s) to it. If you wish to always create a new destination file, add [-new](MP4B_GEN).\\n\"\n\t\t\"The supported input media types depend on your installation, check [filters documentation](Filters) for more info.\\n\"\n\t\t\"  \\n\"\n\t\t\"To select a desired media track from a source, a fragment identifier '#' can be specified, before any other options. The following syntax is used:\\n\"\n\t\t\"- `#video`: adds the first video track found in source\\n\"\n\t\t\"- `#audio`: adds the first audio track found in source\\n\"\n\t\t\"- `#auxv`: adds the first auxiliary video track found in source\\n\"\n\t\t\"- `#pict`: adds the first picture track found in source\\n\"\n\t\t\"- `#trackID=ID` or `#ID`: adds the specified track. For IsoMedia files, ID is the track ID. For other media files, ID is the value indicated by `MP4Box -info inputFile`\\n\"\n\t\t\"- `#pid=ID`: number of desired PID for MPEG-2 TS sources\\n\"\n\t\t\"- `#prog_id=ID`: number of desired program for MPEG-2 TS sources\\n\"\n\t\t\"- `#program=NAME`: name of desired program for MPEG-2 TS sources\\n\"\n\t\t\"  \\n\"\n\t\t\"By default all imports are performed sequentially, and final interleaving is done at the end; this however requires a temporary file holding original ISOBMF file (if any) and added files before creating the final output. Since this can become quite large, it is possible to add media to a new file without temporary storage, using [-flat](MP4B_GEN) option, but this disables media interleaving.\\n\"\n\t\t\"  \\n\"\n\t\t\"If you wish to create an interleaved new file with no temporary storage, use the [-newfs](MP4B_GEN) option. The interleaving might not be as precise as when using [-new]() since it is dependent on muxer input scheduling (each execution might lead to a slightly different result). Additionally in this mode: \\n\"\n\t\t\" - Some muxing options (marked with `X` below) will be activated for all inputs (e.g it is not possible to import one AVC track with `xps_inband` and another without).\\n\"\n\t\t\" - Some muxing options (marked as `D` below) cannot be used as they require temporary storage for file edition.\\n\"\n\t\t\" - Usage of [-cat]() is possible, but concatenated sources will not be interleaved in the output. If you wish to perform more complex cat/add operations without temp file, use a [playlist](flist).\\n\"\n\t\t\"  \\n\"\n\t\t\"Source URL can be any URL supported by GPAC, not limited to local files.\\n\"\n\t\t\"  \\n\"\n\t\t\"Note: When importing SRT or SUB files, MP4Box will choose default layout options to make the subtitle appear at the bottom of the video. You SHOULD NOT import such files before any video track is added to the destination file, otherwise the results will likely not be useful (default SRT/SUB importing uses default serif font, fontSize 18 and display size 400x60). For more details, check [TTXT doc](Subtitling-with-GPAC).\\n\"\n\t\t\"  \\n\"\n\t\t\"When importing several tracks/sources in one pass, all options will be applied if relevant to each source. These options are set for all imported streams. If you need to specify these options per stream, set per-file options using the syntax `-add stream[:opt1:...:optN]`.\\n\"\n\t\t\"  \\n\"\n\t\t\"The import file name may be set to empty or `self`, indicating that the import options should be applied to the destination file track(s).\\n\"\n\t\t\"EX -add self:moovts=-1:noedit src.mp4\\n\"\n\t\t\"This will apply `moovts` and `noedit` option to all tracks in src.mp4\\n\"\n\t\t\"EX -add self#2:moovts=-1:noedit src.mp4\\n\"\n\t\t\"This will apply `moovts` and `noedit` option to track with `ID=2` in src.mp4\\n\"\n\t\t\"Only per-file options marked with a `S` are possible in this mode.\\n\"\n\t\t\"  \\n\"\n\t\t\"When importing an ISOBMFF/QT file, only options marked as `C` or `S` can be used.\\n\"\n\t\t\"  \\n\"\n\t\t\"Allowed per-file options:\\n\\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_imp_fileopt_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_fileopt_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags | GF_PRINTARG_NO_DASH, arg, \"mp4box-import\");\n\t}\n\n\tgf_sys_format_help(helpout, help_flags, \"\\n\"\n\t\t\"Note: `sopt`, `dopt` and `@f` must be placed after all other options.\\n\"\n\t\t\"# Global import options\\n\"\n\t);\n\n\ti=0;\n\twhile (m4b_imp_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_imp_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-import\");\n\t}\n}\n\nBool mp4box_check_isom_fileopt(char *opt)\n{\n\tGF_GPACArg *arg = NULL;\n\tu32 i=0;\n\n\twhile (m4b_imp_fileopt_args[i].name) {\n\t\targ = (GF_GPACArg *) &m4b_imp_fileopt_args[i];\n\t\ti++;\n\t\tif (!stricmp(arg->name, opt)) break;\n\t\targ = NULL;\n\t}\n\tif (!arg) {\n\t\tfprintf(stderr, \"Option %s not described in doc, please report to GPAC devs!\\n\", opt);\n\t\treturn GF_FALSE;\n\t}\n\tif (arg->description[0] != '`')\n\t\treturn GF_FALSE;\n\tconst char *d = arg->description+1;\n\twhile (d[0] != '`') {\n\t\tif (d[0]=='S') return GF_TRUE;\n\t\tif (d[0]=='C') return GF_TRUE;\n\t\td++;\n\t}\n\treturn GF_FALSE;\n}\n\n\nMP4BoxArg m4b_senc_args[] =\n{\n \tMP4BOX_ARG(\"mp4\", \"specify input file is for BIFS/LASeR encoding\", GF_ARG_BOOL, 0, &encode, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"def\", \"encode DEF names in BIFS\", GF_ARG_BOOL, 0, &smenc_opts.flags, GF_SM_ENCODE_USE_NAMES, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"sync\", \"force BIFS sync sample generation every given time in ms (cannot be used with [-shadow]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"shadow\", \"force BIFS sync shadow sample generation every given time in ms (cannot be used with [-sync]() or [-carousel]() )\", GF_ARG_INT, 0, parse_senc_param, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"carousel\", \"use BIFS carousel (cannot be used with [-sync]() or [-shadow]() )\", GF_ARG_INT, 0, parse_senc_param, 2, ARG_IS_FUN),\n\n \tMP4BOX_ARG(\"sclog\", \"generate scene codec log file if available\", GF_ARG_BOOL, 0, &do_scene_log, 0, 0),\n \tMP4BOX_ARG(\"ms\", \"import tracks from the given file\", GF_ARG_STRING, 0, &mediaSource, 0, 0),\n \tMP4BOX_ARG(\"ctx-in\", \"specify initial context (MP4/BT/XMT) file for chunk processing. Input file must be a commands-only file\", GF_ARG_STRING, 0, parse_senc_param, 5, ARG_IS_FUN),\n \tMP4BOX_ARG(\"ctx-out\", \"specify storage of updated context (MP4/BT/XMT) file for chunk processing, optional\", GF_ARG_STRING, 0, &output_ctx, 0, 0),\n \tMP4BOX_ARG(\"resolution\", \"resolution factor (-8 to 7, default 0) for LASeR encoding, and all coordinates are multiplied by `2^res` before truncation (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.resolution, 0, 0),\n \tMP4BOX_ARG(\"coord-bits\", \"number of bits used for encoding truncated coordinates (0 to 31, default 12) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.coord_bits, 0, 0),\n \tMP4BOX_ARG(\"scale-bits\", \"extra bits used for encoding truncated scales (0 to 4, default 0) (LASeR encoding)\", GF_ARG_INT, 0, &smenc_opts.scale_bits, 0, 0),\n \tMP4BOX_ARG(\"auto-quant\", \"resolution is given as if using [-resolution]() but coord-bits and scale-bits are infered (LASeR encoding)\", GF_ARG_INT, 0, parse_senc_param, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"global-quant\", \"resolution is given as if using [-resolution]() but the res is inferred (BIFS encoding)\", GF_ARG_INT, 0, parse_senc_param, 4, ARG_IS_FUN),\n \t{0}\n};\n\n\nvoid PrintEncodeUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# MPEG-4 Scene Encoding Options\\n\"\n\t\t\"## General considerations\\n\"\n\t\t\"MP4Box supports encoding and decoding of of BT, XMT, VRML and (partially) X3D formats int MPEG-4 BIFS, and encoding and decoding of XSR and SVG into MPEG-4 LASeR\\n\"\n\t\t\"Any media track specified through a `MuxInfo` element will be imported in the resulting MP4 file.\\n\"\n\t\t\"See https://wiki.gpac.io/MPEG-4-BIFS-Textual-Format and related pages.\\n\"\n\t\t\"## Scene Random Access\\n\"\n\t\t\"MP4Box can encode BIFS or LASeR streams and insert random access points at a given frequency. This is useful when packaging content for broadcast, where users will not turn in the scene at the same time. In MPEG-4 terminology, this is called the __scene carousel__.\"\n\t\t\"## BIFS Chunk Processing\\n\"\n\t\t\"The BIFS chunk encoding mode alows encoding single BIFS access units from an initial context and a set of commands.\\n\"\n\t\t\"The generated AUs are raw BIFS (not SL-packetized), in files called FILE-ESID-AUIDX.bifs, with FILE the basename of the input file.\\n\"\n\t\t\"Commands with a timing of 0 in the input will modify the carousel version only (i.e. output context).\\n\"\n\t\t\"Commands with a timing different from 0 in the input will generate new AUs.\\n\"\n\t\t\"  \\n\"\n\t\t\"Options:\\n\"\n\t);\n\n\twhile (m4b_senc_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_senc_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-senc\");\n\t}\n}\n\nMP4BoxArg m4b_crypt_args[] =\n{\n \tMP4BOX_ARG(\"crypt\", \"encrypt the input file using the given `CryptFile`\", GF_ARG_STRING, 0, parse_cryp, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"decrypt\", \"decrypt the input file, potentially using the given `CryptFile`. If `CryptFile` is not given, will fail if the key management system is not supported\", GF_ARG_STRING, 0, parse_cryp, 1, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG_S(\"set-kms\", \"tkID=kms_uri\", \"change ISMA/OMA KMS location for a given track or for all tracks if `all=` is used\", 0, parse_track_action, TRAC_ACTION_SET_KMS_URI, ARG_IS_FUN),\n \t{0}\n};\n\nvoid PrintEncryptUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Encryption/Decryption Options\\n\"\n\t\"MP4Box supports encryption and decryption of ISMA, OMA and CENC content, see [encryption filter `gpac -h cecrypt`](cecrypt).\\n\"\n\t\"It requires a specific XML file called `CryptFile`, whose syntax is available at https://wiki.gpac.io/Common-Encryption\\n\"\n\t\"Image files (HEIF) can also be crypted / decrypted, using CENC only.\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_crypt_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_crypt_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-crypt\");\n\t}\n}\n\nMP4BoxArg m4b_hint_args[] =\n{\n \tMP4BOX_ARG(\"hint\", \"hint the file for RTP/RTSP\", GF_ARG_BOOL, 0, &do_hint, 0, ARG_OPEN_EDIT),\n \t{\"mtu\", NULL, \"specify RTP MTU (max size) in bytes (this includes 12 bytes RTP header)\", \"1450\", NULL, GF_ARG_INT, 0, &MTUSize, 0, 0},\n \tMP4BOX_ARG(\"copy\", \"copy media data to hint track rather than reference (speeds up server but takes much more space)\", GF_ARG_BOOL, 0, &HintCopy, 0, 0),\n \tMP4BOX_ARG_S(\"multi\", \"[maxptime]\", \"enable frame concatenation in RTP packets if possible (with max duration 100 ms or `maxptime` ms if given)\", 0, parse_multi_rtp, 0, ARG_IS_FUN),\n \t{\"rate\", NULL, \"specify rtp rate in Hz when no default for payload\", \"90000\", NULL, GF_ARG_INT, 0, &rtp_rate, 0, 0},\n \tMP4BOX_ARG(\"mpeg4\", \"force MPEG-4 generic payload whenever possible\", GF_ARG_BOOL, 0, &import_flags, GF_IMPORT_FORCE_MPEG4, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"latm\", \"force MPG4-LATM transport for AAC streams\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_LATM_AAC, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"static\", \"enable static RTP payload IDs whenever possible (by default, dynamic payloads are always used)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_USE_STATIC_ID, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"add-sdp\", \"add given SDP string to hint track (`tkID:string`) or movie (`string`)\", GF_ARG_STRING, 0, parse_sdp_ext, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"no-offset\", \"signal no random offset for sequence number and timestamp (support will depend on server)\", GF_ARG_BOOL, 0, &hint_no_offset, 0, 0),\n \tMP4BOX_ARG(\"unhint\", \"remove all hinting information from file\", GF_ARG_BOOL, 0, &remove_hint, 0, ARG_OPEN_EDIT),\n \tMP4BOX_ARG(\"group-single\", \"put all tracks in a single hint group\", GF_ARG_BOOL, 0, &single_group, 0, 0),\n \tMP4BOX_ARG(\"ocr\", \"force all MPEG-4 streams to be synchronized (MPEG-4 Systems only)\", GF_ARG_BOOL, 0, &force_ocr, 0, 0),\n \tMP4BOX_ARG(\"rap\", \"signal random access points in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, parse_rap_ref, 0, ARG_IS_FUN | ARG_EMPTY),\n \tMP4BOX_ARG(\"ts\", \"signal AU Time Stamps in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_TS, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"size\", \"signal AU size in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_SIZE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"idx\", \"signal AU sequence numbers in RTP packets (MPEG-4 Systems)\", GF_ARG_BOOL, 0, &hint_flags, GP_RTP_PCK_SIGNAL_AU_IDX, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"iod\", \"prevent systems tracks embedding in IOD (MPEG-4 Systems), not compatible with [-isma]()\", GF_ARG_BOOL, 0, &regular_iod, 0, 0),\n \t{0}\n};\n\nvoid PrintHintUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Hinting Options\\n\"\n\t\t\"IsoMedia hinting consists in creating special tracks in the file that contain transport protocol specific information and optionally multiplexing information. These tracks are then used by the server to create the actual packets being sent over the network, in other words they provide the server with hints on how to build packets, hence their names `hint tracks`.\\n\"\n\t\t\"MP4Box supports creation of hint tracks for RTSP servers supporting these such as QuickTime Streaming Server, DarwinStreaming Server or 3GPP-compliant RTSP servers.\\n\"\n\t\t\"Note: GPAC streaming tools [rtp output](rtpout) and [rtsp server](rtspout) do not use hint tracks, they use on-the-fly packetization \"\n\t\t\"from any media sources, not just MP4\\n\"\n\t\t\"  \\n\"\n\t\t\"Options:\\n\"\n\t);\n\twhile (m4b_hint_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_hint_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-hint\");\n\t}\n}\n\n\nMP4BoxArg m4b_extr_args[] =\n{\n \tMP4BOX_ARG(\"raw\", \"extract given track in raw format when supported. Use `tkID:output=FileName` to set output file name\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NATIVE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"raws\", \"extract each sample of the given track to a file. Use `tkID:N` to extract the Nth sample\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_RAW_SAMPLES, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nhnt\", \"extract given track to [NHNT](nhntr) format\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NHNT, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nhml\", \"extract given track to [NHML](nhmlr) format. Use `tkID:full` for full NHML dump with all packet properties\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_NHML, ARG_IS_FUN),\n \tMP4BOX_ARG(\"webvtt-raw\", \"extract given track as raw media in WebVTT as metadata. Use `tkID:embedded` to include media data in the WebVTT file\", GF_ARG_STRING, 0, parse_track_dump, GF_EXPORT_WEBVTT_META, ARG_IS_FUN),\n \tMP4BOX_ARG(\"single\", \"extract given track to a new mp4 file\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_MP4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"six\", \"extract given track as raw media in **experimental** XML streaming instructions\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_SIX, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mux\", \"mux input to given destination\", GF_ARG_STRING, 0, &mux_name, 0, 0),\n \tMP4BOX_ARG(\"qcp\", \"same as [-raw]() but defaults to QCP file for EVRC/SMV\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_USE_QCP, ARG_IS_FUN),\n \tMP4BOX_ARG(\"saf\", \"remux file to SAF multiplex\", GF_ARG_BOOL, 0, &do_saf, 0, 0),\n \tMP4BOX_ARG(\"dvbhdemux\", \"demux DVB-H file into IP Datagrams sent on the network\", GF_ARG_BOOL, 0, &dvbhdemux, 0, 0),\n \tMP4BOX_ARG(\"raw-layer\", \"same as [-raw]() but skips SVC/MVC/LHVC extractors when extracting\", GF_ARG_INT, 0, parse_track_dump, GF_EXPORT_NATIVE | GF_EXPORT_SVC_LAYER, ARG_IS_FUN),\n \tMP4BOX_ARG(\"diod\", \"extract file IOD in raw format\", GF_ARG_BOOL, 0, &dump_iod, 0, 0),\n \tMP4BOX_ARG(\"mpd\", \"convert given HLS or smooth manifest (local or remote http) to MPD.  \\nWarning: This is not compatible with other DASH options and does not convert associated segments\", GF_ARG_STRING, 0, &do_mpd_conv, 0, 0),\n \t{0}\n};\n\nvoid PrintExtractUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Extracting Options\\n\"\n\t\"MP4Box can be used to extract media tracks from MP4 files. If you need to convert these tracks however, please check the [filters doc](Filters).\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_extr_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_extr_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_dump_args[] =\n{\n \tMP4BOX_ARG(\"std\", \"dump/write to stdout and assume stdout is opened in binary mode\", GF_ARG_BOOL, 0, &dump_std, 2, 0),\n \tMP4BOX_ARG(\"stdb\", \"dump/write to stdout and try to reopen stdout in binary mode\", GF_ARG_BOOL, 0, &dump_std, 1, 0),\n \tMP4BOX_ARG(\"tracks\", \"print the number of tracks on stdout\", GF_ARG_BOOL, 0, &get_nb_tracks, 0, 0),\n \tMP4BOX_ARG(\"info\", \"print movie info (no parameter) or track info with specified ID\", GF_ARG_STRING, 0, parse_file_info, 0, ARG_IS_FUN|ARG_EMPTY),\n \tMP4BOX_ARG(\"infon\", \"print track info for given track number, 1 being the first track in the file\", GF_ARG_STRING, 0, parse_file_info, 1, ARG_IS_FUN|ARG_EMPTY),\n \tMP4BOX_ARG_ALT(\"diso\", \"dmp4\", \"dump IsoMedia file boxes in XML output\", GF_ARG_BOOL, 0, &dump_isom, 1, 0),\n \tMP4BOX_ARG(\"dxml\", \"dump IsoMedia file boxes and known track samples in XML output\", GF_ARG_BOOL, 0, &dump_isom, 2, 0),\n \tMP4BOX_ARG(\"disox\", \"dump IsoMedia file boxes except sample tables in XML output\", GF_ARG_BOOL, 0, &dump_isom, 3, 0),\n \tMP4BOX_ARG(\"keep-ods\", \"do not translate ISOM ODs and ESDs tags (debug purpose only)\", GF_ARG_BOOL, 0, &no_odf_conf, 0, 0),\n \tMP4BOX_ARG(\"bt\", \"dump scene to BT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_BT, ARG_HAS_VALUE),\n \tMP4BOX_ARG(\"xmt\", \"dump scene to XMT format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_XMTA, 0),\n \tMP4BOX_ARG(\"wrl\", \"dump scene to VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_VRML, 0),\n \tMP4BOX_ARG(\"x3d\", \"dump scene to X3D XML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_XML, 0),\n \tMP4BOX_ARG(\"x3dv\", \"dump scene to X3D VRML format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_X3D_VRML, 0),\n \tMP4BOX_ARG(\"lsr\", \"dump scene to LASeR XML (XSR) format\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_LASER, 0),\n \tMP4BOX_ARG(\"svg\", \"dump scene to SVG\", GF_ARG_BOOL, 0, &dump_mode, GF_SM_DUMP_SVG, 0),\n \tMP4BOX_ARG(\"drtp\", \"dump rtp hint samples structure to XML output\", GF_ARG_BOOL, 0, &dump_rtp, 0, 0),\n \tMP4BOX_ARG(\"dts\", \"print sample timing, size and position in file to text output\", GF_ARG_BOOL, 0, parse_dump_ts, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dtsx\", \"same as [-dts]() but does not print offset\", GF_ARG_BOOL, 0, &dump_timestamps, 2, 0),\n \tMP4BOX_ARG(\"dtsc\", \"same as [-dts]() but analyses each sample for duplicated dts/cts (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 3, 0),\n \tMP4BOX_ARG(\"dtsxc\", \"same as [-dtsc]() but does not print offset (__slow !__)\", GF_ARG_BOOL, 0, &dump_timestamps, 4, 0),\n \tMP4BOX_ARG(\"dnal\", \"print NAL sample info of given track\", GF_ARG_INT, 0, parse_dnal, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnalc\", \"print NAL sample info of given track, adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnald\", \"print NAL sample info of given track without DTS and CTS info\", GF_ARG_INT, 0, parse_dnal, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dnalx\", \"print NAL sample info of given track without DTS and CTS info and adding CRC for each nal\", GF_ARG_INT, 0, parse_dnal, 2|1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"sdp\", \"dump SDP description of hinted file\", GF_ARG_BOOL, 0, &print_sdp, 0, 0),\n \tMP4BOX_ARG(\"dsap\", \"dump DASH SAP cues (see -cues) for a given track\", GF_ARG_INT, 0, parse_dsap, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsaps\", \"same as [-dsap]() but only print sample number\", GF_ARG_INT, 0, parse_dsap, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapc\", \"same as [-dsap]() but only print CTS\", GF_ARG_INT, 0, parse_dsap, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapd\", \"same as [-dsap]() but only print DTS\", GF_ARG_INT, 0, parse_dsap, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dsapp\", \"same as [-dsap]() but only print presentation time\", GF_ARG_INT, 4, parse_dsap, 4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"dcr\", \"dump ISMACryp samples structure to XML output\", GF_ARG_BOOL, 0, &dump_cr, 0, 0),\n \tMP4BOX_ARG(\"dump-cover\", \"extract cover art\", GF_ARG_BOOL, 0, &dump_cart, 0, 0),\n \tMP4BOX_ARG(\"dump-chap\", \"extract chapter file as TTXT format\", GF_ARG_BOOL, 0, &dump_chap, 1, 0),\n \tMP4BOX_ARG(\"dump-chap-ogg\", \"extract chapter file as OGG format\", GF_ARG_BOOL, 0, &dump_chap, 2, 0),\n \tMP4BOX_ARG(\"dump-chap-zoom\", \"extract chapter file as zoom format\", GF_ARG_BOOL, 0, &dump_chap, 3, 0),\n \tMP4BOX_ARG_S(\"dump-udta\", \"[tkID:]4cc\", \"extract user data for the given 4CC. If `tkID` is given, dumps from UDTA of the given track ID, otherwise moov is used\", 0, parse_dump_udta, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"mergevtt\", \"merge vtt cues while dumping\", GF_ARG_BOOL, 0, &merge_vtt_cues, 0, 0),\n \tMP4BOX_ARG(\"ttxt\", \"convert input subtitle to GPAC TTXT format if no parameter. Otherwise, dump given text track to GPAC TTXT format\", GF_ARG_INT, 0, parse_ttxt, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"srt\", \"convert input subtitle to SRT format if no parameter. Otherwise, dump given text track to SRT format\", GF_ARG_INT, 0, parse_ttxt, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"stat\", \"generate node/field statistics for scene\", GF_ARG_BOOL, 0, &stat_level, 1, 0),\n \tMP4BOX_ARG(\"stats\", \"generate node/field statistics per Access Unit\", GF_ARG_BOOL, 0, &stat_level, 2, 0),\n \tMP4BOX_ARG(\"statx\", \"generate node/field statistics for scene after each AU\", GF_ARG_BOOL, 0, &stat_level, 3, 0),\n \tMP4BOX_ARG(\"hash\", \"generate SHA-1 Hash of the input file\", GF_ARG_BOOL, 0, &do_hash, 0, 0),\n \tMP4BOX_ARG(\"comp\", \"replace with compressed version all top level box types given as parameter, formatted as `orig_4cc_1=comp_4cc_1[,orig_4cc_2=comp_4cc_2]`\", GF_ARG_STRING, 0, parse_comp_box, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"topcount\", \"print to stdout the number of top-level boxes matching box types given as parameter, formatted as `4cc_1,4cc_2N`\", GF_ARG_STRING, 0, parse_comp_box, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"topsize\", \"print to stdout the number of bytes of top-level boxes matching types given as parameter, formatted as `4cc_1,4cc_2N` or `all` for all boxes\", GF_ARG_STRING, 0, parse_comp_box, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"bin\", \"convert input XML file using NHML bitstream syntax to binary\", GF_ARG_BOOL, 0, &do_bin_xml, 0, 0),\n \tMP4BOX_ARG(\"mpd-rip\", \"fetch MPD and segment to disk\", GF_ARG_BOOL, 0, &do_mpd_rip, 0, 0),\n \tMP4BOX_ARG_S(\"udp-write\", \"IP[:port]\", \"write input name to UDP (default port 2345)\", GF_FS_ARG_HINT_EXPERT, &udp_dest, 0, 0),\n \tMP4BOX_ARG(\"raw-cat\", \"raw concatenation of given file with input file\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &raw_cat, 0, 0),\n \tMP4BOX_ARG(\"wget\", \"fetch resource from http(s) URL\", GF_ARG_STRING, GF_FS_ARG_HINT_EXPERT, &do_wget, 0, 0),\n \tMP4BOX_ARG(\"dm2ts\", \"dump timing of an input MPEG-2 TS stream sample timing\", GF_ARG_BOOL, 0, &dump_m2ts, 0, 0),\n \t{0}\n};\n\nvoid PrintDumpUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# File Dumping\\n\"\n\t\"  \\n\"\n\t\"MP4Box has many dump functionalities, from simple track listing to more complete reporting of special tracks.\\n\"\n\t\"  \\n\"\n\t\"Options:\\n\"\n\t);\n\twhile (m4b_dump_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_dump_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_meta_args[] =\n{\n \tMP4BOX_ARG_S(\"set-meta\", \"ABCD[:tk=tkID]\", \"set meta box type, with `ABCD` the four char meta type (NULL or 0 to remove meta)\\n\"\n\t\t\"- tk not set: use root (file) meta\\n\"\n\t\t\"- tkID == 0: use moov meta\\n\"\n\t\t\"- tkID != 0: use meta of given track\", 0, parse_meta_args, META_ACTION_SET_TYPE, ARG_IS_FUN),\n \tMP4BOX_ARG(\"add-item\", \"add resource to meta, with parameter syntax `file_path[:opt1:optN]`\\n\"\n\t\t\"- file_path `this` or `self`: item is the file itself\\n\"\n\t\t\"- tk=tkID: meta location (file, moov, track)\\n\"\n\t\t\"- name=str: item name\\n\"\n\t\t\"- type=itype: item 4cc type (not needed if mime is provided)\\n\"\n\t\t\"- mime=mtype: item mime type\\n\"\n\t\t\"- encoding=enctype: item content-encoding type\\n\"\n\t\t\"- id=ID: item ID\\n\"\n\t\t\"- ref=4cc,id: reference of type 4cc to an other item (can be set multiple times)\\n\"\n\t\t\"- group=id,type: indicate the id and type of an alternate group for this item\"\n\t\t, GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"add-image\", \"add the given file as HEIF image item, with parameter syntax `file_path[:opt1:optN]`. If `filepath` is omitted, source is the input MP4 file\\n\"\n\t\t\"- name, id, ref: see [-add-item]()\\n\"\n\t\t\"- primary: indicate that this item should be the primary item\\n\"\n\t\t\"- time=t[-e][/i]: use the next sync sample after time t (float, in sec, default 0). A negative time imports ALL intra frames as items\\n\"\n\t\t\" - If `e` is set (float, in sec), import all sync samples between `t` and `e`\\n\"\n\t\t\" - If `i` is set (float, in sec), sets time increment between samples to import\\n\"\n\t\t\"- split_tiles: for an HEVC tiled image, each tile is stored as a separate item\\n\"\n\t\t\"- image-size=wxh: force setting the image size and ignoring the bitstream info, used for grid images also\\n\"\n\t\t\"- rotation=a: set the rotation angle for this image to 90*a degrees anti-clockwise\\n\"\n\t\t\"- mirror-axis=axis: set the mirror axis: vertical, horizontal\\n\"\n\t\t\"- clap=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd: see track clap\\n\"\n\t\t\"- hidden: indicate that this image item should be hidden\\n\"\n\t\t\"- icc_path: path to icc data to add as color info\\n\"\n\t\t\"- alpha: indicate that the image is an alpha image (should use ref=auxl also)\\n\"\n\t\t\"- tk=tkID: indicate the track ID of the source sample. If 0, uses the first video track in the file\\n\"\n\t\t\"- samp=N: indicate the sample number of the source sample\\n\"\n\t\t\"- ref: do not copy the data but refer to the final sample location\\n\"\n\t\t\"- agrid[=AR]: creates an automatic grid from the image items present in the file, in their declaration order. The grid will **try to** have `AR` aspect ratio if specified (float), or the aspect ratio of the source otherwise. The grid will be the primary item and all other images will be hidden\\n\"\n\t\t\"- any other options will be passed as options to the media importer, see [-add]()\"\n\t\t, GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"add-image-grid\", \"create an image grid item, with parameter syntax `grid[:opt1:optN]`\\n\"\n\t\t\"- image-grid-size=rxc: set the number of rows and columns of the grid\\n\"\n\t    \"- any other options from [-add-image]() can be used\\n\", GF_ARG_STRING, 0, parse_meta_args, META_ACTION_ADD_IMAGE_GRID, ARG_IS_FUN),\n\tMP4BOX_ARG_S_ALT(\"rem-item\", \"rem-image\", \"item_ID[:tk=tkID]\", \"remove resource from meta\", 0, parse_meta_args, META_ACTION_REM_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"set-primary\", \"item_ID[:tk=tkID]\", \"set item as primary for meta\", 0, parse_meta_args, META_ACTION_SET_PRIMARY_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"set-xml\", \"xml_file_path[:tk=tkID][:binary]\", \"set meta XML data\", 0, parse_meta_args, META_ACTION_SET_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"rem-xml\", \"[tk=tkID]\", \"remove meta XML data\", 0, parse_meta_args, META_ACTION_REM_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"dump-xml\", \"file_path[:tk=tkID]\", \"dump meta XML to file\", 0, parse_meta_args, META_ACTION_DUMP_XML, ARG_IS_FUN),\n\tMP4BOX_ARG_S(\"dump-item\", \"item_ID[:tk=tkID][:path=fileName]\", \"dump item to file\", 0, parse_meta_args, META_ACTION_DUMP_ITEM, ARG_IS_FUN),\n\tMP4BOX_ARG(\"package\", \"package input XML file into an ISO container, all media referenced except hyperlinks are added to file\", GF_ARG_STRING, 0, &pack_file, 0, 0),\n\tMP4BOX_ARG(\"mgt\", \"package input XML file into an MPEG-U widget with ISO container, all files contained in the current folder are added to the widget package\", GF_ARG_STRING, 0, parse_mpegu, 0, ARG_IS_FUN),\n\t{0}\n};\n\nvoid PrintMetaUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Meta and HEIF Options\\n\"\n\t\"IsoMedia files can be used as generic meta-data containers, for examples storing XML information and sample images for a movie. The resulting file may not always contain a movie as is the case with some HEIF files or MPEG-21 files.\\n\"\n\t\"  \\n\"\n\t\"These information can be stored at the file root level, as is the case for HEIF/IFF and MPEG-21 file formats, or at the movie or track level for a regular movie.\"\n\t\"  \\n  \\n\");\n\twhile (m4b_meta_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_meta_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_swf_args[] =\n{\n \tMP4BOX_ARG(\"global\", \"all SWF defines are placed in first scene replace rather than when needed\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_STATIC_DICT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-ctrl\", \"use a single stream for movie control and dictionary (this will disable ActionScript)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SPLIT_TIMELINE, ARG_BIT_MASK_REM),\n \tMP4BOX_ARG(\"no-text\", \"remove all SWF text\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_TEXT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-font\", \"remove all embedded SWF Fonts (local playback host fonts used)\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_FONT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-line\", \"remove all lines from SWF shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_LINE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"no-grad\", \"remove all gradients from swf shapes\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_NO_GRADIENT, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"quad\", \"use quadratic bezier curves instead of cubic ones\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_QUAD_CURVE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"xlp\", \"support for lines transparency and scalability\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_SCALABLE_LINE, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"ic2d\", \"use indexed curve 2D hardcoded proto\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_USE_IC2D, ARG_BIT_MASK),\n\tMP4BOX_ARG(\"same-app\", \"appearance nodes are reused\", GF_ARG_BOOL, 0, &swf_flags, GF_SM_SWF_REUSE_APPEARANCE, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"flatten\", \"complementary angle below which 2 lines are merged, value `0` means no flattening\", GF_ARG_DOUBLE, 0, &swf_flatten_angle, 0, 0),\n\t{0}\n};\n\nvoid PrintSWFUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# SWF Importer Options\\n\"\n\t        \"\\n\"\n\t        \"MP4Box can import simple Macromedia Flash files (\\\".SWF\\\")\\n\"\n\t        \"You can specify a SWF input file with \\'-bt\\', \\'-xmt\\' and \\'-mp4\\' options\\n\"\n\t        \"  \\n\"\n\t        \"Options:\\n\"\n\t);\n\twhile (m4b_swf_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_swf_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n}\n\nMP4BoxArg m4b_liveenc_args[] =\n{\n \tMP4BOX_ARG(\"live\", \"enable live BIFS/LASeR encoder\", GF_ARG_BOOL, 0, &live_scene, 0, 0),\n \tGF_DEF_ARG(\"dst\", NULL, \"destination IP\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"port\", NULL, \"destination port\", \"7000\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"mtu\", NULL, \"path MTU for RTP packets\", \"1450\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"ifce\", NULL, \"IP address of the physical interface to use\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"ttl\", NULL, \"time to live for multicast packets\", \"1\", NULL, GF_ARG_INT, 0),\n \tGF_DEF_ARG(\"sdp\", NULL, \"output SDP file\", \"session.sdp\", NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"dims\", NULL, \"turn on DIMS mode for SVG input\", NULL, NULL, GF_ARG_BOOL, 0),\n \tGF_DEF_ARG(\"no-rap\", NULL, \"disable RAP sending and carousel generation\", NULL, NULL, GF_ARG_BOOL, 0),\n \tGF_DEF_ARG(\"src\", NULL, \"source of scene updates\", NULL, NULL, GF_ARG_STRING, 0),\n \tGF_DEF_ARG(\"rap\", NULL, \"duration in ms of base carousel; you can specify the RAP period of a single ESID (not in DIMS) using `ESID=X:time`\", NULL, NULL, GF_ARG_INT, 0),\n \t{0}\n};\n\nvoid PrintLiveUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"# Live Scene Encoder Options\\n\"\n\t        \"The options shall be specified as \u00f2pt_name=opt_val.\\n\"\n\t        \"Options:\\n\"\n\t        \"\\n\"\n\t);\n\twhile (m4b_liveenc_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_liveenc_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-extract\");\n\t}\n\n\tgf_sys_format_help(helpout, help_flags, \"  \\n\"\n\t\t\"Runtime options:\\n\"\n\t\t\"- q: quits\\n\"\n\t\t\"- u: inputs some commands to be sent\\n\"\n\t\t\"- U: same as u but signals the updates as critical\\n\"\n\t\t\"- e: inputs some commands to be sent without being aggregated\\n\"\n\t\t\"- E: same as e but signals the updates as critical\\n\"\n\t\t\"- f: forces RAP sending\\n\"\n\t\t\"- F: forces RAP regeneration and sending\\n\"\n\t\t\"- p: dumps current scene\\n\"\n\t);\n}\n\nvoid PrintCoreUsage()\n{\n\tgf_sys_format_help(helpout, help_flags, \"# libgpac core options\\n\");\n\tgf_sys_print_core_help(helpout, 0, GF_ARGMODE_ALL, 0);\n}\n\nvoid PrintTags()\n{\n\tu32 i = 0;\n\n\tgf_sys_format_help(helpout, help_flags, \"# Tagging support\\n\"\n\t\"Tags are specified as a colon-separated list `tag_name=tag_value[:tag2=val2]`\\n\"\n\t\"Setting a tag with no value or value `NULL` removes the tag.\\n\"\n\t\"Special tag value `clear` (or `reset`) removes all tags.\\n\"\n\t\"Unsupported tags can be added using their four character code as a tag name, and string value will be assumed.\\n\"\n\t\"If the tag name length is 3, the prefix 0xA9 is used to create the four character code.\\n\"\n\t\"  \\n\"\n\t\"Tags can also be loaded from a text file using `-itags filename`. The file must be in UTF8 with:\\n\"\n\t\"- lines starting with `tag_name=value` specify the start of a tag\\n\"\n\t\"- other lines specify the remainder of the last declared tag\\n\"\n\t\"  \\n\"\n\t\"If tag name starts with `WM/`, the tag is added to `Xtra` box (WMA tag, string only).\\n\"\n\t\"  \\n\"\n\t\"Supported tag names, values, types, aliases:\\n\"\n\t);\n\n\twhile (1) {\n\t\ts32 type = gf_itags_get_type(i);\n\t\tif (type<0) break;\n\t\tconst char *name = gf_itags_get_name(i);\n\t\tu32 itag = gf_itags_get_itag(i);\n\t\tgf_sys_format_help(helpout, help_flags | GF_PRINTARG_HIGHLIGHT_FIRST , \"%s\", name);\n\t\tgf_sys_format_help(helpout, help_flags, \" (%s) \", gf_4cc_to_str(itag) );\n\t\tswitch (type) {\n\t\tcase GF_ITAG_STR:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"string\"); break;\n\t\tcase GF_ITAG_INT8:\n\t\tcase GF_ITAG_INT16:\n\t\tcase GF_ITAG_INT32:\n\t\tcase GF_ITAG_INT64:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"integer\"); break;\n\t\tcase GF_ITAG_FRAC6:\n\t\tcase GF_ITAG_FRAC8:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"fraction (syntax: `A/B` or `A`, B will be 0)\"); break;\n\t\tcase GF_ITAG_BOOL:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"bool (`yes` or `no`)\"); break;\n\t\tcase GF_ITAG_ID3_GENRE:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"string (ID3 genre tag)\"); break;\n\t\tcase GF_ITAG_FILE:\n\t\t\tgf_sys_format_help(helpout, help_flags, \"file path\"); break;\n\t\t}\n\t\tname = gf_itags_get_alt_name(i);\n\t\tif (name) {\n\t\t\tgf_sys_format_help(helpout, help_flags, \" (`alias` %s)\", name);\n\t\t}\n\n\t\tgf_sys_format_help(helpout, help_flags, \"\\n\");\n\t\ti++;\n\t}\n}\n\nvoid PrintCICP()\n{\n\tu32 i;\n\tgf_sys_format_help(helpout, help_flags, \"# Video CICP (ISO/IEC 23091-2) Constants\\n\");\n\tgf_sys_format_help(helpout, help_flags, \"CICP Color Primaries:\\n\");\n\tfor (i=0; i<GF_CICP_PRIM_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_primaries_name(i);\n\t\tif (!name || !strcmp(name, \"unknwon\")) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n\tgf_sys_format_help(helpout, help_flags, \"  \\nCICP Color Transfer Characteristics:\\n\");\n\tfor (i=0; i<GF_CICP_TRANSFER_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_transfer_name(i);\n\t\tif (!name) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n\tgf_sys_format_help(helpout, help_flags, \"  \\nCICP Color Matrix Coefficients:\\n\");\n\tfor (i=0; i<GF_CICP_MX_LAST; i++) {\n\t\tconst char *name = gf_cicp_color_matrix_name(i);\n\t\tif (!name) continue;\n\t\tgf_sys_format_help(helpout, help_flags, \" - `%s` (value %d)\\n\", name, i);\n\t}\n}\n\nMP4BoxArg m4b_usage_args[] =\n{\n \tMP4BOX_ARG(\"h\", \"print help\\n\"\n \t\t\"- general: general options help\\n\"\n\t\t\"- hint: hinting options help\\n\"\n\t\t\"- dash: DASH segmenter help\\n\"\n\t\t\"- split: split options help\\n\"\n\t\t\"- import: import options help\\n\"\n\t\t\"- encode: scene descrription encoding options help\\n\"\n\t\t\"- meta: meta (HEIF, MPEG-21) handling options help\\n\"\n\t\t\"- extract: extraction options help\\n\"\n\t\t\"- dump: dump options help\\n\"\n\t\t\"- swf: Flash (SWF) options help\\n\"\n\t\t\"- crypt: ISMA E&A options help\\n\"\n\t\t\"- format: supported formats help\\n\"\n\t\t\"- live: BIFS streamer help\\n\"\n\t\t\"- core: libgpac core options\\n\"\n\t\t\"- all: print all the above help screens\\n\"\n\t\t\"- opts: print all options\\n\"\n\t\t\"- tags: print supported iTunes tags\\n\"\n\t\t\"- cicp: print various CICP code points\\n\"\n\t\t\"- VAL: search for option named `VAL` (without `-` or `--`) in MP4Box, libgpac core and all filters\\n\"\n\t\t, GF_ARG_STRING, 0, parse_help, 0, ARG_IS_FUN | ARG_EMPTY | ARG_PUSH_SYSARGS),\n \tMP4BOX_ARG(\"hx\", \"look for given string in all possible options\"\n\t\t, GF_ARG_STRING, 0, parse_help, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nodes\", \"list supported MPEG4 nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"nodex\", \"list supported MPEG4 nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"node\", \"get given MPEG4 node syntax and QP infolist\", GF_ARG_STRING, 0, PrintNode, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnodes\", \"list supported X3D nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 2, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnodex\", \"list supported X3D nodes and print nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 3, ARG_IS_FUN),\n \tMP4BOX_ARG(\"xnode\", \"get given X3D node syntax\", GF_ARG_STRING, 0, PrintNode, 1, ARG_IS_FUN),\n \tMP4BOX_ARG(\"snodes\", \"list supported SVG nodes\", GF_ARG_BOOL, 0, PrintBuiltInNodes, 4, ARG_IS_FUN),\n \tMP4BOX_ARG(\"languages\", \"list supported ISO 639 languages\", GF_ARG_BOOL, 0, PrintLanguages, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"boxes\", \"list all supported ISOBMF boxes and their syntax\", GF_ARG_BOOL, 0, PrintBuiltInBoxes, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"boxcov\", \"perform coverage of box IO coode\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, PrintBuiltInBoxes, 1, ARG_IS_FUN|ARG_PUSH_SYSARGS),\n \tMP4BOX_ARG(\"fstat\", \"print filter session statistics (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 1, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"fgraph\", \"print filter session graph (import/export/encrypt/decrypt/dashing)\", GF_ARG_BOOL, 0, &fs_dump_flags, 2, ARG_BIT_MASK),\n \tMP4BOX_ARG(\"v\", \"verbose mode\", GF_ARG_BOOL, 0, &verbose, 0, ARG_INT_INC),\n \tMP4BOX_ARG(\"version\", \"get build version\", GF_ARG_BOOL, 0, print_version, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"genmd\", \"generate MD doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 0, ARG_IS_FUN),\n \tMP4BOX_ARG(\"genman\", \"generate man doc\", GF_ARG_BOOL, GF_ARG_HINT_HIDE, parse_gendoc, 1, ARG_IS_FUN),\n \tMP4BOX_ARG_S(\"--\", \"INPUT\", \"escape option if INPUT starts with `-` character\", 0, NULL, 0, 0),\n \t{0}\n};\n\nvoid PrintUsage()\n{\n\tu32 i=0;\n\tgf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option]\\n\"\n\t\t\"  \\n\"\n\t\t\"# General Options:\\n\"\n\t);\n\twhile (m4b_usage_args[i].name) {\n\t\tGF_GPACArg *arg = (GF_GPACArg *) &m4b_usage_args[i];\n\t\ti++;\n\t\tgf_sys_print_arg(helpout, help_flags, arg, \"mp4box-general\");\n\t}\n}\n\n/*\n * \t\tEND OF ARGS PARSING AND HELP\n */\n\n\nenum\n{\n\tSEARCH_ARG_EXACT,\n\tSEARCH_ARG_CLOSE,\n\tSEARCH_DESC,\n};\n\nstatic Bool strstr_nocase(const char *text, const char *subtext, u32 subtext_len)\n{\n\tif (!*text || !subtext || !subtext_len)\n\t\treturn GF_FALSE;\n\n\twhile (*text) {\n\t\tif (tolower(*text) == *subtext) {\n\t\t\tif (!strnicmp(text, subtext, subtext_len))\n\t\t\t\treturn GF_TRUE;\n\n\t\t}\n\t\ttext++;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic u32 PrintHelpForArgs(char *arg_name, MP4BoxArg *args, GF_GPACArg *_args, u32 search_type)\n{\n\tu32 res=0;\n\tu32 i=0;\n\tu32 alen = (u32) strlen(arg_name);\n\n\twhile (1) {\n\t\tu32 flags=0;\n\t\tGF_GPACArg *arg;\n\t\tGF_GPACArg an_arg;\n\t\tBool do_match = GF_FALSE;\n\t\tif (args) {\n\t\t\tif (!args[i].name)\n\t\t\t\tbreak;\n\t\t\targ = (GF_GPACArg *) &args[i];\n\t\t} else {\n\t\t\tif (!_args[i].name)\n\t\t\t\tbreak;\n\t\t\targ = &_args[i];\n\t\t}\n\n\t\tif (args == m4b_imp_fileopt_args) {\n\t\t\tflags = GF_PRINTARG_COLON;\n\t\t\tif (!strncmp(arg_name, arg->name, alen) && ((arg->name[alen]==0) || (arg->name[alen]=='=')))\n\t\t\t\tdo_match = GF_TRUE;\n\t\t}\n\t\telse if (!strcmp(arg_name, arg->name))\n\t\t\tdo_match = GF_TRUE;\n\t\telse if ((alen < (u32) strlen(arg->name)) && (arg->name[alen]==' ') && !strncmp(arg_name, arg->name, alen))\n\t\t\tdo_match = GF_TRUE;\n\n\t\tif (arg_name[0] == '@')\n\t\t\tdo_match = GF_TRUE;\n\n\t\tif ((search_type==SEARCH_ARG_EXACT) && !do_match) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((search_type==SEARCH_ARG_CLOSE) && !gf_sys_word_match(arg_name, arg->name)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((search_type==SEARCH_DESC) && !strstr_nocase(arg->description, arg_name, alen)) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tan_arg = *arg;\n\t\tif (search_type!=SEARCH_ARG_EXACT) {\n\t\t\tan_arg.description = NULL;\n\t\t\tan_arg.type = GF_ARG_BOOL;\n\t\t}\n\t\tgf_sys_print_arg(helpout, flags, (GF_GPACArg *) &an_arg, \"\");\n\t\tres++;\n\t\ti++;\n\t}\n\treturn res;\n}\nstatic Bool PrintHelpArg(char *arg_name, u32 search_type, GF_FilterSession *fs)\n{\n\tBool first=GF_TRUE;\n\tGF_GPACArg an_arg;\n\tu32 i, count;\n\tu32 res = 0;\n\tu32 alen = (u32) strlen(arg_name);\n\tres += PrintHelpForArgs(arg_name, m4b_gen_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_split_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_dash_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_imp_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_imp_fileopt_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_senc_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_crypt_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_hint_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_extr_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_dump_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_meta_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_swf_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_liveenc_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, m4b_usage_args, NULL, search_type);\n\tres += PrintHelpForArgs(arg_name, NULL, (GF_GPACArg *) gf_sys_get_options(), search_type);\n\n\tif (!fs) return res;\n\n\tmemset(&an_arg, 0, sizeof(GF_GPACArg));\n\tcount = gf_fs_filters_registers_count(fs);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j=0;\n\t\tconst GF_FilterRegister *reg = gf_fs_get_filter_register(fs, i);\n\n\t\twhile (reg->args) {\n\t\t\tu32 len;\n\t\t\tconst GF_FilterArgs *arg = &reg->args[j];\n\t\t\tif (!arg || !arg->arg_name) break;\n\t\t\tj++;\n\t\t\tif ((search_type==SEARCH_ARG_EXACT) && strcmp(arg->arg_name, arg_name)) continue;\n\n\t\t\tif ((search_type==SEARCH_ARG_CLOSE) && !gf_sys_word_match(arg->arg_name, arg_name)) continue;\n\n\t\t\tif (search_type==SEARCH_DESC) {\n\t\t\t\tif (!strstr_nocase(arg->arg_desc, arg_name, alen)) continue;\n\t\t\t}\n\n\t\t\tan_arg.name = arg->arg_name;\n\t\t\tif (search_type==SEARCH_ARG_EXACT) {\n\t\t\t\tan_arg.description = arg->arg_desc;\n\t\t\t\tswitch (arg->arg_type) {\n\t\t\t\tcase GF_PROP_BOOL:\n\t\t\t\t\tan_arg.type = GF_ARG_BOOL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_UINT:\n\t\t\t\tcase GF_PROP_SINT:\n\t\t\t\t\tan_arg.type = GF_ARG_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_DOUBLE:\n\t\t\t\t\tan_arg.type = GF_ARG_DOUBLE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\tcase GF_PROP_UINT_LIST:\n\t\t\t\tcase GF_PROP_SINT_LIST:\n\t\t\t\tcase GF_PROP_VEC2I_LIST:\n\t\t\t\t\tan_arg.type = GF_ARG_STRINGS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_4CC:\n\t\t\t\t\tan_arg.type = GF_ARG_4CC;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_4CC_LIST:\n\t\t\t\t\tan_arg.type = GF_ARG_4CCS;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tan_arg.type = GF_ARG_STRING;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t\tgf_sys_format_help(helpout, 0, \"\\nGlobal filter session arguments. Syntax is `--arg` or `--arg=VAL`. `[F]` indicates filter name. See `gpac -h` and `gpac -h F` for more info.\\n\");\n\t\t\t\t}\n\t\t\t\tfprintf(helpout, \"[%s]\", reg->name);\n\t\t\t\tlen = (u32)strlen(reg->name);\n\t\t\t\twhile (len<10) {\n\t\t\t\t\tlen++;\n\t\t\t\t\tfprintf(helpout, \" \");\n\t\t\t\t}\n\t\t\t\tfprintf(helpout, \" \");\n\t\t\t}\n\n\t\t\tgf_sys_print_arg(helpout, GF_PRINTARG_ADD_DASH, &an_arg, \"TEST\");\n\t\t\tres++;\n\t\t}\n\t}\n\tif (res) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic void PrintHelp(char *arg_name, Bool search_desc, Bool no_match)\n{\n\tGF_FilterSession *fs;\n\tBool res;\n\n\tfs = gf_fs_new_defaults(0);\n\n\tif (arg_name[0]=='-')\n\t\targ_name++;\n\n\tif (search_desc) {\n\t\tchar *_arg_name = gf_strdup(arg_name);\n\t\tstrlwr(_arg_name);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Possible options mentionning `%s`:\\n\", arg_name));\n\t\tPrintHelpArg(_arg_name, SEARCH_DESC, fs);\n\t\tgf_free(_arg_name);\n\t} else {\n\t\tres = no_match ? GF_FALSE : PrintHelpArg(arg_name, SEARCH_ARG_EXACT, fs);\n\t\tif (!res) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_APP, (\"Option -%s unknown, please check usage.\\n\", arg_name));\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_APP, (\"Possible options are:\\n\"));\n\n\t\t\tPrintHelpArg(arg_name, SEARCH_ARG_CLOSE, fs);\n\t\t}\n\t}\n\tif (fs)\n\t\tgf_fs_del(fs);\n}\n\n\nu32 parse_sdp_ext(char *arg_val, u32 param)\n{\n\tchar *id;\n\tsdp_lines = gf_realloc(sdp_lines, sizeof(SDPLine) * (nb_sdp_ex + 1));\n\tif (!sdp_lines) return 2;\n\tid = strchr(arg_val, ':');\n\tif (id) {\n\t\tid[0] = 0;\n\t\tif (sscanf(arg_val, \"%u\", &sdp_lines[0].trackID) == 1) {\n\t\t\tid[0] = ':';\n\t\t\tsdp_lines[nb_sdp_ex].line = id + 1;\n\t\t}\n\t\telse {\n\t\t\tid[0] = ':';\n\t\t\tsdp_lines[nb_sdp_ex].line = arg_val;\n\t\t\tsdp_lines[nb_sdp_ex].trackID = 0;\n\t\t}\n\t}\n\telse {\n\t\tsdp_lines[nb_sdp_ex].line = arg_val;\n\t\tsdp_lines[nb_sdp_ex].trackID = 0;\n\t}\n\topen_edit = GF_TRUE;\n\tnb_sdp_ex++;\n\treturn GF_FALSE;\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic u32 parse_meta_args(char *opts, MetaActionType act_type)\n{\n\tMetaAction *meta;\n\n\tmetas = gf_realloc(metas, sizeof(MetaAction) * (nb_meta_act + 1));\n\tif (!metas) return 2;\n\tmeta = &metas[nb_meta_act];\n\tnb_meta_act ++;\n\n\tmemset(meta, 0, sizeof(MetaAction));\n\tmeta->act_type = act_type;\n\tmeta->trackID = 0;\n\tmeta->root_meta = 1;\n\topen_edit = GF_TRUE;\n\n\tif (!opts) return 2;\n\n\tif (act_type == META_ACTION_ADD_IMAGE_ITEM)\n\t\thas_add_image = GF_TRUE;\n\n\twhile (1) {\n\t\tchar *next;\n\t\tchar *szSlot;\n\t\tif (!opts || !opts[0]) return 0;\n\t\tif (opts[0]==':') opts += 1;\n\n\t\tszSlot = opts;\n\t\tnext = gf_url_colon_suffix(opts);\n\t\tif (next) next[0] = 0;\n\n\t\tif (!strnicmp(szSlot, \"tk=\", 3)) {\n\t\t\tsscanf(szSlot, \"tk=%u\", &meta->trackID);\n\t\t\tmeta->root_meta = 0;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"id=\", 3)) {\n\t\t\tmeta->item_id = atoi(szSlot+3);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"type=\", 5)) {\n\t\t\tmeta->item_type = GF_4CC(szSlot[5], szSlot[6], szSlot[7], szSlot[8]);\n\t\t}\n\t\t//\"ref\" (without '=') is for data reference, \"ref=\" is for item references\n\t\telse if (!strnicmp(szSlot, \"ref=\", 4)) {\n\t\t\tchar type[5];\n\t\t\tMetaRef\t*ref;\n\t\t\tif (!meta->item_refs) {\n\t\t\t\tmeta->item_refs = gf_list_new();\n\t\t\t\tif (!meta->item_refs) return 2;\n\t\t\t}\n\t\t\tGF_SAFEALLOC(ref, MetaRef);\n\t\t\tif (!ref) return 2;\n\t\t\tsscanf(szSlot, \"ref=%4s,%u\", type, &(ref->ref_item_id));\n\t\t\tref->ref_type = GF_4CC(type[0], type[1], type[2], type[3]);\n\t\t\tgf_list_add(meta->item_refs, ref);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"name=\", 5)) {\n\t\t\tmeta->szName = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"path=\", 5)) {\n\t\t\tmeta->szPath = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"mime=\", 5)) {\n\t\t\tmeta->item_type = GF_META_ITEM_TYPE_MIME;\n\t\t\tmeta->mime_type = gf_strdup(szSlot+5);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"encoding=\", 9)) {\n\t\t\tmeta->enc_type = gf_strdup(szSlot+9);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-size=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->width, &meta->image_props->height);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-grid-size=\", 16)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t}\n\t\t\tsscanf(szSlot+16, \"%dx%d\", &meta->image_props->num_grid_rows, &meta->image_props->num_grid_columns);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-pasp=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->hSpacing, &meta->image_props->vSpacing);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"image-rloc=\", 11)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot+11, \"%dx%d\", &meta->image_props->hOffset, &meta->image_props->vOffset);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"rotation=\", 9)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->angle = atoi(szSlot+9);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"mirror-axis=\", 12)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->mirror = (!strnicmp(szSlot+12, \"vertical\", 8) ? 1 : 2);\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"clap=\", 5)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tsscanf(szSlot + 5, \"%d,%d,%d,%d,%d,%d,%d,%d\", &meta->image_props->clap_wnum, &meta->image_props->clap_wden,\n\t\t\t\t\t   &meta->image_props->clap_hnum, &meta->image_props->clap_hden,\n\t\t\t\t\t   &meta->image_props->clap_honum, &meta->image_props->clap_hoden,\n\t\t\t\t\t   &meta->image_props->clap_vonum, &meta->image_props->clap_voden);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"hidden\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->hidden = GF_TRUE;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"alpha\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->alpha = GF_TRUE;\n\t\t}\n\t\t//\"ref\" (without '=') is for data reference, \"ref=\" is for item references\n\t\telse if (!stricmp(szSlot, \"ref\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->use_reference = GF_TRUE;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"time=\", 5)) {\n\t\t\tFloat s=0, e=0, step=0;\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tif (sscanf(szSlot+5, \"%f-%f/%f\", &s, &e, &step)==3) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->end_time = e;\n\t\t\t\tmeta->image_props->step_time = step;\n\t\t\t} else if (sscanf(szSlot+5, \"%f-%f\", &s, &e)==2) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->end_time = e;\n\t\t\t} else if (sscanf(szSlot+5, \"%f/%f\", &s, &step)==2) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t\tmeta->image_props->step_time = step;\n\t\t\t} else if (sscanf(szSlot+5, \"%f\", &s)==1) {\n\t\t\t\tmeta->image_props->time = s;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"samp=\", 5)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->sample_num = atoi(szSlot+5);\n\t\t\tmeta->root_meta = 1;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"group=\", 6)) {\n\t\t\tchar type[5];\n\t\t\tsscanf(szSlot, \"group=%4s,%u\", type, &meta->group_id);\n\t\t\tmeta->group_type = GF_4CC(type[0], type[1], type[2], type[3]);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"split_tiles\")) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->tile_mode = TILE_ITEM_ALL_BASE;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"dref\")) {\n\t\t\tmeta->use_dref = 1;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"primary\")) {\n\t\t\tmeta->primary = 1;\n\t\t}\n\t\telse if (!stricmp(szSlot, \"binary\")) {\n\t\t\tif (meta->act_type==META_ACTION_SET_XML) meta->act_type=META_ACTION_SET_BINARY_XML;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"icc_path=\", 9)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tstrcpy(meta->image_props->iccPath, szSlot+9);\n\t\t}\n\t\telse if (!stricmp(szSlot, \"agrid\") || !strnicmp(szSlot, \"agrid=\", 6)) {\n\t\t\tif (!meta->image_props) {\n\t\t\t\tGF_SAFEALLOC(meta->image_props, GF_ImageItemProperties);\n\t\t\t\tif (!meta->image_props) return 2;\n\t\t\t}\n\t\t\tmeta->image_props->auto_grid = GF_TRUE;\n\t\t\tif (!strnicmp(szSlot, \"agrid=\", 6))\n\t\t\t\tmeta->image_props->auto_grid_ratio = atof(szSlot+6);\n\t\t}\n\t\telse if (!strchr(szSlot, '=')) {\n\t\t\tswitch (meta->act_type) {\n\t\t\tcase META_ACTION_SET_TYPE:\n\t\t\t\tif (!stricmp(szSlot, \"null\") || !stricmp(szSlot, \"0\")) meta->meta_4cc = 0;\n\t\t\t\telse meta->meta_4cc = GF_4CC(szSlot[0], szSlot[1], szSlot[2], szSlot[3]);\n\t\t\t\tbreak;\n\t\t\tcase META_ACTION_ADD_ITEM:\n\t\t\tcase META_ACTION_ADD_IMAGE_ITEM:\n\t\t\tcase META_ACTION_SET_XML:\n\t\t\tcase META_ACTION_DUMP_XML:\n\t\t\t\tif (!strncmp(szSlot, \"dopt\", 4) || !strncmp(szSlot, \"sopt\", 4) || !strncmp(szSlot, \"@\", 1)) {\n\t\t\t\t\tif (next) next[0]=':';\n\t\t\t\t\tnext=NULL;\n\t\t\t\t}\n\t\t\t\t//cat as -add arg\n\t\t\t\tgf_dynstrcat(&meta->szPath, szSlot, \":\");\n\t\t\t\tif (!meta->szPath) return 2;\n\t\t\t\tbreak;\n\t\t\tcase META_ACTION_REM_ITEM:\n\t\t\tcase META_ACTION_SET_PRIMARY_ITEM:\n\t\t\tcase META_ACTION_DUMP_ITEM:\n\t\t\t\tmeta->item_id = atoi(szSlot);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!next) break;\n\t\topts += strlen(szSlot);\n\t\tnext[0] = ':';\n\t}\n\treturn 0;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nstatic Bool parse_tsel_args(char *opts, TSELActionType act)\n{\n\tGF_ISOTrackID refTrackID = 0;\n\tBool has_switch_id;\n\tu32 switch_id = 0;\n\tu32 criteria[30];\n\tu32 nb_criteria = 0;\n\tTSELAction *tsel_act;\n\tchar szSlot[1024];\n\n\thas_switch_id = 0;\n\n\tif (!opts) return 0;\n\twhile (1) {\n\t\tchar *next;\n\t\tif (!opts || !opts[0]) return 0;\n\t\tif (opts[0]==':') opts += 1;\n\t\tstrcpy(szSlot, opts);\n\t\tnext = gf_url_colon_suffix(szSlot);\n\t\tif (next) next[0] = 0;\n\n\n\t\tif (!strnicmp(szSlot, \"refTrack=\", 9)) refTrackID = atoi(szSlot+9);\n\t\telse if (!strnicmp(szSlot, \"switchID=\", 9)) {\n\t\t\tif (atoi(szSlot+9)<0) {\n\t\t\t\tswitch_id = 0;\n\t\t\t\thas_switch_id = 0;\n\t\t\t} else {\n\t\t\t\tswitch_id = atoi(szSlot+9);\n\t\t\t\thas_switch_id = 1;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"switchID\", 8)) {\n\t\t\tswitch_id = 0;\n\t\t\thas_switch_id = 1;\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"criteria=\", 9)) {\n\t\t\tu32 j=9;\n\t\t\tnb_criteria = 0;\n\t\t\twhile (j+3<strlen(szSlot)) {\n\t\t\t\tcriteria[nb_criteria] = GF_4CC(szSlot[j], szSlot[j+1], szSlot[j+2], szSlot[j+3]);\n\t\t\t\tj+=5;\n\t\t\t\tnb_criteria++;\n\t\t\t}\n\t\t}\n\t\telse if (!strnicmp(szSlot, \"trackID=\", 8) || !strchr(szSlot, '=') ) {\n\t\t\ttsel_acts = gf_realloc(tsel_acts, sizeof(TSELAction) * (nb_tsel_acts + 1));\n\t\t\tif (!tsel_acts) return 2;\n\n\t\t\ttsel_act = &tsel_acts[nb_tsel_acts];\n\t\t\tnb_tsel_acts++;\n\n\t\t\tmemset(tsel_act, 0, sizeof(TSELAction));\n\t\t\ttsel_act->act_type = act;\n\t\t\ttsel_act->trackID = strchr(szSlot, '=') ? atoi(szSlot+8) : atoi(szSlot);\n\t\t\ttsel_act->refTrackID = refTrackID;\n\t\t\ttsel_act->switchGroupID = switch_id;\n\t\t\ttsel_act->is_switchGroup = has_switch_id;\n\t\t\ttsel_act->nb_criteria = nb_criteria;\n\t\t\tmemcpy(tsel_act->criteria, criteria, sizeof(u32)*nb_criteria);\n\n\t\t\tif (!refTrackID)\n\t\t\t\trefTrackID = tsel_act->trackID;\n\n\t\t\topen_edit = GF_TRUE;\n\t\t}\n\t\topts += strlen(szSlot);\n\t}\n\treturn 0;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\nGF_DashSegmenterInput *set_dash_input(GF_DashSegmenterInput *dash_inputs, char *name, u32 *nb_dash_inputs)\n{\n\tGF_DashSegmenterInput *di;\n\tBool skip_rep_id = GF_FALSE;\n\tchar *other_opts = NULL;\n\tchar *sep = gf_url_colon_suffix(name);\n\n\tdash_inputs = gf_realloc(dash_inputs, sizeof(GF_DashSegmenterInput) * (*nb_dash_inputs + 1) );\n\tmemset(&dash_inputs[*nb_dash_inputs], 0, sizeof(GF_DashSegmenterInput) );\n\tdi = &dash_inputs[*nb_dash_inputs];\n\t(*nb_dash_inputs)++;\n\n\tif (sep) {\n\t\tchar *opts, *first_opt;\n\t\tfirst_opt = sep;\n\t\topts = sep+1;\n\t\twhile (opts) {\n\t\t\tsep = gf_url_colon_suffix(opts);\n\t\t\tif (sep && !strncmp(sep, \"://\", 3) && strncmp(sep, \":@\", 2)) sep = gf_url_colon_suffix(sep+3);\n\t\t\tif (sep) sep[0] = 0;\n\n\t\t\tif (!strnicmp(opts, \"id=\", 3)) {\n\t\t\t\tif (!stricmp(opts+3, \"NULL\"))\n\t\t\t\t\tskip_rep_id = GF_TRUE;\n\t\t\t\telse\n\t\t\t\t\tdi->representationID = gf_strdup(opts+3);\n\t\t\t\t/*we allow the same repID to be set to force muxed representations*/\n\t\t\t}\n\t\t\telse if (!strnicmp(opts, \"dur=\", 4)) di->media_duration = (Double)atof(opts+4);\n\t\t\telse if (!strnicmp(opts, \"period=\", 7)) di->periodID = gf_strdup(opts+7);\n\t\t\telse if (!strnicmp(opts, \"BaseURL=\", 8)) {\n\t\t\t\tdi->baseURL = (char **)gf_realloc(di->baseURL, (di->nb_baseURL+1)*sizeof(char *));\n\t\t\t\tdi->baseURL[di->nb_baseURL] = gf_strdup(opts+8);\n\t\t\t\tdi->nb_baseURL++;\n\t\t\t} else if (!strnicmp(opts, \"bandwidth=\", 10)) di->bandwidth = atoi(opts+10);\n\t\t\telse if (!strnicmp(opts, \"role=\", 5)) {\n\t\t\t\tdi->roles = gf_realloc(di->roles, sizeof (char *) * (di->nb_roles+1));\n\t\t\t\tdi->roles[di->nb_roles] = gf_strdup(opts+5);\n\t\t\t\tdi->nb_roles++;\n\t\t\t} else if (!strnicmp(opts, \"desc\", 4)) {\n\t\t\t\tu32 *nb_descs=NULL;\n\t\t\t\tchar ***descs=NULL;\n\t\t\t\tu32 opt_offset=0;\n\t\t\t\tu32 len;\n\t\t\t\tif (!strnicmp(opts, \"desc_p=\", 7)) {\n\t\t\t\t\tnb_descs = &di->nb_p_descs;\n\t\t\t\t\tdescs = &di->p_descs;\n\t\t\t\t\topt_offset = 7;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_as=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_as_descs;\n\t\t\t\t\tdescs = &di->as_descs;\n\t\t\t\t\topt_offset = 8;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_as_c=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_as_c_descs;\n\t\t\t\t\tdescs = &di->as_c_descs;\n\t\t\t\t\topt_offset = 10;\n\t\t\t\t} else if (!strnicmp(opts, \"desc_rep=\", 8)) {\n\t\t\t\t\tnb_descs = &di->nb_rep_descs;\n\t\t\t\t\tdescs = &di->rep_descs;\n\t\t\t\t\topt_offset = 9;\n\t\t\t\t}\n\t\t\t\tif (opt_offset) {\n\t\t\t\t\t(*nb_descs)++;\n\t\t\t\t\topts += opt_offset;\n\t\t\t\t\tlen = (u32) strlen(opts);\n\t\t\t\t\t(*descs) = (char **)gf_realloc((*descs), (*nb_descs)*sizeof(char *));\n\t\t\t\t\t(*descs)[(*nb_descs)-1] = (char *)gf_malloc((len+1)*sizeof(char));\n\t\t\t\t\tmemcpy((*descs)[(*nb_descs)-1], opts, len);\n\t\t\t\t\t(*descs)[(*nb_descs)-1][len] = 0;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (!strnicmp(opts, \"xlink=\", 6)) di->xlink = gf_strdup(opts+6);\n\t\t\telse if (!strnicmp(opts, \"sscale\", 6)) di->sscale = GF_TRUE;\n\t\t\telse if (!strnicmp(opts, \"pdur=\", 5)) di->period_duration = (Double) atof(opts+5);\n\t\t\telse if (!strnicmp(opts, \"period_duration=\", 16)) di->period_duration = (Double) atof(opts+16);\n\t\t\telse if (!strnicmp(opts, \"duration=\", 9)) di->dash_duration = (Double) atof(opts+9);\n\t\t\telse if (!strnicmp(opts, \"asID=\", 5)) di->asID = atoi(opts+5);\n\t\t\telse if (!strnicmp(opts, \"sn=\", 3)) di->startNumber = atoi(opts+3);\n\t\t\telse if (!strnicmp(opts, \"tpl=\", 4)) di->seg_template = gf_strdup(opts+4);\n\t\t\telse if (!strnicmp(opts, \"hls=\", 4)) di->hls_pl = gf_strdup(opts+4);\n\t\t\telse if (!strnicmp(opts, \"trackID=\", 8)) di->track_id = atoi(opts+8);\n\t\t\telse if (!strnicmp(opts, \"@\", 1)) {\n\t\t\t\tBool old_syntax = (opts[1]=='@') ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (sep) sep[0] = ':';\n\t\t\t\tdi->filter_chain = gf_strdup(opts + (old_syntax ? 2 : 1) );\n\t\t\t\tsep = NULL;\n\t\t\t\tif (!old_syntax && (strstr(di->filter_chain, \"@@\")!=NULL)) {\n\t\t\t\t\tskip_rep_id = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_dynstrcat(&other_opts, opts, \":\");\n\t\t\t}\n\n\t\t\tif (!sep) break;\n\t\t\tsep[0] = ':';\n\t\t\topts = sep+1;\n\t\t}\n\t\tfirst_opt[0] = '\\0';\n\t}\n\tdi->file_name = name;\n\tdi->source_opts = other_opts;\n\n\tif (!skip_rep_id && !di->representationID) {\n\t\tchar szRep[100];\n\t\tsprintf(szRep, \"%d\", *nb_dash_inputs);\n\t\tdi->representationID = gf_strdup(szRep);\n\t}\n\n\treturn dash_inputs;\n}\n\nstatic Bool create_new_track_action(char *arg_val, u32 act_type, u32 dump_type)\n{\n\tTrackAction *tka;\n\tchar *param = arg_val;\n\ttracks = (TrackAction *)gf_realloc(tracks, sizeof(TrackAction) * (nb_track_act+1));\n\tif (!tracks) return GF_FALSE;\n\n\ttka = & tracks[nb_track_act];\n\tnb_track_act++;\n\n\tmemset(tka, 0, sizeof(TrackAction) );\n\ttka->act_type = act_type;\n\ttka->dump_type = dump_type;\n\tif (act_type != TRAC_ACTION_RAW_EXTRACT) {\n\t\topen_edit = GF_TRUE;\n\t\tdo_save = GF_TRUE;\n\t}\n\n\tif ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) {\n\t\tif (sscanf(param, \"%d:%u\", &tka->trackID, &tka->newTrackID) != 2) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_PAR) {\n\t\tchar *ext;\n\t\text = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\n\t\tif (!stricmp(ext+1, \"none\"))\n\t\t\ttka->par_num = tka->par_den = 0;\n\t\telse if (!stricmp(ext+1, \"auto\")) {\n\t\t\ttka->par_num = tka->par_den = -1;\n\t\t\ttka->force_par = 1;\n\t\t}\n\t\telse if (!stricmp(ext+1, \"force\")) {\n\t\t\ttka->par_num = tka->par_den = 1;\n\t\t\ttka->force_par = 1;\n\t\t}\n\t\telse {\n\t\t\tif (ext[1]=='w') {\n\t\t\t\ttka->rewrite_bs = 1;\n\t\t\t\text++;\n\t\t\t}\n\t\t\tif (sscanf(ext+1, \"%d:%d\", &tka->par_num, &tka->par_den) != 2) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_CLAP) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (stricmp(ext + 1, \"none\")) {\n\t\t\tif (sscanf(ext + 1, \"%d,%d,%d,%d,%d,%d,%d,%d\", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {\n\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (act_type==TRAC_ACTION_SET_MX) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (!stricmp(ext + 1, \"none\")) {\n\t\t\tmemset(tka->mx, 0, sizeof(s32)*9);\n\t\t\ttka->mx[0] = tka->mx[4] = tka->mx[8] = 1;\n\t\t} else {\n\t\t\ts32 res;\n\t\t\tif (strstr(ext+1, \"0x\")) {\n\t\t\t\tres = sscanf(ext + 1, \"0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d:0x%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);\n\t\t\t} else {\n\t\t\t\tres = sscanf(ext + 1, \"%d:%d:%d:%d:%d:%d:%d:%d:%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);\n\t\t\t}\n\t\t\tif (res != 9) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_EDITS) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track edits - expecting ID=EDITS got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\ttka->string = gf_strdup(ext+1);\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_LANGUAGE) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\tstrncpy(tka->lang, param + 4, 10-1);\n\t\t}\n\t\telse if (!ext) {\n\t\t\tstrncpy(tka->lang, param, 10-1);\n\t\t} else {\n\t\t\tstrncpy(tka->lang, ext + 1, 10-1);\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(param);\n\t\t\text[0] = '=';\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif ((act_type==TRAC_ACTION_SET_KIND) || (act_type==TRAC_ACTION_REM_KIND)) {\n\t\tchar *ext;\n\t\tchar *scheme_start = NULL;\n\n\t\t//extract trackID\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\tscheme_start = param + 4;\n\t\t} else {\n\t\t\text = strchr(param, '=');\n\t\t\tif (ext) {\n\t\t\t\text[0] = 0;\n\t\t\t\tif (sscanf(param, \"%d\", &tka->trackID) == 1) {\n\t\t\t\t\tscheme_start = ext + 1;\n\t\t\t\t} else {\n\t\t\t\t\tscheme_start = param;\n\t\t\t\t}\n\t\t\t\text[0] = '=';\n\t\t\t} else {\n\t\t\t\tscheme_start = param;\n\t\t\t}\n\t\t}\n\n\t\t//extract scheme and value - if not, remove kind\n\t\tif (!scheme_start || !scheme_start[0]) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing kind scheme - expecting ID=schemeURI=value got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t} else {\n\t\t\text = strchr(scheme_start, '=');\n\t\t\tif (!ext) {\n\t\t\t\ttka->kind_scheme = gf_strdup(scheme_start);\n\t\t\t} else {\n\t\t\t\text[0] = 0;\n\t\t\t\ttka->kind_scheme = gf_strdup(scheme_start);\n\t\t\t\text[0] = '=';\n\t\t\t\ttka->kind_value = gf_strdup(ext + 1);\n\t\t\t}\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_DELAY) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\tif (sscanf(ext+1, \"%d/%u\", &tka->delay.num, &tka->delay.den) != 2) {\n\t\t\ttka->delay.num = atoi(ext + 1);\n\t\t\ttka->delay.den = 1000;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_REFERENCE) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) ext = strchr(param, ':');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\n\t\tchar *ext2 = strchr(ext, ':');\n\t\tif (!ext2) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text2[0] = 0;\n\t\tstrncpy(tka->lang, ext+1, 9);\n\t\text2[0] = ':';\n\t\ttka->newTrackID = (s32) atoi(ext2 + 1);\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_HANDLER_NAME) {\n\t\tchar *ext = strchr(param, '=');\n\t\tif (!ext) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad format for track name - expecting tkID=name got %s\\n\", param));\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\text[0] = 0;\n\t\ttka->trackID = atoi(param);\n\t\text[0] = '=';\n\t\ttka->hdl_name = ext + 1;\n\t\treturn GF_TRUE;\n\t}\n\tif (act_type==TRAC_ACTION_SET_KMS_URI) {\n\t\tchar *ext = strchr(param, '=');\n\n\t\tif (!strnicmp(param, \"all=\", 4)) {\n\t\t\ttka->kms = param + 4;\n\t\t} else if (!ext) {\n\t\t\ttka->kms = param;\n\t\t} else {\n\t\t\ttka->kms = ext + 1;\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(param);\n\t\t\text[0] = '=';\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\tif ((act_type==TRAC_ACTION_SET_TIME) || (act_type==TRAC_ACTION_SET_MEDIA_TIME)) {\n\t\tstruct tm time;\n\t\tchar *ext = strchr(arg_val, '=');\n\t\tif (ext) {\n\t\t\text[0] = 0;\n\t\t\ttka->trackID = atoi(arg_val);\n\t\t\text[0] = '=';\n\t\t\targ_val = ext+1;\n\t\t}\n\t\tmemset(&time, 0, sizeof(struct tm));\n\t\tsscanf(arg_val, \"%d/%d/%d-%d:%d:%d\", &time.tm_mday, &time.tm_mon, &time.tm_year, &time.tm_hour, &time.tm_min, &time.tm_sec);\n\t\ttime.tm_isdst = 0;\n\t\ttime.tm_year -= 1900;\n\t\ttime.tm_mon -= 1;\n\t\ttka->time = 2082758400;\n\t\ttka->time += mktime(&time);\n\t\treturn GF_TRUE;\n\t}\n\n\twhile (param) {\n\t\tparam = gf_url_colon_suffix(param);\n\t\tif (param) {\n\t\t\t*param = 0;\n\t\t\tparam++;\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\t\t\tif (!strncmp(\"vttnomerge\", param, 10)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_WEBVTT_NOMERGE;\n\t\t\t} else if (!strncmp(\"layer\", param, 5)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_SVC_LAYER;\n\t\t\t} else if (!strncmp(\"full\", param, 4)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_NHML_FULL;\n\t\t\t} else if (!strncmp(\"embedded\", param, 8)) {\n\t\t\t\ttka->dump_type |= GF_EXPORT_WEBVTT_META_EMBEDDED;\n\t\t\t} else if (!strncmp(\"output=\", param, 7)) {\n\t\t\t\ttka->out_name = gf_strdup(param+7);\n\t\t\t} else if (!strncmp(\"src=\", param, 4)) {\n\t\t\t\ttka->src_name = gf_strdup(param+4);\n\t\t\t} else if (!strncmp(\"str=\", param, 4)) {\n\t\t\t\ttka->string = gf_strdup(param+4);\n\t\t\t} else if (!strncmp(\"box=\", param, 4)) {\n\t\t\t\ttka->src_name = gf_strdup(param+4);\n\t\t\t\ttka->sample_num = 1;\n\t\t\t} else if (!strncmp(\"type=\", param, 4)) {\n\t\t\t\ttka->udta_type = GF_4CC(param[5], param[6], param[7], param[8]);\n\t\t\t} else if (tka->dump_type == GF_EXPORT_RAW_SAMPLES) {\n\t\t\t\ttka->sample_num = atoi(param);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\tif (arg_val) {\n\t\tif (!strcmp(arg_val, \"*\")) {\n\t\t\ttka->trackID = (u32) -1;\n\t\t} else {\n\t\t\tif (act_type==TRAC_ACTION_RAW_EXTRACT) {\n\t\t\t\tif (!strncmp(arg_val, \"video\", 5)) {\n\t\t\t\t\targ_val += 5;\n\t\t\t\t\ttka->dump_track_type = 1;\n\t\t\t\t}\n\t\t\t\telse if (!strncmp(arg_val, \"audio\", 5)) {\n\t\t\t\t\targ_val += 5;\n\t\t\t\t\ttka->dump_track_type = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (arg_val[0])\n\t\t\t\ttka->trackID = atoi(arg_val);\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nu32 parse_track_dump(char *arg, u32 dump_type)\n{\n\tif (!create_new_track_action(arg, TRAC_ACTION_RAW_EXTRACT, dump_type))\n\t\treturn 2;\n\ttrack_dump_type = dump_type;\n\treturn 0;\n}\nu32 parse_track_action(char *arg, u32 act_type)\n{\n\tif (!create_new_track_action(arg, act_type, 0)) {\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_comp_box(char *arg_val, u32 opt)\n{\n\tcompress_top_boxes = arg_val;\n\tsize_top_box = opt;\n\treturn 0;\n}\nu32 parse_dnal(char *arg_val, u32 opt)\n{\n\tdump_nal = atoi(arg_val);\n\tdump_nal_type = opt;\n\treturn 0;\n}\nu32 parse_dsap(char *arg_val, u32 opt)\n{\n\tdump_saps = atoi(arg_val);\n\tdump_saps_mode = opt;\n\treturn 0;\n}\n\nu32 parse_bs_switch(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"no\") || !stricmp(arg_val, \"off\")) bitstream_switching_mode = GF_DASH_BSMODE_NONE;\n\telse if (!stricmp(arg_val, \"merge\"))  bitstream_switching_mode = GF_DASH_BSMODE_MERGED;\n\telse if (!stricmp(arg_val, \"multi\"))  bitstream_switching_mode = GF_DASH_BSMODE_MULTIPLE_ENTRIES;\n\telse if (!stricmp(arg_val, \"single\"))  bitstream_switching_mode = GF_DASH_BSMODE_SINGLE;\n\telse if (!stricmp(arg_val, \"inband\"))  bitstream_switching_mode = GF_DASH_BSMODE_INBAND;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized bitstream switching mode \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_cp_loc(char *arg_val, u32 opt)\n{\n\tif (!strcmp(arg_val, \"both\")) cp_location_mode = GF_DASH_CPMODE_BOTH;\n\telse if (!strcmp(arg_val, \"as\")) cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;\n\telse if (!strcmp(arg_val, \"rep\")) cp_location_mode = GF_DASH_CPMODE_REPRESENTATION;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_pssh(char *arg_val, u32 opt)\n{\n\tif (!strcmp(arg_val, \"f\")) pssh_mode = GF_DASH_PSSH_MOOF;\n\telse if (!strcmp(arg_val, \"v\")) pssh_mode = GF_DASH_PSSH_MOOV;\n\telse if (!strcmp(arg_val, \"m\")) pssh_mode = GF_DASH_PSSH_MPD;\n\telse if (!strcmp(arg_val, \"mf\") || !strcmp(arg_val, \"fm\")) pssh_mode = GF_DASH_PSSH_MOOF_MPD;\n\telse if (!strcmp(arg_val, \"mv\") || !strcmp(arg_val, \"vm\")) pssh_mode = GF_DASH_PSSH_MOOV_MPD;\n\telse pssh_mode = GF_DASH_PSSH_MOOV;\n\treturn 0;\n}\nu32 parse_sdtp(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"both\")) sdtp_in_traf = 2;\n\telse if (!stricmp(arg_val, \"sdtp\")) sdtp_in_traf = 1;\n\telse sdtp_in_traf = 0;\n\treturn 0;\n}\n\nu32 parse_rap_ref(char *arg_val, u32 opt)\n{\n\tif (arg_val) {\n\t\tif (sscanf(arg_val, \"%d\", &trackID) == 1) {\n\t\t\tparse_track_action(arg_val, opt ? TRAC_ACTION_REM_NON_REFS : TRAC_ACTION_REM_NON_RAP);\n\t\t}\n\t}\n\thint_flags |= GP_RTP_PCK_SIGNAL_RAP;\n\tseg_at_rap = 1;\n\treturn 0;\n}\nu32 parse_store_mode(char *arg_val, u32 opt)\n{\n\tdo_save = GF_TRUE;\n\tif ((opt == 0) || (opt == 1)) {\n\t\tinterleaving_time = atof(arg_val) / 1000;\n\t\tif (!interleaving_time) do_flat = 2;\n\t\topen_edit = GF_TRUE;\n\t\tno_inplace = GF_TRUE;\n\t\tif (opt==1) old_interleave = 1;\n\t} else if (opt==2) {\n\t\tinterleaving_time = atof(arg_val);\n\t\tdo_frag = GF_TRUE;\n\t} else {\n\t\tforce_new = 2;\n\t\tinterleaving_time = 0.5;\n\t\tdo_flat = 1;\n\t}\n\treturn 0;\n}\nu32 parse_base_url(char *arg_val, u32 opt)\n{\n\tmpd_base_urls = gf_realloc(mpd_base_urls, (nb_mpd_base_urls + 1)*sizeof(char**));\n\tif (!mpd_base_urls) return 2;\n\tmpd_base_urls[nb_mpd_base_urls] = arg_val;\n\tnb_mpd_base_urls++;\n\treturn 0;\n}\nu32 parse_multi_rtp(char *arg_val, u32 opt)\n{\n\thint_flags |= GP_RTP_PCK_USE_MULTI;\n\tif (arg_val)\n\t\tmax_ptime = atoi(arg_val);\n\treturn 0;\n}\n\n\nu32 parse_senc_param(char *arg_val, u32 opt)\n{\n\tswitch (opt) {\n\tcase 0: //-sync\n\t\tsmenc_opts.flags |= GF_SM_ENCODE_RAP_INBAND;\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 1: //-shadow\n\t\tsmenc_opts.flags &= ~GF_SM_ENCODE_RAP_INBAND;\n\t\tsmenc_opts.flags |= GF_SM_ENCODE_RAP_SHADOW;\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 2: //-carousel\n\t\tsmenc_opts.flags &= ~(GF_SM_ENCODE_RAP_INBAND | GF_SM_ENCODE_RAP_SHADOW);\n\t\tsmenc_opts.rap_freq = atoi(arg_val);\n\t\tbreak;\n\tcase 3: //-auto-quant\n\t\tsmenc_opts.resolution = atoi(arg_val);\n\t\tsmenc_opts.auto_quant = 1;\n\t\tbreak;\n\tcase 4: //-global-quant\n\t\tsmenc_opts.resolution = atoi(arg_val);\n\t\tsmenc_opts.auto_quant = 2;\n\t\tbreak;\n\tcase 5: //-ctx-in or -inctx\n\t\tchunk_mode = GF_TRUE;\n\t\tinput_ctx = arg_val;\n\t}\n\treturn 0;\n}\nu32 parse_cryp(char *arg_val, u32 opt)\n{\n\topen_edit = GF_TRUE;\n\tif (!opt) {\n\t\tcrypt = 1;\n\t\tdrm_file = arg_val;\n\t\topen_edit = GF_TRUE;\n\t\treturn 0;\n\t}\n\tcrypt = 2;\n\tif (arg_val && get_file_type_by_ext(arg_val) != 1) {\n\t\tdrm_file = arg_val;\n\t\treturn 0;\n\t}\n\treturn 3;\n}\n\nu32 parse_dash_profile(char *arg_val, u32 opt)\n{\n\tif (!stricmp(arg_val, \"live\") || !stricmp(arg_val, \"simple\")) dash_profile = GF_DASH_PROFILE_LIVE;\n\telse if (!stricmp(arg_val, \"onDemand\")) dash_profile = GF_DASH_PROFILE_ONDEMAND;\n\telse if (!stricmp(arg_val, \"hbbtv1.5:live\") || !stricmp(arg_val, \"hbbtv1.5.live\"))\n\t\tdash_profile = GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE;\n\telse if (!stricmp(arg_val, \"dashavc264:live\") || !stricmp(arg_val, \"dashavc264.live\"))\n\t\tdash_profile = GF_DASH_PROFILE_AVC264_LIVE;\n\telse if (!stricmp(arg_val, \"dashavc264:onDemand\") || !stricmp(arg_val, \"dashavc264.onDemand\"))\n\t\tdash_profile = GF_DASH_PROFILE_AVC264_ONDEMAND;\n\telse if (!stricmp(arg_val, \"dashif.ll\")) dash_profile = GF_DASH_PROFILE_DASHIF_LL;\n\telse if (!stricmp(arg_val, \"main\")) dash_profile = GF_DASH_PROFILE_MAIN;\n\telse if (!stricmp(arg_val, \"full\")) dash_profile = GF_DASH_PROFILE_FULL;\n\telse {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unrecognized DASH profile \\\"%s\\\" - please check usage\\n\", arg_val));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_fps(char *arg_val, u32 opt)\n{\n\tu32 ticks, dts_inc;\n\tif (!strcmp(arg_val, \"auto\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning, fps=auto option is deprecated\\n\"));\n\t}\n\telse if ((sscanf(arg_val, \"%u-%u\", &ticks, &dts_inc)==2) || (sscanf(arg_val, \"%u/%u\", &ticks, &dts_inc)==2) ) {\n\t\tif (!dts_inc) dts_inc = 1;\n\t\timport_fps.num = ticks;\n\t\timport_fps.den = dts_inc;\n\t} else {\n\t\timport_fps.num = (s32) (1000 * atof(arg_val));\n\t\timport_fps.den = 1000;\n\t}\n\treturn 0;\n}\n\nu32 parse_split(char *arg_val, u32 opt)\n{\n\tswitch (opt) {\n\tcase 0://-split\n\t\tsplit_duration = atof(arg_val);\n\t\tif (split_duration < 0) split_duration = 0;\n\t\tsplit_size = 0;\n\t\tbreak;\n\tcase 1: //-split-rap, -splitr\n\t\tsplit_duration = -1;\n\t\tsplit_size = -1;\n\t\tbreak;\n\tcase 2: //-split-size, -splits\n\t\tsplit_size = (u32)atoi(arg_val);\n\t\tsplit_duration = 0;\n\t\tbreak;\n\tcase 4: //-splitz\n\t\tadjust_split_end = 1;\n\t\t//fallthrough\n\tcase 3: //-split-chunk, -splitx\n\t\tif (!strstr(arg_val, \":\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\tif (strstr(arg_val, \"end\")) {\n\t\t\tif (strstr(arg_val, \"end-\")) {\n\t\t\t\tDouble dur_end=0;\n\t\t\t\tsscanf(arg_val, \"%lf:end-%lf\", &split_start, &dur_end);\n\t\t\t\tsplit_duration = -2 - dur_end;\n\t\t\t} else {\n\t\t\t\tsscanf(arg_val, \"%lf:end\", &split_start);\n\t\t\t\tsplit_duration = -2;\n\t\t\t}\n\t\t} else {\n\t\t\tif (strchr(arg_val, '-')) {\n\t\t\t\tsplit_range_str = arg_val;\n\t\t\t} else {\n\t\t\t\tsscanf(arg_val, \"%lf:%lf\", &split_start, &split_duration);\n\t\t\t\tsplit_duration -= split_start;\n\t\t\t}\n\t\t}\n\t\tsplit_size = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nu32 parse_brand(char *b, u32 opt)\n{\n\topen_edit = GF_TRUE;\n\tswitch (opt) {\n\tcase 0: //-brand\n\t\tmajor_brand = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tif (b[4] == ':') {\n\t\t\tif (!strncmp(b+5, \"0x\", 2))\n\t\t\t\tsscanf(b+5, \"0x%x\", &minor_version);\n\t\t\telse\n\t\t\t\tminor_version = atoi(b + 5);\n\t\t}\n\t\tbreak;\n\tcase 1: //-ab\n\t\tbrand_add = (u32*)gf_realloc(brand_add, sizeof(u32) * (nb_alt_brand_add + 1));\n\t\tif (!brand_add) return 2;\n\t\tbrand_add[nb_alt_brand_add] = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tnb_alt_brand_add++;\n\t\tbreak;\n\tcase 2: //-rb\n\t\tbrand_rem = (u32*)gf_realloc(brand_rem, sizeof(u32) * (nb_alt_brand_rem + 1));\n\t\tif (!brand_rem) return 2;\n\t\tbrand_rem[nb_alt_brand_rem] = GF_4CC(b[0], b[1], b[2], b[3]);\n\t\tnb_alt_brand_rem++;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nu32 parse_mpegu(char *arg_val, u32 opt)\n{\n\tpack_file = arg_val;\n\tpack_wgt = GF_TRUE;\n\treturn 0;\n}\n\nu32 parse_file_info(char *arg_val, u32 opt)\n{\n\tprint_info = opt ? 2 : 1;\n\tif (arg_val) {\n\t\tif (sscanf(arg_val, \"%u\", &info_track_id) == 1) {\n\t\t\tchar szTk[20];\n\t\t\tsprintf(szTk, \"%u\", info_track_id);\n\t\t\tif (strcmp(szTk, arg_val)) info_track_id = 0;\n\t\t}\n\t\tif (!info_track_id) return 3;\n\t}\n\treturn 0;\n}\nu32 parse_boxpatch(char *arg_val, u32 opt)\n{\n\tbox_patch_filename = arg_val;\n\tchar *sep = strchr(box_patch_filename, '=');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tbox_patch_trackID = atoi(box_patch_filename);\n\t\tsep[0] = '=';\n\t\tbox_patch_filename = sep+1;\n\t}\n\topen_edit = GF_TRUE;\n\treturn 0;\n}\n\n\nu32 parse_dump_udta(char *code, u32 opt)\n{\n\tchar *sep;\n\tsep = strchr(code, ':');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tdump_udta_track = atoi(code);\n\t\tsep[0] = ':';\n\t\tcode = sep + 1;\n\t}\n\n\tif (strlen(code) == 4) {\n\t\tdump_udta_type = GF_4CC(code[0], code[1], code[2], code[3]);\n\t} else if (strlen(code) == 8) {\n\t\t// hex representation on 8 chars\n\t\tu32 hex1, hex2, hex3, hex4;\n\t\tif (sscanf(code, \"%02x%02x%02x%02x\", &hex1, &hex2, &hex3, &hex4) != 4) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\tdump_udta_type = GF_4CC(hex1, hex2, hex3, hex4);\n\t} else {\n\t\tM4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));\n\t\treturn 2;\n\t}\n\treturn 0;\n}\n\nu32 parse_dump_ts(char *arg_val, u32 opt)\n{\n\tdump_timestamps = 1;\n\tif (arg_val) {\n\t\tif (isdigit(arg_val[0])) {\n\t\t\tprogram_number = atoi(arg_val);\n\t\t} else {\n\t\t\treturn 3;\n\t\t}\n\t}\n\treturn 0;\n}\n\nu32 parse_ttxt(char *arg_val, u32 opt)\n{\n\tif (opt) //-srt\n\t\tdump_srt = GF_TRUE;\n\telse\n\t\tdump_ttxt = GF_TRUE;\n\n\timport_subtitle = 1;\n\ttrackID = 0;\n\n\tif (arg_val && (!strcmp(arg_val, \"*\") || !strcmp(arg_val, \"@\") || !strcmp(arg_val, \"all\")) ) {\n\t\ttrackID = (u32)-1;\n\t} else if (arg_val) {\n\t\tif (sscanf(arg_val, \"%u\", &trackID) == 1) {\n\t\t\tchar szTk[20];\n\t\t\tsprintf(szTk, \"%d\", trackID);\n\t\t\tif (strcmp(szTk, arg_val))\n\t\t\t\ttrackID = 0;\n\t\t}\n\t\tif (!trackID) return 3;\n\t}\n\treturn 0;\n}\n\nu32 parse_dashlive(char *arg, char *arg_val, u32 opt)\n{\n\tdash_mode = opt ? GF_DASH_DYNAMIC_DEBUG : GF_DASH_DYNAMIC;\n\tdash_live = 1;\n\tif (arg[10] == '=') {\n\t\tdash_ctx_file = arg + 11;\n\t}\n\tdash_duration = atof(arg_val);\n\treturn 0;\n}\n\nu32 parse_help(char *arg_val, u32 opt)\n{\n\tif (!arg_val) PrintUsage();\n\telse if (opt) PrintHelp(arg_val, GF_TRUE, GF_FALSE);\n\telse if (!strcmp(arg_val, \"general\")) PrintGeneralUsage();\n\telse if (!strcmp(arg_val, \"extract\")) PrintExtractUsage();\n\telse if (!strcmp(arg_val, \"split\")) PrintSplitUsage();\n\telse if (!strcmp(arg_val, \"dash\")) PrintDASHUsage();\n\telse if (!strcmp(arg_val, \"dump\")) PrintDumpUsage();\n\telse if (!strcmp(arg_val, \"import\")) PrintImportUsage();\n\telse if (!strcmp(arg_val, \"format\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"deprecated, see [filters documentation](Filters)\\n\"));\n\t}\n\telse if (!strcmp(arg_val, \"hint\")) PrintHintUsage();\n\telse if (!strcmp(arg_val, \"encode\")) PrintEncodeUsage();\n\telse if (!strcmp(arg_val, \"crypt\")) PrintEncryptUsage();\n\telse if (!strcmp(arg_val, \"meta\")) PrintMetaUsage();\n\telse if (!strcmp(arg_val, \"swf\")) PrintSWFUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\telse if (!strcmp(arg_val, \"rtp\")) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"RTP streaming deprecated in MP4Box, use gpac application\\n\"));\n\t}\n\telse if (!strcmp(arg_val, \"live\")) PrintLiveUsage();\n#endif\n\telse if (!strcmp(arg_val, \"core\")) PrintCoreUsage();\n\telse if (!strcmp(arg_val, \"tags\")) PrintTags();\n\telse if (!strcmp(arg_val, \"cicp\")) PrintCICP();\n\telse if (!strcmp(arg_val, \"all\")) {\n\t\tPrintGeneralUsage();\n\t\tPrintExtractUsage();\n\t\tPrintDASHUsage();\n\t\tPrintSplitUsage();\n\t\tPrintDumpUsage();\n\t\tPrintImportUsage();\n\t\tPrintHintUsage();\n\t\tPrintEncodeUsage();\n\t\tPrintEncryptUsage();\n\t\tPrintMetaUsage();\n\t\tPrintSWFUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\t\tPrintCoreUsage();\n\t\tPrintTags();\n\t\tPrintCICP();\n\t} else if (!strcmp(arg_val, \"opts\")) {\n\t\tPrintHelp(\"@\", GF_FALSE, GF_FALSE);\n\t} else {\n\t\tPrintHelp(arg_val, GF_FALSE, GF_FALSE);\n\t}\n\treturn 1;\n}\n\nu32 parse_gendoc(char *name, u32 opt)\n{\n\tu32 i=0;\n\t//gen MD\n\tif (!opt) {\n\t\thelp_flags = GF_PRINTARG_MD | GF_PRINTARG_IS_APP;\n\t\thelpout = gf_fopen(\"mp4box-gen-opts.md\", \"w\");\n\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb General\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tfprintf(helpout, \"# Syntax\\n\");\n\t\tgf_sys_format_help(helpout, help_flags, \"MP4Box [option] input [option] [other_dash_inputs]\\n\"\n\t\t\t\"  \\n\"\n\t\t);\n\t\tPrintGeneralUsage();\n\t\tPrintEncryptUsage();\n\t\tfprintf(helpout, \"# Help Options\\n\");\n\t\twhile (m4b_usage_args[i].name) {\n\t\t\tGF_GPACArg *g_arg = (GF_GPACArg *) &m4b_usage_args[i];\n\t\t\ti++;\n\t\t\tgf_sys_print_arg(helpout, help_flags, g_arg, \"mp4box-general\");\n\t\t}\n\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-import-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Import\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintImportUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-dash-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media DASH\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintDASHUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-dump-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Media Dump and Export\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintExtractUsage();\n\t\tPrintDumpUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-meta-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Meta and HEIF/IFF\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintMetaUsage();\n\t\tgf_fclose(helpout);\n\n\n\t\thelpout = gf_fopen(\"mp4box-scene-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Scene Description\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintEncodeUsage();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\t\tPrintSWFUsage();\n\t\tgf_fclose(helpout);\n\n\t\thelpout = gf_fopen(\"mp4box-other-opts.md\", \"w\");\n\t\tfprintf(helpout, \"[**HOME**](Home) \u00bb [**MP4Box**](MP4Box) \u00bb Other Features\");\n\t\tfprintf(helpout, \"<!-- automatically generated - do not edit, patch gpac/applications/mp4box/main.c -->\\n\");\n\t\tPrintHintUsage();\n\t\tPrintTags();\n\t\tgf_fclose(helpout);\n\t}\n\t//gen man\n\telse {\n\t\thelp_flags = GF_PRINTARG_MAN;\n\t\thelpout = gf_fopen(\"mp4box.1\", \"w\");\n\n\n\t\tfprintf(helpout, \".TH MP4Box 1 2019 MP4Box GPAC\\n\");\n\t\tfprintf(helpout, \".\\n.SH NAME\\n.LP\\nMP4Box \\\\- GPAC command-line media packager\\n.SH SYNOPSIS\\n.LP\\n.B MP4Box\\n.RI [options] \\\\ [file] \\\\ [options]\\n.br\\n.\\n\");\n\n\t\tPrintGeneralUsage();\n\t\tPrintExtractUsage();\n\t\tPrintDASHUsage();\n\t\tPrintSplitUsage();\n\t\tPrintDumpUsage();\n\t\tPrintImportUsage();\n\t\tPrintHintUsage();\n\t\tPrintEncodeUsage();\n\t\tPrintEncryptUsage();\n\t\tPrintMetaUsage();\n\t\tPrintSWFUsage();\n\t\tPrintTags();\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\t\tPrintLiveUsage();\n#endif\n\n\t\tfprintf(helpout, \".SH EXAMPLES\\n.TP\\nBasic and advanced examples are available at https://wiki.gpac.io/MP4Box\\n\");\n\t\tfprintf(helpout, \".SH MORE\\n.LP\\nAuthors: GPAC developers, see git repo history (-log)\\n\"\n\t\t\".br\\nFor bug reports, feature requests, more information and source code, visit https://github.com/gpac/gpac\\n\"\n\t\t\".br\\nbuild: %s\\n\"\n\t\t\".br\\nCopyright: %s\\n.br\\n\"\n\t\t\".SH SEE ALSO\\n\"\n\t\t\".LP\\ngpac(1), MP4Client(1)\\n\", gf_gpac_version(), gf_gpac_copyright());\n\n\t\tgf_fclose(helpout);\n\t}\n\treturn 1;\n}\n\nstatic Bool arg_parse_res = 0;\nu32 mp4box_parse_single_arg_class(int argc, char **argv, char *arg, u32 *arg_index, MP4BoxArg *arg_class)\n{\n\tMP4BoxArg *arg_desc = NULL;\n\tchar *arg_val = NULL;\n\tu32 i=0;\n\twhile (arg_class[i].name) {\n\t\targ_desc = (MP4BoxArg *) &arg_class[i];\n\t\ti++;\n\n#ifdef TEST_ARGS\n\t\tchar *sep = strchr(arg_desc->name, ' ');\n\t\tif (sep) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Invalid arg %s, space not allowed\\n\", arg_desc->name));\n\t\t\texit(1);\n\t\t}\n#endif\n\t\tif (!strcmp(arg_desc->name, arg+1))\n\t\t\tbreak;\n\t\tif (arg_desc->altname && !strcmp(arg_desc->altname, arg+1))\n\t\t\tbreak;\n\n\t\tif (arg_desc->parse_flags & ARG_IS_FUN2) {\n\t\t\tif (!strncmp(arg_desc->name, arg+1, strlen(arg_desc->name) ))\n\t\t\t\tbreak;\n\t\t}\n\t\targ_desc = NULL;\n\t}\n\tif (!arg_desc)\n\t\treturn GF_FALSE;\n\n\tif (arg_desc->parse_flags & ARG_OPEN_EDIT) open_edit = GF_TRUE;\n\tif (arg_desc->parse_flags & ARG_NEED_SAVE) do_save = GF_TRUE;\n\tif (arg_desc->parse_flags & ARG_NO_INPLACE) no_inplace = GF_TRUE;\n\n\tif (arg_desc->type != GF_ARG_BOOL) {\n\t\tBool has_next = GF_TRUE;\n\t\tif (*arg_index + 1 == (u32) argc)\n\t\t\thas_next = GF_FALSE;\n\t\telse if (argv[*arg_index + 1][0] == '-') {\n\t\t\ts32 v;\n\t\t\tif (sscanf(argv[*arg_index + 1], \"%d\", &v)!=1)\n\t\t\t\thas_next = GF_FALSE;\n\t\t}\n\t\tif (!has_next && ! (arg_desc->parse_flags & ARG_EMPTY) ) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing argument value for %s - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (has_next && (arg_desc->parse_flags & ARG_EMPTY) && (arg_desc->type==GF_ARG_INT)) {\n\t\t\ts32 ival;\n\t\t\tif (sscanf(argv[*arg_index + 1], \"%d\", &ival) != 1) {\n\t\t\t\thas_next = GF_FALSE;\n\t\t\t\targ_val = NULL;\n\t\t\t}\n\t\t}\n\t\tif (has_next) {\n\t\t\thas_next_arg = GF_TRUE;\n\t\t\t*arg_index += 1;\n\t\t\targ_val = argv[*arg_index];\n\t\t}\n\t}\n\tif (!arg_desc->arg_ptr) return GF_TRUE;\n\n\tif (arg_desc->parse_flags & (ARG_IS_FUN|ARG_IS_FUN2) ) {\n\t\tu32 res;\n\t\tif (arg_desc->parse_flags & ARG_PUSH_SYSARGS)\n\t\t\tgf_sys_set_args(argc, (const char**) argv);\n\n\t\tif (arg_desc->parse_flags & ARG_IS_FUN) {\n\t\t\tparse_arg_fun fun = (parse_arg_fun) arg_desc->arg_ptr;\n\t\t\tres = fun(arg_val, arg_desc->argv_val);\n\t\t} else {\n\t\t\tparse_arg_fun2 fun2 = (parse_arg_fun2) arg_desc->arg_ptr;\n\t\t\tres = fun2(arg, arg_val, arg_desc->argv_val);\n\t\t}\n\t\t//rewind, not our arg\n\t\tif ((res==3) && argv) {\n\t\t\t*arg_index -= 1;\n\t\t\tres = 0;\n\t\t}\n\t\targ_parse_res = res;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->parse_flags & ARG_INT_INC) {\n\t\t* (u32 *) arg_desc->arg_ptr += 1;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_BOOL) {\n\t\tif (!arg_desc->parse_flags) {\n\t\t\tif (arg_desc->argv_val) {\n\t\t\t\t* (u32 *) arg_desc->arg_ptr = arg_desc->argv_val;\n\t\t\t} else {\n\t\t\t\t* (Bool *) arg_desc->arg_ptr = GF_TRUE;\n\t\t\t}\n\t\t} else if (arg_desc->parse_flags & ARG_BOOL_REV) {\n\t\t\t* (Bool *) arg_desc->arg_ptr = GF_FALSE;\n\t\t} else if (arg_desc->parse_flags & ARG_HAS_VALUE) {\n\t\t\t* (u32 *) arg_desc->arg_ptr = 0;\n\t\t} else if (arg_desc->parse_flags & ARG_BIT_MASK) {\n\t\t\t* (u32 *) arg_desc->arg_ptr |= arg_desc->argv_val;\n\t\t} else if (arg_desc->parse_flags & ARG_BIT_MASK_REM) {\n\t\t\t* (u32 *) arg_desc->arg_ptr &= ~arg_desc->argv_val;\n\t\t} else if (arg_desc->argv_val) {\n\t\t\t* (u32 *) arg_desc->arg_ptr = arg_desc->argv_val;\n\t\t} else {\n\t\t\t* (u32 *) arg_desc->arg_ptr = GF_TRUE;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_STRING) {\n\t\tif (arg_desc->parse_flags & ARG_IS_4CC) {\n\t\t\tu32 alen = arg_val ? (u32) strlen(arg_val) : 0;\n\t\t\tif ((alen<3) || (alen>4)) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s must be a 4CC, %s is not - please check usage\\n\", arg, arg_val));\n\t\t\t\targ_parse_res = 2;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\t* (u32 *) arg_desc->arg_ptr = GF_4CC(arg_val[0], arg_val[1], arg_val[2], arg_val[3]);\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\t* (char **) arg_desc->arg_ptr = arg_val;\n\t\treturn GF_TRUE;\n\t}\n\tif (!arg_val) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Missing value for %s - please check usage\\n\", arg));\n\t\targ_parse_res = 2;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type == GF_ARG_DOUBLE) {\n\t\tDouble v = atof(arg_val);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (Double *) arg_desc->arg_ptr = v;\n\t\treturn GF_TRUE;\n\t}\n\n\tif (arg_desc->type != GF_ARG_INT) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Unsupported argument type for %s - please report to gpac devs\\n\", arg));\n\t\targ_parse_res = 2;\n\t\treturn GF_TRUE;\n\t}\n\tif (arg_desc->parse_flags & ARG_64BITS) {\n\t\tu64 v;\n\t\tsscanf(arg_val, LLU, &v);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (u64 *) arg_desc->arg_ptr = v;\n\t} else {\n\t\tu32 v = atoi(arg_val);\n\t\tif (arg_desc->parse_flags & ARG_DIV_1000) {\n\t\t\tv /= 1000;\n\t\t}\n\t\tif ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));\n\t\t\targ_parse_res = 2;\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\t* (s32 *) arg_desc->arg_ptr = v;\n\t}\n\treturn GF_TRUE;\n}\n\nBool mp4box_parse_single_arg(int argc, char **argv, char *arg, u32 *arg_index)\n{\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_gen_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_split_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dash_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_imp_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_senc_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_crypt_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_hint_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_extr_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_dump_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_meta_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_swf_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_liveenc_args)) return GF_TRUE;\n\tif (mp4box_parse_single_arg_class(argc, argv, arg, arg_index, m4b_usage_args)) return GF_TRUE;\n\n\treturn GF_FALSE;\n}\n\n\nu32 mp4box_parse_args(int argc, char **argv)\n{\n\tu32 i;\n\t/*parse our args*/\n\tfor (i = 1; i < (u32)argc; i++) {\n\t\tchar *arg = argv[i];\n\t\t/*input file(s)*/\n\t\tif ((arg[0] != '-') || !stricmp(arg, \"--\")) {\n\t\t\tchar *arg_val = arg;\n\t\t\tif (!stricmp(arg, \"--\")) {\n\t\t\t\tif (i+1==(u32)argc) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing arg for `--` - please check usage\\n\"));\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t\thas_next_arg = GF_TRUE;\n\t\t\t\targ_val = argv[i + 1];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (argc < 3) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - only one input file found as argument, please check usage\\n\"));\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse if (inName) {\n\t\t\t\tif (dash_duration) {\n\t\t\t\t\tif (!nb_dash_inputs) {\n\t\t\t\t\t\tdash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);\n\t\t\t\t\t}\n\t\t\t\t\tdash_inputs = set_dash_input(dash_inputs, arg_val, &nb_dash_inputs);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - 2 input names specified, please check usage\\n\"));\n\t\t\t\t\treturn 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinName = arg_val;\n\t\t\t}\n\t\t}\n\t\t//all deprecated options\n\t\telse if (!stricmp(arg, \"-grab-ts\") || !stricmp(arg, \"-atsc\") || !stricmp(arg, \"-rtp\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Deprecated fuctionnality `%s` - use gpac application\\n\", arg));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-write-buffer\")) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"`%s` option deprecated, use `-bs-cache-size`\", arg));\n\t\t\tgf_opts_set_key(\"temp\", \"bs-cache-size\", argv[i + 1]);\n\t\t\ti++;\n\t\t}\n\t\telse if (!stricmp(arg, \"-pssh-moof\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-pssh-moof` option deprecated , use `-pssh` option\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-tag-list\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-tag-list` option deprecated, use `-h tags`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-aviraw\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-aviraw` option deprecated, use `-raw`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!stricmp(arg, \"-avi\")) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"`-avi` option deprecated, use `-mux`\\n\"));\n\t\t\treturn 2;\n\t\t}\n\t\telse if (!strncmp(arg, \"-p=\", 3)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t//parse argument\n\t\telse if (mp4box_parse_single_arg(argc, argv, arg, &i)) {\n\t\t\tif (arg_parse_res)\n\t\t\t\treturn mp4box_cleanup(arg_parse_res);\n\t\t}\n\t\t//not a MP4Box arg\n\t\telse {\n\t\t\tu32 res = gf_sys_is_gpac_arg(arg);\n\t\t\tif (res==0) {\n\t\t\t\tPrintHelp(arg, GF_FALSE, GF_TRUE);\n\t\t\t\treturn 2;\n\t\t\t} else if (res==2) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\t//live scene encoder does not use the unified parsing and should be moved as a scene encoder filter\n\t\tif (live_scene) return 0;\n\t}\n\treturn 0;\n}\n\n/*\n\tEND OF OPTION PARSING CODE\n*/\n\n\n\nvoid scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist)\n{\n\tFILE *logs = cbk;\n\tif (log_tool != GF_LOG_CODING) return;\n\tvfprintf(logs, fmt, vlist);\n\tfflush(logs);\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*\n\t\tMP4 File Hinting\n*/\n\nvoid SetupClockReferences(GF_ISOFile *file)\n{\n\tu32 i, count, ocr_id;\n\tcount = gf_isom_get_track_count(file);\n\tif (count==1) return;\n\tocr_id = 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tocr_id = gf_isom_get_track_id(file, i+1);\n\t\tbreak;\n\t}\n\t/*doesn't look like MP4*/\n\tif (!ocr_id) return;\n\tfor (i=0; i<count; i++) {\n\t\tGF_ESD *esd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd) {\n\t\t\tesd->OCRESID = ocr_id;\n\t\t\tgf_isom_change_mpeg4_description(file, i+1, 1, esd);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t}\n\t}\n}\n\n/*base RTP payload type used (you can specify your own types if needed)*/\n#define BASE_PAYT\t\t96\n\nGF_Err HintFile(GF_ISOFile *file, u32 MTUSize, u32 max_ptime, u32 rtp_rate, u32 base_flags, Bool copy_data, Bool interleave, Bool regular_iod, Bool single_group, Bool hint_no_offset)\n{\n\tGF_ESD *esd;\n\tGF_InitialObjectDescriptor *iod;\n\tu32 i, val, res, streamType;\n\tu32 sl_mode, prev_ocr, single_ocr, nb_done, tot_bw, bw, flags, spec_type;\n\tGF_Err e;\n\tchar szPayload[30];\n\tGF_RTPHinter *hinter;\n\tBool copy, has_iod, single_av;\n\tu8 init_payt = BASE_PAYT;\n\tu32 mtype;\n\tGF_SDP_IODProfile iod_mode = GF_SDP_IOD_NONE;\n\tu32 media_group = 0;\n\tu8 media_prio = 0;\n\n\ttot_bw = 0;\n\tprev_ocr = 0;\n\tsingle_ocr = 1;\n\n\thas_iod = 1;\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) has_iod = 0;\n\telse {\n\t\tif (!gf_list_count(iod->ESDescriptors)) has_iod = 0;\n\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t}\n\n\tspec_type = gf_isom_guess_specification(file);\n\tsingle_av = single_group ? 1 : gf_isom_is_single_av(file);\n\n\t/*first make sure we use a systems track as base OCR*/\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tres = gf_isom_get_media_type(file, i+1);\n\t\tif ((res==GF_ISOM_MEDIA_SCENE) || (res==GF_ISOM_MEDIA_OD)) {\n\t\t\tif (gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t\tgf_isom_set_default_sync_track(file, i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnb_done = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tsl_mode = base_flags;\n\t\tcopy = copy_data;\n\t\t/*skip emty tracks (mainly MPEG-4 interaction streams...*/\n\t\tif (!gf_isom_get_sample_count(file, i+1)) continue;\n\t\tif (!gf_isom_is_track_enabled(file, i+1)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));\n\t\t\tcontinue;\n\t\t}\n\n\t\tmtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 2;\n\t\t\t}\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 3;\n            }\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            if (single_av) {\n                media_group = 2;\n                media_prio = 4;\n            }\n            break;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (single_av) {\n\t\t\t\tmedia_group = 2;\n\t\t\t\tmedia_prio = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\t/*no hinting of systems track on isma*/\n\t\t\tif (spec_type==GF_ISOM_BRAND_ISMA) continue;\n\t\t}\n\t\tmtype = gf_isom_get_media_subtype(file, i+1, 1);\n\t\tif ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP) ) mtype = gf_isom_get_mpeg4_subtype(file, i+1, 1);\n\n\t\tif (!single_av) {\n\t\t\t/*one media per group only (we should prompt user for group selection)*/\n\t\t\tmedia_group ++;\n\t\t\tmedia_prio = 1;\n\t\t}\n\n\t\tstreamType = 0;\n\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\tif (esd && esd->decoderConfig) {\n\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\tif (!prev_ocr) {\n\t\t\t\tprev_ocr = esd->OCRESID;\n\t\t\t\tif (!esd->OCRESID) prev_ocr = esd->ESID;\n\t\t\t} else if (esd->OCRESID && prev_ocr != esd->OCRESID) {\n\t\t\t\tsingle_ocr = 0;\n\t\t\t}\n\t\t\t/*OD MUST BE WITHOUT REFERENCES*/\n\t\t\tif (streamType==1) copy = 1;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (!regular_iod && gf_isom_is_track_in_root_od(file, i+1)) {\n\t\t\t/*single AU - check if base64 would fit in ESD (consider 33% overhead of base64), otherwise stream*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) {\n\t\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i+1, 1, &val);\n\t\t\t\tif (streamType) {\n\t\t\t\t\tres = gf_hinter_can_embbed_data(samp->data, samp->dataLength, streamType);\n\t\t\t\t} else {\n\t\t\t\t\t/*not a system track, we shall hint it*/\n\t\t\t\t\tres = 0;\n\t\t\t\t}\n\t\t\t\tif (samp) gf_isom_sample_del(&samp);\n\t\t\t\tif (res) continue;\n\t\t\t}\n\t\t}\n\t\tif (interleave) sl_mode |= GP_RTP_PCK_USE_INTERLEAVING;\n\n\t\thinter = gf_hinter_track_new(file, i+1, MTUSize, max_ptime, rtp_rate, sl_mode, init_payt, copy, media_group, media_prio, &e);\n\n\t\tif (!hinter) {\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));\n\t\t\t\tif (!nb_done) return e;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hint_no_offset)\n\t\t\tgf_hinter_track_force_no_offsets(hinter);\n\n\t\tbw = gf_hinter_track_get_bandwidth(hinter);\n\t\ttot_bw += bw;\n\t\tflags = gf_hinter_track_get_flags(hinter);\n\n\t\t//set extraction mode for AVC/SVC\n\t\tgf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);\n\n\t\tgf_hinter_track_get_payload_name(hinter, szPayload);\n\t\tM4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));\n\t\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));\n\t\te = gf_hinter_track_process(hinter);\n\n\t\tif (!e) e = gf_hinter_track_finalize(hinter, has_iod);\n\t\tgf_hinter_track_del(hinter);\n\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));\n\t\t\tif (!nb_done) return e;\n\t\t}\n\t\tinit_payt++;\n\t\tnb_done ++;\n\t}\n\n\tif (has_iod) {\n\t\tiod_mode = GF_SDP_IOD_ISMA;\n\t\tif (regular_iod) iod_mode = GF_SDP_IOD_REGULAR;\n\t} else {\n\t\tiod_mode = GF_SDP_IOD_NONE;\n\t}\n\tgf_hinter_finalize(file, iod_mode, tot_bw);\n\n\tif (!single_ocr)\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));\n\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)\n\nstatic void check_media_profile(GF_ISOFile *file, u32 track)\n{\n\tu8 PL;\n\tGF_ESD *esd = gf_isom_get_esd(file, track, 1);\n\tif (!esd) return;\n\n\tswitch (esd->decoderConfig->streamType) {\n\tcase 0x04:\n\t\tPL = gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL);\n\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {\n\t\t\tGF_M4VDecSpecInfo vdsi;\n\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &vdsi);\n\t\t\tif (vdsi.VideoPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, vdsi.VideoPL);\n\t\t} else if ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0x15);\n\t\t} else if (!PL) {\n\t\t\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFE);\n\t\t}\n\t\tbreak;\n\tcase 0x05:\n\t\tPL = gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO);\n\t\tswitch (esd->decoderConfig->objectTypeIndication) {\n\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t{\n\t\t\tGF_M4ADecSpecInfo adsi;\n\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &adsi);\n\t\t\tif (adsi.audioPL > PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, adsi.audioPL);\n\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!PL) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFE);\n\t\t}\n\t\tbreak;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n}\nvoid remove_systems_tracks(GF_ISOFile *file)\n{\n\tu32 i, count;\n\n\tcount = gf_isom_get_track_count(file);\n\tif (count==1) return;\n\n\t/*force PL rewrite*/\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 1);\t/*the lib always remove IOD when no profiles are specified..*/\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tswitch (gf_isom_get_media_type(file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n        case GF_ISOM_MEDIA_AUXV:\n        case GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tgf_isom_remove_track_from_root_od(file, i+1);\n\t\t\tcheck_media_profile(file, i+1);\n\t\t\tbreak;\n\t\t/*only remove real systems tracks (eg, delaing with scene description & presentation)\n\t\tbut keep meta & all unknown tracks*/\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\t\t\tgf_isom_remove_track_from_root_od(file, i+1);\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\tcase GF_ISOM_MEDIA_OCR:\n\t\tcase GF_ISOM_MEDIA_MPEGJ:\n\t\t\tgf_isom_remove_track(file, i+1);\n\t\t\ti--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*none required*/\n\tif (!gf_isom_get_pl_indication(file, GF_ISOM_PL_AUDIO)) gf_isom_set_pl_indication(file, GF_ISOM_PL_AUDIO, 0xFF);\n\tif (!gf_isom_get_pl_indication(file, GF_ISOM_PL_VISUAL)) gf_isom_set_pl_indication(file, GF_ISOM_PL_VISUAL, 0xFF);\n\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_OD, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_SCENE, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_GRAPHICS, 0xFF);\n\tgf_isom_set_pl_indication(file, GF_ISOM_PL_INLINE, 0);\n}\n\n#endif /*!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_AV_PARSERS)*/\n\nGF_FileType get_file_type_by_ext(char *inName)\n{\n\tGF_FileType type = GF_FILE_TYPE_NOT_SUPPORTED;\n\tchar *ext = strrchr(inName, '.');\n\tif (ext) {\n\t\tchar *sep;\n\t\tif (!strcmp(ext, \".gz\")) ext = strrchr(ext-1, '.');\n\t\text+=1;\n\t\tsep = strchr(ext, '.');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!stricmp(ext, \"mp4\") || !stricmp(ext, \"3gp\") || !stricmp(ext, \"mov\") || !stricmp(ext, \"3g2\") || !stricmp(ext, \"3gs\")) {\n\t\t\ttype = GF_FILE_TYPE_ISO_MEDIA;\n\t\t} else if (!stricmp(ext, \"bt\") || !stricmp(ext, \"wrl\") || !stricmp(ext, \"x3dv\")) {\n\t\t\ttype = GF_FILE_TYPE_BT_WRL_X3DV;\n\t\t} else if (!stricmp(ext, \"xmt\") || !stricmp(ext, \"x3d\")) {\n\t\t\ttype = GF_FILE_TYPE_XMT_X3D;\n\t\t} else if (!stricmp(ext, \"lsr\") || !stricmp(ext, \"saf\")) {\n\t\t\ttype = GF_FILE_TYPE_LSR_SAF;\n\t\t} else if (!stricmp(ext, \"svg\") || !stricmp(ext, \"xsr\") || !stricmp(ext, \"xml\")) {\n\t\t\ttype = GF_FILE_TYPE_SVG;\n\t\t} else if (!stricmp(ext, \"swf\")) {\n\t\t\ttype = GF_FILE_TYPE_SWF;\n\t\t} else if (!stricmp(ext, \"jp2\")) {\n\t\t\tif (sep) sep[0] = '.';\n\t\t\treturn GF_FILE_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse type = GF_FILE_TYPE_NOT_SUPPORTED;\n\n\t\tif (sep) sep[0] = '.';\n\t}\n\n\n\t/*try open file in read mode*/\n\tif (!type && gf_isom_probe_file(inName)) type = GF_FILE_TYPE_ISO_MEDIA;\n\treturn type;\n}\n\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\nstatic GF_Err xml_bs_to_bin(char *inName, char *outName, u32 dump_std)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu8 *data = NULL;\n\tu32 data_size;\n\n\tGF_DOMParser *dom = gf_xml_dom_new();\n\te = gf_xml_dom_parse(dom, inName, NULL, NULL);\n\tif (e) {\n\t\tgf_xml_dom_del(dom);\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to parse XML file: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root_idx(dom, 0);\n\tif (!root) {\n\t\tgf_xml_dom_del(dom);\n\t\treturn GF_OK;\n\t}\n\n\te = gf_xml_parse_bit_sequence(root, inName, &data, &data_size);\n\tgf_xml_dom_del(dom);\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\n\tif (dump_std) {\n\t\tgf_fwrite(data, data_size, stdout);\n\t} else {\n\t\tFILE *t;\n\t\tchar szFile[GF_MAX_PATH];\n\t\tif (outName) {\n\t\t\tstrcpy(szFile, outName);\n\t\t} else {\n\t\t\tstrcpy(szFile, inName);\n\t\t\tstrcat(szFile, \".bin\");\n\t\t}\n\t\tt = gf_fopen(szFile, \"wb\");\n\t\tif (!t) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", szFile));\n\t\t\te = GF_IO_ERR;\n\t\t} else {\n\t\t\tif (gf_fwrite(data, data_size, t) != data_size) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to write output to file %s\\n\", szFile));\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t\tgf_fclose(t);\n\t\t}\n\t}\n\tgf_free(data);\n\treturn e;\n}\n#endif /*GPAC_DISABLE_CORE_TOOLS*/\n\nstatic u64 do_size_top_boxes(char *inName, char *compress_top_boxes, u32 mode)\n{\n\tFILE *in;\n\tu64 top_size = 0;\n\tBool do_all = GF_FALSE;\n\tGF_BitStream *bs_in;\n\tif (!compress_top_boxes) return GF_BAD_PARAM;\n\tif (!strcmp(compress_top_boxes, \"all\") || !strcmp(compress_top_boxes, \"*\") || !strcmp(compress_top_boxes, \"@\"))\n\t\tdo_all = GF_TRUE;\n\n\tin = gf_fopen(inName, \"rb\");\n\tif (!in) return GF_URL_ERROR;\n\tbs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs_in)) {\n\t\tconst char *stype;\n\t\tu32 hdr_size = 8;\n\t\tu64 lsize = gf_bs_read_u32(bs_in);\n\t\tu32 type = gf_bs_read_u32(bs_in);\n\n\t\tif (lsize==1) {\n\t\t\tlsize = gf_bs_read_u64(bs_in);\n\t\t\thdr_size = 16;\n\t\t} else if (lsize==0) {\n\t\t\tlsize = gf_bs_available(bs_in) + 8;\n\t\t}\n\t\tstype = gf_4cc_to_str(type);\n\t\tif (do_all || strstr(compress_top_boxes, stype)) {\n\t\t\t//only count boxes\n\t\t\tif (mode==2) {\n\t\t\t\ttop_size += 1;\n\t\t\t} else {\n\t\t\t\ttop_size += lsize;\n\t\t\t}\n\t\t}\n\t\tgf_bs_skip_bytes(bs_in, lsize - hdr_size);\n\t}\n\tgf_bs_del(bs_in);\n\tgf_fclose(in);\n\treturn top_size;\n\n}\n\nstatic GF_Err do_compress_top_boxes(char *inName, char *outName)\n{\n\tFILE *in, *out;\n\tu8 *buf;\n\tu32 buf_alloc, comp_size;\n\ts32 bytes_comp=0;\n\ts32 bytes_uncomp=0;\n\tGF_Err e = GF_OK;\n\tu64 source_size, dst_size;\n\tu32 orig_box_overhead;\n\tu32 final_box_overhead;\n\tu32 nb_added_box_bytes=0;\n\tBool has_mov = GF_FALSE;\n\tBool replace_all = !strcmp(compress_top_boxes, \"*\");\n\tGF_BitStream *bs_in, *bs_out;\n\n\tif (!outName) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Missing output file name\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tin = gf_fopen(inName, \"rb\");\n\tif (!in) return GF_URL_ERROR;\n\tout = gf_fopen(outName, \"wb\");\n\tif (!out) return GF_IO_ERR;\n\n\tbuf_alloc = 4096;\n\tbuf = gf_malloc(buf_alloc);\n\n\tbs_in = gf_bs_from_file(in, GF_BITSTREAM_READ);\n\tsource_size = gf_bs_get_size(bs_in);\n\n\tbs_out = gf_bs_from_file(out, GF_BITSTREAM_WRITE);\n\n\torig_box_overhead = 0;\n\tfinal_box_overhead = 0;\n\twhile (gf_bs_available(bs_in)) {\n\t\tu32 size = gf_bs_read_u32(bs_in);\n\t\tu32 type = gf_bs_read_u32(bs_in);\n\t\tconst char *b4cc = gf_4cc_to_str(type);\n\t\tconst u8 *replace = (const u8 *) strstr(compress_top_boxes, b4cc);\n\t\tif (!strcmp(b4cc, \"moov\")) has_mov = GF_TRUE;\n\n\t\tif (!replace && !replace_all) {\n\t\t\tgf_bs_write_u32(bs_out, size);\n\t\t\tgf_bs_write_u32(bs_out, type);\n\n\t\t\tsize-=8;\n\t\t\twhile (size) {\n\t\t\t\tu32 nbytes = size;\n\t\t\t\tif (nbytes>buf_alloc) nbytes=buf_alloc;\n\t\t\t\tgf_bs_read_data(bs_in, buf, nbytes);\n\t\t\t\tgf_bs_write_data(bs_out, buf, nbytes);\n\t\t\t\tsize-=nbytes;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\torig_box_overhead += size;\n\n\t\tsize-=8;\n\n\t\tif (size>buf_alloc) {\n\t\t\tbuf_alloc = size;\n\t\t\tbuf = gf_realloc(buf, buf_alloc);\n\t\t}\n\t\tgf_bs_read_data(bs_in, buf, size);\n\n\t\treplace+=5;\n\n\t\tcomp_size = buf_alloc;\n\n\t\te = gf_gz_compress_payload(&buf, size, &comp_size);\n\t\tif (e) break;\n\n\t\tif (comp_size>buf_alloc) {\n\t\t\tbuf_alloc = comp_size;\n\t\t}\n\t\tbytes_uncomp += size;\n\t\tbytes_comp += comp_size;\n\n\t\t//write size\n\t\tgf_bs_write_u32(bs_out, comp_size+8);\n\t\t//write type\n\t\tgf_bs_write_data(bs_out, replace, 4);\n\t\t//write data\n\t\tgf_bs_write_data(bs_out, buf, comp_size);\n\n\t\tfinal_box_overhead += 8+comp_size;\n\t}\n\tdst_size = gf_bs_get_position(bs_out);\n\n\tif (buf) gf_free(buf);\n\tgf_bs_del(bs_in);\n\tgf_bs_del(bs_out);\n\tgf_fclose(in);\n\tgf_fclose(out);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error compressing: %s\\n\", gf_error_to_string(e)));\n\t\treturn e;\n\t}\n\n\tif (has_mov) {\n\t\tu32 i, nb_tracks, nb_samples;\n\t\tGF_ISOFile *mov;\n\t\tDouble rate, new_rate, duration;\n\n\t\tmov = gf_isom_open(inName, GF_ISOM_OPEN_READ, NULL);\n\t\tduration = (Double) gf_isom_get_duration(mov);\n\t\tduration /= gf_isom_get_timescale(mov);\n\n\t\tnb_samples = 0;\n\t\tnb_tracks = gf_isom_get_track_count(mov);\n\t\tfor (i=0; i<nb_tracks; i++) {\n\t\t\tnb_samples += gf_isom_get_sample_count(mov, i+1);\n\t\t}\n\t\tgf_isom_close(mov);\n\n\t\trate = (Double) source_size;\n\t\trate /= duration;\n\t\trate /= 1000;\n\n\t\tnew_rate = (Double) dst_size;\n\t\tnew_rate /= duration;\n\t\tnew_rate /= 1000;\n\n\n\t\tfprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\torate\\tcrate\\tsamples\\tduration\\tobbps\\tcbbps\\n\");\n\t\tfprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\t%g\\t%g\\t%d\\t%g\\t%g\\t%g\\n\", inName, bytes_uncomp, bytes_comp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, nb_samples, duration, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );\n\n\t\tfprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d original rate %g kbps new rate %g kbps, orig %g box bytes/sample final %g bytes/sample\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes, rate, new_rate, ((Double)orig_box_overhead)/nb_samples, ((Double)final_box_overhead)/nb_samples );\n\n\t} else {\n\t\tfprintf(stderr, \"Log format:\\nname\\torig\\tcomp\\tgain\\tadded_bytes\\n\");\n\t\tfprintf(stdout, \"%s\\t%d\\t%d\\t%g\\t%d\\n\", inName, bytes_uncomp, bytes_comp, ((Double) (bytes_uncomp - bytes_comp)*100)/(bytes_uncomp), nb_added_box_bytes);\n\n\t\tfprintf(stderr, \"%s Compressing top-level boxes saved %d bytes out of %d (reduced by %g %%) additional bytes %d\\n\", inName, bytes_uncomp-bytes_comp, bytes_uncomp, ((Double)(bytes_uncomp-bytes_comp)*100)/bytes_uncomp, nb_added_box_bytes);\n\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err hash_file(char *name, u32 dump_std)\n{\n\tu32 i;\n\tu8 hash[20];\n\tGF_Err e = gf_media_get_file_hash(name, hash);\n\tif (e) return e;\n\tif (dump_std==2) {\n\t\tgf_fwrite(hash, 20, stdout);\n\t} else if (dump_std==1) {\n\t\tfor (i=0; i<20; i++) fprintf(stdout, \"%02X\", hash[i]);\n\t}\n\tfprintf(stderr, \"File hash (SHA-1): \");\n\tfor (i=0; i<20; i++) fprintf(stderr, \"%02X\", hash[i]);\n\tfprintf(stderr, \"\\n\");\n\n\treturn GF_OK;\n}\n\nstatic u32 do_raw_cat()\n{\n\tchar chunk[4096];\n\tFILE *fin, *fout;\n\ts64 to_copy, done;\n\tfin = gf_fopen(raw_cat, \"rb\");\n\tif (!fin) return mp4box_cleanup(1);\n\n\tfout = gf_fopen(inName, \"a+b\");\n\tif (!fout) {\n\t\tgf_fclose(fin);\n\t\treturn mp4box_cleanup(1);\n\t}\n\tgf_fseek(fin, 0, SEEK_END);\n\tto_copy = gf_ftell(fin);\n\tgf_fseek(fin, 0, SEEK_SET);\n\tdone = 0;\n\twhile (1) {\n\t\tu32 nb_bytes = (u32) gf_fread(chunk, 4096, fin);\n\t\tgf_fwrite(chunk, nb_bytes, fout);\n\t\tdone += nb_bytes;\n\t\tfprintf(stderr, \"Appending file %s - %02.2f done\\r\", raw_cat, 100.0*done/to_copy);\n\t\tif (done >= to_copy) break;\n\t}\n\tgf_fclose(fin);\n\tgf_fclose(fout);\n\treturn mp4box_cleanup(0);\n}\n\nstatic u32 do_write_udp()\n{\n\tGF_Err e;\n\tGF_Socket *sock = gf_sk_new(GF_SOCK_TYPE_UDP);\n\tu16 port = 2345;\n\tchar *sep = strrchr(udp_dest, ':');\n\tif (sep) {\n\t\tsep[0] = 0;\n\t\tport = atoi(sep+1);\n\t}\n\te = gf_sk_bind( sock, \"127.0.0.1\", 0, udp_dest, port, 0);\n\tif (sep) sep[0] = ':';\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to bind socket to %s: %s\\n\", udp_dest, gf_error_to_string(e) ));\n\t} else {\n\t\te = gf_sk_send(sock, (u8 *) inName, (u32)strlen(inName));\n\t\tif (e)\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to send datagram: %s\\n\", gf_error_to_string(e) ));\n\t}\n\tgf_sk_del(sock);\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_MPD\nstatic u32 convert_mpd()\n{\n\tGF_Err e;\n\tBool remote = GF_FALSE;\n\tGF_MPD *mpd;\n\tchar *mpd_base_url = NULL;\n\tif (!strnicmp(inName, \"http://\", 7) || !strnicmp(inName, \"https://\", 8)) {\n#if !defined(GPAC_DISABLE_CORE_TOOLS)\n\t\te = gf_dm_wget(inName, \"tmp_main.m3u8\", 0, 0, &mpd_base_url);\n\t\tif (e != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot retrieve M3U8 (%s): %s\\n\", inName, gf_error_to_string(e)));\n\t\t\tif (mpd_base_url) gf_free(mpd_base_url);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tremote = GF_TRUE;\n#else\n\t\tgf_free(mpd_base_url);\n\t\tM4_LOG(GF_LOG_ERROR, (\"HTTP Downloader disabled in this build\\n\"));\n\t\treturn mp4box_cleanup(1);\n#endif\n\n\t\tif (outName)\n\t\t\tstrcpy(outfile, outName);\n\t\telse {\n\t\t\tconst char *sep = gf_file_basename(inName);\n\t\t\tchar *ext = gf_file_ext_start(sep);\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tsprintf(outfile, \"%s.mpd\", sep);\n\t\t\tif (ext) ext[0] = '.';\n\t\t}\n\t} else {\n\t\tif (outName)\n\t\t\tstrcpy(outfile, outName);\n\t\telse {\n\t\t\tchar *dst = strdup(inName);\n\t\t\tchar *ext = strstr(dst, \".m3u8\");\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tsprintf(outfile, \"%s.mpd\", dst);\n\t\t\tgf_free(dst);\n\t\t}\n\t}\n\n\tmpd = gf_mpd_new();\n\tif (!mpd) {\n\t\te = GF_OUT_OF_MEM;\n\t\tM4_LOG(GF_LOG_ERROR, (\"[DASH] Error: MPD creation problem %s\\n\", gf_error_to_string(e)));\n\t\tmp4box_cleanup(1);\n\t}\n\tFILE *f = gf_fopen(remote ? \"tmp_main.m3u8\" : inName, \"r\");\n\tu32 manif_type = 0;\n\tif (f) {\n\t\tchar szDATA[1000];\n\t\ts32 read;\n\t\tszDATA[999]=0;\n\t\tread = (s32) gf_fread(szDATA, 999, f);\n\t\tif (read<0) read = 0;\n\t\tszDATA[read]=0;\n\t\tgf_fclose(f);\n\t\tif (strstr(szDATA, \"SmoothStreamingMedia\"))\n\t\t\tmanif_type = 2;\n\t\telse if (strstr(szDATA, \"#EXTM3U\"))\n\t\t\tmanif_type = 1;\n\t}\n\n\tif (manif_type==1) {\n\t\te = gf_m3u8_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd_base_url ? mpd_base_url : inName, outfile, 0, \"video/mp2t\", GF_TRUE, use_url_template, segment_timeline, NULL, mpd, GF_TRUE, GF_TRUE);\n\t} else if (manif_type==2) {\n\t\te = gf_mpd_smooth_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd, mpd_base_url ? mpd_base_url : inName);\n\t} else {\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\tif (!e)\n\t\tgf_mpd_write_file(mpd, outfile);\n\n\tif (mpd)\n\t\tgf_mpd_del(mpd);\n\tif (mpd_base_url)\n\t\tgf_free(mpd_base_url);\n\n\tif (remote) {\n\t\tgf_file_delete(\"tmp_main.m3u8\");\n\t}\n\tif (e != GF_OK) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error converting %s (%s) to MPD (%s): %s\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile, gf_error_to_string(e)));\n\t\treturn mp4box_cleanup(1);\n\t} else {\n\t\tM4_LOG(GF_LOG_INFO, (\"Done converting %s (%s) to MPD (%s)\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile));\n\t\treturn mp4box_cleanup(0);\n\t}\n}\n#endif\n\nstatic u32 do_import_sub()\n{\n\t/* We import the subtitle file,\n\t   i.e. we parse it and store the content as samples of a 3GPP Timed Text track in an ISO file,\n\t   possibly for later export (e.g. when converting SRT to TTXT, ...) */\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\tGF_Err e;\n\tGF_MediaImporter import;\n\t/* Prepare the importer */\n\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\tif (timescale && file) gf_isom_set_timescale(file, timescale);\n\n\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\timport.dest = file;\n\timport.in_name = inName;\n\t/* Start the import */\n\te = gf_media_import(&import);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\tgf_isom_delete(file);\n\t\tgf_file_delete(\"ttxt_convert\");\n\t\treturn mp4box_cleanup(1);\n\t}\n\t/* Prepare the export */\n\tstrcpy(outfile, inName);\n\tif (strchr(outfile, '.')) {\n\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\toutfile[strlen(outfile)-1] = 0;\n\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\t/* Start the export of the track #1, in the appropriate dump type, indicating it's a conversion */\n\tdump_isom_timed_text(file, gf_isom_get_track_id(file, 1),\n\t\t\t\t\t\t  dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t  GF_TRUE,\n\t\t\t\t\t\t  (import_subtitle==2) ? GF_TEXTDUMPTYPE_SVG : (dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT));\n#endif\n\t/* Clean the importer */\n\tgf_isom_delete(file);\n\tgf_file_delete(\"ttxt_convert\");\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error converting %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\treturn mp4box_cleanup(1);\n\t}\n\treturn mp4box_cleanup(0);\n#else\n\tM4_LOG(GF_LOG_ERROR, (\"Feature not supported\\n\"));\n\treturn mp4box_cleanup(1);\n#endif\n}\n\n#if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)\nstatic u32 do_add_cat(int argc, char **argv)\n{\n\tGF_Err e;\n\tu32 i, ipass, nb_pass = 1;\n\tchar *mux_args=NULL;\n\tGF_FilterSession *fs = NULL;\n\tif (nb_add) {\n\n\t\tGF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT;\n\t\tif (force_new) {\n\t\t\topen_mode = (do_flat || (force_new==2)) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t} else {\n\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\tif (!test) {\n\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\tif (!outName) outName = inName;\n\t\t\t} else {\n\t\t\t\tgf_fclose(test);\n\t\t\t\tif (! gf_isom_probe_file(inName) ) {\n\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\topen_edit = do_flat ? GF_FALSE : GF_TRUE;\n\t\tfile = gf_isom_open(inName, open_mode, NULL);\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\tif (freeze_box_order)\n\t\t\tgf_isom_freeze_order(file);\n\n\t\tif (do_flat) {\n\t\t\tif (major_brand)\n\t\t\t\tgf_isom_set_brand_info(file, major_brand, minor_version);\n\t\t\tfor (i=0; i<nb_alt_brand_add; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!major_brand && !nb_alt_brand_add && has_add_image) {\n\t\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MIF1, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (file && keep_utc && open_edit) {\n\t\tgf_isom_keep_utc_times(file, 1);\n\t}\n\n\tif (do_flat && interleaving_time) {\n\t\tchar szSubArg[100];\n\t\tgf_isom_set_storage_mode(file, GF_ISOM_STORE_FASTSTART);\n\t\tdo_flat = 2;\n\t\tnb_pass = 2;\n\t\tfs = gf_fs_new_defaults(0);\n\t\tif (!fs) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error creating filter session\\n\"));\n\t\t\tgf_isom_delete(file);\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\n\t\t//mux args\n\t\tgf_dynstrcat(&mux_args, \"mp4mx:importer:store=fstart\", \":\");\n\n\t\tsprintf(szSubArg, \"file=%p\", file);\n\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t\tsprintf(szSubArg, \"cdur=%g\", interleaving_time);\n\t\tgf_dynstrcat(&mux_args, szSubArg, \":\");\n\t}\n\n\tfor (ipass=0; ipass<nb_pass; ipass++) {\n\t\tu32 tk_idx = 1;\n\t\tfor (i=0; i<(u32) argc; i++) {\n\t\t\tchar *margs=NULL;\n\t\t\tif (!strcmp(argv[i], \"-add\")) {\n\t\t\t\tchar *src = argv[i+1];\n\n\t\t\t\twhile (src) {\n\t\t\t\t\tchar *loc_src = src;\n\t\t\t\t\tchar *sep = NULL;\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tchar *opt_sep;\n\t\t\t\t\t\tsep = strchr(loc_src, '+');\n\t\t\t\t\t\tif (!sep) break;\n\n\t\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\t\tif (strstr(src, \"://\"))\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\topt_sep = gf_url_colon_suffix(src);\n\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\topt_sep[0] = 0;\n\t\t\t\t\t\tif (gf_file_exists(src)) {\n\t\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\t\topt_sep[0] = ':';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (opt_sep)\n\t\t\t\t\t\t\topt_sep[0] = ':';\n\n\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\tloc_src = sep+1;\n\t\t\t\t\t}\n\n\t\t\t\t\te = import_file(file, src, import_flags, import_fps, agg_samples, fs, (fs && (ipass==0)) ? &margs : NULL, tk_idx);\n\t\t\t\t\ttk_idx++;\n\n\t\t\t\t\tif (margs) {\n\t\t\t\t\t\tgf_dynstrcat(&mux_args, margs, \":\");\n\t\t\t\t\t\tgf_free(margs);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", argv[i+1], gf_error_to_string(e)));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tif (fs)\n\t\t\t\t\t\t\tgf_fs_del(fs);\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = '+';\n\t\t\t\t\t\tsrc = sep+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t} else if (!strcmp(argv[i], \"-cat\") || !strcmp(argv[i], \"-catx\") || !strcmp(argv[i], \"-catpl\")) {\n\t\t\t\tif (nb_pass == 2) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot cat files when using -newfs mode\\n\"));\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t\tif (!file) {\n\t\t\t\t\tu8 open_mode = GF_ISOM_OPEN_EDIT;\n\t\t\t\t\tif (force_new) {\n\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFILE *test = gf_fopen(inName, \"rb\");\n\t\t\t\t\t\tif (!test) {\n\t\t\t\t\t\t\topen_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;\n\t\t\t\t\t\t\tif (!outName) outName = inName;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse gf_fclose(test);\n\t\t\t\t\t}\n\n\t\t\t\t\topen_edit = GF_TRUE;\n\t\t\t\t\tfile = gf_isom_open(inName, open_mode, NULL);\n\t\t\t\t\tif (!file) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\te = cat_isomedia_file(file, argv[i+1], import_flags, import_fps, agg_samples, force_cat, align_cat, !strcmp(argv[i], \"-catx\") ? GF_TRUE : GF_FALSE, !strcmp(argv[i], \"-catpl\") ? GF_TRUE : GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error appending %s: %s\\n\", argv[i+1], gf_error_to_string(e)));\n\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif ((nb_pass == 2) && !ipass) {\n\t\t\tGF_Filter *mux_filter = gf_fs_load_filter(fs, mux_args, NULL);\n\t\t\tgf_free(mux_args);\n\t\t\tif (!mux_filter) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error loadin isobmff mux filter\\n\"));\n\t\t\t\tgf_isom_delete(file);\n\t\t\t\tgf_fs_del(fs);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\n\t\t\te = gf_fs_run(fs);\n\t\t\tif (e==GF_EOS) e = GF_OK;\n\n\t\t\tif (!e) e = gf_fs_get_last_connect_error(fs);\n\t\t\tif (!e) e = gf_fs_get_last_process_error(fs);\n\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing sources: %s\\n\", gf_error_to_string(e)));\n\t\t\t\tgf_isom_delete(file);\n\t\t\t\tgf_fs_del(fs);\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (fs) {\n\t\tgf_fs_print_non_connected(fs);\n\t\tif (fs_dump_flags & 1) gf_fs_print_stats(fs);\n\t\tif (fs_dump_flags & 2) gf_fs_print_connections(fs);\n\t\tgf_fs_del(fs);\n\t}\n\n\t/*unless explicitly asked, remove all systems tracks*/\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tif (!keep_sys_tracks) remove_systems_tracks(file);\n#endif\n\tdo_save = GF_TRUE;\n\n\treturn 0;\n}\n#endif /*!GPAC_DISABLE_MEDIA_IMPORT && !GPAC_DISABLE_ISOM_WRITE*/\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\nstatic GF_Err do_scene_encode()\n{\n\tGF_Err e;\n\tFILE *logs = NULL;\n\tif (do_scene_log) {\n\t\tchar alogfile[GF_MAX_PATH];\n\t\tstrcpy(alogfile, inName);\n\t\tif (strchr(alogfile, '.')) {\n\t\t\twhile (alogfile[strlen(alogfile)-1] != '.') alogfile[strlen(alogfile)-1] = 0;\n\t\t\talogfile[strlen(alogfile)-1] = 0;\n\t\t}\n\t\tstrcat(alogfile, \"_enc.logs\");\n\t\tlogs = gf_fopen(alogfile, \"wt\");\n\t}\n\tstrcpy(outfile, outName ? outName : inName);\n\tif (strchr(outfile, '.')) {\n\t\twhile (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;\n\t\toutfile[strlen(outfile)-1] = 0;\n\t}\n\tstrcat(outfile, \".mp4\");\n\tfile = gf_isom_open(outfile, GF_ISOM_WRITE_EDIT, NULL);\n\tsmenc_opts.mediaSource = mediaSource ? mediaSource : outfile;\n\te = EncodeFile(inName, file, &smenc_opts, logs);\n\tif (logs) gf_fclose(logs);\n\tif (e) return e;\n\tdo_save = GF_TRUE;\n\tif (do_saf) {\n\t\tdo_save = GF_FALSE;\n\t\topen_edit = GF_FALSE;\n\t}\n\treturn GF_OK;\n}\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n\nstatic GF_Err do_dash()\n{\n\tGF_Err e;\n\tu32 i;\n\tBool del_file = GF_FALSE;\n\tchar szMPD[GF_MAX_PATH], *sep;\n\tchar szStateFile[GF_MAX_PATH];\n\tBool dyn_state_file = GF_FALSE;\n\tu32 do_abort = 0;\n\tGF_DASHSegmenter *dasher=NULL;\n\n\tif (crypt) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"MP4Box cannot use -crypt and -dash in the same pass. Please encrypt your content first, or specify encryption filters on dash sources.\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tstrcpy(outfile, outName ? outName : gf_url_get_resource_name(inName) );\n\tsep = strrchr(outfile, '.');\n\tif (sep) sep[0] = 0;\n\tif (!outName) strcat(outfile, \"_dash\");\n\tstrcpy(szMPD, outfile);\n\tif (outName && sep) {\n\t\tsep[0] = '.';\n\t\tstrcat(szMPD, sep);\n\t} else {\n\t\tstrcat(szMPD, \".mpd\");\n\t}\n\n\tif ((dash_subduration>0) && (dash_duration > dash_subduration)) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: -subdur parameter (%g s) should be greater than segment duration (%g s), using segment duration instead\\n\", dash_subduration, dash_duration));\n\t\tdash_subduration = dash_duration;\n\t}\n\n\tif (dash_mode && dash_live)\n\t\tM4_LOG(GF_LOG_INFO, (\"Live DASH-ing - press 'q' to quit, 's' to save context and quit\\n\"));\n\n\tif (!dash_ctx_file && dash_live) {\n\t\tu32 r1;\n\t\tu64 add = (u64) (intptr_t) &dasher;\n\t\tadd ^= gf_net_get_utc();\n\t\tr1 = (u32) add ^ (u32) (add/0xFFFFFFFF);\n\t\tr1 ^= gf_rand();\n\t\tsprintf(szStateFile, \"%s/dasher_%X.xml\", gf_get_default_cache_directory(), r1 );\n\t\tdash_ctx_file = szStateFile;\n\t\tdyn_state_file = GF_TRUE;\n\t} else if (dash_ctx_file) {\n\t\tif (force_new)\n\t\t\tgf_file_delete(dash_ctx_file);\n\t}\n\n\tif (dash_profile==GF_DASH_PROFILE_AUTO)\n\t\tdash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL;\n\n\tif (!dash_mode) {\n\t\ttime_shift_depth = 0;\n\t\tmpd_update_time = 0;\n\t} else if ((dash_profile>=GF_DASH_PROFILE_MAIN) && !use_url_template && !mpd_update_time) {\n\t\t/*use a default MPD update of dash_duration sec*/\n\t\tmpd_update_time = (Double) (dash_subduration ? dash_subduration : dash_duration);\n\t\tM4_LOG(GF_LOG_INFO, (\"Using default MPD refresh of %g seconds\\n\", mpd_update_time));\n\t}\n\n\tif (file && do_save) {\n\t\tgf_isom_close(file);\n\t\tfile = NULL;\n\t\tdel_file = GF_TRUE;\n\t}\n\n\t/*setup dash*/\n\tdasher = gf_dasher_new(szMPD, dash_profile, NULL, dash_scale, dash_ctx_file);\n\tif (!dasher) {\n\t\treturn mp4box_cleanup(1);\n\t}\n\te = gf_dasher_set_info(dasher, dash_title, cprt, dash_more_info, dash_source, NULL);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));\n\t\tgf_dasher_del(dasher);\n\t\treturn e;\n\t}\n\n\tgf_dasher_set_start_date(dasher, dash_start_date);\n\tgf_dasher_set_location(dasher, dash_source);\n\tfor (i=0; i < nb_mpd_base_urls; i++) {\n\t\te = gf_dasher_add_base_url(dasher, mpd_base_urls[i]);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));\n\t\t\tgf_dasher_del(dasher);\n\t\t\treturn e;\n\t\t}\n\t}\n\n\tif (segment_timeline && !use_url_template) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"DASH Warning: using -segment-timeline with no -url-template. Forcing URL template.\\n\"));\n\t\tuse_url_template = GF_TRUE;\n\t}\n\n\te = gf_dasher_enable_url_template(dasher, (Bool) use_url_template, seg_name, seg_ext, init_seg_ext);\n\tif (!e) e = gf_dasher_enable_segment_timeline(dasher, segment_timeline);\n\tif (!e) e = gf_dasher_enable_single_segment(dasher, single_segment);\n\tif (!e) e = gf_dasher_enable_single_file(dasher, single_file);\n\tif (!e) e = gf_dasher_set_switch_mode(dasher, bitstream_switching_mode);\n\tif (!e) e = gf_dasher_set_durations(dasher, dash_duration, interleaving_time, dash_subduration);\n\tif (!e) e = gf_dasher_enable_rap_splitting(dasher, seg_at_rap, frag_at_rap);\n\tif (!e) e = gf_dasher_set_segment_marker(dasher, segment_marker);\n\tif (!e) e = gf_dasher_enable_sidx(dasher, (subsegs_per_sidx>=0) ? 1 : 0, (u32) subsegs_per_sidx, daisy_chain_sidx, use_ssix);\n\tif (!e) e = gf_dasher_set_dynamic_mode(dasher, dash_mode, mpd_update_time, time_shift_depth, mpd_live_duration);\n\tif (!e) e = gf_dasher_set_min_buffer(dasher, min_buffer);\n\tif (!e) e = gf_dasher_set_ast_offset(dasher, ast_offset_ms);\n\tif (!e) e = gf_dasher_enable_memory_fragmenting(dasher, memory_frags);\n\tif (!e) e = gf_dasher_set_initial_isobmf(dasher, initial_moof_sn, initial_tfdt);\n\tif (!e) e = gf_dasher_configure_isobmf_default(dasher, no_fragments_defaults, pssh_mode, samplegroups_in_traf, single_traf_per_moof, tfdt_per_traf, mvex_after_traks, sdtp_in_traf);\n\tif (!e) e = gf_dasher_enable_utc_ref(dasher, insert_utc);\n\tif (!e) e = gf_dasher_enable_real_time(dasher, frag_real_time);\n\tif (!e) e = gf_dasher_set_content_protection_location_mode(dasher, cp_location_mode);\n\tif (!e) e = gf_dasher_set_profile_extension(dasher, dash_profile_extension);\n\tif (!e) e = gf_dasher_enable_cached_inputs(dasher, no_cache);\n\tif (!e) e = gf_dasher_enable_loop_inputs(dasher, ! no_loop);\n\tif (!e) e = gf_dasher_set_split_mode(dasher, dash_split_mode);\n\tif (!e) e = gf_dasher_set_last_segment_merge(dasher, merge_last_seg);\n\tif (!e) e = gf_dasher_set_hls_clock(dasher, hls_clock);\n\tif (!e && dash_cues) e = gf_dasher_set_cues(dasher, dash_cues, strict_cues);\n\tif (!e) e = gf_dasher_print_session_info(dasher, fs_dump_flags);\n\tif (!e)  e = gf_dasher_keep_source_utc(dasher, keep_utc);\n\n\tfor (i=0; i < nb_dash_inputs; i++) {\n\t\tif (!e) e = gf_dasher_add_input(dasher, &dash_inputs[i]);\n\t}\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"DASH Setup Error: %s\\n\", gf_error_to_string(e)));\n\t\tgf_dasher_del(dasher);\n\t\treturn e;\n\t}\n\n\tdash_cumulated_time=0;\n\n\twhile (1) {\n\t\tif (run_for && (dash_cumulated_time >= run_for)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Done running, computing static MPD\\n\"));\n\t\t\tdo_abort = 3;\n\t\t}\n\n\t\tdash_prev_time=gf_sys_clock();\n\t\tif (do_abort>=2) {\n\t\t\te = gf_dasher_set_dynamic_mode(dasher, GF_DASH_DYNAMIC_LAST, 0, time_shift_depth, mpd_live_duration);\n\t\t}\n\n\t\tif (!e) e = gf_dasher_process(dasher);\n\t\tif (!dash_live && (e==GF_EOS) ) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Nothing to dash, too early ...\\n\"));\n\t\t\te = GF_OK;\n\t\t}\n\n\t\tif (do_abort)\n\t\t\tbreak;\n\n\t\t//this happens when reading file while writing them (local playback of the live session ...)\n\t\tif (dash_live && (e==GF_IO_ERR) ) {\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error dashing file (%s) but continuing ...\\n\", gf_error_to_string(e) ));\n\t\t\te = GF_OK;\n\t\t}\n\n\t\tif (e) break;\n\n\t\tif (dash_live) {\n\t\t\tu64 ms_in_session=0;\n\t\t\tu32 slept = gf_sys_clock();\n\t\t\tu32 sleep_for = gf_dasher_next_update_time(dasher, &ms_in_session);\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Next generation scheduled in %u ms (DASH time \"LLU\" ms)\\r\", sleep_for, ms_in_session));\n\t\t\tif (run_for && (ms_in_session>=run_for)) {\n\t\t\t\tdash_cumulated_time = 1+run_for;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twhile (1) {\n\t\t\t\tif (gf_prompt_has_input()) {\n\t\t\t\t\tchar c = (char) gf_prompt_get_char();\n\t\t\t\t\tif (c=='X') {\n\t\t\t\t\t\tdo_abort = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='q') {\n\t\t\t\t\t\tdo_abort = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (c=='s') {\n\t\t\t\t\t\tdo_abort = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dash_mode == GF_DASH_DYNAMIC_DEBUG) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!sleep_for) break;\n\n\t\t\t\tgf_sleep(sleep_for/10);\n\t\t\t\tsleep_for = gf_dasher_next_update_time(dasher, NULL);\n\t\t\t\tif (sleep_for<=1) {\n\t\t\t\t\tdash_now_time=gf_sys_clock();\n\t\t\t\t\tdash_cumulated_time+=(dash_now_time-dash_prev_time);\n\t\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Slept for %d ms before generation, dash cumulated time %d\\n\", dash_now_time - slept, dash_cumulated_time));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgf_dasher_del(dasher);\n\n\tif (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {\n\t\tchar szName[1024];\n\t\tM4_LOG(GF_LOG_INFO, (\"Enter file name to save dash context:\\n\"));\n\t\tif (scanf(\"%1023s\", szName) == 1) {\n\t\t\tgf_file_move(dash_ctx_file, szName);\n\t\t}\n\t}\n\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error DASHing file: %s\\n\", gf_error_to_string(e)));\n\tif (file) gf_isom_delete(file);\n\tif (del_file)\n\t\tgf_file_delete(inName);\n\n\treturn e;\n}\n\n\nstatic GF_Err do_export_tracks_non_isobmf()\n{\n\tu32 i;\n\n\tGF_MediaExporter mdump;\n\tchar szFile[GF_MAX_PATH+24];\n\tfor (i=0; i<nb_track_act; i++) {\n\t\tGF_Err e;\n\t\tTrackAction *tka = &tracks[i];\n\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.in_name = inName;\n\t\tmdump.flags = tka->dump_type;\n\t\tmdump.trackID = tka->trackID;\n\t\tmdump.track_type = tka->dump_track_type;\n\t\tmdump.sample_num = tka->sample_num;\n\n\t\tif (dump_std) {\n\t\t\tmdump.out_name = \"std\";\n\t\t}\n\t\telse if (outName) {\n\t\t\tmdump.out_name = outName;\n\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t} else if (nb_track_act>1) {\n\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\tmdump.out_name = szFile;\n\t\t} else {\n\t\t\tmdump.out_name = outfile;\n\t\t}\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\nstatic GF_Err do_dump_iod()\n{\n\tGF_Err e = GF_OK;\n\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\tif (!iod) {\n\t\tM4_LOG(GF_LOG_WARNING, (\"File %s has no IOD\\n\", inName));\n\t} else {\n\t\tchar szName[GF_MAX_PATH+10];\n\t\tFILE *iodf;\n\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\tiodf = gf_fopen(szName, \"wb\");\n\t\tif (!iodf) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open destination %s\\n\", szName));\n\t\t\te = GF_IO_ERR;\n\t\t} else {\n\t\t\tu8 *desc;\n\t\t\tu32 size;\n\t\t\tGF_BitStream *bs = gf_bs_from_file(iodf, GF_BITSTREAM_WRITE);\n\t\t\tif (gf_odf_desc_write((GF_Descriptor *)iod, &desc, &size)==GF_OK) {\n\t\t\t\tgf_fwrite(desc, size, iodf);\n\t\t\t\tgf_free(desc);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error writing IOD %s\\n\", szName));\n\t\t\t\te = GF_IO_ERR;\n\t\t\t}\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_fclose(iodf);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor*)iod);\n\t}\n\treturn e;\n}\n\nstatic GF_Err do_export_tracks()\n{\n\tGF_Err e;\n\tu32 i;\n\tchar szFile[GF_MAX_PATH+24];\n\tGF_MediaExporter mdump;\n\tfor (i=0; i<nb_track_act; i++) {\n\t\tu32 j;\n\t\tTrackAction *tka = &tracks[i];\n\t\tif (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.file = file;\n\t\tmdump.flags = tka->dump_type;\n\t\tmdump.trackID = tka->trackID;\n\t\tmdump.sample_num = tka->sample_num;\n\t\tif (tka->out_name) {\n\t\t\tmdump.out_name = tka->out_name;\n\t\t} else if (outName) {\n\t\t\tmdump.out_name = outName;\n\t\t\tmdump.flags |= GF_EXPORT_MERGE;\n\t\t\t/*don't infer extension on user-given filename*/\n\t\t\tmdump.flags |= GF_EXPORT_NO_FILE_EXT;\n\t\t} else if (mdump.trackID) {\n\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\tmdump.out_name = szFile;\n\t\t} else {\n\t\t\tsprintf(szFile, \"%s_export\", outfile);\n\t\t\tmdump.out_name = szFile;\n\t\t}\n\t\tif (tka->trackID==(u32) -1) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\tmdump.trackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\tsprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);\n\t\t\t\tmdump.out_name = szFile;\n\t\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\t\te = gf_media_export(&mdump);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t} else {\n\t\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\t\te = gf_media_export(&mdump);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_meta_act()\n{\n\tu32 i;\n\tfor (i=0; i<nb_meta_act; i++) {\n\t\tGF_Err e = GF_OK;\n\t\tu32 tk = 0;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tBool self_ref;\n#endif\n\t\tMetaAction *meta = &metas[i];\n\n\t\tif (meta->trackID) tk = gf_isom_get_track_by_id(file, meta->trackID);\n\n\t\tswitch (meta->act_type) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tcase META_ACTION_SET_TYPE:\n\t\t\t/*note: we don't handle file brand modification, this is an author stuff and cannot be guessed from meta type*/\n\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);\n\t\t\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_ITEM:\n\t\t\tself_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");\n\t\t\te = gf_isom_add_meta_item(file, meta->root_meta, tk, self_ref, self_ref ? NULL : meta->szPath,\n\t\t\t                          meta->szName,\n\t\t\t                          meta->item_id,\n\t\t\t\t\t\t\t\t\t  meta->item_type,\n\t\t\t                          meta->mime_type,\n\t\t\t                          meta->enc_type,\n\t\t\t                          meta->use_dref ? meta->szPath : NULL,  NULL,\n\t\t\t                          meta->image_props);\n\t\t\tif (meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\tu32 ref_i;\n\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_IMAGE_ITEM:\n\t\t{\n\t\t\tu32 old_tk_count = gf_isom_get_track_count(file);\n\t\t\tu32 src_tk_id = 1;\n\t\t\tGF_Fraction _frac = {0,0};\n\t\t\tGF_ISOFile *fsrc = file;\n\t\t\tself_ref = GF_FALSE;\n\n\t\t\ttk = 0;\n\t\t\tif (meta->image_props && meta->image_props->auto_grid) {\n\t\t\t\te = GF_OK;\n\t\t\t\tself_ref = GF_TRUE;\n\t\t\t} else if (!meta->szPath || (meta->image_props && meta->image_props->sample_num && meta->image_props->use_reference)) {\n\t\t\t\te = GF_OK;\n\t\t\t\tself_ref = GF_TRUE;\n\t\t\t\tsrc_tk_id = meta->trackID;\n\t\t\t} else if (meta->szPath) {\n\t\t\t\tif (meta->image_props && gf_isom_probe_file(meta->szPath) && !meta->image_props->tile_mode) {\n\t\t\t\t\tmeta->image_props->src_file = gf_isom_open(meta->szPath, GF_ISOM_OPEN_READ, NULL);\n\t\t\t\t\te = gf_isom_last_error(meta->image_props->src_file);\n\t\t\t\t\tfsrc = meta->image_props->src_file;\n\t\t\t\t} else {\n\t\t\t\t\te = import_file(file, meta->szPath, 0, _frac, 0, NULL, NULL, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing file name to import\\n\"));\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t\tif (e == GF_OK) {\n\t\t\t\tu32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);\n\t\t\t\tif (!meta_type) {\n\t\t\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);\n\t\t\t\t} else {\n\t\t\t\t\tif (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\tif (!meta->item_id) {\n\t\t\t\t\t\te = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);\n\t\t\t\t\t}\n\t\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\t\tif (!src_tk_id) {\n\t\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\t\tfor (j=0; j<gf_isom_get_track_count(fsrc); j++) {\n\t\t\t\t\t\t\t\tif (gf_isom_is_video_handler_type (gf_isom_get_media_type(fsrc, j+1))) {\n\t\t\t\t\t\t\t\t\tsrc_tk_id = gf_isom_get_track_id(fsrc, j+1);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!src_tk_id) {\n\t\t\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"No video track in file, cannot add image from track\\n\"));\n\t\t\t\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te = gf_isom_iff_create_image_item_from_track(file, meta->root_meta, tk, src_tk_id, meta->szName, meta->item_id, meta->image_props, NULL);\n\t\t\t\t\t\tif (e == GF_OK && meta->primary) {\n\t\t\t\t\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\t\t\t\tu32 ref_i;\n\t\t\t\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e == GF_OK && meta->group_type) {\n\t\t\t\t\t\t\te = gf_isom_meta_add_item_group(file, meta->root_meta, tk, meta->item_id, meta->group_id, meta->group_type);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (meta->image_props && meta->image_props->src_file) {\n\t\t\t\tgf_isom_delete(meta->image_props->src_file);\n\t\t\t\tmeta->image_props->src_file = NULL;\n\t\t\t} else if (!self_ref) {\n\t\t\t\tgf_isom_remove_track(file, old_tk_count+1);\n\t\t\t\tif (do_flat) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Warning: -flat storage cannot be used when using -add-image on external file\\n\"));\n\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_ADD_IMAGE_GRID:\n\t\t{\n\t\t\tu32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);\n\t\t\te = GF_OK;\n\t\t\tif (!meta_type) {\n\t\t\t\te = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);\n\t\t\t} else {\n\t\t\t\tif (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e == GF_OK) {\n\t\t\t\tif (!meta->item_id) {\n\t\t\t\t\te = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);\n\t\t\t\t}\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\te = gf_isom_iff_create_image_grid_item(file, meta->root_meta, tk,\n\t\t\t\t\t\t\tmeta->szName && strlen(meta->szName) ? meta->szName : NULL,\n\t\t\t\t\t\t\tmeta->item_id,\n\t\t\t\t\t\t\tmeta->image_props);\n\t\t\t\t\tif (e == GF_OK && meta->primary) {\n\t\t\t\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\t\t\t}\n\t\t\t\t\tif (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {\n\t\t\t\t\t\tu32 ref_i;\n\t\t\t\t\t\tfor (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {\n\t\t\t\t\t\t\tMetaRef\t*ref_entry = gf_list_get(meta->item_refs, ref_i);\n\t\t\t\t\t\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_ITEM:\n\t\t\te = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_PRIMARY_ITEM:\n\t\t\te = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_SET_XML:\n\t\tcase META_ACTION_SET_BINARY_XML:\n\t\t\te = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase META_ACTION_REM_XML:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_remove_meta_xml(file, meta->root_meta, tk);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase META_ACTION_DUMP_ITEM:\n\t\t\tif (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_item(file, meta->root_meta, tk, meta->item_id, meta->szPath && strlen(meta->szPath) ? meta->szPath : NULL);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n\t\tcase META_ACTION_DUMP_XML:\n\t\t\tif (gf_isom_has_meta_xml(file, meta->root_meta, tk)) {\n\t\t\t\te = gf_isom_extract_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));\n\t\t\t\te = GF_OK;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (meta->item_refs) {\n\t\t\twhile (gf_list_count(meta->item_refs)) {\n\t\t\t\tgf_free(gf_list_pop_back(meta->item_refs));\n\t\t\t}\n\t\t\tgf_list_del(meta->item_refs);\n\t\t\tmeta->item_refs = NULL;\n\t\t}\n\t\tif (meta->image_props) {\n\t\t\tgf_free(meta->image_props);\n\t\t\tmeta->image_props = NULL;\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_tsel_act()\n{\n\tu32 i;\n\tGF_Err e;\n\tfor (i=0; i<nb_tsel_acts; i++) {\n\t\tswitch (tsel_acts[i].act_type) {\n\t\tcase TSEL_ACTION_SET_PARAM:\n\t\t\te = gf_isom_set_track_switch_parameter(file,\n\t\t\t                                       gf_isom_get_track_by_id(file, tsel_acts[i].trackID),\n\t\t\t                                       tsel_acts[i].refTrackID ? gf_isom_get_track_by_id(file, tsel_acts[i].refTrackID) : 0,\n\t\t\t                                       tsel_acts[i].is_switchGroup ? 1 : 0,\n\t\t\t                                       &tsel_acts[i].switchGroupID,\n\t\t\t                                       tsel_acts[i].criteria, tsel_acts[i].nb_criteria);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tu32 alternateGroupID, nb_groups;\n\t\t\t\tgf_isom_get_track_switch_group_count(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), &alternateGroupID, &nb_groups);\n\t\t\t\tif (alternateGroupID) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - for adding more tracks to group, using: -group-add -refTrack=ID1:[criteria:]trackID=ID2\\n\"));\n\t\t\t\t} else {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error - for creating a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_TSEL:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:\n\t\t\te = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);\n\t\t\tif (e) return e;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic void do_ipod_conv()\n{\n\tu32 i, ipod_major_brand = 0;\n\tM4_LOG(GF_LOG_INFO, (\"Setting up iTunes/iPod file\\n\"));\n\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tu32 mType = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\tipod_major_brand = GF_ISOM_BRAND_M4V;\n\t\t\tgf_isom_set_ipod_compatible(file, i+1);\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tif (!ipod_major_brand) ipod_major_brand = GF_ISOM_BRAND_M4A;\n\t\t\telse gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_M4A, GF_TRUE);\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\t/*this is a text track track*/\n\t\t\tif (gf_isom_get_media_subtype(file, i+1, 1) == GF_ISOM_SUBTYPE_TX3G) {\n\t\t\t\tBool is_chap = 0;\n\t\t\t\tu32 j;\n\t\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\t\ts32 count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_CHAP);\n\t\t\t\t\tif (count>0) {\n\t\t\t\t\t\tu32 tk, k;\n\t\t\t\t\t\tfor (k=0; k<(u32) count; k++) {\n\t\t\t\t\t\t\tgf_isom_get_reference(file, j+1, GF_ISOM_REF_CHAP, k+1, &tk);\n\t\t\t\t\t\t\tif (tk==i+1) {\n\t\t\t\t\t\t\t\tis_chap = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (is_chap) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (is_chap) break;\n\t\t\t\t}\n\t\t\t\t/*this is a subtitle track*/\n\t\t\t\tif (!is_chap)\n\t\t\t\t\tgf_isom_set_media_type(file, i+1, GF_ISOM_MEDIA_SUBT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgf_isom_set_brand_info(file, ipod_major_brand, 1);\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);\n\tdo_save = GF_TRUE;\n}\n\nstatic GF_Err do_track_act()\n{\n\tu32 j;\n\tfor (j=0; j<nb_track_act; j++) {\n\t\tu32 i;\n\t\tGF_Err e = GF_OK;\n\t\tTrackAction *tka = &tracks[j];\n\t\tu32 track = tka->trackID ? gf_isom_get_track_by_id(file, tka->trackID) : 0;\n\n\t\ttimescale = gf_isom_get_timescale(file);\n\t\tswitch (tka->act_type) {\n\t\tcase TRAC_ACTION_REM_TRACK:\n\t\t\te = gf_isom_remove_track(file, track);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e)));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Removing track ID %d\\n\", tka->trackID));\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_LANGUAGE:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_set_media_language(file, i+1, tka->lang);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_KIND:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_DELAY:\n\t\t\tif (tka->delay.num && tka->delay.den) {\n\t\t\t\tu64 tk_dur;\n\n\t\t\t\te = gf_isom_remove_edits(file, track);\n\t\t\t\tif (e) return e;\n\t\t\t\ttk_dur = gf_isom_get_track_duration(file, track);\n\t\t\t\tif (gf_isom_get_edits_count(file, track))\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\tif (tka->delay.num>0) {\n\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\te = gf_isom_append_edit(file, track, ((u64) tka->delay.num) * timescale / tka->delay.den, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\tu64 to_skip = ((u64) -tka->delay.num) * timescale / tka->delay.den;\n\t\t\t\t\tif (to_skip<tk_dur) {\n\t\t\t\t\t\t//cast to u64, delay_ms * timescale can be quite big before / 1000\n\t\t\t\t\t\tu64 media_time = ((u64) -tka->delay.num) * gf_isom_get_media_timescale(file, track) / tka->delay.den;\n\t\t\t\t\t\te = gf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (gf_isom_get_edits_count(file, track)) {\n\t\t\t\te = gf_isom_remove_edits(file, track);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_KMS_URI:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\tif (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;\n\t\t\t\tif (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;\n\t\t\t\te = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);\n\t\t\t\tif (e) return e;\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_ID:\n\t\t\tif (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\"));\n\t\t\t\ttrack = 1;\n\t\t\t}\n\t\t\tif (track) {\n\t\t\t\tu32 newTrack;\n\t\t\t\tnewTrack = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (newTrack != 0) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, track, tka->newTrackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SWAP_ID:\n\t\t\tif (track) {\n\t\t\t\tu32 tk1, tk2;\n\t\t\t\ttk1 = gf_isom_get_track_by_id(file, tka->trackID);\n\t\t\t\ttk2 = gf_isom_get_track_by_id(file, tka->newTrackID);\n\t\t\t\tif (!tk1 || !tk2) {\n\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot swap track IDs because not existing - ignoring\"));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_set_track_id(file, tk2, 0);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_set_track_id(file, tk1, tka->newTrackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\te = gf_isom_set_track_id(file, tk2, tka->trackID);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tdo_save = GF_TRUE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_PAR:\n\t\t\te = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_CLAP:\n\t\t\te = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_MX:\n\t\t\te = gf_isom_set_track_matrix(file, track, tka->mx);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_HANDLER_NAME:\n\t\t\te = gf_isom_set_handler_name(file, track, tka->hdl_name);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_ENABLE:\n\t\t\tif (!gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_TRUE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_DISABLE:\n\t\t\tif (gf_isom_is_track_enabled(file, track)) {\n\t\t\t\te = gf_isom_set_track_enabled(file, track, GF_FALSE);\n\t\t\t\tdo_save = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REFERENCE:\n\t\t\te = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_RAP:\n\t\t\te = gf_media_remove_non_rap(file, track, GF_FALSE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_REM_NON_REFS:\n\t\t\te = gf_media_remove_non_rap(file, track, GF_TRUE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_UDTA:\n\t\t\te = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_EDITS:\n\t\t\te = apply_edits(file, track, tka->string);\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_TIME:\n\t\t\tif (!tka->trackID) {\n\t\t\t\te = gf_isom_set_creation_time(file, tka->time, tka->time);\n\t\t\t\tif (e) return e;\n\t\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\t\te = gf_isom_set_track_creation_time(file, i+1, tka->time, tka->time);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_track_creation_time(file, track, tka->time, tka->time);\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tcase TRAC_ACTION_SET_MEDIA_TIME:\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tif (track && (track != i+1)) continue;\n\t\t\t\te = gf_isom_set_media_creation_time(file, i+1, tka->time, tka->time);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\tdo_save = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err do_itunes_tag()\n{\n\tGF_Err e;\n\tchar *itunes_data = NULL;\n\tchar *tags = itunes_tags;\n\n\tif (gf_file_exists(itunes_tags)) {\n\t\tu32 len;\n\t\te = gf_file_load_data(itunes_tags, (u8 **) &itunes_data, &len);\n\t\tif (e) return e;;\n\t\ttags = itunes_data;\n\t}\n\n\twhile (tags) {\n\t\tchar *val;\n\t\tBool clear = GF_FALSE;\n\t\tBool is_wma = GF_FALSE;\n\t\tu32 tlen, tagtype=0, itag = 0;\n\t\ts32 tag_idx;\n\t\tchar *sep = itunes_data ? strchr(tags, '\\n') : gf_url_colon_suffix(tags);\n\t\twhile (sep) {\n\t\t\tchar *eq = strchr(sep+1, '=');\n\t\t\tif (eq) eq[0] = 0;\n\t\t\ts32 next_tag_idx = gf_itags_find_by_name(sep+1);\n\t\t\tif ((next_tag_idx<0) && strlen(sep+1)==4)\n\t\t\t\tnext_tag_idx = 0;\n\n\t\t\tif (eq) eq[0] = '=';\n\t\t\tif (next_tag_idx>=0) {\n\t\t\t\tsep[0] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsep = itunes_data ? strchr(sep+1, '\\n') : gf_url_colon_suffix(sep+1);\n\t\t}\n\t\tval = strchr(tags, '=');\n\t\tif (val) val[0] = 0;\n\t\tif (!strcmp(tags, \"clear\") || !strcmp(tags, \"reset\")) {\n\t\t\tclear = GF_TRUE;\n\t\t} else if (!strncmp(tags, \"WM/\", 3) ) {\n\t\t\tis_wma = GF_TRUE;\n\t\t} else {\n\t\t\ttag_idx = gf_itags_find_by_name(tags);\n\t\t\tif (tag_idx<0) {\n\t\t\t\tif (strlen(tags)==4) {\n\t\t\t\t\titag = GF_4CC(tags[0], tags[1], tags[2], tags[3]);\n\t\t\t\t\ttagtype = GF_ITAG_STR;\n\t\t\t\t} else if (strlen(tags)==3) {\n\t\t\t\t\titag = GF_4CC(0xA9, tags[0], tags[1], tags[2]);\n\t\t\t\t\ttagtype = GF_ITAG_STR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (val) {\n\t\t\tval[0] = '=';\n\t\t\tval++;\n\t\t}\n\t\tif (!itag && !clear && !is_wma) {\n\t\t\tif (tag_idx<0) {\n\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Invalid iTune tag name \\\"%s\\\" - ignoring\\n\", tags));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t\ttagtype = gf_itags_get_type(tag_idx);\n\t\t}\n\t\tif (!val || (val[0]==':') || !val[0] || !stricmp(val, \"NULL\") ) val = NULL;\n\n\t\ttlen = val ? (u32) strlen(val) : 0;\n\t\tif (clear) {\n\t\t\te = gf_isom_apple_set_tag(file, GF_ISOM_ITUNE_RESET, NULL, 0, 0, 0);\n\t\t}\n\t\telse if (is_wma) {\n\t\t\tif (val) val[-1] = 0;\n\t\t\te = gf_isom_wma_set_tag(file, tags, val);\n\t\t\tif (val) val[-1] = '=';\n\t\t}\n\t\telse if (val && (tagtype==GF_ITAG_FILE)) {\n\t\t\tu32 flen = (u32) strlen(val);\n\t\t\tu8 *d=NULL;\n\t\t\twhile (flen && val[flen-1]=='\\n') flen--;\n\t\t\tval[flen] = 0;\n\t\t\te = gf_file_load_data(val, (u8 **) &d, &tlen);\n\t\t\tval[flen] = '\\n';\n\n\t\t\tif (!e)\n\t\t\t\te = gf_isom_apple_set_tag(file, itag, d, tlen, 0, 0);\n\n\t\t\tif (d) gf_free(d);\n\t\t} else {\n\t\t\te = gf_isom_apple_set_tag(file, itag, (u8 *) val, tlen, 0, 0);\n\t\t}\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error assigning tag %s: %s\\n\", tags, gf_error_to_string(e) ));\n\t\t}\n\n\t\tdo_save = GF_TRUE;\n\n\t\tif (sep) {\n\t\t\tsep[0] = itunes_data ? '\\n' : ':';\n\t\t\ttags = sep+1;\n\t\t} else {\n\t\t\ttags = NULL;\n\t\t}\n\t}\n\tif (itunes_data) gf_free(itunes_data);\n\treturn GF_OK;\n}\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)\nstatic void set_sdp_ext()\n{\n\tu32 i, j;\n\tfor (i=0; i<nb_sdp_ex; i++) {\n\t\tif (sdp_lines[i].trackID) {\n\t\t\tu32 track = gf_isom_get_track_by_id(file, sdp_lines[i].trackID);\n\t\t\tif (gf_isom_get_media_type(file, track)!=GF_ISOM_MEDIA_HINT) {\n\t\t\t\ts32 ref_count;\n\t\t\t\tu32 k, count = gf_isom_get_track_count(file);\n\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\tif (gf_isom_get_media_type(file, j+1)!=GF_ISOM_MEDIA_HINT) continue;\n\t\t\t\t\tref_count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_HINT);\n\t\t\t\t\tif (ref_count<0) continue;\n\t\t\t\t\tfor (k=0; k<(u32) ref_count; k++) {\n\t\t\t\t\t\tu32 refTk;\n\t\t\t\t\t\tif (gf_isom_get_reference(file, j+1, GF_ISOM_REF_HINT, k+1, &refTk)) continue;\n\t\t\t\t\t\tif (refTk==track) {\n\t\t\t\t\t\t\ttrack = j+1;\n\t\t\t\t\t\t\tj=count;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);\n\t\t\tdo_save = GF_TRUE;\n\t\t} else {\n\t\t\tgf_isom_sdp_add_line(file, sdp_lines[i].line);\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t}\n}\n#endif /*!defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)*/\n\nstatic GF_Err do_remux_file()\n{\n\tGF_MediaExporter mdump;\n\tmemset(&mdump, 0, sizeof(GF_MediaExporter));\n\tmdump.in_name = inName;\n\tmdump.out_name = mux_name;\n\tmdump.flags = GF_EXPORT_REMUX;\n\tmdump.print_stats_graph = fs_dump_flags;\n\treturn gf_media_export(&mdump);\n}\n\nstatic u32 mp4box_cleanup(u32 ret_code) {\n\tif (mpd_base_urls) {\n\t\tgf_free(mpd_base_urls);\n\t\tmpd_base_urls = NULL;\n\t}\n\tif (sdp_lines) {\n\t\tgf_free(sdp_lines);\n\t\tsdp_lines = NULL;\n\t}\n\tif (metas) {\n\t\tu32 i;\n\t\tfor (i=0; i<nb_meta_act; i++) {\n\t\t\tif (metas[i].enc_type) gf_free(metas[i].enc_type);\n\t\t\tif (metas[i].mime_type) gf_free(metas[i].mime_type);\n\t\t\tif (metas[i].szName) gf_free(metas[i].szName);\n\t\t\tif (metas[i].szPath) gf_free(metas[i].szPath);\n\t\t}\n\t\tgf_free(metas);\n\t\tmetas = NULL;\n\t}\n\tif (tracks) {\n\t\tu32 i;\n\t\tfor (i = 0; i<nb_track_act; i++) {\n\t\t\tif (tracks[i].out_name)\n\t\t\t\tgf_free(tracks[i].out_name);\n\t\t\tif (tracks[i].src_name)\n\t\t\t\tgf_free(tracks[i].src_name);\n\t\t\tif (tracks[i].string)\n\t\t\t\tgf_free(tracks[i].string);\n\t\t\tif (tracks[i].kind_scheme)\n\t\t\t\tgf_free(tracks[i].kind_scheme);\n\t\t\tif (tracks[i].kind_value)\n\t\t\t\tgf_free(tracks[i].kind_value);\n\t\t}\n\t\tgf_free(tracks);\n\t\ttracks = NULL;\n\t}\n\tif (tsel_acts) {\n\t\tgf_free(tsel_acts);\n\t\ttsel_acts = NULL;\n\t}\n\tif (brand_add) {\n\t\tgf_free(brand_add);\n\t\tbrand_add = NULL;\n\t}\n\tif (brand_rem) {\n\t\tgf_free(brand_rem);\n\t\tbrand_rem = NULL;\n\t}\n\tif (dash_inputs) {\n\t\tu32 i, j;\n\t\tfor (i = 0; i<nb_dash_inputs; i++) {\n\t\t\tGF_DashSegmenterInput *di = &dash_inputs[i];\n\t\t\tif (di->nb_baseURL) {\n\t\t\t\tfor (j = 0; j<di->nb_baseURL; j++) {\n\t\t\t\t\tgf_free(di->baseURL[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->baseURL);\n\t\t\t}\n\t\t\tif (di->rep_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_rep_descs; j++) {\n\t\t\t\t\tgf_free(di->rep_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->rep_descs);\n\t\t\t}\n\t\t\tif (di->as_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_as_descs; j++) {\n\t\t\t\t\tgf_free(di->as_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->as_descs);\n\t\t\t}\n\t\t\tif (di->as_c_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_as_c_descs; j++) {\n\t\t\t\t\tgf_free(di->as_c_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->as_c_descs);\n\t\t\t}\n\t\t\tif (di->p_descs) {\n\t\t\t\tfor (j = 0; j<di->nb_p_descs; j++) {\n\t\t\t\t\tgf_free(di->p_descs[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->p_descs);\n\t\t\t}\n\t\t\tif (di->representationID) gf_free(di->representationID);\n\t\t\tif (di->periodID) gf_free(di->periodID);\n\t\t\tif (di->xlink) gf_free(di->xlink);\n\t\t\tif (di->seg_template) gf_free(di->seg_template);\n\t\t\tif (di->hls_pl) gf_free(di->hls_pl);\n\t\t\tif (di->source_opts) gf_free(di->source_opts);\n\t\t\tif (di->filter_chain) gf_free(di->filter_chain);\n\n\t\t\tif (di->roles) {\n\t\t\t\tfor (j = 0; j<di->nb_roles; j++) {\n\t\t\t\t\tgf_free(di->roles[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(di->roles);\n\t\t\t}\n\t\t}\n\t\tgf_free(dash_inputs);\n\t\tdash_inputs = NULL;\n\t}\n\tif (logfile) gf_fclose(logfile);\n\tgf_sys_close();\n\treturn ret_code;\n}\n\n\n\nint mp4boxMain(int argc, char **argv)\n{\n\tu32 i, j;\n\tconst char *gpac_profile = \"0\";\n\tGF_Err e = GF_OK;\n\n#ifdef TEST_ARGS\n\ti=0;\n\tmp4box_parse_single_arg(argc, argv, \"\", &i);\n#endif\n\n\tfor (i = 1; i < (u32) argc ; i++) {\n\t\tif (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {\n#ifdef GPAC_MEMORY_TRACKING\n            mem_track = !strcmp(argv[i], \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;\n#else\n\t\t\tM4_LOG(GF_LOG_WARNING, (\"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", argv[i]));\n#endif\n\t\t\tbreak;\n\t\t}\n\t\telse if (!strcmp(argv[i], \"-p\")) {\n\t\t\tif (i+1<(u32) argc)\n\t\t\t\tgpac_profile = argv[i+1];\n\t\t\telse {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Bad argument for -p, expecting profile name but no more args\\n\"));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(argv[i], \"-p=\", 3))\n\t\t\tgpac_profile = argv[i]+3;\n\t}\n\n#ifdef _TWO_DIGIT_EXPONENT\n\t_set_output_format(_TWO_DIGIT_EXPONENT);\n#endif\n\n\t/*init libgpac*/\n\tgf_sys_init(mem_track, gpac_profile);\n\tif (argc < 2) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Not enough arguments - check usage with -h\\n\"));\n\t\tM4_LOG(GF_LOG_INFO, (\"MP4Box - GPAC version %s\\n\"\n\t        \"%s\\n\", gf_gpac_version(), gf_gpac_copyright_cite() ));\n\t\tgf_sys_close();\n\t\treturn 0;\n\t}\n\n\thelpout = stdout;\n\n\ti = mp4box_parse_args(argc, argv);\n\tif (i) {\n\t\treturn mp4box_cleanup(i - 1);\n\t}\n#if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)\n\tif (live_scene) {\n\t\tint ret = live_session(argc, argv);\n\t\treturn mp4box_cleanup(ret);\n\t}\n#endif\n\n\tif (!dash_duration && interleaving_time && do_frag)\n\t\tinterleaving_time /= 1000;\n\n\tif (do_mpd_conv) inName = do_mpd_conv;\n\n\tif (import_flags & GF_IMPORT_FORCE_MPEG4)\n\t\thint_flags |= GP_RTP_PCK_FORCE_MPEG4;\n\n\tif (!inName && dump_std)\n\t\tinName = \"std\";\n\n\tif (!dash_duration && cprt)\n\t\topen_edit = GF_TRUE;\n\n\tif (!inName) {\n\t\tif (has_next_arg) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Broken argument specifier or file name missing - check usage with -h\\n\"));\n\t\t} else {\n\t\t\tPrintUsage();\n\t\t}\n\t\treturn mp4box_cleanup(1);\n\t}\n\tif (!strcmp(inName, \"std\")) dump_std = 2;\n\tif (!strcmp(inName, \"stdb\")) {\n\t\tinName = \"std\";\n\t\tdump_std = 1;\n\t}\n\n\tif (!interleaving_time) {\n\t\t/*by default use single fragment per dash segment*/\n\t\tif (dash_duration)\n\t\t\tinterleaving_time = dash_duration;\n\t\telse if (!do_flat) {\n\t\t\tinterleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\t}\n\t}\n\n\tif (dump_std)\n\t\toutName = \"std\";\n\n\tif (dump_std==2) {\n#ifdef WIN32\n\t\tif ( _setmode(_fileno(stdout), _O_BINARY) == -1 )\n#else\n\t\tif ( freopen(NULL, \"wb\", stdout) == NULL)\n#endif\n\t\t{\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Fatal error: cannot reopen stdout in binary mode.\\n\"));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t}\n\n\tGF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;\n\tgf_log_set_tool_level(GF_LOG_CONTAINER, level);\n\tgf_log_set_tool_level(GF_LOG_SCENE, level);\n\tgf_log_set_tool_level(GF_LOG_PARSER, level);\n\tgf_log_set_tool_level(GF_LOG_AUTHOR, level);\n\tgf_log_set_tool_level(GF_LOG_CODING, level);\n\tgf_log_set_tool_level(GF_LOG_DASH, level);\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track)\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, level);\n#endif\n\n\te = gf_sys_set_args(argc, (const char **) argv);\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error assigning libgpac arguments: %s\\n\", gf_error_to_string(e) ));\n\t\treturn mp4box_cleanup(1);\n\t}\n\n\tif (raw_cat)\n\t\treturn do_raw_cat();\n\n\tif (compress_top_boxes) {\n\t\tif (size_top_box) {\n\t\t\tu64 top_size = do_size_top_boxes(inName, compress_top_boxes, size_top_box);\n\t\t\tfprintf(stdout, LLU\"\\n\", top_size);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t} else {\n\t\t\te = do_compress_top_boxes(inName, outName);\n\t\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t\t}\n\t}\n\n\tif (do_mpd_rip) {\n\t\te = rip_mpd(inName, outName);\n\t\treturn mp4box_cleanup(e ? 1 : 0);\n\t}\n\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_wget != NULL) {\n\t\te = gf_dm_wget(do_wget, inName, 0, 0, NULL);\n\t\tif (e != GF_OK) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot retrieve %s: %s\\n\", do_wget, gf_error_to_string(e) ));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\treturn mp4box_cleanup(0);\n\t}\n#endif\n\n\tif (udp_dest)\n\t\treturn do_write_udp();\n\n#ifndef GPAC_DISABLE_MPD\n\tif (do_mpd_conv)\n\t\treturn convert_mpd();\n#endif\n\n\tif (dash_duration && !nb_dash_inputs) {\n\t\tdash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);\n\t}\n\n\tif (do_saf && !encode) {\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase GF_FILE_TYPE_BT_WRL_X3DV:\n\t\tcase GF_FILE_TYPE_XMT_X3D:\n\t\tcase GF_FILE_TYPE_SVG:\n\t\t\tencode = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_FILE_TYPE_NOT_SUPPORTED:\n\t\tcase GF_FILE_TYPE_ISO_MEDIA:\n\t\tcase GF_FILE_TYPE_SWF:\n\t\tcase GF_FILE_TYPE_LSR_SAF:\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode == GF_SM_DUMP_SVG) {\n\t\tif (strstr(inName, \".srt\") || strstr(inName, \".ttxt\")) import_subtitle = 2;\n\t}\n#endif\n\n\tif (import_subtitle && !trackID)\n\t\treturn do_import_sub();\n\n\n#if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\tif (nb_add || nb_cat) {\n\t\tu32 res = do_add_cat(argc, argv);\n\t\tif (res) return res;\n\t}\n#endif /*!GPAC_DISABLE_MEDIA_IMPORT && !GPAC_DISABLE_ISOM_WRITE*/\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\telse if (chunk_mode) {\n\t\tif (!inName) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"chunk encoding syntax: [-outctx outDump] -inctx inScene auFile\\n\"));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\te = EncodeFileChunk(inName, outName ? outName : inName, input_ctx, output_ctx);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error encoding chunk file %s\\n\", gf_error_to_string(e)));\n\t\t\treturn mp4box_cleanup(1);\n\t\t}\n\t\tgoto exit;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n\telse if (encode) {\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t\te = do_scene_encode();\n\t\tif (e) goto err_exit;\n#endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\telse if (pack_file) {\n\t\tchar *fileName = gf_url_colon_suffix(pack_file);\n\t\tif (fileName && ((fileName - pack_file)==4)) {\n\t\t\tfileName[0] = 0;\n\t\t\tfile = package_file(fileName + 1, pack_file, pack_wgt);\n\t\t\tfileName[0] = ':';\n\t\t} else {\n\t\t\tfile = package_file(pack_file, NULL, pack_wgt);\n\t\t\tif (!file) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to package file\\n\"));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t\tif (!outName) outName = inName;\n\t\tdo_save = GF_TRUE;\n\t\topen_edit = GF_TRUE;\n\t}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\tif (dash_duration) {\n\t\te = do_dash();\n\t\tif (e) return mp4box_cleanup(1);\n\t\tgoto exit;\n\t}\n\n\t//need to open input\n\tif (!file && !do_hash) {\n\t\tFILE *st = gf_fopen(inName, \"rb\");\n\t\tBool file_exists = 0;\n\t\tGF_ISOOpenMode omode;\n\t\tif (st) {\n\t\t\tfile_exists = 1;\n\t\t\tgf_fclose(st);\n\t\t}\n\t\tswitch (get_file_type_by_ext(inName)) {\n\t\tcase 1:\n\t\t\tomode =  (u8) (force_new ? GF_ISOM_WRITE_EDIT : (open_edit ? GF_ISOM_OPEN_EDIT : ( ((dump_isom>0) || print_info) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ) ) );\n\n\t\t\tif (crypt) {\n\t\t\t\t//keep fragment signaling in moov\n\t\t\t\tomode = GF_ISOM_OPEN_READ;\n\t\t\t\tif (use_init_seg)\n\t\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ, NULL);\n\t\t\t}\n\t\t\tif (!crypt && use_init_seg) {\n\t\t\t\tfile = gf_isom_open(use_init_seg, GF_ISOM_OPEN_READ_DUMP, NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\te = gf_isom_open_segment(file, inName, 0, 0, 0);\n\t\t\t\t\tif (e==GF_ISOM_INCOMPLETE_FILE) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_WARNING, (\"Segment %s: %s\\n\", inName, gf_error_to_string(e) ));\n\t\t\t\t\t} else if (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening segment %s: %s\\n\", inName, gf_error_to_string(e) ));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tfile = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!file)\n\t\t\t\tfile = gf_isom_open(inName, omode, NULL);\n\n\t\t\tif (!file && (gf_isom_last_error(NULL) == GF_ISOM_INCOMPLETE_FILE) && !open_edit) {\n\t\t\t\tu64 missing_bytes;\n\t\t\t\tgf_isom_open_progressive(inName, 0, 0, GF_FALSE, &file, &missing_bytes);\n\t\t\t\tif (missing_bytes)\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Truncated file - missing \"LLD\" bytes\\n\", missing_bytes));\n\t\t\t}\n\n\t\t\tif (!file) {\n\t\t\t\tif (open_edit && nb_meta_act) {\n\t\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, NULL);\n\t\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t\t}\n\n\t\t\t\tif (!file) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error opening file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL))));\n\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (freeze_box_order)\n\t\t\t\tgf_isom_freeze_order(file);\n\t\t\tbreak;\n\t\t/*allowed for bt<->xmt*/\n\t\tcase 2:\n\t\tcase 3:\n\t\t/*allowed for svg->lsr**/\n\t\tcase 4:\n\t\t/*allowed for swf->bt, swf->xmt, swf->svg*/\n\t\tcase 5:\n\t\t\tbreak;\n\t\t/*used for .saf / .lsr dump*/\n\t\tcase 6:\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\tif ((dump_mode==GF_SM_DUMP_LASER) || (dump_mode==GF_SM_DUMP_SVG)) {\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\tdefault:\n\t\t\tif (!open_edit && file_exists && !gf_isom_probe_file(inName) && track_dump_type) {\n\t\t\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\telse if (!open_edit && file_exists /* && !gf_isom_probe_file(inName) */\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\t\t\t         && dump_mode == GF_SM_DUMP_NONE\n#endif //GPAC_DISABLE_SCENE_DUMP\n\t\t\t        ) {\n\t\t\t\t/*************************************************************************************************/\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\tif(dvbhdemux)\n\t\t\t\t{\n\t\t\t\t\tGF_MediaImporter import;\n\t\t\t\t\tfile = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);\n\t\t\t\t\tmemset(&import, 0, sizeof(GF_MediaImporter));\n\t\t\t\t\timport.dest = file;\n\t\t\t\t\timport.in_name = inName;\n\t\t\t\t\timport.flags = GF_IMPORT_MPE_DEMUX;\n\t\t\t\t\te = gf_media_import(&import);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));\n\t\t\t\t\t\tgf_isom_delete(file);\n\t\t\t\t\t\tgf_file_delete(\"ttxt_convert\");\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\n\t\t\t\tif (dump_m2ts) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, outName, program_number);\n#endif\n\t\t\t\t} else if (dump_timestamps) {\n#ifndef GPAC_DISABLE_MPEG2TS\n\t\t\t\t\tdump_mpeg2_ts(inName, outName, program_number);\n#endif\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\t\t\t\t} else if (do_bin_xml) {\n\t\t\t\t\txml_bs_to_bin(inName, outName, dump_std);\n#endif\n\t\t\t\t} else if (do_hash) {\n\t\t\t\t\thash_file(inName, dump_std);\n\t\t\t\t} else if (print_info) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\t\t\t\tconvert_file_info(inName, info_track_id);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tif (mux_name) {\n\t\t\t\t\t\te = do_remux_file();\n\t\t\t\t\t\tif (e) goto err_exit;\n\t\t\t\t\t\tif (file) gf_isom_delete(file);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Input %s is not an MP4 file, operation not allowed\\n\", inName));\n\t\t\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgoto exit;\n\t\t\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\t\t\telse if (open_edit) {\n\t\t\t\tfile = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, NULL);\n\t\t\t\tif (!outName && file) outName = inName;\n\t\t\t} else if (!file_exists) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error %s file %s: %s\\n\", force_new ? \"creating\" : \"opening\", inName, gf_error_to_string(GF_URL_ERROR)));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot open %s - extension not supported\\n\", inName));\n\t\t\t\treturn mp4box_cleanup(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (high_dynamc_range_filename) {\n\t\te = parse_high_dynamc_range_xml_desc(file, high_dynamc_range_filename);\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (file && keep_utc) {\n\t\tgf_isom_keep_utc_times(file, 1);\n\t}\n\n\tif ( gf_strlcpy(outfile, outName ? outName : inName, sizeof(outfile)) >= sizeof(outfile) ) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Filename too long (limit is %d)\\n\", GF_MAX_PATH));\n\t\treturn mp4box_cleanup(1);\n\t}\n\n\tchar *szExt = gf_file_ext_start(outfile);\n\tif (szExt) {\n\t\t/*turn on 3GP saving*/\n\t\tif (!stricmp(szExt, \".3gp\") || !stricmp(szExt, \".3gpp\") || !stricmp(szExt, \".3g2\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_3GPP;\n\t\telse if (!stricmp(szExt, \".m4a\") || !stricmp(szExt, \".m4v\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_IPOD;\n\t\telse if (!stricmp(szExt, \".psp\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_PSP;\n\t\telse if (!stricmp(szExt, \".mov\") || !stricmp(szExt, \".qt\"))\n\t\t\tconv_type = GF_ISOM_CONV_TYPE_MOV;\n\n\t\t//remove extension from outfile\n\t\t*szExt = 0;\n\t}\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (!open_edit && track_dump_type && !gf_isom_probe_file(inName)) {\n\t\te = do_export_tracks_non_isobmf();\n\t\tif (e) goto err_exit;\n\t\tgoto exit;\n\t}\n\tif (mux_name) {\n\t\te = do_remux_file();\n\t\tif (e) goto err_exit;\n\t\tif (file) gf_isom_delete(file);\n\t\tgoto exit;\n\t}\n\n\n\n#endif /*GPAC_DISABLE_MEDIA_EXPORT*/\n\n#ifndef GPAC_DISABLE_SCENE_DUMP\n\tif (dump_mode != GF_SM_DUMP_NONE) {\n\t\te = dump_isom_scene(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_mode, do_scene_log, no_odf_conf);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_SCENE_STATS\n\tif (stat_level) dump_isom_scene_stats(inName, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, stat_level);\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (!do_hint && print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\tif (get_nb_tracks) {\n\t\tfprintf(stdout, \"%d\\n\", gf_isom_get_track_count(file));\n\t}\n\tif (print_info) {\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Cannot print info on a non ISOM file (%s)\\n\", inName));\n\t\t} else {\n\t\t\tif (info_track_id) DumpTrackInfo(file, info_track_id, 1, (print_info==2) ? GF_TRUE : GF_FALSE, GF_FALSE);\n\t\t\telse DumpMovieInfo(file);\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_DUMP\n\tif (dump_isom) {\n\t\te = dump_isom_xml(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, (dump_isom==2) ? GF_TRUE : GF_FALSE, merge_vtt_cues, use_init_seg ? GF_TRUE : GF_FALSE, (dump_isom==3) ? GF_TRUE : GF_FALSE);\n\t\tif (e) goto err_exit;\n\t}\n\tif (dump_cr) dump_isom_ismacryp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif ((dump_ttxt || dump_srt) && trackID) {\n\n\t\tif (trackID == (u32)-1) {\n\t\t\tfor (j=0; j<gf_isom_get_track_count(file); j++) {\n\t\t\t\ttrackID = gf_isom_get_track_id(file, j+1);\n\t\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tdump_isom_timed_text(file, trackID, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,\n\t\t\t\t\t\t\t\tGF_FALSE, dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT);\n\t\t}\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (dump_rtp) dump_isom_rtp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n#endif\n\n#endif\n\n\tif (dump_timestamps) dump_isom_timestamps(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_timestamps);\n\tif (dump_nal) dump_isom_nal(file, dump_nal, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_nal_type);\n\tif (dump_saps) dump_isom_saps(file, dump_saps, dump_saps_mode, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\n\tif (do_hash) {\n\t\te = hash_file(inName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#ifndef GPAC_DISABLE_CORE_TOOLS\n\tif (do_bin_xml) {\n\t\te = xml_bs_to_bin(inName, outName, dump_std);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\te = do_dump_iod();\n\t\tif (e) goto err_exit;\n\t}\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\tif (split_duration || split_size || split_range_str) {\n\t\tsplit_isomedia_file(file, split_duration, split_size, inName, interleaving_time, split_start, adjust_split_end, outName, seg_at_rap, split_range_str, fs_dump_flags);\n\n\t\t/*never save file when splitting is desired*/\n\t\topen_edit = GF_FALSE;\n\t\tdo_save = GF_FALSE;\n\t}\n#endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)\n\n#ifndef GPAC_DISABLE_MEDIA_EXPORT\n\tif (track_dump_type) {\n\t\te = do_export_tracks();\n\t\tif (e) goto err_exit;\n\t} else if (do_saf) {\n\t\tGF_MediaExporter mdump;\n\t\tmemset(&mdump, 0, sizeof(mdump));\n\t\tmdump.file = file;\n\t\tmdump.flags = GF_EXPORT_SAF;\n\t\tmdump.out_name = outfile;\n\t\tmdump.print_stats_graph = fs_dump_flags;\n\t\te = gf_media_export(&mdump);\n\t\tif (e) goto err_exit;\n\t}\n#endif\n\n\te = do_meta_act();\n\tif (e) goto err_exit;\n\n\tif (!open_edit && !do_save) {\n\t\tif (file) gf_isom_delete(file);\n\t\tgoto exit;\n\t}\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (clean_groups) {\n\t\te = gf_isom_reset_switch_parameters(file);\n\t\tif (e) goto err_exit;\n\t\tdo_save = GF_TRUE;\n\t}\n\n\n\te = do_tsel_act();\n\tif (e) goto err_exit;\n\n\tif (remove_sys_tracks) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tremove_systems_tracks(file);\n#endif\n\t\tdo_save = GF_TRUE;\n\t\tif (conv_type < GF_ISOM_CONV_TYPE_ISMA_EX) conv_type = 0;\n\t}\n\tif (remove_root_od) {\n\t\tgf_isom_remove_root_od(file);\n\t\tdo_save = GF_TRUE;\n\t}\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (remove_hint) {\n\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\tif (gf_isom_get_media_type(file, i+1) == GF_ISOM_MEDIA_HINT) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Removing hint track ID %d\\n\", gf_isom_get_track_id(file, i+1)));\n\t\t\t\tgf_isom_remove_track(file, i+1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_clean(file);\n\t\tdo_save = GF_TRUE;\n\t}\n#endif // GPAC_DISABLE_ISOM_HINTING\n\n\tif (timescale && (timescale != gf_isom_get_timescale(file))) {\n\t\tgf_isom_set_timescale(file, timescale);\n\t\tdo_save = GF_TRUE;\n\t}\n\n\tif (!encode) {\n\t\tif (!file) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Nothing to do - exiting\\n\"));\n\t\t\tgoto exit;\n\t\t}\n\t\tif (outName) {\n\t\t\tstrcpy(outfile, outName);\n\t\t} else {\n\t\t\tconst char *tmp_dir = gf_opts_get_key(\"core\", \"tmp\");\n\t\t\tchar *rel_name = strrchr(inName, GF_PATH_SEPARATOR);\n\t\t\tif (!rel_name) rel_name = strrchr(inName, '/');\n\n\t\t\tstrcpy(outfile, \"\");\n\t\t\tif (tmp_dir) {\n\t\t\t\tstrcpy(outfile, tmp_dir);\n\t\t\t\tif (!strchr(\"\\\\/\", tmp_dir[strlen(tmp_dir)-1])) strcat(outfile, \"/\");\n\t\t\t}\n\t\t\tif (!pack_file) strcat(outfile, \"out_\");\n\t\t\tstrcat(outfile, rel_name ? rel_name + 1 : inName);\n\n\t\t\tif (pack_file) {\n\t\t\t\tstrcpy(outfile, rel_name ? rel_name + 1 : inName);\n\t\t\t\trel_name = strrchr(outfile, '.');\n\t\t\t\tif (rel_name) rel_name[0] = 0;\n\t\t\t\tstrcat(outfile, \".m21\");\n\t\t\t}\n\t\t}\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tif ((conv_type == GF_ISOM_CONV_TYPE_ISMA) || (conv_type == GF_ISOM_CONV_TYPE_ISMA_EX)) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to ISMA Audio-Video MP4 file\\n\"));\n\t\t\t/*keep ESIDs when doing ISMACryp*/\n\t\t\te = gf_media_make_isma(file, crypt ? 1 : 0, GF_FALSE, (conv_type==GF_ISOM_CONV_TYPE_ISMA_EX) ? 1 : 0);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_3GPP) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to 3GP file\\n\"));\n\t\t\te = gf_media_make_3gpp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_PSP) {\n\t\t\tM4_LOG(GF_LOG_INFO, (\"Converting to PSP file\\n\"));\n\t\t\te = gf_media_make_psp(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t}\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_MOV) {\n\t\t\te = gf_media_check_qt_prores(file);\n\t\t\tif (e) goto err_exit;\n\t\t\tdo_save = GF_TRUE;\n\t\t\tif (interleaving_time) interleaving_time = 0.5;\n\t\t}\n#endif /*GPAC_DISABLE_MEDIA_IMPORT*/\n\t\tif (conv_type == GF_ISOM_CONV_TYPE_IPOD) {\n\t\t\tdo_ipod_conv();\n\t\t}\n\n\t} else if (outName) {\n\t\tstrcpy(outfile, outName);\n\t}\n\n\te = do_track_act();\n\tif (e) goto err_exit;\n\n\tif (itunes_tags) {\n\t\te = do_itunes_tag();\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (cprt) {\n\t\te = gf_isom_set_copyright(file, \"und\", cprt);\n\t\tdo_save = GF_TRUE;\n\t\tif (e) goto err_exit;\n\t}\n\tif (chap_file || chap_file_qt) {\n#ifndef GPAC_DISABLE_MEDIA_IMPORT\n\t\tBool chap_qt = GF_FALSE;\n\t\tif (chap_file_qt) {\n\t\t\tchap_file = chap_file_qt;\n\t\t\tchap_qt = GF_TRUE;\n\t\t}\n\t\te = gf_media_import_chapters(file, chap_file, import_fps, chap_qt);\n\t\tdo_save = GF_TRUE;\n#else\n\t\tM4_LOG(GF_LOG_WARNING, (\"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\"));\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\tif (e) goto err_exit;\n\t}\n\n\tif (major_brand) {\n\t\tgf_isom_set_brand_info(file, major_brand, minor_version);\n\t\tdo_save = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_add; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_add[i], GF_TRUE);\n\t\tdo_save = GF_TRUE;\n\t}\n\tfor (i=0; i<nb_alt_brand_rem; i++) {\n\t\tgf_isom_modify_alternate_brand(file, brand_rem[i], GF_FALSE);\n\t\tdo_save = GF_TRUE;\n\t}\n\tif (box_patch_filename) {\n\t\te = gf_isom_apply_box_patch(file, box_patch_trackID, box_patch_filename, GF_FALSE);\n\t\tif (e) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) ));\n\t\t\tgoto err_exit;\n\t\t}\n\t\tdo_save = GF_TRUE;\n\t}\n\n#ifndef GPAC_DISABLE_CRYPTO\n\tif (crypt) {\n\t\tif (!drm_file && (crypt==1) ) {\n\t\t\tM4_LOG(GF_LOG_ERROR, (\"Missing DRM file location - usage '-%s drm_file input_file\\n\", (crypt==1) ? \"crypt\" : \"decrypt\"));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (crypt == 1) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_crypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_crypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t} else if (crypt ==2) {\n\t\t\tif (use_init_seg) {\n\t\t\t\te = gf_decrypt_fragment(file, drm_file, outfile, inName, fs_dump_flags);\n\t\t\t} else {\n\t\t\t\te = gf_decrypt_file(file, drm_file, outfile, interleaving_time, fs_dump_flags);\n\t\t\t}\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tdo_save = outName ? GF_FALSE : GF_TRUE;\n\n\t\tif (!do_frag && !do_hint && !full_interleave && !force_co64) {\n\t\t\tchar szName[GF_MAX_PATH];\n\t\t\tstrcpy(szName, gf_isom_get_filename(file) );\n\t\t\tgf_isom_delete(file);\n\t\t\tfile = NULL;\n\t\t\tif (!outName) {\n\t\t\t\te = gf_file_move(outfile, szName);\n\t\t\t\tif (e) goto err_exit;\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n#endif /*GPAC_DISABLE_CRYPTO*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (do_frag) {\n\t\tif (!interleaving_time) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;\n\t\tif (do_hint) M4_LOG(GF_LOG_WARNING, (\"Warning: cannot hint and fragment - ignoring hint\\n\"));\n\t\tM4_LOG(GF_LOG_INFO, (\"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time));\n\t\te = gf_media_fragment_file(file, outfile, interleaving_time, use_mfra);\n\t\tif (e) M4_LOG(GF_LOG_ERROR, (\"Error while fragmenting file: %s\\n\", gf_error_to_string(e)));\n\t\tif (!e && !outName) {\n\t\t\tif (gf_file_exists(inName) && gf_file_delete(inName)) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Error removing file %s\\n\", inName));\n\t\t\t}\n\t\t\telse if (gf_file_move(outfile, inName)) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Error renaming file %s to %s\\n\", outfile, inName));\n\t\t\t}\n\t\t}\n\t\tif (e) goto err_exit;\n\t\tgf_isom_delete(file);\n\t\tgoto exit;\n\t}\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\tif (do_hint) {\n\t\tif (force_ocr) SetupClockReferences(file);\n\t\tMTUSize -= 12;\n\t\te = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, hint_interleave, regular_iod, single_group, hint_no_offset);\n\t\tif (e) goto err_exit;\n\t\tdo_save = GF_TRUE;\n\t\tif (print_sdp) dump_isom_sdp(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\t}\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)\n\tset_sdp_ext();\n#endif /*!defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)*/\n\n\tif (force_co64)\n\t\tgf_isom_force_64bit_chunk_offset(file, GF_TRUE);\n\n\tif (compress_moov)\n\t\tgf_isom_enable_compression(file, GF_ISO_COMP_MOOV, GF_FALSE);\n\n\tif (no_inplace)\n\t\tgf_isom_disable_inplace_rewrite(file);\n\n\tif (moov_pading)\n\t\tgf_isom_set_inplace_padding(file, moov_pading);\n\n\tif (outName) {\n\t\tgf_isom_set_final_name(file, outfile);\n\t} else if (!encode && !force_new && !gf_isom_is_inplace_rewrite(file)) {\n\t\tgf_isom_set_final_name(file, outfile);\n\t}\n\n\tBool is_inplace = gf_isom_is_inplace_rewrite(file);\n\n\n\t/*full interleave (sample-based) if just hinted*/\n\tif (full_interleave) {\n\t\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_TIGHT);\n\t} else if (do_flat) {\n\t\te = gf_isom_set_storage_mode(file, (do_flat==1) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE);\n\t\tdo_save = GF_TRUE;\n\t}\n\t//do not set storage mode unless inplace rewrite is disabled , either by user or due to operations on file\n\telse if (!is_inplace) {\n\t\te = gf_isom_make_interleave(file, interleaving_time);\n\t\tif (!e && old_interleave) e = gf_isom_set_storage_mode(file, GF_ISOM_STORE_INTERLEAVED);\n\t}\n\n\tif (e) goto err_exit;\n\n\n\tif (do_save) {\n\n\t\tif (!gf_sys_is_quiet()) {\n\t\t\tif (outName) {\n\t\t\t} else if (encode || pack_file) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Saving to %s: \", gf_isom_get_filename(file) ));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Saving %s: \", inName));\n\t\t\t}\n\t\t\tif (is_inplace) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"In-place rewrite\\n\"));\n\t\t\t} else if (do_hint && full_interleave) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Hinted file - Full Interleaving\\n\"));\n\t\t\t} else if (full_interleave) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Full Interleaving\\n\"));\n\t\t\t} else if ((force_new==2) && interleaving_time) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Fast-start interleaved storage\\n\"));\n\t\t\t} else if (do_flat || !interleaving_time) {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"Flat storage\\n\"));\n\t\t\t} else {\n\t\t\t\tM4_LOG(GF_LOG_INFO, (\"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\"));\n\t\t\t}\n\t\t}\n\n\t\te = gf_isom_close(file);\n\t\tfile = NULL;\n\n\t\tif (!e && !outName && !encode && !force_new && !pack_file && !is_inplace) {\n\t\t\tif (gf_file_exists(inName)) {\n\t\t\t\te = gf_file_delete(inName);\n\t\t\t\tif (e) {\n\t\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error removing file %s\\n\", inName));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te = gf_file_move(outfile, inName);\n\t\t\tif (e) {\n\t\t\t\tM4_LOG(GF_LOG_ERROR, (\"Error renaming file %s to %s\\n\", outfile, inName));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tgf_isom_delete(file);\n\t}\n\n\tif (e) {\n\t\tM4_LOG(GF_LOG_ERROR, (\"Error: %s\\n\", gf_error_to_string(e)));\n\t\tgoto err_exit;\n\t}\n\tgoto exit;\n\n#else\n\t/*close libgpac*/\n\tgf_isom_delete(file);\n\tM4_LOG(GF_LOG_ERROR, (\"Error: Read-only version of MP4Box.\\n\"));\n\treturn mp4box_cleanup(1);\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nerr_exit:\n\t/*close libgpac*/\n\tif (file) gf_isom_delete(file);\n\tM4_LOG(GF_LOG_ERROR, (\"\\n\\tError: %s\\n\", gf_error_to_string(e)));\n\treturn mp4box_cleanup(1);\n\nexit:\n\tmp4box_cleanup(0);\n\n#ifdef GPAC_MEMORY_TRACKING\n\tif (mem_track && (gf_memory_size() || gf_file_handles_count() )) {\n\t\tgf_log_set_tool_level(GF_LOG_MEMORY, GF_LOG_INFO);\n\t\tgf_memory_print();\n\t\treturn 2;\n\t}\n#endif\n\treturn 0;\n}\n\n\nGF_MAIN_FUNC(mp4boxMain)\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["applications/mp4box/main.c"], "buggy_code_start_loc": [3373], "buggy_code_end_loc": [3374], "fixing_code_start_loc": [3373], "fixing_code_end_loc": [3374], "type": "CWE-476", "message": "The HintFile function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-31257", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.267", "lastModified": "2021-04-21T19:42:53.557", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The HintFile function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n HintFile en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/87afe070cd6866df7fe80f11b26ef75161de85e0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1734", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/87afe070cd6866df7fe80f11b26ef75161de85e0"}}