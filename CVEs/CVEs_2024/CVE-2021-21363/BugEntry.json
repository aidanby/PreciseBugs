{"buggy_code": ["package io.swagger.generator.online;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.codegen.*;\nimport io.swagger.generator.exception.ApiException;\nimport io.swagger.generator.exception.BadRequestException;\nimport io.swagger.generator.model.GeneratorInput;\nimport io.swagger.generator.model.InputOption;\nimport io.swagger.generator.util.ZipUtil;\nimport io.swagger.models.Swagger;\nimport io.swagger.models.auth.AuthorizationValue;\nimport io.swagger.parser.SwaggerParser;\nimport io.swagger.util.Json;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Generator {\n    static Logger LOGGER = LoggerFactory.getLogger(Generator.class);\n\n    public static Map<String, CliOption> getOptions(String language) throws ApiException {\n        CodegenConfig config = null;\n        try {\n            config = CodegenConfigLoader.forName(language);\n        } catch (Exception e) {\n            throw new BadRequestException(String.format(\"Unsupported target %s supplied. %s\",\n                    language, e));\n        }\n        Map<String, CliOption> map = new LinkedHashMap<String, CliOption>();\n        for (CliOption option : config.cliOptions()) {\n            map.put(option.getOpt(), option);\n        }\n        return map;\n    }\n\n    public enum Type {\n        CLIENT(\"client\"), SERVER(\"server\");\n\n        private String name;\n\n        Type(String name) {\n            this.name = name;\n        }\n\n        String getTypeName() {\n            return name;\n        }\n    }\n\n    public static String generateClient(String language, GeneratorInput opts) throws ApiException {\n        return generate(language, opts, Type.CLIENT);\n    }\n\n    public static String generateServer(String language, GeneratorInput opts) throws ApiException {\n        return generate(language, opts, Type.SERVER);\n    }\n\n    private static String generate(String language, GeneratorInput opts, Type type)\n            throws ApiException {\n        LOGGER.debug(String.format(\"generate %s for %s\", type.getTypeName(), language));\n        if (opts == null) {\n            throw new BadRequestException(\"No options were supplied\");\n        }\n        JsonNode node = opts.getSpec();\n        if (node != null && \"{}\".equals(node.toString())) {\n            LOGGER.debug(\"ignoring empty spec\");\n            node = null;\n        }\n        Swagger swagger;\n        if (node == null) {\n            if (opts.getSwaggerUrl() != null) {\n                if (opts.getAuthorizationValue() != null) {\n                    List<AuthorizationValue> authorizationValues =\n                            new ArrayList<AuthorizationValue>();\n                    authorizationValues.add(opts.getAuthorizationValue());\n\n                    swagger =\n                            new SwaggerParser().read(opts.getSwaggerUrl(), authorizationValues,\n                                    true);\n                } else {\n                    swagger = new SwaggerParser().read(opts.getSwaggerUrl());\n                }\n            } else {\n                throw new BadRequestException(\"No swagger specification was supplied\");\n            }\n        } else if (opts.getAuthorizationValue() != null) {\n            List<AuthorizationValue> authorizationValues = new ArrayList<AuthorizationValue>();\n            authorizationValues.add(opts.getAuthorizationValue());\n            swagger = new SwaggerParser().read(node, authorizationValues, true);\n        } else {\n            swagger = new SwaggerParser().read(node, true);\n        }\n        if (swagger == null) {\n            throw new BadRequestException(\"The swagger specification supplied was not valid\");\n        }\n\n        String destPath = null;\n\n        if (opts != null && opts.getOptions() != null) {\n            destPath = opts.getOptions().get(\"outputFolder\");\n        }\n        if (destPath == null) {\n            destPath = language + \"-\" + type.getTypeName();\n        }\n\n        ClientOptInput clientOptInput = new ClientOptInput();\n        ClientOpts clientOpts = new ClientOpts();\n        String outputFolder = getTmpFolder().getAbsolutePath() + File.separator + destPath;\n        String outputFilename = outputFolder + \"-bundle.zip\";\n\n        clientOptInput.opts(clientOpts).swagger(swagger);\n\n        CodegenConfig codegenConfig = null;\n        try {\n            codegenConfig = CodegenConfigLoader.forName(language);\n        } catch (RuntimeException e) {\n            throw new BadRequestException(\"Unsupported target \" + language + \" supplied\");\n        }\n\n        if (opts.getOptions() != null) {\n            codegenConfig.additionalProperties().putAll(opts.getOptions());\n            codegenConfig.additionalProperties().put(\"swagger\", swagger);\n        }\n\n        codegenConfig.setOutputDir(outputFolder);\n\n        LOGGER.debug(Json.pretty(clientOpts));\n\n        clientOptInput.setConfig(codegenConfig);\n\n        try {\n            List<File> files = new Codegen().opts(clientOptInput).generate();\n            if (files.size() > 0) {\n                List<File> filesToAdd = new ArrayList<File>();\n                LOGGER.debug(\"adding to \" + outputFolder);\n                filesToAdd.add(new File(outputFolder));\n                ZipUtil zip = new ZipUtil();\n                zip.compressFiles(filesToAdd, outputFilename);\n            } else {\n                throw new BadRequestException(\n                        \"A target generation was attempted, but no files were created!\");\n            }\n            for (File file : files) {\n                try {\n                    file.delete();\n                } catch (Exception e) {\n                    LOGGER.error(\"unable to delete file \" + file.getAbsolutePath());\n                }\n            }\n            try {\n                new File(outputFolder).delete();\n            } catch (Exception e) {\n                LOGGER.error(\"unable to delete output folder \" + outputFolder);\n            }\n        } catch (Exception e) {\n            throw new BadRequestException(\"Unable to build target: \" + e.getMessage());\n        }\n        return outputFilename;\n    }\n\n    public static InputOption clientOptions(@SuppressWarnings(\"unused\") String language) {\n        return null;\n    }\n\n    public static InputOption serverOptions(@SuppressWarnings(\"unused\") String language) {\n        return null;\n    }\n\n    protected static File getTmpFolder() {\n        try {\n            File outputFolder = File.createTempFile(\"codegen-\", \"-tmp\");\n            outputFolder.delete();\n            outputFolder.mkdir();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n"], "fixing_code": ["package io.swagger.generator.online;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.codegen.*;\nimport io.swagger.generator.exception.ApiException;\nimport io.swagger.generator.exception.BadRequestException;\nimport io.swagger.generator.model.GeneratorInput;\nimport io.swagger.generator.model.InputOption;\nimport io.swagger.generator.util.ZipUtil;\nimport io.swagger.models.Swagger;\nimport io.swagger.models.auth.AuthorizationValue;\nimport io.swagger.parser.SwaggerParser;\nimport io.swagger.util.Json;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Generator {\n    static Logger LOGGER = LoggerFactory.getLogger(Generator.class);\n\n    public static Map<String, CliOption> getOptions(String language) throws ApiException {\n        CodegenConfig config = null;\n        try {\n            config = CodegenConfigLoader.forName(language);\n        } catch (Exception e) {\n            throw new BadRequestException(String.format(\"Unsupported target %s supplied. %s\",\n                    language, e));\n        }\n        Map<String, CliOption> map = new LinkedHashMap<String, CliOption>();\n        for (CliOption option : config.cliOptions()) {\n            map.put(option.getOpt(), option);\n        }\n        return map;\n    }\n\n    public enum Type {\n        CLIENT(\"client\"), SERVER(\"server\");\n\n        private String name;\n\n        Type(String name) {\n            this.name = name;\n        }\n\n        String getTypeName() {\n            return name;\n        }\n    }\n\n    public static String generateClient(String language, GeneratorInput opts) throws ApiException {\n        return generate(language, opts, Type.CLIENT);\n    }\n\n    public static String generateServer(String language, GeneratorInput opts) throws ApiException {\n        return generate(language, opts, Type.SERVER);\n    }\n\n    private static String generate(String language, GeneratorInput opts, Type type)\n            throws ApiException {\n        LOGGER.debug(String.format(\"generate %s for %s\", type.getTypeName(), language));\n        if (opts == null) {\n            throw new BadRequestException(\"No options were supplied\");\n        }\n        JsonNode node = opts.getSpec();\n        if (node != null && \"{}\".equals(node.toString())) {\n            LOGGER.debug(\"ignoring empty spec\");\n            node = null;\n        }\n        Swagger swagger;\n        if (node == null) {\n            if (opts.getSwaggerUrl() != null) {\n                if (opts.getAuthorizationValue() != null) {\n                    List<AuthorizationValue> authorizationValues =\n                            new ArrayList<AuthorizationValue>();\n                    authorizationValues.add(opts.getAuthorizationValue());\n\n                    swagger =\n                            new SwaggerParser().read(opts.getSwaggerUrl(), authorizationValues,\n                                    true);\n                } else {\n                    swagger = new SwaggerParser().read(opts.getSwaggerUrl());\n                }\n            } else {\n                throw new BadRequestException(\"No swagger specification was supplied\");\n            }\n        } else if (opts.getAuthorizationValue() != null) {\n            List<AuthorizationValue> authorizationValues = new ArrayList<AuthorizationValue>();\n            authorizationValues.add(opts.getAuthorizationValue());\n            swagger = new SwaggerParser().read(node, authorizationValues, true);\n        } else {\n            swagger = new SwaggerParser().read(node, true);\n        }\n        if (swagger == null) {\n            throw new BadRequestException(\"The swagger specification supplied was not valid\");\n        }\n\n        String destPath = null;\n\n        if (opts != null && opts.getOptions() != null) {\n            destPath = opts.getOptions().get(\"outputFolder\");\n        }\n        if (destPath == null) {\n            destPath = language + \"-\" + type.getTypeName();\n        }\n\n        ClientOptInput clientOptInput = new ClientOptInput();\n        ClientOpts clientOpts = new ClientOpts();\n        String outputFolder = getTmpFolder().getAbsolutePath() + File.separator + destPath;\n        String outputFilename = outputFolder + \"-bundle.zip\";\n\n        clientOptInput.opts(clientOpts).swagger(swagger);\n\n        CodegenConfig codegenConfig = null;\n        try {\n            codegenConfig = CodegenConfigLoader.forName(language);\n        } catch (RuntimeException e) {\n            throw new BadRequestException(\"Unsupported target \" + language + \" supplied\");\n        }\n\n        if (opts.getOptions() != null) {\n            codegenConfig.additionalProperties().putAll(opts.getOptions());\n            codegenConfig.additionalProperties().put(\"swagger\", swagger);\n        }\n\n        codegenConfig.setOutputDir(outputFolder);\n\n        LOGGER.debug(Json.pretty(clientOpts));\n\n        clientOptInput.setConfig(codegenConfig);\n\n        try {\n            List<File> files = new Codegen().opts(clientOptInput).generate();\n            if (files.size() > 0) {\n                List<File> filesToAdd = new ArrayList<File>();\n                LOGGER.debug(\"adding to \" + outputFolder);\n                filesToAdd.add(new File(outputFolder));\n                ZipUtil zip = new ZipUtil();\n                zip.compressFiles(filesToAdd, outputFilename);\n            } else {\n                throw new BadRequestException(\n                        \"A target generation was attempted, but no files were created!\");\n            }\n            for (File file : files) {\n                try {\n                    file.delete();\n                } catch (Exception e) {\n                    LOGGER.error(\"unable to delete file \" + file.getAbsolutePath());\n                }\n            }\n            try {\n                new File(outputFolder).delete();\n            } catch (Exception e) {\n                LOGGER.error(\"unable to delete output folder \" + outputFolder);\n            }\n        } catch (Exception e) {\n            throw new BadRequestException(\"Unable to build target: \" + e.getMessage());\n        }\n        return outputFilename;\n    }\n\n    public static InputOption clientOptions(@SuppressWarnings(\"unused\") String language) {\n        return null;\n    }\n\n    public static InputOption serverOptions(@SuppressWarnings(\"unused\") String language) {\n        return null;\n    }\n\n    protected static File getTmpFolder() {\n        try {\n            File outputFolder = Files.createTempDirectory(\"codegen-\").toFile();\n            outputFolder.deleteOnExit();\n            return outputFolder;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n}\n"], "filenames": ["modules/swagger-generator/src/main/java/io/swagger/generator/online/Generator.java"], "buggy_code_start_loc": [17], "buggy_code_end_loc": [179], "fixing_code_start_loc": [18], "fixing_code_end_loc": [178], "type": "CWE-378", "message": "swagger-codegen is an open-source project which contains a template-driven engine to generate documentation, API clients and server stubs in different languages by parsing your OpenAPI / Swagger definition. In swagger-codegen before version 2.4.19, on Unix like systems, the system's temporary directory is shared between all users on that system. A collocated user can observe the process of creating a temporary sub directory in the shared temporary directory and race to complete the creation of the temporary subdirectory. This vulnerability is local privilege escalation because the contents of the `outputFolder` can be appended to by an attacker. As such, code written to this directory, when executed can be attacker controlled. For more details refer to the referenced GitHub Security Advisory. This vulnerability is fixed in version 2.4.19. Note this is a distinct vulnerability from CVE-2021-21364.", "other": {"cve": {"id": "CVE-2021-21363", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-11T03:15:11.977", "lastModified": "2021-03-18T16:11:27.430", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "swagger-codegen is an open-source project which contains a template-driven engine to generate documentation, API clients and server stubs in different languages by parsing your OpenAPI / Swagger definition. In swagger-codegen before version 2.4.19, on Unix like systems, the system's temporary directory is shared between all users on that system. A collocated user can observe the process of creating a temporary sub directory in the shared temporary directory and race to complete the creation of the temporary subdirectory. This vulnerability is local privilege escalation because the contents of the `outputFolder` can be appended to by an attacker. As such, code written to this directory, when executed can be attacker controlled. For more details refer to the referenced GitHub Security Advisory. This vulnerability is fixed in version 2.4.19. Note this is a distinct vulnerability from CVE-2021-21364."}, {"lang": "es", "value": "swagger-codegen es un proyecto de c\u00f3digo abierto que contiene un motor basado en plantillas para generar documentaci\u00f3n, clientes API y stubs de servidor en diferentes idiomas mediante el an\u00e1lisis de su definici\u00f3n de OpenAPI/Swagger.&#xa0;En swagger-codegen versiones anteriores a 2.4.19, en sistemas similares a Unix, el directorio temporal del sistema se comparte entre todos los usuarios de ese sistema.&#xa0;Un usuario ubicado puede observar el proceso de creaci\u00f3n de un subdirectorio temporal en el directorio temporal compartido y una corrida para completar la creaci\u00f3n del subdirectorio temporal.&#xa0;Esta vulnerabilidad es una escalada de privilegios local porque un atacante puede agregar el contenido de \"outputFolder\".&#xa0;Como tal, el c\u00f3digo escrito en este directorio, cuando se ejecuta, puede ser controlado por el atacante.&#xa0;Para mayor detalles, consulte el GitHub Security Advisory al que se hace referencia.&#xa0;Esta vulnerabilidad es corregido en versi\u00f3n 2.4.19"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:C/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-378"}, {"lang": "en", "value": "CWE-379"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:smartbear:swagger-codegen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.19", "matchCriteriaId": "28D1596B-24DA-4372-B7C9-585ECDBA8C30"}]}]}], "references": [{"url": "https://github.com/swagger-api/swagger-codegen/commit/987ea7a30b463cc239580d6ad166c707ae942a89", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/swagger-api/swagger-codegen/security/advisories/GHSA-pc22-3g76-gm6j", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/swagger-api/swagger-codegen/commit/987ea7a30b463cc239580d6ad166c707ae942a89"}}