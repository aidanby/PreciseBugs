{"buggy_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport static com.sun.faces.config.WebConfiguration.META_INF_CONTRACTS_DIR;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.CacheResourceModificationTimestamp;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.EnableMissingResourceLibraryDetection;\nimport static javax.faces.application.ProjectStage.Development;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\nimport javax.faces.view.facelets.ResourceResolver;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.facelets.impl.DefaultResourceResolver;\nimport com.sun.faces.util.Util;\n\n\n/**\n * <p>\n * A {@link ResourceHelper} implementation for finding/serving resources\n * found on the classpath within the <code>META-INF/resources directory.\n * </p>\n *\n * @since 2.0\n */\npublic class ClasspathResourceHelper extends ResourceHelper {\n\n\n    private static final String BASE_RESOURCE_PATH = \"META-INF/resources\";\n    private boolean cacheTimestamp;\n    private volatile ZipDirectoryEntryScanner libraryScanner;\n    private boolean enableMissingResourceLibraryDetection;\n\n\n\n    // ------------------------------------------------------------ Constructors\n\n\n    public ClasspathResourceHelper() {\n\n        WebConfiguration webconfig = WebConfiguration.getInstance();\n        cacheTimestamp = webconfig.isOptionEnabled(CacheResourceModificationTimestamp);\n        enableMissingResourceLibraryDetection =\n                webconfig.isOptionEnabled(EnableMissingResourceLibraryDetection);\n\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final ClasspathResourceHelper other = (ClasspathResourceHelper) obj;\n        if (this.cacheTimestamp != other.cacheTimestamp) {\n            return false;\n        }\n        if (this.enableMissingResourceLibraryDetection != other.enableMissingResourceLibraryDetection) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 67 * hash + (this.cacheTimestamp ? 1 : 0);\n        hash = 67 * hash + (this.enableMissingResourceLibraryDetection ? 1 : 0);\n        return hash;\n    }\n\n    \n\n    // --------------------------------------------- Methods from ResourceHelper\n\n\n    /**\n     * @see com.sun.faces.application.resource.ResourceHelper#getBaseResourcePath()\n     */\n    @Override\n    public String getBaseResourcePath() {\n        return BASE_RESOURCE_PATH;\n    }\n\n    @Override\n    public String getBaseContractsPath() {\n        return META_INF_CONTRACTS_DIR;\n    }\n    \n    /**\n     * @see ResourceHelper#getNonCompressedInputStream(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext)\n     */\n    @Override\n    protected InputStream getNonCompressedInputStream(ResourceInfo resource, FacesContext ctx) throws IOException {\n\n        InputStream in = null;\n        \n        if (ctx.isProjectStage(Development)) {\n            ClassLoader loader = Util.getCurrentLoader(getClass());\n            String path = resource.getPath();\n            if (loader.getResource(path) != null) {\n                in = loader.getResource(path).openStream();\n            }\n            if (in == null && getClass().getClassLoader().getResource(path) != null) {\n                in = getClass().getClassLoader().getResource(path).openStream();\n            }\n        } else {        \n            ClassLoader loader = Util.getCurrentLoader(getClass());\n            String path = resource.getPath();\n            in = loader.getResourceAsStream(path);\n            if (in == null) {\n                in = getClass().getClassLoader().getResourceAsStream(path);\n            }\n        }\n        return in;\n    }\n\n\n    /**\n     * @see ResourceHelper#getURL(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext)\n     */\n    @Override\n    public URL getURL(ResourceInfo resource, FacesContext ctx) {\n        ResourceResolver nonDefaultResourceResolver = (ResourceResolver) ctx.getAttributes().get(DefaultResourceResolver.NON_DEFAULT_RESOURCE_RESOLVER_PARAM_NAME);\n        String path = resource.getPath();\n        URL url = null;\n        if (null != nonDefaultResourceResolver) {\n            url = nonDefaultResourceResolver.resolveUrl(path);\n        }\n        if (null == url) {\n            ClassLoader loader = Util.getCurrentLoader(this.getClass());\n            url = loader.getResource(path);\n            if (url == null) {\n                // try using this class' loader (necessary when running in OSGi)\n                url = this.getClass().getClassLoader().getResource(resource.getPath());\n            }\n        }\n        return url;\n\n    }\n\n    \n    /**\n     * @see ResourceHelper#findLibrary(String, String, String, javax.faces.context.FacesContext)\n     */\n    @Override\n    public LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        ClassLoader loader = Util.getCurrentLoader(this);\n        String basePath;\n        if (localePrefix == null) {\n            basePath = getBasePath(contract) + '/' + libraryName + '/';\n        } else {\n            basePath = getBasePath(contract)\n                       + '/'\n                       + localePrefix\n                       + '/'\n                       + libraryName\n                       + '/';\n        }\n\n        URL basePathURL = loader.getResource(basePath);\n        if (basePathURL == null) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                return null;\n            }\n        }\n\n        return new LibraryInfo(libraryName, null, localePrefix, contract, this);\n        \n    }\n\n    public LibraryInfo findLibraryWithZipDirectoryEntryScan(String libraryName,\n                                                            String localePrefix,\n                                                            String contract, FacesContext ctx, boolean forceScan) {\n\n        ClassLoader loader = Util.getCurrentLoader(this);\n        String basePath;\n        if (localePrefix == null) {\n            basePath = getBasePath(contract) + '/' + libraryName + '/';\n        } else {\n            basePath = getBasePath(contract)\n                       + '/'\n                       + localePrefix\n                       + '/'\n                       + libraryName\n                       + '/';\n        }\n\n        URL basePathURL = loader.getResource(basePath);\n        if (basePathURL == null) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                if (null != localePrefix && libraryName.equals(\"javax.faces\")) {\n                    return null;\n                }\n                if (enableMissingResourceLibraryDetection || forceScan) {\n                    if (null == libraryScanner) {\n                        libraryScanner = new ZipDirectoryEntryScanner();\n                    }\n                    if (!libraryScanner.libraryExists(libraryName, localePrefix)) {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return new LibraryInfo(libraryName, null, localePrefix, contract, this);\n    }\n\n    /**\n     * @see ResourceHelper#findResource(LibraryInfo, String, String, boolean, javax.faces.context.FacesContext)\n     */\n    @Override\n    public ResourceInfo findResource(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     boolean compressable,\n                                     FacesContext ctx) {\n\n        resourceName = trimLeadingSlash(resourceName);\n        ContractInfo [] outContract = new ContractInfo[1];\n        outContract[0] = null;\n        String [] outBasePath = new String[1];\n        outBasePath[0] = null;\n        \n        ClassLoader loader = Util.getCurrentLoader(this);\n        URL basePathURL = findPathConsideringContracts(loader, library, resourceName, \n                localePrefix, outContract, outBasePath, ctx);\n        String basePath = outBasePath[0];\n        if (null == basePathURL) {\n            basePath = deriveBasePath(library, resourceName, localePrefix);\n            basePathURL = loader.getResource(basePath);\n        }\n\n        if (null == basePathURL) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                // Try it without the localePrefix\n                if (library != null) {\n                    basePath = library.getPath(null) + '/' + resourceName;\n                } else {\n                    basePath = getBaseResourcePath() + '/' + resourceName;\n                }\n                basePathURL = loader.getResource(basePath);\n                if (basePathURL == null) {\n                    // try using this class' loader (necessary when running in OSGi)\n                    basePathURL = this.getClass().getClassLoader().getResource(basePath);\n                    if (basePathURL == null) {\n                        return null;\n                    }\n                }\n\n                localePrefix = null;\n            }\n        }\n\n        ClientResourceInfo value;\n\n        if (library != null) {\n            value = new ClientResourceInfo(library,\n                                     outContract[0],\n                                     resourceName,\n                                     null,\n                                     compressable,\n                                     resourceSupportsEL(resourceName, library.getName(), ctx),\n                                     ctx.isProjectStage(ProjectStage.Development),\n                                     cacheTimestamp);\n        } else {\n            value = new ClientResourceInfo(outContract[0],\n                                     resourceName,\n                                     null,\n                                     localePrefix,\n                                     this,\n                                     compressable,\n                                     resourceSupportsEL(resourceName, null, ctx),\n                                     ctx.isProjectStage(ProjectStage.Development),\n                                     cacheTimestamp);\n        }\n        \n        if (value.isCompressable()) {\n            value = handleCompression(value);\n        }\n        return value;\n\n    }\n    \n    private String deriveBasePath(LibraryInfo library,\n            String resourceName,\n            String localePrefix) {\n        String basePath = null;\n        if (library != null) {\n            basePath = library.getPath(localePrefix) + '/' + resourceName;\n        } else {\n            if (localePrefix == null) {\n                basePath = getBaseResourcePath() + '/' + resourceName;\n            } else {\n                basePath = getBaseResourcePath()\n                        + '/'\n                        + localePrefix\n                        + '/'\n                        + resourceName;\n            }\n        }            \n        return basePath;\n    }\n\n    private URL findPathConsideringContracts(ClassLoader loader, \n                                     LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     ContractInfo [] outContract,\n                                     String [] outBasePath,\n                                     FacesContext ctx) {\n        UIViewRoot root = ctx.getViewRoot();\n        List<String> contracts = null;\n        URL result = null;\n        \n        if (library != null) {\n            if(library.getContract() == null) {\n                contracts = Collections.emptyList();\n            } else {\n                contracts = new ArrayList<String>(1);\n                contracts.add(library.getContract());\n            }\n        } else if (root == null) {\n            String contractName = ctx.getExternalContext().getRequestParameterMap()\n                  .get(\"con\");\n            if (null != contractName && 0 < contractName.length()) {\n                contracts = new ArrayList<>();\n                contracts.add(contractName);\n            } else {\n                return null;\n            }\n        } else {\n       \t\tcontracts = ctx.getResourceLibraryContracts();\n        }\n\n        String basePath = null;\n        \n        for (String curContract : contracts) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseContractsPath() + '/' + curContract + '/' + resourceName;\n                } else {\n                    basePath = getBaseContractsPath()\n                            + '/' + curContract \n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            if (null != (result = loader.getResource(basePath))) {\n                outContract[0] = new ContractInfo(curContract);\n                outBasePath[0] = basePath;\n                break;\n            } else {\n                basePath = null;\n            }\n        }\n            \n        return result;\n    }\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Stream;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.application.ResourceVisitOption;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.Util;\n\n/**\n * This class is used to lookup {@link ResourceInfo} instances\n * and cache any that are successfully looked up to reduce the\n * computational overhead with the scanning/version checking.\n *\n * @since 2.0\n */\npublic class ResourceManager {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    /**\n     * {@link Pattern} for valid mime types to configure compression.\n     */\n    private static final Pattern CONFIG_MIMETYPE_PATTERN = Pattern.compile(\"[a-z-]*/[a-z0-9.\\\\*-]*\");\n    \n    private FaceletWebappResourceHelper faceletWebappResourceHelper = new FaceletWebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up webapp-based resources.\n     */\n    private ResourceHelper webappResourceHelper = new WebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up classpath-based resources.\n     */\n    private ClasspathResourceHelper classpathResourceHelper = new ClasspathResourceHelper();\n\n    /**\n     * Cache for storing {@link ResourceInfo} instances to reduce the cost\n     * of the resource lookups.\n     */\n    private ResourceCache cache;\n\n    /**\n     * Patterns used to find {@link ResourceInfo} instances that may have their\n     * content compressed.\n     */\n    private List<Pattern> compressableTypes;\n\n    /**\n     * This lock is used to ensure the lookup of compressable {@link ResourceInfo}\n     * instances are atomic to prevent theading issues when writing the compressed\n     * content during a lookup.\n     */\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    // ------------------------------------------------------------ Constructors\n\n    /*\n     * This ctor is only ever called by test code.\n     */\n\n    public ResourceManager(ResourceCache cache) {\n        this.cache = cache;\n        Map<String, Object> throwAwayMap = new HashMap<>();\n        initCompressableTypes(throwAwayMap);\n    }\n\n    /**\n     * Constructs a new <code>ResourceManager</code>.  Note:  if the current\n     * {@link ProjectStage} is {@link ProjectStage#Development} caching or\n     * {@link ResourceInfo} instances will not occur.\n     */\n    public ResourceManager(Map<String, Object> appMap, ResourceCache cache) {\n        this.cache = cache;\n        initCompressableTypes(appMap);\n    }\n\n\n    // ------------------------------------------------------ Public Methods\n\n\n    /**\n     * <p>\n     * Attempt to lookup a {@link ResourceInfo} based on the specified\n     * <code>libraryName<code> and <code>resourceName</code>\n     * </p>\n     *\n     * <p>\n     * Implementation Note:  Synchronization is necessary when looking up\n     * compressed resources.  This ensures the atomicity of the content\n     * being compressed.  As such, the cost of doing this is low as once\n     * the resource is in the cache, the lookup won't be performed again\n     * until the cache is cleared.  That said, it's not a good idea\n     * to have caching disabled in a production environment if leveraging\n     * compression.\n     *\n     * If the resource isn't compressable, then we don't worry about creating\n     * a few extra copies of ResourceInfo until the cache is populated.\n     * </p>\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param contentType the content type of the resource.  This will be\n     *  used to determine if the resource is compressable\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *  \n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, FacesContext ctx) {\n        return findResource(libraryName, resourceName, contentType, false, ctx);\n    }\n    \n    public ResourceInfo findViewResource(String resourceName, String contentType, FacesContext facesContext) {\n        String localePrefix = getLocalePrefix(facesContext);\n        List<String> contracts = getResourceLibraryContracts(facesContext);\n        \n        ResourceInfo info = getFromCache(resourceName, null, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, facesContext)) {\n                info = findResourceCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            } else {\n               info = findResourceNonCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            }\n        }\n\n        return info;\n    }\n    \n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, boolean isViewResource, FacesContext ctx) {\n        \n        String localePrefix = getLocalePrefix(ctx);\n        List<String> contracts = getResourceLibraryContracts(ctx);\n        \n        ResourceInfo info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, ctx)) {\n                info = findResourceCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            } else {\n               info = findResourceNonCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            }\n        }\n\n        return info;\n    }\n    \n    public Stream<String> getViewResources(FacesContext facesContext, String path, int maxDepth, ResourceVisitOption... options) {\n        return faceletWebappResourceHelper.getViewResources(facesContext, path, maxDepth, options);\n    }\n\n\n    // ----------------------------------------------------- Private Methods\n\n    private ResourceInfo findResourceCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        \n        ResourceInfo info = null;\n        \n        lock.lock();\n        try {\n            info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n            if (info == null) {\n                info = doLookup(libraryName, resourceName, localePrefix, true, isViewResource, contracts, ctx);\n                if (info != null) {\n                    addToCache(info, contracts);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        \n        return info;\n    }\n    \n    private ResourceInfo findResourceNonCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        ResourceInfo info = doLookup(libraryName, resourceName, localePrefix, false, isViewResource, contracts, ctx);\n\n        if (info == null && contracts != null) {\n            info = doLookup(libraryNameFromContracts(libraryName, contracts), resourceName, localePrefix, false, isViewResource, contracts, ctx);\n        }\n        \n        if (info != null && !info.isDoNotCache()) {\n            addToCache(info, contracts);\n        }\n        \n        return info;\n    }\n    \n    private String libraryNameFromContracts(String libraryName, List<String> contracts) {\n        // If the library name is equal to one of the contracts,\n        // assume the resource to be found is within that contract\n        for (String contract : contracts) {\n            if (contract.equals(libraryName)) {\n                return null;\n            }\n        }\n        \n        return libraryName;\n    }\n    \n\n    /**\n     * Attempt to look up the Resource based on the provided details.\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param localePrefix the locale prefix for this resource (if any)\n     * @param compressable if this resource can be compressed\n     * @param isViewResource \n     * @param contracts the contracts to consider\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *\n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    private ResourceInfo doLookup(String libraryName, String resourceName, String localePrefix, boolean compressable, boolean isViewResource, List<String> contracts, FacesContext ctx) {\n        \n        // Loop over the contracts as described in deriveResourceIdConsideringLocalePrefixAndContracts in the spec\n        for (String contract : contracts) {\n            ResourceInfo info = getResourceInfo(libraryName, resourceName, localePrefix, contract, compressable, isViewResource, ctx, null);\n            if (info != null) {\n                return info;\n            }\n        }\n        \n        return getResourceInfo(libraryName, resourceName, localePrefix, null, compressable, isViewResource, ctx, null);\n    }\n\n    private ResourceInfo getResourceInfo(String libraryName, String resourceName, String localePrefix, String contract, boolean compressable, boolean isViewResource, FacesContext ctx, LibraryInfo library) {\n        if (libraryName != null && !nameContainsForbiddenSequence(libraryName)) {\n            library = findLibrary(libraryName, localePrefix, contract, ctx);\n            \n            if (library == null && localePrefix != null) {\n                // no localized library found.  Try to find a library that isn't localized.\n                library = findLibrary(libraryName, null, contract, ctx);\n            }\n            \n            if (library == null) {\n                // If we don't have one by now, perhaps it's time to consider scanning directories.\n                library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, false);\n                \n                if (library == null && localePrefix != null) {\n                    // no localized library found.  Try to find\n                    // a library that isn't localized.\n                    library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, null, contract, ctx, false);\n                }\n                \n                if (library == null) {\n                    return null;\n                }\n            }\n        } else if (nameContainsForbiddenSequence(libraryName)) {\n            return null;\n        }\n\n        String resName = trimLeadingSlash(resourceName);\n        if (nameContainsForbiddenSequence(resName) || (!isViewResource && resName.startsWith(\"WEB-INF\"))) {\n            return null;\n        }\n\n        ResourceInfo info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n        if (info == null && localePrefix != null) {\n            // no localized resource found, try to find a\n            // resource that isn't localized\n            info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n        }\n\n        // If no resource has been found so far, and we have a library that\n        // was found in the webapp filesystem, see if there is a matching\n        // library on the classpath.  If one is found, try to find a matching\n        // resource in that library.\n        if (info == null && library != null && library.getHelper() instanceof WebappResourceHelper) {\n            LibraryInfo altLibrary = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n            if (altLibrary != null) {\n                VersionInfo originalVersion = library.getVersion();\n                VersionInfo altVersion = altLibrary.getVersion();\n                if (originalVersion == null && altVersion == null) {\n                    library = altLibrary;\n                } else if (originalVersion == null && altVersion != null) {\n                    library = null;\n                } else if (originalVersion != null && altVersion == null) {\n                    library = null;\n                } else if (originalVersion.compareTo(altVersion) == 0) {\n                    library = altLibrary;\n                }\n\n            }\n\n            if (library != null) {\n                info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n                if (info == null && localePrefix != null) {\n                    // no localized resource found, try to find a\n                    // resource that isn't localized\n                    info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n                }\n            }\n        }\n        \n        return info;\n    }\n\n    /**\n     * @param s input String\n     * @return the String without a leading slash if it has one.\n     */\n    private String trimLeadingSlash(String s) {\n        if (s.charAt(0) == '/') {\n            return s.substring(1);\n        } else {\n            return s;\n        }\n    }\n    \n    private static boolean nameContainsForbiddenSequence(String name) {\n        boolean result = false;\n        if (name != null) {\n            name = name.toLowerCase();\n    \n            result = name.startsWith(\".\") ||\n                     name.contains(\"../\") ||\n                     name.contains(\"..\\\\\") ||\n                     name.startsWith(\"/\") ||\n                     name.startsWith(\"\\\\\") ||\n                     name.endsWith(\"/\") ||\n    \n                     name.contains(\"..%2f\") ||\n                     name.contains(\"..%5c\") ||\n                     name.startsWith(\"%2f\") ||\n                     name.startsWith(\"%5c\") ||\n                     name.endsWith(\"%2f\") ||\n    \n                     name.contains(\"..\\\\u002f\") ||\n                     name.contains(\"..\\\\u005c\") ||\n                     name.startsWith(\"\\\\u002f\") ||\n                     name.startsWith(\"\\\\u005c\") ||\n                     name.endsWith(\"\\\\u002f\")\n    \n                    ;\n        }\n        \n        return result;\n    }\n\n\n    /**\n     *\n     * @param name the resource name\n     * @param library the library name\n     * @param localePrefix the Locale prefix\n     * @param contracts\n     * @return the {@link ResourceInfo} from the cache or <code>null</code>\n     *  if no cached entry is found\n     */\n    private ResourceInfo getFromCache(String name, String library, String localePrefix, List<String> contracts) {\n        if (cache == null) {\n            return null;\n        }\n        \n        return cache.get(name, library, localePrefix, contracts);\n    }\n\n\n    /**\n     * Adds the the specified {@link ResourceInfo} to the cache.\n     * @param info the @{link ResourceInfo} to add.\n     * @param contracts the contracts\n     */\n    private void addToCache(ResourceInfo info, List<String> contracts) {\n        if (cache == null) {\n            return;\n        }\n        \n        cache.add(info, contracts);\n    }\n\n    /**\n     * <p> Attempt to lookup and return a {@link LibraryInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application *within the resources directory*.  \n     * If the library is not found, then it processed to\n     * searching the classpath, if not found there, search from the webapp root\n     * *excluding* the resources directory.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     *\n     * @param libraryName the library to find\n     * @param localePrefix the prefix for the desired locale\n     * @param contract the contract to use\n     *@param ctx         the {@link javax.faces.context.FacesContext} for the current request\n     *  @return the Library instance for the specified library\n     */\n     LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        LibraryInfo library = webappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        \n        if (library == null) {\n            library = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n        \n        if (library == null && contract == null) {\n            // FCAPUTO facelets in contracts should have been found by the webapphelper already\n            library = faceletWebappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n\n        // if not library is found at this point, let the caller deal with it\n        return library;\n    }\n\n     LibraryInfo findLibraryOnClasspathWithZipDirectoryEntryScan(String libraryName,\n                                                                 String localePrefix,\n                                                                 String contract, FacesContext ctx, boolean forceScan) {\n         return classpathResourceHelper.findLibraryWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, forceScan);\n     }\n\n   /**\n     * <p> Attempt to lookup and return a {@link ResourceInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application.  If the library is not found, then it processed to\n     * searching the classpath.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     * @param library the library the resource should be found in\n     * @param resourceName the name of the resource\n     * @param localePrefix the prefix for the desired locale\n     * @param compressable <code>true</code> if the resource can be compressed\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current request\n     *\n     * @return the Library instance for the specified library\n     */\n    private ResourceInfo findResource(LibraryInfo library,\n                                      String resourceName,\n                                      String localePrefix,\n                                      boolean compressable,\n                                      boolean skipToFaceletResourceHelper,\n                                      FacesContext ctx) {\n\n        if (library != null) {\n            return library.getHelper().findResource(library,\n                                                    resourceName,\n                                                    localePrefix,\n                                                    compressable,\n                                                    ctx);\n        } else {\n            ResourceInfo resource = null;\n            \n            if (!skipToFaceletResourceHelper) {\n                resource = webappResourceHelper.findResource(null,\n                        resourceName,\n                        localePrefix,\n                        compressable,\n                        ctx);\n            }\n            if (resource == null && !skipToFaceletResourceHelper) {\n                resource = classpathResourceHelper.findResource(null,\n                                                        resourceName,\n                                                        localePrefix,\n                                                        compressable, \n                                                        ctx);\n            }\n            if (resource == null) {\n                resource = faceletWebappResourceHelper.findResource(library, \n                    resourceName, \n                    localePrefix, \n                    compressable, \n                    ctx);\n            }\n            return resource;\n        }\n\n    }\n    \n    ResourceInfo findResource(String resourceId) {\n        // PENDING(fcaputo) do we need to handle contracts here?\n        String libraryName = null;\n        String resourceName = null;\n        int end = 0, start = 0;\n        if (-1 != (end = resourceId.lastIndexOf(\"/\"))) {\n            resourceName = resourceId.substring(end+1);\n            if (-1 != (start = resourceId.lastIndexOf(\"/\", end - 1))) {\n                libraryName = resourceId.substring(start+1, end);\n            } else {\n                libraryName = resourceId.substring(0, end);\n            }\n        }\n        FacesContext context = FacesContext.getCurrentInstance();\n        LibraryInfo info = this.findLibrary(libraryName, null, null, context);\n        ResourceInfo resourceInfo = this.findResource(info, resourceName, libraryName, true, false, context);\n        \n        return resourceInfo;\n    }\n\n\n    /**\n     * <p>\n     * Obtains the application configured message resources for the current\n     * request locale.  If a ResourceBundle is found and contains the key\n     * <code>javax.faces.resource.localePrefix</code>, use the value associated\n     * with that key as the prefix for locale specific resources.\n     * </p>\n     *\n     * <p>\n     * For example, say the request locale is en_US, and\n     * <code>javax.faces.resourceLocalePrefix</code> is found with a value of\n     * <code>en</code>, a resource path within a web application might look like\n     * <code>/resources/en/corp/images/greetings.jpg</code>\n     * </p>\n     *\n     * @param context the {@link FacesContext} for the current request\n     * @return the localePrefix based on the current request, or <code>null</code>\n     *  if no prefix can be determined\n     */\n    private String getLocalePrefix(FacesContext context) {\n\n        String localePrefix = null;\n        \n        localePrefix = context.getExternalContext().getRequestParameterMap().get(\"loc\");\n        \n        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){\n            return localePrefix;\n        }\n        \n        String appBundleName = context.getApplication().getMessageBundle();\n        if (null != appBundleName) {\n        \t\n            Locale locale = null;\n            if (context.getViewRoot() != null) {\n                locale = context.getViewRoot().getLocale();\n            } else {\n                locale = context.getApplication().getViewHandler().calculateLocale(context);\n            }\n            \n                try {\n                    ResourceBundle appBundle =\n                          ResourceBundle.getBundle(appBundleName,\n                                                   locale,\n                                                   Util.getCurrentLoader(ResourceManager.class));\n                    localePrefix =\n                          appBundle\n                                .getString(ResourceHandler.LOCALE_PREFIX);\n                } catch (MissingResourceException mre) { \n                    if (LOGGER.isLoggable(Level.FINEST)) {\n                        LOGGER.log(Level.FINEST, \"Ignoring missing resource\", mre);\n                    }\n                }\n        }\n        return localePrefix;\n\n    }\n\n    private List<String> getResourceLibraryContracts(FacesContext context) {\n        UIViewRoot viewRoot = context.getViewRoot();\n        if(viewRoot == null) {\n\n            if(context.getApplication().getResourceHandler().isResourceRequest(context)) {\n                // it is a resource request. look at the parameter con=.\n\n                String param = context.getExternalContext().getRequestParameterMap().get(\"con\");\n                if(!nameContainsForbiddenSequence(param) && param != null && param.trim().length() > 0) {\n                    return Arrays.asList(param);\n                }\n            }\n            // PENDING(edburns): calculate the contracts!\n            return Collections.emptyList();\n        }\n        return context.getResourceLibraryContracts();\n    }\n\n\n    /**\n     * @param contentType content-type in question\n     * @param ctx the @{link FacesContext} for the current request\n     * @return <code>true</code> if this resource can be compressed, otherwise\n     *  <code>false</code>\n     */\n    private boolean isCompressable(String contentType, FacesContext ctx) {\n\n        // No compression when developing.\n        if (contentType == null || ctx.isProjectStage(ProjectStage.Development)) {\n            return false;\n        } else {\n            if (compressableTypes != null && !compressableTypes.isEmpty()) {\n                for (Pattern p : compressableTypes) {\n                    boolean matches = p.matcher(contentType).matches();\n                    if (matches) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n\n    }\n\n\n    /**\n     * Init <code>compressableTypes</code> from the configuration.\n     */\n    private void initCompressableTypes(Map<String, Object> appMap) {\n\n        WebConfiguration config = WebConfiguration.getInstance();\n        String value = config.getOptionValue(WebConfiguration.WebContextInitParameter.CompressableMimeTypes);\n        if (value != null && value.length() > 0) {\n            String[] values = Util.split(appMap, value, \",\");\n            if (values != null) {\n                for (String s : values) {\n                    String pattern = s.trim();\n                    if (!isPatternValid(pattern)) {\n                        continue;\n                    }\n                    if (pattern.endsWith(\"/*\")) {\n                        pattern = pattern.substring(0, pattern.indexOf(\"/*\"));\n                        pattern += \"/[a-z0-9.-]*\";\n                    }\n                    if (compressableTypes == null) {\n                        compressableTypes = new ArrayList<>(values.length);\n                    }\n                    try {\n                        compressableTypes.add(Pattern.compile(pattern));\n                    } catch (PatternSyntaxException pse) {\n                        if (LOGGER.isLoggable(Level.WARNING)) {\n                            // PENDING i18n\n                            LOGGER.log(Level.WARNING,\n                                       \"jsf.resource.mime.type.configration.invalid\",\n                                       new Object[] { pattern, pse.getPattern()});\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * @param input input mime-type pattern from the configuration\n     * @return <code>true</code> if the input matches the expected pattern,\n     *  otherwise <code>false</code>\n     */\n    private boolean isPatternValid(String input) {\n\n        return (CONFIG_MIMETYPE_PATTERN.matcher(input).matches());\n\n    }\n\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\n\nimport javax.faces.FacesException;\nimport javax.faces.application.ProjectStage;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.CacheResourceModificationTimestamp;\nimport com.sun.faces.facelets.impl.DefaultResourceResolver;\nimport javax.faces.view.facelets.ResourceResolver;\n\n/**\n * <p>\n * A {@link ResourceHelper} implementation for finding/serving resources\n * found within <code>&lt;contextroot&gt;/resources</code> directory of a\n * web application.\n * </p>\n *\n * @since 2.0\n */\npublic class WebappResourceHelper extends ResourceHelper {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    private final String BASE_RESOURCE_PATH;\n    \n    private final String BASE_CONTRACTS_PATH;\n\n    private boolean cacheTimestamp;\n\n\n    // ------------------------------------------------------------ Constructors\n\n\n    public WebappResourceHelper() {\n\n        WebConfiguration webconfig = WebConfiguration.getInstance();\n        cacheTimestamp = webconfig.isOptionEnabled(CacheResourceModificationTimestamp);\n        BASE_RESOURCE_PATH = webconfig.getOptionValue(WebConfiguration.WebContextInitParameter.WebAppResourcesDirectory);\n        BASE_CONTRACTS_PATH = webconfig.getOptionValue(WebConfiguration.WebContextInitParameter.WebAppContractsDirectory);\n\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final WebappResourceHelper other = (WebappResourceHelper) obj;\n        if ((this.BASE_RESOURCE_PATH == null) ? (other.BASE_RESOURCE_PATH != null) : !this.BASE_RESOURCE_PATH.equals(other.BASE_RESOURCE_PATH)) {\n            return false;\n        }\n        if ((this.BASE_CONTRACTS_PATH == null) ? (other.BASE_CONTRACTS_PATH != null) : !this.BASE_CONTRACTS_PATH.equals(other.BASE_CONTRACTS_PATH)) {\n            return false;\n        }\n        if (this.cacheTimestamp != other.cacheTimestamp) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 37 * hash + (this.BASE_RESOURCE_PATH != null ? this.BASE_RESOURCE_PATH.hashCode() : 0);\n        hash = 37 * hash + (this.BASE_CONTRACTS_PATH != null ? this.BASE_CONTRACTS_PATH.hashCode() : 0);\n        hash = 37 * hash + (this.cacheTimestamp ? 1 : 0);\n        return hash;\n    }\n\n    \n\n    // --------------------------------------------- Methods from ResourceHelper\n\n\n    /**\n     * @see com.sun.faces.application.resource.ResourceHelper#getBaseResourcePath()\n     */\n    @Override\n    public String getBaseResourcePath() {\n\n        return BASE_RESOURCE_PATH;\n\n    }\n\n    @Override\n    public String getBaseContractsPath() {\n        return BASE_CONTRACTS_PATH;\n    }\n    \n    /**\n     * @see ResourceHelper#getNonCompressedInputStream(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext) \n     */\n    @Override\n    protected InputStream getNonCompressedInputStream(ResourceInfo resource, FacesContext ctx)\n    throws IOException {\n\n        return ctx.getExternalContext().getResourceAsStream(resource.getPath());\n\n    }\n\n\n    /**\n     * @see ResourceHelper#getURL(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext) \n     */\n    @Override\n    public URL getURL(ResourceInfo resource, FacesContext ctx) {\n        ResourceResolver nonDefaultResourceResolver = (ResourceResolver) ctx.getAttributes().get(DefaultResourceResolver.NON_DEFAULT_RESOURCE_RESOLVER_PARAM_NAME);\n        String path = resource.getPath();\n        if (null != nonDefaultResourceResolver) {\n            return nonDefaultResourceResolver.resolveUrl(path);\n        }\n\n        try {\n            return ctx.getExternalContext().getResource(path);\n        } catch (MalformedURLException e) {\n            return null;\n        }\n\n    }\n    \n    \n\n\n    /**\n     * @see ResourceHelper#findLibrary(String, String, String, javax.faces.context.FacesContext)\n     */\n    @Override\n    public LibraryInfo findLibrary(String libraryName,\n                                   String localePrefix,\n                                   String contract, FacesContext ctx) {\n\n        String path;\n\n        if (localePrefix == null) {\n            path = getBasePath(contract) + '/' + libraryName;\n        } else {\n            path = getBasePath(contract)\n                   + '/'\n                   + localePrefix\n                   + '/'\n                   + libraryName;\n        }\n        Set<String> resourcePaths =\n              ctx.getExternalContext().getResourcePaths(path);\n        // it could be possible that there exists an empty directory\n        // that is representing the library, but if it's empty, treat it\n        // as non-existant and return null.\n        if (resourcePaths != null && !resourcePaths.isEmpty()) {\n            VersionInfo version = getVersion(resourcePaths, false);\n                return new LibraryInfo(libraryName, version, localePrefix, contract, this);\n        }\n\n        return null;\n    }\n\n\n    /**\n     * @see ResourceHelper#findResource(LibraryInfo, String, String, boolean, javax.faces.context.FacesContext)\n     */\n    @Override\n    public ResourceInfo findResource(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     boolean compressable,\n                                     FacesContext ctx) {\n        \n        resourceName = trimLeadingSlash(resourceName);\n        ContractInfo [] outContract = new ContractInfo[1];\n        outContract[0] = null;\n        \n        String basePath = findPathConsideringContracts(library, resourceName, \n                localePrefix, outContract, ctx);\n        \n        if (null == basePath) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseResourcePath() + '/' + resourceName;\n                } else {\n                    basePath = getBaseResourcePath()\n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            // first check to see if the resource exists, if not, return null.  Let\n            // the caller decide what to do.\n            try {\n                if (ctx.getExternalContext().getResource(basePath) == null) {\n                    return null;\n                }\n            } catch (MalformedURLException e) {\n                throw new FacesException(e);\n            }\n        }\n\n        // we got to hear, so we know the resource exists (either as a directory\n        // or file)\n        Set<String> resourcePaths =\n              ctx.getExternalContext().getResourcePaths(basePath);\n        // if getResourcePaths returns null or an empty set, this means that we have\n        // a non-directory resource, therefor, this resource isn't versioned.\n        ClientResourceInfo value;\n        if (resourcePaths == null || resourcePaths.size() == 0) {\n            if (library != null) {\n                value = new ClientResourceInfo(library,\n                                         outContract[0],\n                                         resourceName,\n                                         null,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, library.getName(), ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            } else {\n                value = new ClientResourceInfo(outContract[0], \n                                         resourceName,\n                                         null,\n                                         localePrefix,\n                                         this,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, null, ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            }\n        } else {\n            // ok, subdirectories exist, so find the latest 'version' directory\n            VersionInfo version = getVersion(resourcePaths, true);\n            if (version == null && LOGGER.isLoggable(Level.WARNING)) {\n                LOGGER.log(Level.WARNING,\n                        \"jsf.application.resource.unable_to_determine_resource_version.\",\n                        resourceName);\n            }\n            if (library != null) {\n                value = new ClientResourceInfo(library,\n                                         outContract[0],\n                                         resourceName,\n                                         version,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, library.getName(), ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            } else {\n                value = new ClientResourceInfo(outContract[0], \n                                         resourceName,\n                                         version,\n                                         localePrefix,\n                                         this,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, null, ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            }\n        }\n\n        if (value.isCompressable()) {\n            value = handleCompression(value);\n        }\n        return value;\n\n    }\n\n    private String findPathConsideringContracts(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     ContractInfo [] outContract,\n                                     FacesContext ctx) {\n        UIViewRoot root = ctx.getViewRoot();\n        List<String> contracts = null;\n\n        if (library != null) {\n            if(library.getContract() == null) {\n                contracts = Collections.emptyList();\n            } else {\n                contracts = new ArrayList<String>(1);\n                contracts.add(library.getContract());\n            }\n        } else if (root == null) {\n            String contractName = ctx.getExternalContext().getRequestParameterMap()\n                  .get(\"con\");\n            if (null != contractName && 0 < contractName.length()) {\n                contracts = new ArrayList<>();\n                contracts.add(contractName);\n            } else {\n                return null;\n            }\n        } else {\n        \tcontracts = ctx.getResourceLibraryContracts();\n        }\n\n        String basePath = null;\n        \n        for (String curContract : contracts) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseContractsPath() + '/' + curContract + '/' + resourceName;\n                } else {\n                    basePath = getBaseContractsPath()\n                            + '/' + curContract \n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            try {\n                if (ctx.getExternalContext().getResource(basePath) != null) {\n                    outContract[0] = new ContractInfo(curContract);\n                    break;\n                } else {\n                    basePath = null;\n                }\n            } catch (MalformedURLException e) {\n                throw new FacesException(e);\n            }\n        }\n            \n        return basePath;\n    }\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport static com.sun.faces.config.WebConfiguration.META_INF_CONTRACTS_DIR;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.CacheResourceModificationTimestamp;\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.EnableMissingResourceLibraryDetection;\nimport static javax.faces.application.ProjectStage.Development;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\nimport javax.faces.view.facelets.ResourceResolver;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.facelets.impl.DefaultResourceResolver;\nimport com.sun.faces.util.Util;\n\n\n/**\n * <p>\n * A {@link ResourceHelper} implementation for finding/serving resources\n * found on the classpath within the <code>META-INF/resources directory.\n * </p>\n *\n * @since 2.0\n */\npublic class ClasspathResourceHelper extends ResourceHelper {\n\n\n    private static final String BASE_RESOURCE_PATH = \"META-INF/resources\";\n    private boolean cacheTimestamp;\n    private volatile ZipDirectoryEntryScanner libraryScanner;\n    private boolean enableMissingResourceLibraryDetection;\n\n\n\n    // ------------------------------------------------------------ Constructors\n\n\n    public ClasspathResourceHelper() {\n\n        WebConfiguration webconfig = WebConfiguration.getInstance();\n        cacheTimestamp = webconfig.isOptionEnabled(CacheResourceModificationTimestamp);\n        enableMissingResourceLibraryDetection =\n                webconfig.isOptionEnabled(EnableMissingResourceLibraryDetection);\n\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final ClasspathResourceHelper other = (ClasspathResourceHelper) obj;\n        if (this.cacheTimestamp != other.cacheTimestamp) {\n            return false;\n        }\n        if (this.enableMissingResourceLibraryDetection != other.enableMissingResourceLibraryDetection) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 67 * hash + (this.cacheTimestamp ? 1 : 0);\n        hash = 67 * hash + (this.enableMissingResourceLibraryDetection ? 1 : 0);\n        return hash;\n    }\n\n    \n\n    // --------------------------------------------- Methods from ResourceHelper\n\n\n    /**\n     * @see com.sun.faces.application.resource.ResourceHelper#getBaseResourcePath()\n     */\n    @Override\n    public String getBaseResourcePath() {\n        return BASE_RESOURCE_PATH;\n    }\n\n    @Override\n    public String getBaseContractsPath() {\n        return META_INF_CONTRACTS_DIR;\n    }\n    \n    /**\n     * @see ResourceHelper#getNonCompressedInputStream(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext)\n     */\n    @Override\n    protected InputStream getNonCompressedInputStream(ResourceInfo resource, FacesContext ctx) throws IOException {\n\n        InputStream in = null;\n        \n        if (ctx.isProjectStage(Development)) {\n            ClassLoader loader = Util.getCurrentLoader(getClass());\n            String path = resource.getPath();\n            if (loader.getResource(path) != null) {\n                in = loader.getResource(path).openStream();\n            }\n            if (in == null && getClass().getClassLoader().getResource(path) != null) {\n                in = getClass().getClassLoader().getResource(path).openStream();\n            }\n        } else {        \n            ClassLoader loader = Util.getCurrentLoader(getClass());\n            String path = resource.getPath();\n            in = loader.getResourceAsStream(path);\n            if (in == null) {\n                in = getClass().getClassLoader().getResourceAsStream(path);\n            }\n        }\n        return in;\n    }\n\n\n    /**\n     * @see ResourceHelper#getURL(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext)\n     */\n    @Override\n    public URL getURL(ResourceInfo resource, FacesContext ctx) {\n        ResourceResolver nonDefaultResourceResolver = (ResourceResolver) ctx.getAttributes().get(DefaultResourceResolver.NON_DEFAULT_RESOURCE_RESOLVER_PARAM_NAME);\n        String path = resource.getPath();\n        URL url = null;\n        if (null != nonDefaultResourceResolver) {\n            url = nonDefaultResourceResolver.resolveUrl(path);\n        }\n        if (null == url) {\n            ClassLoader loader = Util.getCurrentLoader(this.getClass());\n            url = loader.getResource(path);\n            if (url == null) {\n                // try using this class' loader (necessary when running in OSGi)\n                url = this.getClass().getClassLoader().getResource(resource.getPath());\n            }\n        }\n        return url;\n\n    }\n\n    \n    /**\n     * @see ResourceHelper#findLibrary(String, String, String, javax.faces.context.FacesContext)\n     */\n    @Override\n    public LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        ClassLoader loader = Util.getCurrentLoader(this);\n        String basePath;\n        if (localePrefix == null) {\n            basePath = getBasePath(contract) + '/' + libraryName + '/';\n        } else {\n            basePath = getBasePath(contract)\n                       + '/'\n                       + localePrefix\n                       + '/'\n                       + libraryName\n                       + '/';\n        }\n\n        URL basePathURL = loader.getResource(basePath);\n        if (basePathURL == null) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                return null;\n            }\n        }\n\n        return new LibraryInfo(libraryName, null, localePrefix, contract, this);\n        \n    }\n\n    public LibraryInfo findLibraryWithZipDirectoryEntryScan(String libraryName,\n                                                            String localePrefix,\n                                                            String contract, FacesContext ctx, boolean forceScan) {\n\n        ClassLoader loader = Util.getCurrentLoader(this);\n        String basePath;\n        if (localePrefix == null) {\n            basePath = getBasePath(contract) + '/' + libraryName + '/';\n        } else {\n            basePath = getBasePath(contract)\n                       + '/'\n                       + localePrefix\n                       + '/'\n                       + libraryName\n                       + '/';\n        }\n\n        URL basePathURL = loader.getResource(basePath);\n        if (basePathURL == null) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                if (null != localePrefix && libraryName.equals(\"javax.faces\")) {\n                    return null;\n                }\n                if (enableMissingResourceLibraryDetection || forceScan) {\n                    if (null == libraryScanner) {\n                        libraryScanner = new ZipDirectoryEntryScanner();\n                    }\n                    if (!libraryScanner.libraryExists(libraryName, localePrefix)) {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        return new LibraryInfo(libraryName, null, localePrefix, contract, this);\n    }\n\n    /**\n     * @see ResourceHelper#findResource(LibraryInfo, String, String, boolean, javax.faces.context.FacesContext)\n     */\n    @Override\n    public ResourceInfo findResource(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     boolean compressable,\n                                     FacesContext ctx) {\n\n        resourceName = trimLeadingSlash(resourceName);\n        ContractInfo [] outContract = new ContractInfo[1];\n        outContract[0] = null;\n        String [] outBasePath = new String[1];\n        outBasePath[0] = null;\n        \n        ClassLoader loader = Util.getCurrentLoader(this);\n        URL basePathURL = findPathConsideringContracts(loader, library, resourceName, \n                localePrefix, outContract, outBasePath, ctx);\n        String basePath = outBasePath[0];\n        if (null == basePathURL) {\n            basePath = deriveBasePath(library, resourceName, localePrefix);\n            basePathURL = loader.getResource(basePath);\n        }\n\n        if (null == basePathURL) {\n            // try using this class' loader (necessary when running in OSGi)\n            basePathURL = this.getClass().getClassLoader().getResource(basePath);\n            if (basePathURL == null) {\n                // Try it without the localePrefix\n                if (library != null) {\n                    basePath = library.getPath(null) + '/' + resourceName;\n                } else {\n                    basePath = getBaseResourcePath() + '/' + resourceName;\n                }\n                basePathURL = loader.getResource(basePath);\n                if (basePathURL == null) {\n                    // try using this class' loader (necessary when running in OSGi)\n                    basePathURL = this.getClass().getClassLoader().getResource(basePath);\n                    if (basePathURL == null) {\n                        return null;\n                    }\n                }\n\n                localePrefix = null;\n            }\n        }\n\n        ClientResourceInfo value;\n\n        if (library != null) {\n            value = new ClientResourceInfo(library,\n                                     outContract[0],\n                                     resourceName,\n                                     null,\n                                     compressable,\n                                     resourceSupportsEL(resourceName, library.getName(), ctx),\n                                     ctx.isProjectStage(ProjectStage.Development),\n                                     cacheTimestamp);\n        } else {\n            value = new ClientResourceInfo(outContract[0],\n                                     resourceName,\n                                     null,\n                                     localePrefix,\n                                     this,\n                                     compressable,\n                                     resourceSupportsEL(resourceName, null, ctx),\n                                     ctx.isProjectStage(ProjectStage.Development),\n                                     cacheTimestamp);\n        }\n        \n        if (value.isCompressable()) {\n            value = handleCompression(value);\n        }\n        return value;\n\n    }\n    \n    private String deriveBasePath(LibraryInfo library,\n            String resourceName,\n            String localePrefix) {\n        String basePath = null;\n        if (library != null) {\n            basePath = library.getPath(localePrefix) + '/' + resourceName;\n        } else {\n            if (localePrefix == null) {\n                basePath = getBaseResourcePath() + '/' + resourceName;\n            } else {\n                basePath = getBaseResourcePath()\n                        + '/'\n                        + localePrefix\n                        + '/'\n                        + resourceName;\n            }\n        }            \n        return basePath;\n    }\n\n    private URL findPathConsideringContracts(ClassLoader loader, \n                                     LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     ContractInfo [] outContract,\n                                     String [] outBasePath,\n                                     FacesContext ctx) {\n        UIViewRoot root = ctx.getViewRoot();\n        List<String> contracts = null;\n        URL result = null;\n        \n        if (library != null) {\n            if(library.getContract() == null) {\n                contracts = Collections.emptyList();\n            } else {\n                contracts = new ArrayList<String>(1);\n                contracts.add(library.getContract());\n            }\n        } else if (root == null) {\n            String contractName = ctx.getExternalContext().getRequestParameterMap()\n                  .get(\"con\");\n            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {\n                contracts = new ArrayList<>();\n                contracts.add(contractName);\n            } else {\n                return null;\n            }\n        } else {\n       \t\tcontracts = ctx.getResourceLibraryContracts();\n        }\n\n        String basePath = null;\n        \n        for (String curContract : contracts) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseContractsPath() + '/' + curContract + '/' + resourceName;\n                } else {\n                    basePath = getBaseContractsPath()\n                            + '/' + curContract \n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            if (null != (result = loader.getResource(basePath))) {\n                outContract[0] = new ContractInfo(curContract);\n                outBasePath[0] = basePath;\n                break;\n            } else {\n                basePath = null;\n            }\n        }\n            \n        return result;\n    }\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Stream;\n\nimport javax.faces.application.ProjectStage;\nimport javax.faces.application.ResourceHandler;\nimport javax.faces.application.ResourceVisitOption;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\nimport com.sun.faces.util.Util;\n\n/**\n * This class is used to lookup {@link ResourceInfo} instances\n * and cache any that are successfully looked up to reduce the\n * computational overhead with the scanning/version checking.\n *\n * @since 2.0\n */\npublic class ResourceManager {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    /**\n     * {@link Pattern} for valid mime types to configure compression.\n     */\n    private static final Pattern CONFIG_MIMETYPE_PATTERN = Pattern.compile(\"[a-z-]*/[a-z0-9.\\\\*-]*\");\n    \n    private FaceletWebappResourceHelper faceletWebappResourceHelper = new FaceletWebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up webapp-based resources.\n     */\n    private ResourceHelper webappResourceHelper = new WebappResourceHelper();\n\n    /**\n     * {@link ResourceHelper} used for looking up classpath-based resources.\n     */\n    private ClasspathResourceHelper classpathResourceHelper = new ClasspathResourceHelper();\n\n    /**\n     * Cache for storing {@link ResourceInfo} instances to reduce the cost\n     * of the resource lookups.\n     */\n    private ResourceCache cache;\n\n    /**\n     * Patterns used to find {@link ResourceInfo} instances that may have their\n     * content compressed.\n     */\n    private List<Pattern> compressableTypes;\n\n    /**\n     * This lock is used to ensure the lookup of compressable {@link ResourceInfo}\n     * instances are atomic to prevent theading issues when writing the compressed\n     * content during a lookup.\n     */\n    private ReentrantLock lock = new ReentrantLock();\n\n\n    // ------------------------------------------------------------ Constructors\n\n    /*\n     * This ctor is only ever called by test code.\n     */\n\n    public ResourceManager(ResourceCache cache) {\n        this.cache = cache;\n        Map<String, Object> throwAwayMap = new HashMap<>();\n        initCompressableTypes(throwAwayMap);\n    }\n\n    /**\n     * Constructs a new <code>ResourceManager</code>.  Note:  if the current\n     * {@link ProjectStage} is {@link ProjectStage#Development} caching or\n     * {@link ResourceInfo} instances will not occur.\n     */\n    public ResourceManager(Map<String, Object> appMap, ResourceCache cache) {\n        this.cache = cache;\n        initCompressableTypes(appMap);\n    }\n\n\n    // ------------------------------------------------------ Public Methods\n\n\n    /**\n     * <p>\n     * Attempt to lookup a {@link ResourceInfo} based on the specified\n     * <code>libraryName<code> and <code>resourceName</code>\n     * </p>\n     *\n     * <p>\n     * Implementation Note:  Synchronization is necessary when looking up\n     * compressed resources.  This ensures the atomicity of the content\n     * being compressed.  As such, the cost of doing this is low as once\n     * the resource is in the cache, the lookup won't be performed again\n     * until the cache is cleared.  That said, it's not a good idea\n     * to have caching disabled in a production environment if leveraging\n     * compression.\n     *\n     * If the resource isn't compressable, then we don't worry about creating\n     * a few extra copies of ResourceInfo until the cache is populated.\n     * </p>\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param contentType the content type of the resource.  This will be\n     *  used to determine if the resource is compressable\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *  \n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, FacesContext ctx) {\n        return findResource(libraryName, resourceName, contentType, false, ctx);\n    }\n    \n    public ResourceInfo findViewResource(String resourceName, String contentType, FacesContext facesContext) {\n        String localePrefix = getLocalePrefix(facesContext);\n        List<String> contracts = getResourceLibraryContracts(facesContext);\n        \n        ResourceInfo info = getFromCache(resourceName, null, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, facesContext)) {\n                info = findResourceCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            } else {\n               info = findResourceNonCompressed(null, resourceName, true, localePrefix, contracts, facesContext);\n            }\n        }\n\n        return info;\n    }\n    \n    public ResourceInfo findResource(String libraryName, String resourceName, String contentType, boolean isViewResource, FacesContext ctx) {\n        \n        String localePrefix = getLocalePrefix(ctx);\n        List<String> contracts = getResourceLibraryContracts(ctx);\n        \n        ResourceInfo info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n        \n        if (info == null) {\n            if (isCompressable(contentType, ctx)) {\n                info = findResourceCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            } else {\n               info = findResourceNonCompressed(libraryName, resourceName, isViewResource, localePrefix, contracts, ctx);\n            }\n        }\n\n        return info;\n    }\n    \n    public Stream<String> getViewResources(FacesContext facesContext, String path, int maxDepth, ResourceVisitOption... options) {\n        return faceletWebappResourceHelper.getViewResources(facesContext, path, maxDepth, options);\n    }\n\n\n    // ----------------------------------------------------- Private Methods\n\n    private ResourceInfo findResourceCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        \n        ResourceInfo info = null;\n        \n        lock.lock();\n        try {\n            info = getFromCache(resourceName, libraryName, localePrefix, contracts);\n            if (info == null) {\n                info = doLookup(libraryName, resourceName, localePrefix, true, isViewResource, contracts, ctx);\n                if (info != null) {\n                    addToCache(info, contracts);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n        \n        return info;\n    }\n    \n    private ResourceInfo findResourceNonCompressed(String libraryName, String resourceName, boolean isViewResource, String localePrefix, List<String> contracts, FacesContext ctx) {\n        ResourceInfo info = doLookup(libraryName, resourceName, localePrefix, false, isViewResource, contracts, ctx);\n\n        if (info == null && contracts != null) {\n            info = doLookup(libraryNameFromContracts(libraryName, contracts), resourceName, localePrefix, false, isViewResource, contracts, ctx);\n        }\n        \n        if (info != null && !info.isDoNotCache()) {\n            addToCache(info, contracts);\n        }\n        \n        return info;\n    }\n    \n    private String libraryNameFromContracts(String libraryName, List<String> contracts) {\n        // If the library name is equal to one of the contracts,\n        // assume the resource to be found is within that contract\n        for (String contract : contracts) {\n            if (contract.equals(libraryName)) {\n                return null;\n            }\n        }\n        \n        return libraryName;\n    }\n    \n\n    /**\n     * Attempt to look up the Resource based on the provided details.\n     *\n     * @param libraryName the name of the library (if any)\n     * @param resourceName the name of the resource\n     * @param localePrefix the locale prefix for this resource (if any)\n     * @param compressable if this resource can be compressed\n     * @param isViewResource \n     * @param contracts the contracts to consider\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current\n     *  request\n     *\n     * @return a {@link ResourceInfo} if a resource if found matching the\n     *  provided arguments, otherwise, return <code>null</code>\n     */\n    private ResourceInfo doLookup(String libraryName, String resourceName, String localePrefix, boolean compressable, boolean isViewResource, List<String> contracts, FacesContext ctx) {\n        \n        // Loop over the contracts as described in deriveResourceIdConsideringLocalePrefixAndContracts in the spec\n        for (String contract : contracts) {\n            ResourceInfo info = getResourceInfo(libraryName, resourceName, localePrefix, contract, compressable, isViewResource, ctx, null);\n            if (info != null) {\n                return info;\n            }\n        }\n        \n        return getResourceInfo(libraryName, resourceName, localePrefix, null, compressable, isViewResource, ctx, null);\n    }\n\n    private ResourceInfo getResourceInfo(String libraryName, String resourceName, String localePrefix, String contract, boolean compressable, boolean isViewResource, FacesContext ctx, LibraryInfo library) {\n        if (libraryName != null && !nameContainsForbiddenSequence(libraryName)) {\n            library = findLibrary(libraryName, localePrefix, contract, ctx);\n            \n            if (library == null && localePrefix != null) {\n                // no localized library found.  Try to find a library that isn't localized.\n                library = findLibrary(libraryName, null, contract, ctx);\n            }\n            \n            if (library == null) {\n                // If we don't have one by now, perhaps it's time to consider scanning directories.\n                library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, false);\n                \n                if (library == null && localePrefix != null) {\n                    // no localized library found.  Try to find\n                    // a library that isn't localized.\n                    library = findLibraryOnClasspathWithZipDirectoryEntryScan(libraryName, null, contract, ctx, false);\n                }\n                \n                if (library == null) {\n                    return null;\n                }\n            }\n        } else if (nameContainsForbiddenSequence(libraryName)) {\n            return null;\n        }\n\n        String resName = trimLeadingSlash(resourceName);\n        if (nameContainsForbiddenSequence(resName) || (!isViewResource && resName.startsWith(\"WEB-INF\"))) {\n            return null;\n        }\n\n        ResourceInfo info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n        if (info == null && localePrefix != null) {\n            // no localized resource found, try to find a\n            // resource that isn't localized\n            info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n        }\n\n        // If no resource has been found so far, and we have a library that\n        // was found in the webapp filesystem, see if there is a matching\n        // library on the classpath.  If one is found, try to find a matching\n        // resource in that library.\n        if (info == null && library != null && library.getHelper() instanceof WebappResourceHelper) {\n            LibraryInfo altLibrary = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n            if (altLibrary != null) {\n                VersionInfo originalVersion = library.getVersion();\n                VersionInfo altVersion = altLibrary.getVersion();\n                if (originalVersion == null && altVersion == null) {\n                    library = altLibrary;\n                } else if (originalVersion == null && altVersion != null) {\n                    library = null;\n                } else if (originalVersion != null && altVersion == null) {\n                    library = null;\n                } else if (originalVersion.compareTo(altVersion) == 0) {\n                    library = altLibrary;\n                }\n\n            }\n\n            if (library != null) {\n                info = findResource(library, resourceName, localePrefix, compressable, isViewResource, ctx);\n                if (info == null && localePrefix != null) {\n                    // no localized resource found, try to find a\n                    // resource that isn't localized\n                    info = findResource(library, resourceName, null, compressable, isViewResource, ctx);\n                }\n            }\n        }\n        \n        return info;\n    }\n\n    /**\n     * @param s input String\n     * @return the String without a leading slash if it has one.\n     */\n    private String trimLeadingSlash(String s) {\n        if (s.charAt(0) == '/') {\n            return s.substring(1);\n        } else {\n            return s;\n        }\n    }\n    \n    static boolean nameContainsForbiddenSequence(String name) {\n        boolean result = false;\n        if (name != null) {\n            name = name.toLowerCase();\n    \n            result = name.startsWith(\".\") ||\n                     name.contains(\"../\") ||\n                     name.contains(\"..\\\\\") ||\n                     name.startsWith(\"/\") ||\n                     name.startsWith(\"\\\\\") ||\n                     name.endsWith(\"/\") ||\n    \n                     name.contains(\"..%2f\") ||\n                     name.contains(\"..%5c\") ||\n                     name.startsWith(\"%2f\") ||\n                     name.startsWith(\"%5c\") ||\n                     name.endsWith(\"%2f\") ||\n    \n                     name.contains(\"..\\\\u002f\") ||\n                     name.contains(\"..\\\\u005c\") ||\n                     name.startsWith(\"\\\\u002f\") ||\n                     name.startsWith(\"\\\\u005c\") ||\n                     name.endsWith(\"\\\\u002f\")\n    \n                    ;\n        }\n        \n        return result;\n    }\n\n\n    /**\n     *\n     * @param name the resource name\n     * @param library the library name\n     * @param localePrefix the Locale prefix\n     * @param contracts\n     * @return the {@link ResourceInfo} from the cache or <code>null</code>\n     *  if no cached entry is found\n     */\n    private ResourceInfo getFromCache(String name, String library, String localePrefix, List<String> contracts) {\n        if (cache == null) {\n            return null;\n        }\n        \n        return cache.get(name, library, localePrefix, contracts);\n    }\n\n\n    /**\n     * Adds the the specified {@link ResourceInfo} to the cache.\n     * @param info the @{link ResourceInfo} to add.\n     * @param contracts the contracts\n     */\n    private void addToCache(ResourceInfo info, List<String> contracts) {\n        if (cache == null) {\n            return;\n        }\n        \n        cache.add(info, contracts);\n    }\n\n    /**\n     * <p> Attempt to lookup and return a {@link LibraryInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application *within the resources directory*.  \n     * If the library is not found, then it processed to\n     * searching the classpath, if not found there, search from the webapp root\n     * *excluding* the resources directory.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     *\n     * @param libraryName the library to find\n     * @param localePrefix the prefix for the desired locale\n     * @param contract the contract to use\n     *@param ctx         the {@link javax.faces.context.FacesContext} for the current request\n     *  @return the Library instance for the specified library\n     */\n     LibraryInfo findLibrary(String libraryName, String localePrefix, String contract, FacesContext ctx) {\n\n        LibraryInfo library = webappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        \n        if (library == null) {\n            library = classpathResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n        \n        if (library == null && contract == null) {\n            // FCAPUTO facelets in contracts should have been found by the webapphelper already\n            library = faceletWebappResourceHelper.findLibrary(libraryName, localePrefix, contract, ctx);\n        }\n\n        // if not library is found at this point, let the caller deal with it\n        return library;\n    }\n\n     LibraryInfo findLibraryOnClasspathWithZipDirectoryEntryScan(String libraryName,\n                                                                 String localePrefix,\n                                                                 String contract, FacesContext ctx, boolean forceScan) {\n         return classpathResourceHelper.findLibraryWithZipDirectoryEntryScan(libraryName, localePrefix, contract, ctx, forceScan);\n     }\n\n   /**\n     * <p> Attempt to lookup and return a {@link ResourceInfo} based on the\n     * specified <code>arguments</code>.\n     * <p/>\n     * <p> The lookup process will first search the file system of the web\n     * application.  If the library is not found, then it processed to\n     * searching the classpath.</p>\n     * <p/>\n     * <p> If a library is found, this method will return a {@link\n     * LibraryInfo} instance that contains the name, version, and {@link\n     * ResourceHelper}.</p>\n     *\n     * @param library the library the resource should be found in\n     * @param resourceName the name of the resource\n     * @param localePrefix the prefix for the desired locale\n     * @param compressable <code>true</code> if the resource can be compressed\n     * @param ctx the {@link javax.faces.context.FacesContext} for the current request\n     *\n     * @return the Library instance for the specified library\n     */\n    private ResourceInfo findResource(LibraryInfo library,\n                                      String resourceName,\n                                      String localePrefix,\n                                      boolean compressable,\n                                      boolean skipToFaceletResourceHelper,\n                                      FacesContext ctx) {\n\n        if (library != null) {\n            return library.getHelper().findResource(library,\n                                                    resourceName,\n                                                    localePrefix,\n                                                    compressable,\n                                                    ctx);\n        } else {\n            ResourceInfo resource = null;\n            \n            if (!skipToFaceletResourceHelper) {\n                resource = webappResourceHelper.findResource(null,\n                        resourceName,\n                        localePrefix,\n                        compressable,\n                        ctx);\n            }\n            if (resource == null && !skipToFaceletResourceHelper) {\n                resource = classpathResourceHelper.findResource(null,\n                                                        resourceName,\n                                                        localePrefix,\n                                                        compressable, \n                                                        ctx);\n            }\n            if (resource == null) {\n                resource = faceletWebappResourceHelper.findResource(library, \n                    resourceName, \n                    localePrefix, \n                    compressable, \n                    ctx);\n            }\n            return resource;\n        }\n\n    }\n    \n    ResourceInfo findResource(String resourceId) {\n        // PENDING(fcaputo) do we need to handle contracts here?\n        String libraryName = null;\n        String resourceName = null;\n        int end = 0, start = 0;\n        if (-1 != (end = resourceId.lastIndexOf(\"/\"))) {\n            resourceName = resourceId.substring(end+1);\n            if (-1 != (start = resourceId.lastIndexOf(\"/\", end - 1))) {\n                libraryName = resourceId.substring(start+1, end);\n            } else {\n                libraryName = resourceId.substring(0, end);\n            }\n        }\n        FacesContext context = FacesContext.getCurrentInstance();\n        LibraryInfo info = this.findLibrary(libraryName, null, null, context);\n        ResourceInfo resourceInfo = this.findResource(info, resourceName, libraryName, true, false, context);\n        \n        return resourceInfo;\n    }\n\n\n    /**\n     * <p>\n     * Obtains the application configured message resources for the current\n     * request locale.  If a ResourceBundle is found and contains the key\n     * <code>javax.faces.resource.localePrefix</code>, use the value associated\n     * with that key as the prefix for locale specific resources.\n     * </p>\n     *\n     * <p>\n     * For example, say the request locale is en_US, and\n     * <code>javax.faces.resourceLocalePrefix</code> is found with a value of\n     * <code>en</code>, a resource path within a web application might look like\n     * <code>/resources/en/corp/images/greetings.jpg</code>\n     * </p>\n     *\n     * @param context the {@link FacesContext} for the current request\n     * @return the localePrefix based on the current request, or <code>null</code>\n     *  if no prefix can be determined\n     */\n    private String getLocalePrefix(FacesContext context) {\n\n        String localePrefix = null;\n        \n        localePrefix = context.getExternalContext().getRequestParameterMap().get(\"loc\");\n        \n        if(localePrefix != null && !nameContainsForbiddenSequence(localePrefix)){\n            return localePrefix;\n        } else {\n            localePrefix = null; \n        }\n        \n        String appBundleName = context.getApplication().getMessageBundle();\n        if (null != appBundleName) {\n        \t\n            Locale locale = null;\n            if (context.getViewRoot() != null) {\n                locale = context.getViewRoot().getLocale();\n            } else {\n                locale = context.getApplication().getViewHandler().calculateLocale(context);\n            }\n            \n                try {\n                    ResourceBundle appBundle =\n                          ResourceBundle.getBundle(appBundleName,\n                                                   locale,\n                                                   Util.getCurrentLoader(ResourceManager.class));\n                    localePrefix =\n                          appBundle\n                                .getString(ResourceHandler.LOCALE_PREFIX);\n                } catch (MissingResourceException mre) { \n                    if (LOGGER.isLoggable(Level.FINEST)) {\n                        LOGGER.log(Level.FINEST, \"Ignoring missing resource\", mre);\n                    }\n                }\n        }\n        return localePrefix;\n\n    }\n\n    private List<String> getResourceLibraryContracts(FacesContext context) {\n        UIViewRoot viewRoot = context.getViewRoot();\n        if(viewRoot == null) {\n\n            if(context.getApplication().getResourceHandler().isResourceRequest(context)) {\n                // it is a resource request. look at the parameter con=.\n\n                String param = context.getExternalContext().getRequestParameterMap().get(\"con\");\n                if(!nameContainsForbiddenSequence(param) && param != null && param.trim().length() > 0) {\n                    return Arrays.asList(param);\n                }\n            }\n            // PENDING(edburns): calculate the contracts!\n            return Collections.emptyList();\n        }\n        return context.getResourceLibraryContracts();\n    }\n\n\n    /**\n     * @param contentType content-type in question\n     * @param ctx the @{link FacesContext} for the current request\n     * @return <code>true</code> if this resource can be compressed, otherwise\n     *  <code>false</code>\n     */\n    private boolean isCompressable(String contentType, FacesContext ctx) {\n\n        // No compression when developing.\n        if (contentType == null || ctx.isProjectStage(ProjectStage.Development)) {\n            return false;\n        } else {\n            if (compressableTypes != null && !compressableTypes.isEmpty()) {\n                for (Pattern p : compressableTypes) {\n                    boolean matches = p.matcher(contentType).matches();\n                    if (matches) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n\n    }\n\n\n    /**\n     * Init <code>compressableTypes</code> from the configuration.\n     */\n    private void initCompressableTypes(Map<String, Object> appMap) {\n\n        WebConfiguration config = WebConfiguration.getInstance();\n        String value = config.getOptionValue(WebConfiguration.WebContextInitParameter.CompressableMimeTypes);\n        if (value != null && value.length() > 0) {\n            String[] values = Util.split(appMap, value, \",\");\n            if (values != null) {\n                for (String s : values) {\n                    String pattern = s.trim();\n                    if (!isPatternValid(pattern)) {\n                        continue;\n                    }\n                    if (pattern.endsWith(\"/*\")) {\n                        pattern = pattern.substring(0, pattern.indexOf(\"/*\"));\n                        pattern += \"/[a-z0-9.-]*\";\n                    }\n                    if (compressableTypes == null) {\n                        compressableTypes = new ArrayList<>(values.length);\n                    }\n                    try {\n                        compressableTypes.add(Pattern.compile(pattern));\n                    } catch (PatternSyntaxException pse) {\n                        if (LOGGER.isLoggable(Level.WARNING)) {\n                            // PENDING i18n\n                            LOGGER.log(Level.WARNING,\n                                       \"jsf.resource.mime.type.configration.invalid\",\n                                       new Object[] { pattern, pse.getPattern()});\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    /**\n     * @param input input mime-type pattern from the configuration\n     * @return <code>true</code> if the input matches the expected pattern,\n     *  otherwise <code>false</code>\n     */\n    private boolean isPatternValid(String input) {\n\n        return (CONFIG_MIMETYPE_PATTERN.matcher(input).matches());\n\n    }\n\n\n}\n", "/*\n * Copyright (c) 1997, 2018 Oracle and/or its affiliates. All rights reserved.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0, which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the\n * Eclipse Public License v. 2.0 are satisfied: GNU General Public License,\n * version 2 with the GNU Classpath Exception, which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n */\n\npackage com.sun.faces.application.resource;\n\nimport com.sun.faces.config.WebConfiguration;\nimport com.sun.faces.util.FacesLogger;\n\nimport javax.faces.FacesException;\nimport javax.faces.application.ProjectStage;\nimport javax.faces.component.UIViewRoot;\nimport javax.faces.context.FacesContext;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static com.sun.faces.config.WebConfiguration.BooleanWebContextInitParameter.CacheResourceModificationTimestamp;\nimport com.sun.faces.facelets.impl.DefaultResourceResolver;\nimport javax.faces.view.facelets.ResourceResolver;\n\n/**\n * <p>\n * A {@link ResourceHelper} implementation for finding/serving resources\n * found within <code>&lt;contextroot&gt;/resources</code> directory of a\n * web application.\n * </p>\n *\n * @since 2.0\n */\npublic class WebappResourceHelper extends ResourceHelper {\n\n    private static final Logger LOGGER = FacesLogger.RESOURCE.getLogger();\n\n    private final String BASE_RESOURCE_PATH;\n    \n    private final String BASE_CONTRACTS_PATH;\n\n    private boolean cacheTimestamp;\n\n\n    // ------------------------------------------------------------ Constructors\n\n\n    public WebappResourceHelper() {\n\n        WebConfiguration webconfig = WebConfiguration.getInstance();\n        cacheTimestamp = webconfig.isOptionEnabled(CacheResourceModificationTimestamp);\n        BASE_RESOURCE_PATH = webconfig.getOptionValue(WebConfiguration.WebContextInitParameter.WebAppResourcesDirectory);\n        BASE_CONTRACTS_PATH = webconfig.getOptionValue(WebConfiguration.WebContextInitParameter.WebAppContractsDirectory);\n\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (getClass() != obj.getClass()) {\n            return false;\n        }\n        final WebappResourceHelper other = (WebappResourceHelper) obj;\n        if ((this.BASE_RESOURCE_PATH == null) ? (other.BASE_RESOURCE_PATH != null) : !this.BASE_RESOURCE_PATH.equals(other.BASE_RESOURCE_PATH)) {\n            return false;\n        }\n        if ((this.BASE_CONTRACTS_PATH == null) ? (other.BASE_CONTRACTS_PATH != null) : !this.BASE_CONTRACTS_PATH.equals(other.BASE_CONTRACTS_PATH)) {\n            return false;\n        }\n        if (this.cacheTimestamp != other.cacheTimestamp) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 37 * hash + (this.BASE_RESOURCE_PATH != null ? this.BASE_RESOURCE_PATH.hashCode() : 0);\n        hash = 37 * hash + (this.BASE_CONTRACTS_PATH != null ? this.BASE_CONTRACTS_PATH.hashCode() : 0);\n        hash = 37 * hash + (this.cacheTimestamp ? 1 : 0);\n        return hash;\n    }\n\n    \n\n    // --------------------------------------------- Methods from ResourceHelper\n\n\n    /**\n     * @see com.sun.faces.application.resource.ResourceHelper#getBaseResourcePath()\n     */\n    @Override\n    public String getBaseResourcePath() {\n\n        return BASE_RESOURCE_PATH;\n\n    }\n\n    @Override\n    public String getBaseContractsPath() {\n        return BASE_CONTRACTS_PATH;\n    }\n    \n    /**\n     * @see ResourceHelper#getNonCompressedInputStream(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext) \n     */\n    @Override\n    protected InputStream getNonCompressedInputStream(ResourceInfo resource, FacesContext ctx)\n    throws IOException {\n\n        return ctx.getExternalContext().getResourceAsStream(resource.getPath());\n\n    }\n\n\n    /**\n     * @see ResourceHelper#getURL(com.sun.faces.application.resource.ResourceInfo, javax.faces.context.FacesContext) \n     */\n    @Override\n    public URL getURL(ResourceInfo resource, FacesContext ctx) {\n        ResourceResolver nonDefaultResourceResolver = (ResourceResolver) ctx.getAttributes().get(DefaultResourceResolver.NON_DEFAULT_RESOURCE_RESOLVER_PARAM_NAME);\n        String path = resource.getPath();\n        if (null != nonDefaultResourceResolver) {\n            return nonDefaultResourceResolver.resolveUrl(path);\n        }\n\n        try {\n            return ctx.getExternalContext().getResource(path);\n        } catch (MalformedURLException e) {\n            return null;\n        }\n\n    }\n    \n    \n\n\n    /**\n     * @see ResourceHelper#findLibrary(String, String, String, javax.faces.context.FacesContext)\n     */\n    @Override\n    public LibraryInfo findLibrary(String libraryName,\n                                   String localePrefix,\n                                   String contract, FacesContext ctx) {\n\n        String path;\n\n        if (localePrefix == null) {\n            path = getBasePath(contract) + '/' + libraryName;\n        } else {\n            path = getBasePath(contract)\n                   + '/'\n                   + localePrefix\n                   + '/'\n                   + libraryName;\n        }\n        Set<String> resourcePaths =\n              ctx.getExternalContext().getResourcePaths(path);\n        // it could be possible that there exists an empty directory\n        // that is representing the library, but if it's empty, treat it\n        // as non-existant and return null.\n        if (resourcePaths != null && !resourcePaths.isEmpty()) {\n            VersionInfo version = getVersion(resourcePaths, false);\n                return new LibraryInfo(libraryName, version, localePrefix, contract, this);\n        }\n\n        return null;\n    }\n\n\n    /**\n     * @see ResourceHelper#findResource(LibraryInfo, String, String, boolean, javax.faces.context.FacesContext)\n     */\n    @Override\n    public ResourceInfo findResource(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     boolean compressable,\n                                     FacesContext ctx) {\n        \n        resourceName = trimLeadingSlash(resourceName);\n        ContractInfo [] outContract = new ContractInfo[1];\n        outContract[0] = null;\n        \n        String basePath = findPathConsideringContracts(library, resourceName, \n                localePrefix, outContract, ctx);\n        \n        if (null == basePath) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseResourcePath() + '/' + resourceName;\n                } else {\n                    basePath = getBaseResourcePath()\n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            // first check to see if the resource exists, if not, return null.  Let\n            // the caller decide what to do.\n            try {\n                if (ctx.getExternalContext().getResource(basePath) == null) {\n                    return null;\n                }\n            } catch (MalformedURLException e) {\n                throw new FacesException(e);\n            }\n        }\n\n        // we got to hear, so we know the resource exists (either as a directory\n        // or file)\n        Set<String> resourcePaths =\n              ctx.getExternalContext().getResourcePaths(basePath);\n        // if getResourcePaths returns null or an empty set, this means that we have\n        // a non-directory resource, therefor, this resource isn't versioned.\n        ClientResourceInfo value;\n        if (resourcePaths == null || resourcePaths.size() == 0) {\n            if (library != null) {\n                value = new ClientResourceInfo(library,\n                                         outContract[0],\n                                         resourceName,\n                                         null,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, library.getName(), ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            } else {\n                value = new ClientResourceInfo(outContract[0], \n                                         resourceName,\n                                         null,\n                                         localePrefix,\n                                         this,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, null, ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            }\n        } else {\n            // ok, subdirectories exist, so find the latest 'version' directory\n            VersionInfo version = getVersion(resourcePaths, true);\n            if (version == null && LOGGER.isLoggable(Level.WARNING)) {\n                LOGGER.log(Level.WARNING,\n                        \"jsf.application.resource.unable_to_determine_resource_version.\",\n                        resourceName);\n            }\n            if (library != null) {\n                value = new ClientResourceInfo(library,\n                                         outContract[0],\n                                         resourceName,\n                                         version,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, library.getName(), ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            } else {\n                value = new ClientResourceInfo(outContract[0], \n                                         resourceName,\n                                         version,\n                                         localePrefix,\n                                         this,\n                                         compressable,\n                                         resourceSupportsEL(resourceName, null, ctx),\n                                         ctx.isProjectStage(ProjectStage.Development),\n                                         cacheTimestamp);\n            }\n        }\n\n        if (value.isCompressable()) {\n            value = handleCompression(value);\n        }\n        return value;\n\n    }\n\n    private String findPathConsideringContracts(LibraryInfo library,\n                                     String resourceName,\n                                     String localePrefix,\n                                     ContractInfo [] outContract,\n                                     FacesContext ctx) {\n        UIViewRoot root = ctx.getViewRoot();\n        List<String> contracts = null;\n\n        if (library != null) {\n            if(library.getContract() == null) {\n                contracts = Collections.emptyList();\n            } else {\n                contracts = new ArrayList<String>(1);\n                contracts.add(library.getContract());\n            }\n        } else if (root == null) {\n            String contractName = ctx.getExternalContext().getRequestParameterMap()\n                  .get(\"con\");\n            if (null != contractName && 0 < contractName.length() && !ResourceManager.nameContainsForbiddenSequence(contractName)) {\n                contracts = new ArrayList<>();\n                contracts.add(contractName);\n            } else {\n                return null;\n            }\n        } else {\n        \tcontracts = ctx.getResourceLibraryContracts();\n        }\n\n        String basePath = null;\n        \n        for (String curContract : contracts) {\n        \n            if (library != null) {\n                // PENDING(fcaputo) no need to iterate over the contracts, if we have a library\n                basePath = library.getPath(localePrefix) + '/' + resourceName;\n            } else {\n                if (localePrefix == null) {\n                    basePath = getBaseContractsPath() + '/' + curContract + '/' + resourceName;\n                } else {\n                    basePath = getBaseContractsPath()\n                            + '/' + curContract \n                            + '/'\n                            + localePrefix\n                            + '/'\n                            + resourceName;\n                }\n            }\n            \n            try {\n                if (ctx.getExternalContext().getResource(basePath) != null) {\n                    outContract[0] = new ContractInfo(curContract);\n                    break;\n                } else {\n                    basePath = null;\n                }\n            } catch (MalformedURLException e) {\n                throw new FacesException(e);\n            }\n        }\n            \n        return basePath;\n    }\n\n}\n"], "filenames": ["impl/src/main/java/com/sun/faces/application/resource/ClasspathResourceHelper.java", "impl/src/main/java/com/sun/faces/application/resource/ResourceManager.java", "impl/src/main/java/com/sun/faces/application/resource/WebappResourceHelper.java"], "buggy_code_start_loc": [358, 354, 318], "buggy_code_end_loc": [359, 569, 319], "fixing_code_start_loc": [358, 354, 318], "fixing_code_end_loc": [359, 572, 319], "type": "CWE-22", "message": "Directory traversal in Eclipse Mojarra before 2.3.14 allows attackers to read arbitrary files via the loc parameter or con parameter.", "other": {"cve": {"id": "CVE-2020-6950", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-02T16:15:08.357", "lastModified": "2022-05-12T14:06:59.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Directory traversal in Eclipse Mojarra before 2.3.14 allows attackers to read arbitrary files via the loc parameter or con parameter."}, {"lang": "es", "value": "Una vulnerabilidad de Salto de Directorio en Eclipse Mojarra versiones anteriores a 2.3.14, permite a atacantes leer archivos arbitrarios por medio del par\u00e1metro loc o del par\u00e1metro con"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:mojarra:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.14", "matchCriteriaId": "66404103-D535-4D06-BC59-5A62894A8688"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_enterprise_default_management:2.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "74C7E2F1-17FC-4322-A5C3-F7EB612BA4F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_enterprise_default_management:2.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "320D36DA-D99F-4149-B582-3F4AB2F41A1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "132CE62A-FBFC-4001-81EC-35D81F73AF48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "645AA3D1-C8B5-4CD2-8ACE-31541FA267F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "AB9FC9AB-1070-420F-870E-A5EC43A924A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "BDC6D658-09EA-4C41-869F-1C2EA163F751"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_network_integrity:7.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "B21E6EEF-2AB7-4E96-B092-1F49D11B4175"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_pricing_design_center:12.0.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7B49D71-6A31-497A-B6A9-06E84F086E7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:hyperion_calculation_manager:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.2.8.0", "matchCriteriaId": "46F62908-6044-487E-A625-86083A099304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_merchandising_system:19.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "AE1BC44A-F0AF-41CD-9CEB-B07AB5ADAB38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:solaris_cluster:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "87A83709-4D38-4844-8928-0C2D6F2033BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:time_and_labor:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.2.6", "versionEndIncluding": "12.2.11", "matchCriteriaId": "19A74710-0E0F-4123-A64C-0684824D13CA"}]}]}], "references": [{"url": "https://bugs.eclipse.org/bugs/show_bug.cgi?id=550943", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/commit/cefbb9447e7be560e59da2da6bd7cb93776f7741", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-ee4j/mojarra/issues/4571", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/eclipse-ee4j/mojarra/commit/cefbb9447e7be560e59da2da6bd7cb93776f7741"}}