{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.Right;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.util.Programming;\n\n/**\n * Information about a deleted document in the recycle bin.\n *\n * @version $Id$\n */\npublic class DeletedDocument extends Api\n{\n    private static final String ADMIN_RIGHT = \"admin\";\n\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeletedDocument.class);\n\n    /**\n     * The internal object wrapped by this API.\n     */\n    private final XWikiDeletedDocument deletedDoc;\n\n    /**\n     * Simple constructor, initializes a new API object with the current {@link com.xpn.xwiki.XWikiContext context} and\n     * the specified protected {@link com.xpn.xwiki.doc.XWikiDeletedDocument deleted document} object.\n     *\n     * @param deletedDoc the internal object wrapped by this API\n     * @param context the current request context\n     */\n    public DeletedDocument(XWikiDeletedDocument deletedDoc, XWikiContext context)\n    {\n        super(context);\n        this.deletedDoc = deletedDoc;\n    }\n\n    /**\n     * @return full name of document (ie: Main.WebHome)\n     */\n    public String getFullName()\n    {\n        return this.deletedDoc.getFullName();\n    }\n\n    /**\n     * @return locale of document\n     * @deprecated since 8.0M1, use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.deletedDoc.getLanguage();\n    }\n\n    /**\n     * @return locale of document\n     * @since 8.0M1\n     */\n    public Locale getLocale()\n    {\n        return this.deletedDoc.getLocale();\n    }\n\n    /**\n     * @return date of delete action\n     */\n    public Date getDate()\n    {\n        return this.deletedDoc.getDate();\n    }\n\n    /**\n     * @return user which delete document\n     */\n    public String getDeleter()\n    {\n        return this.deletedDoc.getDeleter();\n    }\n\n    /**\n     * @return the reference of the user who deleted this document\n     * @since 11.5RC1\n     */\n    public DocumentReference getDeleterReference()\n    {\n        return this.deletedDoc.getDeleterReference();\n    }\n\n    /**\n     * @return id of deleted document. id is unique only for this document.\n     */\n    public long getId()\n    {\n        return this.deletedDoc.getId();\n    }\n\n    /**\n     * @return the id of the operation that deleted multiple documents at the same time, including this one\n     * @since 9.4RC1\n     */\n    public String getBatchId()\n    {\n        return this.deletedDoc.getBatchId();\n    }\n\n    /**\n     * Check if the current user has the right to restore the document.\n     *\n     * @return {@code true} if the current user can restore this document, {@code false} otherwise\n     */\n    public boolean canUndelete()\n    {\n        try {\n            return hasAccessLevel(ADMIN_RIGHT, getFullName()) || hasAccessLevel(\"undelete\", getFullName())\n                || (Objects.equals(this.context.getUserReference(), getDeleterReference())\n                    && hasAccess(Right.EDIT, getDocumentReference()));\n        } catch (XWikiException ex) {\n            // Public APIs should not throw exceptions\n            LOGGER.warn(\"Exception while checking if entry [{}] can be restored from the recycle bin\", getId(), ex);\n            return false;\n        }\n    }\n\n    /**\n     * @return {@code true} if the current user can permanently delete this document, {@code false} otherwise\n     * @xwiki.xwikicfg xwiki.store.recyclebin.adminWaitDays How many days should an administrator wait before being able\n     *                 to permanently delete this document from the recycle bin. 0 by default.\n     * @xwiki.xwikicfg xwiki.store.recyclebin.waitDays How many days should a normal user with \"delete\" right wait\n     *                 before being able to permanently delete this document from the recycle bin. 7 by default.\n     */\n    public boolean canDelete()\n    {\n        try {\n            XWikiDocument doc = new XWikiDocument();\n            doc.setFullName(getFullName(), this.context);\n            if (!hasAccessLevel(\"delete\", getFullName())) {\n                return false;\n            }\n            String waitdays;\n            if (hasAccessLevel(ADMIN_RIGHT, getFullName())) {\n                waitdays = getXWikiContext().getWiki().Param(\"xwiki.store.recyclebin.adminWaitDays\", \"0\");\n            } else {\n                waitdays = getXWikiContext().getWiki().Param(\"xwiki.store.recyclebin.waitDays\", \"7\");\n            }\n            int seconds = (int) (Double.parseDouble(waitdays) * 24 * 60 * 60 + 0.5);\n            Calendar cal = Calendar.getInstance();\n            cal.setTime(getDate());\n            cal.add(Calendar.SECOND, seconds);\n            return cal.before(Calendar.getInstance());\n        } catch (Exception ex) {\n            // Public APIs should not throw exceptions\n            LOGGER.warn(\"Exception while checking if entry [{}] can be removed from the recycle bin\", getId(), ex);\n            return false;\n        }\n    }\n\n    /**\n     * @return original deleted document if user has programming rights, else {@code null}.\n     */\n    @Programming\n    public XWikiDeletedDocument getDeletedDocument()\n    {\n        if (hasProgrammingRights()) {\n            return this.deletedDoc;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @return the document as it is in the recycle bin if the user is allowed to restore it, {@code null} otherwise\n     */\n    public Document getDocument()\n    {\n        if (canUndelete()) {\n            try {\n                return new Document(this.deletedDoc.restoreDocument(null, this.context), this.context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to parse deleted document [{}]\", getFullName(), e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the document reference for the deleted document, including any locale information\n     * @since 9.4RC1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        return this.deletedDoc.getDocumentReference();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport org.xwiki.component.annotation.Role;\nimport org.xwiki.model.reference.DocumentReference;\n\nimport com.xpn.xwiki.XWikiException;\n\n/**\n * Provide generic way of requesting a specific revision of a document from several sources (database, installed XAR\n * extension, etc.).\n * <p>\n * The revision syntax is {@code <provider hint>:<revision>}, default provide being database (the version of the\n * document in the history).\n * \n * @version $Id$\n * @since 9.4RC1\n */\n@Role\npublic interface DocumentRevisionProvider\n{\n    /**\n     * Load the document in the provided revision.\n     * \n     * @param reference the reference of the document\n     * @param revision the revision of the document\n     * @return the {@link XWikiDocument} instance or null if none existing\n     * @throws XWikiException when failing to load the document revision\n     */\n    XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException;\n\n    /**\n     * Load the document in the provided revision.\n     * \n     * @param document the current document\n     * @param revision the revision of the document\n     * @return the {@link XWikiDocument} instance or null if none existing\n     * @throws XWikiException when failing to load the document revision\n     */\n    XWikiDocument getRevision(XWikiDocument document, String revision) throws XWikiException;\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.internal.store.hibernate.XWikiHibernateDeletedDocumentContent;\nimport com.xpn.xwiki.util.AbstractSimpleClass;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Archive of deleted document, stored in {@link com.xpn.xwiki.store.XWikiRecycleBinStoreInterface}. Immutable, because\n * we don't need modify deleted document.\n *\n * @version $Id$\n * @since 1.2M1\n */\npublic class XWikiDeletedDocument extends AbstractSimpleClass\n{\n    /**\n     * Synthetic id.\n     */\n    private long id;\n\n    /**\n     * @see XWikiDocument#getFullName()\n     */\n    private String fullName;\n\n    /**\n     * @see XWikiDocument#getLocale()\n     */\n    private Locale locale;\n\n    /**\n     * date of delete action.\n     */\n    private Date date;\n\n    /**\n     * @see XWikiDeletedDocument#getDeleter()\n     */\n    private String deleter;\n\n    private String xmlStore;\n\n    private XWikiDeletedDocumentContent content;\n\n    private String batchId;\n\n    /**\n     * Default constructor. Used only in hibernate.\n     */\n    protected XWikiDeletedDocument()\n    {\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType - the way to store the document\n     * @param deleter - user which delete document\n     * @param deleteDate - date of delete action\n     * @throws XWikiException if any error\n     * @since 9.0RC1\n     */\n    private XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate)\n        throws XWikiException\n    {\n        this.fullName = fullName;\n        this.locale = locale;\n        this.deleter = deleter;\n        this.date = deleteDate;\n        this.xmlStore = storeType;\n    }\n\n    /**\n     * @param doc - deleted document\n     * @param deleter - user which delete document\n     * @param deleteDate - date of delete action\n     * @param context - used for environment\n     * @throws XWikiException if any error\n     */\n    public XWikiDeletedDocument(XWikiDocument doc, String deleter, Date deleteDate, XWikiContext context)\n        throws XWikiException\n    {\n        this(doc.getFullName(), doc.getLocale(), null, deleter, deleteDate);\n\n        setDocument(doc, context);\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType the way to store the document\n     * @param deleter the user who delete document\n     * @param deleteDate date of delete action\n     * @param content the stored deleted document\n     * @throws XWikiException if any error\n     * @since 9.0RC1\n     */\n    public XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate,\n        XWikiDeletedDocumentContent content) throws XWikiException\n    {\n        this(fullName, locale, storeType, deleter, deleteDate);\n\n        this.content = content;\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType the way to store the document\n     * @param deleter the user who delete document\n     * @param deleteDate date of delete action\n     * @param content the stored deleted document\n     * @param batchId the id of the batch deletion\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate,\n        XWikiDeletedDocumentContent content, String batchId) throws XWikiException\n    {\n        this(fullName, locale, storeType, deleter, deleteDate, content);\n\n        this.batchId = batchId;\n    }\n\n    /**\n     * @return the synthetic id of this deleted document. unique only for document.\n     */\n    public long getId()\n    {\n        return this.id;\n    }\n\n    /**\n     * @param id - the synthetic id to set. used only in Hibernate.\n     */\n    protected void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * @return {@link XWikiDocument#getFullName()}\n     */\n    public String getFullName()\n    {\n        return this.fullName;\n    }\n\n    /**\n     * @param docFullName - {@link XWikiDocument#getFullName()} to set\n     */\n    protected void setFullName(String docFullName)\n    {\n        this.fullName = docFullName;\n    }\n\n    /**\n     * @return the document reference for the deleted document, including any locale information\n     * @since 9.4RC1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        DocumentReference documentReference = getDocumentReferenceResolver().resolve(getFullName());\n\n        Locale localeValue = getLocale();\n        if (localeValue != null) {\n            documentReference = new DocumentReference(documentReference, localeValue);\n        }\n\n        return documentReference;\n    }\n\n    private static DocumentReferenceResolver<String> getDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * @return {@link XWikiDocument#getLanguage()}\n     * @deprecated since 8.0M1, use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * @return {@link XWikiDocument#getLocale()}\n     * @since 8.0M1\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale - {@link XWikiDocument#getLanguage()} to set\n     * @deprecated since 8.0M1\n     */\n    @Deprecated\n    protected void setLanguage(String locale)\n    {\n        this.locale = LocaleUtils.toLocale(Util.normalizeLanguage(locale), Locale.ROOT);\n    }\n\n    /**\n     * @return the date of delete action\n     */\n    public Date getDate()\n    {\n        return this.date;\n    }\n\n    /**\n     * @param date - the date of delete action to set\n     */\n    protected void setDate(Date date)\n    {\n        this.date = date;\n    }\n\n    /**\n     * @return the user which has removed the document\n     */\n    public String getDeleter()\n    {\n        return this.deleter;\n    }\n\n    /**\n     * @return the reference of the user who deleted this document\n     * @since 11.5RC1\n     */\n    public DocumentReference getDeleterReference()\n    {\n        return getDocumentReferenceResolver().resolve(this.deleter);\n    }\n\n    /**\n     * @param deleter - the user which has removed the document to set\n     */\n    protected void setDeleter(String deleter)\n    {\n        this.deleter = deleter;\n    }\n\n    /**\n     * @return the type of the store used for the content\n     * @since 9.0RC1\n     */\n    public String getXmlStore()\n    {\n        return this.xmlStore;\n    }\n\n    /**\n     * @param xmlStore the type of store (supported values are null/\"hibernate\" and \"file\")\n     * @since 9.0RC1\n     */\n    protected void setXmlStore(String xmlStore)\n    {\n        this.xmlStore = xmlStore;\n    }\n\n    /**\n     * Only used in Hibernate.\n     * \n     * @return xml serialization of {@link XWikiDocument}\n     */\n    public String getXml()\n    {\n        if (this.content != null) {\n            try {\n                return this.content.getContentAsString();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        // Return empty String instead of null because this field is configured as not null at database level\n        return \"\";\n    }\n\n    /**\n     * Only used in Hibernate.\n     * \n     * @param xml - xml serialization of {@link XWikiDocument}\n     */\n    protected void setXml(String xml)\n    {\n        if (StringUtils.isNotEmpty(xml)) {\n            try {\n                this.content = new XWikiHibernateDeletedDocumentContent(xml);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    /**\n     * Export {@link XWikiDocument} to {@link XWikiDeletedDocument}.\n     *\n     * @param doc - the deleted document\n     * @param context - used in {@link XWikiDocument#toXML(XWikiContext)}\n     * @throws XWikiException in error in {@link XWikiDocument#toXML(XWikiContext)}\n     * @deprecated since 9.0RC1, use\n     *             {@link XWikiDeletedDocument#XWikiDeletedDocument(String, Locale, String, String, Date, XWikiDeletedDocumentContent)\n     *             instead}\n     */\n    @Deprecated\n    protected void setDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        this.content = new XWikiHibernateDeletedDocumentContent(doc);\n    }\n\n    /**\n     * @return restored document\n     * @param doc optional object where to put the document data, if not <code>null</code>\n     * @param context the current {@link XWikiContext context}\n     * @throws XWikiException if error in {@link XWikiDocument#fromXML(String)}\n     */\n    public XWikiDocument restoreDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        if (this.content == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Cannot find any content for the deleted document [\" + this.fullName + \" (\" + this.locale + \")]\");\n        }\n\n        try {\n            return this.content.getXWikiDocument(doc);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error restoring document\", e, null);\n        }\n    }\n\n    /**\n     * @return restored document\n     * @param context the current {@link XWikiContext context}\n     * @throws XWikiException if error in {@link XWikiDocument#fromXML(String)}\n     * @since 9.0RC1\n     */\n    public XWikiDocument restoreDocument(XWikiContext context) throws XWikiException\n    {\n        return restoreDocument(null, context);\n    }\n\n    /**\n     * @param batchId batch operation ID to set\n     * @since 9.4RC1\n     */\n    protected void setBatchId(String batchId)\n    {\n        this.batchId = batchId;\n    }\n\n    /**\n     * @return the id of the operation that deleted multiple documents at the same time, including this one\n     * @since 9.4RC1\n     */\n    public String getBatchId()\n    {\n        return batchId;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.doc;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.model.reference.DocumentReference;\n\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * The default implementation of {@link DocumentRevisionProvider}.\n * <p>\n * The main job of {@link DefaultDocumentRevisionProvider} is to call the right {@link DocumentRevisionProvider}\n * depending on the revision prefix.\n * \n * @version $Id$\n * @since 9.3rc1\n */\n@Component\n@Singleton\npublic class DefaultDocumentRevisionProvider extends AbstractDocumentRevisionProvider\n{\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    @Named(\"database\")\n    private DocumentRevisionProvider databaseDocumentRevisionProvider;\n\n    @Override\n    public XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException\n    {\n        // Parse the version\n        String revisionPrefix = null;\n        if (revision != null) {\n            int revisionPrefixIndex = revision.indexOf(':');\n            if (revisionPrefixIndex > 0) {\n                revisionPrefix = revision.substring(0, revisionPrefixIndex);\n            }\n        }\n        String shortRevision;\n        if (revisionPrefix != null) {\n            shortRevision = revision.substring(revisionPrefix.length() + 1);\n        } else {\n            shortRevision = revision;\n        }\n\n        // Find the provider\n        DocumentRevisionProvider provider = this.databaseDocumentRevisionProvider;\n        if (revisionPrefix != null) {\n            ComponentManager componentManager = this.componentManagerProvider.get();\n            if (componentManager.hasComponent(DocumentRevisionProvider.class, revisionPrefix)) {\n                try {\n                    provider = componentManager.getInstance(DocumentRevisionProvider.class, revisionPrefix);\n                } catch (ComponentLookupException e) {\n                    throw new XWikiException(\"Failed to get revision provider for revision [\" + revision + \"]\", e);\n                }\n            }\n        }\n\n        // Load the document revision\n        return provider.getRevision(reference, shortRevision);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.doc;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Get deleted document revisions from the database.\n * \n * @version $Id$\n * @since 9.4RC1\n */\n@Component\n@Named(\"deleted\")\n@Singleton\npublic class DeletedDocumentRevisionProvider implements DocumentRevisionProvider\n{\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Override\n    public XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        XWikiDeletedDocument deletedDocument = xcontext.getWiki().getDeletedDocument(Long.valueOf(revision), xcontext);\n\n        // Only local the document if it matches the asked document reference\n        if (deletedDocument != null\n            && (reference == null || deletedDocument.getDocumentReference().equals(reference))) {\n            return deletedDocument.restoreDocument(xcontext);\n        }\n\n        return null;\n\n    }\n\n    @Override\n    public XWikiDocument getRevision(XWikiDocument document, String revision) throws XWikiException\n    {\n        return getRevision(document != null ? document.getDocumentReferenceWithLocale() : null, revision);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.Path;\nimport javax.persistence.criteria.Predicate;\nimport javax.persistence.criteria.Root;\n\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDeletedDocumentContent;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.XWikiHibernateDeletedDocumentContent;\n\n/**\n * Realization of {@link XWikiRecycleBinStoreInterface} for Hibernate store.\n *\n * @version $Id$\n */\n@Component\n@Named(XWikiHibernateBaseStore.HINT)\n@Singleton\npublic class XWikiHibernateRecycleBinStore extends XWikiHibernateBaseStore implements XWikiRecycleBinStoreInterface\n{\n    /**\n     * {@link HibernateCallback} used to retrieve from the recycle bin store the deleted versions of a document.\n     */\n    private static class DeletedDocumentsHibernateCallback implements HibernateCallback<XWikiDeletedDocument[]>\n    {\n        /**\n         * The document whose versions are retrieved from the recycle bin store.\n         */\n        private XWikiDocument document;\n\n        /**\n         * Creates a new call-back for the given document.\n         *\n         * @param document the document whose deleted versions you want to retrieve from the recycle bin store\n         */\n        DeletedDocumentsHibernateCallback(XWikiDocument document)\n        {\n            this.document = document;\n        }\n\n        @Override\n        public XWikiDeletedDocument[] doInHibernate(Session session) throws HibernateException, XWikiException\n        {\n            CriteriaBuilder builder = session.getCriteriaBuilder();\n            CriteriaQuery<XWikiDeletedDocument> query = builder.createQuery(XWikiDeletedDocument.class);\n            Root<XWikiDeletedDocument> root = query.from(XWikiDeletedDocument.class);\n\n            query.select(root);\n\n            Predicate[] predicates = new Predicate[2];\n\n            predicates[0] = builder.equal(root.get(FULL_NAME_FIELD), this.document.getFullName());\n\n            // Note: We need to support databases who treats empty strings as NULL like Oracle. For those checking\n            // for equality when the string is empty is not going to work and thus we need to handle the special\n            // empty case separately.\n            Locale language = this.document.getLocale();\n            Path<String> languageProperty = root.get(LANGUAGE_PROPERTY_NAME);\n            if (language.equals(Locale.ROOT)) {\n                predicates[1] = builder.or(builder.equal(languageProperty, \"\"), builder.isNull(languageProperty));\n            } else {\n                predicates[1] = builder.equal(languageProperty, language);\n            }\n\n            query.where(predicates);\n\n            query.orderBy(builder.desc(root.get(\"date\")));\n\n            List<XWikiDeletedDocument> deletedVersions = session.createQuery(query).getResultList();\n\n            return deletedVersions.toArray(new XWikiDeletedDocument[deletedVersions.size()]);\n        }\n    }\n\n    /**\n     * {@link HibernateCallback} used to retrieve from the recycle bin store the deleted document versions from a given\n     * batch.\n     */\n    private static class DeletedDocumentsBatchHibernateCallback implements HibernateCallback<XWikiDeletedDocument[]>\n    {\n        private String batchId;\n\n        /**\n         * Creates a new call-back for the given batch.\n         *\n         * @param batchId the ID of the batch of deleted documents you want to retrieve from the recycle bin store\n         */\n        DeletedDocumentsBatchHibernateCallback(String batchId)\n        {\n            this.batchId = batchId;\n        }\n\n        @Override\n        public XWikiDeletedDocument[] doInHibernate(Session session) throws HibernateException, XWikiException\n        {\n            CriteriaBuilder builder = session.getCriteriaBuilder();\n            CriteriaQuery<XWikiDeletedDocument> query = builder.createQuery(XWikiDeletedDocument.class);\n            Root<XWikiDeletedDocument> root = query.from(XWikiDeletedDocument.class);\n\n            query.select(root);\n\n            query.where(builder.equal(root.get(\"batchId\"), batchId));\n\n            query.orderBy(builder.asc(root.get(FULL_NAME_FIELD)));\n\n            List<XWikiDeletedDocument> deletedVersions = session.createQuery(query).getResultList();\n\n            return deletedVersions.toArray(new XWikiDeletedDocument[deletedVersions.size()]);\n        }\n    }\n\n    private static final String FULL_NAME_FIELD = \"fullName\";\n\n    /**\n     * Name of the language property in the Hibernate mapping.\n     */\n    private static final String LANGUAGE_PROPERTY_NAME = \"language\";\n\n    @Inject\n    private StoreConfiguration storeConfiguration;\n\n    @Inject\n    private ComponentManager componentManager;\n\n    @Inject\n    private Logger logger;\n\n    /**\n     * @param context used for environment\n     * @deprecated 1.6M1. Use ComponentManager#getInstance(XWikiRecycleBinStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateRecycleBinStore(XWikiContext context)\n    {\n        super(context.getWiki(), context);\n    }\n\n    /**\n     * Empty constructor needed for component manager.\n     */\n    public XWikiHibernateRecycleBinStore()\n    {\n    }\n\n    private XWikiRecycleBinContentStoreInterface getDefaultXWikiRecycleBinContentStore() throws XWikiException\n    {\n        try {\n            return this.storeConfiguration.getXWikiRecycleBinContentStore();\n        } catch (ComponentLookupException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to lookup recycle bin content store\", e);\n        }\n    }\n\n    private XWikiRecycleBinContentStoreInterface getXWikiRecycleBinContentStore(String storeType)\n    {\n        if (storeType != null && !storeType.equals(HINT)) {\n            try {\n                return this.componentManager.getInstance(XWikiRecycleBinContentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                this.logger.warn(\"Can't find recycle bin content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    private XWikiDeletedDocument resolveDeletedDocumentContent(XWikiDeletedDocument deletedDocument,\n        boolean bTransaction) throws XWikiException\n    {\n        XWikiRecycleBinContentStoreInterface contentStore =\n            getXWikiRecycleBinContentStore(deletedDocument.getXmlStore());\n\n        if (contentStore != null) {\n            XWikiDeletedDocumentContent content =\n                contentStore.get(deletedDocument.getDocumentReference(), deletedDocument.getId(), bTransaction);\n\n            try {\n                FieldUtils.writeDeclaredField(deletedDocument, \"content\", content, true);\n            } catch (IllegalAccessException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to set deleted document content\", e);\n            }\n        }\n\n        return deletedDocument;\n    }\n\n    private XWikiDeletedDocument createXWikiDeletedDocument(XWikiDocument doc, String deleter, Date date,\n        XWikiRecycleBinContentStoreInterface contentStore, String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument trashdoc;\n\n        String storeType = null;\n        XWikiDeletedDocumentContent deletedDocumentContent = null;\n\n        if (contentStore != null) {\n            storeType = contentStore.getHint();\n        } else {\n            deletedDocumentContent = new XWikiHibernateDeletedDocumentContent(doc);\n        }\n\n        trashdoc = new XWikiDeletedDocument(doc.getFullName(), doc.getLocale(), storeType, deleter, date,\n            deletedDocumentContent, batchId);\n\n        return trashdoc;\n    }\n\n    private void deleteDeletedDocumentContent(XWikiDeletedDocument deletedDocument, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiRecycleBinContentStoreInterface contentStore =\n            getXWikiRecycleBinContentStore(deletedDocument.getXmlStore());\n\n        if (contentStore != null) {\n            contentStore.delete(deletedDocument.getDocumentReference(), deletedDocument.getId(), bTransaction);\n        }\n    }\n\n    @Override\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, XWikiContext inputxcontext,\n        boolean bTransaction) throws XWikiException\n    {\n        saveToRecycleBin(doc, deleter, date, null, inputxcontext, bTransaction);\n    }\n\n    @Override\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, String batchId,\n        XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            executeWrite(context, session -> {\n                XWikiRecycleBinContentStoreInterface contentStore = getDefaultXWikiRecycleBinContentStore();\n\n                XWikiDeletedDocument trashdoc = createXWikiDeletedDocument(doc, deleter, date, contentStore, batchId);\n\n                // Hibernate store.\n                long index = ((Number) session.save(trashdoc)).longValue();\n\n                // External store\n                if (contentStore != null) {\n                    contentStore.save(doc, index, bTransaction);\n                }\n\n                return null;\n            });\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public XWikiDocument restoreFromRecycleBin(final XWikiDocument doc, final long index,\n        final XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return restoreFromRecycleBin(index, inputxcontext, bTransaction);\n    }\n\n    @Override\n    public XWikiDocument restoreFromRecycleBin(long index, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            XWikiDeletedDocument deletedDocument = getDeletedDocument(index, context, bTransaction);\n            return deletedDocument.restoreDocument(context);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return getDeletedDocument(index, context, bTransaction);\n    }\n\n    @Override\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context, true, bTransaction);\n    }\n\n    private XWikiDeletedDocument getDeletedDocument(final long index, XWikiContext context, boolean resolve,\n        boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            XWikiDeletedDocument deletedDocument = session.get(XWikiDeletedDocument.class, Long.valueOf(index));\n\n            if (deletedDocument != null && resolve) {\n                deletedDocument = resolveDeletedDocumentContent(deletedDocument, false);\n            }\n\n            return deletedDocument;\n        });\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = executeRead(context, new DeletedDocumentsHibernateCallback(doc));\n\n        // Resolve deleted document content if needed\n        for (int i = 0; i < deletedDocuments.length; ++i) {\n            deletedDocuments[i] = resolveDeletedDocumentContent(deletedDocuments[i], bTransaction);\n        }\n\n        return deletedDocuments;\n    }\n\n    @Override\n    public Long[] getAllDeletedDocumentsIds(XWikiContext context, int limit) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            org.hibernate.query.Query<Long> query =\n                session.createQuery(\"SELECT id FROM XWikiDeletedDocument ORDER BY date DESC\", Long.class);\n\n            if (limit > 0) {\n                query.setMaxResults(limit);\n            }\n\n            List<Long> deletedDocIds = query.list();\n            Long[] result = new Long[deletedDocIds.size()];\n            return deletedDocIds.toArray(result);\n        });\n    }\n\n    @Override\n    public Long getNumberOfDeletedDocuments(XWikiContext context) throws XWikiException\n    {\n\n        return executeRead(context, session -> {\n            org.hibernate.query.Query<Long> query =\n                session.createQuery(\"SELECT count(id) FROM XWikiDeletedDocument\", Long.class);\n\n            return query.uniqueResult();\n        });\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        return getAllDeletedDocuments(batchId, true, context, bTransaction);\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, boolean withContent, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments =\n            executeRead(context, new DeletedDocumentsBatchHibernateCallback(batchId));\n\n        // Resolve deleted document content if needed\n        if (withContent) {\n            for (int i = 0; i < deletedDocuments.length; ++i) {\n                XWikiDeletedDocument deletedDocument = deletedDocuments[i];\n                deletedDocuments[i] = resolveDeletedDocumentContent(deletedDocument, bTransaction);\n            }\n        }\n\n        return deletedDocuments;\n    }\n\n    @Override\n    public void deleteFromRecycleBin(XWikiDocument doc, final long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        deleteFromRecycleBin(index, context, bTransaction);\n    }\n\n    @Override\n    public void deleteFromRecycleBin(final long index, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(context, session -> {\n            XWikiDeletedDocument deletedDocument = getDeletedDocument(index, context, false, bTransaction);\n\n            // Delete metadata\n            session.delete(deletedDocument);\n\n            // Delete content\n            deleteDeletedDocumentContent(deletedDocument, bTransaction);\n\n            return null;\n        });\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.util.Date;\n\nimport org.xwiki.component.annotation.Role;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Interface for RecycleBin feature (XWIKI-543) store system.\n *\n * @version $Id$\n * @since 1.2M1\n */\n@Role\npublic interface XWikiRecycleBinStoreInterface\n{\n    /**\n     * Save document to recycle bin.\n     *\n     * @param doc - document to save\n     * @param deleter - the user which delete document\n     * @param date - date of delete action\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @param context - used while saving\n     * @throws XWikiException if error in saving\n     */\n    void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Save document to recycle bin.\n     *\n     * @param doc - document to save\n     * @param deleter - the user which delete document\n     * @param date - date of delete action\n     * @param batchId - id of the operation that deleted multiple documents at the same time, useful when trying to\n     *            revert the operation. {@code null} or empty values are ignored\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @param context - used while saving\n     * @throws XWikiException if error in saving\n     * @since 9.4RC1\n     */\n    default void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, String batchId, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        // XXX: The current signature does not return the saved document index so we have no way of setting the batchId\n        // to the save document. This means we can`t completely respect the method`s contract, but at least the most\n        // important part of the work is done and the document can be individually restored.\n        saveToRecycleBin(doc, deleter, date, context, bTransaction);\n    }\n\n    /**\n     * @return restored document from recycle bin\n     * @param doc - document to restore\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if error while loading\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #restoreFromRecycleBin(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    XWikiDocument restoreFromRecycleBin(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return the restored document from recycle bin\n     * @throws XWikiException if error while loading\n     * @since 9.4RC1\n     */\n    default XWikiDocument restoreFromRecycleBin(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        return restoreFromRecycleBin(new XWikiDocument(), index, context, bTransaction);\n    }\n\n    /**\n     * @return specified deleted document from recycle bin. null if not found.\n     * @param doc - deleted document\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if error while loading\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #getDeletedDocument(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * @param index - what deleted document to restore. See {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return specified deleted document from recycle bin or {@code null} if not found.\n     * @throws XWikiException if error while loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        return getDeletedDocument(new XWikiDocument(), index, context, bTransaction);\n    }\n\n    /**\n     * @return info about all delete actions of specific document. sorted by date.\n     * @param doc - the deleted document\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException - if error in loading\n     */\n    XWikiDeletedDocument[] getAllDeletedDocuments(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Get all the deleted documents ID or a specified number. Sorted by date.\n     * @param context - used to load the deleted documents id.\n     * @param limit - if &gt; 0 then all deleted documents id are returned. Else the specified number.\n     * @return an array of IDs of deleted documents.\n     * @throws XWikiException - if error in loading\n     * @since 10.10RC1\n     */\n    default Long[] getAllDeletedDocumentsIds(XWikiContext context, int limit) throws XWikiException\n    {\n        return new Long[0];\n    }\n\n    /**\n     * @param context - used to realize the query.\n     * @return the number of deleted documents in the recycle bin.\n     * @throws XWikiException - if error in loading.\n     * @since 10.10RC1\n     */\n    default Long getNumberOfDeletedDocuments(XWikiContext context) throws XWikiException\n    {\n        return -1L;\n    }\n\n    /**\n     * @return info about all documents that were deleted in the same batch, as part of the same operation\n     * @param batchId - id of the operation that deleted multiple documents at the same time; useful when trying to\n     *            revert the operation\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException - if error in loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // Return no results as default implementation.\n        return new XWikiDeletedDocument[0];\n    }\n\n    /**\n     * @param batchId - id of the operation that deleted multiple documents at the same time; useful when trying to\n     *            revert the operation\n     * @param withContent - {@code true} if the deleted document's content should also be loaded; {@code false} if\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return info about all documents that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException - if error in loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, boolean withContent, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        // Return no results as default implementation.\n        return new XWikiDeletedDocument[0];\n    }\n\n    /**\n     * Permanently delete document from recycle bin.\n     *\n     * @param doc - document to delete\n     * @param index - which instance document in recycle bin to delete\n     * @param context - used for environment\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #deleteFromRecycleBin(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    void deleteFromRecycleBin(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Permanently delete document from recycle bin.\n     *\n     * @param index - which instance document in recycle bin to delete\n     * @param context - used for environment\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    default void deleteFromRecycleBin(long index, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        deleteFromRecycleBin(new XWikiDocument(), index, context, bTransaction);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.internal.web.DocExistValidator;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.redirection.RedirectionFilter;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    @Inject\n    protected ObservationManager observation;\n\n    @Inject\n    @Named(\"context\")\n    private ComponentManager componentManager;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentmixedReferenceResolver;\n\n    @Inject\n    private ContextualAuthorizationManager autorization;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    @Unstable\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return this.currentmixedReferenceResolver;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected ContextualAuthorizationManager getContextualAuthorizationManager()\n    {\n        return this.autorization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"invalidNameReference\", entityReference, ScriptContext.ENGINE_SCOPE);\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                this.observation.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = this.execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    this.observation.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = handleRedirect(context);\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    // check for doc existence\n                    if (shouldReturnDocDoesNotExist(doc, context)) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        this.observation.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                this.observation.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    /**\n     * Check if the given document exists or not and if it should return a 404 based on the context. A {@link\n     * DocExistValidator} with an hint matching the current action is used to check if the document exists. When no\n     * {@link DocExistValidator} is found, the response is always {@code false} When a {@link DocExistValidator} is\n     * found, the result is delegated to {@link DocExistValidator#docExist(XWikiDocument, XWikiContext)}.\n     *\n     * @param doc the doc for which to check it exists or not\n     * @param context the current context\n     * @return {@code true} if we should return a 404\n     * @throws ComponentLookupException if an error occurs when instantiating a {@link DocExistValidator}\n     */\n    private boolean shouldReturnDocDoesNotExist(XWikiDocument doc, XWikiContext context) throws ComponentLookupException\n    {\n        boolean result = false;\n        String action = context.getAction();\n        if (this.componentManager.hasComponent(DocExistValidator.class, action)) {\n            result = this.componentManager.<DocExistValidator>getInstance(DocExistValidator.class, action)\n                .docExist(doc, context);\n        }\n        return result;\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    @Unstable\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Indicate if the action support redirection. The default value is {@code false}.\n     *\n     * @return {@code true} if the action supports redirections, {@code false} otherwise\n     * @since 14.0RC1\n     */\n    @Unstable\n    protected boolean supportRedirections()\n    {\n        return false;\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n            XWikiDocument rdoc =\n                (!doc.getLocale().equals(tdoc.getLocale())) ? doc : context.getWiki().getDocument(doc, rev, context);\n\n            XWikiDocument rtdoc =\n                (doc.getLocale().equals(tdoc.getLocale())) ? rdoc : context.getWiki().getDocument(tdoc, rev, context);\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Perform a redirect to the given URL.\n     * @param response the response to use to perform the redirect\n     * @param url the location of the redirect\n     * @throws XWikiException in case of IOException when performing the redirect.\n     */\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n            context.setResponseSent(true);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n\n    /**\n     * Helper used resolve the template passed to the action if the current user have access to it.\n     * \n     * @param template the template to copy\n     * @return the reference of the template if not empty and the current user have access to it\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReference resolveTemplate(String template)\n    {\n        if (StringUtils.isNotBlank(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n\n            // Make sure the current user have access to the template document before copying it\n            if (getContextualAuthorizationManager().hasAccess(Right.VIEW, templateReference)) {\n                return templateReference;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper used by various actions to initialize a document by copying a template to it.\n     * \n     * @param document the document to update\n     * @param template the template to copy\n     * @param context the XWiki context\n     * @return true if the document was updated, false otherwise (for example when the current user does not have view\n     *         right on the template document)\n     * @throws XWikiException when failing to copy the template\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    @Unstable\n    protected boolean readFromTemplate(XWikiDocument document, String template, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(template);\n\n        if (templateReference != null) {\n            document.readFromTemplate(templateReference, context);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loop over the {@link RedirectionFilter} components until one of them perform a redirection. If none of the does,\n     * the action continues normally.\n     *\n     * @param context the current wiki content\n     * @return {@code true} if a redirection has been performed, {@code false} otherwise\n     * @throws XWikiException in case of error during the execution of a redirection filter\n     */\n    private boolean handleRedirect(XWikiContext context) throws XWikiException\n    {\n        // If no redirection are expected, this step is skipped.\n        if (this.supportRedirections()) {\n            try {\n                for (RedirectionFilter filter : this.componentManager.<RedirectionFilter>getInstanceList(\n                    RedirectionFilter.class)) {\n                    if (filter.redirect(context)) {\n                        return true;\n                    }\n                }\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(\"Failed to resolve the redirection filters list\", e);\n            }\n        }\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.refactoring.job.RefactoringJobs;\nimport org.xwiki.refactoring.job.RestoreRequest;\nimport org.xwiki.refactoring.script.RefactoringScriptService;\nimport org.xwiki.refactoring.script.RequestFactory;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link UndeleteAction}.\n *\n * @version $Id$\n */\n@OldcoreTest\n@ReferenceComponentList\nclass UndeleteActionTest\n{\n    private static final DocumentReference DELETED_REFERENCE =\n        new DocumentReference(\"xwiki\", \"Main\", \"DeletedDocument\");\n\n    private static final long ID = 13;\n\n    @MockComponent\n    private RequestFactory requestFactory;\n\n    @MockComponent\n    private CSRFToken csrfToken;\n\n    @Mock\n    private RefactoringScriptService refactoringScriptService;\n\n    @MockComponent\n    private JobExecutor jobExecutor;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    @Mock\n    private XWikiRequest request;\n\n    @Mock\n    private Job job;\n\n    @Mock\n    private RestoreRequest jobRequest;\n\n    @Mock\n    private XWikiDeletedDocument deletedDocument;\n\n    /**\n     * The object being tested.\n     */\n    private UndeleteAction undeleteAction = new UndeleteAction();\n\n    @BeforeEach\n    void beforeEach() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(this.request);\n\n        XWikiDocument contextDocument = mock(XWikiDocument.class);\n        when(contextDocument.getDocumentReference()).thenReturn(DELETED_REFERENCE);\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        when(this.jobExecutor.execute(anyString(), any())).thenReturn(this.job);\n\n        this.componentManager.registerComponent(ScriptService.class, \"refactoring\", this.refactoringScriptService);\n        when(this.refactoringScriptService.getRequestFactory()).thenReturn(this.requestFactory);\n        when(this.requestFactory.createRestoreRequest(any(List.class))).thenReturn(this.jobRequest);\n        when(this.requestFactory.createRestoreRequest(anyString())).thenReturn(this.jobRequest);\n\n        when(this.request.getParameter(\"id\")).thenReturn(String.valueOf(ID));\n\n        when(this.deletedDocument.getLocale()).thenReturn(Locale.ROOT);\n        when(deletedDocument.getLocale()).thenReturn(Locale.ROOT);\n        when(deletedDocument.getId()).thenReturn(ID);\n        when(deletedDocument.getDocumentReference()).thenReturn(DELETED_REFERENCE);\n        doReturn(this.deletedDocument).when(this.oldcore.getSpyXWiki()).getDeletedDocument(anyLong(),\n            any(XWikiContext.class));\n    }\n\n    /**\n     * Launches a RestoreJob with the current deleted document ID.\n     */\n    @Test\n    void restoreSingleDocument() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(true);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(Arrays.asList(ID));\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    @Test\n    void restoreSingleDocumentWhenDeleter() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.oldcore.getMockAuthorizationManager().hasAccess(Right.EDIT, null, DELETED_REFERENCE))\n            .thenReturn(true);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(Arrays.asList(ID));\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    @Test\n    void missingCSRFToken() throws Exception\n    {\n        // Invalid CSRF token.\n        when(this.csrfToken.isTokenValid(null)).thenReturn(false);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        // Verify that the resubmission URL was retrieved to be used in the redirect.\n        verify(this.csrfToken).getResubmissionURL();\n    }\n\n    /**\n     * When the recycle bin is disabled or when the deleted document ID is invalid, the document should not be restored.\n     */\n    @Test\n    void recycleBinDisabledOrInvalidId() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        // null is returned when the ID is invalid or the Recycle Bin is disabled.\n        doReturn(null).when(this.oldcore.getSpyXWiki()).getDeletedDocument(anyLong(), any(XWikiContext.class));\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        // Verify that we never get this far.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * Show the \"restore\" UI with the option to include the batch when restoring and to see the contents of the batch of\n     * the current deleted document.\n     */\n    @Test\n    void showBatch() throws Exception\n    {\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(true);\n\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"restore\" template.\n        assertEquals(\"restore\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure that we stop to the display, since the \"confirm=true\" parameter was not passed.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * Launches a RestoreJob with the batchId of the current deleted document.\n     */\n    @Test\n    void restoreBatch() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        String batchId = \"abc123\";\n\n        when(deletedDocument.getBatchId()).thenReturn(batchId);\n\n        // Go through the screen showing the option to include the batch and displaying its contents.\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        // Option to include the entire batch when restoring is enabled.\n        when(this.request.getParameter(\"includeBatch\")).thenReturn(\"true\");\n\n        // Confirmation button pressed.\n        when(this.request.getParameter(\"confirm\")).thenReturn(\"true\");\n\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(true);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(batchId);\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    /**\n     * When trying to restore, rights are checked on the current deleted document, regardless if single or batch\n     * restore.\n     */\n    @Test\n    void notAllowedToRestoreSinglePage() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(false);\n\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"accessdenied\" template.\n        assertEquals(\"accessdenied\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure we don`t go any further.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * When trying to restore, rights are checked on the current deleted document, regardless if single or batch\n     * restore.\n     */\n    @Test\n    void notAllowedToRestoreBatch() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        String batchId = \"abc123\";\n\n        when(this.deletedDocument.getBatchId()).thenReturn(batchId);\n\n        // Go through the screen showing the option to include the batch and displaying its contents.\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        // Option to include the entire batch when restoring is enabled.\n        when(this.request.getParameter(\"includeBatch\")).thenReturn(\"true\");\n\n        // Confirmation button pressed.\n        when(this.request.getParameter(\"confirm\")).thenReturn(\"true\");\n\n        // No rights to restore the page when checking from the Action. The job will check individual rights.\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(false);\n\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"accessdenied\" template.\n        assertEquals(\"accessdenied\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure we don`t go any further.\n        verify(this.requestFactory, never()).createRestoreRequest(batchId);\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n### Show list of deleted documents\n#set($dds = $xwiki.getDeletedDocuments($tdoc.fullName, $tdoc.locale))\n#displayDeletedDocuments($dds, 'docs')\n\n#if ($doc.documentReference.name == 'WebHome')\n  ## Also display the list of terminal documents sharing the same location.\n  ## eg. If the current document is: \"A.B.WebHome\", we should also display any deleted terminal page called \"A.B\".\n  ## This is important because when the user delete a terminal document and go back to the location, she should see\n  ## the page she have just deleted, and not an empty page because A.B.WebHome has never existed...\n  #set($dds = $xwiki.getDeletedDocuments($tdoc.space, $tdoc.locale))\n  #displayDeletedDocuments($dds, 'terminal-docs', 'core.recyclebin.showListTerminalPagesMsg')\n#end\n\n#*\n * Display the given list of deleted documents\n * @param $list the list to display\n * @param $className the name of the css class to apply to the list\n * @param $message (optional) the translation key for the message which introduce the list\n *#\n#macro (displayDeletedDocuments $list $className $message)\n  #if (!$message)\n    #set ($message = 'core.recyclebin.showlistmsg')\n  #end  \n  #if($list && $list.size() > 0)\n    #set ($canDelete = $list[0].canDelete())\n    #set ($canRestore = $list[0].canUndelete())\n    <hr />\n    <div class=\"centered $!className\">\n      <p class=\"recyclebin-message\">$escapetool.xml($services.localization.render($message))</p>\n      <table class=\"centered\">\n       <thead>\n        <tr>\n         <th>$escapetool.xml($services.localization.render('core.recyclebin.deleter'))</td>\n         <th>$escapetool.xml($services.localization.render('core.recyclebin.deleteDate'))</td>\n         #if ($canRestore)\n           <th>$escapetool.xml($services.localization.render('core.recyclebin.batchId'))</td>\n         #end\n         <th colspan=\"2\">$escapetool.xml($services.localization.render('core.recyclebin.actions'))</th>\n        </tr>\n       </thead>\n       <tbody>\n       #foreach($dd in $list)\n        <tr>\n         <td>$xwiki.getUserName($dd.getDeleter())</td>\n         <td>\n           <a class=\"link-view\" href=\"$doc.getURL('view', $escapetool.url({'rev' : \"deleted:${dd.getId()}\"}))\">\n             $xwiki.formatDate($dd.getDate())\n           </a>\n         </td>\n         #if ($canRestore)\n           <td><a href=\"$xwiki.getURL($dd.fullName, 'undelete', \"id=${dd.id}&amp;showBatch=true\")\">$!{dd.batchId}</a></td>\n         #end\n         <td>\n           #if($canRestore)\n             <a href=\"$xwiki.getURL($dd.getFullName(), 'undelete', \"form_token=$!{services.csrf.getToken()}&amp;id=$dd.getId()\")\" class=\"action-restore\">\n               $escapetool.xml($services.localization.render('core.recyclebin.restore'))\n             </a>\n           #end\n         </td>\n         <td>\n          #if($canDelete)\n           <a href=\"$xwiki.getURL($dd.getFullName(), 'delete', \"form_token=$!{services.csrf.getToken()}&amp;id=$dd.getId()\")\"\n            onclick=\"if (confirm('$escapetool.javascript($services.localization.render('core.recyclebin.completelyDeleteConfirm'))')) {this.href += '&amp;confirm=1'; return true;} return false;\" class=\"action-delete\">\n            $escapetool.xml($services.localization.render('core.recyclebin.delete'))\n           </a>\n          #end\n         </td>\n        </tr>\n       #end\n       </tbody>\n      </table>\n    </div>\n  #end\n#end\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.util.Programming;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Information about a deleted document in the recycle bin.\n *\n * @version $Id$\n */\npublic class DeletedDocument extends Api\n{\n    private static final String ADMIN_RIGHT = \"admin\";\n\n    /** Logging helper object. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeletedDocument.class);\n\n    /**\n     * The internal object wrapped by this API.\n     */\n    private final XWikiDeletedDocument deletedDoc;\n\n    private UserReferenceResolver<DocumentReference> userReferenceResolver;\n\n    /**\n     * Simple constructor, initializes a new API object with the current {@link com.xpn.xwiki.XWikiContext context} and\n     * the specified protected {@link com.xpn.xwiki.doc.XWikiDeletedDocument deleted document} object.\n     *\n     * @param deletedDoc the internal object wrapped by this API\n     * @param context the current request context\n     */\n    public DeletedDocument(XWikiDeletedDocument deletedDoc, XWikiContext context)\n    {\n        super(context);\n        this.deletedDoc = deletedDoc;\n    }\n\n    /**\n     * @return full name of document (ie: Main.WebHome)\n     */\n    public String getFullName()\n    {\n        return this.deletedDoc.getFullName();\n    }\n\n    /**\n     * @return locale of document\n     * @deprecated since 8.0M1, use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.deletedDoc.getLanguage();\n    }\n\n    /**\n     * @return locale of document\n     * @since 8.0M1\n     */\n    public Locale getLocale()\n    {\n        return this.deletedDoc.getLocale();\n    }\n\n    /**\n     * @return date of delete action\n     */\n    public Date getDate()\n    {\n        return this.deletedDoc.getDate();\n    }\n\n    /**\n     * @return user which delete document\n     */\n    public String getDeleter()\n    {\n        return this.deletedDoc.getDeleter();\n    }\n\n    /**\n     * @return the reference of the user who deleted this document\n     * @since 11.5RC1\n     */\n    public DocumentReference getDeleterReference()\n    {\n        return this.deletedDoc.getDeleterReference();\n    }\n\n    /**\n     * @return id of deleted document. id is unique only for this document.\n     */\n    public long getId()\n    {\n        return this.deletedDoc.getId();\n    }\n\n    /**\n     * @return the id of the operation that deleted multiple documents at the same time, including this one\n     * @since 9.4RC1\n     */\n    public String getBatchId()\n    {\n        return this.deletedDoc.getBatchId();\n    }\n\n    private UserReferenceResolver<DocumentReference> getUserReferenceResolver()\n    {\n        if (this.userReferenceResolver == null) {\n            this.userReferenceResolver = Utils.getComponent(\n                new DefaultParameterizedType(null, UserReferenceResolver.class, DocumentReference.class), \"document\");\n        }\n        return this.userReferenceResolver;\n    }\n\n    private boolean hasAccess(Right right)\n    {\n        UserReference userReference = getUserReferenceResolver().resolve(this.context.getUserReference());\n        XWikiRecycleBinStoreInterface recycleBinStore = this.context.getWiki().getRecycleBinStore();\n        return recycleBinStore.hasAccess(right, userReference, this.deletedDoc);\n    }\n\n    /**\n     * Check if the current user has the right to restore the document.\n     *\n     * @return {@code true} if the current user can restore this document, {@code false} otherwise\n     */\n    public boolean canUndelete()\n    {\n        return hasAccess(Right.EDIT);\n    }\n\n    /**\n     * Check if the current user has the right to view the deleted document.\n     * This is allowed either if the user has admin right on the original reference of the doc, or if they were the\n     * original user who deleted it.\n     *\n     * @return {code true} if the current user is allowed to view the deleted document.\n     * @since 14.10RC1\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    public boolean canView()\n    {\n        return hasAccess(Right.VIEW);\n    }\n\n    /**\n     * @return {@code true} if the current user can permanently delete this document, {@code false} otherwise\n     * @xwiki.xwikicfg xwiki.store.recyclebin.adminWaitDays How many days should an administrator wait before being able\n     *                 to permanently delete this document from the recycle bin. 0 by default.\n     * @xwiki.xwikicfg xwiki.store.recyclebin.waitDays How many days should a normal user with \"delete\" right wait\n     *                 before being able to permanently delete this document from the recycle bin. 7 by default.\n     */\n    public boolean canDelete()\n    {\n        try {\n            XWikiDocument doc = new XWikiDocument();\n            doc.setFullName(getFullName(), this.context);\n            if (!hasAccessLevel(\"delete\", getFullName())) {\n                return false;\n            }\n            String waitdays;\n            if (hasAccessLevel(ADMIN_RIGHT, getFullName())) {\n                waitdays = getXWikiContext().getWiki().Param(\"xwiki.store.recyclebin.adminWaitDays\", \"0\");\n            } else {\n                waitdays = getXWikiContext().getWiki().Param(\"xwiki.store.recyclebin.waitDays\", \"7\");\n            }\n            int seconds = (int) (Double.parseDouble(waitdays) * 24 * 60 * 60 + 0.5);\n            Calendar cal = Calendar.getInstance();\n            cal.setTime(getDate());\n            cal.add(Calendar.SECOND, seconds);\n            return cal.before(Calendar.getInstance());\n        } catch (Exception ex) {\n            // Public APIs should not throw exceptions\n            LOGGER.warn(\"Exception while checking if entry [{}] can be removed from the recycle bin\", getId(), ex);\n            return false;\n        }\n    }\n\n    /**\n     * @return original deleted document if user has programming rights, else {@code null}.\n     */\n    @Programming\n    public XWikiDeletedDocument getDeletedDocument()\n    {\n        if (hasProgrammingRights()) {\n            return this.deletedDoc;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @return the document as it is in the recycle bin if the user is allowed to restore it, {@code null} otherwise\n     */\n    public Document getDocument()\n    {\n        if (canUndelete()) {\n            try {\n                return new Document(this.deletedDoc.restoreDocument(null, this.context), this.context);\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Failed to parse deleted document [{}]\", getFullName(), e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the document reference for the deleted document, including any locale information\n     * @since 9.4RC1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        return this.deletedDoc.getDocumentReference();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport org.xwiki.component.annotation.Role;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.AccessDeniedException;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiException;\n\n/**\n * Provide generic way of requesting a specific revision of a document from several sources (database, installed XAR\n * extension, etc.).\n * <p>\n * The revision syntax is {@code <provider hint>:<revision>}, default provide being database (the version of the\n * document in the history).\n * \n * @version $Id$\n * @since 9.4RC1\n */\n@Role\npublic interface DocumentRevisionProvider\n{\n    /**\n     * Load the document in the provided revision.\n     * \n     * @param reference the reference of the document\n     * @param revision the revision of the document\n     * @return the {@link XWikiDocument} instance or null if none existing\n     * @throws XWikiException when failing to load the document revision\n     */\n    XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException;\n\n    /**\n     * Load the document in the provided revision.\n     * \n     * @param document the current document\n     * @param revision the revision of the document\n     * @return the {@link XWikiDocument} instance or null if none existing\n     * @throws XWikiException when failing to load the document revision\n     */\n    XWikiDocument getRevision(XWikiDocument document, String revision) throws XWikiException;\n\n    /**\n     * Check if access is granted on the given document revision, for the given user and right: if the access is not\n     * granted this method will throw an {@link AccessDeniedException}.\n     * This method allows each revision provider to have their own check depending on the type of revision.\n     *\n     * @param right the right for which to check if access is granted\n     * @param userReference the user for whom to check access\n     * @param documentReference the reference of the document\n     * @param revision the revision of the document\n     * @throws AuthorizationException if the access is denied\n     * @throws XWikiException in case of problem when loading the revision\n     * @since 14.10RC1\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    default void checkAccess(Right right, UserReference userReference, DocumentReference documentReference,\n        String revision) throws AuthorizationException, XWikiException\n    {\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.doc;\n\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.internal.store.hibernate.XWikiHibernateDeletedDocumentContent;\nimport com.xpn.xwiki.util.AbstractSimpleClass;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Archive of deleted document, stored in {@link com.xpn.xwiki.store.XWikiRecycleBinStoreInterface}. Immutable, because\n * we don't need modify deleted document.\n *\n * @version $Id$\n * @since 1.2M1\n */\npublic class XWikiDeletedDocument extends AbstractSimpleClass\n{\n    /**\n     * Synthetic id.\n     */\n    private long id;\n\n    /**\n     * @see XWikiDocument#getFullName()\n     */\n    private String fullName;\n\n    /**\n     * @see XWikiDocument#getLocale()\n     */\n    private Locale locale;\n\n    /**\n     * date of delete action.\n     */\n    private Date date;\n\n    /**\n     * @see XWikiDeletedDocument#getDeleter()\n     */\n    private String deleter;\n\n    private String xmlStore;\n\n    private XWikiDeletedDocumentContent content;\n\n    private String batchId;\n\n    /**\n     * Default constructor. Used only in hibernate.\n     */\n    protected XWikiDeletedDocument()\n    {\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType - the way to store the document\n     * @param deleter - user which delete document\n     * @param deleteDate - date of delete action\n     * @throws XWikiException if any error\n     * @since 9.0RC1\n     */\n    private XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate)\n        throws XWikiException\n    {\n        this.fullName = fullName;\n        this.locale = locale;\n        this.deleter = deleter;\n        this.date = deleteDate;\n        this.xmlStore = storeType;\n    }\n\n    /**\n     * @param doc - deleted document\n     * @param deleter - user which delete document\n     * @param deleteDate - date of delete action\n     * @param context - used for environment\n     * @throws XWikiException if any error\n     */\n    public XWikiDeletedDocument(XWikiDocument doc, String deleter, Date deleteDate, XWikiContext context)\n        throws XWikiException\n    {\n        this(doc.getFullName(), doc.getLocale(), null, deleter, deleteDate);\n\n        setDocument(doc, context);\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType the way to store the document\n     * @param deleter the user who delete document\n     * @param deleteDate date of delete action\n     * @param content the stored deleted document\n     * @throws XWikiException if any error\n     * @since 9.0RC1\n     */\n    public XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate,\n        XWikiDeletedDocumentContent content) throws XWikiException\n    {\n        this(fullName, locale, storeType, deleter, deleteDate);\n\n        this.content = content;\n    }\n\n    /**\n     * @param fullName the local reference of the document\n     * @param locale the locale of the document\n     * @param storeType the way to store the document\n     * @param deleter the user who delete document\n     * @param deleteDate date of delete action\n     * @param content the stored deleted document\n     * @param batchId the id of the batch deletion\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument(String fullName, Locale locale, String storeType, String deleter, Date deleteDate,\n        XWikiDeletedDocumentContent content, String batchId) throws XWikiException\n    {\n        this(fullName, locale, storeType, deleter, deleteDate, content);\n\n        this.batchId = batchId;\n    }\n\n    /**\n     * @return the synthetic id of this deleted document. unique only for document.\n     */\n    public long getId()\n    {\n        return this.id;\n    }\n\n    /**\n     * @param id - the synthetic id to set. used only in Hibernate.\n     */\n    protected void setId(long id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * @return {@link XWikiDocument#getFullName()}\n     */\n    public String getFullName()\n    {\n        return this.fullName;\n    }\n\n    /**\n     * @param docFullName - {@link XWikiDocument#getFullName()} to set\n     */\n    protected void setFullName(String docFullName)\n    {\n        this.fullName = docFullName;\n    }\n\n    /**\n     * @return the document reference for the deleted document, including any locale information\n     * @since 9.4RC1\n     */\n    public DocumentReference getDocumentReference()\n    {\n        DocumentReference documentReference = getDocumentReferenceResolver().resolve(getFullName());\n\n        Locale localeValue = getLocale();\n        if (localeValue != null) {\n            documentReference = new DocumentReference(documentReference, localeValue);\n        }\n\n        return documentReference;\n    }\n\n    private static DocumentReferenceResolver<String> getDocumentReferenceResolver()\n    {\n        return Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n    }\n\n    /**\n     * @return {@link XWikiDocument#getLanguage()}\n     * @deprecated since 8.0M1, use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return getLocale().toString();\n    }\n\n    /**\n     * @return {@link XWikiDocument#getLocale()}\n     * @since 8.0M1\n     */\n    public Locale getLocale()\n    {\n        return this.locale != null ? this.locale : Locale.ROOT;\n    }\n\n    /**\n     * @param locale - {@link XWikiDocument#getLanguage()} to set\n     * @deprecated since 8.0M1\n     */\n    @Deprecated\n    protected void setLanguage(String locale)\n    {\n        this.locale = LocaleUtils.toLocale(Util.normalizeLanguage(locale), Locale.ROOT);\n    }\n\n    /**\n     * @return the date of delete action\n     */\n    public Date getDate()\n    {\n        return this.date;\n    }\n\n    /**\n     * @param date - the date of delete action to set\n     */\n    protected void setDate(Date date)\n    {\n        this.date = date;\n    }\n\n    /**\n     * @return the user which has removed the document\n     */\n    public String getDeleter()\n    {\n        return this.deleter;\n    }\n\n    /**\n     * @return the reference of the user who deleted this document\n     * @since 11.5RC1\n     */\n    public DocumentReference getDeleterReference()\n    {\n        return getDocumentReferenceResolver().resolve(this.deleter);\n    }\n\n    /**\n     * @param deleter - the user which has removed the document to set\n     */\n    protected void setDeleter(String deleter)\n    {\n        this.deleter = deleter;\n    }\n\n    /**\n     * @return the type of the store used for the content\n     * @since 9.0RC1\n     */\n    public String getXmlStore()\n    {\n        return this.xmlStore;\n    }\n\n    /**\n     * @param xmlStore the type of store (supported values are null/\"hibernate\" and \"file\")\n     * @since 9.0RC1\n     */\n    protected void setXmlStore(String xmlStore)\n    {\n        this.xmlStore = xmlStore;\n    }\n\n    /**\n     * Only used in Hibernate.\n     * \n     * @return xml serialization of {@link XWikiDocument}\n     */\n    public String getXml()\n    {\n        if (this.content != null) {\n            try {\n                return this.content.getContentAsString();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        // Return empty String instead of null because this field is configured as not null at database level\n        return \"\";\n    }\n\n    /**\n     * Only used in Hibernate.\n     * \n     * @param xml - xml serialization of {@link XWikiDocument}\n     */\n    protected void setXml(String xml)\n    {\n        if (StringUtils.isNotEmpty(xml)) {\n            try {\n                this.content = new XWikiHibernateDeletedDocumentContent(xml);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n\n    /**\n     * Export {@link XWikiDocument} to {@link XWikiDeletedDocument}.\n     *\n     * @param doc - the deleted document\n     * @param context - used in {@link XWikiDocument#toXML(XWikiContext)}\n     * @throws XWikiException in error in {@link XWikiDocument#toXML(XWikiContext)}\n     * @deprecated since 9.0RC1, use\n     *             {@link XWikiDeletedDocument#XWikiDeletedDocument(String, Locale, String, String, Date, XWikiDeletedDocumentContent)\n     *             instead}\n     */\n    @Deprecated\n    protected void setDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        this.content = new XWikiHibernateDeletedDocumentContent(doc);\n    }\n\n    /**\n     * @return restored document\n     * @param doc optional object where to put the document data, if not <code>null</code>\n     * @param context the current {@link XWikiContext context}\n     * @throws XWikiException if error in {@link XWikiDocument#fromXML(String)}\n     */\n    public XWikiDocument restoreDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        if (this.content == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Cannot find any content for the deleted document [\" + this.fullName + \" (\" + this.locale + \")]\");\n        }\n\n        try {\n            return this.content.getXWikiDocument(doc);\n        } catch (IOException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_DOC, XWikiException.ERROR_DOC_XML_PARSING,\n                \"Error restoring document\", e, null);\n        }\n    }\n\n    /**\n     * @return restored document\n     * @param context the current {@link XWikiContext context}\n     * @throws XWikiException if error in {@link XWikiDocument#fromXML(String)}\n     * @since 9.0RC1\n     */\n    public XWikiDocument restoreDocument(XWikiContext context) throws XWikiException\n    {\n        return restoreDocument(null, context);\n    }\n\n    /**\n     * @param batchId batch operation ID to set\n     * @since 9.4RC1\n     */\n    protected void setBatchId(String batchId)\n    {\n        this.batchId = batchId;\n    }\n\n    /**\n     * @return the id of the operation that deleted multiple documents at the same time, including this one\n     * @since 9.4RC1\n     */\n    public String getBatchId()\n    {\n        return batchId;\n    }\n\n    @Override\n    public String toString()\n    {\n        return new ToStringBuilder(this)\n            .append(\"id\", id)\n            .append(\"fullName\", fullName)\n            .append(\"locale\", locale)\n            .toString();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.doc;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * The default implementation of {@link DocumentRevisionProvider}.\n * <p>\n * The main job of {@link DefaultDocumentRevisionProvider} is to call the right {@link DocumentRevisionProvider}\n * depending on the revision prefix.\n * \n * @version $Id$\n * @since 9.3rc1\n */\n@Component\n@Singleton\npublic class DefaultDocumentRevisionProvider extends AbstractDocumentRevisionProvider\n{\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    @Named(\"database\")\n    private DocumentRevisionProvider databaseDocumentRevisionProvider;\n\n    private Pair<String, String> parseRevision(String revision)\n    {\n        String revisionPrefix = null;\n        if (revision != null) {\n            int revisionPrefixIndex = revision.indexOf(':');\n            if (revisionPrefixIndex > 0) {\n                revisionPrefix = revision.substring(0, revisionPrefixIndex);\n            }\n        }\n        String shortRevision;\n        if (revisionPrefix != null) {\n            shortRevision = revision.substring(revisionPrefix.length() + 1);\n        } else {\n            shortRevision = revision;\n        }\n        return Pair.of(revisionPrefix, shortRevision);\n    }\n\n    private DocumentRevisionProvider getProvider(String revisionPrefix) throws XWikiException\n    {\n        // Find the provider\n        DocumentRevisionProvider provider = this.databaseDocumentRevisionProvider;\n        if (revisionPrefix != null) {\n            ComponentManager componentManager = this.componentManagerProvider.get();\n            if (componentManager.hasComponent(DocumentRevisionProvider.class, revisionPrefix)) {\n                try {\n                    provider = componentManager.getInstance(DocumentRevisionProvider.class, revisionPrefix);\n                } catch (ComponentLookupException e) {\n                    throw new XWikiException(\"Failed to get revision provider for revision [\" + revisionPrefix + \"]\",\n                        e);\n                }\n            }\n        }\n        return provider;\n    }\n\n    @Override\n    public XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException\n    {\n        Pair<String, String> parsedRevision = parseRevision(revision);\n\n        // Load the document revision\n        return getProvider(parsedRevision.getLeft()).getRevision(reference, parsedRevision.getRight());\n    }\n\n    @Override\n    public void checkAccess(Right right, UserReference userReference, DocumentReference documentReference,\n        String revision) throws AuthorizationException, XWikiException\n    {\n        Pair<String, String> parsedRevision = parseRevision(revision);\n\n        getProvider(parsedRevision.getLeft())\n            .checkAccess(right, userReference, documentReference, parsedRevision.getRight());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.doc;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Get deleted document revisions from the database.\n * \n * @version $Id$\n * @since 9.4RC1\n */\n@Component\n@Named(\"deleted\")\n@Singleton\npublic class DeletedDocumentRevisionProvider implements DocumentRevisionProvider\n{\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Override\n    public XWikiDocument getRevision(DocumentReference reference, String revision) throws XWikiException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        XWikiDeletedDocument deletedDocument = xcontext.getWiki().getDeletedDocument(Long.valueOf(revision), xcontext);\n\n        // Only local the document if it matches the asked document reference\n        if (deletedDocument != null\n            && (reference == null || deletedDocument.getDocumentReference().equals(reference))) {\n            return deletedDocument.restoreDocument(xcontext);\n        }\n\n        return null;\n    }\n\n    @Override\n    public XWikiDocument getRevision(XWikiDocument document, String revision) throws XWikiException\n    {\n        return getRevision(document != null ? document.getDocumentReferenceWithLocale() : null, revision);\n    }\n\n    @Override\n    public void checkAccess(Right right, UserReference userReference, DocumentReference documentReference,\n        String revision) throws AuthorizationException, XWikiException\n    {\n        XWikiContext xcontext = this.xcontextProvider.get();\n\n        XWikiDeletedDocument deletedDocument = xcontext.getWiki().getDeletedDocument(Long.valueOf(revision), xcontext);\n        if (deletedDocument != null) {\n            xcontext.getWiki().getRecycleBinStore().checkAccess(right, userReference, deletedDocument);\n        }\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.Path;\nimport javax.persistence.criteria.Predicate;\nimport javax.persistence.criteria.Root;\n\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.hibernate.HibernateException;\nimport org.hibernate.Session;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceSerializer;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDeletedDocumentContent;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.XWikiHibernateDeletedDocumentContent;\n\n/**\n * Realization of {@link XWikiRecycleBinStoreInterface} for Hibernate store.\n *\n * @version $Id$\n */\n@Component\n@Named(XWikiHibernateBaseStore.HINT)\n@Singleton\npublic class XWikiHibernateRecycleBinStore extends XWikiHibernateBaseStore implements XWikiRecycleBinStoreInterface\n{\n    @Inject\n    private AuthorizationManager authorizationManager;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceSerializer<DocumentReference> userReferenceSerializer;\n\n    /**\n     * {@link HibernateCallback} used to retrieve from the recycle bin store the deleted versions of a document.\n     */\n    private static class DeletedDocumentsHibernateCallback implements HibernateCallback<XWikiDeletedDocument[]>\n    {\n        /**\n         * The document whose versions are retrieved from the recycle bin store.\n         */\n        private XWikiDocument document;\n\n        /**\n         * Creates a new call-back for the given document.\n         *\n         * @param document the document whose deleted versions you want to retrieve from the recycle bin store\n         */\n        DeletedDocumentsHibernateCallback(XWikiDocument document)\n        {\n            this.document = document;\n        }\n\n        @Override\n        public XWikiDeletedDocument[] doInHibernate(Session session) throws HibernateException, XWikiException\n        {\n            CriteriaBuilder builder = session.getCriteriaBuilder();\n            CriteriaQuery<XWikiDeletedDocument> query = builder.createQuery(XWikiDeletedDocument.class);\n            Root<XWikiDeletedDocument> root = query.from(XWikiDeletedDocument.class);\n\n            query.select(root);\n\n            Predicate[] predicates = new Predicate[2];\n\n            predicates[0] = builder.equal(root.get(FULL_NAME_FIELD), this.document.getFullName());\n\n            // Note: We need to support databases who treats empty strings as NULL like Oracle. For those checking\n            // for equality when the string is empty is not going to work and thus we need to handle the special\n            // empty case separately.\n            Locale language = this.document.getLocale();\n            Path<String> languageProperty = root.get(LANGUAGE_PROPERTY_NAME);\n            if (language.equals(Locale.ROOT)) {\n                predicates[1] = builder.or(builder.equal(languageProperty, \"\"), builder.isNull(languageProperty));\n            } else {\n                predicates[1] = builder.equal(languageProperty, language);\n            }\n\n            query.where(predicates);\n\n            query.orderBy(builder.desc(root.get(\"date\")));\n\n            List<XWikiDeletedDocument> deletedVersions = session.createQuery(query).getResultList();\n\n            return deletedVersions.toArray(new XWikiDeletedDocument[deletedVersions.size()]);\n        }\n    }\n\n    /**\n     * {@link HibernateCallback} used to retrieve from the recycle bin store the deleted document versions from a given\n     * batch.\n     */\n    private static class DeletedDocumentsBatchHibernateCallback implements HibernateCallback<XWikiDeletedDocument[]>\n    {\n        private String batchId;\n\n        /**\n         * Creates a new call-back for the given batch.\n         *\n         * @param batchId the ID of the batch of deleted documents you want to retrieve from the recycle bin store\n         */\n        DeletedDocumentsBatchHibernateCallback(String batchId)\n        {\n            this.batchId = batchId;\n        }\n\n        @Override\n        public XWikiDeletedDocument[] doInHibernate(Session session) throws HibernateException, XWikiException\n        {\n            CriteriaBuilder builder = session.getCriteriaBuilder();\n            CriteriaQuery<XWikiDeletedDocument> query = builder.createQuery(XWikiDeletedDocument.class);\n            Root<XWikiDeletedDocument> root = query.from(XWikiDeletedDocument.class);\n\n            query.select(root);\n\n            query.where(builder.equal(root.get(\"batchId\"), batchId));\n\n            query.orderBy(builder.asc(root.get(FULL_NAME_FIELD)));\n\n            List<XWikiDeletedDocument> deletedVersions = session.createQuery(query).getResultList();\n\n            return deletedVersions.toArray(new XWikiDeletedDocument[deletedVersions.size()]);\n        }\n    }\n\n    private static final String FULL_NAME_FIELD = \"fullName\";\n\n    /**\n     * Name of the language property in the Hibernate mapping.\n     */\n    private static final String LANGUAGE_PROPERTY_NAME = \"language\";\n\n    @Inject\n    private StoreConfiguration storeConfiguration;\n\n    @Inject\n    private ComponentManager componentManager;\n\n    @Inject\n    private Logger logger;\n\n    /**\n     * @param context used for environment\n     * @deprecated 1.6M1. Use ComponentManager#getInstance(XWikiRecycleBinStoreInterface.class) instead.\n     */\n    @Deprecated\n    public XWikiHibernateRecycleBinStore(XWikiContext context)\n    {\n        super(context.getWiki(), context);\n    }\n\n    /**\n     * Empty constructor needed for component manager.\n     */\n    public XWikiHibernateRecycleBinStore()\n    {\n    }\n\n    private XWikiRecycleBinContentStoreInterface getDefaultXWikiRecycleBinContentStore() throws XWikiException\n    {\n        try {\n            return this.storeConfiguration.getXWikiRecycleBinContentStore();\n        } catch (ComponentLookupException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to lookup recycle bin content store\", e);\n        }\n    }\n\n    private XWikiRecycleBinContentStoreInterface getXWikiRecycleBinContentStore(String storeType)\n    {\n        if (storeType != null && !storeType.equals(HINT)) {\n            try {\n                return this.componentManager.getInstance(XWikiRecycleBinContentStoreInterface.class, storeType);\n            } catch (ComponentLookupException e) {\n                this.logger.warn(\"Can't find recycle bin content store for type [{}]\", storeType, e);\n            }\n        }\n\n        return null;\n    }\n\n    private XWikiDeletedDocument resolveDeletedDocumentContent(XWikiDeletedDocument deletedDocument,\n        boolean bTransaction) throws XWikiException\n    {\n        XWikiRecycleBinContentStoreInterface contentStore =\n            getXWikiRecycleBinContentStore(deletedDocument.getXmlStore());\n\n        if (contentStore != null) {\n            XWikiDeletedDocumentContent content =\n                contentStore.get(deletedDocument.getDocumentReference(), deletedDocument.getId(), bTransaction);\n\n            try {\n                FieldUtils.writeDeclaredField(deletedDocument, \"content\", content, true);\n            } catch (IllegalAccessException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to set deleted document content\", e);\n            }\n        }\n\n        return deletedDocument;\n    }\n\n    private XWikiDeletedDocument createXWikiDeletedDocument(XWikiDocument doc, String deleter, Date date,\n        XWikiRecycleBinContentStoreInterface contentStore, String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument trashdoc;\n\n        String storeType = null;\n        XWikiDeletedDocumentContent deletedDocumentContent = null;\n\n        if (contentStore != null) {\n            storeType = contentStore.getHint();\n        } else {\n            deletedDocumentContent = new XWikiHibernateDeletedDocumentContent(doc);\n        }\n\n        trashdoc = new XWikiDeletedDocument(doc.getFullName(), doc.getLocale(), storeType, deleter, date,\n            deletedDocumentContent, batchId);\n\n        return trashdoc;\n    }\n\n    private void deleteDeletedDocumentContent(XWikiDeletedDocument deletedDocument, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiRecycleBinContentStoreInterface contentStore =\n            getXWikiRecycleBinContentStore(deletedDocument.getXmlStore());\n\n        if (contentStore != null) {\n            contentStore.delete(deletedDocument.getDocumentReference(), deletedDocument.getId(), bTransaction);\n        }\n    }\n\n    @Override\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, XWikiContext inputxcontext,\n        boolean bTransaction) throws XWikiException\n    {\n        saveToRecycleBin(doc, deleter, date, null, inputxcontext, bTransaction);\n    }\n\n    @Override\n    public void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, String batchId,\n        XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            executeWrite(context, session -> {\n                XWikiRecycleBinContentStoreInterface contentStore = getDefaultXWikiRecycleBinContentStore();\n\n                XWikiDeletedDocument trashdoc = createXWikiDeletedDocument(doc, deleter, date, contentStore, batchId);\n\n                // Hibernate store.\n                long index = ((Number) session.save(trashdoc)).longValue();\n\n                // External store\n                if (contentStore != null) {\n                    contentStore.save(doc, index, bTransaction);\n                }\n\n                return null;\n            });\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public XWikiDocument restoreFromRecycleBin(final XWikiDocument doc, final long index,\n        final XWikiContext inputxcontext, boolean bTransaction) throws XWikiException\n    {\n        return restoreFromRecycleBin(index, inputxcontext, bTransaction);\n    }\n\n    @Override\n    public XWikiDocument restoreFromRecycleBin(long index, XWikiContext inputxcontext, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiContext context = getExecutionXContext(inputxcontext, true);\n\n        try {\n            XWikiDeletedDocument deletedDocument = getDeletedDocument(index, context, bTransaction);\n            return deletedDocument.restoreDocument(context);\n        } finally {\n            restoreExecutionXContext();\n        }\n    }\n\n    @Override\n    public XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, final long index, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        return getDeletedDocument(index, context, bTransaction);\n    }\n\n    @Override\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context, true, bTransaction);\n    }\n\n    private XWikiDeletedDocument getDeletedDocument(final long index, XWikiContext context, boolean resolve,\n        boolean bTransaction) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            XWikiDeletedDocument deletedDocument = session.get(XWikiDeletedDocument.class, Long.valueOf(index));\n\n            if (deletedDocument != null && resolve) {\n                deletedDocument = resolveDeletedDocumentContent(deletedDocument, false);\n            }\n\n            return deletedDocument;\n        });\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = executeRead(context, new DeletedDocumentsHibernateCallback(doc));\n\n        // Resolve deleted document content if needed\n        for (int i = 0; i < deletedDocuments.length; ++i) {\n            deletedDocuments[i] = resolveDeletedDocumentContent(deletedDocuments[i], bTransaction);\n        }\n\n        return deletedDocuments;\n    }\n\n    @Override\n    public Long[] getAllDeletedDocumentsIds(XWikiContext context, int limit) throws XWikiException\n    {\n        return executeRead(context, session -> {\n            org.hibernate.query.Query<Long> query =\n                session.createQuery(\"SELECT id FROM XWikiDeletedDocument ORDER BY date DESC\", Long.class);\n\n            if (limit > 0) {\n                query.setMaxResults(limit);\n            }\n\n            List<Long> deletedDocIds = query.list();\n            Long[] result = new Long[deletedDocIds.size()];\n            return deletedDocIds.toArray(result);\n        });\n    }\n\n    @Override\n    public Long getNumberOfDeletedDocuments(XWikiContext context) throws XWikiException\n    {\n\n        return executeRead(context, session -> {\n            org.hibernate.query.Query<Long> query =\n                session.createQuery(\"SELECT count(id) FROM XWikiDeletedDocument\", Long.class);\n\n            return query.uniqueResult();\n        });\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        return getAllDeletedDocuments(batchId, true, context, bTransaction);\n    }\n\n    @Override\n    public XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, boolean withContent, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments =\n            executeRead(context, new DeletedDocumentsBatchHibernateCallback(batchId));\n\n        // Resolve deleted document content if needed\n        if (withContent) {\n            for (int i = 0; i < deletedDocuments.length; ++i) {\n                XWikiDeletedDocument deletedDocument = deletedDocuments[i];\n                deletedDocuments[i] = resolveDeletedDocumentContent(deletedDocument, bTransaction);\n            }\n        }\n\n        return deletedDocuments;\n    }\n\n    @Override\n    public void deleteFromRecycleBin(XWikiDocument doc, final long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        deleteFromRecycleBin(index, context, bTransaction);\n    }\n\n    @Override\n    public void deleteFromRecycleBin(final long index, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        executeWrite(context, session -> {\n            XWikiDeletedDocument deletedDocument = getDeletedDocument(index, context, false, bTransaction);\n\n            // Delete metadata\n            session.delete(deletedDocument);\n\n            // Delete content\n            deleteDeletedDocumentContent(deletedDocument, bTransaction);\n\n            return null;\n        });\n    }\n\n    @Override\n    public void checkAccess(Right right, UserReference userReference, XWikiDeletedDocument deletedDocument)\n        throws AuthorizationException\n    {\n        if (!this.hasAccess(right, userReference, deletedDocument)) {\n            throw new AuthorizationException(\n                String.format(\"[%s] cannot access deleted document [%s] for right [%s]: \"\n                    + \"only admin or deleter of the document are authorized\",\n                    userReference, deletedDocument, right));\n        }\n    }\n\n    @Override\n    public boolean hasAccess(Right right, UserReference userReference, XWikiDeletedDocument deletedDocument)\n    {\n        DocumentReference documentReference = deletedDocument.getDocumentReference();\n        DocumentReference userDocReference = this.userReferenceSerializer.serialize(userReference);\n\n        boolean result = false;\n        if (this.authorizationManager.hasAccess(Right.ADMIN, userDocReference, documentReference)\n            || (Objects.equals(deletedDocument.getDeleterReference(), userDocReference)\n            && this.authorizationManager.hasAccess(right, userDocReference, documentReference))) {\n            result = true;\n        }\n        return result;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.store;\n\nimport java.util.Date;\n\nimport org.xwiki.component.annotation.Role;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.user.UserReference;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\n/**\n * Interface for RecycleBin feature (XWIKI-543) store system.\n *\n * @version $Id$\n * @since 1.2M1\n */\n@Role\npublic interface XWikiRecycleBinStoreInterface\n{\n    /**\n     * Save document to recycle bin.\n     *\n     * @param doc - document to save\n     * @param deleter - the user which delete document\n     * @param date - date of delete action\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @param context - used while saving\n     * @throws XWikiException if error in saving\n     */\n    void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Save document to recycle bin.\n     *\n     * @param doc - document to save\n     * @param deleter - the user which delete document\n     * @param date - date of delete action\n     * @param batchId - id of the operation that deleted multiple documents at the same time, useful when trying to\n     *            revert the operation. {@code null} or empty values are ignored\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @param context - used while saving\n     * @throws XWikiException if error in saving\n     * @since 9.4RC1\n     */\n    default void saveToRecycleBin(XWikiDocument doc, String deleter, Date date, String batchId, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        // XXX: The current signature does not return the saved document index so we have no way of setting the batchId\n        // to the save document. This means we can`t completely respect the method`s contract, but at least the most\n        // important part of the work is done and the document can be individually restored.\n        saveToRecycleBin(doc, deleter, date, context, bTransaction);\n    }\n\n    /**\n     * @return restored document from recycle bin\n     * @param doc - document to restore\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if error while loading\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #restoreFromRecycleBin(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    XWikiDocument restoreFromRecycleBin(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return the restored document from recycle bin\n     * @throws XWikiException if error while loading\n     * @since 9.4RC1\n     */\n    default XWikiDocument restoreFromRecycleBin(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        return restoreFromRecycleBin(new XWikiDocument(), index, context, bTransaction);\n    }\n\n    /**\n     * @return specified deleted document from recycle bin. null if not found.\n     * @param doc - deleted document\n     * @param index - what deleted document to restore. see {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if error while loading\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #getDeletedDocument(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    XWikiDeletedDocument getDeletedDocument(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * @param index - what deleted document to restore. See {@link XWikiDeletedDocument#getId()}\n     * @param context - used while loading\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return specified deleted document from recycle bin or {@code null} if not found.\n     * @throws XWikiException if error while loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        return getDeletedDocument(new XWikiDocument(), index, context, bTransaction);\n    }\n\n    /**\n     * @return info about all delete actions of specific document. sorted by date.\n     * @param doc - the deleted document\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException - if error in loading\n     */\n    XWikiDeletedDocument[] getAllDeletedDocuments(XWikiDocument doc, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Get all the deleted documents ID or a specified number. Sorted by date.\n     * @param context - used to load the deleted documents id.\n     * @param limit - if &gt; 0 then all deleted documents id are returned. Else the specified number.\n     * @return an array of IDs of deleted documents.\n     * @throws XWikiException - if error in loading\n     * @since 10.10RC1\n     */\n    default Long[] getAllDeletedDocumentsIds(XWikiContext context, int limit) throws XWikiException\n    {\n        return new Long[0];\n    }\n\n    /**\n     * @param context - used to realize the query.\n     * @return the number of deleted documents in the recycle bin.\n     * @throws XWikiException - if error in loading.\n     * @since 10.10RC1\n     */\n    default Long getNumberOfDeletedDocuments(XWikiContext context) throws XWikiException\n    {\n        return -1L;\n    }\n\n    /**\n     * @return info about all documents that were deleted in the same batch, as part of the same operation\n     * @param batchId - id of the operation that deleted multiple documents at the same time; useful when trying to\n     *            revert the operation\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException - if error in loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, XWikiContext context, boolean bTransaction)\n        throws XWikiException\n    {\n        // Return no results as default implementation.\n        return new XWikiDeletedDocument[0];\n    }\n\n    /**\n     * @param batchId - id of the operation that deleted multiple documents at the same time; useful when trying to\n     *            revert the operation\n     * @param withContent - {@code true} if the deleted document's content should also be loaded; {@code false} if\n     * @param context - used to load\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @return info about all documents that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException - if error in loading\n     * @since 9.4RC1\n     */\n    default XWikiDeletedDocument[] getAllDeletedDocuments(String batchId, boolean withContent, XWikiContext context,\n        boolean bTransaction) throws XWikiException\n    {\n        // Return no results as default implementation.\n        return new XWikiDeletedDocument[0];\n    }\n\n    /**\n     * Permanently delete document from recycle bin.\n     *\n     * @param doc - document to delete\n     * @param index - which instance document in recycle bin to delete\n     * @param context - used for environment\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. The document parameter is useless and gets in the way. Use\n     *             {@link #deleteFromRecycleBin(long, XWikiContext, boolean)} instead.\n     */\n    @Deprecated\n    void deleteFromRecycleBin(XWikiDocument doc, long index, XWikiContext context, boolean bTransaction)\n        throws XWikiException;\n\n    /**\n     * Permanently delete document from recycle bin.\n     *\n     * @param index - which instance document in recycle bin to delete\n     * @param context - used for environment\n     * @param bTransaction - should use old transaction(false) or create new (true)\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    default void deleteFromRecycleBin(long index, XWikiContext context, boolean bTransaction) throws XWikiException\n    {\n        // XXX: Depending on how an older implementation handled the XWikiDocument argument, it's relatively safer to\n        // pass an empty document than null. However, if the document's reference is actually used, the result might be\n        // unpredictable.\n        deleteFromRecycleBin(new XWikiDocument(), index, context, bTransaction);\n    }\n\n    /**\n     * Check if the given deleted document can be accessed for the given right by the given user.\n     * This method only throw the {@link AuthorizationException} if the right is not granted.\n     *\n     * @param right the right to check access for\n     * @param userReference the user for whom to check access\n     * @param deletedDocument the document to be accessed\n     * @throws AuthorizationException if the user doesn't have appropriate right\n     * @since 14.10RC1\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    default void checkAccess(Right right, UserReference userReference, XWikiDeletedDocument deletedDocument) throws\n        AuthorizationException\n    {\n    }\n\n    /**\n     * Check if the given deleted document can be accessed for the given right by the given user.\n     *\n     * @param right the right to check access for\n     * @param userReference the user for whom to check access\n     * @param deletedDocument the document to be accessed\n     * @return {@code true} if the user have appropriate right\n     * @since 14.10RC1\n     * @since 14.4.7\n     * @since 13.10.11\n     */\n    @Unstable\n    default boolean hasAccess(Right right, UserReference userReference, XWikiDeletedDocument deletedDocument)\n    {\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.script.ScriptContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.bridge.event.ActionExecutedEvent;\nimport org.xwiki.bridge.event.ActionExecutingEvent;\nimport org.xwiki.component.descriptor.ComponentDescriptor;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.container.Container;\nimport org.xwiki.container.Request;\nimport org.xwiki.container.servlet.ServletContainerException;\nimport org.xwiki.container.servlet.ServletContainerInitializer;\nimport org.xwiki.container.servlet.ServletRequest;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.internal.web.DocExistValidator;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.internal.DefaultJobProgress;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceProvider;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.EntityReferenceValueProvider;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.validation.EntityNameValidationConfiguration;\nimport org.xwiki.model.validation.EntityNameValidationManager;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.WrappedThreadEventListener;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.NotFoundResourceHandlerException;\nimport org.xwiki.resource.ResourceReferenceHandler;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.resource.internal.DefaultResourceReferenceHandlerChain;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.AuthorizationException;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\nimport org.xwiki.velocity.VelocityManager;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.web.LegacyAction;\nimport com.xpn.xwiki.monitor.api.MonitorPlugin;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.plugin.fileupload.FileUploadPlugin;\nimport com.xpn.xwiki.redirection.RedirectionFilter;\n\n/**\n * <p>\n * Root class for most XWiki actions. It provides a common framework that allows actions to execute just the specific\n * action code, handling the extra activities, such as preparing the context and retrieving the document corresponding\n * to the URL.\n * </p>\n * <p>\n * It defines two methods, {@link #action(XWikiContext)} and {@link #render(XWikiContext)}, that should be overridden by\n * specific actions. {@link #action(XWikiContext)} should contain the processing part of the action.\n * {@link #render(XWikiContext)} should return the name of a template that should be rendered, or manually write to the\n * {@link XWikiResponse response} stream.\n * </p>\n * <p>\n * Serving a request goes through the following phases:\n * </p>\n * <ul>\n * <li>Wrapping the request and response object in XWiki specific wrappers</li>\n * <li>Prepare the request {@link XWikiContext XWiki-specific context}</li>\n * <li>Initialize/retrieve the XWiki object corresponding to the requested wiki</li>\n * <li>Handle file uploads</li>\n * <li>Prepare the velocity context</li>\n * <li>Prepare the document objects corresponding to the requested URL</li>\n * <li>Send action pre-notifications to listeners</li>\n * <li>Run the overridden {@link #action(XWikiContext)}</li>\n * <li>If {@link #action(XWikiContext)} returns true, run the overridden {@link #render(XWikiContext)}</li>\n * <li>If {@link #render(XWikiContext)} returned a string (template name), render the template with that name</li>\n * <li>Send action post-notifications to listeners</li>\n * </ul>\n * <p>\n * During this process, also handle specific errors, like when a document does not exist, or the user does not have the\n * right to perform the current action.\n * </p>\n */\npublic abstract class XWikiAction implements LegacyAction\n{\n    public static final String ACTION_PROGRESS = \"actionprogress\";\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiAction.class);\n\n    /**\n     * Actions that need to be resolved on the main wiki instead of the current non-existing wiki. This is used to be\n     * able to render the skin even on a wiki that doesn't exist.\n     */\n    private static final List<String> ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST =\n        Arrays.asList(\"skin\", \"ssx\", \"jsx\", \"download\");\n\n    @Inject\n    protected ComponentDescriptor<LegacyAction> componentDescriptor;\n\n    @Inject\n    protected Container container;\n\n    @Inject\n    protected Execution execution;\n\n    @Inject\n    protected ObservationManager observation;\n\n    @Inject\n    @Named(\"context\")\n    private ComponentManager componentManager;\n\n    /**\n     * Indicate if the action allow asynchronous display (among which the XWiki initialization).\n     */\n    protected boolean waitForXWikiInitialization = true;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentmixedReferenceResolver;\n\n    @Inject\n    private ContextualAuthorizationManager autorization;\n\n    private ContextualLocalizationManager localization;\n\n    private JobProgressManager progress;\n\n    private ScriptContextManager scriptContextManager;\n\n    private EntityNameValidationManager entityNameValidationManager;\n\n    private EntityNameValidationConfiguration entityNameValidationConfiguration;\n\n    private EntityReferenceSerializer<String> localSerializer;\n\n    @Inject\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> userReferenceResolver;\n\n    /**\n     * @return the class of the XWikiForm in charge of parsing the request\n     * @since 13.0\n     */\n    @Unstable\n    protected Class<? extends XWikiForm> getFormClass()\n    {\n        return null;\n    }\n\n    protected ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        return this.currentmixedReferenceResolver;\n    }\n\n    /**\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected ContextualAuthorizationManager getContextualAuthorizationManager()\n    {\n        return this.autorization;\n    }\n\n    protected String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    protected JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    protected EntityNameValidationManager getEntityNameValidationManager()\n    {\n        if (this.entityNameValidationManager == null) {\n            this.entityNameValidationManager = Utils.getComponent(EntityNameValidationManager.class);\n        }\n        return this.entityNameValidationManager;\n    }\n\n    protected EntityNameValidationConfiguration getEntityNameValidationConfiguration()\n    {\n        if (this.entityNameValidationConfiguration == null) {\n            this.entityNameValidationConfiguration = Utils.getComponent(EntityNameValidationConfiguration.class);\n        }\n\n        return this.entityNameValidationConfiguration;\n    }\n\n    protected EntityReferenceSerializer<String> getLocalSerializer()\n    {\n        if (this.localSerializer == null) {\n            this.localSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return this.localSerializer;\n    }\n\n    /**\n     * @return the current unmodified {@link ScriptContext} instance\n     * @since 8.3M1\n     */\n    protected ScriptContext getCurrentScriptContext()\n    {\n        if (this.scriptContextManager == null) {\n            this.scriptContextManager = Utils.getComponent(ScriptContextManager.class);\n        }\n\n        return this.scriptContextManager.getCurrentScriptContext();\n    }\n\n    @Override\n    public void execute(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws Exception\n    {\n        XWikiContext context = null;\n\n        try {\n            // Initialize the XWiki Context which is the main object used to pass information across\n            // classes/methods. It's also wrapping the request, response, and all container objects\n            // in general.\n            context = initializeXWikiContext(servletRequest, servletResponse);\n\n            // From this line forward all information can be found in the XWiki Context.\n            execute(context);\n        } finally {\n            if (context != null) {\n                cleanupComponents();\n            }\n        }\n    }\n\n    /**\n     * Ensure that the given entity reference is valid according to the configured name strategy. Always returns true if\n     * the name strategy is not found.\n     *\n     * @param entityReference the entity reference name to validate\n     * @return {@code true} if the entity reference name is valid according to the name strategy.\n     * @since 12.0RC1\n     */\n    protected boolean isEntityReferenceNameValid(EntityReference entityReference)\n    {\n        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null\n            && this.getEntityNameValidationConfiguration().useValidation()) {\n            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {\n                Object[] args = {getLocalSerializer().serialize(entityReference)};\n                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,\n                    \"Cannot create document {0} because its name does not respect the name strategy of the wiki.\", null,\n                    args);\n                ScriptContext scontext = getCurrentScriptContext();\n                scontext.setAttribute(\"invalidNameReference\", entityReference, ScriptContext.ENGINE_SCOPE);\n                scontext.setAttribute(\"createException\", invalidNameException, ScriptContext.ENGINE_SCOPE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Write an error response to an ajax request.\n     *\n     * @param httpStatusCode The status code to set on the response.\n     * @param message The message that should be displayed.\n     * @param context the context.\n     */\n    protected void writeAjaxErrorResponse(int httpStatusCode, String message, XWikiContext context)\n    {\n        try {\n            context.getResponse().setContentType(\"text/plain\");\n            context.getResponse().setStatus(httpStatusCode);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(message);\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to send error response to AJAX save and continue request.\", e);\n        }\n    }\n\n    public void execute(XWikiContext context) throws Exception\n    {\n        MonitorPlugin monitor = null;\n        FileUploadPlugin fileupload = null;\n        DefaultJobProgress actionProgress = null;\n        String docName = \"\";\n\n        boolean debug = StringUtils.equals(context.getRequest().get(\"debug\"), \"true\");\n\n        String sasync = context.getRequest().get(\"async\");\n\n        try {\n            String action = context.getAction();\n\n            // Start progress\n            if (debug) {\n                actionProgress = new DefaultJobProgress(context.getURL().toExternalForm());\n                this.observation.addListener(new WrappedThreadEventListener(actionProgress));\n\n                // Register the action progress in the context\n                ExecutionContext econtext = this.execution.getContext();\n                if (econtext != null) {\n                    econtext.setProperty(XWikiAction.ACTION_PROGRESS, actionProgress);\n                }\n            }\n\n            getProgress().pushLevelProgress(2, this);\n\n            getProgress().startStep(this, \"Get XWiki instance\");\n\n            // Initialize context.getWiki() with the main wiki\n            XWiki xwiki;\n\n            // Verify that the requested wiki exists\n            try {\n                // Don't show init screen if async is forced to false\n                xwiki = XWiki.getXWiki(this.waitForXWikiInitialization || StringUtils.equals(sasync, \"false\"), context);\n\n                // If XWiki is still initializing display initialization template\n                if (xwiki == null) {\n                    // Display initialization template\n                    renderInit(context);\n\n                    // Initialization template has been displayed, stop here.\n                    return;\n                }\n            } catch (XWikiException e) {\n                // If the wiki asked by the user doesn't exist, then we first attempt to use any existing global\n                // redirects. If there are none, then we display the specific error template.\n                if (e.getCode() == XWikiException.ERROR_XWIKI_DOES_NOT_EXIST) {\n                    xwiki = XWiki.getMainXWiki(context);\n\n                    // Initialize the url factory\n                    XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n                    context.setURLFactory(urlf);\n\n                    // Initialize the velocity context and its bindings so that it may be used in the velocity templates\n                    // that we\n                    // are parsing below.\n                    VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n                    VelocityContext vcontext = velocityManager.getVelocityContext();\n\n                    if (!sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                        // Starting XWiki 5.0M2, 'xwiki.virtual.redirect' was removed. Warn users still using it.\n                        if (!StringUtils.isEmpty(context.getWiki().Param(\"xwiki.virtual.redirect\"))) {\n                            LOGGER.warn(String.format(\"%s %s\", \"'xwiki.virtual.redirect' is no longer supported.\",\n                                \"Please update your configuration and/or see XWIKI-8914 for more details.\"));\n                        }\n\n                        // Display the error template only for actions that are not ignored\n                        if (!ACTIONS_IGNORED_WHEN_WIKI_DOES_NOT_EXIST.contains(action)) {\n\n                            // Add localization resources to the context\n                            xwiki.prepareResources(context);\n\n                            // Set the main home page in the main space of the main wiki as the current requested entity\n                            // since we cannot set the non existing one as it would generate errors obviously...\n                            EntityReferenceValueProvider valueProvider =\n                                Utils.getComponent(EntityReferenceValueProvider.class);\n                            xwiki.setPhonyDocument(new DocumentReference(valueProvider.getDefaultValue(EntityType.WIKI),\n                                valueProvider.getDefaultValue(EntityType.SPACE),\n                                valueProvider.getDefaultValue(EntityType.DOCUMENT)), context, vcontext);\n\n                            // Parse the error template\n                            Utils.parseTemplate(context.getWiki().Param(\"xwiki.wiki_exception\", \"wikidoesnotexist\"),\n                                context);\n\n                            // Error template was displayed, stop here.\n                            return;\n                        }\n\n                        // At this point, we allow regular execution of the ignored action because even if the wiki\n                        // does not exist, we still need to allow UI resources to be retrieved (from the filesystem\n                        // and the main wiki) or our error template will not be rendered properly.\n\n                        // Proceed with serving the main wiki\n\n                    } else {\n                        // Global redirect was executed, stop here.\n                        return;\n                    }\n                } else {\n                    LOGGER.error(\"Uncaught exception during XWiki initialisation:\", e);\n                    throw e;\n                }\n            }\n\n            // Send global redirection (if any)\n            if (sendGlobalRedirect(context.getResponse(), context.getURL().toString(), context)) {\n                return;\n            }\n\n            XWikiURLFactory urlf = xwiki.getURLFactoryService().createURLFactory(context.getMode(), context);\n            context.setURLFactory(urlf);\n\n            // Handle ability to enter space URLs and convert them to page URLs (Nested Documents)\n            if (redirectSpaceURLs(action, urlf, xwiki, context)) {\n                return;\n            }\n\n            String sajax = context.getRequest().get(\"ajax\");\n            boolean ajax = false;\n            if (sajax != null && !sajax.trim().equals(\"\") && !sajax.equals(\"0\")) {\n                ajax = true;\n            }\n            context.put(\"ajax\", ajax);\n\n            boolean async = false;\n            if (StringUtils.isNotEmpty(sasync)) {\n                async = sasync.equals(\"true\");\n            } else {\n                // By default allow asynchronous rendering for \"human oriented\" actions which are not executing an ajax\n                // request\n                async = !ajax && !this.waitForXWikiInitialization;\n            }\n            Utils.getComponent(AsyncContext.class).setEnabled(async);\n\n            // Any error before this will be treated using a redirection to an error page\n\n            if (monitor != null) {\n                monitor.startTimer(\"request\");\n            }\n\n            getProgress().startStep(this, \"Execute request\");\n\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext vcontext = velocityManager.getVelocityContext();\n\n            getProgress().pushLevelProgress(7, this);\n\n            boolean eventSent = false;\n            try {\n                getProgress().startStep(this, \"Prepare documents and put them in the context\");\n\n                // Prepare documents and put them in the context\n                if (!xwiki.prepareDocuments(context.getRequest(), context, vcontext)) {\n                    return;\n                }\n\n                // Start monitoring timer\n                monitor = (MonitorPlugin) xwiki.getPlugin(\"monitor\", context);\n                if (monitor != null) {\n                    monitor.startRequest(\"\", context.getAction(), context.getURL());\n                    monitor.startTimer(\"multipart\");\n                }\n\n                getProgress().startStep(this, \"Parses multipart\");\n\n                // Parses multipart so that params in multipart are available for all actions\n                fileupload = Utils.handleMultipart(context.getRequest().getHttpServletRequest(), context);\n                if (monitor != null) {\n                    monitor.endTimer(\"multipart\");\n                }\n\n                if (monitor != null) {\n                    monitor.setWikiPage(context.getDoc().getFullName());\n                }\n\n                getProgress().startStep(this, \"Send [\" + context.getAction() + \"] action start event\");\n\n                // For the moment we're sending the XWiki context as the data, but this will be\n                // changed in the future, when the whole platform will be written using components\n                // and there won't be a need for the context.\n                try {\n                    ActionExecutingEvent event = new ActionExecutingEvent(context.getAction());\n                    this.observation.notify(event, context.getDoc(), context);\n                    eventSent = true;\n                    if (event.isCanceled()) {\n                        // Action has been canceled\n                        // TODO: do something special ?\n                        return;\n                    }\n                } catch (Throwable ex) {\n                    LOGGER.error(\"Cannot send action notifications for document [\" + context.getDoc()\n                        + \" using action [\" + context.getAction() + \"]\", ex);\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"prenotify\");\n                }\n\n                // Call the Actions\n\n                getProgress().startStep(this, \"Search and execute entity resource handler\");\n\n                // Call the new Entity Resource Reference Handler.\n                ResourceReferenceHandler entityResourceReferenceHandler = Utils.getComponent(\n                    new DefaultParameterizedType(null, ResourceReferenceHandler.class, ResourceType.class), \"bin\");\n                EntityResourceReference entityResourceReference =\n                    (EntityResourceReference) Utils.getComponent(ResourceReferenceManager.class).getResourceReference();\n\n                // We save the current action set since:\n                // - by default the action is set to \"view\" for Extensions not installed as root and contributing some\n                // new Entity Action (see https://jira.xwiki.org/browse/XWIKI-15182).\n                // - we want to set back the action in case no ResourceReferenceHandler was found to handle the URL\n                // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                String originalAction = context.getAction();\n                try {\n                    // Force the action in the context because of https://jira.xwiki.org/browse/XWIKI-15182.\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(entityResourceReference.getAction().getActionName());\n                    entityResourceReferenceHandler.handle(entityResourceReference,\n                        DefaultResourceReferenceHandlerChain.EMPTY);\n                    // Don't let the old actions kick in!\n                    return;\n                } catch (NotFoundResourceHandlerException e) {\n                    // No Entity Resource Action has been found. Don't do anything and let it go through\n                    // so that the old Action system kicks in...\n                    // Put back the action, because of https://jira.xwiki.org/browse/XWIKI-15182\n                    // TODO: Remove once https://jira.xwiki.org/browse/XWIKI-14947 is fixed\n                    context.setAction(originalAction);\n                }\n\n                getProgress().startStep(this, \"Execute action render\");\n\n                // Handle the XWiki.RedirectClass object that can be attached to the current document\n                boolean hasRedirect = handleRedirect(context);\n\n                // Then call the old Actions for backward compatibility (and because a lot of them have not been\n                // migrated to new Actions yet).\n                String renderResult = null;\n                XWikiDocument doc = context.getDoc();\n                docName = doc.getFullName();\n                if (!hasRedirect && action(context)) {\n                    renderResult = render(context);\n                }\n\n                if (renderResult != null) {\n                    // check for doc existence\n                    if (shouldReturnDocDoesNotExist(doc, context)) {\n                        String page = Utils.getPage(context.getRequest(), \"docdoesnotexist\");\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, context);\n                    } else {\n                        String page = Utils.getPage(context.getRequest(), renderResult);\n\n                        getProgress().startStep(this, \"Execute template [\" + page + \"]\");\n                        Utils.parseTemplate(page, !page.equals(\"direct\"), context);\n                    }\n                }\n                return;\n            } catch (Throwable e) {\n                if (e instanceof IOException) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP,\n                        XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION, \"Exception while sending response\", e);\n                }\n\n                if (!(e instanceof XWikiException)) {\n                    e = new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_UNKNOWN,\n                        \"Uncaught exception\", e);\n                }\n\n                try {\n                    XWikiException xex = (XWikiException) e;\n                    if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        // Connection aborted from the client side, there's not much we can do on the server side. We\n                        // simply ignore it.\n                        LOGGER.debug(\"Connection aborted\", e);\n                        // We don't write any other message to the response, as the connection is broken, anyway.\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_ACCESS_DENIED) {\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.access_exception\", \"accessdenied\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_INACTIVE\n                        || xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                        if (xex.getCode() == XWikiException.ERROR_XWIKI_USER_DISABLED) {\n                            context.put(\"cause\", \"disabled\");\n                        }\n                        // In case of user disabled or inactive, the resources are actually forbidden.\n                        context.getResponse().setStatus(HttpServletResponse.SC_FORBIDDEN);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.user_exception\", \"userinactive\"), context);\n\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_ATTACHMENT_NOT_FOUND) {\n                        context.put(\"message\", \"attachmentdoesnotexist\");\n                        Utils.parseTemplate(\n                            context.getWiki().Param(\"xwiki.attachment_exception\", \"attachmentdoesnotexist\"), context);\n                        return;\n                    } else if (xex.getCode() == XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION) {\n                        vcontext.put(\"message\", localizePlainOrKey(\"platform.core.invalidUrl\"));\n                        xwiki.setPhonyDocument(xwiki.getDefaultSpace(context) + \".\" + xwiki.getDefaultPage(context),\n                            context, vcontext);\n                        context.getResponse().setStatus(HttpServletResponse.SC_BAD_REQUEST);\n                        Utils.parseTemplate(context.getWiki().Param(\"xwiki.invalid_url_exception\", \"error\"), context);\n                        return;\n                    }\n                    // Note: We don't use the vcontext variable computed above since apparently the velocity context\n                    // can have changed in between. Thus we get it again to be sure we're setting the binding in the\n                    // right one.\n                    velocityManager.getVelocityContext().put(\"exp\", e);\n                    if (LOGGER.isWarnEnabled()) {\n                        // Don't log \"Broken Pipe\" exceptions since they're not real errors and we don't want to pollute\n                        // the logs with unnecessary stack traces. It just means the client side has cancelled the\n                        // connection.\n                        if (ExceptionUtils.getRootCauseMessage(e).equals(\"IOException: Broken pipe\")) {\n                            return;\n                        }\n                        LOGGER.warn(\"Uncaught exception: \" + e.getMessage(), e);\n                    }\n                    // If the request is an AJAX request, we don't return a whole HTML page, but just the exception\n                    // inline.\n                    String exceptionTemplate = ajax ? \"exceptioninline\" : \"exception\";\n                    Utils.parseTemplate(Utils.getPage(context.getRequest(), exceptionTemplate), context);\n                    return;\n                } catch (XWikiException ex) {\n                    if (ex.getCode() == XWikiException.ERROR_XWIKI_APP_SEND_RESPONSE_EXCEPTION) {\n                        LOGGER.error(\"Connection aborted\");\n                    }\n                } catch (Exception e2) {\n                    // I hope this never happens\n                    LOGGER.error(\"Uncaught exceptions (inner): \", e);\n                    LOGGER.error(\"Uncaught exceptions (outer): \", e2);\n                }\n                return;\n            } finally {\n                // Let's make sure we have flushed content and closed\n                try {\n                    context.getResponse().getWriter().flush();\n                } catch (Throwable e) {\n                    // This might happen if the connection was closed, for example.\n                    // If we can't flush, then there's nothing more we can send to the client.\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"request\");\n                    monitor.startTimer(\"notify\");\n                }\n\n                if (eventSent) {\n                    // For the moment we're sending the XWiki context as the data, but this will be\n                    // changed in the future, when the whole platform will be written using components\n                    // and there won't be a need for the context.\n                    try {\n                        this.observation.notify(new ActionExecutedEvent(context.getAction()), context.getDoc(), context);\n                    } catch (Throwable ex) {\n                        LOGGER.error(\"Cannot send action notifications for document [\" + docName + \" using action [\"\n                            + context.getAction() + \"]\", ex);\n                    }\n                }\n\n                if (monitor != null) {\n                    monitor.endTimer(\"notify\");\n                }\n\n                getProgress().startStep(this, \"Cleanup database connections\");\n\n                // Make sure we cleanup database connections\n                // There could be cases where we have some\n                xwiki.getStore().cleanUp(context);\n\n                getProgress().popLevelProgress(this);\n            }\n        } finally {\n            // End request\n            if (monitor != null) {\n                monitor.endRequest();\n            }\n\n            // Stop progress\n            if (actionProgress != null) {\n                getProgress().popLevelProgress(this);\n\n                this.observation.removeListener(actionProgress.getName());\n            }\n\n            if (fileupload != null) {\n                fileupload.cleanFileList(context);\n            }\n        }\n    }\n\n    /**\n     * Check if the given document exists or not and if it should return a 404 based on the context. A {@link\n     * DocExistValidator} with an hint matching the current action is used to check if the document exists. When no\n     * {@link DocExistValidator} is found, the response is always {@code false} When a {@link DocExistValidator} is\n     * found, the result is delegated to {@link DocExistValidator#docExist(XWikiDocument, XWikiContext)}.\n     *\n     * @param doc the doc for which to check it exists or not\n     * @param context the current context\n     * @return {@code true} if we should return a 404\n     * @throws ComponentLookupException if an error occurs when instantiating a {@link DocExistValidator}\n     */\n    private boolean shouldReturnDocDoesNotExist(XWikiDocument doc, XWikiContext context) throws ComponentLookupException\n    {\n        boolean result = false;\n        String action = context.getAction();\n        if (this.componentManager.hasComponent(DocExistValidator.class, action)) {\n            result = this.componentManager.<DocExistValidator>getInstance(DocExistValidator.class, action)\n                .docExist(doc, context);\n        }\n        return result;\n    }\n\n    private void renderInit(XWikiContext xcontext) throws Exception\n    {\n        RenderingContext renderingContext = Utils.getComponent(RenderingContext.class);\n        MutableRenderingContext mutableRenderingContext =\n            renderingContext instanceof MutableRenderingContext ? (MutableRenderingContext) renderingContext : null;\n\n        if (mutableRenderingContext != null) {\n            mutableRenderingContext.push(renderingContext.getTransformation(), renderingContext.getXDOM(),\n                renderingContext.getDefaultSyntax(), \"init.vm\", renderingContext.isRestricted(), Syntax.XHTML_1_0);\n        }\n\n        xcontext.getResponse().setStatus(202);\n        xcontext.getResponse().setContentType(\"text/html; charset=UTF-8\");\n\n        try {\n            Utils.getComponent(TemplateManager.class).render(\"init.vm\", xcontext.getResponse().getWriter());\n        } finally {\n            if (mutableRenderingContext != null) {\n                mutableRenderingContext.pop();\n            }\n        }\n\n        xcontext.getResponse().flushBuffer();\n\n        xcontext.setFinished(true);\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse)\n        throws XWikiException, ServletException, InstantiationException, IllegalAccessException\n    {\n        XWikiForm form;\n        if (getFormClass() != null) {\n            form = getFormClass().newInstance();\n        } else {\n            form = null;\n        }\n\n        return initializeXWikiContext(servletRequest, servletResponse, form);\n    }\n\n    /**\n     * @return the name to put in the {@link XWikiContext}, by default the component role hint is used\n     * @since 13.0\n     */\n    @Unstable\n    protected String getName()\n    {\n        return this.componentDescriptor.getRoleHint();\n    }\n\n    protected XWikiContext initializeXWikiContext(HttpServletRequest servletRequest,\n        HttpServletResponse servletResponse, XWikiForm form) throws XWikiException, ServletException\n    {\n        String action = getName();\n\n        XWikiRequest request = new XWikiServletRequest(servletRequest);\n        XWikiResponse response = new XWikiServletResponse(servletResponse);\n        XWikiContext context = Utils.prepareContext(action, request, response,\n            new XWikiServletContext(servletRequest.getServletContext()));\n\n        if (form != null) {\n            form.reset(request);\n        }\n\n        // Add the form to the context\n        context.setForm(form);\n\n        // Initialize the Container component which is the new way of transporting the Context in the new\n        // component architecture.\n        initializeContainerComponent(context);\n\n        return context;\n    }\n\n    protected void initializeContainerComponent(XWikiContext context) throws ServletException\n    {\n        // Initialize the Container fields (request, response, session).\n        // Note that this is a bridge between the old core and the component architecture.\n        // In the new component architecture we use ThreadLocal to transport the request,\n        // response and session to components which require them.\n        // In the future this Servlet will be replaced by the XWikiPlexusServlet Servlet.\n        ServletContainerInitializer containerInitializer = Utils.getComponent(ServletContainerInitializer.class);\n\n        try {\n            containerInitializer.initializeRequest(context.getRequest().getHttpServletRequest(), context);\n            containerInitializer.initializeResponse(context.getResponse());\n            containerInitializer.initializeSession(context.getRequest().getHttpServletRequest());\n        } catch (ServletContainerException e) {\n            throw new ServletException(\"Failed to initialize Request/Response or Session\", e);\n        }\n    }\n\n    protected void cleanupComponents()\n    {\n        // We must ensure we clean the ThreadLocal variables located in the Container and Execution\n        // components as otherwise we will have a potential memory leak.\n        container.removeRequest();\n        container.removeResponse();\n        container.removeSession();\n        execution.removeContext();\n    }\n\n    public String getRealPath(String path)\n    {\n        Request request = this.container.getRequest();\n\n        if (request instanceof ServletRequest) {\n            return ((ServletRequest) request).getHttpServletRequest().getServletContext().getRealPath(path);\n        }\n\n        return null;\n    }\n\n    // hook\n    public boolean action(XWikiContext context) throws XWikiException\n    {\n        return true;\n    }\n\n    // hook\n    public String render(XWikiContext context) throws XWikiException\n    {\n        return null;\n    }\n\n    /**\n     * Indicate if the action support redirection. The default value is {@code false}.\n     *\n     * @return {@code true} if the action supports redirections, {@code false} otherwise\n     * @since 14.0RC1\n     */\n    @Unstable\n    protected boolean supportRedirections()\n    {\n        return false;\n    }\n\n    private UserReference getCurrentUserReference(XWikiContext context)\n    {\n        return this.userReferenceResolver.resolve(context.getUserReference());\n    }\n\n    protected void handleRevision(XWikiContext context) throws XWikiException\n    {\n        String rev = context.getRequest().getParameter(\"rev\");\n        if (rev != null) {\n            context.put(\"rev\", rev);\n            XWikiDocument doc = (XWikiDocument) context.get(\"doc\");\n            XWikiDocument tdoc = (XWikiDocument) context.get(\"tdoc\");\n            // if the doc is deleted and we request a specific language, we have to set the locale so we can retrieve\n            // properly the document revision.\n            if (rev.startsWith(\"deleted\") && !StringUtils.isEmpty(context.getRequest().getParameter(\"language\"))\n                && doc == tdoc) {\n                Locale locale = LocaleUtils.toLocale(context.getRequest().getParameter(\"language\"), Locale.ROOT);\n                tdoc = new XWikiDocument(tdoc.getDocumentReference(), locale);\n            }\n\n            DocumentReference documentReference = doc.getDocumentReference();\n            try {\n                documentRevisionProvider\n                    .checkAccess(Right.VIEW, getCurrentUserReference(context), documentReference, rev);\n            } catch (AuthorizationException e) {\n                Object[] args = { documentReference, rev, context.getUserReference() };\n                throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                    \"Access to document {0} with revision {1} has been denied to user {2}\", e, args);\n            }\n\n            XWikiDocument rdoc;\n            XWikiDocument rtdoc;\n            if (doc.getLocale().equals(tdoc.getLocale())) {\n                rdoc = this.documentRevisionProvider.getRevision(doc.getDocumentReferenceWithLocale(), rev);\n                rtdoc = rdoc;\n            } else {\n                rdoc = doc;\n                rtdoc = this.documentRevisionProvider.getRevision(tdoc.getDocumentReferenceWithLocale(), rev);\n            }\n\n            context.put(\"tdoc\", rtdoc);\n            context.put(\"cdoc\", rdoc);\n            context.put(\"doc\", rdoc);\n        }\n    }\n\n    /**\n     * Send redirection based on a regexp pattern (if any) set at the main wiki level. To enable this feature you must\n     * add xwiki.preferences.redirect=1 to your xwiki.cfg.\n     *\n     * @param response the servlet response\n     * @param url url of the request\n     * @param context the XWiki context\n     * @return true if a redirection has been sent\n     */\n    protected boolean sendGlobalRedirect(XWikiResponse response, String url, XWikiContext context) throws Exception\n    {\n        if (\"1\".equals(context.getWiki().Param(\"xwiki.preferences.redirect\"))) {\n            // Note: This implementation is not performant at all and will slow down the wiki as the number\n            // of redirects increases. A better implementation would use a cache of redirects and would use\n            // the notification mechanism to update the cache when the XWiki.XWikiPreferences document is\n            // modified.\n            XWikiDocument globalPreferences = context.getWiki().getDocument(\"xwiki:XWiki.XWikiPreferences\", context);\n            Vector<BaseObject> redirects = globalPreferences.getObjects(\"XWiki.GlobalRedirect\");\n\n            if (redirects != null) {\n                for (BaseObject redir : redirects) {\n                    if (redir != null) {\n                        String p = redir.getStringValue(\"pattern\");\n                        if (p != null && url.matches(p)) {\n                            String dest = redir.getStringValue(\"destination\");\n                            response.sendRedirect(url.replaceAll(p, dest));\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Perform a redirect to the given URL.\n     * @param response the response to use to perform the redirect\n     * @param url the location of the redirect\n     * @throws XWikiException in case of IOException when performing the redirect.\n     */\n    protected void sendRedirect(XWikiResponse response, String url) throws XWikiException\n    {\n        try {\n            if (url != null) {\n                response.sendRedirect(response.encodeRedirectURL(url));\n            }\n        } catch (IOException e) {\n            Object[] args = {url};\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_REDIRECT_EXCEPTION,\n                \"Exception while sending redirect to page {0}\", e, args);\n        }\n    }\n\n    /**\n     * Gets the translated version of a document, in the specified language. If the translation does not exist, a new\n     * document translation is created. If the requested language does not correspond to a translation (is not defined\n     * or is the same as the main document), then the main document is returned.\n     *\n     * @param doc the main (default, untranslated) document to translate\n     * @param language the requested document language\n     * @param context the current request context\n     * @return the translated document, or the original untranslated document if the requested language is not a\n     *         translation\n     * @throws XWikiException if the translation cannot be retrieved from the database\n     */\n    protected XWikiDocument getTranslatedDocument(XWikiDocument doc, String language, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument tdoc;\n        if (StringUtils.isBlank(language) || language.equals(\"default\") || language.equals(doc.getDefaultLanguage())) {\n            tdoc = doc;\n        } else {\n            tdoc = doc.getTranslatedDocument(language, context);\n            if (tdoc == doc) {\n                tdoc = new XWikiDocument(doc.getDocumentReference());\n                tdoc.setLanguage(language);\n                tdoc.setStore(doc.getStore());\n            }\n            tdoc.setTranslation(1);\n        }\n        return tdoc;\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     */\n    protected boolean csrfTokenCheck(XWikiContext context) throws XWikiException\n    {\n        return csrfTokenCheck(context, false);\n    }\n\n    /**\n     * Perform CSRF check and redirect to the resubmission page if needed. Throws an exception if the access should be\n     * denied, returns false if the check failed and the user will be redirected to a resubmission page.\n     *\n     * @param context current xwiki context containing the request\n     * @param jsonAnswer if true, returns a JSON answer in case of AJAX request: allow to process it properly on client.\n     * @return true if the check succeeded, false if resubmission is needed\n     * @throws XWikiException if the check fails\n     * @since 11.3RC1\n     */\n    protected boolean csrfTokenCheck(XWikiContext context, boolean jsonAnswer) throws XWikiException\n    {\n        final boolean isAjaxRequest = Utils.isAjaxRequest(context);\n        CSRFToken csrf = Utils.getComponent(CSRFToken.class);\n        try {\n            String token = context.getRequest().getParameter(\"form_token\");\n            if (!csrf.isTokenValid(token)) {\n                if (isAjaxRequest) {\n                    if (jsonAnswer) {\n                        Map<String, String> jsonObject = new LinkedHashMap<>();\n                        jsonObject.put(\"errorType\", \"CSRF\");\n                        jsonObject.put(\"resubmissionURI\", csrf.getRequestURI());\n                        jsonObject.put(\"newToken\", csrf.getToken());\n                        this.answerJSON(context, HttpServletResponse.SC_FORBIDDEN, jsonObject);\n                    } else {\n                        final String csrfCheckFailedMessage = localizePlainOrKey(\"core.editors.csrfCheckFailed\");\n                        writeAjaxErrorResponse(HttpServletResponse.SC_FORBIDDEN, csrfCheckFailedMessage, context);\n                    }\n                } else {\n                    sendRedirect(context.getResponse(), csrf.getResubmissionURL());\n                }\n\n                return false;\n            }\n        } catch (XWikiException exception) {\n            // too bad\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access denied, secret token verification failed\", exception);\n        }\n        return true;\n    }\n\n    /**\n     * In order to let users enter URLs to Spaces we do the following when receiving {@code /A/B} (where A and B are\n     * spaces):\n     * <ul>\n     * <li>check that the action is \"view\" (we only support this for the view action since otherwise this would break\n     * apps written before this concept was introduced in XWiki 7.2M1)</li>\n     * <li>if A.B exists then continue</li>\n     * <li>if A.B doesn't exist then forward to A.B.WebHome</li>\n     * </ul>\n     * In order to disable this redirect you should provide the {@code spaceRedirect=false} Query String parameter and\n     * value.\n     *\n     * @since 7.2M1\n     */\n    private boolean redirectSpaceURLs(String action, XWikiURLFactory urlf, XWiki xwiki, XWikiContext context)\n        throws Exception\n    {\n        if (\"view\".equals(action) && !\"false\".equalsIgnoreCase(context.getRequest().getParameter(\"spaceRedirect\"))) {\n            DocumentReference reference = xwiki.getDocumentReference(context.getRequest(), context);\n            if (!xwiki.exists(reference, context)) {\n                String defaultDocumentName = Utils.getComponent(EntityReferenceProvider.class)\n                    .getDefaultReference(EntityType.DOCUMENT).getName();\n                // Avoid an infinite loop by ensuring we're not on a WebHome already\n                if (!reference.getName().equals(defaultDocumentName)) {\n                    // Consider the reference as a Space Reference and Construct a new reference to the home of that\n                    // Space. Then generate the URL for it and forward to it\n                    SpaceReference spaceReference = new SpaceReference(reference.getName(), reference.getParent());\n                    // Extract the anchor\n                    String anchor = new URL(context.getRequest().getRequestURL().toString()).getRef();\n                    URL forwardURL = urlf.createURL(getLocalSerializer().serialize(spaceReference), defaultDocumentName,\n                        action, context.getRequest().getQueryString(), anchor,\n                        spaceReference.getWikiReference().getName(), context);\n                    // Since createURL() contain the webapp context and since RequestDispatcher should not contain it,\n                    // we need to remove it!\n                    String webappContext = xwiki.getWebAppPath(context);\n                    String relativeURL = urlf.getURL(forwardURL, context);\n                    relativeURL = '/' + StringUtils.substringAfter(relativeURL, webappContext);\n                    context.getRequest().getRequestDispatcher(relativeURL).forward(context.getRequest(),\n                        context.getResponse());\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Answer to a request with a JSON content.\n     * \n     * @param context the current context of the request.\n     * @param status the status code to send back.\n     * @param answer the content of the JSON answer.\n     * @throws XWikiException in case of error during the serialization of the JSON.\n     */\n    protected void answerJSON(XWikiContext context, int status, Map<String, String> answer) throws XWikiException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n\n        try {\n            String jsonAnswerAsString = mapper.writeValueAsString(answer);\n            context.getResponse().setContentType(\"application/json\");\n            context.getResponse().setContentLength(jsonAnswerAsString.length());\n            context.getResponse().setStatus(status);\n            context.getResponse().setCharacterEncoding(context.getWiki().getEncoding());\n            context.getResponse().getWriter().print(jsonAnswerAsString);\n            context.setResponseSent(true);\n        } catch (IOException e) {\n            throw new XWikiException(\"Error while sending JSON answer.\", e);\n        }\n    }\n\n    /**\n     * Make sure to set the right length (or nothing) in the response.\n     * \n     * @param response the response\n     * @param length the length to set in the response\n     * @since 11.10\n     * @since 10.11.10\n     * @since 11.3.6\n     */\n    protected void setContentLength(XWikiResponse response, long length)\n    {\n        // Set the content length in the response\n        response.setContentLengthLong(length);\n    }\n\n    /**\n     * Helper used resolve the template passed to the action if the current user have access to it.\n     * \n     * @param template the template to copy\n     * @return the reference of the template if not empty and the current user have access to it\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    protected DocumentReference resolveTemplate(String template)\n    {\n        if (StringUtils.isNotBlank(template)) {\n            DocumentReference templateReference = getCurrentMixedDocumentReferenceResolver().resolve(template);\n\n            // Make sure the current user have access to the template document before copying it\n            if (getContextualAuthorizationManager().hasAccess(Right.VIEW, templateReference)) {\n                return templateReference;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper used by various actions to initialize a document by copying a template to it.\n     * \n     * @param document the document to update\n     * @param template the template to copy\n     * @param context the XWiki context\n     * @return true if the document was updated, false otherwise (for example when the current user does not have view\n     *         right on the template document)\n     * @throws XWikiException when failing to copy the template\n     * @since 12.10.6\n     * @since 13.2RC1\n     */\n    @Unstable\n    protected boolean readFromTemplate(XWikiDocument document, String template, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference templateReference = resolveTemplate(template);\n\n        if (templateReference != null) {\n            document.readFromTemplate(templateReference, context);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loop over the {@link RedirectionFilter} components until one of them perform a redirection. If none of the does,\n     * the action continues normally.\n     *\n     * @param context the current wiki content\n     * @return {@code true} if a redirection has been performed, {@code false} otherwise\n     * @throws XWikiException in case of error during the execution of a redirection filter\n     */\n    private boolean handleRedirect(XWikiContext context) throws XWikiException\n    {\n        // If no redirection are expected, this step is skipped.\n        if (this.supportRedirections()) {\n            try {\n                for (RedirectionFilter filter : this.componentManager.<RedirectionFilter>getInstanceList(\n                    RedirectionFilter.class)) {\n                    if (filter.redirect(context)) {\n                        return true;\n                    }\n                }\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(\"Failed to resolve the redirection filters list\", e);\n            }\n        }\n        return false;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.web;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.xwiki.csrf.CSRFToken;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.refactoring.job.RefactoringJobs;\nimport org.xwiki.refactoring.job.RestoreRequest;\nimport org.xwiki.refactoring.script.RefactoringScriptService;\nimport org.xwiki.refactoring.script.RequestFactory;\nimport org.xwiki.script.service.ScriptService;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.junit5.mockito.InjectComponentManager;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.test.mockito.MockitoComponentManager;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.store.XWikiHibernateRecycleBinStore;\nimport com.xpn.xwiki.test.MockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.InjectMockitoOldcore;\nimport com.xpn.xwiki.test.junit5.mockito.OldcoreTest;\nimport com.xpn.xwiki.test.reference.ReferenceComponentList;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n/**\n * Unit tests for {@link UndeleteAction}.\n *\n * @version $Id$\n */\n@OldcoreTest\n@ReferenceComponentList\nclass UndeleteActionTest\n{\n    private static final DocumentReference DELETED_REFERENCE =\n        new DocumentReference(\"xwiki\", \"Main\", \"DeletedDocument\");\n\n    private static final long ID = 13;\n\n    @MockComponent\n    private RequestFactory requestFactory;\n\n    @MockComponent\n    private CSRFToken csrfToken;\n\n    @Mock\n    private RefactoringScriptService refactoringScriptService;\n\n    @MockComponent\n    private JobExecutor jobExecutor;\n\n    @InjectMockitoOldcore\n    private MockitoOldcore oldcore;\n\n    @InjectComponentManager\n    private MockitoComponentManager componentManager;\n\n    @Mock\n    private XWikiRequest request;\n\n    @Mock\n    private Job job;\n\n    @Mock\n    private RestoreRequest jobRequest;\n\n    @Mock\n    private XWikiDeletedDocument deletedDocument;\n\n    @Mock\n    private XWikiHibernateRecycleBinStore recycleBinStore;\n\n    /**\n     * The object being tested.\n     */\n    private UndeleteAction undeleteAction = new UndeleteAction();\n\n    @BeforeEach\n    void beforeEach() throws Exception\n    {\n        this.oldcore.getXWikiContext().setRequest(this.request);\n        this.oldcore.getSpyXWiki().setRecycleBinStore(this.recycleBinStore);\n        XWikiDocument contextDocument = mock(XWikiDocument.class);\n        when(contextDocument.getDocumentReference()).thenReturn(DELETED_REFERENCE);\n        this.oldcore.getXWikiContext().setDoc(contextDocument);\n\n        when(this.jobExecutor.execute(anyString(), any())).thenReturn(this.job);\n\n        this.componentManager.registerComponent(ScriptService.class, \"refactoring\", this.refactoringScriptService);\n        when(this.refactoringScriptService.getRequestFactory()).thenReturn(this.requestFactory);\n        when(this.requestFactory.createRestoreRequest(any(List.class))).thenReturn(this.jobRequest);\n        when(this.requestFactory.createRestoreRequest(anyString())).thenReturn(this.jobRequest);\n\n        when(this.request.getParameter(\"id\")).thenReturn(String.valueOf(ID));\n\n        when(this.deletedDocument.getLocale()).thenReturn(Locale.ROOT);\n        when(deletedDocument.getLocale()).thenReturn(Locale.ROOT);\n        when(deletedDocument.getId()).thenReturn(ID);\n        when(deletedDocument.getDocumentReference()).thenReturn(DELETED_REFERENCE);\n        doReturn(this.deletedDocument).when(this.oldcore.getSpyXWiki()).getDeletedDocument(anyLong(),\n            any(XWikiContext.class));\n    }\n\n    /**\n     * Launches a RestoreJob with the current deleted document ID.\n     */\n    @Test\n    void restoreSingleDocument() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.recycleBinStore.hasAccess(any(), any(), any()))\n            .thenReturn(true);\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(Arrays.asList(ID));\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    @Test\n    void restoreSingleDocumentWhenDeleter() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.recycleBinStore.hasAccess(any(), any(), any()))\n            .thenReturn(true);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(Arrays.asList(ID));\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    @Test\n    void missingCSRFToken() throws Exception\n    {\n        // Invalid CSRF token.\n        when(this.csrfToken.isTokenValid(null)).thenReturn(false);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        // Verify that the resubmission URL was retrieved to be used in the redirect.\n        verify(this.csrfToken).getResubmissionURL();\n    }\n\n    /**\n     * When the recycle bin is disabled or when the deleted document ID is invalid, the document should not be restored.\n     */\n    @Test\n    void recycleBinDisabledOrInvalidId() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        // null is returned when the ID is invalid or the Recycle Bin is disabled.\n        doReturn(null).when(this.oldcore.getSpyXWiki()).getDeletedDocument(anyLong(), any(XWikiContext.class));\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        // Verify that we never get this far.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * Show the \"restore\" UI with the option to include the batch when restoring and to see the contents of the batch of\n     * the current deleted document.\n     */\n    @Test\n    void showBatch() throws Exception\n    {\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        when(this.recycleBinStore.hasAccess(any(), any(), any()))\n            .thenReturn(true);\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"restore\" template.\n        assertEquals(\"restore\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure that we stop to the display, since the \"confirm=true\" parameter was not passed.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * Launches a RestoreJob with the batchId of the current deleted document.\n     */\n    @Test\n    void restoreBatch() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        String batchId = \"abc123\";\n\n        when(deletedDocument.getBatchId()).thenReturn(batchId);\n\n        // Go through the screen showing the option to include the batch and displaying its contents.\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        // Option to include the entire batch when restoring is enabled.\n        when(this.request.getParameter(\"includeBatch\")).thenReturn(\"true\");\n\n        // Confirmation button pressed.\n        when(this.request.getParameter(\"confirm\")).thenReturn(\"true\");\n\n        when(this.recycleBinStore.hasAccess(any(), any(), any()))\n            .thenReturn(true);\n\n        assertFalse(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n\n        verify(this.requestFactory).createRestoreRequest(batchId);\n        verify(jobExecutor).execute(RefactoringJobs.RESTORE, jobRequest);\n        verify(job).join();\n    }\n\n    /**\n     * When trying to restore, rights are checked on the current deleted document, regardless if single or batch\n     * restore.\n     */\n    @Test\n    void notAllowedToRestoreSinglePage() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(false);\n\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"accessdenied\" template.\n        assertEquals(\"accessdenied\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure we don`t go any further.\n        verify(this.requestFactory, never()).createRestoreRequest(Arrays.asList(ID));\n    }\n\n    /**\n     * When trying to restore, rights are checked on the current deleted document, regardless if single or batch\n     * restore.\n     */\n    @Test\n    void notAllowedToRestoreBatch() throws Exception\n    {\n        when(this.csrfToken.isTokenValid(null)).thenReturn(true);\n\n        String batchId = \"abc123\";\n\n        when(this.deletedDocument.getBatchId()).thenReturn(batchId);\n\n        // Go through the screen showing the option to include the batch and displaying its contents.\n        when(this.request.getParameter(\"showBatch\")).thenReturn(\"true\");\n\n        // Option to include the entire batch when restoring is enabled.\n        when(this.request.getParameter(\"includeBatch\")).thenReturn(\"true\");\n\n        // Confirmation button pressed.\n        when(this.request.getParameter(\"confirm\")).thenReturn(\"true\");\n\n        // No rights to restore the page when checking from the Action. The job will check individual rights.\n        when(this.oldcore.getMockRightService().hasAccessLevel(any(), any(), any(), any())).thenReturn(false);\n\n        assertTrue(this.undeleteAction.action(this.oldcore.getXWikiContext()));\n        // Render the \"accessdenied\" template.\n        assertEquals(\"accessdenied\", undeleteAction.render(this.oldcore.getXWikiContext()));\n\n        // Just make sure we don`t go any further.\n        verify(this.requestFactory, never()).createRestoreRequest(batchId);\n    }\n}\n", "## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n### Show list of deleted documents\n#set($dds = $xwiki.getDeletedDocuments($tdoc.fullName, $tdoc.locale))\n#displayDeletedDocuments($dds, 'docs')\n\n#if ($doc.documentReference.name == 'WebHome')\n  ## Also display the list of terminal documents sharing the same location.\n  ## eg. If the current document is: \"A.B.WebHome\", we should also display any deleted terminal page called \"A.B\".\n  ## This is important because when the user delete a terminal document and go back to the location, she should see\n  ## the page she have just deleted, and not an empty page because A.B.WebHome has never existed...\n  #set($dds = $xwiki.getDeletedDocuments($tdoc.space, $tdoc.locale))\n  #displayDeletedDocuments($dds, 'terminal-docs', 'core.recyclebin.showListTerminalPagesMsg')\n#end\n\n#*\n * Display the given list of deleted documents\n * @param $list the list to display\n * @param $className the name of the css class to apply to the list\n * @param $message (optional) the translation key for the message which introduce the list\n *#\n#macro (displayDeletedDocuments $list $className $message)\n  #if (!$message)\n    #set ($message = 'core.recyclebin.showlistmsg')\n  #end  \n  #if($list && $list.size() > 0)\n    #set ($canDelete = $list[0].canDelete())\n    #set ($canRestore = $list[0].canUndelete())\n    #set ($canView = $list[0].canView())\n    <hr />\n    <div class=\"centered $!className\">\n      <p class=\"recyclebin-message\">$escapetool.xml($services.localization.render($message))</p>\n      <table class=\"centered\">\n       <thead>\n        <tr>\n         <th>$escapetool.xml($services.localization.render('core.recyclebin.deleter'))</td>\n         <th>$escapetool.xml($services.localization.render('core.recyclebin.deleteDate'))</td>\n         #if ($canRestore)\n           <th>$escapetool.xml($services.localization.render('core.recyclebin.batchId'))</td>\n         #end\n         <th colspan=\"2\">$escapetool.xml($services.localization.render('core.recyclebin.actions'))</th>\n        </tr>\n       </thead>\n       <tbody>\n       #foreach($dd in $list)\n        <tr>\n         <td>$xwiki.getUserName($dd.getDeleter())</td>\n         <td>\n         #if ($canView)\n           <a class=\"link-view\" href=\"$doc.getURL('view', $escapetool.url({'rev' : \"deleted:${dd.getId()}\"}))\">\n             $xwiki.formatDate($dd.getDate())\n           </a>\n         #else\n           $xwiki.formatDate($dd.getDate())\n         #end\n         </td>\n         #if ($canRestore)\n           <td><a href=\"$xwiki.getURL($dd.fullName, 'undelete', \"id=${dd.id}&amp;showBatch=true\")\">$!{dd.batchId}</a></td>\n         #end\n         <td>\n           #if($canRestore)\n             <a href=\"$xwiki.getURL($dd.getFullName(), 'undelete', \"form_token=$!{services.csrf.getToken()}&amp;id=$dd.getId()\")\" class=\"action-restore\">\n               $escapetool.xml($services.localization.render('core.recyclebin.restore'))\n             </a>\n           #end\n         </td>\n         <td>\n          #if($canDelete)\n           <a href=\"$xwiki.getURL($dd.getFullName(), 'delete', \"form_token=$!{services.csrf.getToken()}&amp;id=$dd.getId()\")\"\n            onclick=\"if (confirm('$escapetool.javascript($services.localization.render('core.recyclebin.completelyDeleteConfirm'))')) {this.href += '&amp;confirm=1'; return true;} return false;\" class=\"action-delete\">\n            $escapetool.xml($services.localization.render('core.recyclebin.delete'))\n           </a>\n          #end\n         </td>\n        </tr>\n       #end\n       </tbody>\n      </table>\n    </div>\n  #end\n#end\n"], "filenames": ["xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/DeletedDocument.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/DocumentRevisionProvider.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/doc/XWikiDeletedDocument.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/internal/doc/DefaultDocumentRevisionProvider.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/internal/doc/DeletedDocumentRevisionProvider.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/store/XWikiHibernateRecycleBinStore.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/store/XWikiRecycleBinStoreInterface.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/web/XWikiAction.java", "xwiki-platform-core/xwiki-platform-oldcore/src/test/java/com/xpn/xwiki/web/UndeleteActionTest.java", "xwiki-platform-core/xwiki-platform-web/xwiki-platform-web-templates/src/main/resources/templates/recyclebinlist.vm"], "buggy_code_start_loc": [25, 23, 26, 26, 28, 24, 24, 84, 45, 45], "buggy_code_end_loc": [153, 58, 396, 90, 71, 432, 234, 914, 240, 67], "fixing_code_start_loc": [24, 24, 27, 27, 29, 25, 25, 85, 46, 46], "fixing_code_end_loc": [184, 85, 408, 114, 86, 474, 274, 945, 245, 73], "type": "CWE-668", "message": "XWiki Commons are technical libraries common to several other top level XWiki projects. Rights added to a document are not taken into account for viewing it once it's deleted. Note that this vulnerability only impact deleted documents that where containing view rights: the view rights provided on a space of a deleted document are properly checked. The problem has been patched in XWiki 14.10 by checking the rights of current user: only admin and deleter of the document are allowed to view it.", "other": {"cve": {"id": "CVE-2023-29208", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-15T16:15:07.380", "lastModified": "2023-04-25T18:47:18.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Commons are technical libraries common to several other top level XWiki projects. Rights added to a document are not taken into account for viewing it once it's deleted. Note that this vulnerability only impact deleted documents that where containing view rights: the view rights provided on a space of a deleted document are properly checked. The problem has been patched in XWiki 14.10 by checking the rights of current user: only admin and deleter of the document are allowed to view it."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1", "versionEndExcluding": "13.10.11", "matchCriteriaId": "FB7E83A5-F68B-487F-B235-9AA7BC32B4D7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.4.0", "versionEndExcluding": "14.4.7", "matchCriteriaId": "FC782E27-0FE5-48CE-B1E6-896F47ACB5BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.5", "versionEndExcluding": "14.10", "matchCriteriaId": "569EE28C-5C86-467F-A153-DD4B9BF0053D"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/d9e947559077e947315bf700c5703dfc7dd8a8d7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-4f8g-fq6x-jqrr", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-16285", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/d9e947559077e947315bf700c5703dfc7dd8a8d7"}}