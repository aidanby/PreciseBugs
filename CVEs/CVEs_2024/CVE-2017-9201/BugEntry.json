{"buggy_code": ["// imagew-api.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// Most of the functions declared in imagew.h are defined here.\n\n#include \"imagew-config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"imagew-internals.h\"\n\n// Translate a string, using the given flags.\nIW_IMPL(void) iw_translate(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *src)\n{\n\tint ret;\n\n\tdst[0]='\\0';\n\n\tif(ctx && ctx->translate_fn) {\n\t\tret = (*ctx->translate_fn)(ctx,flags,dst,dstlen,src);\n\t}\n\telse {\n\t\tret = 0;\n\t}\n\n\tif(!ret) {\n\t\t// Not translated. Just copy the string.\n\t\tiw_strlcpy(dst,src,dstlen);\n\t}\n}\n\n// Formats and translates, and returns the resulting string in buf.\n// 'ctx' can be NULL, in which case no tranlation will happen.\nIW_IMPL(void) iw_translatev(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *fmt, va_list ap)\n{\n\tchar buf1[IW_MSG_MAX];\n\tchar buf2[IW_MSG_MAX];\n\n\t// If not translating, just format the string directly.\n\tif(!ctx || !ctx->translate_fn) {\n\t\tiw_vsnprintf(dst,dstlen,fmt,ap);\n\t\treturn;\n\t}\n\n\t// String is now in fmt.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_FORMAT|flags,buf1,sizeof(buf1),fmt);\n\t// String is now in buf1.\n\tiw_vsnprintf(buf2,sizeof(buf2),buf1,ap);\n\t// String is now in buf2.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_POSTFORMAT|flags,dst,dstlen,buf2);\n\t// String is now in dst.\n}\n\n// Formats and translates, and returns the resulting string in buf\nIW_IMPL(void) iw_translatef(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tiw_translatev(ctx,flags,dst,dstlen,fmt,ap);\n\tva_end(ap);\n}\n\nstatic void iw_warning_internal(struct iw_context *ctx, const char *s)\n{\n\tif(!ctx->warning_fn) return;\n\n\t(*ctx->warning_fn)(ctx,s);\n}\n\nIW_IMPL(void) iw_warning(struct iw_context *ctx, const char *s)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(!ctx->warning_fn) return;\n\tiw_translate(ctx,IW_TRANSLATEFLAG_WARNINGMSG,buf,sizeof(buf),s);\n\tiw_warning_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_warningv(struct iw_context *ctx, const char *fmt, va_list ap)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(!ctx->warning_fn) return;\n\tiw_translatev(ctx,IW_TRANSLATEFLAG_WARNINGMSG,buf,sizeof(buf),fmt,ap);\n\tiw_warning_internal(ctx,buf);\n}\n\n// Call the caller's warning function, if defined.\nIW_IMPL(void) iw_warningf(struct iw_context *ctx, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif(!ctx->warning_fn) return;\n\tva_start(ap, fmt);\n\tiw_warningv(ctx,fmt,ap);\n\tva_end(ap);\n}\n\nstatic void iw_set_error_internal(struct iw_context *ctx, const char *s)\n{\n\tif(ctx->error_flag) return; // Only record the first error.\n\tctx->error_flag = 1;\n\n\tif(!ctx->error_msg) {\n\t\tctx->error_msg=iw_malloc_ex(ctx,IW_MALLOCFLAG_NOERRORS,IW_MSG_MAX*sizeof(char));\n\t\tif(!ctx->error_msg) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tiw_strlcpy(ctx->error_msg,s,IW_MSG_MAX);\n}\n\nIW_IMPL(void) iw_set_error(struct iw_context *ctx, const char *s)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(ctx->error_flag) return; // Only record the first error.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,sizeof(buf),s);\n\tiw_set_error_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_set_errorv(struct iw_context *ctx, const char *fmt, va_list ap)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(ctx->error_flag) return; // Only record the first error.\n\tiw_translatev(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,sizeof(buf),fmt,ap);\n\tiw_set_error_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_set_errorf(struct iw_context *ctx, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tiw_set_errorv(ctx,fmt,ap);\n\tva_end(ap);\n}\n\nIW_IMPL(const char*) iw_get_errormsg(struct iw_context *ctx, char *buf, int buflen)\n{\n\tif(ctx->error_msg) {\n\t\tiw_strlcpy(buf,ctx->error_msg,buflen);\n\t}\n\telse {\n\t\tiw_translate(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,buflen,\"Error message not available\");\n\t}\n\n\treturn buf;\n}\n\nIW_IMPL(int) iw_get_errorflag(struct iw_context *ctx)\n{\n\treturn ctx->error_flag;\n}\n\n// Given a color type, returns the number of channels.\nIW_IMPL(int) iw_imgtype_num_channels(int t)\n{\n\tswitch(t) {\n\tcase IW_IMGTYPE_RGBA:\n\t\treturn 4;\n\tcase IW_IMGTYPE_RGB:\n\t\treturn 3;\n\tcase IW_IMGTYPE_GRAYA:\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nIW_IMPL(size_t) iw_calc_bytesperrow(int num_pixels, int bits_per_pixel)\n{\n\treturn (size_t)(((num_pixels*bits_per_pixel)+7)/8);\n}\n\nIW_IMPL(int) iw_check_image_dimensions(struct iw_context *ctx, int w, int h)\n{\n\tif(w>ctx->max_width || h>ctx->max_height) {\n\t\tiw_set_errorf(ctx,\"Image dimensions too large (%d\\xc3\\x97%d)\",w,h);\n\t\treturn 0;\n\t}\n\n\tif(w<1 || h<1) {\n\t\tiw_set_errorf(ctx,\"Invalid image dimensions (%d\\xc3\\x97%d)\",w,h);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nIW_IMPL(int) iw_is_valid_density(double density_x, double density_y, int density_code)\n{\n\tif(density_x<0.0001 || density_y<0.0001) return 0;\n\tif(density_x>10000000.0 || density_y>10000000.0) return 0;\n\tif(density_x/10.0>density_y) return 0;\n\tif(density_y/10.0>density_x) return 0;\n\tif(density_code!=IW_DENSITY_UNITS_UNKNOWN && density_code!=IW_DENSITY_UNITS_PER_METER)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void default_resize_settings(struct iw_resize_settings *rs)\n{\n\tint i;\n\trs->family = IW_RESIZETYPE_AUTO;\n\trs->edge_policy = IW_EDGE_POLICY_STANDARD;\n\trs->blur_factor = 1.0;\n\trs->translate = 0.0;\n\tfor(i=0;i<3;i++) {\n\t\trs->channel_offset[i] = 0.0;\n\t}\n}\n\nIW_IMPL(struct iw_context*) iw_create_context(struct iw_init_params *params)\n{\n\tstruct iw_context *ctx;\n\n\tif(params && params->mallocfn) {\n\t\tctx = (*params->mallocfn)(params->userdata,IW_MALLOCFLAG_ZEROMEM,sizeof(struct iw_context));\n\t}\n\telse {\n\t\tctx = iwpvt_default_malloc(NULL,IW_MALLOCFLAG_ZEROMEM,sizeof(struct iw_context));\n\t}\n\n\tif(!ctx) return NULL;\n\n\tif(params) {\n\t\tctx->userdata = params->userdata;\n\t\tctx->caller_api_version = params->api_version;\n\t}\n\n\tif(params && params->mallocfn) {\n\t\tctx->mallocfn = params->mallocfn;\n\t\tctx->freefn = params->freefn;\n\t}\n\telse {\n\t\tctx->mallocfn = iwpvt_default_malloc;\n\t\tctx->freefn = iwpvt_default_free;\n\t}\n\n\tctx->max_malloc = IW_DEFAULT_MAX_MALLOC;\n\tctx->max_width = ctx->max_height = IW_DEFAULT_MAX_DIMENSION;\n\tdefault_resize_settings(&ctx->resize_settings[IW_DIMENSION_H]);\n\tdefault_resize_settings(&ctx->resize_settings[IW_DIMENSION_V]);\n\tctx->input_w = -1;\n\tctx->input_h = -1;\n\tiw_make_srgb_csdescr_2(&ctx->img1cs);\n\tiw_make_srgb_csdescr_2(&ctx->img2cs);\n\tctx->to_grayscale=0;\n\tctx->grayscale_formula = IW_GSF_STANDARD;\n\tctx->req.include_screen = 1;\n\tctx->opt_grayscale = 1;\n\tctx->opt_palette = 1;\n\tctx->opt_16_to_8 = 1;\n\tctx->opt_strip_alpha = 1;\n\tctx->opt_binary_trns = 1;\n\n\treturn ctx;\n}\n\nIW_IMPL(void) iw_destroy_context(struct iw_context *ctx)\n{\n\tint i;\n\tif(!ctx) return;\n\tif(ctx->req.options) {\n\t\tfor(i=0; i<=ctx->req.options_count; i++) {\n\t\t\tiw_free(ctx, ctx->req.options[i].name);\n\t\t\tiw_free(ctx, ctx->req.options[i].val);\n\t\t}\n\t\tiw_free(ctx, ctx->req.options);\n\t}\n\tif(ctx->img1.pixels) iw_free(ctx,ctx->img1.pixels);\n\tif(ctx->img2.pixels) iw_free(ctx,ctx->img2.pixels);\n\tif(ctx->error_msg) iw_free(ctx,ctx->error_msg);\n\tif(ctx->optctx.tmp_pixels) iw_free(ctx,ctx->optctx.tmp_pixels);\n\tif(ctx->optctx.palette) iw_free(ctx,ctx->optctx.palette);\n\tif(ctx->input_color_corr_table) iw_free(ctx,ctx->input_color_corr_table);\n\tif(ctx->output_rev_color_corr_table) iw_free(ctx,ctx->output_rev_color_corr_table);\n\tif(ctx->nearest_color_table) iw_free(ctx,ctx->nearest_color_table);\n\tif(ctx->prng) iwpvt_prng_destroy(ctx,ctx->prng);\n\tiw_free(ctx,ctx);\n}\n\nIW_IMPL(void) iw_get_output_image(struct iw_context *ctx, struct iw_image *img)\n{\n\tint k;\n\n\tiw_zeromem(img,sizeof(struct iw_image));\n\timg->width = ctx->optctx.width;\n\timg->height = ctx->optctx.height;\n\timg->imgtype = ctx->optctx.imgtype;\n\timg->sampletype = ctx->img2.sampletype;\n\timg->bit_depth = ctx->optctx.bit_depth;\n\timg->pixels = (iw_byte*)ctx->optctx.pixelsptr;\n\timg->bpr = ctx->optctx.bpr;\n\timg->density_code = ctx->img2.density_code;\n\timg->density_x = ctx->img2.density_x;\n\timg->density_y = ctx->img2.density_y;\n\timg->rendering_intent = ctx->img2.rendering_intent;\n\n\timg->has_bkgdlabel = ctx->optctx.has_bkgdlabel;\n\tfor(k=0;k<4;k++) {\n\t\tif(ctx->optctx.bit_depth==8) {\n\t\t\timg->bkgdlabel.c[k] = ((double)ctx->optctx.bkgdlabel[k])/255.0;\n\t\t}\n\t\telse {\n\t\t\timg->bkgdlabel.c[k] = ((double)ctx->optctx.bkgdlabel[k])/65535.0;\n\t\t}\n\t}\n\n\timg->has_colorkey_trns = ctx->optctx.has_colorkey_trns;\n\timg->colorkey[0] = ctx->optctx.colorkey[0];\n\timg->colorkey[1] = ctx->optctx.colorkey[1];\n\timg->colorkey[2] = ctx->optctx.colorkey[2];\n\tif(ctx->reduced_output_maxcolor_flag) {\n\t\timg->reduced_maxcolors = 1;\n\t\tif(IW_IMGTYPE_IS_GRAY(img->imgtype)) {\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY] = ctx->img2_ci[0].maxcolorcode_int;\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(img->imgtype)) {\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA] = ctx->img2_ci[1].maxcolorcode_int;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_RED]   = ctx->img2_ci[0].maxcolorcode_int;\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN] = ctx->img2_ci[1].maxcolorcode_int;\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE]  = ctx->img2_ci[2].maxcolorcode_int;\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(img->imgtype)) {\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA] = ctx->img2_ci[3].maxcolorcode_int;\n\t\t\t}\n\t\t}\n\t}\n}\n\nIW_IMPL(void) iw_get_output_colorspace(struct iw_context *ctx, struct iw_csdescr *csdescr)\n{\n\t*csdescr = ctx->img2cs; // struct copy\n}\n\nIW_IMPL(const struct iw_palette*) iw_get_output_palette(struct iw_context *ctx)\n{\n\treturn ctx->optctx.palette;\n}\n\nIW_IMPL(void) iw_set_output_canvas_size(struct iw_context *ctx, int w, int h)\n{\n\tctx->canvas_width = w;\n\tctx->canvas_height = h;\n}\n\nIW_IMPL(void) iw_set_output_image_size(struct iw_context *ctx, double w, double h)\n{\n\tctx->req.out_true_width = w;\n\tif(ctx->req.out_true_width<0.01) ctx->req.out_true_width=0.01;\n\tctx->req.out_true_height = h;\n\tif(ctx->req.out_true_height<0.01) ctx->req.out_true_height=0.01;\n\tctx->req.out_true_valid = 1;\n}\n\nIW_IMPL(void) iw_set_input_crop(struct iw_context *ctx, int x, int y, int w, int h)\n{\n\tctx->input_start_x = x;\n\tctx->input_start_y = y;\n\tctx->input_w = w;\n\tctx->input_h = h;\n}\n\nIW_IMPL(void) iw_set_output_profile(struct iw_context *ctx, unsigned int n)\n{\n\tctx->output_profile = n;\n}\n\nIW_IMPL(void) iw_set_output_depth(struct iw_context *ctx, int bps)\n{\n\tctx->req.output_depth = bps;\n}\n\nIW_IMPL(void) iw_set_output_max_color_code(struct iw_context *ctx, int channeltype, int n)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->req.output_maxcolorcode[channeltype] = n;\n\t}\n}\n\nIW_IMPL(void) iw_set_dither_type(struct iw_context *ctx, int channeltype, int f, int s)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->ditherfamily_by_channeltype[channeltype] = f;\n\t\tctx->dithersubtype_by_channeltype[channeltype] = s;\n\t}\n\n\tswitch(channeltype) {\n\tcase IW_CHANNELTYPE_ALL:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_ALPHA] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_ALPHA] = s;\n\t\t// fall thru\n\tcase IW_CHANNELTYPE_NONALPHA:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_RED] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_RED] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GREEN] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GREEN] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_BLUE] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_BLUE] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GRAY] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GRAY] = s;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(void) iw_set_color_count(struct iw_context *ctx, int channeltype, int c)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->req.color_count[channeltype] = c;\n\t}\n\n\tswitch(channeltype) {\n\tcase IW_CHANNELTYPE_ALL:\n\t\tctx->req.color_count[IW_CHANNELTYPE_ALPHA] = c;\n\t\t// fall thru\n\tcase IW_CHANNELTYPE_NONALPHA:\n\t\tctx->req.color_count[IW_CHANNELTYPE_RED] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_GREEN] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_BLUE] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_GRAY] = c;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(void) iw_set_channel_offset(struct iw_context *ctx, int channeltype, int dimension, double offs)\n{\n\tif(channeltype<0 || channeltype>2) return;\n\tif(dimension<0 || dimension>1) dimension=0;\n\tctx->resize_settings[dimension].channel_offset[channeltype] = offs;\n}\n\nIW_IMPL(void) iw_set_input_max_color_code(struct iw_context *ctx, int input_channel, int c)\n{\n\tif(input_channel>=0 && input_channel<IW_CI_COUNT) {\n\t\tctx->img1_ci[input_channel].maxcolorcode_int = c;\n\t}\n}\n\nIW_IMPL(void) iw_set_input_bkgd_label_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->img1_bkgd_label_set = 1;\n\tctx->img1_bkgd_label_inputcs = *clr;\n}\n\nIW_IMPL(void) iw_set_input_bkgd_label(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[0] = r;\n\tclr.c[1] = g;\n\tclr.c[2] = b;\n\tclr.c[3] = 1.0;\n\tiw_set_input_bkgd_label_2(ctx, &clr);\n}\n\nIW_IMPL(void) iw_set_output_bkgd_label_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->req.output_bkgd_label_valid = 1;\n\tctx->req.output_bkgd_label = *clr;\n}\n\nIW_IMPL(void) iw_set_output_bkgd_label(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[0] = r;\n\tclr.c[1] = g;\n\tclr.c[2] = b;\n\tclr.c[3] = 1.0;\n\tiw_set_output_bkgd_label_2(ctx, &clr);\n}\n\nIW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nIW_IMPL(void) iw_set_output_density(struct iw_context *ctx,\n   double x, double y, int code)\n{\n\tctx->img2.density_code = code;\n\tctx->img2.density_x = x;\n\tctx->img2.density_y = y;\n}\n\n// Detect a \"gamma\" colorspace that is actually linear.\nstatic void optimize_csdescr(struct iw_csdescr *cs)\n{\n\tif(cs->cstype!=IW_CSTYPE_GAMMA) return;\n\tif(cs->gamma>=0.999995 && cs->gamma<=1.000005) {\n\t\tcs->cstype = IW_CSTYPE_LINEAR;\n\t}\n}\n\nIW_IMPL(void) iw_make_linear_csdescr(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_LINEAR;\n\tcs->gamma = 0.0;\n\tcs->srgb_intent = 0;\n}\n\n// This function is deprecated, and should not be used.\nIW_IMPL(void) iw_make_srgb_csdescr(struct iw_csdescr *cs, int srgb_intent)\n{\n\tcs->cstype = IW_CSTYPE_SRGB;\n\tcs->gamma = 0.0;\n\tcs->srgb_intent = srgb_intent;\n}\n\nIW_IMPL(void) iw_make_srgb_csdescr_2(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_SRGB;\n\tcs->gamma = 0.0;\n}\n\nIW_IMPL(void) iw_make_rec709_csdescr(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_REC709;\n\tcs->gamma = 0.0;\n}\n\nIW_IMPL(void) iw_make_gamma_csdescr(struct iw_csdescr *cs, double gamma)\n{\n\tcs->cstype = IW_CSTYPE_GAMMA;\n\tcs->gamma = gamma;\n\tif(cs->gamma<0.1) cs->gamma=0.1;\n\tif(cs->gamma>10.0) cs->gamma=10.0;\n\tcs->srgb_intent = 0;\n\toptimize_csdescr(cs);\n}\n\nIW_IMPL(void) iw_set_output_colorspace(struct iw_context *ctx, const struct iw_csdescr *csdescr)\n{\n\tctx->req.output_cs = *csdescr; // struct copy\n\toptimize_csdescr(&ctx->req.output_cs);\n\tctx->req.output_cs_valid = 1;\n}\n\nIW_IMPL(void) iw_set_input_colorspace(struct iw_context *ctx, const struct iw_csdescr *csdescr)\n{\n\tctx->img1cs = *csdescr; // struct copy\n\toptimize_csdescr(&ctx->img1cs);\n}\n\nIW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->req.bkgd_valid=1;\n\tctx->req.bkgd = *clr;\n}\n\nIW_IMPL(void) iw_set_apply_bkgd(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[IW_CHANNELTYPE_RED]=r;\n\tclr.c[IW_CHANNELTYPE_GREEN]=g;\n\tclr.c[IW_CHANNELTYPE_BLUE]=b;\n\tclr.c[IW_CHANNELTYPE_ALPHA]=1.0;\n\tiw_set_apply_bkgd_2(ctx, &clr);\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard_2(struct iw_context *ctx, int checkersize,\n\tconst struct iw_color *clr)\n{\n\tctx->req.bkgd_checkerboard=1;\n\tctx->bkgd_check_size=checkersize;\n\tctx->req.bkgd2 = *clr;\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard(struct iw_context *ctx, int checkersize,\n    double r2, double g2, double b2)\n{\n\tstruct iw_color clr;\n\tclr.c[IW_CHANNELTYPE_RED]=r2;\n\tclr.c[IW_CHANNELTYPE_GREEN]=g2;\n\tclr.c[IW_CHANNELTYPE_BLUE]=b2;\n\tclr.c[IW_CHANNELTYPE_ALPHA]=1.0;\n\tiw_set_bkgd_checkerboard_2(ctx, checkersize, &clr);\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard_origin(struct iw_context *ctx, int x, int y)\n{\n\tctx->bkgd_check_origin[IW_DIMENSION_H] = x;\n\tctx->bkgd_check_origin[IW_DIMENSION_V] = y;\n}\n\nIW_IMPL(void) iw_set_max_malloc(struct iw_context *ctx, size_t n)\n{\n\tctx->max_malloc = n;\n}\n\nIW_IMPL(void) iw_set_random_seed(struct iw_context *ctx, int randomize, int rand_seed)\n{\n\tctx->randomize = randomize;\n\tctx->random_seed = rand_seed;\n}\n\nIW_IMPL(void) iw_set_userdata(struct iw_context *ctx, void *userdata)\n{\n\tctx->userdata = userdata;\n}\n\nIW_IMPL(void*) iw_get_userdata(struct iw_context *ctx)\n{\n\treturn ctx->userdata;\n}\n\nIW_IMPL(void) iw_set_translate_fn(struct iw_context *ctx, iw_translatefn_type xlatefn)\n{\n\tctx->translate_fn = xlatefn;\n}\n\nIW_IMPL(void) iw_set_warning_fn(struct iw_context *ctx, iw_warningfn_type warnfn)\n{\n\tctx->warning_fn = warnfn;\n}\n\nIW_IMPL(void) iw_set_input_image(struct iw_context *ctx, const struct iw_image *img)\n{\n\tctx->img1 = *img; // struct copy\n}\n\nIW_IMPL(void) iw_set_resize_alg(struct iw_context *ctx, int dimension, int family,\n    double blur, double param1, double param2)\n{\n\tstruct iw_resize_settings *rs;\n\n\tif(dimension<0 || dimension>1) dimension=0;\n\trs=&ctx->resize_settings[dimension];\n\n\trs->family = family;\n\trs->blur_factor = blur;\n\trs->param1 = param1;\n\trs->param2 = param2;\n}\n\nIW_IMPL(void) iw_reorient_image(struct iw_context *ctx, unsigned int x)\n{\n\tstatic const unsigned int transpose_tbl[8] = { 4,6,5,7,0,2,1,3 };\n\tint tmpi;\n\tdouble tmpd;\n\n\tx = x & 0x07;\n\n\t// If needed, perform a 'transpose' of the current transform.\n\tif(x&0x04) {\n\t\tctx->img1.orient_transform = transpose_tbl[ctx->img1.orient_transform];\n\n\t\t// We swapped the width and height, so we need to fix up some things.\n\t\ttmpi = ctx->img1.width;\n\t\tctx->img1.width = ctx->img1.height;\n\t\tctx->img1.height = tmpi;\n\n\t\ttmpd = ctx->img1.density_x;\n\t\tctx->img1.density_x = ctx->img1.density_y;\n\t\tctx->img1.density_y = tmpd;\n\t}\n\n\t// Do horizontal and vertical mirroring.\n\tctx->img1.orient_transform ^= (x&0x03);\n}\n\nIW_IMPL(int) iw_get_sample_size(void)\n{\n\treturn (int)sizeof(iw_float32);\n}\n\nIW_IMPL(int) iw_get_version_int(void)\n{\n\treturn IW_VERSION_INT;\n}\n\nIW_IMPL(char*) iw_get_version_string(struct iw_context *ctx, char *s, int s_len)\n{\n\tint ver;\n\tver = iw_get_version_int();\n\tiw_snprintf(s,s_len,\"%d.%d.%d\",\n\t\t(ver&0xff0000)>>16, (ver&0xff00)>>8, (ver&0xff) );\n\treturn s;\n}\n\nIW_IMPL(char*) iw_get_copyright_string(struct iw_context *ctx, char *dst, int dstlen)\n{\n\tiw_translatef(ctx,0,dst,dstlen,\"Copyright \\xc2\\xa9 %s %s\",IW_COPYRIGHT_YEAR,\"Jason Summers\");\n\treturn dst;\n}\n\nIW_IMPL(void) iw_set_zlib_module(struct iw_context *ctx, struct iw_zlib_module *z)\n{\n\tctx->zlib_module = z;\n}\n\nIW_IMPL(struct iw_zlib_module*) iw_get_zlib_module(struct iw_context *ctx)\n{\n\treturn ctx->zlib_module;\n}\n\nIW_IMPL(void) iw_set_allow_opt(struct iw_context *ctx, int opt, int n)\n{\n\tiw_byte v;\n\tv = n?1:0;\n\n\tswitch(opt) {\n\tcase IW_OPT_GRAYSCALE: ctx->opt_grayscale = v; break;\n\tcase IW_OPT_PALETTE: ctx->opt_palette = v; break;\n\tcase IW_OPT_16_TO_8: ctx->opt_16_to_8 = v; break;\n\tcase IW_OPT_STRIP_ALPHA: ctx->opt_strip_alpha = v; break;\n\tcase IW_OPT_BINARY_TRNS: ctx->opt_binary_trns = v; break;\n\t}\n}\n\nIW_IMPL(void) iw_set_grayscale_weights(struct iw_context *ctx,\n\tdouble r, double g, double b)\n{\n\tdouble tot;\n\n\t//ctx->grayscale_formula = IW_GSF_WEIGHTED;\n\n\t// Normalize, so the weights add up to 1.\n\ttot = r+g+b;\n\tif(tot==0.0) tot=1.0;\n\tctx->grayscale_weight[0] = r/tot;\n\tctx->grayscale_weight[1] = g/tot;\n\tctx->grayscale_weight[2] = b/tot;\n}\n\nIW_IMPL(unsigned int) iw_color_get_int_sample(struct iw_color *clr, int channel,\n\tunsigned int maxcolorcode)\n{\n\tint n;\n\tn = (int)(0.5+(clr->c[channel] * (double)maxcolorcode));\n\tif(n<0) n=0;\n\telse if(n>(int)maxcolorcode) n=(int)maxcolorcode;\n\treturn (unsigned int)n;\n}\n\nIW_IMPL(void) iw_set_value(struct iw_context *ctx, int code, int n)\n{\n\tswitch(code) {\n\tcase IW_VAL_API_VERSION:\n\t\tctx->caller_api_version = n;\n\t\tbreak;\n\tcase IW_VAL_CVT_TO_GRAYSCALE:\n\t\tctx->to_grayscale = n;\n\t\tbreak;\n\tcase IW_VAL_DISABLE_GAMMA:\n\t\tctx->no_gamma = n;\n\t\tbreak;\n\tcase IW_VAL_NO_CSLABEL:\n\t\tctx->req.suppress_output_cslabel = n;\n\t\tbreak;\n\tcase IW_VAL_INT_CLAMP:\n\t\tctx->intclamp = n;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_X:\n\t\tctx->resize_settings[IW_DIMENSION_H].edge_policy = n;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_Y:\n\t\tctx->resize_settings[IW_DIMENSION_V].edge_policy = n;\n\t\tbreak;\n\tcase IW_VAL_PREF_UNITS:\n\t\tctx->pref_units = n;\n\t\tbreak;\n\tcase IW_VAL_GRAYSCALE_FORMULA:\n\t\tctx->grayscale_formula = n;\n\t\tbreak;\n\tcase IW_VAL_INPUT_NATIVE_GRAYSCALE:\n\t\tctx->img1.native_grayscale = n;\n\t\tbreak;\n\tcase IW_VAL_COMPRESSION:\n\t\tctx->req.compression = n;\n\t\tbreak;\n\tcase IW_VAL_PAGE_TO_READ:\n\t\tctx->req.page_to_read = n;\n\t\tbreak;\n\tcase IW_VAL_INCLUDE_SCREEN:\n\t\tctx->req.include_screen = n;\n\t\tbreak;\n\tcase IW_VAL_JPEG_QUALITY:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:quality\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_SAMP_FACTOR_H:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:sampling-x\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_SAMP_FACTOR_V:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:sampling-y\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_ARITH_CODING:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:arith\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_DEFLATE_CMPR_LEVEL:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"deflate:cmprlevel\", iwpvt_strdup_dbl(ctx, (double)n)); \n\t\tbreak;\n\tcase IW_VAL_OUTPUT_INTERLACED:\n\t\tctx->req.interlaced = n;\n\t\tbreak;\n\tcase IW_VAL_USE_BKGD_LABEL:\n\t\tctx->req.use_bkgd_label_from_file = n;\n\t\tbreak;\n\tcase IW_VAL_BMP_NO_FILEHEADER:\n\t\tctx->req.bmp_no_fileheader = n;\n\t\tbreak;\n\tcase IW_VAL_BMP_VERSION:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"bmp:version\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_MAX_WIDTH:\n\t\tctx->max_width = n;\n\t\tbreak;\n\tcase IW_VAL_MAX_HEIGHT:\n\t\tctx->max_height = n;\n\t\tbreak;\n\tcase IW_VAL_NO_BKGD_LABEL:\n\t\tctx->req.suppress_output_bkgd_label = n;\n\t\tbreak;\n\tcase IW_VAL_INTENT:\n\t\tctx->req.output_rendering_intent = n;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_SAMPLE_TYPE:\n\t\tctx->req.output_sample_type = n;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_COLOR_TYPE:\n\t\t// For backward compatibility only.\n\t\tif(n==IW_COLORTYPE_RGB) {\n\t\t\tiw_set_option(ctx, \"deflate:colortype\", \"rgb\"); \n\t\t}\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_FORMAT:\n\t\tctx->req.output_format = n;\n\t\tbreak;\n\tcase IW_VAL_NEGATE_TARGET:\n\t\tctx->req.negate_target = n;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(int) iw_get_value(struct iw_context *ctx, int code)\n{\n\tint ret=0;\n\n\tswitch(code) {\n\tcase IW_VAL_API_VERSION:\n\t\tret = ctx->caller_api_version;\n\t\tbreak;\n\tcase IW_VAL_CVT_TO_GRAYSCALE:\n\t\tret = ctx->to_grayscale;\n\t\tbreak;\n\tcase IW_VAL_DISABLE_GAMMA:\n\t\tret = ctx->no_gamma;\n\t\tbreak;\n\tcase IW_VAL_NO_CSLABEL:\n\t\tret = ctx->req.suppress_output_cslabel;\n\t\tbreak;\n\tcase IW_VAL_INT_CLAMP:\n\t\tret = ctx->intclamp;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_X:\n\t\tret = ctx->resize_settings[IW_DIMENSION_H].edge_policy;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_Y:\n\t\tret = ctx->resize_settings[IW_DIMENSION_V].edge_policy;\n\t\tbreak;\n\tcase IW_VAL_PREF_UNITS:\n\t\tret = ctx->pref_units;\n\t\tbreak;\n\tcase IW_VAL_GRAYSCALE_FORMULA:\n\t\tret = ctx->grayscale_formula;\n\t\tbreak;\n\tcase IW_VAL_INPUT_NATIVE_GRAYSCALE:\n\t\tret = ctx->img1.native_grayscale;\n\t\tbreak;\n\tcase IW_VAL_INPUT_WIDTH:\n\t\tif(ctx->img1.width<1) ret=1;\n\t\telse ret = ctx->img1.width;\n\t\tbreak;\n\tcase IW_VAL_INPUT_HEIGHT:\n\t\tif(ctx->img1.height<1) ret=1;\n\t\telse ret = ctx->img1.height;\n\t\tbreak;\n\tcase IW_VAL_INPUT_IMAGE_TYPE:\n\t\tret = ctx->img1.imgtype;\n\t\tbreak;\n\tcase IW_VAL_INPUT_DEPTH:\n\t\tret = ctx->img1.bit_depth;\n\t\tbreak;\n\tcase IW_VAL_COMPRESSION:\n\t\tret = ctx->req.compression;\n\t\tbreak;\n\tcase IW_VAL_PAGE_TO_READ:\n\t\tret = ctx->req.page_to_read;\n\t\tbreak;\n\tcase IW_VAL_INCLUDE_SCREEN:\n\t\tret = ctx->req.include_screen;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_PALETTE_GRAYSCALE:\n\t\tret = ctx->optctx.palette_is_grayscale;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_INTERLACED:\n\t\tret = ctx->req.interlaced;\n\t\tbreak;\n\tcase IW_VAL_USE_BKGD_LABEL:\n\t\tret = ctx->req.use_bkgd_label_from_file;\n\t\tbreak;\n\tcase IW_VAL_BMP_NO_FILEHEADER:\n\t\tret = ctx->req.bmp_no_fileheader;\n\t\tbreak;\n\tcase IW_VAL_MAX_WIDTH:\n\t\tret = ctx->max_width;\n\t\tbreak;\n\tcase IW_VAL_MAX_HEIGHT:\n\t\tret = ctx->max_height;\n\t\tbreak;\n\tcase IW_VAL_PRECISION:\n\t\tret = 32;\n\t\tbreak;\n\tcase IW_VAL_NO_BKGD_LABEL:\n\t\tret = ctx->req.suppress_output_bkgd_label;\n\t\tbreak;\n\tcase IW_VAL_INTENT:\n\t\tret = ctx->req.output_rendering_intent;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_SAMPLE_TYPE:\n\t\tret = ctx->req.output_sample_type;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_FORMAT:\n\t\tret = ctx->req.output_format;\n\t\tbreak;\n\tcase IW_VAL_NEGATE_TARGET:\n\t\tret = ctx->req.negate_target;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nIW_IMPL(void) iw_set_value_dbl(struct iw_context *ctx, int code, double n)\n{\n\tswitch(code) {\n\tcase IW_VAL_WEBP_QUALITY:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"webp:quality\", iwpvt_strdup_dbl(ctx, n)); \n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_X:\n\t\tctx->resize_settings[IW_DIMENSION_H].translate = n;\n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_Y:\n\t\tctx->resize_settings[IW_DIMENSION_V].translate = n;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(double) iw_get_value_dbl(struct iw_context *ctx, int code)\n{\n\tdouble ret = 0.0;\n\n\tswitch(code) {\n\tcase IW_VAL_TRANSLATE_X:\n\t\tret = ctx->resize_settings[IW_DIMENSION_H].translate;\n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_Y:\n\t\tret = ctx->resize_settings[IW_DIMENSION_V].translate;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nIW_IMPL(void) iw_set_option(struct iw_context *ctx, const char *name, const char *val)\n{\n#define IW_MAX_OPTIONS 32\n\tint i;\n\n\tif(val==NULL || val[0]=='\\0') {\n\t\t// An empty value can be used to mean \"turn on this option\".\n\t\t// To make that easier, set such values to \"1\".\n\t\tval = \"1\";\n\t}\n\n\t// Allocate req.options if that hasn't been done yet.\n\tif(!ctx->req.options) {\n\t\tctx->req.options = iw_mallocz(ctx, IW_MAX_OPTIONS*sizeof(struct iw_option_struct));\n\t\tif(!ctx->req.options) return;\n\t\tctx->req.options_numalloc = IW_MAX_OPTIONS;\n\t\tctx->req.options_count = 0;\n\t}\n\n\t// If option already exists, replace it.\n\tfor(i=0; i<ctx->req.options_count; i++) {\n\t\tif(ctx->req.options[i].name && !strcmp(ctx->req.options[i].name, name)) {\n\t\t\tiw_free(ctx, ctx->req.options[i].val);\n\t\t\tctx->req.options[i].val = iw_strdup(ctx, val);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Add the new option.\n\tif(ctx->req.options_count>=IW_MAX_OPTIONS) return;\n\tctx->req.options[ctx->req.options_count].name = iw_strdup(ctx, name);\n\tctx->req.options[ctx->req.options_count].val = iw_strdup(ctx, val);\n\tctx->req.options_count++;\n}\n\n// Return the value of the first option with the given name.\n// Return NULL if not found.\nIW_IMPL(const char*) iw_get_option(struct iw_context *ctx, const char *name)\n{\n\tint i;\n\tfor(i=0; i<ctx->req.options_count; i++) {\n\t\tif(ctx->req.options[i].name && !strcmp(ctx->req.options[i].name, name)) {\n\t\t\treturn ctx->req.options[i].val;\n\t\t}\n\t}\n\treturn NULL;\n}\n"], "fixing_code": ["// imagew-api.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// Most of the functions declared in imagew.h are defined here.\n\n#include \"imagew-config.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"imagew-internals.h\"\n\n// Translate a string, using the given flags.\nIW_IMPL(void) iw_translate(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *src)\n{\n\tint ret;\n\n\tdst[0]='\\0';\n\n\tif(ctx && ctx->translate_fn) {\n\t\tret = (*ctx->translate_fn)(ctx,flags,dst,dstlen,src);\n\t}\n\telse {\n\t\tret = 0;\n\t}\n\n\tif(!ret) {\n\t\t// Not translated. Just copy the string.\n\t\tiw_strlcpy(dst,src,dstlen);\n\t}\n}\n\n// Formats and translates, and returns the resulting string in buf.\n// 'ctx' can be NULL, in which case no tranlation will happen.\nIW_IMPL(void) iw_translatev(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *fmt, va_list ap)\n{\n\tchar buf1[IW_MSG_MAX];\n\tchar buf2[IW_MSG_MAX];\n\n\t// If not translating, just format the string directly.\n\tif(!ctx || !ctx->translate_fn) {\n\t\tiw_vsnprintf(dst,dstlen,fmt,ap);\n\t\treturn;\n\t}\n\n\t// String is now in fmt.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_FORMAT|flags,buf1,sizeof(buf1),fmt);\n\t// String is now in buf1.\n\tiw_vsnprintf(buf2,sizeof(buf2),buf1,ap);\n\t// String is now in buf2.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_POSTFORMAT|flags,dst,dstlen,buf2);\n\t// String is now in dst.\n}\n\n// Formats and translates, and returns the resulting string in buf\nIW_IMPL(void) iw_translatef(struct iw_context *ctx, unsigned int flags,\n\tchar *dst, size_t dstlen, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tiw_translatev(ctx,flags,dst,dstlen,fmt,ap);\n\tva_end(ap);\n}\n\nstatic void iw_warning_internal(struct iw_context *ctx, const char *s)\n{\n\tif(!ctx->warning_fn) return;\n\n\t(*ctx->warning_fn)(ctx,s);\n}\n\nIW_IMPL(void) iw_warning(struct iw_context *ctx, const char *s)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(!ctx->warning_fn) return;\n\tiw_translate(ctx,IW_TRANSLATEFLAG_WARNINGMSG,buf,sizeof(buf),s);\n\tiw_warning_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_warningv(struct iw_context *ctx, const char *fmt, va_list ap)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(!ctx->warning_fn) return;\n\tiw_translatev(ctx,IW_TRANSLATEFLAG_WARNINGMSG,buf,sizeof(buf),fmt,ap);\n\tiw_warning_internal(ctx,buf);\n}\n\n// Call the caller's warning function, if defined.\nIW_IMPL(void) iw_warningf(struct iw_context *ctx, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tif(!ctx->warning_fn) return;\n\tva_start(ap, fmt);\n\tiw_warningv(ctx,fmt,ap);\n\tva_end(ap);\n}\n\nstatic void iw_set_error_internal(struct iw_context *ctx, const char *s)\n{\n\tif(ctx->error_flag) return; // Only record the first error.\n\tctx->error_flag = 1;\n\n\tif(!ctx->error_msg) {\n\t\tctx->error_msg=iw_malloc_ex(ctx,IW_MALLOCFLAG_NOERRORS,IW_MSG_MAX*sizeof(char));\n\t\tif(!ctx->error_msg) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tiw_strlcpy(ctx->error_msg,s,IW_MSG_MAX);\n}\n\nIW_IMPL(void) iw_set_error(struct iw_context *ctx, const char *s)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(ctx->error_flag) return; // Only record the first error.\n\tiw_translate(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,sizeof(buf),s);\n\tiw_set_error_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_set_errorv(struct iw_context *ctx, const char *fmt, va_list ap)\n{\n\tchar buf[IW_MSG_MAX];\n\n\tif(ctx->error_flag) return; // Only record the first error.\n\tiw_translatev(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,sizeof(buf),fmt,ap);\n\tiw_set_error_internal(ctx,buf);\n}\n\nIW_IMPL(void) iw_set_errorf(struct iw_context *ctx, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tiw_set_errorv(ctx,fmt,ap);\n\tva_end(ap);\n}\n\nIW_IMPL(const char*) iw_get_errormsg(struct iw_context *ctx, char *buf, int buflen)\n{\n\tif(ctx->error_msg) {\n\t\tiw_strlcpy(buf,ctx->error_msg,buflen);\n\t}\n\telse {\n\t\tiw_translate(ctx,IW_TRANSLATEFLAG_ERRORMSG,buf,buflen,\"Error message not available\");\n\t}\n\n\treturn buf;\n}\n\nIW_IMPL(int) iw_get_errorflag(struct iw_context *ctx)\n{\n\treturn ctx->error_flag;\n}\n\n// Given a color type, returns the number of channels.\nIW_IMPL(int) iw_imgtype_num_channels(int t)\n{\n\tswitch(t) {\n\tcase IW_IMGTYPE_RGBA:\n\t\treturn 4;\n\tcase IW_IMGTYPE_RGB:\n\t\treturn 3;\n\tcase IW_IMGTYPE_GRAYA:\n\t\treturn 2;\n\t}\n\treturn 1;\n}\n\nIW_IMPL(size_t) iw_calc_bytesperrow(int num_pixels, int bits_per_pixel)\n{\n\treturn (size_t)(((num_pixels*bits_per_pixel)+7)/8);\n}\n\nIW_IMPL(int) iw_check_image_dimensions(struct iw_context *ctx, int w, int h)\n{\n\tif(w>ctx->max_width || h>ctx->max_height) {\n\t\tiw_set_errorf(ctx,\"Image dimensions too large (%d\\xc3\\x97%d)\",w,h);\n\t\treturn 0;\n\t}\n\n\tif(w<1 || h<1) {\n\t\tiw_set_errorf(ctx,\"Invalid image dimensions (%d\\xc3\\x97%d)\",w,h);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nIW_IMPL(int) iw_is_valid_density(double density_x, double density_y, int density_code)\n{\n\tif(density_x<0.0001 || density_y<0.0001) return 0;\n\tif(density_x>10000000.0 || density_y>10000000.0) return 0;\n\tif(density_x/10.0>density_y) return 0;\n\tif(density_y/10.0>density_x) return 0;\n\tif(density_code!=IW_DENSITY_UNITS_UNKNOWN && density_code!=IW_DENSITY_UNITS_PER_METER)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic void default_resize_settings(struct iw_resize_settings *rs)\n{\n\tint i;\n\trs->family = IW_RESIZETYPE_AUTO;\n\trs->edge_policy = IW_EDGE_POLICY_STANDARD;\n\trs->blur_factor = 1.0;\n\trs->translate = 0.0;\n\tfor(i=0;i<3;i++) {\n\t\trs->channel_offset[i] = 0.0;\n\t}\n}\n\nIW_IMPL(struct iw_context*) iw_create_context(struct iw_init_params *params)\n{\n\tstruct iw_context *ctx;\n\n\tif(params && params->mallocfn) {\n\t\tctx = (*params->mallocfn)(params->userdata,IW_MALLOCFLAG_ZEROMEM,sizeof(struct iw_context));\n\t}\n\telse {\n\t\tctx = iwpvt_default_malloc(NULL,IW_MALLOCFLAG_ZEROMEM,sizeof(struct iw_context));\n\t}\n\n\tif(!ctx) return NULL;\n\n\tif(params) {\n\t\tctx->userdata = params->userdata;\n\t\tctx->caller_api_version = params->api_version;\n\t}\n\n\tif(params && params->mallocfn) {\n\t\tctx->mallocfn = params->mallocfn;\n\t\tctx->freefn = params->freefn;\n\t}\n\telse {\n\t\tctx->mallocfn = iwpvt_default_malloc;\n\t\tctx->freefn = iwpvt_default_free;\n\t}\n\n\tctx->max_malloc = IW_DEFAULT_MAX_MALLOC;\n\tctx->max_width = ctx->max_height = IW_DEFAULT_MAX_DIMENSION;\n\tdefault_resize_settings(&ctx->resize_settings[IW_DIMENSION_H]);\n\tdefault_resize_settings(&ctx->resize_settings[IW_DIMENSION_V]);\n\tctx->input_w = -1;\n\tctx->input_h = -1;\n\tiw_make_srgb_csdescr_2(&ctx->img1cs);\n\tiw_make_srgb_csdescr_2(&ctx->img2cs);\n\tctx->to_grayscale=0;\n\tctx->grayscale_formula = IW_GSF_STANDARD;\n\tctx->req.include_screen = 1;\n\tctx->opt_grayscale = 1;\n\tctx->opt_palette = 1;\n\tctx->opt_16_to_8 = 1;\n\tctx->opt_strip_alpha = 1;\n\tctx->opt_binary_trns = 1;\n\n\treturn ctx;\n}\n\nIW_IMPL(void) iw_destroy_context(struct iw_context *ctx)\n{\n\tint i;\n\tif(!ctx) return;\n\tif(ctx->req.options) {\n\t\tfor(i=0; i<=ctx->req.options_count; i++) {\n\t\t\tiw_free(ctx, ctx->req.options[i].name);\n\t\t\tiw_free(ctx, ctx->req.options[i].val);\n\t\t}\n\t\tiw_free(ctx, ctx->req.options);\n\t}\n\tif(ctx->img1.pixels) iw_free(ctx,ctx->img1.pixels);\n\tif(ctx->img2.pixels) iw_free(ctx,ctx->img2.pixels);\n\tif(ctx->error_msg) iw_free(ctx,ctx->error_msg);\n\tif(ctx->optctx.tmp_pixels) iw_free(ctx,ctx->optctx.tmp_pixels);\n\tif(ctx->optctx.palette) iw_free(ctx,ctx->optctx.palette);\n\tif(ctx->input_color_corr_table) iw_free(ctx,ctx->input_color_corr_table);\n\tif(ctx->output_rev_color_corr_table) iw_free(ctx,ctx->output_rev_color_corr_table);\n\tif(ctx->nearest_color_table) iw_free(ctx,ctx->nearest_color_table);\n\tif(ctx->prng) iwpvt_prng_destroy(ctx,ctx->prng);\n\tiw_free(ctx,ctx);\n}\n\nIW_IMPL(void) iw_get_output_image(struct iw_context *ctx, struct iw_image *img)\n{\n\tint k;\n\n\tiw_zeromem(img,sizeof(struct iw_image));\n\timg->width = ctx->optctx.width;\n\timg->height = ctx->optctx.height;\n\timg->imgtype = ctx->optctx.imgtype;\n\timg->sampletype = ctx->img2.sampletype;\n\timg->bit_depth = ctx->optctx.bit_depth;\n\timg->pixels = (iw_byte*)ctx->optctx.pixelsptr;\n\timg->bpr = ctx->optctx.bpr;\n\timg->density_code = ctx->img2.density_code;\n\timg->density_x = ctx->img2.density_x;\n\timg->density_y = ctx->img2.density_y;\n\timg->rendering_intent = ctx->img2.rendering_intent;\n\n\timg->has_bkgdlabel = ctx->optctx.has_bkgdlabel;\n\tfor(k=0;k<4;k++) {\n\t\tif(ctx->optctx.bit_depth==8) {\n\t\t\timg->bkgdlabel.c[k] = ((double)ctx->optctx.bkgdlabel[k])/255.0;\n\t\t}\n\t\telse {\n\t\t\timg->bkgdlabel.c[k] = ((double)ctx->optctx.bkgdlabel[k])/65535.0;\n\t\t}\n\t}\n\n\timg->has_colorkey_trns = ctx->optctx.has_colorkey_trns;\n\timg->colorkey[0] = ctx->optctx.colorkey[0];\n\timg->colorkey[1] = ctx->optctx.colorkey[1];\n\timg->colorkey[2] = ctx->optctx.colorkey[2];\n\tif(ctx->reduced_output_maxcolor_flag) {\n\t\timg->reduced_maxcolors = 1;\n\t\tif(IW_IMGTYPE_IS_GRAY(img->imgtype)) {\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY] = ctx->img2_ci[0].maxcolorcode_int;\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(img->imgtype)) {\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA] = ctx->img2_ci[1].maxcolorcode_int;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_RED]   = ctx->img2_ci[0].maxcolorcode_int;\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN] = ctx->img2_ci[1].maxcolorcode_int;\n\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE]  = ctx->img2_ci[2].maxcolorcode_int;\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(img->imgtype)) {\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA] = ctx->img2_ci[3].maxcolorcode_int;\n\t\t\t}\n\t\t}\n\t}\n}\n\nIW_IMPL(void) iw_get_output_colorspace(struct iw_context *ctx, struct iw_csdescr *csdescr)\n{\n\t*csdescr = ctx->img2cs; // struct copy\n}\n\nIW_IMPL(const struct iw_palette*) iw_get_output_palette(struct iw_context *ctx)\n{\n\treturn ctx->optctx.palette;\n}\n\nIW_IMPL(void) iw_set_output_canvas_size(struct iw_context *ctx, int w, int h)\n{\n\tctx->canvas_width = w;\n\tctx->canvas_height = h;\n}\n\nIW_IMPL(void) iw_set_output_image_size(struct iw_context *ctx, double w, double h)\n{\n\tctx->req.out_true_width = w;\n\tif(ctx->req.out_true_width<0.01) ctx->req.out_true_width=0.01;\n\tctx->req.out_true_height = h;\n\tif(ctx->req.out_true_height<0.01) ctx->req.out_true_height=0.01;\n\tctx->req.out_true_valid = 1;\n}\n\nIW_IMPL(void) iw_set_input_crop(struct iw_context *ctx, int x, int y, int w, int h)\n{\n\tctx->input_start_x = x;\n\tctx->input_start_y = y;\n\tctx->input_w = w;\n\tctx->input_h = h;\n}\n\nIW_IMPL(void) iw_set_output_profile(struct iw_context *ctx, unsigned int n)\n{\n\tctx->output_profile = n;\n}\n\nIW_IMPL(void) iw_set_output_depth(struct iw_context *ctx, int bps)\n{\n\tctx->req.output_depth = bps;\n}\n\nIW_IMPL(void) iw_set_output_max_color_code(struct iw_context *ctx, int channeltype, int n)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->req.output_maxcolorcode[channeltype] = n;\n\t}\n}\n\nIW_IMPL(void) iw_set_dither_type(struct iw_context *ctx, int channeltype, int f, int s)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->ditherfamily_by_channeltype[channeltype] = f;\n\t\tctx->dithersubtype_by_channeltype[channeltype] = s;\n\t}\n\n\tswitch(channeltype) {\n\tcase IW_CHANNELTYPE_ALL:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_ALPHA] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_ALPHA] = s;\n\t\t// fall thru\n\tcase IW_CHANNELTYPE_NONALPHA:\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_RED] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_RED] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GREEN] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GREEN] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_BLUE] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_BLUE] = s;\n\t\tctx->ditherfamily_by_channeltype[IW_CHANNELTYPE_GRAY] = f;\n\t\tctx->dithersubtype_by_channeltype[IW_CHANNELTYPE_GRAY] = s;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(void) iw_set_color_count(struct iw_context *ctx, int channeltype, int c)\n{\n\tif(channeltype>=0 && channeltype<IW_NUM_CHANNELTYPES) {\n\t\tctx->req.color_count[channeltype] = c;\n\t}\n\n\tswitch(channeltype) {\n\tcase IW_CHANNELTYPE_ALL:\n\t\tctx->req.color_count[IW_CHANNELTYPE_ALPHA] = c;\n\t\t// fall thru\n\tcase IW_CHANNELTYPE_NONALPHA:\n\t\tctx->req.color_count[IW_CHANNELTYPE_RED] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_GREEN] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_BLUE] = c;\n\t\tctx->req.color_count[IW_CHANNELTYPE_GRAY] = c;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(void) iw_set_channel_offset(struct iw_context *ctx, int channeltype, int dimension, double offs)\n{\n\tif(channeltype<0 || channeltype>2) return;\n\tif(dimension<0 || dimension>1) dimension=0;\n\tctx->resize_settings[dimension].channel_offset[channeltype] = offs;\n}\n\nIW_IMPL(void) iw_set_input_max_color_code(struct iw_context *ctx, int input_channel, int c)\n{\n\tif(input_channel>=0 && input_channel<IW_CI_COUNT) {\n\t\tctx->img1_ci[input_channel].maxcolorcode_int = c;\n\t}\n}\n\nIW_IMPL(void) iw_set_input_bkgd_label_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->img1_bkgd_label_set = 1;\n\tctx->img1_bkgd_label_inputcs = *clr;\n}\n\nIW_IMPL(void) iw_set_input_bkgd_label(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[0] = r;\n\tclr.c[1] = g;\n\tclr.c[2] = b;\n\tclr.c[3] = 1.0;\n\tiw_set_input_bkgd_label_2(ctx, &clr);\n}\n\nIW_IMPL(void) iw_set_output_bkgd_label_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->req.output_bkgd_label_valid = 1;\n\tctx->req.output_bkgd_label = *clr;\n}\n\nIW_IMPL(void) iw_set_output_bkgd_label(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[0] = r;\n\tclr.c[1] = g;\n\tclr.c[2] = b;\n\tclr.c[3] = 1.0;\n\tiw_set_output_bkgd_label_2(ctx, &clr);\n}\n\nIW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = IW_DENSITY_UNKNOWN;\n\n\tif(ctx->img1.density_code==IW_DENSITY_UNKNOWN) {\n\t\treturn 0;\n\t}\n\tif(!iw_is_valid_density(ctx->img1.density_x, ctx->img1.density_y,\n\t\tctx->img1.density_code))\n\t{\n\t\treturn 0;\n\t}\n\t*px = ctx->img1.density_x;\n\t*py = ctx->img1.density_y;\n\t*pcode = ctx->img1.density_code;\n\treturn 1;\n}\n\nIW_IMPL(void) iw_set_output_density(struct iw_context *ctx,\n   double x, double y, int code)\n{\n\tctx->img2.density_code = code;\n\tctx->img2.density_x = x;\n\tctx->img2.density_y = y;\n}\n\n// Detect a \"gamma\" colorspace that is actually linear.\nstatic void optimize_csdescr(struct iw_csdescr *cs)\n{\n\tif(cs->cstype!=IW_CSTYPE_GAMMA) return;\n\tif(cs->gamma>=0.999995 && cs->gamma<=1.000005) {\n\t\tcs->cstype = IW_CSTYPE_LINEAR;\n\t}\n}\n\nIW_IMPL(void) iw_make_linear_csdescr(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_LINEAR;\n\tcs->gamma = 0.0;\n\tcs->srgb_intent = 0;\n}\n\n// This function is deprecated, and should not be used.\nIW_IMPL(void) iw_make_srgb_csdescr(struct iw_csdescr *cs, int srgb_intent)\n{\n\tcs->cstype = IW_CSTYPE_SRGB;\n\tcs->gamma = 0.0;\n\tcs->srgb_intent = srgb_intent;\n}\n\nIW_IMPL(void) iw_make_srgb_csdescr_2(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_SRGB;\n\tcs->gamma = 0.0;\n}\n\nIW_IMPL(void) iw_make_rec709_csdescr(struct iw_csdescr *cs)\n{\n\tcs->cstype = IW_CSTYPE_REC709;\n\tcs->gamma = 0.0;\n}\n\nIW_IMPL(void) iw_make_gamma_csdescr(struct iw_csdescr *cs, double gamma)\n{\n\tcs->cstype = IW_CSTYPE_GAMMA;\n\tcs->gamma = gamma;\n\tif(cs->gamma<0.1) cs->gamma=0.1;\n\tif(cs->gamma>10.0) cs->gamma=10.0;\n\tcs->srgb_intent = 0;\n\toptimize_csdescr(cs);\n}\n\nIW_IMPL(void) iw_set_output_colorspace(struct iw_context *ctx, const struct iw_csdescr *csdescr)\n{\n\tctx->req.output_cs = *csdescr; // struct copy\n\toptimize_csdescr(&ctx->req.output_cs);\n\tctx->req.output_cs_valid = 1;\n}\n\nIW_IMPL(void) iw_set_input_colorspace(struct iw_context *ctx, const struct iw_csdescr *csdescr)\n{\n\tctx->img1cs = *csdescr; // struct copy\n\toptimize_csdescr(&ctx->img1cs);\n}\n\nIW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)\n{\n\tctx->req.bkgd_valid=1;\n\tctx->req.bkgd = *clr;\n}\n\nIW_IMPL(void) iw_set_apply_bkgd(struct iw_context *ctx, double r, double g, double b)\n{\n\tstruct iw_color clr;\n\tclr.c[IW_CHANNELTYPE_RED]=r;\n\tclr.c[IW_CHANNELTYPE_GREEN]=g;\n\tclr.c[IW_CHANNELTYPE_BLUE]=b;\n\tclr.c[IW_CHANNELTYPE_ALPHA]=1.0;\n\tiw_set_apply_bkgd_2(ctx, &clr);\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard_2(struct iw_context *ctx, int checkersize,\n\tconst struct iw_color *clr)\n{\n\tctx->req.bkgd_checkerboard=1;\n\tctx->bkgd_check_size=checkersize;\n\tctx->req.bkgd2 = *clr;\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard(struct iw_context *ctx, int checkersize,\n    double r2, double g2, double b2)\n{\n\tstruct iw_color clr;\n\tclr.c[IW_CHANNELTYPE_RED]=r2;\n\tclr.c[IW_CHANNELTYPE_GREEN]=g2;\n\tclr.c[IW_CHANNELTYPE_BLUE]=b2;\n\tclr.c[IW_CHANNELTYPE_ALPHA]=1.0;\n\tiw_set_bkgd_checkerboard_2(ctx, checkersize, &clr);\n}\n\nIW_IMPL(void) iw_set_bkgd_checkerboard_origin(struct iw_context *ctx, int x, int y)\n{\n\tctx->bkgd_check_origin[IW_DIMENSION_H] = x;\n\tctx->bkgd_check_origin[IW_DIMENSION_V] = y;\n}\n\nIW_IMPL(void) iw_set_max_malloc(struct iw_context *ctx, size_t n)\n{\n\tctx->max_malloc = n;\n}\n\nIW_IMPL(void) iw_set_random_seed(struct iw_context *ctx, int randomize, int rand_seed)\n{\n\tctx->randomize = randomize;\n\tctx->random_seed = rand_seed;\n}\n\nIW_IMPL(void) iw_set_userdata(struct iw_context *ctx, void *userdata)\n{\n\tctx->userdata = userdata;\n}\n\nIW_IMPL(void*) iw_get_userdata(struct iw_context *ctx)\n{\n\treturn ctx->userdata;\n}\n\nIW_IMPL(void) iw_set_translate_fn(struct iw_context *ctx, iw_translatefn_type xlatefn)\n{\n\tctx->translate_fn = xlatefn;\n}\n\nIW_IMPL(void) iw_set_warning_fn(struct iw_context *ctx, iw_warningfn_type warnfn)\n{\n\tctx->warning_fn = warnfn;\n}\n\nIW_IMPL(void) iw_set_input_image(struct iw_context *ctx, const struct iw_image *img)\n{\n\tctx->img1 = *img; // struct copy\n}\n\nIW_IMPL(void) iw_set_resize_alg(struct iw_context *ctx, int dimension, int family,\n    double blur, double param1, double param2)\n{\n\tstruct iw_resize_settings *rs;\n\n\tif(dimension<0 || dimension>1) dimension=0;\n\trs=&ctx->resize_settings[dimension];\n\n\trs->family = family;\n\trs->blur_factor = blur;\n\trs->param1 = param1;\n\trs->param2 = param2;\n}\n\nIW_IMPL(void) iw_reorient_image(struct iw_context *ctx, unsigned int x)\n{\n\tstatic const unsigned int transpose_tbl[8] = { 4,6,5,7,0,2,1,3 };\n\tint tmpi;\n\tdouble tmpd;\n\n\tx = x & 0x07;\n\n\t// If needed, perform a 'transpose' of the current transform.\n\tif(x&0x04) {\n\t\tctx->img1.orient_transform = transpose_tbl[ctx->img1.orient_transform];\n\n\t\t// We swapped the width and height, so we need to fix up some things.\n\t\ttmpi = ctx->img1.width;\n\t\tctx->img1.width = ctx->img1.height;\n\t\tctx->img1.height = tmpi;\n\n\t\ttmpd = ctx->img1.density_x;\n\t\tctx->img1.density_x = ctx->img1.density_y;\n\t\tctx->img1.density_y = tmpd;\n\t}\n\n\t// Do horizontal and vertical mirroring.\n\tctx->img1.orient_transform ^= (x&0x03);\n}\n\nIW_IMPL(int) iw_get_sample_size(void)\n{\n\treturn (int)sizeof(iw_float32);\n}\n\nIW_IMPL(int) iw_get_version_int(void)\n{\n\treturn IW_VERSION_INT;\n}\n\nIW_IMPL(char*) iw_get_version_string(struct iw_context *ctx, char *s, int s_len)\n{\n\tint ver;\n\tver = iw_get_version_int();\n\tiw_snprintf(s,s_len,\"%d.%d.%d\",\n\t\t(ver&0xff0000)>>16, (ver&0xff00)>>8, (ver&0xff) );\n\treturn s;\n}\n\nIW_IMPL(char*) iw_get_copyright_string(struct iw_context *ctx, char *dst, int dstlen)\n{\n\tiw_translatef(ctx,0,dst,dstlen,\"Copyright \\xc2\\xa9 %s %s\",IW_COPYRIGHT_YEAR,\"Jason Summers\");\n\treturn dst;\n}\n\nIW_IMPL(void) iw_set_zlib_module(struct iw_context *ctx, struct iw_zlib_module *z)\n{\n\tctx->zlib_module = z;\n}\n\nIW_IMPL(struct iw_zlib_module*) iw_get_zlib_module(struct iw_context *ctx)\n{\n\treturn ctx->zlib_module;\n}\n\nIW_IMPL(void) iw_set_allow_opt(struct iw_context *ctx, int opt, int n)\n{\n\tiw_byte v;\n\tv = n?1:0;\n\n\tswitch(opt) {\n\tcase IW_OPT_GRAYSCALE: ctx->opt_grayscale = v; break;\n\tcase IW_OPT_PALETTE: ctx->opt_palette = v; break;\n\tcase IW_OPT_16_TO_8: ctx->opt_16_to_8 = v; break;\n\tcase IW_OPT_STRIP_ALPHA: ctx->opt_strip_alpha = v; break;\n\tcase IW_OPT_BINARY_TRNS: ctx->opt_binary_trns = v; break;\n\t}\n}\n\nIW_IMPL(void) iw_set_grayscale_weights(struct iw_context *ctx,\n\tdouble r, double g, double b)\n{\n\tdouble tot;\n\n\t//ctx->grayscale_formula = IW_GSF_WEIGHTED;\n\n\t// Normalize, so the weights add up to 1.\n\ttot = r+g+b;\n\tif(tot==0.0) tot=1.0;\n\tctx->grayscale_weight[0] = r/tot;\n\tctx->grayscale_weight[1] = g/tot;\n\tctx->grayscale_weight[2] = b/tot;\n}\n\nIW_IMPL(unsigned int) iw_color_get_int_sample(struct iw_color *clr, int channel,\n\tunsigned int maxcolorcode)\n{\n\tint n;\n\tn = (int)(0.5+(clr->c[channel] * (double)maxcolorcode));\n\tif(n<0) n=0;\n\telse if(n>(int)maxcolorcode) n=(int)maxcolorcode;\n\treturn (unsigned int)n;\n}\n\nIW_IMPL(void) iw_set_value(struct iw_context *ctx, int code, int n)\n{\n\tswitch(code) {\n\tcase IW_VAL_API_VERSION:\n\t\tctx->caller_api_version = n;\n\t\tbreak;\n\tcase IW_VAL_CVT_TO_GRAYSCALE:\n\t\tctx->to_grayscale = n;\n\t\tbreak;\n\tcase IW_VAL_DISABLE_GAMMA:\n\t\tctx->no_gamma = n;\n\t\tbreak;\n\tcase IW_VAL_NO_CSLABEL:\n\t\tctx->req.suppress_output_cslabel = n;\n\t\tbreak;\n\tcase IW_VAL_INT_CLAMP:\n\t\tctx->intclamp = n;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_X:\n\t\tctx->resize_settings[IW_DIMENSION_H].edge_policy = n;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_Y:\n\t\tctx->resize_settings[IW_DIMENSION_V].edge_policy = n;\n\t\tbreak;\n\tcase IW_VAL_PREF_UNITS:\n\t\tctx->pref_units = n;\n\t\tbreak;\n\tcase IW_VAL_GRAYSCALE_FORMULA:\n\t\tctx->grayscale_formula = n;\n\t\tbreak;\n\tcase IW_VAL_INPUT_NATIVE_GRAYSCALE:\n\t\tctx->img1.native_grayscale = n;\n\t\tbreak;\n\tcase IW_VAL_COMPRESSION:\n\t\tctx->req.compression = n;\n\t\tbreak;\n\tcase IW_VAL_PAGE_TO_READ:\n\t\tctx->req.page_to_read = n;\n\t\tbreak;\n\tcase IW_VAL_INCLUDE_SCREEN:\n\t\tctx->req.include_screen = n;\n\t\tbreak;\n\tcase IW_VAL_JPEG_QUALITY:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:quality\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_SAMP_FACTOR_H:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:sampling-x\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_SAMP_FACTOR_V:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:sampling-y\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_JPEG_ARITH_CODING:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"jpeg:arith\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_DEFLATE_CMPR_LEVEL:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"deflate:cmprlevel\", iwpvt_strdup_dbl(ctx, (double)n)); \n\t\tbreak;\n\tcase IW_VAL_OUTPUT_INTERLACED:\n\t\tctx->req.interlaced = n;\n\t\tbreak;\n\tcase IW_VAL_USE_BKGD_LABEL:\n\t\tctx->req.use_bkgd_label_from_file = n;\n\t\tbreak;\n\tcase IW_VAL_BMP_NO_FILEHEADER:\n\t\tctx->req.bmp_no_fileheader = n;\n\t\tbreak;\n\tcase IW_VAL_BMP_VERSION:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"bmp:version\", iwpvt_strdup_dbl(ctx, (double)n));\n\t\tbreak;\n\tcase IW_VAL_MAX_WIDTH:\n\t\tctx->max_width = n;\n\t\tbreak;\n\tcase IW_VAL_MAX_HEIGHT:\n\t\tctx->max_height = n;\n\t\tbreak;\n\tcase IW_VAL_NO_BKGD_LABEL:\n\t\tctx->req.suppress_output_bkgd_label = n;\n\t\tbreak;\n\tcase IW_VAL_INTENT:\n\t\tctx->req.output_rendering_intent = n;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_SAMPLE_TYPE:\n\t\tctx->req.output_sample_type = n;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_COLOR_TYPE:\n\t\t// For backward compatibility only.\n\t\tif(n==IW_COLORTYPE_RGB) {\n\t\t\tiw_set_option(ctx, \"deflate:colortype\", \"rgb\"); \n\t\t}\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_FORMAT:\n\t\tctx->req.output_format = n;\n\t\tbreak;\n\tcase IW_VAL_NEGATE_TARGET:\n\t\tctx->req.negate_target = n;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(int) iw_get_value(struct iw_context *ctx, int code)\n{\n\tint ret=0;\n\n\tswitch(code) {\n\tcase IW_VAL_API_VERSION:\n\t\tret = ctx->caller_api_version;\n\t\tbreak;\n\tcase IW_VAL_CVT_TO_GRAYSCALE:\n\t\tret = ctx->to_grayscale;\n\t\tbreak;\n\tcase IW_VAL_DISABLE_GAMMA:\n\t\tret = ctx->no_gamma;\n\t\tbreak;\n\tcase IW_VAL_NO_CSLABEL:\n\t\tret = ctx->req.suppress_output_cslabel;\n\t\tbreak;\n\tcase IW_VAL_INT_CLAMP:\n\t\tret = ctx->intclamp;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_X:\n\t\tret = ctx->resize_settings[IW_DIMENSION_H].edge_policy;\n\t\tbreak;\n\tcase IW_VAL_EDGE_POLICY_Y:\n\t\tret = ctx->resize_settings[IW_DIMENSION_V].edge_policy;\n\t\tbreak;\n\tcase IW_VAL_PREF_UNITS:\n\t\tret = ctx->pref_units;\n\t\tbreak;\n\tcase IW_VAL_GRAYSCALE_FORMULA:\n\t\tret = ctx->grayscale_formula;\n\t\tbreak;\n\tcase IW_VAL_INPUT_NATIVE_GRAYSCALE:\n\t\tret = ctx->img1.native_grayscale;\n\t\tbreak;\n\tcase IW_VAL_INPUT_WIDTH:\n\t\tif(ctx->img1.width<1) ret=1;\n\t\telse ret = ctx->img1.width;\n\t\tbreak;\n\tcase IW_VAL_INPUT_HEIGHT:\n\t\tif(ctx->img1.height<1) ret=1;\n\t\telse ret = ctx->img1.height;\n\t\tbreak;\n\tcase IW_VAL_INPUT_IMAGE_TYPE:\n\t\tret = ctx->img1.imgtype;\n\t\tbreak;\n\tcase IW_VAL_INPUT_DEPTH:\n\t\tret = ctx->img1.bit_depth;\n\t\tbreak;\n\tcase IW_VAL_COMPRESSION:\n\t\tret = ctx->req.compression;\n\t\tbreak;\n\tcase IW_VAL_PAGE_TO_READ:\n\t\tret = ctx->req.page_to_read;\n\t\tbreak;\n\tcase IW_VAL_INCLUDE_SCREEN:\n\t\tret = ctx->req.include_screen;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_PALETTE_GRAYSCALE:\n\t\tret = ctx->optctx.palette_is_grayscale;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_INTERLACED:\n\t\tret = ctx->req.interlaced;\n\t\tbreak;\n\tcase IW_VAL_USE_BKGD_LABEL:\n\t\tret = ctx->req.use_bkgd_label_from_file;\n\t\tbreak;\n\tcase IW_VAL_BMP_NO_FILEHEADER:\n\t\tret = ctx->req.bmp_no_fileheader;\n\t\tbreak;\n\tcase IW_VAL_MAX_WIDTH:\n\t\tret = ctx->max_width;\n\t\tbreak;\n\tcase IW_VAL_MAX_HEIGHT:\n\t\tret = ctx->max_height;\n\t\tbreak;\n\tcase IW_VAL_PRECISION:\n\t\tret = 32;\n\t\tbreak;\n\tcase IW_VAL_NO_BKGD_LABEL:\n\t\tret = ctx->req.suppress_output_bkgd_label;\n\t\tbreak;\n\tcase IW_VAL_INTENT:\n\t\tret = ctx->req.output_rendering_intent;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_SAMPLE_TYPE:\n\t\tret = ctx->req.output_sample_type;\n\t\tbreak;\n\tcase IW_VAL_OUTPUT_FORMAT:\n\t\tret = ctx->req.output_format;\n\t\tbreak;\n\tcase IW_VAL_NEGATE_TARGET:\n\t\tret = ctx->req.negate_target;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nIW_IMPL(void) iw_set_value_dbl(struct iw_context *ctx, int code, double n)\n{\n\tswitch(code) {\n\tcase IW_VAL_WEBP_QUALITY:\n\t\t// For backward compatibility only.\n\t\tiw_set_option(ctx, \"webp:quality\", iwpvt_strdup_dbl(ctx, n)); \n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_X:\n\t\tctx->resize_settings[IW_DIMENSION_H].translate = n;\n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_Y:\n\t\tctx->resize_settings[IW_DIMENSION_V].translate = n;\n\t\tbreak;\n\t}\n}\n\nIW_IMPL(double) iw_get_value_dbl(struct iw_context *ctx, int code)\n{\n\tdouble ret = 0.0;\n\n\tswitch(code) {\n\tcase IW_VAL_TRANSLATE_X:\n\t\tret = ctx->resize_settings[IW_DIMENSION_H].translate;\n\t\tbreak;\n\tcase IW_VAL_TRANSLATE_Y:\n\t\tret = ctx->resize_settings[IW_DIMENSION_V].translate;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nIW_IMPL(void) iw_set_option(struct iw_context *ctx, const char *name, const char *val)\n{\n#define IW_MAX_OPTIONS 32\n\tint i;\n\n\tif(val==NULL || val[0]=='\\0') {\n\t\t// An empty value can be used to mean \"turn on this option\".\n\t\t// To make that easier, set such values to \"1\".\n\t\tval = \"1\";\n\t}\n\n\t// Allocate req.options if that hasn't been done yet.\n\tif(!ctx->req.options) {\n\t\tctx->req.options = iw_mallocz(ctx, IW_MAX_OPTIONS*sizeof(struct iw_option_struct));\n\t\tif(!ctx->req.options) return;\n\t\tctx->req.options_numalloc = IW_MAX_OPTIONS;\n\t\tctx->req.options_count = 0;\n\t}\n\n\t// If option already exists, replace it.\n\tfor(i=0; i<ctx->req.options_count; i++) {\n\t\tif(ctx->req.options[i].name && !strcmp(ctx->req.options[i].name, name)) {\n\t\t\tiw_free(ctx, ctx->req.options[i].val);\n\t\t\tctx->req.options[i].val = iw_strdup(ctx, val);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Add the new option.\n\tif(ctx->req.options_count>=IW_MAX_OPTIONS) return;\n\tctx->req.options[ctx->req.options_count].name = iw_strdup(ctx, name);\n\tctx->req.options[ctx->req.options_count].val = iw_strdup(ctx, val);\n\tctx->req.options_count++;\n}\n\n// Return the value of the first option with the given name.\n// Return NULL if not found.\nIW_IMPL(const char*) iw_get_option(struct iw_context *ctx, const char *name)\n{\n\tint i;\n\tfor(i=0; i<ctx->req.options_count; i++) {\n\t\tif(ctx->req.options[i].name && !strcmp(ctx->req.options[i].name, name)) {\n\t\t\treturn ctx->req.options[i].val;\n\t\t}\n\t}\n\treturn NULL;\n}\n"], "filenames": ["src/imagew-api.c"], "buggy_code_start_loc": [485], "buggy_code_end_loc": [493], "fixing_code_start_loc": [486], "fixing_code_end_loc": [500], "type": "CWE-369", "message": "imagew-cmd.c:850:46 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (divide-by-zero error) via a crafted image, related to imagew-api.c.", "other": {"cve": {"id": "CVE-2017-9201", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-23T04:29:04.353", "lastModified": "2019-09-16T14:33:31.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "imagew-cmd.c:850:46 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (divide-by-zero error) via a crafted image, related to imagew-api.c."}, {"lang": "es", "value": "Imagew-cmd.c:850:46 en libimageworsener.a en ImageWorsener 1.3.1 permite a atacantes remotos causar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero) a trav\u00e9s de una imagen especialmente dise\u00f1ada, relacionada con imagew-api.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:imageworsener:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "60307047-29E3-470F-9482-7FA546DE3196"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/05/20/imageworsener-multiple-vulnerabilities/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/jsummers/imageworsener/commit/dc49c807926b96e503bd7c0dec35119eecd6c6fe", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/imageworsener/commit/dc49c807926b96e503bd7c0dec35119eecd6c6fe"}}