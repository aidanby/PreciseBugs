{"buggy_code": ["/*\n * Copyright (C) 2005-2010 IBM Corporation\n *\n * Author:\n * Mimi Zohar <zohar@us.ibm.com>\n * Kylene Hall <kjhall@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * File: evm_main.c\n *\timplements evm_inode_setxattr, evm_inode_post_setxattr,\n *\tevm_inode_removexattr, and evm_verifyxattr\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/audit.h>\n#include <linux/xattr.h>\n#include <linux/integrity.h>\n#include <linux/evm.h>\n#include <crypto/hash.h>\n#include \"evm.h\"\n\nint evm_initialized;\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\nchar *evm_hmac = \"hmac(sha1)\";\nchar *evm_hash = \"sha1\";\nint evm_hmac_attrs;\n\nchar *evm_config_xattrnames[] = {\n#ifdef CONFIG_SECURITY_SELINUX\n\tXATTR_NAME_SELINUX,\n#endif\n#ifdef CONFIG_SECURITY_SMACK\n\tXATTR_NAME_SMACK,\n#ifdef CONFIG_EVM_EXTRA_SMACK_XATTRS\n\tXATTR_NAME_SMACKEXEC,\n\tXATTR_NAME_SMACKTRANSMUTE,\n\tXATTR_NAME_SMACKMMAP,\n#endif\n#endif\n#ifdef CONFIG_IMA_APPRAISE\n\tXATTR_NAME_IMA,\n#endif\n\tXATTR_NAME_CAPS,\n\tNULL\n};\n\nstatic int evm_fixmode;\nstatic int __init evm_set_fixmode(char *str)\n{\n\tif (strncmp(str, \"fix\", 3) == 0)\n\t\tevm_fixmode = 1;\n\treturn 0;\n}\n__setup(\"evm=\", evm_set_fixmode);\n\nstatic void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}\n\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = inode->i_op->getxattr(dentry, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n/*\n * evm_verify_hmac - calculate and compare the HMAC with the EVM xattr\n *\n * Compute the HMAC on the dentry's protected set of extended attributes\n * and compare it against the stored security.evm xattr.\n *\n * For performance:\n * - use the previoulsy retrieved xattr value and length to calculate the\n *   HMAC.)\n * - cache the verification result in the iint, when available.\n *\n * Returns integrity status\n */\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = memcmp(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\n/**\n * evm_verifyxattr - verify the integrity of the requested xattr\n * @dentry: object of the verify xattr\n * @xattr_name: requested xattr\n * @xattr_value: requested xattr value\n * @xattr_value_len: requested xattr value length\n *\n * Calculate the HMAC for the given dentry and verify it against the stored\n * security.evm xattr. For performance, use the xattr value and length\n * previously retrieved to calculate the HMAC.\n *\n * Returns the xattr integrity status.\n *\n * This function requires the caller to lock the inode's i_mutex before it\n * is executed.\n */\nenum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}\nEXPORT_SYMBOL_GPL(evm_verifyxattr);\n\n/*\n * evm_verify_current_integrity - verify the dentry's metadata integrity\n * @dentry: pointer to the affected dentry\n *\n * Verify and return the dentry's metadata integrity. The exceptions are\n * before EVM is initialized or in 'fix' mode.\n */\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}\n\n/*\n * evm_protect_xattr - protect the EVM extended attribute\n *\n * Prevent security.evm from being modified or removed without the\n * necessary permissions or when the existing value is invalid.\n *\n * The posix xattr acls are 'system' prefixed, which normally would not\n * affect security.evm.  An interesting side affect of writing posix xattr\n * acls is their modifying of the i_mode, which is included in security.evm.\n * For posix xattr acls only, permit security.evm, even if it currently\n * doesn't exist, to be updated.\n */\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_inode->i_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_inode->i_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}\n\n/**\n * evm_inode_setxattr - protect the EVM extended attribute\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n * @xattr_value: pointer to the new extended attribute value\n * @xattr_value_len: pointer to the new extended attribute value length\n *\n * Before allowing the 'security.evm' protected xattr to be updated,\n * verify the existing value is valid.  As only the kernel should have\n * access to the EVM encrypted key needed to calculate the HMAC, prevent\n * userspace from writing HMAC value.  Writing 'security.evm' requires\n * requires CAP_SYS_ADMIN privileges.\n */\nint evm_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = xattr_value;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!xattr_value_len)\n\t\t\treturn -EINVAL;\n\t\tif (xattr_data->type != EVM_IMA_XATTR_DIGSIG)\n\t\t\treturn -EPERM;\n\t}\n\treturn evm_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len);\n}\n\n/**\n * evm_inode_removexattr - protect the EVM extended attribute\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n *\n * Removing 'security.evm' requires CAP_SYS_ADMIN privileges and that\n * the current value is valid.\n */\nint evm_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\treturn evm_protect_xattr(dentry, xattr_name, NULL, 0);\n}\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}\n\n/**\n * evm_inode_post_setxattr - update 'security.evm' to reflect the changes\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n * @xattr_value: pointer to the new extended attribute value\n * @xattr_value_len: pointer to the new extended attribute value length\n *\n * Update the HMAC stored in 'security.evm' to reflect the change.\n *\n * No need to take the i_mutex lock here, as this function is called from\n * __vfs_setxattr_noperm().  The caller of which has taken the inode's\n * i_mutex lock.\n */\nvoid evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (!evm_initialized || (!evm_protected_xattr(xattr_name)\n\t\t\t\t && !posix_xattr_acl(xattr_name)))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\n}\n\n/**\n * evm_inode_post_removexattr - update 'security.evm' after removing the xattr\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n *\n * Update the HMAC stored in 'security.evm' to reflect removal of the xattr.\n *\n * No need to take the i_mutex lock here, as this function is called from\n * vfs_removexattr() which takes the i_mutex.\n */\nvoid evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}\n\n/**\n * evm_inode_setattr - prevent updating an invalid EVM extended attribute\n * @dentry: pointer to the affected dentry\n */\nint evm_inode_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tenum integrity_status evm_status;\n\n\tif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\n\t\treturn 0;\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\treturn 0;\n\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t    integrity_status_msg[evm_status], -EPERM, 0);\n\treturn -EPERM;\n}\n\n/**\n * evm_inode_post_setattr - update 'security.evm' after modifying metadata\n * @dentry: pointer to the affected dentry\n * @ia_valid: for the UID and GID status\n *\n * For now, update the HMAC stored in 'security.evm' to reflect UID/GID\n * changes.\n *\n * This function is called from notify_change(), which expects the caller\n * to lock the inode's i_mutex.\n */\nvoid evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\n{\n\tif (!evm_initialized)\n\t\treturn;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\tevm_update_evmxattr(dentry, NULL, NULL, 0);\n}\n\n/*\n * evm_inode_init_security - initializes security.evm\n */\nint evm_inode_init_security(struct inode *inode,\n\t\t\t\t const struct xattr *lsm_xattr,\n\t\t\t\t struct xattr *evm_xattr)\n{\n\tstruct evm_ima_xattr_data *xattr_data;\n\tint rc;\n\n\tif (!evm_initialized || !evm_protected_xattr(lsm_xattr->name))\n\t\treturn 0;\n\n\txattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\n\tif (!xattr_data)\n\t\treturn -ENOMEM;\n\n\txattr_data->type = EVM_XATTR_HMAC;\n\trc = evm_init_hmac(inode, lsm_xattr, xattr_data->digest);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tevm_xattr->value = xattr_data;\n\tevm_xattr->value_len = sizeof(*xattr_data);\n\tevm_xattr->name = XATTR_EVM_SUFFIX;\n\treturn 0;\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(evm_inode_init_security);\n\n#ifdef CONFIG_EVM_LOAD_X509\nvoid __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}\n#endif\n\nstatic int __init init_evm(void)\n{\n\tint error;\n\n\tevm_init_config();\n\n\terror = integrity_init_keyring(INTEGRITY_KEYRING_EVM);\n\tif (error)\n\t\treturn error;\n\n\terror = evm_init_secfs();\n\tif (error < 0) {\n\t\tpr_info(\"Error registering secfs\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * evm_display_config - list the EVM protected security extended attributes\n */\nstatic int __init evm_display_config(void)\n{\n\tchar **xattrname;\n\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\n\t\tpr_info(\"%s\\n\", *xattrname);\n\treturn 0;\n}\n\npure_initcall(evm_display_config);\nlate_initcall(init_evm);\n\nMODULE_DESCRIPTION(\"Extended Verification Module\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * Copyright (C) 2005-2010 IBM Corporation\n *\n * Author:\n * Mimi Zohar <zohar@us.ibm.com>\n * Kylene Hall <kjhall@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * File: evm_main.c\n *\timplements evm_inode_setxattr, evm_inode_post_setxattr,\n *\tevm_inode_removexattr, and evm_verifyxattr\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/audit.h>\n#include <linux/xattr.h>\n#include <linux/integrity.h>\n#include <linux/evm.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include \"evm.h\"\n\nint evm_initialized;\n\nstatic char *integrity_status_msg[] = {\n\t\"pass\", \"fail\", \"no_label\", \"no_xattrs\", \"unknown\"\n};\nchar *evm_hmac = \"hmac(sha1)\";\nchar *evm_hash = \"sha1\";\nint evm_hmac_attrs;\n\nchar *evm_config_xattrnames[] = {\n#ifdef CONFIG_SECURITY_SELINUX\n\tXATTR_NAME_SELINUX,\n#endif\n#ifdef CONFIG_SECURITY_SMACK\n\tXATTR_NAME_SMACK,\n#ifdef CONFIG_EVM_EXTRA_SMACK_XATTRS\n\tXATTR_NAME_SMACKEXEC,\n\tXATTR_NAME_SMACKTRANSMUTE,\n\tXATTR_NAME_SMACKMMAP,\n#endif\n#endif\n#ifdef CONFIG_IMA_APPRAISE\n\tXATTR_NAME_IMA,\n#endif\n\tXATTR_NAME_CAPS,\n\tNULL\n};\n\nstatic int evm_fixmode;\nstatic int __init evm_set_fixmode(char *str)\n{\n\tif (strncmp(str, \"fix\", 3) == 0)\n\t\tevm_fixmode = 1;\n\treturn 0;\n}\n__setup(\"evm=\", evm_set_fixmode);\n\nstatic void __init evm_init_config(void)\n{\n#ifdef CONFIG_EVM_ATTR_FSUUID\n\tevm_hmac_attrs |= EVM_ATTR_FSUUID;\n#endif\n\tpr_info(\"HMAC attrs: 0x%x\\n\", evm_hmac_attrs);\n}\n\nstatic int evm_find_protected_xattrs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tchar **xattr;\n\tint error;\n\tint count = 0;\n\n\tif (!inode->i_op->getxattr)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (xattr = evm_config_xattrnames; *xattr != NULL; xattr++) {\n\t\terror = inode->i_op->getxattr(dentry, *xattr, NULL, 0);\n\t\tif (error < 0) {\n\t\t\tif (error == -ENODATA)\n\t\t\t\tcontinue;\n\t\t\treturn error;\n\t\t}\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\n/*\n * evm_verify_hmac - calculate and compare the HMAC with the EVM xattr\n *\n * Compute the HMAC on the dentry's protected set of extended attributes\n * and compare it against the stored security.evm xattr.\n *\n * For performance:\n * - use the previoulsy retrieved xattr value and length to calculate the\n *   HMAC.)\n * - cache the verification result in the iint, when available.\n *\n * Returns integrity status\n */\nstatic enum integrity_status evm_verify_hmac(struct dentry *dentry,\n\t\t\t\t\t     const char *xattr_name,\n\t\t\t\t\t     char *xattr_value,\n\t\t\t\t\t     size_t xattr_value_len,\n\t\t\t\t\t     struct integrity_iint_cache *iint)\n{\n\tstruct evm_ima_xattr_data *xattr_data = NULL;\n\tstruct evm_ima_xattr_data calc;\n\tenum integrity_status evm_status = INTEGRITY_PASS;\n\tint rc, xattr_len;\n\n\tif (iint && iint->evm_status == INTEGRITY_PASS)\n\t\treturn iint->evm_status;\n\n\t/* if status is not PASS, try to check again - against -ENOMEM */\n\n\t/* first need to know the sig type */\n\trc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,\n\t\t\t\tGFP_NOFS);\n\tif (rc <= 0) {\n\t\tevm_status = INTEGRITY_FAIL;\n\t\tif (rc == -ENODATA) {\n\t\t\trc = evm_find_protected_xattrs(dentry);\n\t\t\tif (rc > 0)\n\t\t\t\tevm_status = INTEGRITY_NOLABEL;\n\t\t\telse if (rc == 0)\n\t\t\t\tevm_status = INTEGRITY_NOXATTRS; /* new file */\n\t\t} else if (rc == -EOPNOTSUPP) {\n\t\t\tevm_status = INTEGRITY_UNKNOWN;\n\t\t}\n\t\tgoto out;\n\t}\n\n\txattr_len = rc;\n\n\t/* check value type */\n\tswitch (xattr_data->type) {\n\tcase EVM_XATTR_HMAC:\n\t\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = crypto_memneq(xattr_data->digest, calc.digest,\n\t\t\t    sizeof(calc.digest));\n\t\tif (rc)\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\trc = evm_calc_hash(dentry, xattr_name, xattr_value,\n\t\t\t\txattr_value_len, calc.digest);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,\n\t\t\t\t\t(const char *)xattr_data, xattr_len,\n\t\t\t\t\tcalc.digest, sizeof(calc.digest));\n\t\tif (!rc) {\n\t\t\t/* Replace RSA with HMAC if not mounted readonly and\n\t\t\t * not immutable\n\t\t\t */\n\t\t\tif (!IS_RDONLY(d_backing_inode(dentry)) &&\n\t\t\t    !IS_IMMUTABLE(d_backing_inode(dentry)))\n\t\t\t\tevm_update_evmxattr(dentry, xattr_name,\n\t\t\t\t\t\t    xattr_value,\n\t\t\t\t\t\t    xattr_value_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc)\n\t\tevm_status = (rc == -ENODATA) ?\n\t\t\t\tINTEGRITY_NOXATTRS : INTEGRITY_FAIL;\nout:\n\tif (iint)\n\t\tiint->evm_status = evm_status;\n\tkfree(xattr_data);\n\treturn evm_status;\n}\n\nstatic int evm_protected_xattr(const char *req_xattr_name)\n{\n\tchar **xattrname;\n\tint namelen;\n\tint found = 0;\n\n\tnamelen = strlen(req_xattr_name);\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((strlen(*xattrname) == namelen)\n\t\t    && (strncmp(req_xattr_name, *xattrname, namelen) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (strncmp(req_xattr_name,\n\t\t\t    *xattrname + XATTR_SECURITY_PREFIX_LEN,\n\t\t\t    strlen(req_xattr_name)) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\n/**\n * evm_verifyxattr - verify the integrity of the requested xattr\n * @dentry: object of the verify xattr\n * @xattr_name: requested xattr\n * @xattr_value: requested xattr value\n * @xattr_value_len: requested xattr value length\n *\n * Calculate the HMAC for the given dentry and verify it against the stored\n * security.evm xattr. For performance, use the xattr value and length\n * previously retrieved to calculate the HMAC.\n *\n * Returns the xattr integrity status.\n *\n * This function requires the caller to lock the inode's i_mutex before it\n * is executed.\n */\nenum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}\nEXPORT_SYMBOL_GPL(evm_verifyxattr);\n\n/*\n * evm_verify_current_integrity - verify the dentry's metadata integrity\n * @dentry: pointer to the affected dentry\n *\n * Verify and return the dentry's metadata integrity. The exceptions are\n * before EVM is initialized or in 'fix' mode.\n */\nstatic enum integrity_status evm_verify_current_integrity(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\n\tif (!evm_initialized || !S_ISREG(inode->i_mode) || evm_fixmode)\n\t\treturn 0;\n\treturn evm_verify_hmac(dentry, NULL, NULL, 0, NULL);\n}\n\n/*\n * evm_protect_xattr - protect the EVM extended attribute\n *\n * Prevent security.evm from being modified or removed without the\n * necessary permissions or when the existing value is invalid.\n *\n * The posix xattr acls are 'system' prefixed, which normally would not\n * affect security.evm.  An interesting side affect of writing posix xattr\n * acls is their modifying of the i_mode, which is included in security.evm.\n * For posix xattr acls only, permit security.evm, even if it currently\n * doesn't exist, to be updated.\n */\nstatic int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tenum integrity_status evm_status;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!evm_protected_xattr(xattr_name)) {\n\t\tif (!posix_xattr_acl(xattr_name))\n\t\t\treturn 0;\n\t\tevm_status = evm_verify_current_integrity(dentry);\n\t\tif ((evm_status == INTEGRITY_PASS) ||\n\t\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\t\treturn 0;\n\t\tgoto out;\n\t}\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif (evm_status == INTEGRITY_NOXATTRS) {\n\t\tstruct integrity_iint_cache *iint;\n\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (iint && (iint->flags & IMA_NEW_FILE))\n\t\t\treturn 0;\n\n\t\t/* exception for pseudo filesystems */\n\t\tif (dentry->d_inode->i_sb->s_magic == TMPFS_MAGIC\n\t\t    || dentry->d_inode->i_sb->s_magic == SYSFS_MAGIC)\n\t\t\treturn 0;\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA,\n\t\t\t\t    dentry->d_inode, dentry->d_name.name,\n\t\t\t\t    \"update_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\t}\nout:\n\tif (evm_status != INTEGRITY_PASS)\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t\t    integrity_status_msg[evm_status],\n\t\t\t\t    -EPERM, 0);\n\treturn evm_status == INTEGRITY_PASS ? 0 : -EPERM;\n}\n\n/**\n * evm_inode_setxattr - protect the EVM extended attribute\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n * @xattr_value: pointer to the new extended attribute value\n * @xattr_value_len: pointer to the new extended attribute value length\n *\n * Before allowing the 'security.evm' protected xattr to be updated,\n * verify the existing value is valid.  As only the kernel should have\n * access to the EVM encrypted key needed to calculate the HMAC, prevent\n * userspace from writing HMAC value.  Writing 'security.evm' requires\n * requires CAP_SYS_ADMIN privileges.\n */\nint evm_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xattr_data = xattr_value;\n\n\tif (strcmp(xattr_name, XATTR_NAME_EVM) == 0) {\n\t\tif (!xattr_value_len)\n\t\t\treturn -EINVAL;\n\t\tif (xattr_data->type != EVM_IMA_XATTR_DIGSIG)\n\t\t\treturn -EPERM;\n\t}\n\treturn evm_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len);\n}\n\n/**\n * evm_inode_removexattr - protect the EVM extended attribute\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n *\n * Removing 'security.evm' requires CAP_SYS_ADMIN privileges and that\n * the current value is valid.\n */\nint evm_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\treturn evm_protect_xattr(dentry, xattr_name, NULL, 0);\n}\n\nstatic void evm_reset_status(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tiint = integrity_iint_find(inode);\n\tif (iint)\n\t\tiint->evm_status = INTEGRITY_UNKNOWN;\n}\n\n/**\n * evm_inode_post_setxattr - update 'security.evm' to reflect the changes\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n * @xattr_value: pointer to the new extended attribute value\n * @xattr_value_len: pointer to the new extended attribute value length\n *\n * Update the HMAC stored in 'security.evm' to reflect the change.\n *\n * No need to take the i_mutex lock here, as this function is called from\n * __vfs_setxattr_noperm().  The caller of which has taken the inode's\n * i_mutex lock.\n */\nvoid evm_inode_post_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (!evm_initialized || (!evm_protected_xattr(xattr_name)\n\t\t\t\t && !posix_xattr_acl(xattr_name)))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, xattr_value, xattr_value_len);\n}\n\n/**\n * evm_inode_post_removexattr - update 'security.evm' after removing the xattr\n * @dentry: pointer to the affected dentry\n * @xattr_name: pointer to the affected extended attribute name\n *\n * Update the HMAC stored in 'security.evm' to reflect removal of the xattr.\n *\n * No need to take the i_mutex lock here, as this function is called from\n * vfs_removexattr() which takes the i_mutex.\n */\nvoid evm_inode_post_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn;\n\n\tevm_reset_status(dentry->d_inode);\n\n\tevm_update_evmxattr(dentry, xattr_name, NULL, 0);\n}\n\n/**\n * evm_inode_setattr - prevent updating an invalid EVM extended attribute\n * @dentry: pointer to the affected dentry\n */\nint evm_inode_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tenum integrity_status evm_status;\n\n\tif (!(ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)))\n\t\treturn 0;\n\tevm_status = evm_verify_current_integrity(dentry);\n\tif ((evm_status == INTEGRITY_PASS) ||\n\t    (evm_status == INTEGRITY_NOXATTRS))\n\t\treturn 0;\n\tintegrity_audit_msg(AUDIT_INTEGRITY_METADATA, d_backing_inode(dentry),\n\t\t\t    dentry->d_name.name, \"appraise_metadata\",\n\t\t\t    integrity_status_msg[evm_status], -EPERM, 0);\n\treturn -EPERM;\n}\n\n/**\n * evm_inode_post_setattr - update 'security.evm' after modifying metadata\n * @dentry: pointer to the affected dentry\n * @ia_valid: for the UID and GID status\n *\n * For now, update the HMAC stored in 'security.evm' to reflect UID/GID\n * changes.\n *\n * This function is called from notify_change(), which expects the caller\n * to lock the inode's i_mutex.\n */\nvoid evm_inode_post_setattr(struct dentry *dentry, int ia_valid)\n{\n\tif (!evm_initialized)\n\t\treturn;\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\tevm_update_evmxattr(dentry, NULL, NULL, 0);\n}\n\n/*\n * evm_inode_init_security - initializes security.evm\n */\nint evm_inode_init_security(struct inode *inode,\n\t\t\t\t const struct xattr *lsm_xattr,\n\t\t\t\t struct xattr *evm_xattr)\n{\n\tstruct evm_ima_xattr_data *xattr_data;\n\tint rc;\n\n\tif (!evm_initialized || !evm_protected_xattr(lsm_xattr->name))\n\t\treturn 0;\n\n\txattr_data = kzalloc(sizeof(*xattr_data), GFP_NOFS);\n\tif (!xattr_data)\n\t\treturn -ENOMEM;\n\n\txattr_data->type = EVM_XATTR_HMAC;\n\trc = evm_init_hmac(inode, lsm_xattr, xattr_data->digest);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tevm_xattr->value = xattr_data;\n\tevm_xattr->value_len = sizeof(*xattr_data);\n\tevm_xattr->name = XATTR_EVM_SUFFIX;\n\treturn 0;\nout:\n\tkfree(xattr_data);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(evm_inode_init_security);\n\n#ifdef CONFIG_EVM_LOAD_X509\nvoid __init evm_load_x509(void)\n{\n\tint rc;\n\n\trc = integrity_load_x509(INTEGRITY_KEYRING_EVM, CONFIG_EVM_X509_PATH);\n\tif (!rc)\n\t\tevm_initialized |= EVM_INIT_X509;\n}\n#endif\n\nstatic int __init init_evm(void)\n{\n\tint error;\n\n\tevm_init_config();\n\n\terror = integrity_init_keyring(INTEGRITY_KEYRING_EVM);\n\tif (error)\n\t\treturn error;\n\n\terror = evm_init_secfs();\n\tif (error < 0) {\n\t\tpr_info(\"Error registering secfs\\n\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n}\n\n/*\n * evm_display_config - list the EVM protected security extended attributes\n */\nstatic int __init evm_display_config(void)\n{\n\tchar **xattrname;\n\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++)\n\t\tpr_info(\"%s\\n\", *xattrname);\n\treturn 0;\n}\n\npure_initcall(evm_display_config);\nlate_initcall(init_evm);\n\nMODULE_DESCRIPTION(\"Extended Verification Module\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["security/integrity/evm/evm_main.c"], "buggy_code_start_loc": [25], "buggy_code_end_loc": [152], "fixing_code_start_loc": [26], "fixing_code_end_loc": [153], "type": "CWE-19", "message": "The evm_verify_hmac function in security/integrity/evm/evm_main.c in the Linux kernel before 4.5 does not properly copy data, which makes it easier for local users to forge MAC values via a timing side-channel attack.", "other": {"cve": {"id": "CVE-2016-2085", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-27T17:59:07.977", "lastModified": "2016-12-03T03:24:27.613", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The evm_verify_hmac function in security/integrity/evm/evm_main.c in the Linux kernel before 4.5 does not properly copy data, which makes it easier for local users to forge MAC values via a timing side-channel attack."}, {"lang": "es", "value": "La funci\u00f3n evm_verify_hmac en security/integrity/evm/evm_main.c en el kernel de Linux en versiones anteriores a 4.5 no copia correctamente los datos, lo que facilita a usuarios locales falsificar los valores MAC a trav\u00e9s de un ataque de tiempo side-chanel."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.4.8", "matchCriteriaId": "3E43C27F-72D6-4615-8337-67245A069FFD"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=613317bd212c585c20796c10afe5daaa95d4b0a1", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2946-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2946-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2947-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2947-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2947-3", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2948-1", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2948-2", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2949-1", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1324867", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/613317bd212c585c20796c10afe5daaa95d4b0a1", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://people.canonical.com/~ubuntu-security/cve/2016/CVE-2016-2085.html", "source": "cve@mitre.org"}, {"url": "https://security-tracker.debian.org/tracker/CVE-2016-2085", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/613317bd212c585c20796c10afe5daaa95d4b0a1"}}