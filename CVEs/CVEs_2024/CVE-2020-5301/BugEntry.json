{"buggy_code": ["<?php\n\ndeclare(strict_types=1);\n\nnamespace SimpleSAML;\n\nuse SimpleSAML\\Kernel;\nuse SimpleSAML\\Utils;\nuse Symfony\\Component\\Config\\Exception\\FileLocatorFileNotFoundException;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Webmozart\\Assert\\Assert;\n\n/**\n * Helper class for accessing information about modules.\n *\n * @author Olav Morken <olav.morken@uninett.no>, UNINETT AS.\n * @author Boy Baukema, SURFnet.\n * @author Jaime Perez <jaime.perez@uninett.no>, UNINETT AS.\n * @package SimpleSAMLphp\n */\nclass Module\n{\n    /**\n     * Index pages: file names to attempt when accessing directories.\n     *\n     * @var array\n     */\n    public static $indexFiles = ['index.php', 'index.html', 'index.htm', 'index.txt'];\n\n    /**\n     * MIME Types\n     *\n     * The key is the file extension and the value the corresponding MIME type.\n     *\n     * @var array\n     */\n    public static $mimeTypes = [\n        'bmp'   => 'image/x-ms-bmp',\n        'css'   => 'text/css',\n        'gif'   => 'image/gif',\n        'htm'   => 'text/html',\n        'html'  => 'text/html',\n        'shtml' => 'text/html',\n        'ico'   => 'image/vnd.microsoft.icon',\n        'jpe'   => 'image/jpeg',\n        'jpeg'  => 'image/jpeg',\n        'jpg'   => 'image/jpeg',\n        'js'    => 'text/javascript',\n        'pdf'   => 'application/pdf',\n        'png'   => 'image/png',\n        'svg'   => 'image/svg+xml',\n        'svgz'  => 'image/svg+xml',\n        'swf'   => 'application/x-shockwave-flash',\n        'swfl'  => 'application/x-shockwave-flash',\n        'txt'   => 'text/plain',\n        'xht'   => 'application/xhtml+xml',\n        'xhtml' => 'application/xhtml+xml',\n    ];\n\n    /**\n     * A list containing the modules currently installed.\n     *\n     * @var array\n     */\n    public static $modules = [];\n\n    /**\n     * A list containing the modules that are enabled by default, unless specifically disabled\n     *\n     * @var array\n     */\n    public static $core_modules = [\n        'core' => true,\n        'saml' => true\n    ];\n\n    /**\n     * A cache containing specific information for modules, like whether they are enabled or not, or their hooks.\n     *\n     * @var array\n     */\n    public static $module_info = [];\n\n\n    /**\n     * Retrieve the base directory for a module.\n     *\n     * The returned path name will be an absolute path.\n     *\n     * @param string $module Name of the module\n     *\n     * @return string The base directory of a module.\n     */\n    public static function getModuleDir(string $module): string\n    {\n        $baseDir = dirname(dirname(dirname(__FILE__))) . '/modules';\n        $moduleDir = $baseDir . '/' . $module;\n\n        return $moduleDir;\n    }\n\n\n    /**\n     * Determine whether a module is enabled.\n     *\n     * Will return false if the given module doesn't exist.\n     *\n     * @param string $module Name of the module\n     *\n     * @return bool True if the given module is enabled, false otherwise.\n     *\n     * @throws \\Exception If module.enable is set and is not boolean.\n     */\n    public static function isModuleEnabled(string $module): bool\n    {\n        $config = Configuration::getOptionalConfig();\n        return self::isModuleEnabledWithConf($module, $config->getArray('module.enable', self::$core_modules));\n    }\n\n\n    /**\n     * Handler for module requests.\n     *\n     * This controller receives requests for pages hosted by modules, and processes accordingly. Depending on the\n     * configuration and the actual request, it will run a PHP script and exit, or return a Response produced either\n     * by another controller or by a static file.\n     *\n     * @param Request|null $request The request to process. Defaults to the current one.\n     *\n     * @return Response|BinaryFileResponse Returns a Response object that can be sent to the browser.\n     * @throws Error\\BadRequest In case the request URI is malformed.\n     * @throws Error\\NotFound In case the request URI is invalid or the resource it points to cannot be found.\n     */\n    public static function process(Request $request = null): Response\n    {\n        if ($request === null) {\n            $request = Request::createFromGlobals();\n        }\n\n        if ($request->server->get('PATH_INFO') === '/') {\n            throw new Error\\NotFound('No PATH_INFO to module.php');\n        }\n\n        $url = $request->server->get('PATH_INFO');\n        Assert::same(substr($url, 0, 1), '/');\n\n        /* clear the PATH_INFO option, so that a script can detect whether it is called with anything following the\n         *'.php'-ending.\n         */\n        unset($_SERVER['PATH_INFO']);\n\n        $modEnd = strpos($url, '/', 1);\n        if ($modEnd === false) {\n            $modEnd = strlen($url);\n            $module = substr($url, 1);\n            $url = '';\n        } else {\n            $module = substr($url, 1, $modEnd - 1);\n            $url = substr($url, $modEnd + 1);\n        }\n\n        if (!self::isModuleEnabled($module)) {\n            throw new Error\\NotFound('The module \\'' . $module . '\\' was either not found, or wasn\\'t enabled.');\n        }\n\n        /* Make sure that the request isn't suspicious (contains references to current directory or parent directory or\n         * anything like that. Searching for './' in the URL will detect both '../' and './'. Searching for '\\' will\n         * detect attempts to use Windows-style paths.\n         */\n        if (strpos($url, '\\\\') !== false) {\n            throw new Error\\BadRequest('Requested URL contained a backslash.');\n        } elseif (strpos($url, './') !== false) {\n            throw new Error\\BadRequest('Requested URL contained \\'./\\'.');\n        }\n\n        $config = Configuration::getInstance();\n\n        // rebuild REQUEST_URI and SCRIPT_NAME just in case we need to.\n        // This is needed for server aliases and rewrites\n        $translated_uri = $config->getBasePath() . 'module.php/' . $module . '/' . $url;\n        $request->server->set('REQUEST_URI', $translated_uri);\n        $request->server->set('SCRIPT_NAME', $config->getBasePath() . 'module.php');\n        // strip any NULL files (form file fields with nothing selected)\n        // because initialize() will throw an error on them\n        $request_files = array_filter(\n            $request->files->all(),\n            function ($val) {\n                return !is_null($val);\n            }\n        );\n        $request->initialize(\n            $request->query->all(),\n            $request->request->all(),\n            $request->attributes->all(),\n            $request->cookies->all(),\n            $request_files,\n            $request->server->all(),\n            $request->getContent()\n        );\n\n        try {\n            $kernel = new Kernel($module);\n            $response = $kernel->handle($request);\n            $kernel->terminate($request, $response);\n\n            return $response;\n        } catch (FileLocatorFileNotFoundException $e) {\n            // no routes configured for this module, fall back to the old system\n        } catch (NotFoundHttpException $e) {\n            // this module has been migrated, but the route wasn't found\n        }\n\n        $moduleDir = self::getModuleDir($module) . '/www/';\n\n        // check for '.php/' in the path, the presence of which indicates that another php-script should handle the\n        // request\n        for ($phpPos = strpos($url, '.php/'); $phpPos !== false; $phpPos = strpos($url, '.php/', $phpPos + 1)) {\n            $newURL = substr($url, 0, $phpPos + 4);\n            $param = substr($url, $phpPos + 4);\n\n            if (is_file($moduleDir . $newURL)) {\n                /* $newPath points to a normal file. Point execution to that file, and save the remainder of the path\n                 * in PATH_INFO.\n                 */\n                $url = $newURL;\n                $request->server->set('PATH_INFO', $param);\n                $_SERVER['PATH_INFO'] = $param;\n                break;\n            }\n        }\n\n        $path = $moduleDir . $url;\n\n        if ($path[strlen($path) - 1] === '/') {\n            // path ends with a slash - directory reference. Attempt to find index file in directory\n            foreach (self::$indexFiles as $if) {\n                if (file_exists($path . $if)) {\n                    $path .= $if;\n                    break;\n                }\n            }\n        }\n\n        if (is_dir($path)) {\n            /* Path is a directory - maybe no index file was found in the previous step, or maybe the path didn't end\n             * with a slash. Either way, we don't do directory listings.\n             */\n            throw new Error\\NotFound('Directory listing not available.');\n        }\n\n        if (!file_exists($path)) {\n            // file not found\n            Logger::info('Could not find file \\'' . $path . '\\'.');\n            throw new Error\\NotFound('The URL wasn\\'t found in the module.');\n        }\n\n        if (substr($path, -4) === '.php') {\n            // PHP file - attempt to run it\n\n            /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that\n             * case, and append script name only if necessary.\n             *\n             * Contributed by Travis Hegner.\n             */\n            $script = \"/$module/$url\";\n            if (strpos($request->getScriptName(), $script) === false) {\n                $request->server->set('SCRIPT_NAME', $request->getScriptName() . '/' . $module . '/' . $url);\n            }\n\n            require($path);\n            exit();\n        }\n\n        // some other file type - attempt to serve it\n\n        // find MIME type for file, based on extension\n        $contentType = null;\n        if (preg_match('#\\.([^/\\.]+)$#D', $path, $type)) {\n            $type = strtolower($type[1]);\n            if (array_key_exists($type, self::$mimeTypes)) {\n                $contentType = self::$mimeTypes[$type];\n            }\n        }\n\n        if ($contentType === null) {\n            /* We were unable to determine the MIME type from the file extension. Fall back to mime_content_type (if it\n             * exists).\n             */\n            if (function_exists('mime_content_type')) {\n                $contentType = mime_content_type($path);\n            } else {\n                // mime_content_type doesn't exist. Return a default MIME type\n                Logger::warning('Unable to determine mime content type of file: ' . $path);\n                $contentType = 'application/octet-stream';\n            }\n        }\n\n        /** @psalm-var \\SimpleSAML\\Configuration $assetConfig */\n        $assetConfig = $config->getConfigItem('assets');\n        /** @psalm-var \\SimpleSAML\\Configuration $cacheConfig */\n        $cacheConfig = $assetConfig->getConfigItem('caching');\n        $response = new BinaryFileResponse($path);\n        $response->setCache([\n            // \"public\" allows response caching even if the request was authenticated,\n            // which is exactly what we want for static resources\n            'public' => true,\n            'max_age' => strval($cacheConfig->getInteger('max_age', 86400))\n        ]);\n        $response->setAutoLastModified();\n        if ($cacheConfig->getBoolean('etag', false)) {\n            $response->setAutoEtag();\n        }\n        $response->isNotModified($request);\n        $response->headers->set('Content-Type', $contentType);\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_INLINE);\n        $response->prepare($request);\n        return $response;\n    }\n\n\n    /**\n     * @param string $module\n     * @param array $mod_config\n     * @return bool\n     */\n    private static function isModuleEnabledWithConf(string $module, array $mod_config): bool\n    {\n        if (isset(self::$module_info[$module]['enabled'])) {\n            return self::$module_info[$module]['enabled'];\n        }\n\n        if (!empty(self::$modules) && !in_array($module, self::$modules, true)) {\n            return false;\n        }\n\n        $moduleDir = self::getModuleDir($module);\n\n        if (!is_dir($moduleDir)) {\n            self::$module_info[$module]['enabled'] = false;\n            return false;\n        }\n\n        if (isset($mod_config[$module])) {\n            if (is_bool($mod_config[$module])) {\n                self::$module_info[$module]['enabled'] = $mod_config[$module];\n                return $mod_config[$module];\n            }\n\n            throw new \\Exception(\"Invalid module.enable value for the '$module' module.\");\n        }\n\n        $core_module =  array_key_exists($module, self::$core_modules) ? true : false;\n\n        self::$module_info[$module]['enabled'] = $core_module ? true : false;\n        return $core_module ? true : false;\n    }\n\n\n    /**\n     * Get available modules.\n     *\n     * @return string[] One string for each module.\n     *\n     * @throws \\Exception If we cannot open the module's directory.\n     */\n    public static function getModules(): array\n    {\n        if (!empty(self::$modules)) {\n            return self::$modules;\n        }\n\n        $path = self::getModuleDir('.');\n\n        $dh = scandir($path);\n        if ($dh === false) {\n            throw new \\Exception('Unable to open module directory \"' . $path . '\".');\n        }\n\n        foreach ($dh as $f) {\n            if ($f[0] === '.') {\n                continue;\n            }\n\n            if (!is_dir($path . '/' . $f)) {\n                continue;\n            }\n\n            self::$modules[] = $f;\n        }\n\n        return self::$modules;\n    }\n\n\n    /**\n     * Resolve module class.\n     *\n     * This function takes a string on the form \"<module>:<class>\" and converts it to a class\n     * name. It can also check that the given class is a subclass of a specific class. The\n     * resolved classname will be \"\\SimleSAML\\Module\\<module>\\<$type>\\<class>.\n     *\n     * It is also possible to specify a full classname instead of <module>:<class>.\n     *\n     * An exception will be thrown if the class can't be resolved.\n     *\n     * @param string      $id The string we should resolve.\n     * @param string      $type The type of the class.\n     * @param string|null $subclass The class should be a subclass of this class. Optional.\n     *\n     * @return string The classname.\n     *\n     * @throws \\Exception If the class cannot be resolved.\n     */\n    public static function resolveClass(string $id, string $type, ?string $subclass = null): string\n    {\n        $tmp = explode(':', $id, 2);\n        if (count($tmp) === 1) {\n            // no module involved\n            $className = $tmp[0];\n            if (!class_exists($className)) {\n                throw new \\Exception(\"Could not resolve '$id': no class named '$className'.\");\n            }\n        } else {\n            // should be a module\n            // make sure empty types are handled correctly\n            $type = (empty($type)) ? '\\\\' : '\\\\' . $type . '\\\\';\n\n            $className = 'SimpleSAML\\\\Module\\\\' . $tmp[0] . $type . $tmp[1];\n            if (!class_exists($className)) {\n                // check for the old-style class names\n                $type = str_replace('\\\\', '_', $type);\n                $oldClassName = 'sspmod_' . $tmp[0] . $type . $tmp[1];\n\n                if (!class_exists($oldClassName)) {\n                    throw new \\Exception(\"Could not resolve '$id': no class named '$className' or '$oldClassName'.\");\n                }\n                $className = $oldClassName;\n            }\n        }\n\n        if ($subclass !== null && !is_subclass_of($className, $subclass)) {\n            throw new \\Exception(\n                'Could not resolve \\'' . $id . '\\': The class \\'' . $className\n                . '\\' isn\\'t a subclass of \\'' . $subclass . '\\'.'\n            );\n        }\n\n        return $className;\n    }\n\n\n    /**\n     * Get absolute URL to a specified module resource.\n     *\n     * This function creates an absolute URL to a resource stored under \".../modules/<module>/www/\".\n     *\n     * @param string $resource Resource path, on the form \"<module name>/<resource>\"\n     * @param array  $parameters Extra parameters which should be added to the URL. Optional.\n     *\n     * @return string The absolute URL to the given resource.\n     */\n    public static function getModuleURL(string $resource, array $parameters = []): string\n    {\n        Assert::notSame($resource[0], '/');\n\n        $url = Utils\\HTTP::getBaseURL() . 'module.php/' . $resource;\n        if (!empty($parameters)) {\n            $url = Utils\\HTTP::addURLParameters($url, $parameters);\n        }\n        return $url;\n    }\n\n\n    /**\n     * Get the available hooks for a given module.\n     *\n     * @param string $module The module where we should look for hooks.\n     *\n     * @return array An array with the hooks available for this module. Each element is an array with two keys: 'file'\n     * points to the file that contains the hook, and 'func' contains the name of the function implementing that hook.\n     * When there are no hooks defined, an empty array is returned.\n     */\n    public static function getModuleHooks(string $module): array\n    {\n        if (isset(self::$modules[$module]['hooks'])) {\n            return self::$modules[$module]['hooks'];\n        }\n\n        $hook_dir = self::getModuleDir($module) . '/hooks';\n        if (!is_dir($hook_dir)) {\n            return [];\n        }\n\n        $hooks = [];\n        $files = scandir($hook_dir);\n        foreach ($files as $file) {\n            if ($file[0] === '.') {\n                continue;\n            }\n\n            if (!preg_match('/hook_(\\w+)\\.php/', $file, $matches)) {\n                continue;\n            }\n            $hook_name = $matches[1];\n            $hook_func = $module . '_hook_' . $hook_name;\n            $hooks[$hook_name] = ['file' => $hook_dir . '/' . $file, 'func' => $hook_func];\n        }\n        return $hooks;\n    }\n\n\n    /**\n     * Call a hook in all enabled modules.\n     *\n     * This function iterates over all enabled modules and calls a hook in each module.\n     *\n     * @param string $hook The name of the hook.\n     * @param mixed  &$data The data which should be passed to each hook. Will be passed as a reference.\n     * @return void\n     *\n     * @throws \\SimpleSAML\\Error\\Exception If an invalid hook is found in a module.\n     */\n    public static function callHooks(string $hook, &$data = null): void\n    {\n        $modules = self::getModules();\n        $config = Configuration::getOptionalConfig()->getArray('module.enable', []);\n        sort($modules);\n        foreach ($modules as $module) {\n            if (!self::isModuleEnabledWithConf($module, $config)) {\n                continue;\n            }\n\n            if (!isset(self::$module_info[$module]['hooks'])) {\n                self::$module_info[$module]['hooks'] = self::getModuleHooks($module);\n            }\n\n            if (\n                !isset(self::$module_info[$module]['hooks'][$hook])\n                || empty(self::$module_info[$module]['hooks'][$hook])\n            ) {\n                continue;\n            }\n\n            require_once(self::$module_info[$module]['hooks'][$hook]['file']);\n\n            if (!is_callable(self::$module_info[$module]['hooks'][$hook]['func'])) {\n                throw new Error\\Exception('Invalid hook \\'' . $hook . '\\' for module \\'' . $module . '\\'.');\n            }\n\n            $fn = self::$module_info[$module]['hooks'][$hook]['func'];\n            $fn($data);\n        }\n    }\n\n\n    /**\n     * Handle a valid request for a module that lacks a trailing slash.\n     *\n     * This method add the trailing slash and redirects to the resulting URL.\n     *\n     * @param Request $request The request to process by this controller method.\n     *\n     * @return RedirectResponse A redirection to the URI specified in the request, but with a trailing slash.\n     */\n    public static function addTrailingSlash(Request $request): RedirectResponse\n    {\n        // Must be of form /{module} - append a slash\n        return new RedirectResponse($request->getRequestUri() . '/', 308);\n    }\n\n\n    /**\n     * Handle a valid request that ends with a trailing slash.\n     *\n     * This method removes the trailing slash and redirects to the resulting URL.\n     *\n     * @param \\Symfony\\Component\\HttpFoundation\\Request $request The request to process by this controller method.\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\RedirectResponse\n     *   A redirection to the URI specified in the request, but without the trailing slash.\n     */\n    public static function removeTrailingSlash(Request $request): RedirectResponse\n    {\n        $pathInfo = $request->server->get('PATH_INFO');\n        $url = str_replace($pathInfo, rtrim($pathInfo, ' /'), $request->getRequestUri());\n        return new RedirectResponse($url, 308);\n    }\n}\n"], "fixing_code": ["<?php\n\ndeclare(strict_types=1);\n\nnamespace SimpleSAML;\n\nuse SimpleSAML\\Kernel;\nuse SimpleSAML\\Utils;\nuse Symfony\\Component\\Config\\Exception\\FileLocatorFileNotFoundException;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\RedirectResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\ResponseHeaderBag;\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\nuse Webmozart\\Assert\\Assert;\n\n/**\n * Helper class for accessing information about modules.\n *\n * @author Olav Morken <olav.morken@uninett.no>, UNINETT AS.\n * @author Boy Baukema, SURFnet.\n * @author Jaime Perez <jaime.perez@uninett.no>, UNINETT AS.\n * @package SimpleSAMLphp\n */\nclass Module\n{\n    /**\n     * Index pages: file names to attempt when accessing directories.\n     *\n     * @var array\n     */\n    public static $indexFiles = ['index.php', 'index.html', 'index.htm', 'index.txt'];\n\n    /**\n     * MIME Types\n     *\n     * The key is the file extension and the value the corresponding MIME type.\n     *\n     * @var array\n     */\n    public static $mimeTypes = [\n        'bmp'   => 'image/x-ms-bmp',\n        'css'   => 'text/css',\n        'gif'   => 'image/gif',\n        'htm'   => 'text/html',\n        'html'  => 'text/html',\n        'shtml' => 'text/html',\n        'ico'   => 'image/vnd.microsoft.icon',\n        'jpe'   => 'image/jpeg',\n        'jpeg'  => 'image/jpeg',\n        'jpg'   => 'image/jpeg',\n        'js'    => 'text/javascript',\n        'pdf'   => 'application/pdf',\n        'png'   => 'image/png',\n        'svg'   => 'image/svg+xml',\n        'svgz'  => 'image/svg+xml',\n        'swf'   => 'application/x-shockwave-flash',\n        'swfl'  => 'application/x-shockwave-flash',\n        'txt'   => 'text/plain',\n        'xht'   => 'application/xhtml+xml',\n        'xhtml' => 'application/xhtml+xml',\n    ];\n\n    /**\n     * A list containing the modules currently installed.\n     *\n     * @var array\n     */\n    public static $modules = [];\n\n    /**\n     * A list containing the modules that are enabled by default, unless specifically disabled\n     *\n     * @var array\n     */\n    public static $core_modules = [\n        'core' => true,\n        'saml' => true\n    ];\n\n    /**\n     * A cache containing specific information for modules, like whether they are enabled or not, or their hooks.\n     *\n     * @var array\n     */\n    public static $module_info = [];\n\n\n    /**\n     * Retrieve the base directory for a module.\n     *\n     * The returned path name will be an absolute path.\n     *\n     * @param string $module Name of the module\n     *\n     * @return string The base directory of a module.\n     */\n    public static function getModuleDir(string $module): string\n    {\n        $baseDir = dirname(dirname(dirname(__FILE__))) . '/modules';\n        $moduleDir = $baseDir . '/' . $module;\n\n        return $moduleDir;\n    }\n\n\n    /**\n     * Determine whether a module is enabled.\n     *\n     * Will return false if the given module doesn't exist.\n     *\n     * @param string $module Name of the module\n     *\n     * @return bool True if the given module is enabled, false otherwise.\n     *\n     * @throws \\Exception If module.enable is set and is not boolean.\n     */\n    public static function isModuleEnabled(string $module): bool\n    {\n        $config = Configuration::getOptionalConfig();\n        return self::isModuleEnabledWithConf($module, $config->getArray('module.enable', self::$core_modules));\n    }\n\n\n    /**\n     * Handler for module requests.\n     *\n     * This controller receives requests for pages hosted by modules, and processes accordingly. Depending on the\n     * configuration and the actual request, it will run a PHP script and exit, or return a Response produced either\n     * by another controller or by a static file.\n     *\n     * @param Request|null $request The request to process. Defaults to the current one.\n     *\n     * @return Response|BinaryFileResponse Returns a Response object that can be sent to the browser.\n     * @throws Error\\BadRequest In case the request URI is malformed.\n     * @throws Error\\NotFound In case the request URI is invalid or the resource it points to cannot be found.\n     */\n    public static function process(Request $request = null): Response\n    {\n        if ($request === null) {\n            $request = Request::createFromGlobals();\n        }\n\n        if ($request->server->get('PATH_INFO') === '/') {\n            throw new Error\\NotFound('No PATH_INFO to module.php');\n        }\n\n        $url = $request->server->get('PATH_INFO');\n        Assert::same(substr($url, 0, 1), '/');\n\n        /* clear the PATH_INFO option, so that a script can detect whether it is called with anything following the\n         *'.php'-ending.\n         */\n        unset($_SERVER['PATH_INFO']);\n\n        $modEnd = strpos($url, '/', 1);\n        if ($modEnd === false) {\n            $modEnd = strlen($url);\n            $module = substr($url, 1);\n            $url = '';\n        } else {\n            $module = substr($url, 1, $modEnd - 1);\n            $url = substr($url, $modEnd + 1);\n        }\n\n        if (!self::isModuleEnabled($module)) {\n            throw new Error\\NotFound('The module \\'' . $module . '\\' was either not found, or wasn\\'t enabled.');\n        }\n\n        /* Make sure that the request isn't suspicious (contains references to current directory or parent directory or\n         * anything like that. Searching for './' in the URL will detect both '../' and './'. Searching for '\\' will\n         * detect attempts to use Windows-style paths.\n         */\n        if (strpos($url, '\\\\') !== false) {\n            throw new Error\\BadRequest('Requested URL contained a backslash.');\n        } elseif (strpos($url, './') !== false) {\n            throw new Error\\BadRequest('Requested URL contained \\'./\\'.');\n        }\n\n        $config = Configuration::getInstance();\n\n        // rebuild REQUEST_URI and SCRIPT_NAME just in case we need to.\n        // This is needed for server aliases and rewrites\n        $translated_uri = $config->getBasePath() . 'module.php/' . $module . '/' . $url;\n        $request->server->set('REQUEST_URI', $translated_uri);\n        $request->server->set('SCRIPT_NAME', $config->getBasePath() . 'module.php');\n        // strip any NULL files (form file fields with nothing selected)\n        // because initialize() will throw an error on them\n        $request_files = array_filter(\n            $request->files->all(),\n            function ($val) {\n                return !is_null($val);\n            }\n        );\n        $request->initialize(\n            $request->query->all(),\n            $request->request->all(),\n            $request->attributes->all(),\n            $request->cookies->all(),\n            $request_files,\n            $request->server->all(),\n            $request->getContent()\n        );\n\n        try {\n            $kernel = new Kernel($module);\n            $response = $kernel->handle($request);\n            $kernel->terminate($request, $response);\n\n            return $response;\n        } catch (FileLocatorFileNotFoundException $e) {\n            // no routes configured for this module, fall back to the old system\n        } catch (NotFoundHttpException $e) {\n            // this module has been migrated, but the route wasn't found\n        }\n\n        $moduleDir = self::getModuleDir($module) . '/www/';\n\n        // check for '.php/' in the path, the presence of which indicates that another php-script should handle the\n        // request\n        for ($phpPos = strpos($url, '.php/'); $phpPos !== false; $phpPos = strpos($url, '.php/', $phpPos + 1)) {\n            $newURL = substr($url, 0, $phpPos + 4);\n            $param = substr($url, $phpPos + 4);\n\n            if (is_file($moduleDir . $newURL)) {\n                /* $newPath points to a normal file. Point execution to that file, and save the remainder of the path\n                 * in PATH_INFO.\n                 */\n                $url = $newURL;\n                $request->server->set('PATH_INFO', $param);\n                $_SERVER['PATH_INFO'] = $param;\n                break;\n            }\n        }\n\n        $path = $moduleDir . $url;\n\n        if ($path[strlen($path) - 1] === '/') {\n            // path ends with a slash - directory reference. Attempt to find index file in directory\n            foreach (self::$indexFiles as $if) {\n                if (file_exists($path . $if)) {\n                    $path .= $if;\n                    break;\n                }\n            }\n        }\n\n        if (is_dir($path)) {\n            /* Path is a directory - maybe no index file was found in the previous step, or maybe the path didn't end\n             * with a slash. Either way, we don't do directory listings.\n             */\n            throw new Error\\NotFound('Directory listing not available.');\n        }\n\n        if (!file_exists($path)) {\n            // file not found\n            Logger::info('Could not find file \\'' . $path . '\\'.');\n            throw new Error\\NotFound('The URL wasn\\'t found in the module.');\n        }\n\n        if (mb_strtolower(substr($path, -4), 'UTF-8') === '.php') {\n            // PHP file - attempt to run it\n\n            /* In some environments, $_SERVER['SCRIPT_NAME'] is already set with $_SERVER['PATH_INFO']. Check for that\n             * case, and append script name only if necessary.\n             *\n             * Contributed by Travis Hegner.\n             */\n            $script = \"/$module/$url\";\n            if (strpos($request->getScriptName(), $script) === false) {\n                $request->server->set('SCRIPT_NAME', $request->getScriptName() . '/' . $module . '/' . $url);\n            }\n\n            require($path);\n            exit();\n        }\n\n        // some other file type - attempt to serve it\n\n        // find MIME type for file, based on extension\n        $contentType = null;\n        if (preg_match('#\\.([^/\\.]+)$#D', $path, $type)) {\n            $type = strtolower($type[1]);\n            if (array_key_exists($type, self::$mimeTypes)) {\n                $contentType = self::$mimeTypes[$type];\n            }\n        }\n\n        if ($contentType === null) {\n            /* We were unable to determine the MIME type from the file extension. Fall back to mime_content_type (if it\n             * exists).\n             */\n            if (function_exists('mime_content_type')) {\n                $contentType = mime_content_type($path);\n            } else {\n                // mime_content_type doesn't exist. Return a default MIME type\n                Logger::warning('Unable to determine mime content type of file: ' . $path);\n                $contentType = 'application/octet-stream';\n            }\n        }\n\n        /** @psalm-var \\SimpleSAML\\Configuration $assetConfig */\n        $assetConfig = $config->getConfigItem('assets');\n        /** @psalm-var \\SimpleSAML\\Configuration $cacheConfig */\n        $cacheConfig = $assetConfig->getConfigItem('caching');\n        $response = new BinaryFileResponse($path);\n        $response->setCache([\n            // \"public\" allows response caching even if the request was authenticated,\n            // which is exactly what we want for static resources\n            'public' => true,\n            'max_age' => strval($cacheConfig->getInteger('max_age', 86400))\n        ]);\n        $response->setAutoLastModified();\n        if ($cacheConfig->getBoolean('etag', false)) {\n            $response->setAutoEtag();\n        }\n        $response->isNotModified($request);\n        $response->headers->set('Content-Type', $contentType);\n        $response->setContentDisposition(ResponseHeaderBag::DISPOSITION_INLINE);\n        $response->prepare($request);\n        return $response;\n    }\n\n\n    /**\n     * @param string $module\n     * @param array $mod_config\n     * @return bool\n     */\n    private static function isModuleEnabledWithConf(string $module, array $mod_config): bool\n    {\n        if (isset(self::$module_info[$module]['enabled'])) {\n            return self::$module_info[$module]['enabled'];\n        }\n\n        if (!empty(self::$modules) && !in_array($module, self::$modules, true)) {\n            return false;\n        }\n\n        $moduleDir = self::getModuleDir($module);\n\n        if (!is_dir($moduleDir)) {\n            self::$module_info[$module]['enabled'] = false;\n            return false;\n        }\n\n        if (isset($mod_config[$module])) {\n            if (is_bool($mod_config[$module])) {\n                self::$module_info[$module]['enabled'] = $mod_config[$module];\n                return $mod_config[$module];\n            }\n\n            throw new \\Exception(\"Invalid module.enable value for the '$module' module.\");\n        }\n\n        $core_module =  array_key_exists($module, self::$core_modules) ? true : false;\n\n        self::$module_info[$module]['enabled'] = $core_module ? true : false;\n        return $core_module ? true : false;\n    }\n\n\n    /**\n     * Get available modules.\n     *\n     * @return string[] One string for each module.\n     *\n     * @throws \\Exception If we cannot open the module's directory.\n     */\n    public static function getModules(): array\n    {\n        if (!empty(self::$modules)) {\n            return self::$modules;\n        }\n\n        $path = self::getModuleDir('.');\n\n        $dh = scandir($path);\n        if ($dh === false) {\n            throw new \\Exception('Unable to open module directory \"' . $path . '\".');\n        }\n\n        foreach ($dh as $f) {\n            if ($f[0] === '.') {\n                continue;\n            }\n\n            if (!is_dir($path . '/' . $f)) {\n                continue;\n            }\n\n            self::$modules[] = $f;\n        }\n\n        return self::$modules;\n    }\n\n\n    /**\n     * Resolve module class.\n     *\n     * This function takes a string on the form \"<module>:<class>\" and converts it to a class\n     * name. It can also check that the given class is a subclass of a specific class. The\n     * resolved classname will be \"\\SimleSAML\\Module\\<module>\\<$type>\\<class>.\n     *\n     * It is also possible to specify a full classname instead of <module>:<class>.\n     *\n     * An exception will be thrown if the class can't be resolved.\n     *\n     * @param string      $id The string we should resolve.\n     * @param string      $type The type of the class.\n     * @param string|null $subclass The class should be a subclass of this class. Optional.\n     *\n     * @return string The classname.\n     *\n     * @throws \\Exception If the class cannot be resolved.\n     */\n    public static function resolveClass(string $id, string $type, ?string $subclass = null): string\n    {\n        $tmp = explode(':', $id, 2);\n        if (count($tmp) === 1) {\n            // no module involved\n            $className = $tmp[0];\n            if (!class_exists($className)) {\n                throw new \\Exception(\"Could not resolve '$id': no class named '$className'.\");\n            }\n        } else {\n            // should be a module\n            // make sure empty types are handled correctly\n            $type = (empty($type)) ? '\\\\' : '\\\\' . $type . '\\\\';\n\n            $className = 'SimpleSAML\\\\Module\\\\' . $tmp[0] . $type . $tmp[1];\n            if (!class_exists($className)) {\n                // check for the old-style class names\n                $type = str_replace('\\\\', '_', $type);\n                $oldClassName = 'sspmod_' . $tmp[0] . $type . $tmp[1];\n\n                if (!class_exists($oldClassName)) {\n                    throw new \\Exception(\"Could not resolve '$id': no class named '$className' or '$oldClassName'.\");\n                }\n                $className = $oldClassName;\n            }\n        }\n\n        if ($subclass !== null && !is_subclass_of($className, $subclass)) {\n            throw new \\Exception(\n                'Could not resolve \\'' . $id . '\\': The class \\'' . $className\n                . '\\' isn\\'t a subclass of \\'' . $subclass . '\\'.'\n            );\n        }\n\n        return $className;\n    }\n\n\n    /**\n     * Get absolute URL to a specified module resource.\n     *\n     * This function creates an absolute URL to a resource stored under \".../modules/<module>/www/\".\n     *\n     * @param string $resource Resource path, on the form \"<module name>/<resource>\"\n     * @param array  $parameters Extra parameters which should be added to the URL. Optional.\n     *\n     * @return string The absolute URL to the given resource.\n     */\n    public static function getModuleURL(string $resource, array $parameters = []): string\n    {\n        Assert::notSame($resource[0], '/');\n\n        $url = Utils\\HTTP::getBaseURL() . 'module.php/' . $resource;\n        if (!empty($parameters)) {\n            $url = Utils\\HTTP::addURLParameters($url, $parameters);\n        }\n        return $url;\n    }\n\n\n    /**\n     * Get the available hooks for a given module.\n     *\n     * @param string $module The module where we should look for hooks.\n     *\n     * @return array An array with the hooks available for this module. Each element is an array with two keys: 'file'\n     * points to the file that contains the hook, and 'func' contains the name of the function implementing that hook.\n     * When there are no hooks defined, an empty array is returned.\n     */\n    public static function getModuleHooks(string $module): array\n    {\n        if (isset(self::$modules[$module]['hooks'])) {\n            return self::$modules[$module]['hooks'];\n        }\n\n        $hook_dir = self::getModuleDir($module) . '/hooks';\n        if (!is_dir($hook_dir)) {\n            return [];\n        }\n\n        $hooks = [];\n        $files = scandir($hook_dir);\n        foreach ($files as $file) {\n            if ($file[0] === '.') {\n                continue;\n            }\n\n            if (!preg_match('/hook_(\\w+)\\.php/', $file, $matches)) {\n                continue;\n            }\n            $hook_name = $matches[1];\n            $hook_func = $module . '_hook_' . $hook_name;\n            $hooks[$hook_name] = ['file' => $hook_dir . '/' . $file, 'func' => $hook_func];\n        }\n        return $hooks;\n    }\n\n\n    /**\n     * Call a hook in all enabled modules.\n     *\n     * This function iterates over all enabled modules and calls a hook in each module.\n     *\n     * @param string $hook The name of the hook.\n     * @param mixed  &$data The data which should be passed to each hook. Will be passed as a reference.\n     * @return void\n     *\n     * @throws \\SimpleSAML\\Error\\Exception If an invalid hook is found in a module.\n     */\n    public static function callHooks(string $hook, &$data = null): void\n    {\n        $modules = self::getModules();\n        $config = Configuration::getOptionalConfig()->getArray('module.enable', []);\n        sort($modules);\n        foreach ($modules as $module) {\n            if (!self::isModuleEnabledWithConf($module, $config)) {\n                continue;\n            }\n\n            if (!isset(self::$module_info[$module]['hooks'])) {\n                self::$module_info[$module]['hooks'] = self::getModuleHooks($module);\n            }\n\n            if (\n                !isset(self::$module_info[$module]['hooks'][$hook])\n                || empty(self::$module_info[$module]['hooks'][$hook])\n            ) {\n                continue;\n            }\n\n            require_once(self::$module_info[$module]['hooks'][$hook]['file']);\n\n            if (!is_callable(self::$module_info[$module]['hooks'][$hook]['func'])) {\n                throw new Error\\Exception('Invalid hook \\'' . $hook . '\\' for module \\'' . $module . '\\'.');\n            }\n\n            $fn = self::$module_info[$module]['hooks'][$hook]['func'];\n            $fn($data);\n        }\n    }\n\n\n    /**\n     * Handle a valid request for a module that lacks a trailing slash.\n     *\n     * This method add the trailing slash and redirects to the resulting URL.\n     *\n     * @param Request $request The request to process by this controller method.\n     *\n     * @return RedirectResponse A redirection to the URI specified in the request, but with a trailing slash.\n     */\n    public static function addTrailingSlash(Request $request): RedirectResponse\n    {\n        // Must be of form /{module} - append a slash\n        return new RedirectResponse($request->getRequestUri() . '/', 308);\n    }\n\n\n    /**\n     * Handle a valid request that ends with a trailing slash.\n     *\n     * This method removes the trailing slash and redirects to the resulting URL.\n     *\n     * @param \\Symfony\\Component\\HttpFoundation\\Request $request The request to process by this controller method.\n     *\n     * @return \\Symfony\\Component\\HttpFoundation\\RedirectResponse\n     *   A redirection to the URI specified in the request, but without the trailing slash.\n     */\n    public static function removeTrailingSlash(Request $request): RedirectResponse\n    {\n        $pathInfo = $request->server->get('PATH_INFO');\n        $url = str_replace($pathInfo, rtrim($pathInfo, ' /'), $request->getRequestUri());\n        return new RedirectResponse($url, 308);\n    }\n}\n"], "filenames": ["lib/SimpleSAML/Module.php"], "buggy_code_start_loc": [262], "buggy_code_end_loc": [263], "fixing_code_start_loc": [262], "fixing_code_end_loc": [263], "type": "CWE-178", "message": "SimpleSAMLphp versions before 1.18.6 contain an information disclosure vulnerability. The module controller in `SimpleSAML\\Module` that processes requests for pages hosted by modules, has code to identify paths ending with `.php` and process those as PHP code. If no other suitable way of handling the given path exists it presents the file to the browser. The check to identify paths ending with `.php` does not account for uppercase letters. If someone requests a path ending with e.g. `.PHP` and the server is serving the code from a case-insensitive file system, such as on Windows, the processing of the PHP code does not occur, and the source code is instead presented to the browser. An attacker may use this issue to gain access to the source code in third-party modules that is meant to be private, or even sensitive. However, the attack surface is considered small, as the attack will only work when SimpleSAMLphp serves such content from a file system that is not case-sensitive, such as on Windows. This issue is fixed in version 1.18.6.", "other": {"cve": {"id": "CVE-2020-5301", "sourceIdentifier": "security-advisories@github.com", "published": "2020-04-21T20:15:13.260", "lastModified": "2021-09-14T13:44:27.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SimpleSAMLphp versions before 1.18.6 contain an information disclosure vulnerability. The module controller in `SimpleSAML\\Module` that processes requests for pages hosted by modules, has code to identify paths ending with `.php` and process those as PHP code. If no other suitable way of handling the given path exists it presents the file to the browser. The check to identify paths ending with `.php` does not account for uppercase letters. If someone requests a path ending with e.g. `.PHP` and the server is serving the code from a case-insensitive file system, such as on Windows, the processing of the PHP code does not occur, and the source code is instead presented to the browser. An attacker may use this issue to gain access to the source code in third-party modules that is meant to be private, or even sensitive. However, the attack surface is considered small, as the attack will only work when SimpleSAMLphp serves such content from a file system that is not case-sensitive, such as on Windows. This issue is fixed in version 1.18.6."}, {"lang": "es", "value": "Las versiones SimpleSAMLphp en versiones anteriores a la 1.18.6 contienen una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n. El controlador de m\u00f3dulos en `SimpleSAML\\Module` que procesa las peticiones de p\u00e1ginas alojadas por m\u00f3dulos, tiene c\u00f3digo para identificar las rutas que terminan en `.php` y procesarlas como c\u00f3digo PHP. Si no existe otra forma adecuada de manejar la ruta dada, presenta el archivo al navegador. La comprobaci\u00f3n para identificar los caminos que terminan en `.php` no tiene en cuenta las may\u00fasculas. Si alguien solicita un camino que termina por ejemplo con `.PHP` y el servidor est\u00e1 sirviendo el c\u00f3digo de un sistema de archivos que no distingue entre may\u00fasculas y min\u00fasculas, como en Windows, el procesamiento del c\u00f3digo PHP no ocurre, y el c\u00f3digo fuente se presenta en su lugar al navegador. Un atacante puede utilizar este problema para obtener acceso al c\u00f3digo fuente en m\u00f3dulos de terceros que se supone que son privados, o incluso sensibles. Sin embargo, se considera que la superficie de ataque es peque\u00f1a, ya que el ataque s\u00f3lo funcionar\u00e1 cuando SimpleSAMLphp sirva ese contenido desde un sistema de archivos que no distinga entre may\u00fasculas y min\u00fasculas, como en Windows. Este problema est\u00e1 corregido en la versi\u00f3n 1.18.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.0, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-178"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:simplesamlphp:simplesamlphp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.18.6", "matchCriteriaId": "AD186CF9-4548-455F-8A4C-F4D8FD572416"}]}]}], "references": [{"url": "https://github.com/simplesamlphp/simplesamlphp/commit/47968d26a2fd3ed52da70dc09210921d612ce44e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/simplesamlphp/simplesamlphp/security/advisories/GHSA-24m3-w8g9-jwpq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/simplesamlphp/simplesamlphp/commit/47968d26a2fd3ed52da70dc09210921d612ce44e"}}