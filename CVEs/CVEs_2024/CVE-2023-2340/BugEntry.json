{"buggy_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request)\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType = null)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, Config $config, $isDelete = false)\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = $savedGridConfig->getName();\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = $savedGridConfig->getDescription();\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n\n                foreach($gridConfig['columns'] as &$column) {\n                    if (array_key_exists('isOperator', $column) && $column['isOperator']) {\n                        $colAttributes = &$column['fieldConfig']['attributes'];\n                        SecurityHelper::convertHtmlSpecialCharsArrayKeys($colAttributes, ['label', 'attribute', 'param1']);\n                    }\n                }\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                $class,\n                $gridType,\n                $request->get('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, $sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = explode(',', $frontendLanguages)[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'sqlFilter' => $gridConfig['sqlFilter'] ?? '',\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n        ];\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param DataObject\\ClassDefinition|null $class\n     * @param string $gridType\n     * @param bool $noBrickColumns\n     * @param DataObject\\ClassDefinition\\Data[] $fields\n     * @param array $context\n     * @param int $objectId\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $class, $gridType, $noBrickColumns, $fields, $context, $objectId, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields($field, $brickFields, &$availableFields, $gridType, &$count, $brickType, $class, $objectId, $context = null)\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, $count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     */\n    protected function getCalculatedColumnConfig($config)\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useSession(function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and type != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName($metadata['gridConfigName']);\n                    $gridConfig->setDescription($metadata['gridConfigDescription']);\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = $gridConfig->getName();\n                $settings['gridConfigDescription'] = $gridConfig->getDescription();\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata, $objectId)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                (int) $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $gridType, $position, $force = false, $keyPrefix = null, $class = null, $objectId = null)\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request)\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        File::put($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        File::put($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    private function getDataPreview($originalFile, $dialect)\n    {\n        $count = 0;\n        $data = [];\n        if (($handle = fopen($originalFile, 'r')) !== false) {\n            while (($rowData = fgetcsv($handle, 0, $dialect->delimiter, $dialect->quotechar, $dialect->escapechar)) !== false) {\n                $tmpData = [];\n\n                foreach ($rowData as $key => $value) {\n                    $tmpData['field_' . $key] = $value;\n                }\n\n                $tmpData['rowId'] = $count + 1;\n                $data[] = $tmpData;\n\n                $count++;\n\n                /**\n                 * Reached the number or rows for the preview\n                 */\n                if ($count > 18) {\n                    break;\n                }\n            }\n            fclose($handle);\n        }\n\n        return $data;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher)\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService, EventDispatcherInterface $eventDispatcher)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? null;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\Exception('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var \\Pimcore\\Model\\DataObject\\Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('o_id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(o_id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n        }\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        if (is_array($contextFromRequest)) {\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData($requestedLanguage, $localeService, $list, $fields, $addTitles, $context);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        $lineCount = count($csv);\n\n        if (!$addTitles && $lineCount > 0) {\n            fwrite($temp, \"\\r\\n\");\n        }\n\n        for ($i = 0; $i < $lineCount; $i++) {\n            $line = $csv[$i];\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line);\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n            }\n            if ($i < $lineCount - 1) {\n                fwrite($temp, \"\\r\\n\");\n            }\n        }\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData($object)\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request)\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n                        $brick->$valueSetter($newData);\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request)\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions($fds, &$firstOne, &$commonFields)\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\n\npimcore.registerNS(\"pimcore.element.helpers.gridColumnConfig\");\npimcore.element.helpers.gridColumnConfig = {\n\n    batchJobDelay: 50,\n\n    getSaveAsDialog: function () {\n        var defaultName = new Date();\n\n        var nameField = new Ext.form.TextField({\n            fieldLabel: t('name'),\n            length: 50,\n            allowBlank: false,\n            value: this.settings.gridConfigName ? this.settings.gridConfigName : defaultName\n        });\n\n        var descriptionField = new Ext.form.TextArea({\n            fieldLabel: t('description'),\n            // height: 200,\n            value: this.settings.gridConfigDescription\n        });\n\n        var configPanel = new Ext.Panel({\n            layout: \"form\",\n            bodyStyle: \"padding: 10px;\",\n            items: [nameField, descriptionField],\n            buttons: [{\n                text: t(\"save\"),\n                iconCls: \"pimcore_icon_apply\",\n                handler: function () {\n                    this.settings.gridConfigId = null;\n                    this.settings.gridConfigName = nameField.getValue();\n                    this.settings.gridConfigDescription = descriptionField.getValue();\n\n                    pimcore.helpers.saveColumnConfig(this.object.id, this.classId, this.getGridConfig(), this.searchType, this.saveColumnConfigButton,\n                        this.columnConfigurationSavedHandler.bind(this), this.settings, this.gridType);\n                    this.saveWindow.close();\n                }.bind(this)\n            }]\n        });\n\n        this.saveWindow = new Ext.Window({\n            width: 600,\n            height: 300,\n            modal: true,\n            title: t('save_as_copy'),\n            layout: \"fit\",\n            items: [configPanel]\n        });\n\n        this.saveWindow.show();\n        nameField.focus();\n        nameField.selectText();\n        return this.window;\n    },\n\n    deleteGridConfig: function () {\n\n        Ext.MessageBox.show({\n            title: t('delete'),\n            msg: t('delete_message'),\n            buttons: Ext.Msg.OKCANCEL,\n            icon: Ext.MessageBox.INFO,\n            fn: this.deleteGridConfigConfirmed.bind(this)\n        });\n    },\n\n    deleteGridConfigConfirmed: function (btn) {\n        var route = null;\n\n        if (this.gridType === 'asset') {\n            route = 'pimcore_admin_asset_assethelper_griddeletecolumnconfig';\n        }\n        else if(this.gridType === 'object') {\n            route = 'pimcore_admin_dataobject_dataobjecthelper_griddeletecolumnconfig';\n        }\n        else {\n            throw new Error('Type unknown');\n        }\n\n        if (btn === 'ok') {\n            Ext.Ajax.request({\n                url: Routing.generate(route),\n                method: \"DELETE\",\n                params: {\n                    id: this.classId,\n                    objectId:\n                    this.object.id,\n                    gridtype: \"grid\",\n                    gridConfigId: this.settings.gridConfigId,\n                    searchType: this.searchType\n                },\n                success: function (response) {\n\n                    decodedResponse = Ext.decode(response.responseText);\n                    if (!decodedResponse.deleteSuccess) {\n                        pimcore.helpers.showNotification(t(\"error\"), t(\"error_deleting_item\"), \"error\");\n                    }\n\n                    this.createGrid(false, response);\n                }.bind(this)\n            });\n        }\n    },\n\n    switchToGridConfig: function (menuItem) {\n        var gridConfig = menuItem.gridConfig;\n        this.settings.gridConfigId = gridConfig.id;\n        this.getTableDescription();\n    },\n\n    addGridConfigMenuItems: function(menu, list, onlyConfigs) {\n        for (var i = 0; i < list.length; i++) {\n            var disabled = false;\n            var config = list[i];\n            var text = config[\"name\"];\n            if (config.id == this.settings.gridConfigId) {\n                text = this.settings.gridConfigName;\n                if (!onlyConfigs) {\n                    text = \"<b>\" + text + \"</b>\";\n                    disabled = true;\n                }\n            }\n            var menuConfig = {\n                text: text,\n                disabled: disabled,\n                iconCls: 'pimcore_icon_gridcolumnconfig',\n                gridConfig: config,\n                handler: this.switchToGridConfig.bind(this)\n            };\n            menu.add(menuConfig);\n        }\n    },\n\n    buildColumnConfigMenu: function (onlyConfigs) {\n        var menu = this.columnConfigButton.getMenu();\n        menu.removeAll();\n\n        if (!onlyConfigs) {\n            menu.add({\n                text: t('save_as_copy'),\n                iconCls: \"pimcore_icon_save\",\n                handler: this.saveConfig.bind(this, true)\n            });\n\n            menu.add({\n                text: t('set_as_favourite'),\n                iconCls: \"pimcore_icon_favourite\",\n                handler: function () {\n                    pimcore.helpers.markColumnConfigAsFavourite(this.object.id, this.classId, this.settings.gridConfigId, this.searchType, true, this.gridType);\n                }.bind(this)\n            });\n\n            menu.add({\n                text: t('delete'),\n                iconCls: \"pimcore_icon_delete\",\n                disabled: !this.settings.gridConfigId || this.settings.isShared,\n                handler: this.deleteGridConfig.bind(this)\n            });\n\n            menu.add('-');\n        }\n\n        var disabled = false;\n        var text = t('predefined');\n        if (!this.settings.gridConfigId && !onlyConfigs) {\n            text = \"<b>\" + text + \"</b>\";\n            disabled = true;\n\n        }\n\n        menu.add({\n            text: text,\n            iconCls: \"pimcore_icon_gridcolumnconfig\",\n            disabled: disabled,\n            gridConfig: {\n                id: 0\n            },\n            handler: this.switchToGridConfig.bind(this)\n        });\n\n        if (this.availableConfigs && this.availableConfigs.length > 0) {\n            this.addGridConfigMenuItems(menu, this.availableConfigs, onlyConfigs);\n        }\n\n        if (this.sharedConfigs && this.sharedConfigs.length > 0) {\n            menu.add('-');\n            this.addGridConfigMenuItems(menu, this.sharedConfigs, onlyConfigs);\n        }\n    },\n\n    saveConfig: function (asCopy, context) {\n        if (asCopy) {\n            this.getSaveAsDialog();\n        } else {\n            pimcore.helpers.saveColumnConfig(this.object.id, this.classId, this.getGridConfig(), this.searchType, this.saveColumnConfigButton,\n                this.columnConfigurationSavedHandler.bind(this), this.settings, this.gridType, this.context);\n        }\n    },\n\n    filterUpdateFunction: function (grid, toolbarFilterInfo, clearFilterButton) {\n        var filterStringConfig = [];\n        var filterData = grid.getStore().getFilters().items;\n\n        // reset\n        toolbarFilterInfo.setTooltip(\" \");\n\n        if (filterData.length > 0) {\n\n            for (var i = 0; i < filterData.length; i++) {\n\n                var operator = filterData[i].getOperator();\n                if (operator == 'lt') {\n                    operator = \"&lt;\";\n                } else if (operator == 'gt') {\n                    operator = \"&gt;\";\n                } else if (operator == 'eq') {\n                    operator = \"=\";\n                }\n\n                var value = filterData[i].getValue();\n\n                if (value instanceof Date) {\n                    value = Ext.Date.format(value, \"Y-m-d\");\n                }\n\n                if (value && typeof value == \"object\") {\n                    filterStringConfig.push(filterData[i].getProperty() + \" \" + operator + \" (\"\n                        + value.join(\" OR \") + \")\");\n                } else {\n                    filterStringConfig.push(filterData[i].getProperty() + \" \" + operator + \" \" + value);\n                }\n            }\n\n            var filterCondition = filterStringConfig.join(\" AND \") + \"</b>\";\n            toolbarFilterInfo.setTooltip(\"<b>\" + t(\"filter_condition\") + \": \" + filterCondition);\n            toolbarFilterInfo.pimcore_filter_condition = filterCondition;\n            toolbarFilterInfo.setHidden(false);\n        }\n        toolbarFilterInfo.setHidden(filterData.length == 0);\n        clearFilterButton.setHidden(!toolbarFilterInfo.isVisible());\n    },\n\n    updateGridHeaderContextMenu: function (grid) {\n        var columnConfig = new Ext.menu.Item({\n            text: t(\"grid_options\"),\n            iconCls: \"pimcore_icon_table_col pimcore_icon_overlay_edit\",\n            handler: this.openColumnConfig.bind(this)\n        });\n        var menu = grid.headerCt.getMenu();\n        menu.add(columnConfig);\n        //\n\n        var batchAllMenu = new Ext.menu.Item({\n            text: t(\"batch_change\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, false, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAllMenu);\n\n        var batchSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_change_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, false, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchSelectedMenu);\n\n        var batchAppendAllMenu = new Ext.menu.Item({\n            text: t(\"batch_append_all\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, true, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAppendAllMenu);\n\n        var batchAppendSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_append_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, true, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAppendSelectedMenu);\n\n\n        var batchRemoveAllMenu = new Ext.menu.Item({\n            text: t(\"batch_remove_all\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, false, true);\n            }.bind(this, grid)\n        });\n        menu.add(batchRemoveAllMenu);\n\n        var batchRemoveSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_remove_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, false, true);\n            }.bind(this, grid)\n        });\n        menu.add(batchRemoveSelectedMenu);\n\n        var filterByRelationMenu = new Ext.menu.Item({\n            text: t(\"filter_by_relation\"),\n            iconCls: \"pimcore_icon_filter pimcore_icon_overlay_add\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.filterPrepare(column);\n            }.bind(this, grid)\n        });\n        menu.add(filterByRelationMenu);\n\n        //\n        menu.on('beforeshow', function (batchAllMenu, batchSelectedMenu, grid) {\n            var menu = grid.headerCt.getMenu();\n            var columnDataIndex = menu.activeHeader.dataIndex;\n\n            if (menu.activeHeader.config && typeof menu.activeHeader.config.getRelationFilter === \"function\") {\n                filterByRelationMenu.show();\n            } else {\n                filterByRelationMenu.hide();\n            }\n\n            // no batch for system properties\n            if (Ext.Array.contains(this.systemColumns, columnDataIndex) || Ext.Array.contains(this.noBatchColumns, columnDataIndex)) {\n                batchAllMenu.hide();\n                batchSelectedMenu.hide();\n            } else {\n                batchAllMenu.show();\n                batchSelectedMenu.show();\n            }\n\n            if (!Ext.Array.contains(this.systemColumns, columnDataIndex) && Ext.Array.contains(this.batchAppendColumns ? this.batchAppendColumns : [], columnDataIndex)) {\n                batchAppendAllMenu.show();\n                batchAppendSelectedMenu.show();\n            } else {\n                batchAppendAllMenu.hide();\n                batchAppendSelectedMenu.hide();\n            }\n\n            if (!Ext.Array.contains(this.systemColumns,columnDataIndex) && Ext.Array.contains(this.batchRemoveColumns ? this.batchRemoveColumns : [], columnDataIndex)) {\n                batchRemoveAllMenu.show();\n                batchRemoveSelectedMenu.show();\n            } else {\n                batchRemoveAllMenu.hide();\n                batchRemoveSelectedMenu.hide();\n            }\n        }.bind(this, batchAllMenu, batchSelectedMenu, grid));\n    },\n\n    filterPrepare: function (column) {\n        var dataIndexName = column.dataIndex\n        var gridColumns = this.grid.getColumns();\n        var columnIndex = -1;\n        for (let i = 0; i < gridColumns.length; i++) {\n            let dataIndex = gridColumns[i].dataIndex;\n            if (dataIndex == dataIndexName) {\n                columnIndex = i;\n                break;\n            }\n        }\n        if (columnIndex < 0) {\n            return;\n        }\n\n        if (this.systemColumns.indexOf(gridColumns[columnIndex].dataIndex) > -1) {\n            return;\n        }\n\n        var fieldInfo = this.grid.getColumns()[columnIndex].config;\n\n        if((this.objecttype === \"object\") || (this.objecttype === \"variant\")) {\n            if (!fieldInfo.layout || !fieldInfo.layout.layout) {\n                return;\n            }\n\n            var tagType = fieldInfo.layout.type;\n            var editor = new pimcore.object.tags[tagType](null, fieldInfo.layout.layout);\n            editor.setObject(this.object);\n        }\n\n        editor.updateContext({\n            containerType: \"filterByRelationWindow\"\n        });\n\n        var formPanel = Ext.create('Ext.form.Panel', {\n            xtype: \"form\",\n            border: false,\n            items: [editor.getLayoutEdit()],\n            bodyStyle: \"padding: 10px;\",\n            buttons: [\n                {\n                    text: t(\"clear_relation_filter\"),\n                    iconCls: \"pimcore_icon_filter_condition pimcore_icon_overlay_delete\",\n                    handler: function () {\n                        this.filterByRelationWindow.close();\n                        this.grid.store.filters.removeByKey(\"x-gridfilter-\"+fieldInfo.dataIndex);\n                    }.bind(this)\n                },\n                {\n                    text: t(\"apply_filter\"),\n                    iconCls: \"pimcore_icon_filter pimcore_icon_overlay_add\",\n                    handler: function () {\n                        if (formPanel.isValid() && typeof fieldInfo.getRelationFilter === \"function\") {\n                            this.grid.filters.getStore().addFilter(\n                                fieldInfo.getRelationFilter(fieldInfo.dataIndex, editor)\n                            );\n                            this.filterByRelationWindow.close();\n                        }\n                    }.bind(this)\n                }\n            ]\n        });\n\n        var title = t(\"filter_by_relation_field\") + \" \" + fieldInfo.text;\n        this.filterByRelationWindow = new Ext.Window({\n            autoScroll: true,\n            modal: false,\n            title: title,\n            items: [formPanel],\n            bodyStyle: \"background: #fff;\",\n            width: 700,\n            maxHeight: 650\n        });\n        this.filterByRelationWindow.show();\n        this.filterByRelationWindow.updateLayout();\n    },\n\n    batchPrepare: function (column, onlySelected, append, remove) {\n        var dataIndexName = column.dataIndex\n        var gridColumns = this.grid.getColumns();\n        var columnIndex = -1;\n        for (let i = 0; i < gridColumns.length; i++) {\n            let dataIndex = gridColumns[i].dataIndex;\n            if (dataIndex == dataIndexName) {\n                columnIndex = i;\n                break;\n            }\n        }\n        if (columnIndex < 0) {\n            return;\n        }\n\n        // no batch for system properties\n\n        if (this.systemColumns.indexOf(gridColumns[columnIndex].dataIndex) > -1) {\n            return;\n        }\n\n        var jobs = [];\n        if (onlySelected) {\n            var selectedRows = this.grid.getSelectionModel().getSelection();\n            for (var i = 0; i < selectedRows.length; i++) {\n                jobs.push(selectedRows[i].get(\"id\"));\n            }\n            this.batchOpen(columnIndex, jobs, append, remove, onlySelected);\n\n        } else {\n            let params = this.getGridParams(onlySelected);\n            Ext.Ajax.request({\n                url: this.batchPrepareUrl,\n                params: params,\n                success: function (columnIndex, response) {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata.success && rdata.jobs) {\n                        this.batchOpen(columnIndex, rdata.jobs, append, remove, onlySelected);\n                    }\n\n                }.bind(this, columnIndex)\n            });\n        }\n\n    },\n\n    batchOpen: function (columnIndex, jobs, append, remove, onlySelected) {\n\n        columnIndex = columnIndex - 1;\n\n        var fieldInfo = this.grid.getColumns()[columnIndex + 1].config;\n\n        // HACK: typemapping for published (systemfields) because they have no edit masks, so we use them from the\n        // data-types\n        if (fieldInfo.dataIndex == \"published\") {\n            fieldInfo.layout = {\n                layout: {\n                    title: t(\"published\"),\n                    name: \"published\",\n                    hideEmptyButton: true\n                },\n                type: \"checkbox\"\n            };\n        }\n        // HACK END\n\n        if((this.objecttype === \"object\") || (this.objecttype === \"variant\")) {\n            if (!fieldInfo.layout || !fieldInfo.layout.layout) {\n                return;\n            }\n\n            if (fieldInfo.layout.layout.noteditable) {\n                Ext.MessageBox.alert(t('error'), t('this_element_cannot_be_edited'));\n                return;\n            }\n\n            var tagType = fieldInfo.layout.type;\n            var editor = new pimcore.object.tags[tagType](null, fieldInfo.layout.layout);\n            editor.setObject(this.object);\n        } else {\n            var tagType = this.fieldObject[fieldInfo.dataIndex].layout.fieldtype;\n            let layoutInfo = this.fieldObject[fieldInfo.dataIndex].layout\n            try {\n                if (typeof pimcore.asset.metadata.tags[tagType].prototype.prepareBatchEditLayout == \"function\") {\n                    layoutInfo = pimcore.asset.metadata.tags[tagType].prototype.prepareBatchEditLayout(layoutInfo);\n                }\n            } catch (e) {\n                console.log(e);\n            }\n\n            var editor = new pimcore.asset.metadata.tags[tagType](null, layoutInfo);\n            editor.setAsset(this.asset);\n        }\n\n        editor.updateContext({\n            containerType: \"batch\"\n        });\n\n        var formPanel = Ext.create('Ext.form.Panel', {\n            xtype: \"form\",\n            border: false,\n            items: [editor.getLayoutEdit()],\n            bodyStyle: \"padding: 10px;\",\n            buttons: [\n                {\n                    text: t(\"save\"),\n                    handler: function () {\n                        if (formPanel.isValid()) {\n                            this.batchProcess(jobs, append, remove, editor, fieldInfo, true);\n                        }\n                    }.bind(this)\n                }\n            ]\n        });\n        var batchTitle = onlySelected ? \"batch_edit_field_selected\" : \"batch_edit_field\";\n        var appendTitle = onlySelected ? \"batch_append_selected_to\" : \"batch_append_to\";\n        var removeTitle = onlySelected ? \"batch_remove_selected_from\" : \"batch_remove_from\";\n        var title = remove ? t(removeTitle) + \" \" + fieldInfo.text : (append ? t(appendTitle) + \" \" + fieldInfo.text : t(batchTitle) + \" \" + fieldInfo.text);\n        this.batchWin = new Ext.Window({\n            autoScroll: true,\n            modal: false,\n            title: title,\n            items: [formPanel],\n            bodyStyle: \"background: #fff;\",\n            width: 700,\n            maxHeight: 600\n        });\n        this.batchWin.show();\n        this.batchWin.updateLayout();\n    },\n\n    batchProcess: function (jobs, append,  remove, editor, fieldInfo, initial) {\n        if (initial) {\n            this.batchErrors = [];\n            this.batchJobCurrent = 0;\n\n            var newValue = editor.getValue();\n\n            var valueType = \"primitive\";\n            if (newValue && typeof newValue == \"object\") {\n                newValue = Ext.encode(newValue);\n                valueType = \"object\";\n            }\n\n            this.batchParameters = {\n                name: fieldInfo.dataIndex,\n                value: newValue,\n                valueType: valueType,\n                language: this.gridLanguage\n            };\n\n\n            this.batchWin.close();\n\n            this.batchProgressBar = new Ext.ProgressBar({\n                text: t('initializing'),\n                style: \"margin: 10px;\",\n                width: 500\n            });\n\n            this.batchProgressWin = new Ext.Window({\n                title: t('batch_operation'),\n                items: [this.batchProgressBar],\n                layout: 'fit',\n                width: 400,\n                bodyStyle: \"padding: 10px;\",\n                closable: false,\n                plain: true,\n                modal: true\n            });\n\n            this.batchProgressWin.show();\n\n        }\n\n        if (this.batchJobCurrent >= jobs.length) {\n            this.batchProgressWin.close();\n            this.pagingtoolbar.moveFirst();\n            try {\n                var tree = pimcore.globalmanager.get(\"layout_object_tree\").tree;\n                tree.getStore().load({\n                    node: tree.getRootNode()\n                });\n            } catch (e) {\n                console.log(e);\n            }\n\n            // error handling\n            if (this.batchErrors.length > 0) {\n                var jobErrors = [];\n                for (var i = 0; i < this.batchErrors.length; i++) {\n                    jobErrors.push(this.batchErrors[i].job + ' - ' + this.batchErrors[i].error);\n                }\n                Ext.Msg.alert(t(\"error\"), t(\"error_jobs\") + \":<br>\" + jobErrors.join(\"<br>\"));\n            }\n\n            return;\n        }\n\n        var status = (this.batchJobCurrent / jobs.length);\n        var percent = Math.ceil(status * 100);\n        this.batchProgressBar.updateProgress(status, percent + \"%\");\n\n        this.batchParameters.job = jobs[this.batchJobCurrent];\n        if (append) {\n            this.batchParameters.append = 1;\n        }\n        if (remove) {\n            this.batchParameters.remove = 1;\n        }\n\n        Ext.Ajax.request({\n            url: this.batchProcessUrl,\n            method: 'PUT',\n            params: {\n                data: Ext.encode(this.batchParameters)\n            },\n            success: function (jobs, currentJob, response) {\n\n                try {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata) {\n                        if (!rdata.success) {\n                            throw \"not successful\";\n                        }\n                    }\n                } catch (e) {\n                    this.batchErrors.push({\n                        job: currentJob,\n                        error: (typeof(rdata.message) !== \"undefined\" && rdata.message) ?\n                            rdata.message : 'Not Successful'\n                    });\n                }\n\n                window.setTimeout(function () {\n                    this.batchJobCurrent++;\n                    this.batchProcess(jobs, append, remove);\n                }.bind(this), this.batchJobDelay);\n            }.bind(this, jobs, this.batchParameters.job)\n        });\n    },\n\n    exportPrepare: function (settings, exportType) {\n        let params = this.getGridParams();\n\n        var fields = this.getGridConfig().columns;\n        var fieldKeys = Object.keys(fields);\n        params[\"fields[]\"] = fieldKeys;\n        if (this.context) {\n            params[\"context\"] = Ext.encode(this.context);\n        }\n\n        settings = Ext.encode(settings);\n        params[\"settings\"] = settings;\n        Ext.Ajax.request({\n            method: 'POST',\n            url: this.exportPrepareUrl,\n            params: params,\n            success: function (response) {\n                var rdata = Ext.decode(response.responseText);\n\n                if (rdata.success && rdata.jobs) {\n                    this.exportProcess(rdata.jobs, rdata.fileHandle, fieldKeys, true, settings, exportType);\n                }\n            }.bind(this)\n        });\n    },\n\n    exportProcess: function (jobs, fileHandle, fields, initial, settings, exportType) {\n        if (initial) {\n            this.exportErrors = [];\n            this.exportJobCurrent = 0;\n\n            this.exportParameters = {\n                fileHandle: fileHandle,\n                language: this.gridLanguage,\n                settings: settings\n            };\n            this.exportProgressBar = new Ext.ProgressBar({\n                text: t('initializing'),\n                style: \"margin: 10px;\",\n                width: 500\n            });\n\n            this.exportProgressWin = new Ext.Window({\n                title: t(\"export\"),\n                items: [this.exportProgressBar],\n                layout: 'fit',\n                width: 200,\n                bodyStyle: \"padding: 10px;\",\n                closable: false,\n                plain: true,\n                listeners: pimcore.helpers.getProgressWindowListeners()\n            });\n            this.exportProgressWin.show();\n        }\n\n        if (this.exportJobCurrent >= jobs.length) {\n            this.exportProgressWin.close();\n\n            // error handling\n            if (this.exportErrors.length > 0) {\n                var jobErrors = [];\n                for (var i = 0; i < this.exportErrors.length; i++) {\n                    jobErrors.push(this.exportErrors[i].job);\n                }\n                Ext.Msg.alert(t(\"error\"), t(\"error_jobs\") + \": \" + jobErrors.join(\",\"));\n            } else {\n                pimcore.helpers.download(exportType.getDownloadUrl(fileHandle));\n            }\n\n            return;\n        }\n\n        var status = (this.exportJobCurrent / jobs.length);\n        var percent = Math.ceil(status * 100);\n        this.exportProgressBar.updateProgress(status, percent + \"%\");\n\n        this.exportParameters['ids[]'] = jobs[this.exportJobCurrent];\n        this.exportParameters[\"fields[]\"] = fields;\n        this.exportParameters.classId = this.classId;\n        this.exportParameters.initial = initial ? 1 : 0;\n        this.exportParameters.language = this.gridLanguage;\n        this.exportParameters.context = Ext.encode(this.context);\n\n        Ext.Ajax.request({\n            url: this.exportProcessUrl,\n            method: 'POST',\n            params: this.exportParameters,\n            success: function (jobs, currentJob, response) {\n\n                try {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata) {\n                        if (!rdata.success) {\n                            throw \"not successful\";\n                        }\n                    }\n                } catch (e) {\n                    this.exportErrors.push({\n                        job: currentJob\n                    });\n                }\n\n                window.setTimeout(function () {\n                    this.exportJobCurrent++;\n                    this.exportProcess(jobs, fileHandle, fields, false, settings, exportType);\n                }.bind(this), this.batchJobDelay);\n            }.bind(this, jobs, jobs[this.exportJobCurrent])\n        });\n    },\n\n    columnConfigurationSavedHandler: function (rdata) {\n        this.settings = rdata.settings;\n        this.availableConfigs = rdata.availableConfigs;\n        this.buildColumnConfigMenu();\n    },\n\n    getGridParams: function (onlySelected) {\n        var filters = \"\";\n        var condition = \"\";\n        var searchQuery = this.searchField ? this.searchField.getValue() : \"\";\n\n        if (this.sqlFilter) {\n            condition = this.sqlEditor.getValue();\n        } else {\n            var filterData = this.store.getFilters().items;\n            if (filterData.length > 0) {\n                filters = this.store.getProxy().encodeFilters(filterData);\n            }\n        }\n\n        var params = {\n            filter: filters,\n            condition: condition,\n            classId: this.classId,\n            folderId: this.element.id,\n            objecttype: this.objecttype,\n            language: this.gridLanguage,\n            batch: true, // to avoid limit for export\n        };\n\n        if (searchQuery) {\n            params[\"query\"] = searchQuery;\n        }\n\n        if (onlySelected !== false) {\n            //create the ids array which contains chosen rows to export\n            ids = [];\n            var selectedRows = this.grid.getSelectionModel().getSelection();\n            for (var i = 0; i < selectedRows.length; i++) {\n                ids.push(selectedRows[i].data.id);\n            }\n\n            if (ids.length > 0) {\n                params[\"ids[]\"] = ids;\n            }\n        }\n\n        //tags filter\n        if(this.tagsTree) {\n            params[\"tagIds[]\"] = this.tagsTree.getCheckedTagIds();\n\n            if(this.tagsPanel) {\n                params[\"considerChildTags\"] = this.tagsPanel.considerChildTags;\n            }\n        }\n\n        //only direct children filter\n        if (this.checkboxOnlyDirectChildren) {\n            params[\"only_direct_children\"] = this.checkboxOnlyDirectChildren.getValue();\n        }\n\n        //only unreferenced filter\n        if (this.checkboxOnlyUnreferenced) {\n            params[\"only_unreferenced\"] = this.checkboxOnlyUnreferenced.getValue();\n        }\n\n        var fields = this.getGridConfig().columns;\n        var fieldKeys = Object.keys(fields);\n        params[\"fields[]\"] = fieldKeys;\n\n        return params;\n\n    }\n};\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Security;\n\nclass SecurityHelper\n{\n    public static function convertHtmlSpecialChars(?string $text): ?string\n    {\n        if(is_string($text)) {\n            return htmlspecialchars($text, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8', false);\n        }\n\n        return null;\n    }\n\n    public static function convertHtmlSpecialCharsArrayKeys(array &$array, array $keys): void\n    {\n        foreach ($keys as $key) {\n            if (array_key_exists($key, $array)) {\n                $array[$key] = self::convertHtmlSpecialChars($array[$key]);\n            }\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Bundle\\AdminBundle\\Controller\\Admin\\DataObject;\n\nuse League\\Flysystem\\FilesystemException;\nuse League\\Flysystem\\UnableToReadFile;\nuse PhpOffice\\PhpSpreadsheet\\Reader\\Csv;\nuse PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx;\nuse Pimcore\\Bundle\\AdminBundle\\Controller\\AdminController;\nuse Pimcore\\Bundle\\AdminBundle\\Helper\\GridHelperService;\nuse Pimcore\\Config;\nuse Pimcore\\Db;\nuse Pimcore\\Event\\AdminEvents;\nuse Pimcore\\File;\nuse Pimcore\\Localization\\LocaleServiceInterface;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\DataObject;\nuse Pimcore\\Model\\GridConfig;\nuse Pimcore\\Model\\GridConfigFavourite;\nuse Pimcore\\Model\\GridConfigShare;\nuse Pimcore\\Model\\User;\nuse Pimcore\\Security\\SecurityHelper;\nuse Pimcore\\Tool;\nuse Pimcore\\Tool\\Storage;\nuse Pimcore\\Version;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\nuse Symfony\\Component\\HttpFoundation\\BinaryFileResponse;\nuse Symfony\\Component\\HttpFoundation\\HeaderUtils;\nuse Symfony\\Component\\HttpFoundation\\JsonResponse;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpFoundation\\Session\\Attribute\\AttributeBagInterface;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\nuse Symfony\\Contracts\\EventDispatcher\\EventDispatcherInterface;\n\n/**\n * @Route(\"/object-helper\", name=\"pimcore_admin_dataobject_dataobjecthelper_\")\n *\n * @internal\n */\nclass DataObjectHelperController extends AdminController\n{\n    const SYSTEM_COLUMNS = ['id', 'fullpath', 'key', 'published', 'creationDate', 'modificationDate', 'filename', 'classname'];\n\n    /**\n     * @Route(\"/load-object-data\", name=\"loadobjectdata\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function loadObjectDataAction(Request $request)\n    {\n        $object = DataObject::getById((int) $request->get('id'));\n        $result = [];\n        if ($object) {\n            $result['success'] = true;\n            $fields = $request->get('fields');\n            $result['fields'] = DataObject\\Service::gridObjectData($object, $fields);\n        } else {\n            $result['success'] = false;\n        }\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param int $userId\n     * @param string $classId\n     * @param string|null $searchType\n     *\n     * @return array\n     */\n    public function getMyOwnGridColumnConfigs($userId, $classId, $searchType = null)\n    {\n        $db = Db::get();\n        $configListingConditionParts = [];\n        $configListingConditionParts[] = 'ownerId = ' . $userId;\n        $configListingConditionParts[] = 'classId = ' . $db->quote($classId);\n\n        if ($searchType) {\n            $configListingConditionParts[] = 'searchType = ' . $db->quote($searchType);\n        }\n\n        $configCondition = implode(' AND ', $configListingConditionParts);\n        $configListing = new GridConfig\\Listing();\n        $configListing->setOrderKey('name');\n        $configListing->setOrder('ASC');\n        $configListing->setCondition($configCondition);\n        $configListing = $configListing->load();\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @param User $user\n     * @param string $classId\n     * @param string $searchType\n     *\n     * @return array\n     */\n    public function getSharedGridColumnConfigs($user, $classId, $searchType = null)\n    {\n        $configListing = [];\n\n        $userIds = [$user->getId()];\n        // collect all roles\n        $userIds = array_merge($userIds, $user->getRoles());\n        $userIds = implode(',', $userIds);\n        $db = Db::get();\n\n        $query = 'select distinct c1.id from gridconfigs c1, gridconfig_shares s\n                    where (c1.searchType = ' . $db->quote($searchType) . ' and ((c1.id = s.gridConfigId and s.sharedWithUserId IN (' . $userIds . '))) and c1.classId = ' . $db->quote($classId) . ')\n                            UNION distinct select c2.id from gridconfigs c2 where shareGlobally = 1 and c2.classId = '. $db->quote($classId) . '  and c2.ownerId != ' . $db->quote($user->getId());\n\n        $ids = $db->fetchFirstColumn($query);\n\n        if ($ids) {\n            $ids = implode(',', $ids);\n            $configListing = new GridConfig\\Listing();\n            $configListing->setOrderKey('name');\n            $configListing->setOrder('ASC');\n            $configListing->setCondition('id in (' . $ids . ')');\n            $configListing = $configListing->load();\n        }\n\n        $configData = [];\n        if (is_array($configListing)) {\n            foreach ($configListing as $config) {\n                $configData[] = $config->getObjectVars();\n            }\n        }\n\n        return $configData;\n    }\n\n    /**\n     * @Route(\"/get-export-configs\", name=\"getexportconfigs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getExportConfigsAction(Request $request)\n    {\n        $classId = $request->get('classId');\n        $list = $this->getMyOwnGridColumnConfigs($this->getAdminUser()->getId(), $classId);\n        if (!is_array($list)) {\n            $list = [];\n        }\n        $list = array_merge($list, $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId));\n        $result = [];\n\n        $result[] = [\n            'id' => -1,\n            'name' => '--default--',\n        ];\n\n        if ($list) {\n            /** @var GridConfig $config */\n            foreach ($list as $config) {\n                $result[] = [\n                    'id' => $config['id'],\n                    'name' => $config['name'],\n                ];\n            }\n        }\n\n        return $this->adminJson(['success' => true, 'data' => $result]);\n    }\n\n    /**\n     * @Route(\"/grid-delete-column-config\", name=\"griddeletecolumnconfig\", methods={\"DELETE\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridDeleteColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $gridConfigId = $request->get('gridConfigId');\n        $gridConfig = GridConfig::getById($gridConfigId);\n        $success = false;\n        if ($gridConfig) {\n            if ($gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                throw new \\Exception(\"don't mess with someone elses grid config\");\n            }\n\n            $gridConfig->delete();\n            $success = true;\n        }\n\n        $newGridConfig = $this->doGetGridColumnConfig($request, $config, true);\n        $newGridConfig['deleteSuccess'] = $success;\n\n        $event = new GenericEvent($this, [\n            'data' => $newGridConfig,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'delete',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $newGridConfig = $event->getArgument('data');\n\n        return $this->adminJson($newGridConfig);\n    }\n\n    /**\n     * @Route(\"/grid-get-column-config\", name=\"gridgetcolumnconfig\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param EventDispatcherInterface $eventDispatcher\n     * @param Config $config\n     *\n     * @return JsonResponse\n     */\n    public function gridGetColumnConfigAction(Request $request, EventDispatcherInterface $eventDispatcher, Config $config)\n    {\n        $result = $this->doGetGridColumnConfig($request, $config);\n\n        $event = new GenericEvent($this, [\n            'data' => $result,\n            'request' => $request,\n            'config' => $config,\n            'context' => 'get',\n        ]);\n\n        $eventDispatcher->dispatch($event, AdminEvents::OBJECT_GRID_GET_COLUMN_CONFIG_PRE_SEND_DATA);\n        $result = $event->getArgument('data');\n\n        return $this->adminJson($result);\n    }\n\n    /**\n     * @param Request $request\n     * @param Config $config\n     * @param bool $isDelete\n     *\n     * @return array\n     */\n    public function doGetGridColumnConfig(Request $request, Config $config, $isDelete = false)\n    {\n        $class = null;\n        $fields = null;\n\n        if ($request->get('id')) {\n            $class = DataObject\\ClassDefinition::getById($request->get('id'));\n        } elseif ($request->get('name')) {\n            $class = DataObject\\ClassDefinition::getByName($request->get('name'));\n        }\n\n        $gridConfigId = null;\n        $gridType = 'search';\n        if ($request->get('gridtype')) {\n            $gridType = $request->get('gridtype');\n        }\n\n        $objectId = (int) $request->get('objectId');\n\n        if ($objectId) {\n            $fields = DataObject\\Service::getCustomGridFieldDefinitions($class->getId(), $objectId);\n        }\n\n        $context = ['purpose' => 'gridconfig'];\n        if ($class) {\n            $context['class'] = $class;\n        }\n\n        if ($objectId) {\n            $object = DataObject::getById($objectId);\n            $context['object'] = $object;\n        }\n\n        if (!$fields && $class) {\n            $fields = $class->getFieldDefinitions();\n        }\n\n        $types = [];\n        if ($request->get('types')) {\n            $types = explode(',', $request->get('types'));\n        }\n\n        $userId = $this->getAdminUser()->getId();\n\n        $requestedGridConfigId = $isDelete ? null : $request->get('gridConfigId');\n\n        // grid config\n        $gridConfig = [];\n        $searchType = $request->get('searchType');\n\n        if (strlen($requestedGridConfigId) == 0 && $class) {\n            // check if there is a favourite view\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), $objectId ?: 0, $searchType);\n            if (!$favourite && $objectId) {\n                $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId($userId, $class->getId(), 0, $searchType);\n            }\n\n            if ($favourite) {\n                $requestedGridConfigId = $favourite->getGridConfigId();\n            }\n        }\n\n        if (is_numeric($requestedGridConfigId) && $requestedGridConfigId > 0) {\n            $db = Db::get();\n            $savedGridConfig = GridConfig::getById((int) $requestedGridConfigId);\n\n            if ($savedGridConfig) {\n                $shared = false;\n                if (!$this->getAdminUser()->isAdmin()) {\n                    $userIds = [$this->getAdminUser()->getId()];\n                    if ($this->getAdminUser()->getRoles()) {\n                        $userIds = array_merge($userIds, $this->getAdminUser()->getRoles());\n                    }\n                    $userIds = implode(',', $userIds);\n                    $shared = ($savedGridConfig->getOwnerId() != $userId && $savedGridConfig->isShareGlobally()) || $db->fetchOne('select 1 from gridconfig_shares where sharedWithUserId IN ('.$userIds.') and gridConfigId = '.$savedGridConfig->getId());\n                    //                  $shared = $savedGridConfig->isShareGlobally() || GridConfigShare::getByGridConfigAndSharedWithId($savedGridConfig->getId(), $this->getUser()->getId());\n\n                    if (!$shared && $savedGridConfig->getOwnerId() != $this->getAdminUser()->getId()) {\n                        throw new \\Exception('You are neither the owner of this config nor it is shared with you');\n                    }\n                }\n\n                $gridConfigId = $savedGridConfig->getId();\n                $gridConfig = $savedGridConfig->getConfig();\n                $gridConfig = json_decode($gridConfig, true);\n                $gridConfigName = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getName());\n                $owner = $savedGridConfig->getOwnerId();\n                $ownerObject = User::getById($owner);\n                if ($ownerObject instanceof User) {\n                    $owner = $ownerObject->getName();\n                }\n                $modificationDate = $savedGridConfig->getModificationDate();\n                $gridConfigDescription = SecurityHelper::convertHtmlSpecialChars($savedGridConfig->getDescription());\n                $sharedGlobally = $savedGridConfig->isShareGlobally();\n                $setAsFavourite = $savedGridConfig->isSetAsFavourite();\n\n                foreach($gridConfig['columns'] as &$column) {\n                    if (array_key_exists('isOperator', $column) && $column['isOperator']) {\n                        $colAttributes = &$column['fieldConfig']['attributes'];\n                        SecurityHelper::convertHtmlSpecialCharsArrayKeys($colAttributes, ['label', 'attribute', 'param1']);\n                    }\n                }\n            }\n        }\n\n        $localizedFields = [];\n        $objectbrickFields = [];\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFields[] = $field;\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks) {\n                    $objectbrickFields[] = $field;\n                }\n            }\n        }\n\n        $availableFields = [];\n\n        if (empty($gridConfig)) {\n            $availableFields = $this->getDefaultGridFields(\n                $request->get('no_system_columns'),\n                $class,\n                $gridType,\n                $request->get('no_brick_columns'),\n                $fields,\n                $context,\n                $objectId,\n                $types);\n        } else {\n            $savedColumns = $gridConfig['columns'];\n            foreach ($savedColumns as $key => $sc) {\n                if (!$sc['hidden']) {\n                    if (in_array($key, self::SYSTEM_COLUMNS)) {\n                        $colConfig = [\n                            'key' => $key,\n                            'type' => 'system',\n                            'label' => $key,\n                            'locked' => $sc['locked'] ?? null,\n                            'position' => $sc['position'],\n                        ];\n                        if (isset($sc['width'])) {\n                            $colConfig['width'] = $sc['width'];\n                        }\n                        $availableFields[] = $colConfig;\n                    } else {\n                        $keyParts = explode('~', $key);\n\n                        if (substr($key, 0, 1) == '~') {\n                            // not needed for now\n                            $type = $keyParts[1];\n                            //                            $field = $keyParts[2];\n                            $groupAndKeyId = explode('-', $keyParts[3]);\n                            $keyId = (int) $groupAndKeyId[1];\n\n                            if ($type == 'classificationstore') {\n                                $keyDef = DataObject\\Classificationstore\\KeyConfig::getById($keyId);\n                                if ($keyDef) {\n                                    $keyFieldDef = json_decode($keyDef->getDefinition(), true);\n                                    if ($keyFieldDef) {\n                                        $keyFieldDef = \\Pimcore\\Model\\DataObject\\Classificationstore\\Service::getFieldDefinitionFromJson($keyFieldDef, $keyDef->getType());\n                                        $fieldConfig = $this->getFieldGridConfig($keyFieldDef, $gridType, $sc['position'], true, null, $class, $objectId);\n                                        if ($fieldConfig) {\n                                            $fieldConfig['key'] = $key;\n                                            $fieldConfig['label'] = '#' . $keyFieldDef->getTitle();\n                                            if (isset($sc['locked'])) {\n                                                $fieldConfig['locked'] = $sc['locked'];\n                                            }\n                                            $availableFields[] = $fieldConfig;\n                                        }\n                                    }\n                                }\n                            }\n                        } elseif (count($keyParts) > 1) {\n                            $brick = $keyParts[0];\n                            $brickDescriptor = null;\n\n                            if (strpos($brick, '?') !== false) {\n                                $brickDescriptor = substr($brick, 1);\n                                $brickDescriptor = json_decode($brickDescriptor, true);\n                                $keyPrefix = $brick . '~';\n                                $brick = $brickDescriptor['containerKey'];\n                            } else {\n                                $keyPrefix = $brick . '~';\n                            }\n\n                            $fieldname = $keyParts[1];\n\n                            $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brick);\n\n                            $fd = null;\n                            if ($brickClass instanceof DataObject\\Objectbrick\\Definition) {\n                                if ($brickDescriptor) {\n                                    $innerContainer = $brickDescriptor['innerContainer'] ?? 'localizedfields';\n                                    /** @var DataObject\\ClassDefinition\\Data\\Localizedfields $localizedFields */\n                                    $localizedFields = $brickClass->getFieldDefinition($innerContainer);\n                                    $fd = $localizedFields->getFieldDefinition($brickDescriptor['brickfield']);\n                                } else {\n                                    $fd = $brickClass->getFieldDefinition($fieldname);\n                                }\n                            }\n\n                            if ($fd !== null) {\n                                $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, $keyPrefix, $class, $objectId);\n                                if (!empty($fieldConfig)) {\n                                    if (isset($sc['width'])) {\n                                        $fieldConfig['width'] = $sc['width'];\n                                    }\n                                    if (isset($sc['locked'])) {\n                                        $fieldConfig['locked'] = $sc['locked'];\n                                    }\n                                    $availableFields[] = $fieldConfig;\n                                }\n                            }\n                        } else {\n                            if (DataObject\\Service::isHelperGridColumnConfig($key)) {\n                                $calculatedColumnConfig = $this->getCalculatedColumnConfig($savedColumns[$key]);\n                                if ($calculatedColumnConfig) {\n                                    $availableFields[] = $calculatedColumnConfig;\n                                }\n                            } else {\n                                $fd = $class->getFieldDefinition($key);\n                                //if not found, look for localized fields\n                                if (empty($fd)) {\n                                    foreach ($localizedFields as $lf) {\n                                        $fd = $lf->getFieldDefinition($key);\n                                        if (!empty($fd)) {\n                                            break;\n                                        }\n                                    }\n                                }\n\n                                if (!empty($fd)) {\n                                    $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $sc['position'], true, null, $class, $objectId);\n                                    if (!empty($fieldConfig)) {\n                                        if (isset($sc['width'])) {\n                                            $fieldConfig['width'] = $sc['width'];\n                                        }\n                                        if (isset($sc['locked'])) {\n                                            $fieldConfig['locked'] = $sc['locked'];\n                                        }\n                                        $availableFields[] = $fieldConfig;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        usort($availableFields, function ($a, $b) {\n            if ($a['position'] == $b['position']) {\n                return 0;\n            }\n\n            return ($a['position'] < $b['position']) ? -1 : 1;\n        });\n\n        $frontendLanguages = Tool\\Admin::reorderWebsiteLanguages(\\Pimcore\\Tool\\Admin::getCurrentUser(), $config['general']['valid_languages']);\n        if ($frontendLanguages) {\n            $language = explode(',', $frontendLanguages)[0];\n        } else {\n            $language = $request->getLocale();\n        }\n\n        if (!Tool::isValidLanguage($language)) {\n            $validLanguages = Tool::getValidLanguages();\n            $language = $validLanguages[0];\n        }\n\n        if (!empty($gridConfig) && !empty($gridConfig['language'])) {\n            $language = $gridConfig['language'];\n        }\n\n        $availableConfigs = $class ? $this->getMyOwnGridColumnConfigs($userId, $class->getId(), $searchType) : [];\n        $sharedConfigs = $class ? $this->getSharedGridColumnConfigs($this->getAdminUser(), $class->getId(), $searchType) : [];\n        $settings = $this->getShareSettings((int)$gridConfigId);\n        $settings['gridConfigId'] = (int)$gridConfigId;\n        $settings['gridConfigName'] = $gridConfigName ?? null;\n        $settings['gridConfigDescription'] = $gridConfigDescription ?? null;\n        $settings['owner'] = $owner ?? null;\n        $settings['modificationDate'] = $modificationDate ?? null;\n        $settings['shareGlobally'] = $sharedGlobally ?? null;\n        $settings['setAsFavourite'] = $setAsFavourite ?? null;\n        $settings['isShared'] = !$gridConfigId || ($shared ?? null);\n\n        $context = $gridConfig['context'] ?? null;\n        if ($context) {\n            $context = json_decode($context, true);\n        }\n\n        return [\n            'sortinfo' => $gridConfig['sortinfo'] ?? false,\n            'language' => $language,\n            'availableFields' => $availableFields,\n            'settings' => $settings,\n            'onlyDirectChildren' => $gridConfig['onlyDirectChildren'] ?? false,\n            'pageSize' => $gridConfig['pageSize'] ?? false,\n            'availableConfigs' => $availableConfigs,\n            'sharedConfigs' => $sharedConfigs,\n            'context' => $context,\n            'sqlFilter' => $gridConfig['sqlFilter'] ?? '',\n            'searchFilter' => $gridConfig['searchFilter'] ?? '',\n        ];\n    }\n\n    /**\n     * @param bool $noSystemColumns\n     * @param DataObject\\ClassDefinition|null $class\n     * @param string $gridType\n     * @param bool $noBrickColumns\n     * @param DataObject\\ClassDefinition\\Data[] $fields\n     * @param array $context\n     * @param int $objectId\n     * @param array $types\n     *\n     * @return array\n     */\n    public function getDefaultGridFields($noSystemColumns, $class, $gridType, $noBrickColumns, $fields, $context, $objectId, $types = [])\n    {\n        $count = 0;\n        $availableFields = [];\n\n        if (!$noSystemColumns && $class) {\n            $vis = $class->getPropertyVisibility();\n            foreach (self::SYSTEM_COLUMNS as $sc) {\n                $key = $sc;\n                if ($key === 'fullpath') {\n                    $key = 'path';\n                }\n\n                if (empty($types) && (!empty($vis[$gridType][$key]) || $gridType === 'all')) {\n                    $availableFields[] = [\n                        'key' => $sc,\n                        'type' => 'system',\n                        'label' => $sc,\n                        'position' => $count, ];\n                    $count++;\n                }\n            }\n        }\n\n        $includeBricks = !$noBrickColumns;\n\n        if (is_array($fields)) {\n            foreach ($fields as $key => $field) {\n                if ($field instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    foreach ($field->getFieldDefinitions($context) as $fd) {\n                        if (empty($types) || in_array($fd->getFieldType(), $types)) {\n                            $fieldConfig = $this->getFieldGridConfig($fd, $gridType, $count, false, null, $class, $objectId);\n                            if (!empty($fieldConfig)) {\n                                $availableFields[] = $fieldConfig;\n                                $count++;\n                            }\n                        }\n                    }\n                } elseif ($field instanceof DataObject\\ClassDefinition\\Data\\Objectbricks && $includeBricks) {\n                    if (in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, false, null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    } else {\n                        $allowedTypes = $field->getAllowedTypes();\n                        if (!empty($allowedTypes)) {\n                            foreach ($allowedTypes as $t) {\n                                $brickClass = DataObject\\Objectbrick\\Definition::getByKey($t);\n                                $brickFields = $brickClass->getFieldDefinitions($context);\n\n                                $this->appendBrickFields($field, $brickFields, $availableFields, $gridType, $count, $t, $class, $objectId);\n                            }\n                        }\n                    }\n                } else {\n                    if (empty($types) || in_array($field->getFieldType(), $types)) {\n                        $fieldConfig = $this->getFieldGridConfig($field, $gridType, $count, !empty($types), null, $class, $objectId);\n                        if (!empty($fieldConfig)) {\n                            $availableFields[] = $fieldConfig;\n                            $count++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return $availableFields;\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param DataObject\\ClassDefinition\\Data[] $brickFields\n     * @param array $availableFields\n     * @param string $gridType\n     * @param int $count\n     * @param string $brickType\n     * @param DataObject\\ClassDefinition $class\n     * @param int $objectId\n     * @param array|null $context\n     */\n    protected function appendBrickFields($field, $brickFields, &$availableFields, $gridType, &$count, $brickType, $class, $objectId, $context = null)\n    {\n        if (!empty($brickFields)) {\n            foreach ($brickFields as $bf) {\n                if ($bf instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $localizedFieldDefinitions = $bf->getFieldDefinitions();\n\n                    $localizedContext = [\n                        'containerKey' => $brickType,\n                        'fieldname' => $field->getName(),\n                    ];\n\n                    $this->appendBrickFields($bf, $localizedFieldDefinitions, $availableFields, $gridType, $count, $brickType, $class, $objectId, $localizedContext);\n                } else {\n                    if ($context) {\n                        $context['brickfield'] = $bf->getName();\n                        $keyPrefix = '?' . json_encode($context) . '~';\n                    } else {\n                        $keyPrefix = $brickType . '~';\n                    }\n                    $fieldConfig = $this->getFieldGridConfig($bf, $gridType, $count, false, $keyPrefix, $class, $objectId);\n                    if (!empty($fieldConfig)) {\n                        $availableFields[] = $fieldConfig;\n                        $count++;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     */\n    protected function getCalculatedColumnConfig($config)\n    {\n        try {\n            $calculatedColumnConfig = Tool\\Session::useSession(function (AttributeBagInterface $session) use ($config) {\n                //otherwise create a new one\n\n                $calculatedColumn = [];\n                // note that we have to generate a new key!\n\n                $existingKey = $config['fieldConfig']['key'];\n                $calculatedColumnConfig['key'] = $existingKey;\n                $calculatedColumnConfig['position'] = $config['position'];\n                $calculatedColumnConfig['isOperator'] = true;\n                $calculatedColumnConfig['attributes'] = $config['fieldConfig']['attributes'];\n                $calculatedColumnConfig['width'] = $config['width'];\n                $calculatedColumnConfig['locked'] = $config['locked'];\n\n                $existingColumns = $session->get('helpercolumns', []);\n\n                if (isset($existingColumns[$existingKey])) {\n                    // if the configuration is still in the session, then reuse it\n                    return $calculatedColumnConfig;\n                }\n\n                $newKey = '#' . uniqid();\n                $calculatedColumnConfig['key'] = $newKey;\n\n                // prepare a column config on the fly\n                $phpConfig = json_encode($config['fieldConfig']);\n                $phpConfig = json_decode($phpConfig);\n                $helperColumns = [];\n                $helperColumns[$newKey] = $phpConfig;\n\n                $helperColumns = array_merge($helperColumns, $existingColumns);\n                $session->set('helpercolumns', $helperColumns);\n\n                return $calculatedColumnConfig;\n            }, 'pimcore_gridconfig');\n\n            return $calculatedColumnConfig;\n        } catch (\\Exception $e) {\n            Logger::error((string) $e);\n        }\n    }\n\n    /**\n     * @Route(\"/prepare-helper-column-configs\", name=\"preparehelpercolumnconfigs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function prepareHelperColumnConfigs(Request $request)\n    {\n        $helperColumns = [];\n        $newData = [];\n        /** @var \\stdClass[] $data */\n        $data = json_decode($request->get('columns'));\n        foreach ($data as $item) {\n            if (!empty($item->isOperator)) {\n                $itemKey = '#' . uniqid();\n\n                $item->key = $itemKey;\n                $newData[] = $item;\n                $helperColumns[$itemKey] = $item;\n            } else {\n                $newData[] = $item;\n            }\n        }\n\n        Tool\\Session::useSession(function (AttributeBagInterface $session) use ($helperColumns) {\n            $existingColumns = $session->get('helpercolumns', []);\n            $helperColumns = array_merge($helperColumns, $existingColumns);\n            $session->set('helpercolumns', $helperColumns);\n        }, 'pimcore_gridconfig');\n\n        return $this->adminJson(['success' => true, 'columns' => $newData]);\n    }\n\n    /**\n     * @Route(\"/grid-config-apply-to-all\", name=\"gridconfigapplytoall\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridConfigApplyToAllAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $searchType = $request->get('searchType');\n            $user = $this->getAdminUser();\n            $db = Db::get();\n            $db->executeQuery('delete from gridconfig_favourites where '\n                . 'ownerId = ' . $user->getId()\n                . ' and classId = ' . $db->quote($classId) .\n                ' and searchType = ' . $db->quote($searchType)\n                . ' and objectId != ' . $objectId . ' and objectId != 0');\n\n            return $this->adminJson(['success' => true]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @Route(\"/grid-mark-favourite-column-config\", name=\"gridmarkfavouritecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridMarkFavouriteColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('objectId');\n        $object = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            $classId = $request->get('classId');\n            $gridConfigId = $request->get('gridConfigId');\n            $searchType = $request->get('searchType');\n            $global = $request->get('global');\n            $user = $this->getAdminUser();\n            $type = $request->get('type');\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setOwnerId($user->getId());\n            $class = DataObject\\ClassDefinition::getById($classId);\n            if (!$class) {\n                throw new \\Exception('class ' . $classId . ' does not exist anymore');\n            }\n            $favourite->setClassId($classId);\n            $favourite->setSearchType($searchType);\n            $favourite->setType($type);\n            $specializedConfigs = false;\n\n            try {\n                if ($gridConfigId != 0) {\n                    $gridConfig = GridConfig::getById($gridConfigId);\n                    $favourite->setGridConfigId($gridConfig->getId());\n                }\n                $favourite->setObjectId($objectId);\n                $favourite->save();\n\n                if ($global) {\n                    $favourite->setObjectId(0);\n                    $favourite->save();\n                }\n                $db = Db::get();\n                $count = $db->fetchOne('select * from gridconfig_favourites where '\n                    . 'ownerId = ' . $user->getId()\n                    . ' and classId = ' . $db->quote($classId).\n                    ' and searchType = ' . $db->quote($searchType)\n                    . ' and objectId != ' . $objectId . ' and objectId != 0'\n                    . ' and type != ' . $db->quote($type));\n                $specializedConfigs = $count > 0;\n            } catch (\\Exception $e) {\n                $favourite->delete();\n            }\n\n            return $this->adminJson(['success' => true, 'spezializedConfigs' => $specializedConfigs]);\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param int $gridConfigId\n     *\n     * @return array\n     */\n    protected function getShareSettings($gridConfigId)\n    {\n        $result = [\n            'sharedUserIds' => [],\n            'sharedRoleIds' => [],\n        ];\n\n        $db = Db::get();\n        $allShares = $db->fetchAllAssociative('select s.sharedWithUserId, u.type from gridconfig_shares s, users u\n                      where s.sharedWithUserId = u.id and s.gridConfigId = ' . $gridConfigId);\n\n        if ($allShares) {\n            foreach ($allShares as $share) {\n                $type = $share['type'];\n                $key = 'shared' . ucfirst($type) . 'Ids';\n                $result[$key][] = $share['sharedWithUserId'];\n            }\n        }\n\n        foreach ($result as $idx => $value) {\n            $value = $value ? implode(',', $value) : '';\n            $result[$idx] = $value;\n        }\n\n        return $result;\n    }\n\n    /**\n     * @Route(\"/grid-save-column-config\", name=\"gridsavecolumnconfig\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function gridSaveColumnConfigAction(Request $request)\n    {\n        $objectId = $request->get('id');\n        $object   = DataObject::getById($objectId);\n\n        if ($object->isAllowed('list')) {\n            try {\n                $classId = $request->get('class_id');\n                $context = $request->get('context');\n\n                $searchType = $request->get('searchType');\n\n                // grid config\n                $gridConfigData = $this->decodeJson($request->get('gridconfig'));\n                $gridConfigData['pimcore_version'] = Version::getVersion();\n                $gridConfigData['pimcore_revision'] = Version::getRevision();\n\n                $gridConfigData['context'] = $context;\n\n                unset($gridConfigData['settings']['isShared']);\n\n                $metadata = $request->get('settings');\n                $metadata = json_decode($metadata, true);\n\n                $gridConfigId = $metadata['gridConfigId'];\n                $gridConfig = GridConfig::getById($gridConfigId);\n\n                if ($gridConfig && $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin()) {\n                    throw new \\Exception(\"don't mess around with somebody elses configuration\");\n                }\n\n                $this->updateGridConfigShares($gridConfig, $metadata);\n\n                if ($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin()) {\n                    $this->updateGridConfigFavourites($gridConfig, $metadata, $objectId);\n                }\n\n                if (!$gridConfig) {\n                    $gridConfig = new GridConfig();\n                    $gridConfig->setName(date('c'));\n                    $gridConfig->setClassId($classId);\n                    $gridConfig->setSearchType($searchType);\n\n                    $gridConfig->setOwnerId($this->getAdminUser()->getId());\n                }\n\n                if ($metadata) {\n                    $gridConfig->setName(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigName']));\n                    $gridConfig->setDescription(SecurityHelper::convertHtmlSpecialChars($metadata['gridConfigDescription']));\n                    $gridConfig->setShareGlobally($metadata['shareGlobally'] && $this->getAdminUser()->isAdmin());\n                    $gridConfig->setSetAsFavourite($metadata['setAsFavourite'] && $this->getAdminUser()->isAdmin());\n                }\n\n                $gridConfigData = json_encode($gridConfigData);\n                $gridConfig->setConfig($gridConfigData);\n                $gridConfig->save();\n\n                $userId = $this->getAdminUser()->getId();\n\n                $availableConfigs = $this->getMyOwnGridColumnConfigs($userId, $classId, $searchType);\n                $sharedConfigs = $this->getSharedGridColumnConfigs($this->getAdminUser(), $classId, $searchType);\n\n                $settings = $this->getShareSettings($gridConfig->getId());\n                $settings['gridConfigId'] = (int)$gridConfig->getId();\n                $settings['gridConfigName'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getName());\n                $settings['gridConfigDescription'] = SecurityHelper::convertHtmlSpecialChars($gridConfig->getDescription());\n                $settings['shareGlobally'] = $gridConfig->isShareGlobally();\n                $settings['setAsFavourite'] = $gridConfig->isSetAsFavourite();\n                $settings['isShared'] = $gridConfig->getOwnerId() != $this->getAdminUser()->getId() && !$this->getAdminUser()->isAdmin();\n\n                return $this->adminJson([\n                    'success' => true,\n                    'settings' => $settings,\n                    'availableConfigs' => $availableConfigs,\n                    'sharedConfigs' => $sharedConfigs,\n                ]);\n            } catch (\\Exception $e) {\n                return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n            }\n        }\n\n        throw $this->createAccessDeniedHttpException();\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigShares($gridConfig, $metadata)\n    {\n        $user = $this->getAdminUser();\n        if (!$gridConfig || !$user->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if ($gridConfig->getOwnerId() != $user->getId() && !$user->isAdmin()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n        $combinedShares = [];\n        $sharedUserIds = $metadata['sharedUserIds'];\n        $sharedRoleIds = $metadata['sharedRoleIds'];\n\n        if ($sharedUserIds) {\n            $combinedShares = explode(',', $sharedUserIds);\n        }\n\n        if ($sharedRoleIds) {\n            $sharedRoleIds = explode(',', $sharedRoleIds);\n            $combinedShares = array_merge($combinedShares, $sharedRoleIds);\n        }\n\n        $db = Db::get();\n        $db->delete('gridconfig_shares', ['gridConfigId' => $gridConfig->getId()]);\n\n        foreach ($combinedShares as $id) {\n            $share = new GridConfigShare();\n            $share->setGridConfigId($gridConfig->getId());\n            $share->setSharedWithUserId((int) $id);\n            $share->save();\n        }\n    }\n\n    /**\n     * @param GridConfig|null $gridConfig\n     * @param array $metadata\n     * @param int $objectId\n     *\n     * @throws \\Exception\n     */\n    protected function updateGridConfigFavourites($gridConfig, $metadata, $objectId)\n    {\n        $currentUser = $this->getAdminUser();\n\n        if (!$gridConfig || $currentUser === null || !$currentUser->isAllowed('share_configurations')) {\n            // nothing to do\n            return;\n        }\n\n        if (!$currentUser->isAdmin() && (int) $gridConfig->getOwnerId() !== $currentUser->getId()) {\n            throw new \\Exception(\"don't mess with someone elses grid config\");\n        }\n\n        $sharedUsers = [];\n\n        if ($metadata['shareGlobally'] === false) {\n            $sharedUserIds = $metadata['sharedUserIds'];\n\n            if ($sharedUserIds) {\n                $sharedUsers = explode(',', $sharedUserIds);\n            }\n        }\n\n        if ($metadata['shareGlobally'] === true) {\n            $users = new User\\Listing();\n            $users->setCondition('id = ?', $currentUser->getId());\n\n            foreach ($users as $user) {\n                $sharedUsers[] = $user->getId();\n            }\n        }\n\n        foreach ($sharedUsers as $id) {\n            $global    = true;\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                (int) $objectId,\n                $gridConfig->getSearchType()\n            );\n\n            // If the user has already a favourite for that object we check the current favourite and decide if we update\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ((bool) $favouriteGridConfig->isShareGlobally() === false) {\n                        continue;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the favourite\n                    if ((int) $favouriteGridConfig->getOwnerId() === (int) $id) {\n                        continue;\n                    }\n                }\n            }\n\n            // Check if the user has already a global favourite then we do not save the favourite as global\n            $favourite = GridConfigFavourite::getByOwnerAndClassAndObjectId(\n                (int) $id,\n                $gridConfig->getClassId(),\n                0,\n                $gridConfig->getSearchType()\n            );\n\n            if ($favourite instanceof GridConfigFavourite) {\n                $favouriteGridConfig = GridConfig::getById($favourite->getGridConfigId());\n\n                if ($favouriteGridConfig instanceof GridConfig) {\n                    // Check if the grid config was shared globally if that is *not* the case we also not update\n                    if ($favouriteGridConfig->isShareGlobally() === false) {\n                        $global = false;\n                    }\n\n                    // Check if the user is the owner. If that is the case we do not update the global favourite\n                    if ($favouriteGridConfig->getOwnerId() === (int) $id) {\n                        $global = false;\n                    }\n                }\n            }\n\n            $favourite = new GridConfigFavourite();\n            $favourite->setGridConfigId($gridConfig->getId());\n            $favourite->setClassId($gridConfig->getClassId());\n            $favourite->setObjectId($objectId);\n            $favourite->setOwnerId($id);\n            $favourite->setType($gridConfig->getType());\n            $favourite->setSearchType($gridConfig->getSearchType());\n            $favourite->save();\n\n            if ($global === true) {\n                $favourite->setObjectId(0);\n                $favourite->save();\n            }\n        }\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data $field\n     * @param string $gridType\n     * @param string $position\n     * @param bool $force\n     * @param string|null $keyPrefix\n     * @param DataObject\\ClassDefinition|null $class\n     * @param int|null $objectId\n     *\n     * @return array|null\n     */\n    protected function getFieldGridConfig($field, $gridType, $position, $force = false, $keyPrefix = null, $class = null, $objectId = null)\n    {\n        $key = $keyPrefix . $field->getName();\n        $config = null;\n        $title = $field->getName();\n        if (method_exists($field, 'getTitle')) {\n            if ($field->getTitle()) {\n                $title = $field->getTitle();\n            }\n        }\n\n        if ($field instanceof DataObject\\ClassDefinition\\Data\\Slider) {\n            $config['minValue'] = $field->getMinValue();\n            $config['maxValue'] = $field->getMaxValue();\n            $config['increment'] = $field->getIncrement();\n        }\n\n        if (method_exists($field, 'getWidth')) {\n            $config['width'] = $field->getWidth();\n        }\n        if (method_exists($field, 'getHeight')) {\n            $config['height'] = $field->getHeight();\n        }\n\n        $visible = false;\n        if ($gridType == 'search') {\n            $visible = $field->getVisibleSearch();\n        } elseif ($gridType == 'grid') {\n            $visible = $field->getVisibleGridView();\n        } elseif ($gridType == 'all') {\n            $visible = true;\n        }\n\n        if (!$field->getInvisible() && ($force || $visible)) {\n            $context = ['purpose' => 'gridconfig'];\n            if ($class) {\n                $context['class'] = $class;\n            }\n\n            if ($objectId) {\n                $object = DataObject::getById($objectId);\n                $context['object'] = $object;\n            }\n            DataObject\\Service::enrichLayoutDefinition($field, null, $context);\n\n            $result = [\n                'key' => $key,\n                'type' => $field->getFieldType(),\n                'label' => $title,\n                'config' => $config,\n                'layout' => $field,\n                'position' => $position,\n            ];\n\n            if ($field instanceof DataObject\\ClassDefinition\\Data\\EncryptedField) {\n                $result['delegateDatatype'] = $field->getDelegateDatatype();\n            }\n\n            return $result;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * IMPORTER\n     */\n\n    /**\n     * @Route(\"/import-upload\", name=\"importupload\", methods={\"POST\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function importUploadAction(Request $request)\n    {\n        $data = file_get_contents($_FILES['Filedata']['tmp_name']);\n        $data = Tool\\Text::convertToUTF8($data);\n\n        $importId = $request->get('importId');\n        $importId = str_replace('..', '', $importId);\n        $importFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId;\n        File::put($importFile, $data);\n\n        $importFileOriginal = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/import_' . $importId . '_original';\n        File::put($importFileOriginal, $data);\n\n        $response = $this->adminJson([\n            'success' => true,\n        ]);\n\n        // set content-type to text/html, otherwise (when application/json is sent) chrome will complain in\n        // Ext.form.Action.Submit and mark the submission as failed\n        $response->headers->set('Content-Type', 'text/html');\n\n        return $response;\n    }\n\n    private function getDataPreview($originalFile, $dialect)\n    {\n        $count = 0;\n        $data = [];\n        if (($handle = fopen($originalFile, 'r')) !== false) {\n            while (($rowData = fgetcsv($handle, 0, $dialect->delimiter, $dialect->quotechar, $dialect->escapechar)) !== false) {\n                $tmpData = [];\n\n                foreach ($rowData as $key => $value) {\n                    $tmpData['field_' . $key] = $value;\n                }\n\n                $tmpData['rowId'] = $count + 1;\n                $data[] = $tmpData;\n\n                $count++;\n\n                /**\n                 * Reached the number or rows for the preview\n                 */\n                if ($count > 18) {\n                    break;\n                }\n            }\n            fclose($handle);\n        }\n\n        return $data;\n    }\n\n    /**\n     * @param Request $request\n     *\n     * @return string\n     */\n    protected function extractLanguage(Request $request)\n    {\n        $requestedLanguage = $request->get('language');\n        if ($requestedLanguage) {\n            if ($requestedLanguage != 'default') {\n                $request->setLocale($requestedLanguage);\n            }\n        } else {\n            $requestedLanguage = $request->getLocale();\n        }\n\n        return $requestedLanguage;\n    }\n\n    /**\n     * @param string $fileHandle\n     *\n     * @return string\n     */\n    protected function getCsvFile($fileHandle)\n    {\n        return $fileHandle . '.csv';\n    }\n\n    /**\n     * @Route(\"/get-export-jobs\", name=\"getexportjobs\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     */\n    public function getExportJobsAction(Request $request, GridHelperService $gridHelperService, EventDispatcherInterface $eventDispatcher)\n    {\n        $requestedLanguage = $this->extractLanguage($request);\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $list = $gridHelperService->prepareListingForGrid($allParams, $requestedLanguage, $this->getAdminUser());\n\n        $beforeListPrepareEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListPrepareEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT_PREPARE);\n\n        $list = $beforeListPrepareEvent->getArgument('list');\n\n        $ids = $list->loadIdList();\n\n        $jobs = array_chunk($ids, 20);\n\n        $fileHandle = uniqid('export-');\n\n        $storage = Storage::get('temp');\n        $storage->write($this->getCsvFile($fileHandle), '');\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs, 'fileHandle' => $fileHandle]);\n    }\n\n    /**\n     * @Route(\"/do-export\", name=\"doexport\", methods={\"POST\"})\n     *\n     * @param Request $request\n     * @param LocaleServiceInterface $localeService\n     * @param EventDispatcherInterface $eventDispatcher\n     *\n     * @return JsonResponse\n     *\n     * @throws \\Exception\n     */\n    public function doExportAction(Request $request, LocaleServiceInterface $localeService, EventDispatcherInterface $eventDispatcher)\n    {\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $ids = $request->get('ids');\n        $settings = $request->get('settings');\n        $settings = json_decode($settings, true);\n        $delimiter = $settings['delimiter'] ?? ';';\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n\n        $enableInheritance = $settings['enableInheritance'] ?? null;\n        DataObject\\Concrete::setGetInheritedValues($enableInheritance);\n\n        $class = DataObject\\ClassDefinition::getById($request->get('classId'));\n\n        if (!$class) {\n            throw new \\Exception('No class definition found');\n        }\n\n        $className = $class->getName();\n        $listClass = '\\\\Pimcore\\\\Model\\\\DataObject\\\\' . ucfirst($className) . '\\\\Listing';\n\n        /** @var \\Pimcore\\Model\\DataObject\\Listing $list */\n        $list = new $listClass();\n\n        $quotedIds = [];\n        foreach ($ids as $id) {\n            $quotedIds[] = $list->quote($id);\n        }\n\n        $list->setObjectTypes(DataObject::$types);\n        $list->setCondition('o_id IN (' . implode(',', $quotedIds) . ')');\n        $list->setOrderKey(' FIELD(o_id, ' . implode(',', $quotedIds) . ')', false);\n\n        $beforeListExportEvent = new GenericEvent($this, [\n            'list' => $list,\n            'context' => $allParams,\n        ]);\n        $eventDispatcher->dispatch($beforeListExportEvent, AdminEvents::OBJECT_LIST_BEFORE_EXPORT);\n\n        $list = $beforeListExportEvent->getArgument('list');\n\n        $fields = $request->get('fields');\n\n        $addTitles = (bool) $request->get('initial');\n\n        $requestedLanguage = $this->extractLanguage($request);\n\n        $contextFromRequest = $request->get('context');\n        if ($contextFromRequest) {\n            $contextFromRequest = json_decode($contextFromRequest, true);\n        }\n\n        $context = [\n            'source' => 'pimcore-export',\n        ];\n\n        if (is_array($contextFromRequest)) {\n            $context = array_merge($context, $contextFromRequest);\n        }\n\n        $csv = DataObject\\Service::getCsvData($requestedLanguage, $localeService, $list, $fields, $addTitles, $context);\n\n        $storage = Storage::get('temp');\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        $fileStream = $storage->readStream($csvFile);\n\n        $temp = tmpfile();\n        stream_copy_to_stream($fileStream, $temp, null, 0);\n\n        $firstLine = true;\n        $lineCount = count($csv);\n\n        if (!$addTitles && $lineCount > 0) {\n            fwrite($temp, \"\\r\\n\");\n        }\n\n        for ($i = 0; $i < $lineCount; $i++) {\n            $line = $csv[$i];\n            if ($addTitles && $firstLine) {\n                $firstLine = false;\n                $line = implode($delimiter, $line);\n                fwrite($temp, $line);\n            } else {\n                fwrite($temp, implode($delimiter, array_map([$this, 'encodeFunc'], $line)));\n            }\n            if ($i < $lineCount - 1) {\n                fwrite($temp, \"\\r\\n\");\n            }\n        }\n        $storage->writeStream($csvFile, $temp);\n\n        return $this->adminJson(['success' => true]);\n    }\n\n    public function encodeFunc($value)\n    {\n        $value = str_replace('\"', '\"\"', $value);\n        //force wrap value in quotes and return\n        return '\"' . $value . '\"';\n    }\n\n    /**\n     * @Route(\"/download-csv-file\", name=\"downloadcsvfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return Response\n     */\n    public function downloadCsvFileAction(Request $request)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            $csvData = $storage->read($csvFile);\n            $response = new Response($csvData);\n            $response->headers->set('Content-Type', 'application/csv');\n            $disposition = HeaderUtils::makeDisposition(\n                HeaderUtils::DISPOSITION_ATTACHMENT,\n                'export.csv'\n            );\n\n            $response->headers->set('Content-Disposition', $disposition);\n            $storage->delete($csvFile);\n\n            return $response;\n        } catch (FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('CSV file not found');\n        }\n    }\n\n    /**\n     * @Route(\"/download-xlsx-file\", name=\"downloadxlsxfile\", methods={\"GET\"})\n     *\n     * @param Request $request\n     * @param GridHelperService $gridHelperService\n     *\n     * @return BinaryFileResponse\n     */\n    public function downloadXlsxFileAction(Request $request, GridHelperService $gridHelperService)\n    {\n        $storage = Storage::get('temp');\n        $fileHandle = \\Pimcore\\File::getValidFilename($request->get('fileHandle'));\n        $csvFile = $this->getCsvFile($fileHandle);\n\n        try {\n            return $gridHelperService->createXlsxExportFile($storage, $fileHandle, $csvFile);\n        } catch (\\Exception | FilesystemException | UnableToReadFile $exception) {\n            // handle the error\n            throw $this->createNotFoundException('XLSX file not found');\n        }\n    }\n\n    /**\n     * Flattens object data to an array with key=>value where\n     * value is simply a string representation of the value (for objects, hrefs and assets the full path is used)\n     *\n     * @param DataObject\\Concrete $object\n     *\n     * @return array\n     */\n    protected function csvObjectData($object)\n    {\n        $o = [];\n        foreach ($object->getClass()->getFieldDefinitions() as $key => $value) {\n            $o[$key] = $value->getForCsvExport($object);\n        }\n\n        $o['id (system)'] = $object->getId();\n        $o['key (system)'] = $object->getKey();\n        $o['fullpath (system)'] = $object->getRealFullPath();\n        $o['published (system)'] = $object->isPublished();\n        $o['type (system)'] = $object->getType();\n\n        return $o;\n    }\n\n    /**\n     * @Route(\"/get-batch-jobs\", name=\"getbatchjobs\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getBatchJobsAction(Request $request, GridHelperService $gridHelperService)\n    {\n        if ($request->get('language')) {\n            $request->setLocale($request->get('language'));\n        }\n\n        $allParams = array_merge($request->request->all(), $request->query->all());\n        $list = $gridHelperService->prepareListingForGrid($allParams, $request->getLocale(), $this->getAdminUser());\n\n        $jobs = $list->loadIdList();\n\n        return $this->adminJson(['success' => true, 'jobs' => $jobs]);\n    }\n\n    /**\n     * @Route(\"/batch\", name=\"batch\", methods={\"PUT\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function batchAction(Request $request)\n    {\n        $success = true;\n\n        try {\n            if ($request->get('data')) {\n                $params = $this->decodeJson($request->get('data'), true);\n                $object = DataObject\\Concrete::getById($params['job']);\n\n                if ($object) {\n                    $name = $params['name'];\n\n                    if (!$object->isAllowed('save') || ($name === 'published' && !$object->isAllowed('publish'))) {\n                        throw new \\Exception(\"Permission denied. You don't have the rights to save this object.\");\n                    }\n\n                    $append = $params['append'] ?? false;\n                    $remove = $params['remove'] ?? false;\n\n                    $className = $object->getClassName();\n                    $class = DataObject\\ClassDefinition::getByName($className);\n                    $value = $params['value'];\n                    if ($params['valueType'] == 'object') {\n                        $value = $this->decodeJson($value);\n                    }\n\n                    $parts = explode('~', $name);\n\n                    if (substr($name, 0, 1) == '~') {\n                        $type = $parts[1];\n                        $field = $parts[2];\n                        $keyId = $parts[3];\n\n                        if ($type == 'classificationstore') {\n                            $requestedLanguage = $params['language'];\n                            if ($requestedLanguage) {\n                                if ($requestedLanguage != 'default') {\n                                    $request->setLocale($requestedLanguage);\n                                }\n                            } else {\n                                $requestedLanguage = $request->getLocale();\n                            }\n\n                            $groupKeyId = explode('-', $keyId);\n                            $groupId = (int) $groupKeyId[0];\n                            $keyId = (int) $groupKeyId[1];\n\n                            $getter = 'get' . ucfirst($field);\n                            if (method_exists($object, $getter)) {\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $csFieldDefinition */\n                                $csFieldDefinition = $object->getClass()->getFieldDefinition($field);\n                                $csLanguage = $requestedLanguage;\n                                if (!$csFieldDefinition->isLocalized()) {\n                                    $csLanguage = 'default';\n                                }\n\n                                /** @var DataObject\\ClassDefinition\\Data\\Classificationstore $fd */\n                                $fd = $class->getFieldDefinition($field);\n                                $keyConfig = $fd->getKeyConfiguration($keyId);\n                                $dataDefinition = DataObject\\Classificationstore\\Service::getFieldDefinitionFromKeyConfig($keyConfig);\n\n                                /** @var DataObject\\Classificationstore $classificationStoreData */\n                                $classificationStoreData = $object->$getter();\n                                if ($append) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->appendData($oldValue, $value);\n                                }\n                                if ($remove) {\n                                    $oldValue = $classificationStoreData->getLocalizedKeyValue($groupId, $keyId);\n                                    $value = $dataDefinition->removeData($oldValue, $value);\n                                }\n                                $classificationStoreData->setLocalizedKeyValue(\n                                    $groupId,\n                                    $keyId,\n                                    $dataDefinition->getDataFromEditmode($value),\n                                    $csLanguage\n                                );\n                            }\n                        }\n                    } elseif (count($parts) > 1) {\n                        // check for bricks\n                        $brickType = $parts[0];\n                        $brickKey = $parts[1];\n                        $brickField = DataObject\\Service::getFieldForBrickType($object->getClass(), $brickType);\n\n                        $fieldGetter = 'get' . ucfirst($brickField);\n                        $brickGetter = 'get' . ucfirst($brickType);\n                        $valueSetter = 'set' . ucfirst($brickKey);\n\n                        $brick = $object->$fieldGetter()->$brickGetter();\n                        if (empty($brick)) {\n                            $classname = '\\\\Pimcore\\\\Model\\\\DataObject\\\\Objectbrick\\\\Data\\\\' . ucfirst($brickType);\n                            $brickSetter = 'set' . ucfirst($brickType);\n                            $brick = new $classname($object);\n                            $object->$fieldGetter()->$brickSetter($brick);\n                        }\n\n                        $brickClass = DataObject\\Objectbrick\\Definition::getByKey($brickType);\n                        $field = $brickClass->getFieldDefinition($brickKey);\n\n                        $newData = $field->getDataFromEditmode($value, $object);\n\n                        if ($append) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->appendData($existingData, $newData);\n                        }\n                        if ($remove) {\n                            $valueGetter = 'get' . ucfirst($brickKey);\n                            $existingData = $brick->$valueGetter();\n                            $newData = $field->removeData($existingData, $newData);\n                        }\n                        $brick->$valueSetter($newData);\n                    } else {\n                        // everything else\n                        $field = $class->getFieldDefinition($name);\n                        if ($field) {\n                            $newData = $field->getDataFromEditmode($value, $object);\n\n                            if ($append) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->appendData($existingData, $newData);\n                            }\n                            if ($remove) {\n                                $existingData = $object->{'get' . $name}();\n                                $newData = $field->removeData($existingData, $newData);\n                            }\n                            $object->setValue($name, $newData);\n                        } else {\n                            // check if it is a localized field\n                            if ($params['language']) {\n                                $localizedField = $class->getFieldDefinition('localizedfields');\n                                if ($localizedField instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                                    $field = $localizedField->getFieldDefinition($name);\n                                    if ($field) {\n                                        $getter = 'get' . $name;\n                                        $setter = 'set' . $name;\n                                        $newData = $field->getDataFromEditmode($value, $object);\n                                        if ($append) {\n                                            $existingData = $object->$getter($params['language']);\n                                            $newData = $field->appendData($existingData, $newData);\n                                        }\n                                        if ($remove) {\n                                            $existingData = $object->$getter($request->get('language'));\n                                            $newData = $field->removeData($existingData, $newData);\n                                        }\n\n                                        $object->$setter($newData, $params['language']);\n                                    }\n                                }\n                            }\n\n                            // seems to be a system field, this is actually only possible for the \"published\" field yet\n                            if ($name == 'published') {\n                                if ($value === 'false' || empty($value)) {\n                                    $object->setPublished(false);\n                                } else {\n                                    $object->setPublished(true);\n                                }\n                            }\n                        }\n                    }\n\n                    try {\n                        // don't check for mandatory fields here\n                        $object->setOmitMandatoryCheck(!$object->isPublished());\n                        $object->setUserModification($this->getAdminUser()->getId());\n                        $object->save();\n                        $success = true;\n                    } catch (\\Exception $e) {\n                        return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n                    }\n                } else {\n                    Logger::debug('DataObjectController::batchAction => There is no object left to update.');\n\n                    return $this->adminJson(['success' => false, 'message' => 'DataObjectController::batchAction => There is no object left to update.']);\n                }\n            }\n        } catch (\\Exception $e) {\n            Logger::err((string) $e);\n\n            return $this->adminJson(['success' => false, 'message' => $e->getMessage()]);\n        }\n\n        return $this->adminJson(['success' => $success]);\n    }\n\n    /**\n     * @Route(\"/get-available-visible-vields\", name=\"getavailablevisiblefields\", methods={\"GET\"})\n     *\n     * @param Request $request\n     *\n     * @return JsonResponse\n     */\n    public function getAvailableVisibleFieldsAction(Request $request)\n    {\n        $class = null;\n        $fields = null;\n\n        $classList = [];\n        $classNameList = [];\n\n        if ($request->get('classes')) {\n            $classNameList = $request->get('classes');\n            $classNameList = explode(',', $classNameList);\n            foreach ($classNameList as $className) {\n                $class = DataObject\\ClassDefinition::getByName($className);\n                if ($class) {\n                    $classList[] = $class;\n                }\n            }\n        }\n\n        if (!$classList) {\n            return $this->adminJson(['availableFields' => []]);\n        }\n        $availableFields = [];\n        foreach (self::SYSTEM_COLUMNS as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        /** @var DataObject\\ClassDefinition\\Data[] $commonFields */\n        $commonFields = [];\n\n        $firstOne = true;\n        foreach ($classNameList as $className) {\n            $class = DataObject\\ClassDefinition::getByName($className);\n            if ($class) {\n                $fds = $class->getFieldDefinitions();\n\n                $additionalFieldNames = array_keys($fds);\n                $localizedFields = $class->getFieldDefinition('localizedfields');\n                if ($localizedFields instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                    $lfNames = array_keys($localizedFields->getFieldDefinitions());\n                    $additionalFieldNames = array_merge($additionalFieldNames, $lfNames);\n                }\n\n                foreach ($commonFields as $commonFieldKey => $commonFieldDefinition) {\n                    if (!in_array($commonFieldKey, $additionalFieldNames)) {\n                        unset($commonFields[$commonFieldKey]);\n                    }\n                }\n\n                $this->processAvailableFieldDefinitions($fds, $firstOne, $commonFields);\n\n                $firstOne = false;\n            }\n        }\n\n        $commonFieldKeys = array_keys($commonFields);\n        foreach ($commonFieldKeys as $field) {\n            $availableFields[] = [\n                'key' => $field,\n                'value' => $field,\n            ];\n        }\n\n        return $this->adminJson(['availableFields' => $availableFields]);\n    }\n\n    /**\n     * @param DataObject\\ClassDefinition\\Data[] $fds\n     * @param bool $firstOne\n     * @param DataObject\\ClassDefinition\\Data[] $commonFields\n     */\n    protected function processAvailableFieldDefinitions($fds, &$firstOne, &$commonFields)\n    {\n        foreach ($fds as $fd) {\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Fieldcollections || $fd instanceof DataObject\\ClassDefinition\\Data\\Objectbricks\n                || $fd instanceof DataObject\\ClassDefinition\\Data\\Block) {\n                continue;\n            }\n\n            if ($fd instanceof DataObject\\ClassDefinition\\Data\\Localizedfields) {\n                $lfDefs = $fd->getFieldDefinitions();\n                $this->processAvailableFieldDefinitions($lfDefs, $firstOne, $commonFields);\n            } elseif ($firstOne || (isset($commonFields[$fd->getName()]) && $commonFields[$fd->getName()]->getFieldtype() == $fd->getFieldtype())) {\n                $commonFields[$fd->getName()] = $fd;\n            }\n        }\n    }\n}\n", "/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\n\npimcore.registerNS(\"pimcore.element.helpers.gridColumnConfig\");\npimcore.element.helpers.gridColumnConfig = {\n\n    batchJobDelay: 50,\n\n    getSaveAsDialog: function () {\n        var defaultName = new Date();\n\n        var nameField = new Ext.form.TextField({\n            fieldLabel: t('name'),\n            length: 50,\n            allowBlank: false,\n            value: this.settings.gridConfigName ? this.settings.gridConfigName : defaultName,\n            listeners: {\n                change: pimcore.helpers.htmlEncodeTextField\n            }\n        });\n\n        var descriptionField = new Ext.form.TextArea({\n            fieldLabel: t('description'),\n            // height: 200,\n            value: this.settings.gridConfigDescription\n        });\n\n        var configPanel = new Ext.Panel({\n            layout: \"form\",\n            bodyStyle: \"padding: 10px;\",\n            items: [nameField, descriptionField],\n            buttons: [{\n                text: t(\"save\"),\n                iconCls: \"pimcore_icon_apply\",\n                handler: function () {\n                    this.settings.gridConfigId = null;\n                    this.settings.gridConfigName = nameField.getValue();\n                    this.settings.gridConfigDescription = descriptionField.getValue();\n\n                    pimcore.helpers.saveColumnConfig(this.object.id, this.classId, this.getGridConfig(), this.searchType, this.saveColumnConfigButton,\n                        this.columnConfigurationSavedHandler.bind(this), this.settings, this.gridType);\n                    this.saveWindow.close();\n                }.bind(this)\n            }]\n        });\n\n        this.saveWindow = new Ext.Window({\n            width: 600,\n            height: 300,\n            modal: true,\n            title: t('save_as_copy'),\n            layout: \"fit\",\n            items: [configPanel]\n        });\n\n        this.saveWindow.show();\n        nameField.focus();\n        nameField.selectText();\n        return this.window;\n    },\n\n    deleteGridConfig: function () {\n\n        Ext.MessageBox.show({\n            title: t('delete'),\n            msg: t('delete_message'),\n            buttons: Ext.Msg.OKCANCEL,\n            icon: Ext.MessageBox.INFO,\n            fn: this.deleteGridConfigConfirmed.bind(this)\n        });\n    },\n\n    deleteGridConfigConfirmed: function (btn) {\n        var route = null;\n\n        if (this.gridType === 'asset') {\n            route = 'pimcore_admin_asset_assethelper_griddeletecolumnconfig';\n        }\n        else if(this.gridType === 'object') {\n            route = 'pimcore_admin_dataobject_dataobjecthelper_griddeletecolumnconfig';\n        }\n        else {\n            throw new Error('Type unknown');\n        }\n\n        if (btn === 'ok') {\n            Ext.Ajax.request({\n                url: Routing.generate(route),\n                method: \"DELETE\",\n                params: {\n                    id: this.classId,\n                    objectId:\n                    this.object.id,\n                    gridtype: \"grid\",\n                    gridConfigId: this.settings.gridConfigId,\n                    searchType: this.searchType\n                },\n                success: function (response) {\n\n                    decodedResponse = Ext.decode(response.responseText);\n                    if (!decodedResponse.deleteSuccess) {\n                        pimcore.helpers.showNotification(t(\"error\"), t(\"error_deleting_item\"), \"error\");\n                    }\n\n                    this.createGrid(false, response);\n                }.bind(this)\n            });\n        }\n    },\n\n    switchToGridConfig: function (menuItem) {\n        var gridConfig = menuItem.gridConfig;\n        this.settings.gridConfigId = gridConfig.id;\n        this.getTableDescription();\n    },\n\n    addGridConfigMenuItems: function(menu, list, onlyConfigs) {\n        for (var i = 0; i < list.length; i++) {\n            var disabled = false;\n            var config = list[i];\n            let text = `<span>${Ext.util.Format.htmlEncode(config[\"name\"])}</span>`;\n            if (config.id == this.settings.gridConfigId) {\n                text = Ext.util.Format.htmlEncode(this.settings.gridConfigName);\n                if (!onlyConfigs) {\n                    text = \"<b>\" + text + \"</b>\";\n                    disabled = true;\n                }\n            }\n            var menuConfig = {\n                text: text,\n                disabled: disabled,\n                iconCls: 'pimcore_icon_gridcolumnconfig',\n                gridConfig: config,\n                handler: this.switchToGridConfig.bind(this)\n            };\n            menu.add(menuConfig);\n        }\n    },\n\n    buildColumnConfigMenu: function (onlyConfigs) {\n        var menu = this.columnConfigButton.getMenu();\n        menu.removeAll();\n\n        if (!onlyConfigs) {\n            menu.add({\n                text: t('save_as_copy'),\n                iconCls: \"pimcore_icon_save\",\n                handler: this.saveConfig.bind(this, true)\n            });\n\n            menu.add({\n                text: t('set_as_favourite'),\n                iconCls: \"pimcore_icon_favourite\",\n                handler: function () {\n                    pimcore.helpers.markColumnConfigAsFavourite(this.object.id, this.classId, this.settings.gridConfigId, this.searchType, true, this.gridType);\n                }.bind(this)\n            });\n\n            menu.add({\n                text: t('delete'),\n                iconCls: \"pimcore_icon_delete\",\n                disabled: !this.settings.gridConfigId || this.settings.isShared,\n                handler: this.deleteGridConfig.bind(this)\n            });\n\n            menu.add('-');\n        }\n\n        var disabled = false;\n        var text = t('predefined');\n        if (!this.settings.gridConfigId && !onlyConfigs) {\n            text = \"<b>\" + text + \"</b>\";\n            disabled = true;\n\n        }\n\n        menu.add({\n            text: text,\n            iconCls: \"pimcore_icon_gridcolumnconfig\",\n            disabled: disabled,\n            gridConfig: {\n                id: 0\n            },\n            handler: this.switchToGridConfig.bind(this)\n        });\n\n        if (this.availableConfigs && this.availableConfigs.length > 0) {\n            this.addGridConfigMenuItems(menu, this.availableConfigs, onlyConfigs);\n        }\n\n        if (this.sharedConfigs && this.sharedConfigs.length > 0) {\n            menu.add('-');\n            this.addGridConfigMenuItems(menu, this.sharedConfigs, onlyConfigs);\n        }\n    },\n\n    saveConfig: function (asCopy, context) {\n        if (asCopy) {\n            this.getSaveAsDialog();\n        } else {\n            pimcore.helpers.saveColumnConfig(this.object.id, this.classId, this.getGridConfig(), this.searchType, this.saveColumnConfigButton,\n                this.columnConfigurationSavedHandler.bind(this), this.settings, this.gridType, this.context);\n        }\n    },\n\n    filterUpdateFunction: function (grid, toolbarFilterInfo, clearFilterButton) {\n        var filterStringConfig = [];\n        var filterData = grid.getStore().getFilters().items;\n\n        // reset\n        toolbarFilterInfo.setTooltip(\" \");\n\n        if (filterData.length > 0) {\n\n            for (var i = 0; i < filterData.length; i++) {\n\n                var operator = filterData[i].getOperator();\n                if (operator == 'lt') {\n                    operator = \"&lt;\";\n                } else if (operator == 'gt') {\n                    operator = \"&gt;\";\n                } else if (operator == 'eq') {\n                    operator = \"=\";\n                }\n\n                var value = filterData[i].getValue();\n\n                if (value instanceof Date) {\n                    value = Ext.Date.format(value, \"Y-m-d\");\n                }\n\n                if (value && typeof value == \"object\") {\n                    filterStringConfig.push(filterData[i].getProperty() + \" \" + operator + \" (\"\n                        + value.join(\" OR \") + \")\");\n                } else {\n                    filterStringConfig.push(filterData[i].getProperty() + \" \" + operator + \" \" + value);\n                }\n            }\n\n            var filterCondition = filterStringConfig.join(\" AND \") + \"</b>\";\n            toolbarFilterInfo.setTooltip(\"<b>\" + t(\"filter_condition\") + \": \" + filterCondition);\n            toolbarFilterInfo.pimcore_filter_condition = filterCondition;\n            toolbarFilterInfo.setHidden(false);\n        }\n        toolbarFilterInfo.setHidden(filterData.length == 0);\n        clearFilterButton.setHidden(!toolbarFilterInfo.isVisible());\n    },\n\n    updateGridHeaderContextMenu: function (grid) {\n        var columnConfig = new Ext.menu.Item({\n            text: t(\"grid_options\"),\n            iconCls: \"pimcore_icon_table_col pimcore_icon_overlay_edit\",\n            handler: this.openColumnConfig.bind(this)\n        });\n        var menu = grid.headerCt.getMenu();\n        menu.add(columnConfig);\n        //\n\n        var batchAllMenu = new Ext.menu.Item({\n            text: t(\"batch_change\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, false, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAllMenu);\n\n        var batchSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_change_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, false, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchSelectedMenu);\n\n        var batchAppendAllMenu = new Ext.menu.Item({\n            text: t(\"batch_append_all\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, true, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAppendAllMenu);\n\n        var batchAppendSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_append_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, true, false);\n            }.bind(this, grid)\n        });\n        menu.add(batchAppendSelectedMenu);\n\n\n        var batchRemoveAllMenu = new Ext.menu.Item({\n            text: t(\"batch_remove_all\"),\n            iconCls: \"pimcore_icon_table pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, false, false, true);\n            }.bind(this, grid)\n        });\n        menu.add(batchRemoveAllMenu);\n\n        var batchRemoveSelectedMenu = new Ext.menu.Item({\n            text: t(\"batch_remove_selected\"),\n            iconCls: \"pimcore_icon_structuredTable pimcore_icon_overlay_go\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.batchPrepare(column, true, false, true);\n            }.bind(this, grid)\n        });\n        menu.add(batchRemoveSelectedMenu);\n\n        var filterByRelationMenu = new Ext.menu.Item({\n            text: t(\"filter_by_relation\"),\n            iconCls: \"pimcore_icon_filter pimcore_icon_overlay_add\",\n            handler: function (grid) {\n                var menu = grid.headerCt.getMenu();\n                var column = menu.activeHeader;\n                this.filterPrepare(column);\n            }.bind(this, grid)\n        });\n        menu.add(filterByRelationMenu);\n\n        //\n        menu.on('beforeshow', function (batchAllMenu, batchSelectedMenu, grid) {\n            var menu = grid.headerCt.getMenu();\n            var columnDataIndex = menu.activeHeader.dataIndex;\n\n            if (menu.activeHeader.config && typeof menu.activeHeader.config.getRelationFilter === \"function\") {\n                filterByRelationMenu.show();\n            } else {\n                filterByRelationMenu.hide();\n            }\n\n            // no batch for system properties\n            if (Ext.Array.contains(this.systemColumns, columnDataIndex) || Ext.Array.contains(this.noBatchColumns, columnDataIndex)) {\n                batchAllMenu.hide();\n                batchSelectedMenu.hide();\n            } else {\n                batchAllMenu.show();\n                batchSelectedMenu.show();\n            }\n\n            if (!Ext.Array.contains(this.systemColumns, columnDataIndex) && Ext.Array.contains(this.batchAppendColumns ? this.batchAppendColumns : [], columnDataIndex)) {\n                batchAppendAllMenu.show();\n                batchAppendSelectedMenu.show();\n            } else {\n                batchAppendAllMenu.hide();\n                batchAppendSelectedMenu.hide();\n            }\n\n            if (!Ext.Array.contains(this.systemColumns,columnDataIndex) && Ext.Array.contains(this.batchRemoveColumns ? this.batchRemoveColumns : [], columnDataIndex)) {\n                batchRemoveAllMenu.show();\n                batchRemoveSelectedMenu.show();\n            } else {\n                batchRemoveAllMenu.hide();\n                batchRemoveSelectedMenu.hide();\n            }\n        }.bind(this, batchAllMenu, batchSelectedMenu, grid));\n    },\n\n    filterPrepare: function (column) {\n        var dataIndexName = column.dataIndex\n        var gridColumns = this.grid.getColumns();\n        var columnIndex = -1;\n        for (let i = 0; i < gridColumns.length; i++) {\n            let dataIndex = gridColumns[i].dataIndex;\n            if (dataIndex == dataIndexName) {\n                columnIndex = i;\n                break;\n            }\n        }\n        if (columnIndex < 0) {\n            return;\n        }\n\n        if (this.systemColumns.indexOf(gridColumns[columnIndex].dataIndex) > -1) {\n            return;\n        }\n\n        var fieldInfo = this.grid.getColumns()[columnIndex].config;\n\n        if((this.objecttype === \"object\") || (this.objecttype === \"variant\")) {\n            if (!fieldInfo.layout || !fieldInfo.layout.layout) {\n                return;\n            }\n\n            var tagType = fieldInfo.layout.type;\n            var editor = new pimcore.object.tags[tagType](null, fieldInfo.layout.layout);\n            editor.setObject(this.object);\n        }\n\n        editor.updateContext({\n            containerType: \"filterByRelationWindow\"\n        });\n\n        var formPanel = Ext.create('Ext.form.Panel', {\n            xtype: \"form\",\n            border: false,\n            items: [editor.getLayoutEdit()],\n            bodyStyle: \"padding: 10px;\",\n            buttons: [\n                {\n                    text: t(\"clear_relation_filter\"),\n                    iconCls: \"pimcore_icon_filter_condition pimcore_icon_overlay_delete\",\n                    handler: function () {\n                        this.filterByRelationWindow.close();\n                        this.grid.store.filters.removeByKey(\"x-gridfilter-\"+fieldInfo.dataIndex);\n                    }.bind(this)\n                },\n                {\n                    text: t(\"apply_filter\"),\n                    iconCls: \"pimcore_icon_filter pimcore_icon_overlay_add\",\n                    handler: function () {\n                        if (formPanel.isValid() && typeof fieldInfo.getRelationFilter === \"function\") {\n                            this.grid.filters.getStore().addFilter(\n                                fieldInfo.getRelationFilter(fieldInfo.dataIndex, editor)\n                            );\n                            this.filterByRelationWindow.close();\n                        }\n                    }.bind(this)\n                }\n            ]\n        });\n\n        var title = t(\"filter_by_relation_field\") + \" \" + fieldInfo.text;\n        this.filterByRelationWindow = new Ext.Window({\n            autoScroll: true,\n            modal: false,\n            title: title,\n            items: [formPanel],\n            bodyStyle: \"background: #fff;\",\n            width: 700,\n            maxHeight: 650\n        });\n        this.filterByRelationWindow.show();\n        this.filterByRelationWindow.updateLayout();\n    },\n\n    batchPrepare: function (column, onlySelected, append, remove) {\n        var dataIndexName = column.dataIndex\n        var gridColumns = this.grid.getColumns();\n        var columnIndex = -1;\n        for (let i = 0; i < gridColumns.length; i++) {\n            let dataIndex = gridColumns[i].dataIndex;\n            if (dataIndex == dataIndexName) {\n                columnIndex = i;\n                break;\n            }\n        }\n        if (columnIndex < 0) {\n            return;\n        }\n\n        // no batch for system properties\n\n        if (this.systemColumns.indexOf(gridColumns[columnIndex].dataIndex) > -1) {\n            return;\n        }\n\n        var jobs = [];\n        if (onlySelected) {\n            var selectedRows = this.grid.getSelectionModel().getSelection();\n            for (var i = 0; i < selectedRows.length; i++) {\n                jobs.push(selectedRows[i].get(\"id\"));\n            }\n            this.batchOpen(columnIndex, jobs, append, remove, onlySelected);\n\n        } else {\n            let params = this.getGridParams(onlySelected);\n            Ext.Ajax.request({\n                url: this.batchPrepareUrl,\n                params: params,\n                success: function (columnIndex, response) {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata.success && rdata.jobs) {\n                        this.batchOpen(columnIndex, rdata.jobs, append, remove, onlySelected);\n                    }\n\n                }.bind(this, columnIndex)\n            });\n        }\n\n    },\n\n    batchOpen: function (columnIndex, jobs, append, remove, onlySelected) {\n\n        columnIndex = columnIndex - 1;\n\n        var fieldInfo = this.grid.getColumns()[columnIndex + 1].config;\n\n        // HACK: typemapping for published (systemfields) because they have no edit masks, so we use them from the\n        // data-types\n        if (fieldInfo.dataIndex == \"published\") {\n            fieldInfo.layout = {\n                layout: {\n                    title: t(\"published\"),\n                    name: \"published\",\n                    hideEmptyButton: true\n                },\n                type: \"checkbox\"\n            };\n        }\n        // HACK END\n\n        if((this.objecttype === \"object\") || (this.objecttype === \"variant\")) {\n            if (!fieldInfo.layout || !fieldInfo.layout.layout) {\n                return;\n            }\n\n            if (fieldInfo.layout.layout.noteditable) {\n                Ext.MessageBox.alert(t('error'), t('this_element_cannot_be_edited'));\n                return;\n            }\n\n            var tagType = fieldInfo.layout.type;\n            var editor = new pimcore.object.tags[tagType](null, fieldInfo.layout.layout);\n            editor.setObject(this.object);\n        } else {\n            var tagType = this.fieldObject[fieldInfo.dataIndex].layout.fieldtype;\n            let layoutInfo = this.fieldObject[fieldInfo.dataIndex].layout\n            try {\n                if (typeof pimcore.asset.metadata.tags[tagType].prototype.prepareBatchEditLayout == \"function\") {\n                    layoutInfo = pimcore.asset.metadata.tags[tagType].prototype.prepareBatchEditLayout(layoutInfo);\n                }\n            } catch (e) {\n                console.log(e);\n            }\n\n            var editor = new pimcore.asset.metadata.tags[tagType](null, layoutInfo);\n            editor.setAsset(this.asset);\n        }\n\n        editor.updateContext({\n            containerType: \"batch\"\n        });\n\n        var formPanel = Ext.create('Ext.form.Panel', {\n            xtype: \"form\",\n            border: false,\n            items: [editor.getLayoutEdit()],\n            bodyStyle: \"padding: 10px;\",\n            buttons: [\n                {\n                    text: t(\"save\"),\n                    handler: function () {\n                        if (formPanel.isValid()) {\n                            this.batchProcess(jobs, append, remove, editor, fieldInfo, true);\n                        }\n                    }.bind(this)\n                }\n            ]\n        });\n        var batchTitle = onlySelected ? \"batch_edit_field_selected\" : \"batch_edit_field\";\n        var appendTitle = onlySelected ? \"batch_append_selected_to\" : \"batch_append_to\";\n        var removeTitle = onlySelected ? \"batch_remove_selected_from\" : \"batch_remove_from\";\n        var title = remove ? t(removeTitle) + \" \" + fieldInfo.text : (append ? t(appendTitle) + \" \" + fieldInfo.text : t(batchTitle) + \" \" + fieldInfo.text);\n        this.batchWin = new Ext.Window({\n            autoScroll: true,\n            modal: false,\n            title: title,\n            items: [formPanel],\n            bodyStyle: \"background: #fff;\",\n            width: 700,\n            maxHeight: 600\n        });\n        this.batchWin.show();\n        this.batchWin.updateLayout();\n    },\n\n    batchProcess: function (jobs, append,  remove, editor, fieldInfo, initial) {\n        if (initial) {\n            this.batchErrors = [];\n            this.batchJobCurrent = 0;\n\n            var newValue = editor.getValue();\n\n            var valueType = \"primitive\";\n            if (newValue && typeof newValue == \"object\") {\n                newValue = Ext.encode(newValue);\n                valueType = \"object\";\n            }\n\n            this.batchParameters = {\n                name: fieldInfo.dataIndex,\n                value: newValue,\n                valueType: valueType,\n                language: this.gridLanguage\n            };\n\n\n            this.batchWin.close();\n\n            this.batchProgressBar = new Ext.ProgressBar({\n                text: t('initializing'),\n                style: \"margin: 10px;\",\n                width: 500\n            });\n\n            this.batchProgressWin = new Ext.Window({\n                title: t('batch_operation'),\n                items: [this.batchProgressBar],\n                layout: 'fit',\n                width: 400,\n                bodyStyle: \"padding: 10px;\",\n                closable: false,\n                plain: true,\n                modal: true\n            });\n\n            this.batchProgressWin.show();\n\n        }\n\n        if (this.batchJobCurrent >= jobs.length) {\n            this.batchProgressWin.close();\n            this.pagingtoolbar.moveFirst();\n            try {\n                var tree = pimcore.globalmanager.get(\"layout_object_tree\").tree;\n                tree.getStore().load({\n                    node: tree.getRootNode()\n                });\n            } catch (e) {\n                console.log(e);\n            }\n\n            // error handling\n            if (this.batchErrors.length > 0) {\n                var jobErrors = [];\n                for (var i = 0; i < this.batchErrors.length; i++) {\n                    jobErrors.push(this.batchErrors[i].job + ' - ' + this.batchErrors[i].error);\n                }\n                Ext.Msg.alert(t(\"error\"), t(\"error_jobs\") + \":<br>\" + jobErrors.join(\"<br>\"));\n            }\n\n            return;\n        }\n\n        var status = (this.batchJobCurrent / jobs.length);\n        var percent = Math.ceil(status * 100);\n        this.batchProgressBar.updateProgress(status, percent + \"%\");\n\n        this.batchParameters.job = jobs[this.batchJobCurrent];\n        if (append) {\n            this.batchParameters.append = 1;\n        }\n        if (remove) {\n            this.batchParameters.remove = 1;\n        }\n\n        Ext.Ajax.request({\n            url: this.batchProcessUrl,\n            method: 'PUT',\n            params: {\n                data: Ext.encode(this.batchParameters)\n            },\n            success: function (jobs, currentJob, response) {\n\n                try {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata) {\n                        if (!rdata.success) {\n                            throw \"not successful\";\n                        }\n                    }\n                } catch (e) {\n                    this.batchErrors.push({\n                        job: currentJob,\n                        error: (typeof(rdata.message) !== \"undefined\" && rdata.message) ?\n                            rdata.message : 'Not Successful'\n                    });\n                }\n\n                window.setTimeout(function () {\n                    this.batchJobCurrent++;\n                    this.batchProcess(jobs, append, remove);\n                }.bind(this), this.batchJobDelay);\n            }.bind(this, jobs, this.batchParameters.job)\n        });\n    },\n\n    exportPrepare: function (settings, exportType) {\n        let params = this.getGridParams();\n\n        var fields = this.getGridConfig().columns;\n        var fieldKeys = Object.keys(fields);\n        params[\"fields[]\"] = fieldKeys;\n        if (this.context) {\n            params[\"context\"] = Ext.encode(this.context);\n        }\n\n        settings = Ext.encode(settings);\n        params[\"settings\"] = settings;\n        Ext.Ajax.request({\n            method: 'POST',\n            url: this.exportPrepareUrl,\n            params: params,\n            success: function (response) {\n                var rdata = Ext.decode(response.responseText);\n\n                if (rdata.success && rdata.jobs) {\n                    this.exportProcess(rdata.jobs, rdata.fileHandle, fieldKeys, true, settings, exportType);\n                }\n            }.bind(this)\n        });\n    },\n\n    exportProcess: function (jobs, fileHandle, fields, initial, settings, exportType) {\n        if (initial) {\n            this.exportErrors = [];\n            this.exportJobCurrent = 0;\n\n            this.exportParameters = {\n                fileHandle: fileHandle,\n                language: this.gridLanguage,\n                settings: settings\n            };\n            this.exportProgressBar = new Ext.ProgressBar({\n                text: t('initializing'),\n                style: \"margin: 10px;\",\n                width: 500\n            });\n\n            this.exportProgressWin = new Ext.Window({\n                title: t(\"export\"),\n                items: [this.exportProgressBar],\n                layout: 'fit',\n                width: 200,\n                bodyStyle: \"padding: 10px;\",\n                closable: false,\n                plain: true,\n                listeners: pimcore.helpers.getProgressWindowListeners()\n            });\n            this.exportProgressWin.show();\n        }\n\n        if (this.exportJobCurrent >= jobs.length) {\n            this.exportProgressWin.close();\n\n            // error handling\n            if (this.exportErrors.length > 0) {\n                var jobErrors = [];\n                for (var i = 0; i < this.exportErrors.length; i++) {\n                    jobErrors.push(this.exportErrors[i].job);\n                }\n                Ext.Msg.alert(t(\"error\"), t(\"error_jobs\") + \": \" + jobErrors.join(\",\"));\n            } else {\n                pimcore.helpers.download(exportType.getDownloadUrl(fileHandle));\n            }\n\n            return;\n        }\n\n        var status = (this.exportJobCurrent / jobs.length);\n        var percent = Math.ceil(status * 100);\n        this.exportProgressBar.updateProgress(status, percent + \"%\");\n\n        this.exportParameters['ids[]'] = jobs[this.exportJobCurrent];\n        this.exportParameters[\"fields[]\"] = fields;\n        this.exportParameters.classId = this.classId;\n        this.exportParameters.initial = initial ? 1 : 0;\n        this.exportParameters.language = this.gridLanguage;\n        this.exportParameters.context = Ext.encode(this.context);\n\n        Ext.Ajax.request({\n            url: this.exportProcessUrl,\n            method: 'POST',\n            params: this.exportParameters,\n            success: function (jobs, currentJob, response) {\n\n                try {\n                    var rdata = Ext.decode(response.responseText);\n                    if (rdata) {\n                        if (!rdata.success) {\n                            throw \"not successful\";\n                        }\n                    }\n                } catch (e) {\n                    this.exportErrors.push({\n                        job: currentJob\n                    });\n                }\n\n                window.setTimeout(function () {\n                    this.exportJobCurrent++;\n                    this.exportProcess(jobs, fileHandle, fields, false, settings, exportType);\n                }.bind(this), this.batchJobDelay);\n            }.bind(this, jobs, jobs[this.exportJobCurrent])\n        });\n    },\n\n    columnConfigurationSavedHandler: function (rdata) {\n        this.settings = rdata.settings;\n        this.availableConfigs = rdata.availableConfigs;\n        this.buildColumnConfigMenu();\n    },\n\n    getGridParams: function (onlySelected) {\n        var filters = \"\";\n        var condition = \"\";\n        var searchQuery = this.searchField ? this.searchField.getValue() : \"\";\n\n        if (this.sqlFilter) {\n            condition = this.sqlEditor.getValue();\n        } else {\n            var filterData = this.store.getFilters().items;\n            if (filterData.length > 0) {\n                filters = this.store.getProxy().encodeFilters(filterData);\n            }\n        }\n\n        var params = {\n            filter: filters,\n            condition: condition,\n            classId: this.classId,\n            folderId: this.element.id,\n            objecttype: this.objecttype,\n            language: this.gridLanguage,\n            batch: true, // to avoid limit for export\n        };\n\n        if (searchQuery) {\n            params[\"query\"] = searchQuery;\n        }\n\n        if (onlySelected !== false) {\n            //create the ids array which contains chosen rows to export\n            ids = [];\n            var selectedRows = this.grid.getSelectionModel().getSelection();\n            for (var i = 0; i < selectedRows.length; i++) {\n                ids.push(selectedRows[i].data.id);\n            }\n\n            if (ids.length > 0) {\n                params[\"ids[]\"] = ids;\n            }\n        }\n\n        //tags filter\n        if(this.tagsTree) {\n            params[\"tagIds[]\"] = this.tagsTree.getCheckedTagIds();\n\n            if(this.tagsPanel) {\n                params[\"considerChildTags\"] = this.tagsPanel.considerChildTags;\n            }\n        }\n\n        //only direct children filter\n        if (this.checkboxOnlyDirectChildren) {\n            params[\"only_direct_children\"] = this.checkboxOnlyDirectChildren.getValue();\n        }\n\n        //only unreferenced filter\n        if (this.checkboxOnlyUnreferenced) {\n            params[\"only_unreferenced\"] = this.checkboxOnlyUnreferenced.getValue();\n        }\n\n        var fields = this.getGridConfig().columns;\n        var fieldKeys = Object.keys(fields);\n        params[\"fields[]\"] = fieldKeys;\n\n        return params;\n\n    }\n};\n", "<?php\n\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Commercial License (PCL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n *  @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n *  @license    http://www.pimcore.org/license     GPLv3 and PCL\n */\n\nnamespace Pimcore\\Security;\n\n/**\n * @internal\n */\nclass SecurityHelper\n{\n    public static function convertHtmlSpecialChars(?string $text): ?string\n    {\n        if(is_string($text)) {\n            return htmlspecialchars($text, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8', false);\n        }\n\n        return null;\n    }\n\n    public static function convertHtmlSpecialCharsArrayKeys(array &$array, array $keys): void\n    {\n        foreach ($keys as $key) {\n            if (array_key_exists($key, $array)) {\n                $array[$key] = self::convertHtmlSpecialChars($array[$key]);\n            }\n        }\n    }\n}\n"], "filenames": ["bundles/AdminBundle/Controller/Admin/DataObject/DataObjectHelperController.php", "bundles/AdminBundle/Resources/public/js/pimcore/element/helpers/gridColumnConfig.js", "lib/Security/SecurityHelper.php"], "buggy_code_start_loc": [349, 27, 17], "buggy_code_end_loc": [973, 132, 17], "fixing_code_start_loc": [349, 27, 18], "fixing_code_end_loc": [973, 135, 21], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.5.21.", "other": {"cve": {"id": "CVE-2023-2340", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-27T13:15:09.213", "lastModified": "2023-05-04T20:07:12.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository pimcore/pimcore prior to 10.5.21."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.5.21", "matchCriteriaId": "72C537D6-67BA-4562-B853-F99E6C14315C"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/aa38319e353cc3cdfac12e03e21ed7a8f3628d3e", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/964762b0-b4fe-441c-81e1-0ebdbbf80f3b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/aa38319e353cc3cdfac12e03e21ed7a8f3628d3e"}}