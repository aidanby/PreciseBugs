{"buggy_code": ["{{$NEXT}}\n\n0.29  2021-03-29\n\n- Fixed a typo in the POD.\n\n\n0.28  2021-03-29\n\n- Added docs about the security implications of using functions like\n  is_private_ip4() without _also_ calling is_ipv4() first. This was inspired\n  by a recent issue with the Node netmask package. See\n  https://sick.codes/universal-netmask-npm-package-used-by-270000-projects-vulnerable-to-octal-input-data-server-side-request-forgery-remote-file-inclusion-local-file-inclusion-and-more-cve-2021-28918/\n  for a write up.\n\n\n0.27  2016-11-17\n\n- If your version of Socket.pm provides a sane inet_pton, most of the is_*_ip\n  subroutines will use a much faster implementation. is_private_ipv4 and\n  is_private_ipv4 are approximately 16x faster. is_private_ipv6 and\n  is_public_ipv6 are about 3-4x faster.  Implemented by Greg Oschwald. GitHub\n  PR #8.\n\n\n0.26  2016-05-31\n\n- Fixed issue where invalid IPv6 strings such as ::0000000 would be marked as\n  valid by is_ipv6() when using the faster inet_pton() code path (GitHub\n  #6). Fixed by Greg Oschwald. GitHub PR #7.\n\n\n0.25  2016-02-01\n\n- Added is_ip(), is_public_ip(), is_private_ip(), is_linklocal_ip(),\n  is_loopback_ip(), and is_multicast_ip(). These are similar to the existing\n  subroutines but are IP address family agnostic. Implemented by Greg\n  Oschwald. GitHub PR #5.\n\n- The subroutines included in this module now always return a scalar when\n  called in list context. Previously they would generally return an empty list\n  when validation failed. Implemented by Greg Oschwald. GitHub PR #5.\n\n\n0.24     2014-08-28\n\n- A string with a null byte (\\0) would be considered valid if the internal\n  implementation used inet_pton() to validate IP addresses. Fixed by Greg\n  Oschwald. GitHub PR #4.\n\n\n0.23     2014-03-09\n\n- Fixed is_ipv6 to correctly fail for a string like \":abcd\" on platforms where\n  inet_pton() isn't usable. Reported by Brian Bickerton. RT #93622.\n\n- As a side effect of the above, the code to check IPv6 addresses when\n  inet_pton() isn't usable is about 7-8x times faster now.\n\n\n0.22     2013-12-05\n\n- Fixed some small doc typo/formatting issues.\n\n\n0.21     2013-12-05\n\n- The 198.51.100.0/24 and 203.0.113.0/24 networks were mistakenly put in the\n  unroutable list, rather than the testnet list. This has been fixed. Note\n  that if you've just been using is_public_ipv4 in your code, there are no\n  changes in the results.\n\n- Added the 6to4 anycast network - 192.88.99.0/24. Addresses in this network\n  are not considered public and there is now a new is_anycast_ipv4()\n  subroutine exported.\n\n- Added a number of missing reserved IPv6 networks. These are the IPv4-mapped\n  block (::ffff:0:0/96), the discard prefix (100::/64), TEREDO (2001::/32),\n  ORCHID (2001:10::/28), and documentation (2001:db8::/32) IPv6\n  networks. There are now is_ipv4_mapped_ipv6(), is_discard_ipv6(),\n  is_teredo_ipv6(), is_orchid_ipv6(), and is_documentation_ipv6() subs. Note\n  that the TEREDO and ORCHID networks are both subnets of the larger special\n  network, and as such were already excluded by is_public_ipv6(), though\n  arguably the TEREDO addresses _should_ be considered public.\n\n- Rewrote most of the docs to greatly reduce the amount of text and to improve\n  the ToC on MetaCPAN and search.cpan.org.\n\n\n0.20     2013-07-13\n\n- Add docs for the is_public_ipv6() sub that was added in 0.15. Reported by\n  Greg Oschwald.\n\n\n0.19     2013-03-13\n\n- Fix a deprecation warning that showed up with Perl 5.10.1, but not with\n  newer Perls. Reported by Iosif Fettich.\n\n\n0.18     2013-02-19\n\n- Versions 0.15 - 0.17 still had $VERSION set to 0.14. Reported by Greg\n  Oschwald.\n\n\n0.17     2013-02-19\n\n- Previous releases broke is_innet_ipv4 for many network formats. This support\n  has been restored, but only the \"a.b.c.d/nn\" CIDR form will be documented\n  going forward. All other forms are deprecated, and support for them will be\n  removed in a future release.\n\n\n0.16     2013-02-06\n\n- Made the check for Socket.pm stricter. On some platforms it exports an\n  inet_pton() that just dies when called. On other platforms it accepts\n  invalid input like '016.17.184.1' or '2067::1:'.\n\n\n0.15     2013-02-04\n\n- If your installed version of Socket.pm provides an inet_pton subroutine we\n  use that to do validation. This is about 5x faster for IPv4 addresses and 20\n  times faster for IPv6.\n\n- Various unroutable networks are now recognized as non-public\n  addresses. Based on a patch by Greg Oschwald. (Bug#83081).\n\n- Added is_unroutable_ipv4 exported sub.\n\n- Added is_public_ipv6, is_private_ipv6, is_loopback_ipv6, is_multicast_ipv6,\n  and is_special_ipv6 subroutines.\n\n- Fixed the is_linklocal_ipv6 method. It didn't recognize the full link-local\n  range properly.\n\n- Fixed bug where '::' was not recognized as a valid IPv6 address. (Bug#81700)\n\n- Fixed bug where ipv6 related subroutines were not untainting their return\n  value.\n\n\n0.14     2011-01-06\n\n- Cleaned up test suite (no code changes)\n\n\n0.13     2011-01-06\n\n- Fixed unshorted ipv6 check when ipv4 address is trailing. (Bug#64532) Thanks\n  to Milan Matlak <milan.matlak@sde.cz> for patch\n\n\n0.12     2010-12-29\n\n- Fixed parsing of trailing :: (such as 2001::), as that is valid This address\n  bug#58991 - Thanks to Alan.Chester@tekelec.com for identifying the problem.\n\n- Also fixed incorrectly treating 2001::1: as a valid IPv6 address when it\n  isn't\n\n\n0.11     2010-03-01\n\n- Added support for is_innet_ipv4 - simple check to see if IP is in network.\n  Thanks to \"Bart\u0142omiej Syryjczyk\" <bartlomiej@syryjczyk.name> for suggesting\n  the function\n\n\n0.10     2009-06-04\n\n- Added initial support for is_ipv6.  ipv6 is new territory for me, so please\n  send in your bug reports to me so that I can make sure I get it done\n  correctly.\n\n\n0.09     2009-01-30\n\n- Removed AUTOLOAD\n\n\n0.08     2007-12-06\n\n- Fixed is_ipv4 to treat leading 0's in an ip as invalid, i.e.: 017.1.1.1 is\n  invalid.  Thanks to Joshua D. Abraham <jabra@spl0it.org> for submitting the\n  patch\n\n\n0.07     2007-05-17\n\n- Added POD testing, and minor cleanup related to that\n\n\n0.06     2007-05-16\n\n- Updated contact information to be neil@neely.cx, this is a purely cosmetic change\n\n\n0.05     2007-03-06\n\n- Added is_multicast_ipv4 and is_linklocal_ipv4.  Thanks to Matt Dainty\n  <matt@bodgit-n-scarper.com> for doing all the work\n\n\n0.04     2005-04-28\n\n- Removed perl version dependency in Makefile.PL\n\n\n0.03     2005-03-04\n\n- Minor fix to pod markup\n\n\n0.02     2005-03-04\n\n- Added is_private_ipv4 is_loopback_ipv4 is_testnet_ipv4 is_public_ipv4\n\n\n0.01     2005-03-03\n\n- Original version; created by h2xs 1.23 with options -AXn Data::Validate::IP\n", "package Data::Validate::IP;\n\nuse strict;\nuse warnings;\n\nuse 5.008;\n\nour $VERSION = '0.30';\n\nuse NetAddr::IP 4;\nuse Scalar::Util qw( blessed );\n\nuse base 'Exporter';\n\n## no critic (Modules::ProhibitAutomaticExportation)\nour @EXPORT = qw(\n    is_ip\n    is_ipv4\n    is_ipv6\n    is_innet_ipv4\n);\n## use critic\n\nour $HAS_SOCKET;\n\nBEGIN {\n    local $@ = undef;\n    $HAS_SOCKET = (!$ENV{DVI_NO_SOCKET})\n        && eval {\n        require Socket;\n        Socket->import(qw( AF_INET AF_INET6 inet_pton ));\n\n        # On some platforms, Socket.pm exports an inet_pton that just dies\n        # when it is called. On others, inet_pton accepts various forms of\n        # invalid input.\n        defined &Socket::inet_pton\n            && !defined inet_pton(Socket::AF_INET(),  '016.17.184.1')\n            && !defined inet_pton(Socket::AF_INET6(), '2067::1:')\n\n            # Some old versions of Socket are hopelessly broken\n            && length(inet_pton(Socket::AF_INET(), '1.1.1.1')) == 4;\n        };\n\n    if ($HAS_SOCKET) {\n        *is_ipv4             = \\&_fast_is_ipv4;\n        *is_ipv6             = \\&_fast_is_ipv6;\n        *is_ip               = \\&_fast_is_ip;\n        *_build_is_X_ip_subs = \\&_build_fast_is_X_ip_subs;\n    }\n    else {\n        *is_ipv4             = \\&_slow_is_ipv4;\n        *is_ipv6             = \\&_slow_is_ipv6;\n        *is_ip               = \\&_slow_is_ip;\n        *_build_is_X_ip_subs = \\&_build_slow_is_X_ip_subs;\n    }\n}\n\nsub new {\n    my $class = shift;\n\n    return bless {}, $class;\n}\n\nsub _fast_is_ip {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined $value;\n    return $value =~ /:/ ? _fast_is_ipv6($value) : _fast_is_ipv4($value);\n}\n\nsub _fast_is_ipv4 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless _fast_is_ipv4_packed($value);\n\n    ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n    $value =~ /(.+)/;\n    return $1;\n}\n\nsub _fast_is_ipv4_packed {\n    my $value = shift;\n\n    return undef unless defined $value;\n    return undef if $value =~ /\\0/;\n    return inet_pton(Socket::AF_INET(), $value);\n}\n\nsub _slow_is_ip {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return _slow_is_ipv4($value) || _slow_is_ipv6($value);\n}\n\nsub _slow_is_ipv4 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined($value);\n\n    my (@octets) = $value =~ /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\n    return undef unless (@octets == 4);\n    foreach (@octets) {\n        return undef if $_ < 0 || $_ > 255;\n        return undef if $_ =~ /^0\\d{1,2}$/;\n    }\n\n    return join('.', @octets);\n}\n\nsub _fast_is_ipv6 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless _fast_is_ipv6_packed($value);\n\n    ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n    $value =~ /(.+)/;\n    return $1;\n}\n\nsub _fast_is_ipv6_packed {\n    my $value = shift;\n\n    return undef unless defined $value;\n    return undef if $value =~ /\\0/;\n    return undef if $value =~ /0[[:xdigit:]]{4}/;\n    return inet_pton(Socket::AF_INET6(), $value);\n}\n\n{\n    # This comes from Regexp::IPv6\n    ## no critic (RegularExpressions::ProhibitComplexRegexes)\n    my $ipv6_re\n        = qr/(?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))/;\n\n    sub _slow_is_ipv6 {\n        shift if ref $_[0];\n        my $value = shift;\n\n        return undef unless defined($value);\n\n        return '::' if $value eq '::';\n        return undef unless $value =~ /^$ipv6_re$/;\n\n        ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n        $value =~ /(.+)/;\n        return $1;\n    }\n}\n\n# This is just a quick test - we'll let NetAddr::IP decide if the address is\n# valid.\nmy $ip_re         = qr/\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/;\nmy $partial_ip_re = qr/\\d{1,3}(?:\\.\\d{1,3}){0,2}/;\n\n## no critic (Subroutines::ProhibitExcessComplexity, ControlStructures::ProhibitCascadingIfElse)\nsub is_innet_ipv4 {\n    shift if ref $_[0];\n    my $value   = shift;\n    my $network = shift;\n\n    return undef unless defined($value);\n\n    my $ip = is_ipv4($value);\n    return undef unless defined $ip;\n\n    # Backwards compatibility hacks to make it accept things that Net::Netmask\n    # accepts.\n    if (   $network eq 'default'\n        || $network =~ /^$ip_re$/\n        || $network =~ m{^$ip_re/\\d\\d?$}) {\n\n        $network = NetAddr::IP->new($network) or return undef;\n    }\n    elsif (!(blessed $network && $network->isa('NetAddr::IP'))) {\n        my $orig = $network;\n        if ($network =~ /^($ip_re)[:\\-]($ip_re)$/) {\n            my ($net, $netmask) = ($1, $2);\n\n            my $bits = _netmask_to_bits($netmask)\n                or return undef;\n\n            $network = \"$net/$bits\";\n        }\n        elsif ($network =~ /^($ip_re)\\#($ip_re)$/) {\n            my ($net, $hostmask) = ($1, $2);\n\n            my $bits = _hostmask_to_bits($hostmask)\n                or return undef;\n\n            $network = \"$net/$bits\";\n        }\n        elsif ($network =~ m{^($partial_ip_re)/(\\d\\d?)$}) {\n            my ($net, $bits) = ($1, $2);\n\n            # This is a hack to avoid a deprecation warning (Use of implicit\n            # split to @_ is deprecated) that shows up on 5.10.1 but not on\n            # newer Perls.\n            #\n            ## no critic(Variables::ProhibitUnusedVarsStricter)\n            my $octets = scalar(my @tmp = split /\\./, $net);\n            $network = $net;\n            $network .= '.0' x (4 - $octets);\n            $network .= \"/$bits\";\n        }\n        elsif ($network =~ /^$partial_ip_re$/) {\n\n            ## no critic(Variables::ProhibitUnusedVarsStricter)\n            my $octets = scalar(my @tmp = split /\\./, $network);\n            if ($octets < 4) {\n                $network .= '.0' x (4 - $octets);\n                $network .= '/' . $octets * 8;\n            }\n        }\n\n        if ($orig ne $network) {\n            _deprecation_warn(\n                'Use of non-CIDR notation for networks with is_innet_ipv4() is deprecated'\n            );\n        }\n\n        $network = NetAddr::IP->new($network) or return undef;\n    }\n\n    my $netaddr_ip = NetAddr::IP->new($ip) or return undef;\n\n    return $ip if $network->contains($netaddr_ip);\n    return undef;\n}\n## use critic;\n\n{\n    my %netmasks = (\n        '128.0.0.0'       => '1',\n        '192.0.0.0'       => '2',\n        '224.0.0.0'       => '3',\n        '240.0.0.0'       => '4',\n        '248.0.0.0'       => '5',\n        '252.0.0.0'       => '6',\n        '254.0.0.0'       => '7',\n        '255.0.0.0'       => '8',\n        '255.128.0.0'     => '9',\n        '255.192.0.0'     => '10',\n        '255.224.0.0'     => '11',\n        '255.240.0.0'     => '12',\n        '255.248.0.0'     => '13',\n        '255.252.0.0'     => '14',\n        '255.254.0.0'     => '15',\n        '255.255.0.0'     => '16',\n        '255.255.128.0'   => '17',\n        '255.255.192.0'   => '18',\n        '255.255.224.0'   => '19',\n        '255.255.240.0'   => '20',\n        '255.255.248.0'   => '21',\n        '255.255.252.0'   => '22',\n        '255.255.254.0'   => '23',\n        '255.255.255.0'   => '24',\n        '255.255.255.128' => '25',\n        '255.255.255.192' => '26',\n        '255.255.255.224' => '27',\n        '255.255.255.240' => '28',\n        '255.255.255.248' => '29',\n        '255.255.255.252' => '30',\n        '255.255.255.254' => '31',\n        '255.255.255.255' => '32',\n    );\n\n    sub _netmask_to_bits {\n        return $netmasks{ $_[0] };\n    }\n}\n\n{\n    my %hostmasks = (\n        '255.255.255.255' => 0,\n        '127.255.255.255' => 1,\n        '63.255.255.255'  => 2,\n        '31.255.255.255'  => 3,\n        '15.255.255.255'  => 4,\n        '7.255.255.255'   => 5,\n        '3.255.255.255'   => 6,\n        '1.255.255.255'   => 7,\n        '0.255.255.255'   => 8,\n        '0.127.255.255'   => 9,\n        '0.63.255.255'    => 10,\n        '0.31.255.255'    => 11,\n        '0.15.255.255'    => 12,\n        '0.7.255.255'     => 13,\n        '0.3.255.255'     => 14,\n        '0.1.255.255'     => 15,\n        '0.0.255.255'     => 16,\n        '0.0.127.255'     => 17,\n        '0.0.63.255'      => 18,\n        '0.0.31.255'      => 19,\n        '0.0.15.255'      => 20,\n        '0.0.7.255'       => 21,\n        '0.0.3.255'       => 22,\n        '0.0.1.255'       => 23,\n        '0.0.0.255'       => 24,\n        '0.0.0.127'       => 25,\n        '0.0.0.63'        => 26,\n        '0.0.0.31'        => 27,\n        '0.0.0.15'        => 28,\n        '0.0.0.7'         => 29,\n        '0.0.0.3'         => 30,\n        '0.0.0.1'         => 31,\n        '0.0.0.0'         => 32,\n    );\n\n    sub _hostmask_to_bits {\n        return $hostmasks{ $_[0] };\n    }\n}\n\n{\n    my %warned_at;\n\n    sub _deprecation_warn {\n        my $warning = shift;\n        my @caller  = caller(2);\n\n        my $caller_info\n            = \"at line $caller[2] of $caller[0] in sub $caller[3]\";\n\n        return undef if $warned_at{$warning}{$caller_info}++;\n\n        warn \"$warning $caller_info\\n\";\n    }\n}\n\n{\n    my %ipv4_networks = (\n        loopback => { networks => '127.0.0.0/8' },\n        private  => {\n            networks => [\n                qw(\n                    10.0.0.0/8\n                    172.16.0.0/12\n                    192.168.0.0/16\n                )\n            ],\n        },\n        testnet => {\n            networks => [\n                qw(\n                    192.0.2.0/24\n                    198.51.100.0/24\n                    203.0.113.0/24\n                )\n            ],\n        },\n        anycast    => { networks => '192.88.99.0/24' },\n        multicast  => { networks => '224.0.0.0/4' },\n        linklocal  => { networks => '169.254.0.0/16' },\n        unroutable => {\n            networks => [\n                qw(\n                    0.0.0.0/8\n                    100.64.0.0/10\n                    192.0.0.0/29\n                    198.18.0.0/15\n                    240.0.0.0/4\n                )\n            ],\n        },\n    );\n\n    _build_is_X_ip_subs(\\%ipv4_networks, 4);\n}\n\n{\n    my %ipv6_networks = (\n        loopback    => { networks => '::1/128' },\n        ipv4_mapped => { networks => '::ffff:0:0/96' },\n        discard     => { networks => '100::/64' },\n        special     => { networks => '2001::/23' },\n        teredo      => {\n            networks  => '2001::/32',\n            subnet_of => 'special',\n        },\n        orchid => {\n            networks  => '2001:10::/28',\n            subnet_of => 'special',\n        },\n        documentation => { networks => '2001:db8::/32' },\n        private       => { networks => 'fc00::/7' },\n        linklocal     => { networks => 'fe80::/10' },\n        multicast     => { networks => 'ff00::/8' },\n    );\n\n    _build_is_X_ip_subs(\\%ipv6_networks, 6);\n\n    # This exists for the benefit of the test code.\n    ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)\n    sub _network_is_subnet_of {\n        my $network = shift;\n        my $other   = shift;\n\n        return ($ipv6_networks{$network}{subnet_of} || q{}) eq $other;\n    }\n}\n\n## no critic (TestingAndDebugging::ProhibitNoStrict, BuiltinFunctions::ProhibitStringyEval)\nsub _build_slow_is_X_ip_subs {\n    my $networks  = shift;\n    my $ip_number = shift;\n\n    my $is_ip_sub   = $ip_number == 4 ? 'is_ipv4' : 'is_ipv6';\n    my $netaddr_new = $ip_number == 4 ? 'new'     : 'new6';\n\n    my @all_nets;\n\n    local $@ = undef;\n    for my $type (keys %{$networks}) {\n        my @nets\n            = map { NetAddr::IP->$netaddr_new($_) }\n            ref $networks->{$type}{networks}\n            ? @{ $networks->{$type}{networks} }\n            : $networks->{$type}{networks};\n\n        # Some IPv6 networks (like TEREDO) are a subset of the special block\n        # so there's no point in checking for them in the is_public_ipv6()\n        # sub.\n        unless ($networks->{$type}{subnet_of}) {\n            push @all_nets, @nets;\n        }\n\n        # We're using code gen rather than just making an anon sub outright so\n        # we don't have to pay the cost of derefencing the $is_ip_sub and the\n        # dynamic dispatch cost for $netaddr_new\n        my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined $value;\n\n    my $ip = %s($value);\n    return undef unless defined $ip;\n\n    my $netaddr_ip = NetAddr::IP->%s($ip);\n    for my $net (@nets) {\n        return $ip if $net->contains($netaddr_ip);\n    }\n    return undef;\n}\nEOF\n        die $@ if $@;\n\n        my $sub_name = 'is_' . $type . '_ipv' . $ip_number;\n        {\n            no strict 'refs';\n            *{$sub_name} = $sub;\n        }\n        push @EXPORT, $sub_name;\n    }\n\n    my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined($value);\n\n    my $ip = %s($value);\n    return undef unless defined $ip;\n\n    my $netaddr_ip = NetAddr::IP->%s($ip);\n    for my $net (@all_nets) {\n        return undef if $net->contains($netaddr_ip);\n    }\n\n    return $ip;\n}\nEOF\n    die $@ if $@;\n\n    my $sub_name = 'is_public_ipv' . $ip_number;\n    {\n        no strict 'refs';\n        *{$sub_name} = $sub;\n    }\n    push @EXPORT, $sub_name;\n}\n\nsub _build_fast_is_X_ip_subs {\n    my $networks  = shift;\n    my $ip_number = shift;\n\n    my $family = $ip_number == 4 ? Socket::AF_INET() : Socket::AF_INET6();\n\n    my @all_nets;\n\n    local $@ = undef;\n    for my $type (keys %{$networks}) {\n        my @nets\n            = map { _packed_network_and_netmask($family, $_) }\n            ref $networks->{$type}{networks}\n            ? @{ $networks->{$type}{networks} }\n            : $networks->{$type}{networks};\n\n        # Some IPv6 networks (like TEREDO) are a subset of the special block\n        # so there's no point in checking for them in the is_public_ipv6()\n        # sub.\n        unless ($networks->{$type}{subnet_of}) {\n            push @all_nets, @nets;\n        }\n\n        # We're using code gen rather than just making an anon sub outright so\n        # we don't have to pay the cost of derefencing the $is_ip_sub and the\n        # dynamic dispatch cost for $netaddr_new\n        my $sub = eval sprintf( <<'EOF', $ip_number);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    my $ip = _fast_is_ipv%u_packed($value);\n\n    return undef unless defined $ip;\n\n    for my $net (@nets) {\n        if (($net->[1] & $ip) eq $net->[0]) {\n            $value =~ /(.+)/;\n            return $1;\n        }\n    }\n    return undef;\n}\nEOF\n        die $@ if $@;\n\n        my $sub_name = 'is_' . $type . '_ipv' . $ip_number;\n        {\n            no strict 'refs';\n            *{$sub_name} = $sub;\n        }\n        push @EXPORT, $sub_name;\n    }\n\n    my $sub = eval sprintf( <<'EOF', $ip_number);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    my $ip = _fast_is_ipv%u_packed($value);\n\n    return undef unless defined $ip;\n\n    for my $net (@all_nets) {\n        return undef if ($net->[1] & $ip) eq $net->[0];\n    }\n\n    $value =~ /(.+)/;\n    return $1;\n}\nEOF\n    die $@ if $@;\n\n    my $sub_name = 'is_public_ipv' . $ip_number;\n    {\n        no strict 'refs';\n        *{$sub_name} = $sub;\n    }\n    push @EXPORT, $sub_name;\n}\n\nsub _packed_network_and_netmask {\n    my $family  = shift;\n    my $network = shift;\n\n    my ($ip, $bits) = split qr{/}, $network, 2;\n\n    return [\n        inet_pton($family, $ip),\n        _packed_netmask($family, $bits)\n    ];\n}\n\nsub _packed_netmask {\n    my $family = shift;\n    my $bits   = shift;\n\n    my $bit_length = $family == Socket::AF_INET() ? 32 : 128;\n\n    my $bit_string\n        = join(q{}, (1) x $bits, (0) x ($bit_length - $bits));\n    return pack('B' . $bit_length, $bit_string);\n}\n\nfor my $sub (qw( linklocal loopback multicast private public )) {\n    my $sub_name = \"is_${sub}_ip\";\n\n    {\n        no strict 'refs';\n        *{$sub_name}\n            = eval \"sub { ${sub_name}v4(\\@_) || ${sub_name}v6(\\@_) }\";\n        die $@ if $@;\n    }\n\n    push @EXPORT, $sub_name;\n}\n## use critic\n\n1;\n\n# ABSTRACT: IPv4 and IPv6 validation methods\n\n__END__\n\n=pod\n\n=head1 SYNOPSIS\n\n  use Data::Validate::IP qw(is_ipv4 is_ipv6);\n\n  my $suspect = '1.2.3.4';\n  if (is_ipv4($suspect)) {\n      print \"Looks like an IPv4 address\";\n  }\n  else {\n      print \"Not an IPv4 address\\n\";\n  }\n\n  $suspect = '::1234';\n  if (is_ipv6($suspect)) {\n      print \"Looks like an IPv6 address\";\n  }\n  else {\n      print \"Not an IPv6 address\\n\";\n  }\n\n=head1 DESCRIPTION\n\nThis module provides a number IP address validation subs that both validate\nand untaint their input. This includes both basic validation (C<is_ipv4()> and\nC<is_ipv6()>) and special cases like checking whether an address belongs to a\nspecific network or whether an address is public or private (reserved).\n\n=head1 USAGE AND SECURITY RECOMMENDATIONS\n\nIt's important to understand that if C<is_ipv4($ip)> or C<is_ipv6($ip)> return\nfalse, then all other validation functions for that IP address family will\nI<also> return false. So for example, if C<is_ipv4($ip)> is false, so are both\nC<is_private_ipv4($ip)> I<and> C<is_public_ipv4($ip)>.\n\nThis means that simply calling C<is_private_ipv4($ip)> by itself is not\nsufficient if you are dealing with untrusted input. You should always check\nC<is_ipv4($ip)> as well.\n\nThere are security implications to this around certain oddly formed\naddresses. Notably, an address like \"010.0.0.1\" is technically valid, but the\noperating system will treat \"010\" as an octal number. That means that\n\"010.0.0.1\" is equivalent to \"8.0.0.1\", I<not> \"10.0.0.1\".\n\nHowever, this module's C<is_ipv4($ip)> function will return false for\naddresses like \"010.0.0.1\" which have octal components. And of course that\nmeans that it also returns false for C<is_private_ipv4($ip)> I<and>\nC<is_public_ipv4($ip)>.\n\n=head1 FUNCTIONS\n\nAll of the functions below are exported by default.\n\nAll functions return an untainted value if the test passes and undef if it\nfails. In theory, this means that you should always check for a defined status\nexplicitly but in practice there are no valid IP addresses where the string\nform evaluates to false in Perl.\n\nNote that none of these functions actually attempt to test whether the given\nIP address is routable from your device; they are purely semantic checks.\n\n=head2 is_ipv4($ip), is_ipv6($ip), is_ip($ip)\n\nThese functions simply check whether the address is a valid IPv4 or IPv6 address.\n\n=head2 is_innet_ipv4($ip, $network)\n\nThis subroutine checks whether the address belongs to the given IPv4\nnetwork. The C<$network> argument can either be a string in CIDR notation like\n\"15.0.15.0/24\" or a L<NetAddr::IP> object.\n\nThis subroutine used to accept many more forms of network specifications\n(anything L<Net::Netmask> accepts) but this has been deprecated.\n\n=head2 is_unroutable_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of several special\nuse IPv4 networks - C<0.0.0.0/8>, C<100.64.0.0/10>, C<192.0.0.0/29>,\nC<198.18.0.0/15>, C<240.0.0.0/4> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>, L<RFC\n6333|http://tools.ietf.org/html/rfc6333>, and L<RFC\n6958|http://tools.ietf.org/html/rfc6598>.\n\nArguably, these should be broken down further but this subroutine will always\nexist for backwards compatibility.\n\n=head2 is_private_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of the private IPv4\nnetworks - C<10.0.0.0/8>, C<172.16.0.0/12>, C<192.168.0.0/16> - as defined by\nL<RFC 5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_loopback_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 loopback\nnetwork - C<127.0.0.0/8> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_linklocal_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 link local\nnetwork - C<169.254.0.0/16> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_testnet_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of the IPv4 TEST-NET\nnetworks for use in documentation and example code - C<192.0.2.0/24>,\nC<198.51.100.0/24>, and C<203.0.113.0/24> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_anycast_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the 6to4 relay anycast\nnetwork - C<192.88.99.0/24> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_multicast_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 multicast\nnetwork - C<224.0.0.0/4> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_loopback_ipv6($ip)\n\nThis subroutine checks whether the address is the IPv6 loopback address -\nC<::1/128> - as defined by L<RFC 4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_ipv4_mapped_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 IPv4-mapped\naddress network - C<::ffff:0:0/96> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_discard_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 discard prefix\nnetwork - C<100::/64> - as defined by L<RFC\n6666|http://tools.ietf.org/html/rfc6666>.\n\n=head2 is_special_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 special network\n- C<2001::/23> - as defined by L<RFC 2928|http://tools.ietf.org/html/rfc2928>.\n\n=head2 is_teredo_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 TEREDO network\n- C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.\n\nNote that this network is a subnet of the larger special network at\nC<2001::/23>.\n\n=head2 is_orchid_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 ORCHID network\n- C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.\n\nNote that this network is a subnet of the larger special network at\nC<2001::/23>.\n\nThis network is currently scheduled to be returned to the special pool in\nMarch of 2014 unless the IETF extends its use. If that happens this subroutine\nwill continue to exist but will always return false.\n\n=head2 is_documentation_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 documentation\nnetwork - C<2001:DB8::/32> - as defined by L<RFC\n3849|http://tools.ietf.org/html/rfc3849>.\n\n=head2 is_private_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 private network\n- C<FC00::/7> - as defined by L<RFC 4193|http://tools.ietf.org/html/rfc4193>.\n\n=head2 is_linklocal_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 link-local\nunicast network - C<FE80::/10> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_multicast_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 multicast\nnetwork - C<FF00::/8> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_public_ipv4($ip), is_public_ipv6($ip), is_public_ip($ip)\n\nThese subroutines check whether the given IP address belongs to any of the\nspecial case networks defined previously. Note that this is B<not> simply the\nopposite of checking C<is_private_ipv4()> or C<is_private_ipv6()>. The private\nnetworks are a subset of all the special case networks.\n\n=head2 is_linklocal_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6\nlink-local unicast network.\n\n=head2 is_loopback_ip($ip)\n\nThis subroutine checks whether the address is the IPv4 or IPv6 loopback\naddress.\n\n=head2 is_multicast_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6\nmulticast network.\n\n=head2 is_private_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6 private\nnetwork.\n\n=for Pod::Coverage new\n\n=head1 OBJECT-ORIENTED INTERFACE\n\nThis module can also be used as a class. You can call C<<\nData::Validate::IP->new() >> to get an object and then call any of the\nvalidation subroutines as methods on that object. This is somewhat pointless\nsince the object will never contain any state but this interface is kept for\nbackwards compatibility.\n\n=head1 SEE ALSO\n\nIPv4\n\nB<[RFC 5735] [RFC 1918]>\n\nIPv6\n\nB<[RFC 2460] [RFC 4193] [RFC 4291] [RFC 6434]>\n\n=head1 BUGS\n\nPlease report any bugs or feature requests to\nC<bug-data-validate-ip@rt.cpan.org>, or through the web interface at\nL<http://rt.cpan.org>. I will be notified, and then you'll automatically be\nnotified of progress on your bug as I make changes.\n\n=head1 ACKNOWLEDGEMENTS\n\nThanks to Richard Sonnen <F<sonnen@richardsonnen.com>> for writing the\nData::Validate module.\n\nThanks to Matt Dainty <F<matt@bodgit-n-scarper.com>> for adding the\nC<is_multicast_ipv4()> and C<is_linklocal_ipv4()> code.\n\n=cut\n"], "fixing_code": ["{{$NEXT}}\n\n- Added some more details to the security docs to include mentions of the\n  is_*_ip() functions too.\n\n\n0.29  2021-03-29\n\n- Fixed a typo in the POD.\n\n\n0.28  2021-03-29\n\n- Added docs about the security implications of using functions like\n  is_private_ip4() without _also_ calling is_ipv4() first. This was inspired\n  by a recent issue with the Node netmask package. See\n  https://sick.codes/universal-netmask-npm-package-used-by-270000-projects-vulnerable-to-octal-input-data-server-side-request-forgery-remote-file-inclusion-local-file-inclusion-and-more-cve-2021-28918/\n  for a write up.\n\n\n0.27  2016-11-17\n\n- If your version of Socket.pm provides a sane inet_pton, most of the is_*_ip\n  subroutines will use a much faster implementation. is_private_ipv4 and\n  is_private_ipv4 are approximately 16x faster. is_private_ipv6 and\n  is_public_ipv6 are about 3-4x faster.  Implemented by Greg Oschwald. GitHub\n  PR #8.\n\n\n0.26  2016-05-31\n\n- Fixed issue where invalid IPv6 strings such as ::0000000 would be marked as\n  valid by is_ipv6() when using the faster inet_pton() code path (GitHub\n  #6). Fixed by Greg Oschwald. GitHub PR #7.\n\n\n0.25  2016-02-01\n\n- Added is_ip(), is_public_ip(), is_private_ip(), is_linklocal_ip(),\n  is_loopback_ip(), and is_multicast_ip(). These are similar to the existing\n  subroutines but are IP address family agnostic. Implemented by Greg\n  Oschwald. GitHub PR #5.\n\n- The subroutines included in this module now always return a scalar when\n  called in list context. Previously they would generally return an empty list\n  when validation failed. Implemented by Greg Oschwald. GitHub PR #5.\n\n\n0.24     2014-08-28\n\n- A string with a null byte (\\0) would be considered valid if the internal\n  implementation used inet_pton() to validate IP addresses. Fixed by Greg\n  Oschwald. GitHub PR #4.\n\n\n0.23     2014-03-09\n\n- Fixed is_ipv6 to correctly fail for a string like \":abcd\" on platforms where\n  inet_pton() isn't usable. Reported by Brian Bickerton. RT #93622.\n\n- As a side effect of the above, the code to check IPv6 addresses when\n  inet_pton() isn't usable is about 7-8x times faster now.\n\n\n0.22     2013-12-05\n\n- Fixed some small doc typo/formatting issues.\n\n\n0.21     2013-12-05\n\n- The 198.51.100.0/24 and 203.0.113.0/24 networks were mistakenly put in the\n  unroutable list, rather than the testnet list. This has been fixed. Note\n  that if you've just been using is_public_ipv4 in your code, there are no\n  changes in the results.\n\n- Added the 6to4 anycast network - 192.88.99.0/24. Addresses in this network\n  are not considered public and there is now a new is_anycast_ipv4()\n  subroutine exported.\n\n- Added a number of missing reserved IPv6 networks. These are the IPv4-mapped\n  block (::ffff:0:0/96), the discard prefix (100::/64), TEREDO (2001::/32),\n  ORCHID (2001:10::/28), and documentation (2001:db8::/32) IPv6\n  networks. There are now is_ipv4_mapped_ipv6(), is_discard_ipv6(),\n  is_teredo_ipv6(), is_orchid_ipv6(), and is_documentation_ipv6() subs. Note\n  that the TEREDO and ORCHID networks are both subnets of the larger special\n  network, and as such were already excluded by is_public_ipv6(), though\n  arguably the TEREDO addresses _should_ be considered public.\n\n- Rewrote most of the docs to greatly reduce the amount of text and to improve\n  the ToC on MetaCPAN and search.cpan.org.\n\n\n0.20     2013-07-13\n\n- Add docs for the is_public_ipv6() sub that was added in 0.15. Reported by\n  Greg Oschwald.\n\n\n0.19     2013-03-13\n\n- Fix a deprecation warning that showed up with Perl 5.10.1, but not with\n  newer Perls. Reported by Iosif Fettich.\n\n\n0.18     2013-02-19\n\n- Versions 0.15 - 0.17 still had $VERSION set to 0.14. Reported by Greg\n  Oschwald.\n\n\n0.17     2013-02-19\n\n- Previous releases broke is_innet_ipv4 for many network formats. This support\n  has been restored, but only the \"a.b.c.d/nn\" CIDR form will be documented\n  going forward. All other forms are deprecated, and support for them will be\n  removed in a future release.\n\n\n0.16     2013-02-06\n\n- Made the check for Socket.pm stricter. On some platforms it exports an\n  inet_pton() that just dies when called. On other platforms it accepts\n  invalid input like '016.17.184.1' or '2067::1:'.\n\n\n0.15     2013-02-04\n\n- If your installed version of Socket.pm provides an inet_pton subroutine we\n  use that to do validation. This is about 5x faster for IPv4 addresses and 20\n  times faster for IPv6.\n\n- Various unroutable networks are now recognized as non-public\n  addresses. Based on a patch by Greg Oschwald. (Bug#83081).\n\n- Added is_unroutable_ipv4 exported sub.\n\n- Added is_public_ipv6, is_private_ipv6, is_loopback_ipv6, is_multicast_ipv6,\n  and is_special_ipv6 subroutines.\n\n- Fixed the is_linklocal_ipv6 method. It didn't recognize the full link-local\n  range properly.\n\n- Fixed bug where '::' was not recognized as a valid IPv6 address. (Bug#81700)\n\n- Fixed bug where ipv6 related subroutines were not untainting their return\n  value.\n\n\n0.14     2011-01-06\n\n- Cleaned up test suite (no code changes)\n\n\n0.13     2011-01-06\n\n- Fixed unshorted ipv6 check when ipv4 address is trailing. (Bug#64532) Thanks\n  to Milan Matlak <milan.matlak@sde.cz> for patch\n\n\n0.12     2010-12-29\n\n- Fixed parsing of trailing :: (such as 2001::), as that is valid This address\n  bug#58991 - Thanks to Alan.Chester@tekelec.com for identifying the problem.\n\n- Also fixed incorrectly treating 2001::1: as a valid IPv6 address when it\n  isn't\n\n\n0.11     2010-03-01\n\n- Added support for is_innet_ipv4 - simple check to see if IP is in network.\n  Thanks to \"Bart\u0142omiej Syryjczyk\" <bartlomiej@syryjczyk.name> for suggesting\n  the function\n\n\n0.10     2009-06-04\n\n- Added initial support for is_ipv6.  ipv6 is new territory for me, so please\n  send in your bug reports to me so that I can make sure I get it done\n  correctly.\n\n\n0.09     2009-01-30\n\n- Removed AUTOLOAD\n\n\n0.08     2007-12-06\n\n- Fixed is_ipv4 to treat leading 0's in an ip as invalid, i.e.: 017.1.1.1 is\n  invalid.  Thanks to Joshua D. Abraham <jabra@spl0it.org> for submitting the\n  patch\n\n\n0.07     2007-05-17\n\n- Added POD testing, and minor cleanup related to that\n\n\n0.06     2007-05-16\n\n- Updated contact information to be neil@neely.cx, this is a purely cosmetic change\n\n\n0.05     2007-03-06\n\n- Added is_multicast_ipv4 and is_linklocal_ipv4.  Thanks to Matt Dainty\n  <matt@bodgit-n-scarper.com> for doing all the work\n\n\n0.04     2005-04-28\n\n- Removed perl version dependency in Makefile.PL\n\n\n0.03     2005-03-04\n\n- Minor fix to pod markup\n\n\n0.02     2005-03-04\n\n- Added is_private_ipv4 is_loopback_ipv4 is_testnet_ipv4 is_public_ipv4\n\n\n0.01     2005-03-03\n\n- Original version; created by h2xs 1.23 with options -AXn Data::Validate::IP\n", "package Data::Validate::IP;\n\nuse strict;\nuse warnings;\n\nuse 5.008;\n\nour $VERSION = '0.30';\n\nuse NetAddr::IP 4;\nuse Scalar::Util qw( blessed );\n\nuse base 'Exporter';\n\n## no critic (Modules::ProhibitAutomaticExportation)\nour @EXPORT = qw(\n    is_ip\n    is_ipv4\n    is_ipv6\n    is_innet_ipv4\n);\n## use critic\n\nour $HAS_SOCKET;\n\nBEGIN {\n    local $@ = undef;\n    $HAS_SOCKET = (!$ENV{DVI_NO_SOCKET})\n        && eval {\n        require Socket;\n        Socket->import(qw( AF_INET AF_INET6 inet_pton ));\n\n        # On some platforms, Socket.pm exports an inet_pton that just dies\n        # when it is called. On others, inet_pton accepts various forms of\n        # invalid input.\n        defined &Socket::inet_pton\n            && !defined inet_pton(Socket::AF_INET(),  '016.17.184.1')\n            && !defined inet_pton(Socket::AF_INET6(), '2067::1:')\n\n            # Some old versions of Socket are hopelessly broken\n            && length(inet_pton(Socket::AF_INET(), '1.1.1.1')) == 4;\n        };\n\n    if ($HAS_SOCKET) {\n        *is_ipv4             = \\&_fast_is_ipv4;\n        *is_ipv6             = \\&_fast_is_ipv6;\n        *is_ip               = \\&_fast_is_ip;\n        *_build_is_X_ip_subs = \\&_build_fast_is_X_ip_subs;\n    }\n    else {\n        *is_ipv4             = \\&_slow_is_ipv4;\n        *is_ipv6             = \\&_slow_is_ipv6;\n        *is_ip               = \\&_slow_is_ip;\n        *_build_is_X_ip_subs = \\&_build_slow_is_X_ip_subs;\n    }\n}\n\nsub new {\n    my $class = shift;\n\n    return bless {}, $class;\n}\n\nsub _fast_is_ip {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined $value;\n    return $value =~ /:/ ? _fast_is_ipv6($value) : _fast_is_ipv4($value);\n}\n\nsub _fast_is_ipv4 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless _fast_is_ipv4_packed($value);\n\n    ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n    $value =~ /(.+)/;\n    return $1;\n}\n\nsub _fast_is_ipv4_packed {\n    my $value = shift;\n\n    return undef unless defined $value;\n    return undef if $value =~ /\\0/;\n    return inet_pton(Socket::AF_INET(), $value);\n}\n\nsub _slow_is_ip {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return _slow_is_ipv4($value) || _slow_is_ipv6($value);\n}\n\nsub _slow_is_ipv4 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined($value);\n\n    my (@octets) = $value =~ /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\n    return undef unless (@octets == 4);\n    foreach (@octets) {\n        return undef if $_ < 0 || $_ > 255;\n        return undef if $_ =~ /^0\\d{1,2}$/;\n    }\n\n    return join('.', @octets);\n}\n\nsub _fast_is_ipv6 {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless _fast_is_ipv6_packed($value);\n\n    ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n    $value =~ /(.+)/;\n    return $1;\n}\n\nsub _fast_is_ipv6_packed {\n    my $value = shift;\n\n    return undef unless defined $value;\n    return undef if $value =~ /\\0/;\n    return undef if $value =~ /0[[:xdigit:]]{4}/;\n    return inet_pton(Socket::AF_INET6(), $value);\n}\n\n{\n    # This comes from Regexp::IPv6\n    ## no critic (RegularExpressions::ProhibitComplexRegexes)\n    my $ipv6_re\n        = qr/(?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))/;\n\n    sub _slow_is_ipv6 {\n        shift if ref $_[0];\n        my $value = shift;\n\n        return undef unless defined($value);\n\n        return '::' if $value eq '::';\n        return undef unless $value =~ /^$ipv6_re$/;\n\n        ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)\n        $value =~ /(.+)/;\n        return $1;\n    }\n}\n\n# This is just a quick test - we'll let NetAddr::IP decide if the address is\n# valid.\nmy $ip_re         = qr/\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/;\nmy $partial_ip_re = qr/\\d{1,3}(?:\\.\\d{1,3}){0,2}/;\n\n## no critic (Subroutines::ProhibitExcessComplexity, ControlStructures::ProhibitCascadingIfElse)\nsub is_innet_ipv4 {\n    shift if ref $_[0];\n    my $value   = shift;\n    my $network = shift;\n\n    return undef unless defined($value);\n\n    my $ip = is_ipv4($value);\n    return undef unless defined $ip;\n\n    # Backwards compatibility hacks to make it accept things that Net::Netmask\n    # accepts.\n    if (   $network eq 'default'\n        || $network =~ /^$ip_re$/\n        || $network =~ m{^$ip_re/\\d\\d?$}) {\n\n        $network = NetAddr::IP->new($network) or return undef;\n    }\n    elsif (!(blessed $network && $network->isa('NetAddr::IP'))) {\n        my $orig = $network;\n        if ($network =~ /^($ip_re)[:\\-]($ip_re)$/) {\n            my ($net, $netmask) = ($1, $2);\n\n            my $bits = _netmask_to_bits($netmask)\n                or return undef;\n\n            $network = \"$net/$bits\";\n        }\n        elsif ($network =~ /^($ip_re)\\#($ip_re)$/) {\n            my ($net, $hostmask) = ($1, $2);\n\n            my $bits = _hostmask_to_bits($hostmask)\n                or return undef;\n\n            $network = \"$net/$bits\";\n        }\n        elsif ($network =~ m{^($partial_ip_re)/(\\d\\d?)$}) {\n            my ($net, $bits) = ($1, $2);\n\n            # This is a hack to avoid a deprecation warning (Use of implicit\n            # split to @_ is deprecated) that shows up on 5.10.1 but not on\n            # newer Perls.\n            #\n            ## no critic(Variables::ProhibitUnusedVarsStricter)\n            my $octets = scalar(my @tmp = split /\\./, $net);\n            $network = $net;\n            $network .= '.0' x (4 - $octets);\n            $network .= \"/$bits\";\n        }\n        elsif ($network =~ /^$partial_ip_re$/) {\n\n            ## no critic(Variables::ProhibitUnusedVarsStricter)\n            my $octets = scalar(my @tmp = split /\\./, $network);\n            if ($octets < 4) {\n                $network .= '.0' x (4 - $octets);\n                $network .= '/' . $octets * 8;\n            }\n        }\n\n        if ($orig ne $network) {\n            _deprecation_warn(\n                'Use of non-CIDR notation for networks with is_innet_ipv4() is deprecated'\n            );\n        }\n\n        $network = NetAddr::IP->new($network) or return undef;\n    }\n\n    my $netaddr_ip = NetAddr::IP->new($ip) or return undef;\n\n    return $ip if $network->contains($netaddr_ip);\n    return undef;\n}\n## use critic;\n\n{\n    my %netmasks = (\n        '128.0.0.0'       => '1',\n        '192.0.0.0'       => '2',\n        '224.0.0.0'       => '3',\n        '240.0.0.0'       => '4',\n        '248.0.0.0'       => '5',\n        '252.0.0.0'       => '6',\n        '254.0.0.0'       => '7',\n        '255.0.0.0'       => '8',\n        '255.128.0.0'     => '9',\n        '255.192.0.0'     => '10',\n        '255.224.0.0'     => '11',\n        '255.240.0.0'     => '12',\n        '255.248.0.0'     => '13',\n        '255.252.0.0'     => '14',\n        '255.254.0.0'     => '15',\n        '255.255.0.0'     => '16',\n        '255.255.128.0'   => '17',\n        '255.255.192.0'   => '18',\n        '255.255.224.0'   => '19',\n        '255.255.240.0'   => '20',\n        '255.255.248.0'   => '21',\n        '255.255.252.0'   => '22',\n        '255.255.254.0'   => '23',\n        '255.255.255.0'   => '24',\n        '255.255.255.128' => '25',\n        '255.255.255.192' => '26',\n        '255.255.255.224' => '27',\n        '255.255.255.240' => '28',\n        '255.255.255.248' => '29',\n        '255.255.255.252' => '30',\n        '255.255.255.254' => '31',\n        '255.255.255.255' => '32',\n    );\n\n    sub _netmask_to_bits {\n        return $netmasks{ $_[0] };\n    }\n}\n\n{\n    my %hostmasks = (\n        '255.255.255.255' => 0,\n        '127.255.255.255' => 1,\n        '63.255.255.255'  => 2,\n        '31.255.255.255'  => 3,\n        '15.255.255.255'  => 4,\n        '7.255.255.255'   => 5,\n        '3.255.255.255'   => 6,\n        '1.255.255.255'   => 7,\n        '0.255.255.255'   => 8,\n        '0.127.255.255'   => 9,\n        '0.63.255.255'    => 10,\n        '0.31.255.255'    => 11,\n        '0.15.255.255'    => 12,\n        '0.7.255.255'     => 13,\n        '0.3.255.255'     => 14,\n        '0.1.255.255'     => 15,\n        '0.0.255.255'     => 16,\n        '0.0.127.255'     => 17,\n        '0.0.63.255'      => 18,\n        '0.0.31.255'      => 19,\n        '0.0.15.255'      => 20,\n        '0.0.7.255'       => 21,\n        '0.0.3.255'       => 22,\n        '0.0.1.255'       => 23,\n        '0.0.0.255'       => 24,\n        '0.0.0.127'       => 25,\n        '0.0.0.63'        => 26,\n        '0.0.0.31'        => 27,\n        '0.0.0.15'        => 28,\n        '0.0.0.7'         => 29,\n        '0.0.0.3'         => 30,\n        '0.0.0.1'         => 31,\n        '0.0.0.0'         => 32,\n    );\n\n    sub _hostmask_to_bits {\n        return $hostmasks{ $_[0] };\n    }\n}\n\n{\n    my %warned_at;\n\n    sub _deprecation_warn {\n        my $warning = shift;\n        my @caller  = caller(2);\n\n        my $caller_info\n            = \"at line $caller[2] of $caller[0] in sub $caller[3]\";\n\n        return undef if $warned_at{$warning}{$caller_info}++;\n\n        warn \"$warning $caller_info\\n\";\n    }\n}\n\n{\n    my %ipv4_networks = (\n        loopback => { networks => '127.0.0.0/8' },\n        private  => {\n            networks => [\n                qw(\n                    10.0.0.0/8\n                    172.16.0.0/12\n                    192.168.0.0/16\n                )\n            ],\n        },\n        testnet => {\n            networks => [\n                qw(\n                    192.0.2.0/24\n                    198.51.100.0/24\n                    203.0.113.0/24\n                )\n            ],\n        },\n        anycast    => { networks => '192.88.99.0/24' },\n        multicast  => { networks => '224.0.0.0/4' },\n        linklocal  => { networks => '169.254.0.0/16' },\n        unroutable => {\n            networks => [\n                qw(\n                    0.0.0.0/8\n                    100.64.0.0/10\n                    192.0.0.0/29\n                    198.18.0.0/15\n                    240.0.0.0/4\n                )\n            ],\n        },\n    );\n\n    _build_is_X_ip_subs(\\%ipv4_networks, 4);\n}\n\n{\n    my %ipv6_networks = (\n        loopback    => { networks => '::1/128' },\n        ipv4_mapped => { networks => '::ffff:0:0/96' },\n        discard     => { networks => '100::/64' },\n        special     => { networks => '2001::/23' },\n        teredo      => {\n            networks  => '2001::/32',\n            subnet_of => 'special',\n        },\n        orchid => {\n            networks  => '2001:10::/28',\n            subnet_of => 'special',\n        },\n        documentation => { networks => '2001:db8::/32' },\n        private       => { networks => 'fc00::/7' },\n        linklocal     => { networks => 'fe80::/10' },\n        multicast     => { networks => 'ff00::/8' },\n    );\n\n    _build_is_X_ip_subs(\\%ipv6_networks, 6);\n\n    # This exists for the benefit of the test code.\n    ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)\n    sub _network_is_subnet_of {\n        my $network = shift;\n        my $other   = shift;\n\n        return ($ipv6_networks{$network}{subnet_of} || q{}) eq $other;\n    }\n}\n\n## no critic (TestingAndDebugging::ProhibitNoStrict, BuiltinFunctions::ProhibitStringyEval)\nsub _build_slow_is_X_ip_subs {\n    my $networks  = shift;\n    my $ip_number = shift;\n\n    my $is_ip_sub   = $ip_number == 4 ? 'is_ipv4' : 'is_ipv6';\n    my $netaddr_new = $ip_number == 4 ? 'new'     : 'new6';\n\n    my @all_nets;\n\n    local $@ = undef;\n    for my $type (keys %{$networks}) {\n        my @nets\n            = map { NetAddr::IP->$netaddr_new($_) }\n            ref $networks->{$type}{networks}\n            ? @{ $networks->{$type}{networks} }\n            : $networks->{$type}{networks};\n\n        # Some IPv6 networks (like TEREDO) are a subset of the special block\n        # so there's no point in checking for them in the is_public_ipv6()\n        # sub.\n        unless ($networks->{$type}{subnet_of}) {\n            push @all_nets, @nets;\n        }\n\n        # We're using code gen rather than just making an anon sub outright so\n        # we don't have to pay the cost of derefencing the $is_ip_sub and the\n        # dynamic dispatch cost for $netaddr_new\n        my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined $value;\n\n    my $ip = %s($value);\n    return undef unless defined $ip;\n\n    my $netaddr_ip = NetAddr::IP->%s($ip);\n    for my $net (@nets) {\n        return $ip if $net->contains($netaddr_ip);\n    }\n    return undef;\n}\nEOF\n        die $@ if $@;\n\n        my $sub_name = 'is_' . $type . '_ipv' . $ip_number;\n        {\n            no strict 'refs';\n            *{$sub_name} = $sub;\n        }\n        push @EXPORT, $sub_name;\n    }\n\n    my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    return undef unless defined($value);\n\n    my $ip = %s($value);\n    return undef unless defined $ip;\n\n    my $netaddr_ip = NetAddr::IP->%s($ip);\n    for my $net (@all_nets) {\n        return undef if $net->contains($netaddr_ip);\n    }\n\n    return $ip;\n}\nEOF\n    die $@ if $@;\n\n    my $sub_name = 'is_public_ipv' . $ip_number;\n    {\n        no strict 'refs';\n        *{$sub_name} = $sub;\n    }\n    push @EXPORT, $sub_name;\n}\n\nsub _build_fast_is_X_ip_subs {\n    my $networks  = shift;\n    my $ip_number = shift;\n\n    my $family = $ip_number == 4 ? Socket::AF_INET() : Socket::AF_INET6();\n\n    my @all_nets;\n\n    local $@ = undef;\n    for my $type (keys %{$networks}) {\n        my @nets\n            = map { _packed_network_and_netmask($family, $_) }\n            ref $networks->{$type}{networks}\n            ? @{ $networks->{$type}{networks} }\n            : $networks->{$type}{networks};\n\n        # Some IPv6 networks (like TEREDO) are a subset of the special block\n        # so there's no point in checking for them in the is_public_ipv6()\n        # sub.\n        unless ($networks->{$type}{subnet_of}) {\n            push @all_nets, @nets;\n        }\n\n        # We're using code gen rather than just making an anon sub outright so\n        # we don't have to pay the cost of derefencing the $is_ip_sub and the\n        # dynamic dispatch cost for $netaddr_new\n        my $sub = eval sprintf( <<'EOF', $ip_number);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    my $ip = _fast_is_ipv%u_packed($value);\n\n    return undef unless defined $ip;\n\n    for my $net (@nets) {\n        if (($net->[1] & $ip) eq $net->[0]) {\n            $value =~ /(.+)/;\n            return $1;\n        }\n    }\n    return undef;\n}\nEOF\n        die $@ if $@;\n\n        my $sub_name = 'is_' . $type . '_ipv' . $ip_number;\n        {\n            no strict 'refs';\n            *{$sub_name} = $sub;\n        }\n        push @EXPORT, $sub_name;\n    }\n\n    my $sub = eval sprintf( <<'EOF', $ip_number);\nsub {\n    shift if ref $_[0];\n    my $value = shift;\n\n    my $ip = _fast_is_ipv%u_packed($value);\n\n    return undef unless defined $ip;\n\n    for my $net (@all_nets) {\n        return undef if ($net->[1] & $ip) eq $net->[0];\n    }\n\n    $value =~ /(.+)/;\n    return $1;\n}\nEOF\n    die $@ if $@;\n\n    my $sub_name = 'is_public_ipv' . $ip_number;\n    {\n        no strict 'refs';\n        *{$sub_name} = $sub;\n    }\n    push @EXPORT, $sub_name;\n}\n\nsub _packed_network_and_netmask {\n    my $family  = shift;\n    my $network = shift;\n\n    my ($ip, $bits) = split qr{/}, $network, 2;\n\n    return [\n        inet_pton($family, $ip),\n        _packed_netmask($family, $bits)\n    ];\n}\n\nsub _packed_netmask {\n    my $family = shift;\n    my $bits   = shift;\n\n    my $bit_length = $family == Socket::AF_INET() ? 32 : 128;\n\n    my $bit_string\n        = join(q{}, (1) x $bits, (0) x ($bit_length - $bits));\n    return pack('B' . $bit_length, $bit_string);\n}\n\nfor my $sub (qw( linklocal loopback multicast private public )) {\n    my $sub_name = \"is_${sub}_ip\";\n\n    {\n        no strict 'refs';\n        *{$sub_name}\n            = eval \"sub { ${sub_name}v4(\\@_) || ${sub_name}v6(\\@_) }\";\n        die $@ if $@;\n    }\n\n    push @EXPORT, $sub_name;\n}\n## use critic\n\n1;\n\n# ABSTRACT: IPv4 and IPv6 validation methods\n\n__END__\n\n=pod\n\n=head1 SYNOPSIS\n\n  use Data::Validate::IP qw(is_ipv4 is_ipv6);\n\n  my $suspect = '1.2.3.4';\n  if (is_ipv4($suspect)) {\n      print \"Looks like an IPv4 address\";\n  }\n  else {\n      print \"Not an IPv4 address\\n\";\n  }\n\n  $suspect = '::1234';\n  if (is_ipv6($suspect)) {\n      print \"Looks like an IPv6 address\";\n  }\n  else {\n      print \"Not an IPv6 address\\n\";\n  }\n\n=head1 DESCRIPTION\n\nThis module provides a number IP address validation subs that both validate\nand untaint their input. This includes both basic validation (C<is_ipv4()> and\nC<is_ipv6()>) and special cases like checking whether an address belongs to a\nspecific network or whether an address is public or private (reserved).\n\n=head1 USAGE AND SECURITY RECOMMENDATIONS\n\nIt's important to understand that if C<is_ipv4($ip)>, C<is_ipv6($ip)>, or\nC<is_ip($ip)> return false, then all other validation functions for that IP\naddress family will I<also> return false. So for example, if C<is_ipv4($ip)>\nreturns false, then C<is_private_ipv4($ip)> I<and> C<is_public_ipv4($ip)> will\nboth also return false.\n\nThis means that simply calling C<is_private_ipv4($ip)> by itself is not\nsufficient if you are dealing with untrusted input. You should always check\nC<is_ipv4($ip)> as well. This applies as well when using IPv6 functions or\ngeneric functions like C<is_private_ip($ip)>.\n\nThere are security implications to this around certain oddly formed\naddresses. Notably, an address like \"010.0.0.1\" is technically valid, but the\noperating system will treat \"010\" as an octal number. That means that\n\"010.0.0.1\" is equivalent to \"8.0.0.1\", I<not> \"10.0.0.1\".\n\nHowever, this module's C<is_ipv4($ip)> and C<is_ip($ip)> functions will return\nfalse for addresses like \"010.0.0.1\" which have octal components. And of\ncourse that means that it also returns false for C<is_private_ipv4($ip)>\nI<and> C<is_public_ipv4($ip)>.\n\n=head1 FUNCTIONS\n\nAll of the functions below are exported by default.\n\nAll functions return an untainted value if the test passes and undef if it\nfails. In theory, this means that you should always check for a defined status\nexplicitly but in practice there are no valid IP addresses where the string\nform evaluates to false in Perl.\n\nNote that none of these functions actually attempt to test whether the given\nIP address is routable from your device; they are purely semantic checks.\n\n=head2 is_ipv4($ip), is_ipv6($ip), is_ip($ip)\n\nThese functions simply check whether the address is a valid IPv4 or IPv6 address.\n\n=head2 is_innet_ipv4($ip, $network)\n\nThis subroutine checks whether the address belongs to the given IPv4\nnetwork. The C<$network> argument can either be a string in CIDR notation like\n\"15.0.15.0/24\" or a L<NetAddr::IP> object.\n\nThis subroutine used to accept many more forms of network specifications\n(anything L<Net::Netmask> accepts) but this has been deprecated.\n\n=head2 is_unroutable_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of several special\nuse IPv4 networks - C<0.0.0.0/8>, C<100.64.0.0/10>, C<192.0.0.0/29>,\nC<198.18.0.0/15>, C<240.0.0.0/4> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>, L<RFC\n6333|http://tools.ietf.org/html/rfc6333>, and L<RFC\n6958|http://tools.ietf.org/html/rfc6598>.\n\nArguably, these should be broken down further but this subroutine will always\nexist for backwards compatibility.\n\n=head2 is_private_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of the private IPv4\nnetworks - C<10.0.0.0/8>, C<172.16.0.0/12>, C<192.168.0.0/16> - as defined by\nL<RFC 5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_loopback_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 loopback\nnetwork - C<127.0.0.0/8> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_linklocal_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 link local\nnetwork - C<169.254.0.0/16> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_testnet_ipv4($ip)\n\nThis subroutine checks whether the address belongs to any of the IPv4 TEST-NET\nnetworks for use in documentation and example code - C<192.0.2.0/24>,\nC<198.51.100.0/24>, and C<203.0.113.0/24> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_anycast_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the 6to4 relay anycast\nnetwork - C<192.88.99.0/24> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_multicast_ipv4($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 multicast\nnetwork - C<224.0.0.0/4> - as defined by L<RFC\n5735|http://tools.ietf.org/html/rfc5735>.\n\n=head2 is_loopback_ipv6($ip)\n\nThis subroutine checks whether the address is the IPv6 loopback address -\nC<::1/128> - as defined by L<RFC 4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_ipv4_mapped_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 IPv4-mapped\naddress network - C<::ffff:0:0/96> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_discard_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 discard prefix\nnetwork - C<100::/64> - as defined by L<RFC\n6666|http://tools.ietf.org/html/rfc6666>.\n\n=head2 is_special_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 special network\n- C<2001::/23> - as defined by L<RFC 2928|http://tools.ietf.org/html/rfc2928>.\n\n=head2 is_teredo_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 TEREDO network\n- C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.\n\nNote that this network is a subnet of the larger special network at\nC<2001::/23>.\n\n=head2 is_orchid_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 ORCHID network\n- C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.\n\nNote that this network is a subnet of the larger special network at\nC<2001::/23>.\n\nThis network is currently scheduled to be returned to the special pool in\nMarch of 2014 unless the IETF extends its use. If that happens this subroutine\nwill continue to exist but will always return false.\n\n=head2 is_documentation_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 documentation\nnetwork - C<2001:DB8::/32> - as defined by L<RFC\n3849|http://tools.ietf.org/html/rfc3849>.\n\n=head2 is_private_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 private network\n- C<FC00::/7> - as defined by L<RFC 4193|http://tools.ietf.org/html/rfc4193>.\n\n=head2 is_linklocal_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 link-local\nunicast network - C<FE80::/10> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_multicast_ipv6($ip)\n\nThis subroutine checks whether the address belongs to the IPv6 multicast\nnetwork - C<FF00::/8> - as defined by L<RFC\n4291|http://tools.ietf.org/html/rfc4291>.\n\n=head2 is_public_ipv4($ip), is_public_ipv6($ip), is_public_ip($ip)\n\nThese subroutines check whether the given IP address belongs to any of the\nspecial case networks defined previously. Note that this is B<not> simply the\nopposite of checking C<is_private_ipv4()> or C<is_private_ipv6()>. The private\nnetworks are a subset of all the special case networks.\n\n=head2 is_linklocal_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6\nlink-local unicast network.\n\n=head2 is_loopback_ip($ip)\n\nThis subroutine checks whether the address is the IPv4 or IPv6 loopback\naddress.\n\n=head2 is_multicast_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6\nmulticast network.\n\n=head2 is_private_ip($ip)\n\nThis subroutine checks whether the address belongs to the IPv4 or IPv6 private\nnetwork.\n\n=for Pod::Coverage new\n\n=head1 OBJECT-ORIENTED INTERFACE\n\nThis module can also be used as a class. You can call C<<\nData::Validate::IP->new() >> to get an object and then call any of the\nvalidation subroutines as methods on that object. This is somewhat pointless\nsince the object will never contain any state but this interface is kept for\nbackwards compatibility.\n\n=head1 SEE ALSO\n\nIPv4\n\nB<[RFC 5735] [RFC 1918]>\n\nIPv6\n\nB<[RFC 2460] [RFC 4193] [RFC 4291] [RFC 6434]>\n\n=head1 BUGS\n\nPlease report any bugs or feature requests to\nC<bug-data-validate-ip@rt.cpan.org>, or through the web interface at\nL<http://rt.cpan.org>. I will be notified, and then you'll automatically be\nnotified of progress on your bug as I make changes.\n\n=head1 ACKNOWLEDGEMENTS\n\nThanks to Richard Sonnen <F<sonnen@richardsonnen.com>> for writing the\nData::Validate module.\n\nThanks to Matt Dainty <F<matt@bodgit-n-scarper.com>> for adding the\nC<is_multicast_ipv4()> and C<is_linklocal_ipv4()> code.\n\n=cut\n"], "filenames": ["Changes", "lib/Data/Validate/IP.pm"], "buggy_code_start_loc": [1, 645], "buggy_code_end_loc": [1, 663], "fixing_code_start_loc": [2, 645], "fixing_code_end_loc": [6, 665], "type": "CWE-863", "message": "The Data::Validate::IP module through 0.29 for Perl does not properly consider extraneous zero characters at the beginning of an IP address string, which (in some situations) allows attackers to bypass access control that is based on IP addresses.", "other": {"cve": {"id": "CVE-2021-29662", "sourceIdentifier": "cve@mitre.org", "published": "2021-03-31T18:15:16.037", "lastModified": "2021-06-08T13:51:42.127", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Data::Validate::IP module through 0.29 for Perl does not properly consider extraneous zero characters at the beginning of an IP address string, which (in some situations) allows attackers to bypass access control that is based on IP addresses."}, {"lang": "es", "value": "El m\u00f3dulo Data::Validate::IP versiones hasta 0.29 para Perl, no considera apropiadamente los caracteres cero extra\u00f1os al comienzo de una cadena de direcci\u00f3n IP, lo que (en algunas situaciones) permite a los atacantes omitir el control de acceso que se basa en direcciones IP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:data\\:\\:validate\\:\\:ip_project:data\\:\\:validate\\:\\:ip:*:*:*:*:*:perl:*:*", "versionEndIncluding": "0.29", "matchCriteriaId": "612FC238-2C82-44A8-83E5-8F263697F9F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}]}]}], "references": [{"url": "https://blog.urth.org/2021/03/29/security-issues-in-perl-ip-address-distros/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/houseabsolute/Data-Validate-IP", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/houseabsolute/Data-Validate-IP/commit/3bba13c819d616514a75e089badd75002fd4f14e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sickcodes/security/blob/master/advisories/SICK-2021-018.md", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210604-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://sick.codes/sick-2021-018/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/houseabsolute/Data-Validate-IP/commit/3bba13c819d616514a75e089badd75002fd4f14e"}}