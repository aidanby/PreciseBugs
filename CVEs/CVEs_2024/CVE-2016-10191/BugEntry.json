{"buggy_code": ["/*\n * RTMP input format\n * Copyright (c) 2009 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavcodec/bytestream.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/intfloat.h\"\n#include \"avformat.h\"\n\n#include \"rtmppkt.h\"\n#include \"flv.h\"\n#include \"url.h\"\n\nvoid ff_amf_write_bool(uint8_t **dst, int val)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_BOOL);\n    bytestream_put_byte(dst, val);\n}\n\nvoid ff_amf_write_number(uint8_t **dst, double val)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_NUMBER);\n    bytestream_put_be64(dst, av_double2int(val));\n}\n\nvoid ff_amf_write_string(uint8_t **dst, const char *str)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_STRING);\n    bytestream_put_be16(dst, strlen(str));\n    bytestream_put_buffer(dst, str, strlen(str));\n}\n\nvoid ff_amf_write_string2(uint8_t **dst, const char *str1, const char *str2)\n{\n    int len1 = 0, len2 = 0;\n    if (str1)\n        len1 = strlen(str1);\n    if (str2)\n        len2 = strlen(str2);\n    bytestream_put_byte(dst, AMF_DATA_TYPE_STRING);\n    bytestream_put_be16(dst, len1 + len2);\n    bytestream_put_buffer(dst, str1, len1);\n    bytestream_put_buffer(dst, str2, len2);\n}\n\nvoid ff_amf_write_null(uint8_t **dst)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_NULL);\n}\n\nvoid ff_amf_write_object_start(uint8_t **dst)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_OBJECT);\n}\n\nvoid ff_amf_write_field_name(uint8_t **dst, const char *str)\n{\n    bytestream_put_be16(dst, strlen(str));\n    bytestream_put_buffer(dst, str, strlen(str));\n}\n\nvoid ff_amf_write_object_end(uint8_t **dst)\n{\n    /* first two bytes are field name length = 0,\n     * AMF object should end with it and end marker\n     */\n    bytestream_put_be24(dst, AMF_DATA_TYPE_OBJECT_END);\n}\n\nint ff_amf_read_bool(GetByteContext *bc, int *val)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_BOOL)\n        return AVERROR_INVALIDDATA;\n    *val = bytestream2_get_byte(bc);\n    return 0;\n}\n\nint ff_amf_read_number(GetByteContext *bc, double *val)\n{\n    uint64_t read;\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_NUMBER)\n        return AVERROR_INVALIDDATA;\n    read = bytestream2_get_be64(bc);\n    *val = av_int2double(read);\n    return 0;\n}\n\nint ff_amf_get_string(GetByteContext *bc, uint8_t *str,\n                      int strsize, int *length)\n{\n    int stringlen = 0;\n    int readsize;\n    stringlen = bytestream2_get_be16(bc);\n    if (stringlen + 1 > strsize)\n        return AVERROR(EINVAL);\n    readsize = bytestream2_get_buffer(bc, str, stringlen);\n    if (readsize != stringlen) {\n        av_log(NULL, AV_LOG_WARNING,\n               \"Unable to read as many bytes as AMF string signaled\\n\");\n    }\n    str[readsize] = '\\0';\n    *length = FFMIN(stringlen, readsize);\n    return 0;\n}\n\nint ff_amf_read_string(GetByteContext *bc, uint8_t *str,\n                       int strsize, int *length)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_STRING)\n        return AVERROR_INVALIDDATA;\n    return ff_amf_get_string(bc, str, strsize, length);\n}\n\nint ff_amf_read_null(GetByteContext *bc)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_NULL)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nint ff_rtmp_check_alloc_array(RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                              int channel)\n{\n    int nb_alloc;\n    RTMPPacket *ptr;\n    if (channel < *nb_prev_pkt)\n        return 0;\n\n    nb_alloc = channel + 16;\n    // This can't use the av_reallocp family of functions, since we\n    // would need to free each element in the array before the array\n    // itself is freed.\n    ptr = av_realloc_array(*prev_pkt, nb_alloc, sizeof(**prev_pkt));\n    if (!ptr)\n        return AVERROR(ENOMEM);\n    memset(ptr + *nb_prev_pkt, 0, (nb_alloc - *nb_prev_pkt) * sizeof(*ptr));\n    *prev_pkt = ptr;\n    *nb_prev_pkt = nb_alloc;\n    return 0;\n}\n\nint ff_rtmp_packet_read(URLContext *h, RTMPPacket *p,\n                        int chunk_size, RTMPPacket **prev_pkt, int *nb_prev_pkt)\n{\n    uint8_t hdr;\n\n    if (ffurl_read(h, &hdr, 1) != 1)\n        return AVERROR(EIO);\n\n    return ff_rtmp_packet_read_internal(h, p, chunk_size, prev_pkt,\n                                        nb_prev_pkt, hdr);\n}\n\nstatic int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\n}\n\nint ff_rtmp_packet_read_internal(URLContext *h, RTMPPacket *p, int chunk_size,\n                                 RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                                 uint8_t hdr)\n{\n    while (1) {\n        int ret = rtmp_packet_read_one_chunk(h, p, chunk_size, prev_pkt,\n                                             nb_prev_pkt, hdr);\n        if (ret > 0 || ret != AVERROR(EAGAIN))\n            return ret;\n\n        if (ffurl_read(h, &hdr, 1) != 1)\n            return AVERROR(EIO);\n    }\n}\n\nint ff_rtmp_packet_write(URLContext *h, RTMPPacket *pkt,\n                         int chunk_size, RTMPPacket **prev_pkt_ptr,\n                         int *nb_prev_pkt)\n{\n    uint8_t pkt_hdr[16], *p = pkt_hdr;\n    int mode = RTMP_PS_TWELVEBYTES;\n    int off = 0;\n    int written = 0;\n    int ret;\n    RTMPPacket *prev_pkt;\n    int use_delta; // flag if using timestamp delta, not RTMP_PS_TWELVEBYTES\n    uint32_t timestamp; // full 32-bit timestamp or delta value\n\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         pkt->channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n\n    //if channel_id = 0, this is first presentation of prev_pkt, send full hdr.\n    use_delta = prev_pkt[pkt->channel_id].channel_id &&\n        pkt->extra == prev_pkt[pkt->channel_id].extra &&\n        pkt->timestamp >= prev_pkt[pkt->channel_id].timestamp;\n\n    timestamp = pkt->timestamp;\n    if (use_delta) {\n        timestamp -= prev_pkt[pkt->channel_id].timestamp;\n    }\n    if (timestamp >= 0xFFFFFF) {\n        pkt->ts_field = 0xFFFFFF;\n    } else {\n        pkt->ts_field = timestamp;\n    }\n\n    if (use_delta) {\n        if (pkt->type == prev_pkt[pkt->channel_id].type &&\n            pkt->size == prev_pkt[pkt->channel_id].size) {\n            mode = RTMP_PS_FOURBYTES;\n            if (pkt->ts_field == prev_pkt[pkt->channel_id].ts_field)\n                mode = RTMP_PS_ONEBYTE;\n        } else {\n            mode = RTMP_PS_EIGHTBYTES;\n        }\n    }\n\n    if (pkt->channel_id < 64) {\n        bytestream_put_byte(&p, pkt->channel_id | (mode << 6));\n    } else if (pkt->channel_id < 64 + 256) {\n        bytestream_put_byte(&p, 0               | (mode << 6));\n        bytestream_put_byte(&p, pkt->channel_id - 64);\n    } else {\n        bytestream_put_byte(&p, 1               | (mode << 6));\n        bytestream_put_le16(&p, pkt->channel_id - 64);\n    }\n    if (mode != RTMP_PS_ONEBYTE) {\n        bytestream_put_be24(&p, pkt->ts_field);\n        if (mode != RTMP_PS_FOURBYTES) {\n            bytestream_put_be24(&p, pkt->size);\n            bytestream_put_byte(&p, pkt->type);\n            if (mode == RTMP_PS_TWELVEBYTES)\n                bytestream_put_le32(&p, pkt->extra);\n        }\n    }\n    if (pkt->ts_field == 0xFFFFFF)\n        bytestream_put_be32(&p, timestamp);\n    // save history\n    prev_pkt[pkt->channel_id].channel_id = pkt->channel_id;\n    prev_pkt[pkt->channel_id].type       = pkt->type;\n    prev_pkt[pkt->channel_id].size       = pkt->size;\n    prev_pkt[pkt->channel_id].timestamp  = pkt->timestamp;\n    prev_pkt[pkt->channel_id].ts_field   = pkt->ts_field;\n    prev_pkt[pkt->channel_id].extra      = pkt->extra;\n\n    if ((ret = ffurl_write(h, pkt_hdr, p - pkt_hdr)) < 0)\n        return ret;\n    written = p - pkt_hdr + pkt->size;\n    while (off < pkt->size) {\n        int towrite = FFMIN(chunk_size, pkt->size - off);\n        if ((ret = ffurl_write(h, pkt->data + off, towrite)) < 0)\n            return ret;\n        off += towrite;\n        if (off < pkt->size) {\n            uint8_t marker = 0xC0 | pkt->channel_id;\n            if ((ret = ffurl_write(h, &marker, 1)) < 0)\n                return ret;\n            written++;\n            if (pkt->ts_field == 0xFFFFFF) {\n                uint8_t ts_header[4];\n                AV_WB32(ts_header, timestamp);\n                if ((ret = ffurl_write(h, ts_header, 4)) < 0)\n                    return ret;\n                written += 4;\n            }\n        }\n    }\n    return written;\n}\n\nint ff_rtmp_packet_create(RTMPPacket *pkt, int channel_id, RTMPPacketType type,\n                          int timestamp, int size)\n{\n    if (size) {\n        pkt->data = av_realloc(NULL, size);\n        if (!pkt->data)\n            return AVERROR(ENOMEM);\n    }\n    pkt->size       = size;\n    pkt->channel_id = channel_id;\n    pkt->type       = type;\n    pkt->timestamp  = timestamp;\n    pkt->extra      = 0;\n    pkt->ts_field   = 0;\n\n    return 0;\n}\n\nvoid ff_rtmp_packet_destroy(RTMPPacket *pkt)\n{\n    if (!pkt)\n        return;\n    av_freep(&pkt->data);\n    pkt->size = 0;\n}\n\nint ff_amf_tag_size(const uint8_t *data, const uint8_t *data_end)\n{\n    const uint8_t *base = data;\n    AMFDataType type;\n    unsigned nb   = -1;\n    int parse_key = 1;\n\n    if (data >= data_end)\n        return -1;\n    switch ((type = *data++)) {\n    case AMF_DATA_TYPE_NUMBER:      return 9;\n    case AMF_DATA_TYPE_BOOL:        return 2;\n    case AMF_DATA_TYPE_STRING:      return 3 + AV_RB16(data);\n    case AMF_DATA_TYPE_LONG_STRING: return 5 + AV_RB32(data);\n    case AMF_DATA_TYPE_NULL:        return 1;\n    case AMF_DATA_TYPE_DATE:        return 11;\n    case AMF_DATA_TYPE_ARRAY:\n        parse_key = 0;\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        nb = bytestream_get_be32(&data);\n    case AMF_DATA_TYPE_OBJECT:\n        while (nb-- > 0 || type != AMF_DATA_TYPE_ARRAY) {\n            int t;\n            if (parse_key) {\n                int size = bytestream_get_be16(&data);\n                if (!size) {\n                    data++;\n                    break;\n                }\n                if (size < 0 || size >= data_end - data)\n                    return -1;\n                data += size;\n            }\n            t = ff_amf_tag_size(data, data_end);\n            if (t < 0 || t >= data_end - data)\n                return -1;\n            data += t;\n        }\n        return data - base;\n    case AMF_DATA_TYPE_OBJECT_END:  return 1;\n    default:                        return -1;\n    }\n}\n\nint ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}\n\nstatic const char* rtmp_packet_type(int type)\n{\n    switch (type) {\n    case RTMP_PT_CHUNK_SIZE:     return \"chunk size\";\n    case RTMP_PT_BYTES_READ:     return \"bytes read\";\n    case RTMP_PT_PING:           return \"ping\";\n    case RTMP_PT_SERVER_BW:      return \"server bandwidth\";\n    case RTMP_PT_CLIENT_BW:      return \"client bandwidth\";\n    case RTMP_PT_AUDIO:          return \"audio packet\";\n    case RTMP_PT_VIDEO:          return \"video packet\";\n    case RTMP_PT_FLEX_STREAM:    return \"Flex shared stream\";\n    case RTMP_PT_FLEX_OBJECT:    return \"Flex shared object\";\n    case RTMP_PT_FLEX_MESSAGE:   return \"Flex shared message\";\n    case RTMP_PT_NOTIFY:         return \"notification\";\n    case RTMP_PT_SHARED_OBJ:     return \"shared object\";\n    case RTMP_PT_INVOKE:         return \"invoke\";\n    case RTMP_PT_METADATA:       return \"metadata\";\n    default:                     return \"unknown\";\n    }\n}\n\nstatic void amf_tag_contents(void *ctx, const uint8_t *data,\n                             const uint8_t *data_end)\n{\n    unsigned int size, nb = -1;\n    char buf[1024];\n    AMFDataType type;\n    int parse_key = 1;\n\n    if (data >= data_end)\n        return;\n    switch ((type = *data++)) {\n    case AMF_DATA_TYPE_NUMBER:\n        av_log(ctx, AV_LOG_DEBUG, \" number %g\\n\", av_int2double(AV_RB64(data)));\n        return;\n    case AMF_DATA_TYPE_BOOL:\n        av_log(ctx, AV_LOG_DEBUG, \" bool %d\\n\", *data);\n        return;\n    case AMF_DATA_TYPE_STRING:\n    case AMF_DATA_TYPE_LONG_STRING:\n        if (type == AMF_DATA_TYPE_STRING) {\n            size = bytestream_get_be16(&data);\n        } else {\n            size = bytestream_get_be32(&data);\n        }\n        size = FFMIN(size, sizeof(buf) - 1);\n        memcpy(buf, data, size);\n        buf[size] = 0;\n        av_log(ctx, AV_LOG_DEBUG, \" string '%s'\\n\", buf);\n        return;\n    case AMF_DATA_TYPE_NULL:\n        av_log(ctx, AV_LOG_DEBUG, \" NULL\\n\");\n        return;\n    case AMF_DATA_TYPE_ARRAY:\n        parse_key = 0;\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        nb = bytestream_get_be32(&data);\n    case AMF_DATA_TYPE_OBJECT:\n        av_log(ctx, AV_LOG_DEBUG, \" {\\n\");\n        while (nb-- > 0 || type != AMF_DATA_TYPE_ARRAY) {\n            int t;\n            if (parse_key) {\n                size = bytestream_get_be16(&data);\n                size = FFMIN(size, sizeof(buf) - 1);\n                if (!size) {\n                    av_log(ctx, AV_LOG_DEBUG, \" }\\n\");\n                    data++;\n                    break;\n                }\n                memcpy(buf, data, size);\n                buf[size] = 0;\n                if (size >= data_end - data)\n                    return;\n                data += size;\n                av_log(ctx, AV_LOG_DEBUG, \"  %s: \", buf);\n            }\n            amf_tag_contents(ctx, data, data_end);\n            t = ff_amf_tag_size(data, data_end);\n            if (t < 0 || t >= data_end - data)\n                return;\n            data += t;\n        }\n        return;\n    case AMF_DATA_TYPE_OBJECT_END:\n        av_log(ctx, AV_LOG_DEBUG, \" }\\n\");\n        return;\n    default:\n        return;\n    }\n}\n\nvoid ff_rtmp_packet_dump(void *ctx, RTMPPacket *p)\n{\n    av_log(ctx, AV_LOG_DEBUG, \"RTMP packet type '%s'(%d) for channel %d, timestamp %d, extra field %d size %d\\n\",\n           rtmp_packet_type(p->type), p->type, p->channel_id, p->timestamp, p->extra, p->size);\n    if (p->type == RTMP_PT_INVOKE || p->type == RTMP_PT_NOTIFY) {\n        uint8_t *src = p->data, *src_end = p->data + p->size;\n        while (src < src_end) {\n            int sz;\n            amf_tag_contents(ctx, src, src_end);\n            sz = ff_amf_tag_size(src, src_end);\n            if (sz < 0)\n                break;\n            src += sz;\n        }\n    } else if (p->type == RTMP_PT_SERVER_BW){\n        av_log(ctx, AV_LOG_DEBUG, \"Server BW = %d\\n\", AV_RB32(p->data));\n    } else if (p->type == RTMP_PT_CLIENT_BW){\n        av_log(ctx, AV_LOG_DEBUG, \"Client BW = %d\\n\", AV_RB32(p->data));\n    } else if (p->type != RTMP_PT_AUDIO && p->type != RTMP_PT_VIDEO && p->type != RTMP_PT_METADATA) {\n        int i;\n        for (i = 0; i < p->size; i++)\n            av_log(ctx, AV_LOG_DEBUG, \" %02X\", p->data[i]);\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n    }\n}\n\nint ff_amf_match_string(const uint8_t *data, int size, const char *str)\n{\n    int len = strlen(str);\n    int amf_len, type;\n\n    if (size < 1)\n        return 0;\n\n    type = *data++;\n\n    if (type != AMF_DATA_TYPE_LONG_STRING &&\n        type != AMF_DATA_TYPE_STRING)\n        return 0;\n\n    if (type == AMF_DATA_TYPE_LONG_STRING) {\n        if ((size -= 4 + 1) < 0)\n            return 0;\n        amf_len = bytestream_get_be32(&data);\n    } else {\n        if ((size -= 2 + 1) < 0)\n            return 0;\n        amf_len = bytestream_get_be16(&data);\n    }\n\n    if (amf_len > size)\n        return 0;\n\n    if (amf_len != len)\n        return 0;\n\n    return !memcmp(data, str, len);\n}\n"], "fixing_code": ["/*\n * RTMP input format\n * Copyright (c) 2009 Konstantin Shishkov\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavcodec/bytestream.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/intfloat.h\"\n#include \"avformat.h\"\n\n#include \"rtmppkt.h\"\n#include \"flv.h\"\n#include \"url.h\"\n\nvoid ff_amf_write_bool(uint8_t **dst, int val)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_BOOL);\n    bytestream_put_byte(dst, val);\n}\n\nvoid ff_amf_write_number(uint8_t **dst, double val)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_NUMBER);\n    bytestream_put_be64(dst, av_double2int(val));\n}\n\nvoid ff_amf_write_string(uint8_t **dst, const char *str)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_STRING);\n    bytestream_put_be16(dst, strlen(str));\n    bytestream_put_buffer(dst, str, strlen(str));\n}\n\nvoid ff_amf_write_string2(uint8_t **dst, const char *str1, const char *str2)\n{\n    int len1 = 0, len2 = 0;\n    if (str1)\n        len1 = strlen(str1);\n    if (str2)\n        len2 = strlen(str2);\n    bytestream_put_byte(dst, AMF_DATA_TYPE_STRING);\n    bytestream_put_be16(dst, len1 + len2);\n    bytestream_put_buffer(dst, str1, len1);\n    bytestream_put_buffer(dst, str2, len2);\n}\n\nvoid ff_amf_write_null(uint8_t **dst)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_NULL);\n}\n\nvoid ff_amf_write_object_start(uint8_t **dst)\n{\n    bytestream_put_byte(dst, AMF_DATA_TYPE_OBJECT);\n}\n\nvoid ff_amf_write_field_name(uint8_t **dst, const char *str)\n{\n    bytestream_put_be16(dst, strlen(str));\n    bytestream_put_buffer(dst, str, strlen(str));\n}\n\nvoid ff_amf_write_object_end(uint8_t **dst)\n{\n    /* first two bytes are field name length = 0,\n     * AMF object should end with it and end marker\n     */\n    bytestream_put_be24(dst, AMF_DATA_TYPE_OBJECT_END);\n}\n\nint ff_amf_read_bool(GetByteContext *bc, int *val)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_BOOL)\n        return AVERROR_INVALIDDATA;\n    *val = bytestream2_get_byte(bc);\n    return 0;\n}\n\nint ff_amf_read_number(GetByteContext *bc, double *val)\n{\n    uint64_t read;\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_NUMBER)\n        return AVERROR_INVALIDDATA;\n    read = bytestream2_get_be64(bc);\n    *val = av_int2double(read);\n    return 0;\n}\n\nint ff_amf_get_string(GetByteContext *bc, uint8_t *str,\n                      int strsize, int *length)\n{\n    int stringlen = 0;\n    int readsize;\n    stringlen = bytestream2_get_be16(bc);\n    if (stringlen + 1 > strsize)\n        return AVERROR(EINVAL);\n    readsize = bytestream2_get_buffer(bc, str, stringlen);\n    if (readsize != stringlen) {\n        av_log(NULL, AV_LOG_WARNING,\n               \"Unable to read as many bytes as AMF string signaled\\n\");\n    }\n    str[readsize] = '\\0';\n    *length = FFMIN(stringlen, readsize);\n    return 0;\n}\n\nint ff_amf_read_string(GetByteContext *bc, uint8_t *str,\n                       int strsize, int *length)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_STRING)\n        return AVERROR_INVALIDDATA;\n    return ff_amf_get_string(bc, str, strsize, length);\n}\n\nint ff_amf_read_null(GetByteContext *bc)\n{\n    if (bytestream2_get_byte(bc) != AMF_DATA_TYPE_NULL)\n        return AVERROR_INVALIDDATA;\n    return 0;\n}\n\nint ff_rtmp_check_alloc_array(RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                              int channel)\n{\n    int nb_alloc;\n    RTMPPacket *ptr;\n    if (channel < *nb_prev_pkt)\n        return 0;\n\n    nb_alloc = channel + 16;\n    // This can't use the av_reallocp family of functions, since we\n    // would need to free each element in the array before the array\n    // itself is freed.\n    ptr = av_realloc_array(*prev_pkt, nb_alloc, sizeof(**prev_pkt));\n    if (!ptr)\n        return AVERROR(ENOMEM);\n    memset(ptr + *nb_prev_pkt, 0, (nb_alloc - *nb_prev_pkt) * sizeof(*ptr));\n    *prev_pkt = ptr;\n    *nb_prev_pkt = nb_alloc;\n    return 0;\n}\n\nint ff_rtmp_packet_read(URLContext *h, RTMPPacket *p,\n                        int chunk_size, RTMPPacket **prev_pkt, int *nb_prev_pkt)\n{\n    uint8_t hdr;\n\n    if (ffurl_read(h, &hdr, 1) != 1)\n        return AVERROR(EIO);\n\n    return ff_rtmp_packet_read_internal(h, p, chunk_size, prev_pkt,\n                                        nb_prev_pkt, hdr);\n}\n\nstatic int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n\n    written++;\n    channel_id = hdr & 0x3F;\n\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    }\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n            }\n        }\n    }\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    }\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n\n    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {\n        av_log(NULL, AV_LOG_ERROR, \"RTMP packet size mismatch %d != %d\\n\",\n                size,\n                prev_pkt[channel_id].size);\n        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);\n        prev_pkt[channel_id].read = 0;\n    }\n\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    }\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    }\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       p->data      = NULL;\n       return AVERROR(EAGAIN);\n    }\n\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\n}\n\nint ff_rtmp_packet_read_internal(URLContext *h, RTMPPacket *p, int chunk_size,\n                                 RTMPPacket **prev_pkt, int *nb_prev_pkt,\n                                 uint8_t hdr)\n{\n    while (1) {\n        int ret = rtmp_packet_read_one_chunk(h, p, chunk_size, prev_pkt,\n                                             nb_prev_pkt, hdr);\n        if (ret > 0 || ret != AVERROR(EAGAIN))\n            return ret;\n\n        if (ffurl_read(h, &hdr, 1) != 1)\n            return AVERROR(EIO);\n    }\n}\n\nint ff_rtmp_packet_write(URLContext *h, RTMPPacket *pkt,\n                         int chunk_size, RTMPPacket **prev_pkt_ptr,\n                         int *nb_prev_pkt)\n{\n    uint8_t pkt_hdr[16], *p = pkt_hdr;\n    int mode = RTMP_PS_TWELVEBYTES;\n    int off = 0;\n    int written = 0;\n    int ret;\n    RTMPPacket *prev_pkt;\n    int use_delta; // flag if using timestamp delta, not RTMP_PS_TWELVEBYTES\n    uint32_t timestamp; // full 32-bit timestamp or delta value\n\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         pkt->channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n\n    //if channel_id = 0, this is first presentation of prev_pkt, send full hdr.\n    use_delta = prev_pkt[pkt->channel_id].channel_id &&\n        pkt->extra == prev_pkt[pkt->channel_id].extra &&\n        pkt->timestamp >= prev_pkt[pkt->channel_id].timestamp;\n\n    timestamp = pkt->timestamp;\n    if (use_delta) {\n        timestamp -= prev_pkt[pkt->channel_id].timestamp;\n    }\n    if (timestamp >= 0xFFFFFF) {\n        pkt->ts_field = 0xFFFFFF;\n    } else {\n        pkt->ts_field = timestamp;\n    }\n\n    if (use_delta) {\n        if (pkt->type == prev_pkt[pkt->channel_id].type &&\n            pkt->size == prev_pkt[pkt->channel_id].size) {\n            mode = RTMP_PS_FOURBYTES;\n            if (pkt->ts_field == prev_pkt[pkt->channel_id].ts_field)\n                mode = RTMP_PS_ONEBYTE;\n        } else {\n            mode = RTMP_PS_EIGHTBYTES;\n        }\n    }\n\n    if (pkt->channel_id < 64) {\n        bytestream_put_byte(&p, pkt->channel_id | (mode << 6));\n    } else if (pkt->channel_id < 64 + 256) {\n        bytestream_put_byte(&p, 0               | (mode << 6));\n        bytestream_put_byte(&p, pkt->channel_id - 64);\n    } else {\n        bytestream_put_byte(&p, 1               | (mode << 6));\n        bytestream_put_le16(&p, pkt->channel_id - 64);\n    }\n    if (mode != RTMP_PS_ONEBYTE) {\n        bytestream_put_be24(&p, pkt->ts_field);\n        if (mode != RTMP_PS_FOURBYTES) {\n            bytestream_put_be24(&p, pkt->size);\n            bytestream_put_byte(&p, pkt->type);\n            if (mode == RTMP_PS_TWELVEBYTES)\n                bytestream_put_le32(&p, pkt->extra);\n        }\n    }\n    if (pkt->ts_field == 0xFFFFFF)\n        bytestream_put_be32(&p, timestamp);\n    // save history\n    prev_pkt[pkt->channel_id].channel_id = pkt->channel_id;\n    prev_pkt[pkt->channel_id].type       = pkt->type;\n    prev_pkt[pkt->channel_id].size       = pkt->size;\n    prev_pkt[pkt->channel_id].timestamp  = pkt->timestamp;\n    prev_pkt[pkt->channel_id].ts_field   = pkt->ts_field;\n    prev_pkt[pkt->channel_id].extra      = pkt->extra;\n\n    if ((ret = ffurl_write(h, pkt_hdr, p - pkt_hdr)) < 0)\n        return ret;\n    written = p - pkt_hdr + pkt->size;\n    while (off < pkt->size) {\n        int towrite = FFMIN(chunk_size, pkt->size - off);\n        if ((ret = ffurl_write(h, pkt->data + off, towrite)) < 0)\n            return ret;\n        off += towrite;\n        if (off < pkt->size) {\n            uint8_t marker = 0xC0 | pkt->channel_id;\n            if ((ret = ffurl_write(h, &marker, 1)) < 0)\n                return ret;\n            written++;\n            if (pkt->ts_field == 0xFFFFFF) {\n                uint8_t ts_header[4];\n                AV_WB32(ts_header, timestamp);\n                if ((ret = ffurl_write(h, ts_header, 4)) < 0)\n                    return ret;\n                written += 4;\n            }\n        }\n    }\n    return written;\n}\n\nint ff_rtmp_packet_create(RTMPPacket *pkt, int channel_id, RTMPPacketType type,\n                          int timestamp, int size)\n{\n    if (size) {\n        pkt->data = av_realloc(NULL, size);\n        if (!pkt->data)\n            return AVERROR(ENOMEM);\n    }\n    pkt->size       = size;\n    pkt->channel_id = channel_id;\n    pkt->type       = type;\n    pkt->timestamp  = timestamp;\n    pkt->extra      = 0;\n    pkt->ts_field   = 0;\n\n    return 0;\n}\n\nvoid ff_rtmp_packet_destroy(RTMPPacket *pkt)\n{\n    if (!pkt)\n        return;\n    av_freep(&pkt->data);\n    pkt->size = 0;\n}\n\nint ff_amf_tag_size(const uint8_t *data, const uint8_t *data_end)\n{\n    const uint8_t *base = data;\n    AMFDataType type;\n    unsigned nb   = -1;\n    int parse_key = 1;\n\n    if (data >= data_end)\n        return -1;\n    switch ((type = *data++)) {\n    case AMF_DATA_TYPE_NUMBER:      return 9;\n    case AMF_DATA_TYPE_BOOL:        return 2;\n    case AMF_DATA_TYPE_STRING:      return 3 + AV_RB16(data);\n    case AMF_DATA_TYPE_LONG_STRING: return 5 + AV_RB32(data);\n    case AMF_DATA_TYPE_NULL:        return 1;\n    case AMF_DATA_TYPE_DATE:        return 11;\n    case AMF_DATA_TYPE_ARRAY:\n        parse_key = 0;\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        nb = bytestream_get_be32(&data);\n    case AMF_DATA_TYPE_OBJECT:\n        while (nb-- > 0 || type != AMF_DATA_TYPE_ARRAY) {\n            int t;\n            if (parse_key) {\n                int size = bytestream_get_be16(&data);\n                if (!size) {\n                    data++;\n                    break;\n                }\n                if (size < 0 || size >= data_end - data)\n                    return -1;\n                data += size;\n            }\n            t = ff_amf_tag_size(data, data_end);\n            if (t < 0 || t >= data_end - data)\n                return -1;\n            data += t;\n        }\n        return data - base;\n    case AMF_DATA_TYPE_OBJECT_END:  return 1;\n    default:                        return -1;\n    }\n}\n\nint ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}\n\nstatic const char* rtmp_packet_type(int type)\n{\n    switch (type) {\n    case RTMP_PT_CHUNK_SIZE:     return \"chunk size\";\n    case RTMP_PT_BYTES_READ:     return \"bytes read\";\n    case RTMP_PT_PING:           return \"ping\";\n    case RTMP_PT_SERVER_BW:      return \"server bandwidth\";\n    case RTMP_PT_CLIENT_BW:      return \"client bandwidth\";\n    case RTMP_PT_AUDIO:          return \"audio packet\";\n    case RTMP_PT_VIDEO:          return \"video packet\";\n    case RTMP_PT_FLEX_STREAM:    return \"Flex shared stream\";\n    case RTMP_PT_FLEX_OBJECT:    return \"Flex shared object\";\n    case RTMP_PT_FLEX_MESSAGE:   return \"Flex shared message\";\n    case RTMP_PT_NOTIFY:         return \"notification\";\n    case RTMP_PT_SHARED_OBJ:     return \"shared object\";\n    case RTMP_PT_INVOKE:         return \"invoke\";\n    case RTMP_PT_METADATA:       return \"metadata\";\n    default:                     return \"unknown\";\n    }\n}\n\nstatic void amf_tag_contents(void *ctx, const uint8_t *data,\n                             const uint8_t *data_end)\n{\n    unsigned int size, nb = -1;\n    char buf[1024];\n    AMFDataType type;\n    int parse_key = 1;\n\n    if (data >= data_end)\n        return;\n    switch ((type = *data++)) {\n    case AMF_DATA_TYPE_NUMBER:\n        av_log(ctx, AV_LOG_DEBUG, \" number %g\\n\", av_int2double(AV_RB64(data)));\n        return;\n    case AMF_DATA_TYPE_BOOL:\n        av_log(ctx, AV_LOG_DEBUG, \" bool %d\\n\", *data);\n        return;\n    case AMF_DATA_TYPE_STRING:\n    case AMF_DATA_TYPE_LONG_STRING:\n        if (type == AMF_DATA_TYPE_STRING) {\n            size = bytestream_get_be16(&data);\n        } else {\n            size = bytestream_get_be32(&data);\n        }\n        size = FFMIN(size, sizeof(buf) - 1);\n        memcpy(buf, data, size);\n        buf[size] = 0;\n        av_log(ctx, AV_LOG_DEBUG, \" string '%s'\\n\", buf);\n        return;\n    case AMF_DATA_TYPE_NULL:\n        av_log(ctx, AV_LOG_DEBUG, \" NULL\\n\");\n        return;\n    case AMF_DATA_TYPE_ARRAY:\n        parse_key = 0;\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        nb = bytestream_get_be32(&data);\n    case AMF_DATA_TYPE_OBJECT:\n        av_log(ctx, AV_LOG_DEBUG, \" {\\n\");\n        while (nb-- > 0 || type != AMF_DATA_TYPE_ARRAY) {\n            int t;\n            if (parse_key) {\n                size = bytestream_get_be16(&data);\n                size = FFMIN(size, sizeof(buf) - 1);\n                if (!size) {\n                    av_log(ctx, AV_LOG_DEBUG, \" }\\n\");\n                    data++;\n                    break;\n                }\n                memcpy(buf, data, size);\n                buf[size] = 0;\n                if (size >= data_end - data)\n                    return;\n                data += size;\n                av_log(ctx, AV_LOG_DEBUG, \"  %s: \", buf);\n            }\n            amf_tag_contents(ctx, data, data_end);\n            t = ff_amf_tag_size(data, data_end);\n            if (t < 0 || t >= data_end - data)\n                return;\n            data += t;\n        }\n        return;\n    case AMF_DATA_TYPE_OBJECT_END:\n        av_log(ctx, AV_LOG_DEBUG, \" }\\n\");\n        return;\n    default:\n        return;\n    }\n}\n\nvoid ff_rtmp_packet_dump(void *ctx, RTMPPacket *p)\n{\n    av_log(ctx, AV_LOG_DEBUG, \"RTMP packet type '%s'(%d) for channel %d, timestamp %d, extra field %d size %d\\n\",\n           rtmp_packet_type(p->type), p->type, p->channel_id, p->timestamp, p->extra, p->size);\n    if (p->type == RTMP_PT_INVOKE || p->type == RTMP_PT_NOTIFY) {\n        uint8_t *src = p->data, *src_end = p->data + p->size;\n        while (src < src_end) {\n            int sz;\n            amf_tag_contents(ctx, src, src_end);\n            sz = ff_amf_tag_size(src, src_end);\n            if (sz < 0)\n                break;\n            src += sz;\n        }\n    } else if (p->type == RTMP_PT_SERVER_BW){\n        av_log(ctx, AV_LOG_DEBUG, \"Server BW = %d\\n\", AV_RB32(p->data));\n    } else if (p->type == RTMP_PT_CLIENT_BW){\n        av_log(ctx, AV_LOG_DEBUG, \"Client BW = %d\\n\", AV_RB32(p->data));\n    } else if (p->type != RTMP_PT_AUDIO && p->type != RTMP_PT_VIDEO && p->type != RTMP_PT_METADATA) {\n        int i;\n        for (i = 0; i < p->size; i++)\n            av_log(ctx, AV_LOG_DEBUG, \" %02X\", p->data[i]);\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n    }\n}\n\nint ff_amf_match_string(const uint8_t *data, int size, const char *str)\n{\n    int len = strlen(str);\n    int amf_len, type;\n\n    if (size < 1)\n        return 0;\n\n    type = *data++;\n\n    if (type != AMF_DATA_TYPE_LONG_STRING &&\n        type != AMF_DATA_TYPE_STRING)\n        return 0;\n\n    if (type == AMF_DATA_TYPE_LONG_STRING) {\n        if ((size -= 4 + 1) < 0)\n            return 0;\n        amf_len = bytestream_get_be32(&data);\n    } else {\n        if ((size -= 2 + 1) < 0)\n            return 0;\n        amf_len = bytestream_get_be16(&data);\n    }\n\n    if (amf_len > size)\n        return 0;\n\n    if (amf_len != len)\n        return 0;\n\n    return !memcmp(data, str, len);\n}\n"], "filenames": ["libavformat/rtmppkt.c"], "buggy_code_start_loc": [236], "buggy_code_end_loc": [236], "fixing_code_start_loc": [237], "fixing_code_end_loc": [245], "type": "CWE-119", "message": "Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.", "other": {"cve": {"id": "CVE-2016-10191", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T15:59:00.723", "lastModified": "2018-12-21T11:29:02.733", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en libavformat/rtmppkt.c en FFmpeg en versiones anteriores a 2.8.10, 3.0.x en versiones anteriores a 3.0.5, 3.1.x en versiones anteriores a 3.1.6 y 3.2.x en versiones anteriores a 3.2.2 permite a atacantes remotos ejecutar c\u00f3digo arbitrario aprovechando el fallo para comprobar si hay desajustes de tama\u00f1o de paquete RTMP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.9", "matchCriteriaId": "BB8F94CB-75BE-4D48-A4A6-4CE03A3D60B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C6E85AA0-559E-4EC5-AF61-100732EF0643"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "3E86E3C4-946B-4E89-B0C1-010046D8D478"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "94E316AE-DF67-40B7-99CE-CE30BFECC4C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "368CB50E-729C-4CA3-A6E4-67A277354255"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "10FD1F85-27FB-4E8B-A2D0-529A048701C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "1A730657-04E4-4802-8336-DB067AF00C5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "77E8C6C8-4849-4475-8271-CAD3ECE761CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "59A336FF-56BE-4B09-827E-887FCF0A018B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "E6FB6CF6-F80E-4570-8790-F43D2F035A07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "95D2E370-7B0E-451F-9802-D4C272C4902E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A040488F-32AA-4451-B922-45B17D2AEA90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "21F765CB-B78E-42A3-BB22-D9FC515694B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5DFEAF5-8003-4EDB-B2B3-9022052939C4"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2017/01/31/12", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/02/02/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95989", "source": "cve@mitre.org"}, {"url": "https://ffmpeg.org/security.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7d57ca4d9a75562fa32e40766211de150f8b3ee7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/12/msg00009.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7d57ca4d9a75562fa32e40766211de150f8b3ee7"}}