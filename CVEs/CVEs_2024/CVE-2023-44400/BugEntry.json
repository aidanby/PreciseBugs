{"buggy_code": ["const { BeanModel } = require(\"redbean-node/dist/bean-model\");\nconst passwordHash = require(\"../password-hash\");\nconst { R } = require(\"redbean-node\");\n\nclass User extends BeanModel {\n    /**\n     * Reset user password\n     * Fix #1510, as in the context reset-password.js, there is no auto model mapping. Call this static function instead.\n     * @param {number} userID ID of user to update\n     * @param {string} newPassword\n     * @returns {Promise<void>}\n     */\n    static async resetPassword(userID, newPassword) {\n        await R.exec(\"UPDATE `user` SET password = ? WHERE id = ? \", [\n            passwordHash.generate(newPassword),\n            userID\n        ]);\n    }\n\n    /**\n     * Reset this users password\n     * @param {string} newPassword\n     * @returns {Promise<void>}\n     */\n    async resetPassword(newPassword) {\n        await User.resetPassword(this.id, newPassword);\n        this.password = newPassword;\n    }\n\n}\n\nmodule.exports = User;\n", "/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance(args);\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, FBSD, doubleCheckPassword, startE2eTests } = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = FBSD ? null : process.env.HOST;\nlet hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                if (user) {\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: jwt.sign({\n                            username: data.username,\n                        }, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: jwt.sign({\n                                username: data.username,\n                            }, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        server.startNSCDServices();\n                    } else {\n                        server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nprocess.addListener(\"unhandledRejection\", (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n});\n", "const tcpp = require(\"tcp-ping\");\nconst ping = require(\"@louislam/ping\");\nconst { R } = require(\"redbean-node\");\nconst { log, genSecret } = require(\"../src/util\");\nconst passwordHash = require(\"./password-hash\");\nconst { Resolver } = require(\"dns\");\nconst childProcess = require(\"child_process\");\nconst iconv = require(\"iconv-lite\");\nconst chardet = require(\"chardet\");\nconst mqtt = require(\"mqtt\");\nconst chroma = require(\"chroma-js\");\nconst { badgeConstants } = require(\"./config\");\nconst mssql = require(\"mssql\");\nconst { Client } = require(\"pg\");\nconst postgresConParse = require(\"pg-connection-string\").parse;\nconst mysql = require(\"mysql2\");\nconst { MongoClient } = require(\"mongodb\");\nconst { NtlmClient } = require(\"axios-ntlm\");\nconst { Settings } = require(\"./settings\");\nconst grpc = require(\"@grpc/grpc-js\");\nconst protojs = require(\"protobufjs\");\nconst radiusClient = require(\"node-radius-client\");\nconst redis = require(\"redis\");\nconst oidc = require(\"openid-client\");\n\nconst {\n    dictionaries: {\n        rfc2865: { file, attributes },\n    },\n} = require(\"node-radius-utils\");\nconst dayjs = require(\"dayjs\");\n\n// SASLOptions used in JSDoc\n// eslint-disable-next-line no-unused-vars\nconst { Kafka, SASLOptions } = require(\"kafkajs\");\n\nconst isWindows = process.platform === /^win/.test(process.platform);\n/**\n * Init or reset JWT secret\n * @returns {Promise<Bean>}\n */\nexports.initJWTSecret = async () => {\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (!jwtSecretBean) {\n        jwtSecretBean = R.dispense(\"setting\");\n        jwtSecretBean.key = \"jwtSecret\";\n    }\n\n    jwtSecretBean.value = passwordHash.generate(genSecret());\n    await R.store(jwtSecretBean);\n    return jwtSecretBean;\n};\n\n/**\n * Decodes a jwt and returns the payload portion without verifying the jqt.\n * @param {string} jwt The input jwt as a string\n * @returns {Object} Decoded jwt payload object\n */\nexports.decodeJwt = (jwt) => {\n    return JSON.parse(Buffer.from(jwt.split(\".\")[1], \"base64\").toString());\n};\n\n/**\n * Gets a Access Token form a oidc/oauth2 provider\n * @param {string} tokenEndpoint The token URI form the auth service provider\n * @param {string} clientId The oidc/oauth application client id\n * @param {string} clientSecret The oidc/oauth application client secret\n * @param {string} scope The scope the for which the token should be issued for\n * @param {string} authMethod The method on how to sent the credentials. Default client_secret_basic\n * @returns {Promise<oidc.TokenSet>} TokenSet promise if the token request was successful\n */\nexports.getOidcTokenClientCredentials = async (tokenEndpoint, clientId, clientSecret, scope, authMethod = \"client_secret_basic\") => {\n    const oauthProvider = new oidc.Issuer({ token_endpoint: tokenEndpoint });\n    let client = new oauthProvider.Client({\n        client_id: clientId,\n        client_secret: clientSecret,\n        token_endpoint_auth_method: authMethod\n    });\n\n    // Increase default timeout and clock tolerance\n    client[oidc.custom.http_options] = () => ({ timeout: 10000 });\n    client[oidc.custom.clock_tolerance] = 5;\n\n    let grantParams = { grant_type: \"client_credentials\" };\n    if (scope) {\n        grantParams.scope = scope;\n    }\n    return await client.grant(grantParams);\n};\n\n/**\n * Send TCP request to specified hostname and port\n * @param {string} hostname Hostname / address of machine\n * @param {number} port TCP port to test\n * @returns {Promise<number>} Maximum time in ms rounded to nearest integer\n */\nexports.tcping = function (hostname, port) {\n    return new Promise((resolve, reject) => {\n        tcpp.ping({\n            address: hostname,\n            port: port,\n            attempts: 1,\n        }, function (err, data) {\n\n            if (err) {\n                reject(err);\n            }\n\n            if (data.results.length >= 1 && data.results[0].err) {\n                reject(data.results[0].err);\n            }\n\n            resolve(Math.round(data.max));\n        });\n    });\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine\n * @param {number} [size=56] Size of packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.ping = async (hostname, size = 56) => {\n    try {\n        return await exports.pingAsync(hostname, false, size);\n    } catch (e) {\n        // If the host cannot be resolved, try again with ipv6\n        console.debug(\"ping\", \"IPv6 error message: \" + e.message);\n\n        // As node-ping does not report a specific error for this, try again if it is an empty message with ipv6 no matter what.\n        if (!e.message) {\n            return await exports.pingAsync(hostname, true, size);\n        } else {\n            throw e;\n        }\n    }\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine to ping\n * @param {boolean} ipv6 Should IPv6 be used?\n * @param {number} [size = 56] Size of ping packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.pingAsync = function (hostname, ipv6 = false, size = 56) {\n    return new Promise((resolve, reject) => {\n        ping.promise.probe(hostname, {\n            v6: ipv6,\n            min_reply: 1,\n            deadline: 10,\n            packetSize: size,\n        }).then((res) => {\n            // If ping failed, it will set field to unknown\n            if (res.alive) {\n                resolve(res.time);\n            } else {\n                if (isWindows) {\n                    reject(new Error(exports.convertToUTF8(res.output)));\n                } else {\n                    reject(new Error(res.output));\n                }\n            }\n        }).catch((err) => {\n            reject(err);\n        });\n    });\n};\n\n/**\n * MQTT Monitor\n * @param {string} hostname Hostname / address of machine to test\n * @param {string} topic MQTT topic\n * @param {string} okMessage Expected result\n * @param {Object} [options={}] MQTT options. Contains port, username,\n * password and interval (interval defaults to 20)\n * @returns {Promise<string>}\n */\nexports.mqttAsync = function (hostname, topic, okMessage, options = {}) {\n    return new Promise((resolve, reject) => {\n        const { port, username, password, interval = 20 } = options;\n\n        // Adds MQTT protocol to the hostname if not already present\n        if (!/^(?:http|mqtt|ws)s?:\\/\\//.test(hostname)) {\n            hostname = \"mqtt://\" + hostname;\n        }\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"mqtt\", \"MQTT timeout triggered\");\n            client.end();\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        const mqttUrl = `${hostname}:${port}`;\n\n        log.debug(\"mqtt\", `MQTT connecting to ${mqttUrl}`);\n\n        let client = mqtt.connect(mqttUrl, {\n            username,\n            password\n        });\n\n        client.on(\"connect\", () => {\n            log.debug(\"mqtt\", \"MQTT connected\");\n\n            try {\n                log.debug(\"mqtt\", \"MQTT subscribe topic\");\n                client.subscribe(topic);\n            } catch (e) {\n                client.end();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Cannot subscribe topic\"));\n            }\n        });\n\n        client.on(\"error\", (error) => {\n            client.end();\n            clearTimeout(timeoutID);\n            reject(error);\n        });\n\n        client.on(\"message\", (messageTopic, message) => {\n            if (messageTopic === topic) {\n                client.end();\n                clearTimeout(timeoutID);\n                if (okMessage != null && okMessage !== \"\" && message.toString() !== okMessage) {\n                    reject(new Error(`Message Mismatch - Topic: ${messageTopic}; Message: ${message.toString()}`));\n                } else {\n                    resolve(`Topic: ${messageTopic}; Message: ${message.toString()}`);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Monitor Kafka using Producer\n * @param {string} topic Topic name to produce into\n * @param {string} message Message to produce\n * @param {Object} [options={interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\"}]\n * Kafka client options. Contains ssl, clientId, allowAutoTopicCreation and\n * interval (interval defaults to 20, allowAutoTopicCreation defaults to false, clientId defaults to \"Uptime-Kuma\"\n * and ssl defaults to false)\n * @param {string[]} brokers List of kafka brokers to connect, host and port joined by ':'\n * @param {SASLOptions} [saslOptions={}] Options for kafka client Authentication (SASL) (defaults to\n * {})\n * @returns {Promise<string>}\n */\nexports.kafkaProducerAsync = function (brokers, topic, message, options = {}, saslOptions = {}) {\n    return new Promise((resolve, reject) => {\n        const { interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\" } = options;\n\n        let connectedToKafka = false;\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"kafkaProducer\", \"KafkaProducer timeout triggered\");\n            connectedToKafka = true;\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        if (saslOptions.mechanism === \"None\") {\n            saslOptions = undefined;\n        }\n\n        let client = new Kafka({\n            brokers: brokers,\n            clientId: clientId,\n            sasl: saslOptions,\n            retry: {\n                retries: 0,\n            },\n            ssl: ssl,\n        });\n\n        let producer = client.producer({\n            allowAutoTopicCreation: allowAutoTopicCreation,\n            retry: {\n                retries: 0,\n            }\n        });\n\n        producer.connect().then(\n            () => {\n                producer.send({\n                    topic: topic,\n                    messages: [{\n                        value: message,\n                    }],\n                }).then((_) => {\n                    resolve(\"Message sent successfully\");\n                }).catch((e) => {\n                    connectedToKafka = true;\n                    producer.disconnect();\n                    clearTimeout(timeoutID);\n                    reject(new Error(\"Error sending message: \" + e.message));\n                }).finally(() => {\n                    connectedToKafka = true;\n                    clearTimeout(timeoutID);\n                });\n            }\n        ).catch(\n            (e) => {\n                connectedToKafka = true;\n                producer.disconnect();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Error in producer connection: \" + e.message));\n            }\n        );\n\n        producer.on(\"producer.network.request_timeout\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.network.request_timeout\"));\n            }\n        });\n\n        producer.on(\"producer.disconnect\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.disconnect\"));\n            }\n        });\n    });\n};\n\n/**\n * Use NTLM Auth for a http request.\n * @param {Object} options The http request options\n * @param {Object} ntlmOptions The auth options\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.httpNtlm = function (options, ntlmOptions) {\n    return new Promise((resolve, reject) => {\n        let client = NtlmClient(ntlmOptions);\n\n        client(options)\n            .then((resp) => {\n                resolve(resp);\n            })\n            .catch((err) => {\n                reject(err);\n            });\n    });\n};\n\n/**\n * Resolves a given record using the specified DNS server\n * @param {string} hostname The hostname of the record to lookup\n * @param {string} resolverServer The DNS server to use\n * @param {string} resolverPort Port the DNS server is listening on\n * @param {string} rrtype The type of record to request\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.dnsResolve = function (hostname, resolverServer, resolverPort, rrtype) {\n    const resolver = new Resolver();\n    // Remove brackets from IPv6 addresses so we can re-add them to\n    // prevent issues with ::1:5300 (::1 port 5300)\n    resolverServer = resolverServer.replace(\"[\", \"\").replace(\"]\", \"\");\n    resolver.setServers([ `[${resolverServer}]:${resolverPort}` ]);\n    return new Promise((resolve, reject) => {\n        if (rrtype === \"PTR\") {\n            resolver.reverse(hostname, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        } else {\n            resolver.resolve(hostname, rrtype, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        }\n    });\n};\n\n/**\n * Run a query on SQL Server\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mssqlQuery = async function (connectionString, query) {\n    let pool;\n    try {\n        pool = new mssql.ConnectionPool(connectionString);\n        await pool.connect();\n        await pool.request().query(query);\n        pool.close();\n    } catch (e) {\n        if (pool) {\n            pool.close();\n        }\n        throw e;\n    }\n};\n\n/**\n * Run a query on Postgres\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.postgresQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const config = postgresConParse(connectionString);\n\n        if (config.password === \"\") {\n            // See https://github.com/brianc/node-postgres/issues/1927\n            return reject(new Error(\"Password is undefined.\"));\n        }\n\n        const client = new Client({ connectionString });\n\n        client.connect((err) => {\n            if (err) {\n                reject(err);\n                client.end();\n            } else {\n                // Connected here\n                try {\n                    // No query provided by user, use SELECT 1\n                    if (!query || (typeof query === \"string\" && query.trim() === \"\")) {\n                        query = \"SELECT 1\";\n                    }\n\n                    client.query(query, (err, res) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(res);\n                        }\n                        client.end();\n                    });\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Run a query on MySQL/MariaDB\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string)>}\n */\nexports.mysqlQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const connection = mysql.createConnection(connectionString);\n\n        connection.on(\"error\", (err) => {\n            reject(err);\n        });\n\n        connection.query(query, (err, res) => {\n            if (err) {\n                reject(err);\n            } else {\n                if (Array.isArray(res)) {\n                    resolve(\"Rows: \" + res.length);\n                } else {\n                    resolve(\"No Error, but the result is not an array. Type: \" + typeof res);\n                }\n            }\n\n            try {\n                connection.end();\n            } catch (_) {\n                connection.destroy();\n            }\n        });\n    });\n};\n\n/**\n * Connect to and Ping a MongoDB database\n * @param {string} connectionString The database connection string\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mongodbPing = async function (connectionString) {\n    let client = await MongoClient.connect(connectionString);\n    let dbPing = await client.db().command({ ping: 1 });\n    await client.close();\n\n    if (dbPing[\"ok\"] === 1) {\n        return \"UP\";\n    } else {\n        throw Error(\"failed\");\n    }\n};\n\n/**\n * Query radius server\n * @param {string} hostname Hostname of radius server\n * @param {string} username Username to use\n * @param {string} password Password to use\n * @param {string} calledStationId ID of called station\n * @param {string} callingStationId ID of calling station\n * @param {string} secret Secret to use\n * @param {number} [port=1812] Port to contact radius server on\n * @param {number} [timeout=2500] Timeout for connection to use\n * @returns {Promise<any>}\n */\nexports.radius = function (\n    hostname,\n    username,\n    password,\n    calledStationId,\n    callingStationId,\n    secret,\n    port = 1812,\n    timeout = 2500,\n) {\n    const client = new radiusClient({\n        host: hostname,\n        hostPort: port,\n        timeout: timeout,\n        retries: 1,\n        dictionaries: [ file ],\n    });\n\n    return client.accessRequest({\n        secret: secret,\n        attributes: [\n            [ attributes.USER_NAME, username ],\n            [ attributes.USER_PASSWORD, password ],\n            [ attributes.CALLING_STATION_ID, callingStationId ],\n            [ attributes.CALLED_STATION_ID, calledStationId ],\n        ],\n    }).catch((error) => {\n        if (error.response?.code) {\n            throw Error(error.response.code);\n        } else {\n            throw Error(error.message);\n        }\n    });\n};\n\n/**\n * Redis server ping\n * @param {string} dsn The redis connection string\n */\nexports.redisPingAsync = function (dsn) {\n    return new Promise((resolve, reject) => {\n        const client = redis.createClient({\n            url: dsn\n        });\n        client.on(\"error\", (err) => {\n            if (client.isOpen) {\n                client.disconnect();\n            }\n            reject(err);\n        });\n        client.connect().then(() => {\n            if (!client.isOpen) {\n                client.emit(\"error\", new Error(\"connection isn't open\"));\n            }\n            client.ping().then((res, err) => {\n                if (client.isOpen) {\n                    client.disconnect();\n                }\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            }).catch(error => reject(error));\n        });\n    });\n};\n\n/**\n * Retrieve value of setting based on key\n * @param {string} key Key of setting to retrieve\n * @returns {Promise<any>} Value\n * @deprecated Use await Settings.get(key)\n */\nexports.setting = async function (key) {\n    return await Settings.get(key);\n};\n\n/**\n * Sets the specified setting to specifed value\n * @param {string} key Key of setting to set\n * @param {any} value Value to set to\n * @param {?string} type Type of setting\n * @returns {Promise<void>}\n */\nexports.setSetting = async function (key, value, type = null) {\n    await Settings.set(key, value, type);\n};\n\n/**\n * Get settings based on type\n * @param {string} type The type of setting\n * @returns {Promise<Bean>}\n */\nexports.getSettings = async function (type) {\n    return await Settings.getSettings(type);\n};\n\n/**\n * Set settings based on type\n * @param {string} type Type of settings to set\n * @param {Object} data Values of settings\n * @returns {Promise<void>}\n */\nexports.setSettings = async function (type, data) {\n    await Settings.setSettings(type, data);\n};\n\n// ssl-checker by @dyaa\n//https://github.com/dyaa/ssl-checker/blob/master/src/index.ts\n\n/**\n * Get number of days between two dates\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysBetween = (validFrom, validTo) =>\n    Math.round(Math.abs(+validFrom - +validTo) / 8.64e7);\n\n/**\n * Get days remaining from a time range\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysRemaining = (validFrom, validTo) => {\n    const daysRemaining = getDaysBetween(validFrom, validTo);\n    if (new Date(validTo).getTime() < new Date().getTime()) {\n        return -daysRemaining;\n    }\n    return daysRemaining;\n};\n\n/**\n * Fix certificate info for display\n * @param {Object} info The chain obtained from getPeerCertificate()\n * @returns {Object} An object representing certificate information\n */\nconst parseCertificateInfo = function (info) {\n    let link = info;\n    let i = 0;\n\n    const existingList = {};\n\n    while (link) {\n        log.debug(\"cert\", `[${i}] ${link.fingerprint}`);\n\n        if (!link.valid_from || !link.valid_to) {\n            break;\n        }\n        link.validTo = new Date(link.valid_to);\n        link.validFor = link.subjectaltname?.replace(/DNS:|IP Address:/g, \"\").split(\", \");\n        link.daysRemaining = getDaysRemaining(new Date(), link.validTo);\n\n        existingList[link.fingerprint] = true;\n\n        // Move up the chain until loop is encountered\n        if (link.issuerCertificate == null) {\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            break;\n        } else if (link.issuerCertificate.fingerprint in existingList) {\n            // a root CA certificate is typically \"signed by itself\"  (=> \"self signed certificate\") and thus the \"issuerCertificate\" is a reference to itself.\n            log.debug(\"cert\", `[Last] ${link.issuerCertificate.fingerprint}`);\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            link.issuerCertificate = null;\n            break;\n        } else {\n            link.certType = (i === 0) ? \"server\" : \"intermediate CA\";\n            link = link.issuerCertificate;\n        }\n\n        // Should be no use, but just in case.\n        if (i > 500) {\n            throw new Error(\"Dead loop occurred in parseCertificateInfo\");\n        }\n        i++;\n    }\n\n    return info;\n};\n\n/**\n * Check if certificate is valid\n * @param {Object} res Response object from axios\n * @returns {Object} Object containing certificate information\n */\nexports.checkCertificate = function (res) {\n    if (!res.request.res.socket) {\n        throw new Error(\"No socket found\");\n    }\n\n    const info = res.request.res.socket.getPeerCertificate(true);\n    const valid = res.request.res.socket.authorized || false;\n\n    log.debug(\"cert\", \"Parsing Certificate Info\");\n    const parsedInfo = parseCertificateInfo(info);\n\n    return {\n        valid: valid,\n        certInfo: parsedInfo\n    };\n};\n\n/**\n * Check if the provided status code is within the accepted ranges\n * @param {number} status The status code to check\n * @param {string[]} acceptedCodes An array of accepted status codes\n * @returns {boolean} True if status code within range, false otherwise\n */\nexports.checkStatusCode = function (status, acceptedCodes) {\n    if (acceptedCodes == null || acceptedCodes.length === 0) {\n        return false;\n    }\n\n    for (const codeRange of acceptedCodes) {\n        if (typeof codeRange !== \"string\") {\n            log.error(\"monitor\", `Accepted status code not a string. ${codeRange} is of type ${typeof codeRange}`);\n            continue;\n        }\n\n        const codeRangeSplit = codeRange.split(\"-\").map(string => parseInt(string));\n        if (codeRangeSplit.length === 1) {\n            if (status === codeRangeSplit[0]) {\n                return true;\n            }\n        } else if (codeRangeSplit.length === 2) {\n            if (status >= codeRangeSplit[0] && status <= codeRangeSplit[1]) {\n                return true;\n            }\n        } else {\n            log.error(\"monitor\", `${codeRange} is not a valid status code range`);\n            continue;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Get total number of clients in room\n * @param {Server} io Socket server instance\n * @param {string} roomName Name of room to check\n * @returns {number}\n */\nexports.getTotalClientInRoom = (io, roomName) => {\n\n    const sockets = io.sockets;\n\n    if (!sockets) {\n        return 0;\n    }\n\n    const adapter = sockets.adapter;\n\n    if (!adapter) {\n        return 0;\n    }\n\n    const room = adapter.rooms.get(roomName);\n\n    if (room) {\n        return room.size;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Allow CORS all origins if development\n * @param {Object} res Response object from axios\n */\nexports.allowDevAllOrigin = (res) => {\n    if (process.env.NODE_ENV === \"development\") {\n        exports.allowAllOrigin(res);\n    }\n};\n\n/**\n * Allow CORS all origins\n * @param {Object} res Response object from axios\n */\nexports.allowAllOrigin = (res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n};\n\n/**\n * Check if a user is logged in\n * @param {Socket} socket Socket instance\n */\nexports.checkLogin = (socket) => {\n    if (!socket.userID) {\n        throw new Error(\"You are not logged in.\");\n    }\n};\n\n/**\n * For logged-in users, double-check the password\n * @param {Socket} socket Socket.io instance\n * @param {string} currentPassword\n * @returns {Promise<Bean>}\n */\nexports.doubleCheckPassword = async (socket, currentPassword) => {\n    if (typeof currentPassword !== \"string\") {\n        throw new Error(\"Wrong data type?\");\n    }\n\n    let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n        socket.userID,\n    ]);\n\n    if (!user || !passwordHash.verify(currentPassword, user.password)) {\n        throw new Error(\"Incorrect current password\");\n    }\n\n    return user;\n};\n\n/** Start Unit tests */\nexports.startUnitTest = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"jest-backend\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/** Start end-to-end tests */\nexports.startE2eTests = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"cy:run\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/**\n * Convert unknown string to UTF8\n * @param {Uint8Array} body Buffer\n * @returns {string}\n */\nexports.convertToUTF8 = (body) => {\n    const guessEncoding = chardet.detect(body);\n    const str = iconv.decode(body, guessEncoding);\n    return str.toString();\n};\n\n/**\n * Returns a color code in hex format based on a given percentage:\n * 0% => hue = 10 => red\n * 100% => hue = 90 => green\n *\n * @param {number} percentage float, 0 to 1\n * @param {number} maxHue\n * @param {number} minHue, int\n * @returns {string}, hex value\n */\nexports.percentageToColor = (percentage, maxHue = 90, minHue = 10) => {\n    const hue = percentage * (maxHue - minHue) + minHue;\n    try {\n        return chroma(`hsl(${hue}, 90%, 40%)`).hex();\n    } catch (err) {\n        return badgeConstants.naColor;\n    }\n};\n\n/**\n * Joins and array of string to one string after filtering out empty values\n *\n * @param {string[]} parts\n * @param {string} connector\n * @returns {string}\n */\nexports.filterAndJoin = (parts, connector = \"\") => {\n    return parts.filter((part) => !!part && part !== \"\").join(connector);\n};\n\n/**\n * Send an Error response\n * @param {Object} res Express response object\n * @param {string} [msg=\"\"] Message to send\n */\nmodule.exports.sendHttpError = (res, msg = \"\") => {\n    if (msg.includes(\"SQLITE_BUSY\") || msg.includes(\"SQLITE_LOCKED\")) {\n        res.status(503).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else if (msg.toLowerCase().includes(\"not found\")) {\n        res.status(404).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else {\n        res.status(403).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    }\n};\n\nfunction timeObjectConvertTimezone(obj, timezone, timeObjectToUTC = true) {\n    let offsetString;\n\n    if (timezone) {\n        offsetString = dayjs().tz(timezone).format(\"Z\");\n    } else {\n        offsetString = dayjs().format(\"Z\");\n    }\n\n    let hours = parseInt(offsetString.substring(1, 3));\n    let minutes = parseInt(offsetString.substring(4, 6));\n\n    if (\n        (timeObjectToUTC && offsetString.startsWith(\"+\")) ||\n        (!timeObjectToUTC && offsetString.startsWith(\"-\"))\n    ) {\n        hours *= -1;\n        minutes *= -1;\n    }\n\n    obj.hours += hours;\n    obj.minutes += minutes;\n\n    // Handle out of bound\n    if (obj.minutes < 0) {\n        obj.minutes += 60;\n        obj.hours--;\n    } else if (obj.minutes > 60) {\n        obj.minutes -= 60;\n        obj.hours++;\n    }\n\n    if (obj.hours < 0) {\n        obj.hours += 24;\n    } else if (obj.hours > 24) {\n        obj.hours -= 24;\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToUTC = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, true);\n};\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToLocal = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, false);\n};\n\n/**\n * Create gRPC client stib\n * @param {Object} options from gRPC client\n */\nmodule.exports.grpcQuery = async (options) => {\n    const { grpcUrl, grpcProtobufData, grpcServiceName, grpcEnableTls, grpcMethod, grpcBody } = options;\n    const protocObject = protojs.parse(grpcProtobufData);\n    const protoServiceObject = protocObject.root.lookupService(grpcServiceName);\n    const Client = grpc.makeGenericClientConstructor({});\n    const credentials = grpcEnableTls ? grpc.credentials.createSsl() : grpc.credentials.createInsecure();\n    const client = new Client(\n        grpcUrl,\n        credentials\n    );\n    const grpcService = protoServiceObject.create(function (method, requestData, cb) {\n        const fullServiceName = method.fullName;\n        const serviceFQDN = fullServiceName.split(\".\");\n        const serviceMethod = serviceFQDN.pop();\n        const serviceMethodClientImpl = `/${serviceFQDN.slice(1).join(\".\")}/${serviceMethod}`;\n        log.debug(\"monitor\", `gRPC method ${serviceMethodClientImpl}`);\n        client.makeUnaryRequest(\n            serviceMethodClientImpl,\n            arg => arg,\n            arg => arg,\n            requestData,\n            cb);\n    }, false, false);\n    return new Promise((resolve, _) => {\n        try {\n            return grpcService[`${grpcMethod}`](JSON.parse(grpcBody), function (err, response) {\n                const responseData = JSON.stringify(response);\n                if (err) {\n                    return resolve({\n                        code: err.code,\n                        errorMessage: err.details,\n                        data: \"\"\n                    });\n                } else {\n                    log.debug(\"monitor:\", `gRPC response: ${JSON.stringify(response)}`);\n                    return resolve({\n                        code: 1,\n                        errorMessage: \"\",\n                        data: responseData\n                    });\n                }\n            });\n        } catch (err) {\n            return resolve({\n                code: -1,\n                errorMessage: `Error ${err}. Please review your gRPC configuration option. The service name must not include package name value, and the method name must follow camelCase format`,\n                data: \"\"\n            });\n        }\n\n    });\n};\n\n// For unit test, export functions\nif (process.env.TEST_BACKEND) {\n    module.exports.__test = {\n        parseCertificateInfo,\n    };\n    module.exports.__getPrivateFunction = (functionName) => {\n        return module.exports.__test[functionName];\n    };\n}\n"], "fixing_code": ["const { BeanModel } = require(\"redbean-node/dist/bean-model\");\nconst passwordHash = require(\"../password-hash\");\nconst { R } = require(\"redbean-node\");\nconst jwt = require(\"jsonwebtoken\");\nconst { shake256, SHAKE256_LENGTH } = require(\"../util-server\");\n\nclass User extends BeanModel {\n    /**\n     * Reset user password\n     * Fix #1510, as in the context reset-password.js, there is no auto model mapping. Call this static function instead.\n     * @param {number} userID ID of user to update\n     * @param {string} newPassword\n     * @returns {Promise<void>}\n     */\n    static async resetPassword(userID, newPassword) {\n        await R.exec(\"UPDATE `user` SET password = ? WHERE id = ? \", [\n            passwordHash.generate(newPassword),\n            userID\n        ]);\n    }\n\n    /**\n     * Reset this users password\n     * @param {string} newPassword\n     * @returns {Promise<void>}\n     */\n    async resetPassword(newPassword) {\n        await User.resetPassword(this.id, newPassword);\n        this.password = newPassword;\n    }\n\n    /**\n     * Create a new JWT for a user\n     * @param {User} user\n     * @param {string} jwtSecret\n     * @return {string}\n     */\n    static createJWT(user, jwtSecret) {\n        return jwt.sign({\n            username: user.username,\n            h: shake256(user.password, SHAKE256_LENGTH),\n        }, jwtSecret);\n    }\n\n}\n\nmodule.exports = User;\n", "/*\n * Uptime Kuma Server\n * node \"server/server.js\"\n * DO NOT require(\"./server\") in other modules, it likely creates circular dependency!\n */\nconsole.log(\"Welcome to Uptime Kuma\");\n\n// As the log function need to use dayjs, it should be very top\nconst dayjs = require(\"dayjs\");\ndayjs.extend(require(\"dayjs/plugin/utc\"));\ndayjs.extend(require(\"./modules/dayjs/plugin/timezone\"));\ndayjs.extend(require(\"dayjs/plugin/customParseFormat\"));\n\n// Load environment variables from `.env`\nrequire(\"dotenv\").config();\n\n// Check Node.js Version\nconst nodeVersion = process.versions.node;\n\n// Get the required Node.js version from package.json\nconst requiredNodeVersions = require(\"../package.json\").engines.node;\nconst bannedNodeVersions = \" < 14 || 20.0.* || 20.1.* || 20.2.* || 20.3.* \";\nconsole.log(`Your Node.js version: ${nodeVersion}`);\n\nconst semver = require(\"semver\");\nconst requiredNodeVersionsComma = requiredNodeVersions.split(\"||\").map((version) => version.trim()).join(\", \");\n\n// Exit Uptime Kuma immediately if the Node.js version is banned\nif (semver.satisfies(nodeVersion, bannedNodeVersions)) {\n    console.error(\"\\x1b[31m%s\\x1b[0m\", `Error: Your Node.js version: ${nodeVersion} is not supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n    process.exit(-1);\n}\n\n// Warning if the Node.js version is not in the support list, but it maybe still works\nif (!semver.satisfies(nodeVersion, requiredNodeVersions)) {\n    console.warn(\"\\x1b[31m%s\\x1b[0m\", `Warning: Your Node.js version: ${nodeVersion} is not officially supported, please upgrade your Node.js to ${requiredNodeVersionsComma}.`);\n}\n\nconst args = require(\"args-parser\")(process.argv);\nconst { sleep, log, getRandomInt, genSecret, isDev } = require(\"../src/util\");\nconst config = require(\"./config\");\n\nlog.info(\"server\", \"Welcome to Uptime Kuma\");\nlog.debug(\"server\", \"Arguments\");\nlog.debug(\"server\", args);\n\nif (! process.env.NODE_ENV) {\n    process.env.NODE_ENV = \"production\";\n}\n\nlog.info(\"server\", \"Node Env: \" + process.env.NODE_ENV);\nlog.info(\"server\", \"Inside Container: \" + (process.env.UPTIME_KUMA_IS_CONTAINER === \"1\"));\n\nlog.info(\"server\", \"Importing Node libraries\");\nconst fs = require(\"fs\");\n\nlog.info(\"server\", \"Importing 3rd-party libraries\");\n\nlog.debug(\"server\", \"Importing express\");\nconst express = require(\"express\");\nconst expressStaticGzip = require(\"express-static-gzip\");\nlog.debug(\"server\", \"Importing redbean-node\");\nconst { R } = require(\"redbean-node\");\nlog.debug(\"server\", \"Importing jsonwebtoken\");\nconst jwt = require(\"jsonwebtoken\");\nlog.debug(\"server\", \"Importing http-graceful-shutdown\");\nconst gracefulShutdown = require(\"http-graceful-shutdown\");\nlog.debug(\"server\", \"Importing prometheus-api-metrics\");\nconst prometheusAPIMetrics = require(\"prometheus-api-metrics\");\nlog.debug(\"server\", \"Importing compare-versions\");\nconst compareVersions = require(\"compare-versions\");\nconst { passwordStrength } = require(\"check-password-strength\");\n\nlog.debug(\"server\", \"Importing 2FA Modules\");\nconst notp = require(\"notp\");\nconst base32 = require(\"thirty-two\");\n\nconst { UptimeKumaServer } = require(\"./uptime-kuma-server\");\nconst server = UptimeKumaServer.getInstance(args);\nconst io = module.exports.io = server.io;\nconst app = server.app;\n\nlog.info(\"server\", \"Importing this project modules\");\nlog.debug(\"server\", \"Importing Monitor\");\nconst Monitor = require(\"./model/monitor\");\nconst User = require(\"./model/user\");\n\nlog.debug(\"server\", \"Importing Settings\");\nconst { getSettings, setSettings, setting, initJWTSecret, checkLogin, startUnitTest, FBSD, doubleCheckPassword, startE2eTests, shake256, SHAKE256_LENGTH\n} = require(\"./util-server\");\n\nlog.debug(\"server\", \"Importing Notification\");\nconst { Notification } = require(\"./notification\");\nNotification.init();\n\nlog.debug(\"server\", \"Importing Proxy\");\nconst { Proxy } = require(\"./proxy\");\n\nlog.debug(\"server\", \"Importing Database\");\nconst Database = require(\"./database\");\n\nlog.debug(\"server\", \"Importing Background Jobs\");\nconst { initBackgroundJobs, stopBackgroundJobs } = require(\"./jobs\");\nconst { loginRateLimiter, twoFaRateLimiter } = require(\"./rate-limiter\");\n\nconst { apiAuth } = require(\"./auth\");\nconst { login } = require(\"./auth\");\nconst passwordHash = require(\"./password-hash\");\n\nconst checkVersion = require(\"./check-version\");\nlog.info(\"server\", \"Version: \" + checkVersion.version);\n\n// If host is omitted, the server will accept connections on the unspecified IPv6 address (::) when IPv6 is available and the unspecified IPv4 address (0.0.0.0) otherwise.\n// Dual-stack support for (::)\n// Also read HOST if not FreeBSD, as HOST is a system environment variable in FreeBSD\nlet hostEnv = FBSD ? null : process.env.HOST;\nlet hostname = args.host || process.env.UPTIME_KUMA_HOST || hostEnv;\n\nif (hostname) {\n    log.info(\"server\", \"Custom hostname: \" + hostname);\n}\n\nconst port = [ args.port, process.env.UPTIME_KUMA_PORT, process.env.PORT, 3001 ]\n    .map(portValue => parseInt(portValue))\n    .find(portValue => !isNaN(portValue));\n\nconst disableFrameSameOrigin = !!process.env.UPTIME_KUMA_DISABLE_FRAME_SAMEORIGIN || args[\"disable-frame-sameorigin\"] || false;\nconst cloudflaredToken = args[\"cloudflared-token\"] || process.env.UPTIME_KUMA_CLOUDFLARED_TOKEN || undefined;\n\n// 2FA / notp verification defaults\nconst twoFAVerifyOptions = {\n    \"window\": 1,\n    \"time\": 30\n};\n\n/**\n * Run unit test after the server is ready\n * @type {boolean}\n */\nconst testMode = !!args[\"test\"] || false;\nconst e2eTestMode = !!args[\"e2e\"] || false;\n\nif (config.demoMode) {\n    log.info(\"server\", \"==== Demo Mode ====\");\n}\n\n// Must be after io instantiation\nconst { sendNotificationList, sendHeartbeatList, sendImportantHeartbeatList, sendInfo, sendProxyList, sendDockerHostList, sendAPIKeyList } = require(\"./client\");\nconst { statusPageSocketHandler } = require(\"./socket-handlers/status-page-socket-handler\");\nconst databaseSocketHandler = require(\"./socket-handlers/database-socket-handler\");\nconst TwoFA = require(\"./2fa\");\nconst StatusPage = require(\"./model/status_page\");\nconst { cloudflaredSocketHandler, autoStart: cloudflaredAutoStart, stop: cloudflaredStop } = require(\"./socket-handlers/cloudflared-socket-handler\");\nconst { proxySocketHandler } = require(\"./socket-handlers/proxy-socket-handler\");\nconst { dockerSocketHandler } = require(\"./socket-handlers/docker-socket-handler\");\nconst { maintenanceSocketHandler } = require(\"./socket-handlers/maintenance-socket-handler\");\nconst { apiKeySocketHandler } = require(\"./socket-handlers/api-key-socket-handler\");\nconst { generalSocketHandler } = require(\"./socket-handlers/general-socket-handler\");\nconst { Settings } = require(\"./settings\");\nconst { CacheableDnsHttpAgent } = require(\"./cacheable-dns-http-agent\");\nconst apicache = require(\"./modules/apicache\");\nconst { resetChrome } = require(\"./monitor-types/real-browser-monitor-type\");\n\napp.use(express.json());\n\n// Global Middleware\napp.use(function (req, res, next) {\n    if (!disableFrameSameOrigin) {\n        res.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n    }\n    res.removeHeader(\"X-Powered-By\");\n    next();\n});\n\n/**\n * Show Setup Page\n * @type {boolean}\n */\nlet needSetup = false;\n\n(async () => {\n    Database.init(args);\n    await initDatabase(testMode);\n    await server.initAfterDatabaseReady();\n    server.entryPage = await Settings.get(\"entryPage\");\n    await StatusPage.loadDomainMappingList();\n\n    log.info(\"server\", \"Adding route\");\n\n    // ***************************\n    // Normal Router here\n    // ***************************\n\n    // Entry Page\n    app.get(\"/\", async (request, response) => {\n        let hostname = request.hostname;\n        if (await setting(\"trustProxy\")) {\n            const proxy = request.headers[\"x-forwarded-host\"];\n            if (proxy) {\n                hostname = proxy;\n            }\n        }\n\n        log.debug(\"entry\", `Request Domain: ${hostname}`);\n\n        const uptimeKumaEntryPage = server.entryPage;\n        if (hostname in StatusPage.domainMappingList) {\n            log.debug(\"entry\", \"This is a status page domain\");\n\n            let slug = StatusPage.domainMappingList[hostname];\n            await StatusPage.handleStatusPageResponse(response, server.indexHTML, slug);\n\n        } else if (uptimeKumaEntryPage && uptimeKumaEntryPage.startsWith(\"statusPage-\")) {\n            response.redirect(\"/status/\" + uptimeKumaEntryPage.replace(\"statusPage-\", \"\"));\n\n        } else {\n            response.redirect(\"/dashboard\");\n        }\n    });\n\n    if (isDev) {\n        app.use(express.urlencoded({ extended: true }));\n        app.post(\"/test-webhook\", async (request, response) => {\n            log.debug(\"test\", request.headers);\n            log.debug(\"test\", request.body);\n            response.send(\"OK\");\n        });\n    }\n\n    // Robots.txt\n    app.get(\"/robots.txt\", async (_request, response) => {\n        let txt = \"User-agent: *\\nDisallow:\";\n        if (!await setting(\"searchEngineIndex\")) {\n            txt += \" /\";\n        }\n        response.setHeader(\"Content-Type\", \"text/plain\");\n        response.send(txt);\n    });\n\n    // Basic Auth Router here\n\n    // Prometheus API metrics  /metrics\n    // With Basic Auth using the first user's username/password\n    app.get(\"/metrics\", apiAuth, prometheusAPIMetrics());\n\n    app.use(\"/\", expressStaticGzip(\"dist\", {\n        enableBrotli: true,\n    }));\n\n    // ./data/upload\n    app.use(\"/upload\", express.static(Database.uploadDir));\n\n    app.get(\"/.well-known/change-password\", async (_, response) => {\n        response.redirect(\"https://github.com/louislam/uptime-kuma/wiki/Reset-Password-via-CLI\");\n    });\n\n    // API Router\n    const apiRouter = require(\"./routers/api-router\");\n    app.use(apiRouter);\n\n    // Status Page Router\n    const statusPageRouter = require(\"./routers/status-page-router\");\n    app.use(statusPageRouter);\n\n    // Universal Route Handler, must be at the end of all express routes.\n    app.get(\"*\", async (_request, response) => {\n        if (_request.originalUrl.startsWith(\"/upload/\")) {\n            response.status(404).send(\"File not found.\");\n        } else {\n            response.send(server.indexHTML);\n        }\n    });\n\n    log.info(\"server\", \"Adding socket handler\");\n    io.on(\"connection\", async (socket) => {\n\n        sendInfo(socket, true);\n\n        if (needSetup) {\n            log.info(\"server\", \"Redirect to setup page\");\n            socket.emit(\"setup\");\n        }\n\n        // ***************************\n        // Public Socket API\n        // ***************************\n\n        socket.on(\"loginByToken\", async (token, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by token. IP=${clientIP}`);\n\n            try {\n                let decoded = jwt.verify(token, server.jwtSecret);\n\n                log.info(\"auth\", \"Username from JWT: \" + decoded.username);\n\n                let user = await R.findOne(\"user\", \" username = ? AND active = 1 \", [\n                    decoded.username,\n                ]);\n\n                // Check if the password changed\n                if (decoded.h !== shake256(user.password, SHAKE256_LENGTH)) {\n                    throw new Error(\"The token is invalid due to password change or old token\");\n                }\n\n                if (user) {\n                    log.debug(\"auth\", \"afterLogin\");\n                    afterLogin(socket, user);\n                    log.debug(\"auth\", \"afterLogin ok\");\n\n                    log.info(\"auth\", `Successfully logged in user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                    });\n                } else {\n\n                    log.info(\"auth\", `Inactive or deleted user ${decoded.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: false,\n                        msg: \"The user is inactive or deleted.\",\n                    });\n                }\n            } catch (error) {\n                log.error(\"auth\", `Invalid token. IP=${clientIP}`);\n                if (error.message) {\n                    log.error(\"auth\", error.message, `IP=${clientIP}`);\n                }\n                callback({\n                    ok: false,\n                    msg: \"Invalid token.\",\n                });\n            }\n\n        });\n\n        socket.on(\"login\", async (data, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            log.info(\"auth\", `Login by username + password. IP=${clientIP}`);\n\n            // Checking\n            if (typeof callback !== \"function\") {\n                return;\n            }\n\n            if (!data) {\n                return;\n            }\n\n            // Login Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                log.info(\"auth\", `Too many failed requests for user ${data.username}. IP=${clientIP}`);\n                return;\n            }\n\n            let user = await login(data.username, data.password);\n\n            if (user) {\n                if (user.twofa_status === 0) {\n                    afterLogin(socket, user);\n\n                    log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        ok: true,\n                        token: User.createJWT(user, server.jwtSecret),\n                    });\n                }\n\n                if (user.twofa_status === 1 && !data.token) {\n\n                    log.info(\"auth\", `2FA token required for user ${data.username}. IP=${clientIP}`);\n\n                    callback({\n                        tokenRequired: true,\n                    });\n                }\n\n                if (data.token) {\n                    let verify = notp.totp.verify(data.token, user.twofa_secret, twoFAVerifyOptions);\n\n                    if (user.twofa_last_token !== data.token && verify) {\n                        afterLogin(socket, user);\n\n                        await R.exec(\"UPDATE `user` SET twofa_last_token = ? WHERE id = ? \", [\n                            data.token,\n                            socket.userID,\n                        ]);\n\n                        log.info(\"auth\", `Successfully logged in user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: true,\n                            token: User.createJWT(user, server.jwtSecret),\n                        });\n                    } else {\n\n                        log.warn(\"auth\", `Invalid token provided for user ${data.username}. IP=${clientIP}`);\n\n                        callback({\n                            ok: false,\n                            msg: \"Invalid Token!\",\n                        });\n                    }\n                }\n            } else {\n\n                log.warn(\"auth\", `Incorrect username or password for user ${data.username}. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: \"Incorrect username or password.\",\n                });\n            }\n\n        });\n\n        socket.on(\"logout\", async (callback) => {\n            // Rate Limit\n            if (! await loginRateLimiter.pass(callback)) {\n                return;\n            }\n\n            socket.leave(socket.userID);\n            socket.userID = null;\n\n            if (typeof callback === \"function\") {\n                callback();\n            }\n        });\n\n        socket.on(\"prepare2FA\", async (currentPassword, callback) => {\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 0) {\n                    let newSecret = genSecret();\n                    let encodedSecret = base32.encode(newSecret);\n\n                    // Google authenticator doesn't like equal signs\n                    // The fix is found at https://github.com/guyht/notp\n                    // Related issue: https://github.com/louislam/uptime-kuma/issues/486\n                    encodedSecret = encodedSecret.toString().replace(/=/g, \"\");\n\n                    let uri = `otpauth://totp/Uptime%20Kuma:${user.username}?secret=${encodedSecret}`;\n\n                    await R.exec(\"UPDATE `user` SET twofa_secret = ? WHERE id = ? \", [\n                        newSecret,\n                        socket.userID,\n                    ]);\n\n                    callback({\n                        ok: true,\n                        uri: uri,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"2FA is already enabled.\",\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"save2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                await R.exec(\"UPDATE `user` SET twofa_status = 1 WHERE id = ? \", [\n                    socket.userID,\n                ]);\n\n                log.info(\"auth\", `Saved 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Enabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error changing 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"disable2FA\", async (currentPassword, callback) => {\n            const clientIP = await server.getClientIP(socket);\n\n            try {\n                if (! await twoFaRateLimiter.pass(callback)) {\n                    return;\n                }\n\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n                await TwoFA.disable2FA(socket.userID);\n\n                log.info(\"auth\", `Disabled 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: true,\n                    msg: \"2FA Disabled.\",\n                });\n            } catch (error) {\n\n                log.error(\"auth\", `Error disabling 2FA token. IP=${clientIP}`);\n\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"verifyToken\", async (token, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n                await doubleCheckPassword(socket, currentPassword);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                let verify = notp.totp.verify(token, user.twofa_secret, twoFAVerifyOptions);\n\n                if (user.twofa_last_token !== token && verify) {\n                    callback({\n                        ok: true,\n                        valid: true,\n                    });\n                } else {\n                    callback({\n                        ok: false,\n                        msg: \"Invalid Token.\",\n                        valid: false,\n                    });\n                }\n\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"twoFAStatus\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n                    socket.userID,\n                ]);\n\n                if (user.twofa_status === 1) {\n                    callback({\n                        ok: true,\n                        status: true,\n                    });\n                } else {\n                    callback({\n                        ok: true,\n                        status: false,\n                    });\n                }\n            } catch (error) {\n                callback({\n                    ok: false,\n                    msg: error.message,\n                });\n            }\n        });\n\n        socket.on(\"needSetup\", async (callback) => {\n            callback(needSetup);\n        });\n\n        socket.on(\"setup\", async (username, password, callback) => {\n            try {\n                if (passwordStrength(password).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                if ((await R.count(\"user\")) !== 0) {\n                    throw new Error(\"Uptime Kuma has been initialized. If you want to run setup again, please delete the database.\");\n                }\n\n                let user = R.dispense(\"user\");\n                user.username = username;\n                user.password = passwordHash.generate(password);\n                await R.store(user);\n\n                needSetup = false;\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // ***************************\n        // Auth Only API\n        // ***************************\n\n        // Add a new monitor\n        socket.on(\"add\", async (monitor, callback) => {\n            try {\n                checkLogin(socket);\n                let bean = R.dispense(\"monitor\");\n\n                let notificationIDList = monitor.notificationIDList;\n                delete monitor.notificationIDList;\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n                monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                delete monitor.accepted_statuscodes;\n\n                monitor.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                monitor.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n\n                bean.import(monitor);\n                bean.user_id = socket.userID;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                await updateMonitorNotification(bean.id, notificationIDList);\n\n                await server.sendMonitorList(socket);\n\n                if (monitor.active !== false) {\n                    await startMonitor(socket.userID, bean.id);\n                }\n\n                log.info(\"monitor\", `Added Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n\n                log.error(\"monitor\", `Error adding Monitor: ${monitor.id} User ID: ${socket.userID}`);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Edit a monitor\n        socket.on(\"editMonitor\", async (monitor, callback) => {\n            try {\n                let removeGroupChildren = false;\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? \", [ monitor.id ]);\n\n                if (bean.user_id !== socket.userID) {\n                    throw new Error(\"Permission denied.\");\n                }\n\n                // Check if Parent is Descendant (would cause endless loop)\n                if (monitor.parent !== null) {\n                    const childIDs = await Monitor.getAllChildrenIDs(monitor.id);\n                    if (childIDs.includes(monitor.parent)) {\n                        throw new Error(\"Invalid Monitor Group\");\n                    }\n                }\n\n                // Remove children if monitor type has changed (from group to non-group)\n                if (bean.type === \"group\" && monitor.type !== bean.type) {\n                    removeGroupChildren = true;\n                }\n\n                // Ensure status code ranges are strings\n                if (!monitor.accepted_statuscodes.every((code) => typeof code === \"string\")) {\n                    throw new Error(\"Accepted status codes are not all strings\");\n                }\n\n                bean.name = monitor.name;\n                bean.description = monitor.description;\n                bean.parent = monitor.parent;\n                bean.type = monitor.type;\n                bean.url = monitor.url;\n                bean.method = monitor.method;\n                bean.body = monitor.body;\n                bean.headers = monitor.headers;\n                bean.basic_auth_user = monitor.basic_auth_user;\n                bean.basic_auth_pass = monitor.basic_auth_pass;\n                bean.timeout = monitor.timeout;\n                bean.oauth_client_id = monitor.oauth_client_id;\n                bean.oauth_client_secret = monitor.oauth_client_secret;\n                bean.oauth_auth_method = monitor.oauth_auth_method;\n                bean.oauth_token_url = monitor.oauth_token_url;\n                bean.oauth_scopes = monitor.oauth_scopes;\n                bean.tlsCa = monitor.tlsCa;\n                bean.tlsCert = monitor.tlsCert;\n                bean.tlsKey = monitor.tlsKey;\n                bean.interval = monitor.interval;\n                bean.retryInterval = monitor.retryInterval;\n                bean.resendInterval = monitor.resendInterval;\n                bean.hostname = monitor.hostname;\n                bean.game = monitor.game;\n                bean.maxretries = monitor.maxretries;\n                bean.port = parseInt(monitor.port);\n                bean.keyword = monitor.keyword;\n                bean.invertKeyword = monitor.invertKeyword;\n                bean.ignoreTls = monitor.ignoreTls;\n                bean.expiryNotification = monitor.expiryNotification;\n                bean.upsideDown = monitor.upsideDown;\n                bean.packetSize = monitor.packetSize;\n                bean.maxredirects = monitor.maxredirects;\n                bean.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                bean.dns_resolve_type = monitor.dns_resolve_type;\n                bean.dns_resolve_server = monitor.dns_resolve_server;\n                bean.pushToken = monitor.pushToken;\n                bean.docker_container = monitor.docker_container;\n                bean.docker_host = monitor.docker_host;\n                bean.proxyId = Number.isInteger(monitor.proxyId) ? monitor.proxyId : null;\n                bean.mqttUsername = monitor.mqttUsername;\n                bean.mqttPassword = monitor.mqttPassword;\n                bean.mqttTopic = monitor.mqttTopic;\n                bean.mqttSuccessMessage = monitor.mqttSuccessMessage;\n                bean.databaseConnectionString = monitor.databaseConnectionString;\n                bean.databaseQuery = monitor.databaseQuery;\n                bean.authMethod = monitor.authMethod;\n                bean.authWorkstation = monitor.authWorkstation;\n                bean.authDomain = monitor.authDomain;\n                bean.grpcUrl = monitor.grpcUrl;\n                bean.grpcProtobuf = monitor.grpcProtobuf;\n                bean.grpcServiceName = monitor.grpcServiceName;\n                bean.grpcMethod = monitor.grpcMethod;\n                bean.grpcBody = monitor.grpcBody;\n                bean.grpcMetadata = monitor.grpcMetadata;\n                bean.grpcEnableTls = monitor.grpcEnableTls;\n                bean.radiusUsername = monitor.radiusUsername;\n                bean.radiusPassword = monitor.radiusPassword;\n                bean.radiusCalledStationId = monitor.radiusCalledStationId;\n                bean.radiusCallingStationId = monitor.radiusCallingStationId;\n                bean.radiusSecret = monitor.radiusSecret;\n                bean.httpBodyEncoding = monitor.httpBodyEncoding;\n                bean.expectedValue = monitor.expectedValue;\n                bean.jsonPath = monitor.jsonPath;\n                bean.kafkaProducerTopic = monitor.kafkaProducerTopic;\n                bean.kafkaProducerBrokers = JSON.stringify(monitor.kafkaProducerBrokers);\n                bean.kafkaProducerAllowAutoTopicCreation = monitor.kafkaProducerAllowAutoTopicCreation;\n                bean.kafkaProducerSaslOptions = JSON.stringify(monitor.kafkaProducerSaslOptions);\n                bean.kafkaProducerMessage = monitor.kafkaProducerMessage;\n                bean.gamedigGivenPortOnly = monitor.gamedigGivenPortOnly;\n\n                bean.validate();\n\n                await R.store(bean);\n\n                if (removeGroupChildren) {\n                    await Monitor.unlinkAllChildren(monitor.id);\n                }\n\n                await updateMonitorNotification(bean.id, monitor.notificationIDList);\n\n                if (await bean.isActive()) {\n                    await restartMonitor(socket.userID, bean.id);\n                }\n\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved.\",\n                    monitorID: bean.id,\n                });\n\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorList\", async (callback) => {\n            try {\n                checkLogin(socket);\n                await server.sendMonitorList(socket);\n                callback({\n                    ok: true,\n                });\n            } catch (e) {\n                log.error(\"monitor\", e);\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                let bean = await R.findOne(\"monitor\", \" id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                callback({\n                    ok: true,\n                    monitor: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getMonitorBeats\", async (monitorID, period, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"monitor\", `Get Monitor Beats: ${monitorID} User ID: ${socket.userID}`);\n\n                if (period == null) {\n                    throw new Error(\"Invalid period.\");\n                }\n\n                let list = await R.getAll(`\n                    SELECT * FROM heartbeat\n                    WHERE monitor_id = ? AND\n                    time > DATETIME('now', '-' || ? || ' hours')\n                    ORDER BY time ASC\n                `, [\n                    monitorID,\n                    period,\n                ]);\n\n                callback({\n                    ok: true,\n                    data: list,\n                });\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Start or Resume the monitor\n        socket.on(\"resumeMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await startMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Resumed Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"pauseMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n                await pauseMonitor(socket.userID, monitorID);\n                await server.sendMonitorList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Paused Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitor\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Delete Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                if (monitorID in server.monitorList) {\n                    server.monitorList[monitorID].stop();\n                    delete server.monitorList[monitorID];\n                }\n\n                const startTime = Date.now();\n\n                await R.exec(\"DELETE FROM monitor WHERE id = ? AND user_id = ? \", [\n                    monitorID,\n                    socket.userID,\n                ]);\n\n                // Fix #2880\n                apicache.clear();\n\n                const endTime = Date.now();\n\n                log.info(\"DB\", `Delete Monitor completed in : ${endTime - startTime} ms`);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n                await server.sendMonitorList(socket);\n                // Clear heartbeat list on client\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getTags\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                const list = await R.findAll(\"tag\");\n\n                callback({\n                    ok: true,\n                    tags: list.map(bean => bean.toJSON()),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = R.dispense(\"tag\");\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editTag\", async (tag, callback) => {\n            try {\n                checkLogin(socket);\n\n                let bean = await R.findOne(\"tag\", \" id = ? \", [ tag.id ]);\n                if (bean == null) {\n                    callback({\n                        ok: false,\n                        msg: \"Tag not found\",\n                    });\n                    return;\n                }\n                bean.name = tag.name;\n                bean.color = tag.color;\n                await R.store(bean);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    tag: await bean.toJSON(),\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteTag\", async (tagID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM tag WHERE id = ? \", [ tagID ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"addMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Added Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"editMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"UPDATE monitor_tag SET value = ? WHERE tag_id = ? AND monitor_id = ?\", [\n                    value,\n                    tagID,\n                    monitorID,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Edited Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteMonitorTag\", async (tagID, monitorID, value, callback) => {\n            try {\n                checkLogin(socket);\n\n                await R.exec(\"DELETE FROM monitor_tag WHERE tag_id = ? AND monitor_id = ? AND value = ?\", [\n                    tagID,\n                    monitorID,\n                    value,\n                ]);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted Successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"changePassword\", async (password, callback) => {\n            try {\n                checkLogin(socket);\n\n                if (! password.newPassword) {\n                    throw new Error(\"Invalid new password\");\n                }\n\n                if (passwordStrength(password.newPassword).value === \"Too weak\") {\n                    throw new Error(\"Password is too weak. It should contain alphabetic and numeric characters. It must be at least 6 characters in length.\");\n                }\n\n                let user = await doubleCheckPassword(socket, password.currentPassword);\n                await user.resetPassword(password.newPassword);\n\n                callback({\n                    ok: true,\n                    msg: \"Password has been updated successfully.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"getSettings\", async (callback) => {\n            try {\n                checkLogin(socket);\n                const data = await getSettings(\"general\");\n\n                if (!data.serverTimezone) {\n                    data.serverTimezone = await server.getTimezone();\n                }\n\n                callback({\n                    ok: true,\n                    data: data,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"setSettings\", async (data, currentPassword, callback) => {\n            try {\n                checkLogin(socket);\n\n                // If currently is disabled auth, don't need to check\n                // Disabled Auth + Want to Disable Auth => No Check\n                // Disabled Auth + Want to Enable Auth => No Check\n                // Enabled Auth + Want to Disable Auth => Check!!\n                // Enabled Auth + Want to Enable Auth => No Check\n                const currentDisabledAuth = await setting(\"disableAuth\");\n                if (!currentDisabledAuth && data.disableAuth) {\n                    await doubleCheckPassword(socket, currentPassword);\n                }\n\n                const previousChromeExecutable = await Settings.get(\"chromeExecutable\");\n                const previousNSCDStatus = await Settings.get(\"nscd\");\n\n                await setSettings(\"general\", data);\n                server.entryPage = data.entryPage;\n\n                await CacheableDnsHttpAgent.update();\n\n                // Also need to apply timezone globally\n                if (data.serverTimezone) {\n                    await server.setTimezone(data.serverTimezone);\n                }\n\n                // If Chrome Executable is changed, need to reset the browser\n                if (previousChromeExecutable !== data.chromeExecutable) {\n                    log.info(\"settings\", \"Chrome executable is changed. Resetting Chrome...\");\n                    await resetChrome();\n                }\n\n                // Update nscd status\n                if (previousNSCDStatus !== data.nscd) {\n                    if (data.nscd) {\n                        server.startNSCDServices();\n                    } else {\n                        server.stopNSCDServices();\n                    }\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\"\n                });\n\n                sendInfo(socket);\n                server.sendMaintenanceList(socket);\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Add or Edit\n        socket.on(\"addNotification\", async (notification, notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                let notificationBean = await Notification.save(notification, notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Saved\",\n                    id: notificationBean.id,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"deleteNotification\", async (notificationID, callback) => {\n            try {\n                checkLogin(socket);\n\n                await Notification.delete(notificationID, socket.userID);\n                await sendNotificationList(socket);\n\n                callback({\n                    ok: true,\n                    msg: \"Deleted\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"testNotification\", async (notification, callback) => {\n            try {\n                checkLogin(socket);\n\n                let msg = await Notification.send(notification, notification.name + \" Testing\");\n\n                callback({\n                    ok: true,\n                    msg,\n                });\n\n            } catch (e) {\n                console.error(e);\n\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"checkApprise\", async (callback) => {\n            try {\n                checkLogin(socket);\n                callback(Notification.checkApprise());\n            } catch (e) {\n                callback(false);\n            }\n        });\n\n        socket.on(\"uploadBackup\", async (uploadedJSON, importHandle, callback) => {\n            try {\n                checkLogin(socket);\n\n                let backupData = JSON.parse(uploadedJSON);\n\n                log.info(\"manage\", `Importing Backup, User ID: ${socket.userID}, Version: ${backupData.version}`);\n\n                let notificationListData = backupData.notificationList;\n                let proxyListData = backupData.proxyList;\n                let monitorListData = backupData.monitorList;\n\n                let version17x = compareVersions.compare(backupData.version, \"1.7.0\", \">=\");\n\n                // If the import option is \"overwrite\" it'll clear most of the tables, except \"settings\" and \"user\"\n                if (importHandle === \"overwrite\") {\n                    // Stops every monitor first, so it doesn't execute any heartbeat while importing\n                    for (let id in server.monitorList) {\n                        let monitor = server.monitorList[id];\n                        await monitor.stop();\n                    }\n                    await R.exec(\"DELETE FROM heartbeat\");\n                    await R.exec(\"DELETE FROM monitor_notification\");\n                    await R.exec(\"DELETE FROM monitor_tls_info\");\n                    await R.exec(\"DELETE FROM notification\");\n                    await R.exec(\"DELETE FROM monitor_tag\");\n                    await R.exec(\"DELETE FROM tag\");\n                    await R.exec(\"DELETE FROM monitor\");\n                    await R.exec(\"DELETE FROM proxy\");\n                }\n\n                // Only starts importing if the backup file contains at least one notification\n                if (notificationListData.length >= 1) {\n                    // Get every existing notification name and puts them in one simple string\n                    let notificationNameList = await R.getAll(\"SELECT name FROM notification\");\n                    let notificationNameListString = JSON.stringify(notificationNameList);\n\n                    for (let i = 0; i < notificationListData.length; i++) {\n                        // Only starts importing the notification if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && notificationNameListString.includes(notificationListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            let notification = JSON.parse(notificationListData[i].config);\n                            await Notification.save(notification, null, socket.userID);\n\n                        }\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one proxy\n                if (proxyListData && proxyListData.length >= 1) {\n                    const proxies = await R.findAll(\"proxy\");\n\n                    // Loop over proxy list and save proxies\n                    for (const proxy of proxyListData) {\n                        const exists = proxies.find(item => item.id === proxy.id);\n\n                        // Do not process when proxy already exists in import handle is skip and keep\n                        if ([ \"skip\", \"keep\" ].includes(importHandle) && !exists) {\n                            return;\n                        }\n\n                        // Save proxy as new entry if exists update exists one\n                        await Proxy.save(proxy, exists ? proxy.id : undefined, proxy.userId);\n                    }\n                }\n\n                // Only starts importing if the backup file contains at least one monitor\n                if (monitorListData.length >= 1) {\n                    // Get every existing monitor name and puts them in one simple string\n                    let monitorNameList = await R.getAll(\"SELECT name FROM monitor\");\n                    let monitorNameListString = JSON.stringify(monitorNameList);\n\n                    for (let i = 0; i < monitorListData.length; i++) {\n                        // Only starts importing the monitor if the import option is \"overwrite\", \"keep\" or \"skip\" but the notification doesn't exists\n                        if ((importHandle === \"skip\" && monitorNameListString.includes(monitorListData[i].name) === false) || importHandle === \"keep\" || importHandle === \"overwrite\") {\n\n                            // Define in here every new variable for monitors which where implemented after the first version of the Import/Export function (1.6.0)\n                            // --- Start ---\n\n                            // Define default values\n                            let retryInterval = 0;\n                            let timeout = monitorListData[i].timeout || (monitorListData[i].interval * 0.8); // fallback to old value\n\n                            /*\n                            Only replace the default value with the backup file data for the specific version, where it appears the first time\n                            More information about that where \"let version\" will be defined\n                            */\n                            if (version17x) {\n                                retryInterval = monitorListData[i].retryInterval;\n                            }\n\n                            // --- End ---\n\n                            let monitor = {\n                                // Define the new variable from earlier here\n                                name: monitorListData[i].name,\n                                description: monitorListData[i].description,\n                                type: monitorListData[i].type,\n                                url: monitorListData[i].url,\n                                method: monitorListData[i].method || \"GET\",\n                                body: monitorListData[i].body,\n                                headers: monitorListData[i].headers,\n                                authMethod: monitorListData[i].authMethod,\n                                basic_auth_user: monitorListData[i].basic_auth_user,\n                                basic_auth_pass: monitorListData[i].basic_auth_pass,\n                                authWorkstation: monitorListData[i].authWorkstation,\n                                authDomain: monitorListData[i].authDomain,\n                                timeout,\n                                interval: monitorListData[i].interval,\n                                retryInterval: retryInterval,\n                                resendInterval: monitorListData[i].resendInterval || 0,\n                                hostname: monitorListData[i].hostname,\n                                maxretries: monitorListData[i].maxretries,\n                                port: monitorListData[i].port,\n                                keyword: monitorListData[i].keyword,\n                                invertKeyword: monitorListData[i].invertKeyword,\n                                ignoreTls: monitorListData[i].ignoreTls,\n                                upsideDown: monitorListData[i].upsideDown,\n                                maxredirects: monitorListData[i].maxredirects,\n                                accepted_statuscodes: monitorListData[i].accepted_statuscodes,\n                                dns_resolve_type: monitorListData[i].dns_resolve_type,\n                                dns_resolve_server: monitorListData[i].dns_resolve_server,\n                                notificationIDList: monitorListData[i].notificationIDList,\n                                proxy_id: monitorListData[i].proxy_id || null,\n                            };\n\n                            if (monitorListData[i].pushToken) {\n                                monitor.pushToken = monitorListData[i].pushToken;\n                            }\n\n                            let bean = R.dispense(\"monitor\");\n\n                            let notificationIDList = monitor.notificationIDList;\n                            delete monitor.notificationIDList;\n\n                            monitor.accepted_statuscodes_json = JSON.stringify(monitor.accepted_statuscodes);\n                            delete monitor.accepted_statuscodes;\n\n                            bean.import(monitor);\n                            bean.user_id = socket.userID;\n                            await R.store(bean);\n\n                            // Only for backup files with the version 1.7.0 or higher, since there was the tag feature implemented\n                            if (version17x) {\n                                // Only import if the specific monitor has tags assigned\n                                for (const oldTag of monitorListData[i].tags) {\n\n                                    // Check if tag already exists and get data ->\n                                    let tag = await R.findOne(\"tag\", \" name = ?\", [\n                                        oldTag.name,\n                                    ]);\n\n                                    let tagId;\n                                    if (! tag) {\n                                        // -> If it doesn't exist, create new tag from backup file\n                                        let beanTag = R.dispense(\"tag\");\n                                        beanTag.name = oldTag.name;\n                                        beanTag.color = oldTag.color;\n                                        await R.store(beanTag);\n\n                                        tagId = beanTag.id;\n                                    } else {\n                                        // -> If it already exist, set tagId to value from database\n                                        tagId = tag.id;\n                                    }\n\n                                    // Assign the new created tag to the monitor\n                                    await R.exec(\"INSERT INTO monitor_tag (tag_id, monitor_id, value) VALUES (?, ?, ?)\", [\n                                        tagId,\n                                        bean.id,\n                                        oldTag.value,\n                                    ]);\n\n                                }\n                            }\n\n                            await updateMonitorNotification(bean.id, notificationIDList);\n\n                            // If monitor was active start it immediately, otherwise pause it\n                            if (monitorListData[i].active === 1) {\n                                await startMonitor(socket.userID, bean.id);\n                            } else {\n                                await pauseMonitor(socket.userID, bean.id);\n                            }\n\n                        }\n                    }\n\n                    await sendNotificationList(socket);\n                    await server.sendMonitorList(socket);\n                }\n\n                callback({\n                    ok: true,\n                    msg: \"Backup successfully restored.\",\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearEvents\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Events Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"UPDATE heartbeat SET msg = ?, important = ? WHERE monitor_id = ? \", [\n                    \"\",\n                    \"0\",\n                    monitorID,\n                ]);\n\n                await sendImportantHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearHeartbeats\", async (monitorID, callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Heartbeats Monitor: ${monitorID} User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat WHERE monitor_id = ?\", [\n                    monitorID\n                ]);\n\n                await sendHeartbeatList(socket, monitorID, true, true);\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        socket.on(\"clearStatistics\", async (callback) => {\n            try {\n                checkLogin(socket);\n\n                log.info(\"manage\", `Clear Statistics User ID: ${socket.userID}`);\n\n                await R.exec(\"DELETE FROM heartbeat\");\n\n                callback({\n                    ok: true,\n                });\n\n            } catch (e) {\n                callback({\n                    ok: false,\n                    msg: e.message,\n                });\n            }\n        });\n\n        // Status Page Socket Handler for admin only\n        statusPageSocketHandler(socket);\n        cloudflaredSocketHandler(socket);\n        databaseSocketHandler(socket);\n        proxySocketHandler(socket);\n        dockerSocketHandler(socket);\n        maintenanceSocketHandler(socket);\n        apiKeySocketHandler(socket);\n        generalSocketHandler(socket, server);\n\n        log.debug(\"server\", \"added all socket handlers\");\n\n        // ***************************\n        // Better do anything after added all socket handlers here\n        // ***************************\n\n        log.debug(\"auth\", \"check auto login\");\n        if (await setting(\"disableAuth\")) {\n            log.info(\"auth\", \"Disabled Auth: auto login to admin\");\n            afterLogin(socket, await R.findOne(\"user\"));\n            socket.emit(\"autoLogin\");\n        } else {\n            log.debug(\"auth\", \"need auth\");\n        }\n\n    });\n\n    log.info(\"server\", \"Init the server\");\n\n    server.httpServer.once(\"error\", async (err) => {\n        console.error(\"Cannot listen: \" + err.message);\n        await shutdownFunction();\n    });\n\n    server.start();\n\n    server.httpServer.listen(port, hostname, () => {\n        if (hostname) {\n            log.info(\"server\", `Listening on ${hostname}:${port}`);\n        } else {\n            log.info(\"server\", `Listening on ${port}`);\n        }\n        startMonitors();\n        checkVersion.startInterval();\n\n        if (testMode) {\n            startUnitTest();\n        }\n\n        if (e2eTestMode) {\n            startE2eTests();\n        }\n    });\n\n    await initBackgroundJobs();\n\n    // Start cloudflared at the end if configured\n    await cloudflaredAutoStart(cloudflaredToken);\n\n})();\n\n/**\n * Update notifications for a given monitor\n * @param {number} monitorID ID of monitor to update\n * @param {number[]} notificationIDList List of new notification\n * providers to add\n * @returns {Promise<void>}\n */\nasync function updateMonitorNotification(monitorID, notificationIDList) {\n    await R.exec(\"DELETE FROM monitor_notification WHERE monitor_id = ? \", [\n        monitorID,\n    ]);\n\n    for (let notificationID in notificationIDList) {\n        if (notificationIDList[notificationID]) {\n            let relation = R.dispense(\"monitor_notification\");\n            relation.monitor_id = monitorID;\n            relation.notification_id = notificationID;\n            await R.store(relation);\n        }\n    }\n}\n\n/**\n * Check if a given user owns a specific monitor\n * @param {number} userID\n * @param {number} monitorID\n * @returns {Promise<void>}\n * @throws {Error} The specified user does not own the monitor\n */\nasync function checkOwner(userID, monitorID) {\n    let row = await R.getRow(\"SELECT id FROM monitor WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (! row) {\n        throw new Error(\"You do not own this monitor.\");\n    }\n}\n\n/**\n * Function called after user login\n * This function is used to send the heartbeat list of a monitor.\n * @param {Socket} socket Socket.io instance\n * @param {Object} user User object\n * @returns {Promise<void>}\n */\nasync function afterLogin(socket, user) {\n    socket.userID = user.id;\n    socket.join(user.id);\n\n    let monitorList = await server.sendMonitorList(socket);\n    sendInfo(socket);\n    server.sendMaintenanceList(socket);\n    sendNotificationList(socket);\n    sendProxyList(socket);\n    sendDockerHostList(socket);\n    sendAPIKeyList(socket);\n\n    await sleep(500);\n\n    await StatusPage.sendStatusPageList(io, socket);\n\n    for (let monitorID in monitorList) {\n        await sendHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await sendImportantHeartbeatList(socket, monitorID);\n    }\n\n    for (let monitorID in monitorList) {\n        await Monitor.sendStats(io, monitorID, user.id);\n    }\n\n    // Set server timezone from client browser if not set\n    // It should be run once only\n    if (! await Settings.get(\"initServerTimezone\")) {\n        log.debug(\"server\", \"emit initServerTimezone\");\n        socket.emit(\"initServerTimezone\");\n    }\n}\n\n/**\n * Initialize the database\n * @param {boolean} [testMode=false] Should the connection be\n * started in test mode?\n * @returns {Promise<void>}\n */\nasync function initDatabase(testMode = false) {\n    if (! fs.existsSync(Database.path)) {\n        log.info(\"server\", \"Copying Database\");\n        fs.copyFileSync(Database.templatePath, Database.path);\n    }\n\n    log.info(\"server\", \"Connecting to the Database\");\n    await Database.connect(testMode);\n    log.info(\"server\", \"Connected\");\n\n    // Patch the database\n    await Database.patch();\n\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (! jwtSecretBean) {\n        log.info(\"server\", \"JWT secret is not found, generate one.\");\n        jwtSecretBean = await initJWTSecret();\n        log.info(\"server\", \"Stored JWT secret into database\");\n    } else {\n        log.info(\"server\", \"Load JWT secret from database.\");\n    }\n\n    // If there is no record in user table, it is a new Uptime Kuma instance, need to setup\n    if ((await R.count(\"user\")) === 0) {\n        log.info(\"server\", \"No user, need setup\");\n        needSetup = true;\n    }\n\n    server.jwtSecret = jwtSecretBean.value;\n}\n\n/**\n * Start the specified monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function startMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Resume Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 1 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    let monitor = await R.findOne(\"monitor\", \" id = ? \", [\n        monitorID,\n    ]);\n\n    if (monitor.id in server.monitorList) {\n        server.monitorList[monitor.id].stop();\n    }\n\n    server.monitorList[monitor.id] = monitor;\n    monitor.start(io);\n}\n\n/**\n * Restart a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function restartMonitor(userID, monitorID) {\n    return await startMonitor(userID, monitorID);\n}\n\n/**\n * Pause a given monitor\n * @param {number} userID ID of user who owns monitor\n * @param {number} monitorID ID of monitor to start\n * @returns {Promise<void>}\n */\nasync function pauseMonitor(userID, monitorID) {\n    await checkOwner(userID, monitorID);\n\n    log.info(\"manage\", `Pause Monitor: ${monitorID} User ID: ${userID}`);\n\n    await R.exec(\"UPDATE monitor SET active = 0 WHERE id = ? AND user_id = ? \", [\n        monitorID,\n        userID,\n    ]);\n\n    if (monitorID in server.monitorList) {\n        server.monitorList[monitorID].stop();\n    }\n}\n\n/** Resume active monitors */\nasync function startMonitors() {\n    let list = await R.find(\"monitor\", \" active = 1 \");\n\n    for (let monitor of list) {\n        server.monitorList[monitor.id] = monitor;\n    }\n\n    for (let monitor of list) {\n        monitor.start(io);\n        // Give some delays, so all monitors won't make request at the same moment when just start the server.\n        await sleep(getRandomInt(300, 1000));\n    }\n}\n\n/**\n * Shutdown the application\n * Stops all monitors and closes the database connection.\n * @param {string} signal The signal that triggered this function to be called.\n * @returns {Promise<void>}\n */\nasync function shutdownFunction(signal) {\n    log.info(\"server\", \"Shutdown requested\");\n    log.info(\"server\", \"Called signal: \" + signal);\n\n    await server.stop();\n\n    log.info(\"server\", \"Stopping all monitors\");\n    for (let id in server.monitorList) {\n        let monitor = server.monitorList[id];\n        monitor.stop();\n    }\n    await sleep(2000);\n    await Database.close();\n\n    stopBackgroundJobs();\n    await cloudflaredStop();\n    Settings.stopCacheCleaner();\n}\n\n/** Final function called before application exits */\nfunction finalFunction() {\n    log.info(\"server\", \"Graceful shutdown successful!\");\n}\n\ngracefulShutdown(server.httpServer, {\n    signals: \"SIGINT SIGTERM\",\n    timeout: 30000,                   // timeout: 30 secs\n    development: false,               // not in dev mode\n    forceExit: true,                  // triggers process.exit() at the end of shutdown process\n    onShutdown: shutdownFunction,     // shutdown function (async) - e.g. for cleanup DB, ...\n    finally: finalFunction,            // finally function (sync) - e.g. for logging\n});\n\n// Catch unexpected errors here\nprocess.addListener(\"unhandledRejection\", (error, promise) => {\n    console.trace(error);\n    UptimeKumaServer.errorLog(error, false);\n    console.error(\"If you keep encountering errors, please report to https://github.com/louislam/uptime-kuma/issues\");\n});\n", "const tcpp = require(\"tcp-ping\");\nconst ping = require(\"@louislam/ping\");\nconst { R } = require(\"redbean-node\");\nconst { log, genSecret } = require(\"../src/util\");\nconst passwordHash = require(\"./password-hash\");\nconst { Resolver } = require(\"dns\");\nconst childProcess = require(\"child_process\");\nconst iconv = require(\"iconv-lite\");\nconst chardet = require(\"chardet\");\nconst mqtt = require(\"mqtt\");\nconst chroma = require(\"chroma-js\");\nconst { badgeConstants } = require(\"./config\");\nconst mssql = require(\"mssql\");\nconst { Client } = require(\"pg\");\nconst postgresConParse = require(\"pg-connection-string\").parse;\nconst mysql = require(\"mysql2\");\nconst { MongoClient } = require(\"mongodb\");\nconst { NtlmClient } = require(\"axios-ntlm\");\nconst { Settings } = require(\"./settings\");\nconst grpc = require(\"@grpc/grpc-js\");\nconst protojs = require(\"protobufjs\");\nconst radiusClient = require(\"node-radius-client\");\nconst redis = require(\"redis\");\nconst oidc = require(\"openid-client\");\n\nconst {\n    dictionaries: {\n        rfc2865: { file, attributes },\n    },\n} = require(\"node-radius-utils\");\nconst dayjs = require(\"dayjs\");\n\n// SASLOptions used in JSDoc\n// eslint-disable-next-line no-unused-vars\nconst { Kafka, SASLOptions } = require(\"kafkajs\");\nconst crypto = require(\"crypto\");\n\nconst isWindows = process.platform === /^win/.test(process.platform);\n/**\n * Init or reset JWT secret\n * @returns {Promise<Bean>}\n */\nexports.initJWTSecret = async () => {\n    let jwtSecretBean = await R.findOne(\"setting\", \" `key` = ? \", [\n        \"jwtSecret\",\n    ]);\n\n    if (!jwtSecretBean) {\n        jwtSecretBean = R.dispense(\"setting\");\n        jwtSecretBean.key = \"jwtSecret\";\n    }\n\n    jwtSecretBean.value = passwordHash.generate(genSecret());\n    await R.store(jwtSecretBean);\n    return jwtSecretBean;\n};\n\n/**\n * Decodes a jwt and returns the payload portion without verifying the jqt.\n * @param {string} jwt The input jwt as a string\n * @returns {Object} Decoded jwt payload object\n */\nexports.decodeJwt = (jwt) => {\n    return JSON.parse(Buffer.from(jwt.split(\".\")[1], \"base64\").toString());\n};\n\n/**\n * Gets a Access Token form a oidc/oauth2 provider\n * @param {string} tokenEndpoint The token URI form the auth service provider\n * @param {string} clientId The oidc/oauth application client id\n * @param {string} clientSecret The oidc/oauth application client secret\n * @param {string} scope The scope the for which the token should be issued for\n * @param {string} authMethod The method on how to sent the credentials. Default client_secret_basic\n * @returns {Promise<oidc.TokenSet>} TokenSet promise if the token request was successful\n */\nexports.getOidcTokenClientCredentials = async (tokenEndpoint, clientId, clientSecret, scope, authMethod = \"client_secret_basic\") => {\n    const oauthProvider = new oidc.Issuer({ token_endpoint: tokenEndpoint });\n    let client = new oauthProvider.Client({\n        client_id: clientId,\n        client_secret: clientSecret,\n        token_endpoint_auth_method: authMethod\n    });\n\n    // Increase default timeout and clock tolerance\n    client[oidc.custom.http_options] = () => ({ timeout: 10000 });\n    client[oidc.custom.clock_tolerance] = 5;\n\n    let grantParams = { grant_type: \"client_credentials\" };\n    if (scope) {\n        grantParams.scope = scope;\n    }\n    return await client.grant(grantParams);\n};\n\n/**\n * Send TCP request to specified hostname and port\n * @param {string} hostname Hostname / address of machine\n * @param {number} port TCP port to test\n * @returns {Promise<number>} Maximum time in ms rounded to nearest integer\n */\nexports.tcping = function (hostname, port) {\n    return new Promise((resolve, reject) => {\n        tcpp.ping({\n            address: hostname,\n            port: port,\n            attempts: 1,\n        }, function (err, data) {\n\n            if (err) {\n                reject(err);\n            }\n\n            if (data.results.length >= 1 && data.results[0].err) {\n                reject(data.results[0].err);\n            }\n\n            resolve(Math.round(data.max));\n        });\n    });\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine\n * @param {number} [size=56] Size of packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.ping = async (hostname, size = 56) => {\n    try {\n        return await exports.pingAsync(hostname, false, size);\n    } catch (e) {\n        // If the host cannot be resolved, try again with ipv6\n        console.debug(\"ping\", \"IPv6 error message: \" + e.message);\n\n        // As node-ping does not report a specific error for this, try again if it is an empty message with ipv6 no matter what.\n        if (!e.message) {\n            return await exports.pingAsync(hostname, true, size);\n        } else {\n            throw e;\n        }\n    }\n};\n\n/**\n * Ping the specified machine\n * @param {string} hostname Hostname / address of machine to ping\n * @param {boolean} ipv6 Should IPv6 be used?\n * @param {number} [size = 56] Size of ping packet to send\n * @returns {Promise<number>} Time for ping in ms rounded to nearest integer\n */\nexports.pingAsync = function (hostname, ipv6 = false, size = 56) {\n    return new Promise((resolve, reject) => {\n        ping.promise.probe(hostname, {\n            v6: ipv6,\n            min_reply: 1,\n            deadline: 10,\n            packetSize: size,\n        }).then((res) => {\n            // If ping failed, it will set field to unknown\n            if (res.alive) {\n                resolve(res.time);\n            } else {\n                if (isWindows) {\n                    reject(new Error(exports.convertToUTF8(res.output)));\n                } else {\n                    reject(new Error(res.output));\n                }\n            }\n        }).catch((err) => {\n            reject(err);\n        });\n    });\n};\n\n/**\n * MQTT Monitor\n * @param {string} hostname Hostname / address of machine to test\n * @param {string} topic MQTT topic\n * @param {string} okMessage Expected result\n * @param {Object} [options={}] MQTT options. Contains port, username,\n * password and interval (interval defaults to 20)\n * @returns {Promise<string>}\n */\nexports.mqttAsync = function (hostname, topic, okMessage, options = {}) {\n    return new Promise((resolve, reject) => {\n        const { port, username, password, interval = 20 } = options;\n\n        // Adds MQTT protocol to the hostname if not already present\n        if (!/^(?:http|mqtt|ws)s?:\\/\\//.test(hostname)) {\n            hostname = \"mqtt://\" + hostname;\n        }\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"mqtt\", \"MQTT timeout triggered\");\n            client.end();\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        const mqttUrl = `${hostname}:${port}`;\n\n        log.debug(\"mqtt\", `MQTT connecting to ${mqttUrl}`);\n\n        let client = mqtt.connect(mqttUrl, {\n            username,\n            password\n        });\n\n        client.on(\"connect\", () => {\n            log.debug(\"mqtt\", \"MQTT connected\");\n\n            try {\n                log.debug(\"mqtt\", \"MQTT subscribe topic\");\n                client.subscribe(topic);\n            } catch (e) {\n                client.end();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Cannot subscribe topic\"));\n            }\n        });\n\n        client.on(\"error\", (error) => {\n            client.end();\n            clearTimeout(timeoutID);\n            reject(error);\n        });\n\n        client.on(\"message\", (messageTopic, message) => {\n            if (messageTopic === topic) {\n                client.end();\n                clearTimeout(timeoutID);\n                if (okMessage != null && okMessage !== \"\" && message.toString() !== okMessage) {\n                    reject(new Error(`Message Mismatch - Topic: ${messageTopic}; Message: ${message.toString()}`));\n                } else {\n                    resolve(`Topic: ${messageTopic}; Message: ${message.toString()}`);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Monitor Kafka using Producer\n * @param {string} topic Topic name to produce into\n * @param {string} message Message to produce\n * @param {Object} [options={interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\"}]\n * Kafka client options. Contains ssl, clientId, allowAutoTopicCreation and\n * interval (interval defaults to 20, allowAutoTopicCreation defaults to false, clientId defaults to \"Uptime-Kuma\"\n * and ssl defaults to false)\n * @param {string[]} brokers List of kafka brokers to connect, host and port joined by ':'\n * @param {SASLOptions} [saslOptions={}] Options for kafka client Authentication (SASL) (defaults to\n * {})\n * @returns {Promise<string>}\n */\nexports.kafkaProducerAsync = function (brokers, topic, message, options = {}, saslOptions = {}) {\n    return new Promise((resolve, reject) => {\n        const { interval = 20, allowAutoTopicCreation = false, ssl = false, clientId = \"Uptime-Kuma\" } = options;\n\n        let connectedToKafka = false;\n\n        const timeoutID = setTimeout(() => {\n            log.debug(\"kafkaProducer\", \"KafkaProducer timeout triggered\");\n            connectedToKafka = true;\n            reject(new Error(\"Timeout\"));\n        }, interval * 1000 * 0.8);\n\n        if (saslOptions.mechanism === \"None\") {\n            saslOptions = undefined;\n        }\n\n        let client = new Kafka({\n            brokers: brokers,\n            clientId: clientId,\n            sasl: saslOptions,\n            retry: {\n                retries: 0,\n            },\n            ssl: ssl,\n        });\n\n        let producer = client.producer({\n            allowAutoTopicCreation: allowAutoTopicCreation,\n            retry: {\n                retries: 0,\n            }\n        });\n\n        producer.connect().then(\n            () => {\n                producer.send({\n                    topic: topic,\n                    messages: [{\n                        value: message,\n                    }],\n                }).then((_) => {\n                    resolve(\"Message sent successfully\");\n                }).catch((e) => {\n                    connectedToKafka = true;\n                    producer.disconnect();\n                    clearTimeout(timeoutID);\n                    reject(new Error(\"Error sending message: \" + e.message));\n                }).finally(() => {\n                    connectedToKafka = true;\n                    clearTimeout(timeoutID);\n                });\n            }\n        ).catch(\n            (e) => {\n                connectedToKafka = true;\n                producer.disconnect();\n                clearTimeout(timeoutID);\n                reject(new Error(\"Error in producer connection: \" + e.message));\n            }\n        );\n\n        producer.on(\"producer.network.request_timeout\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.network.request_timeout\"));\n            }\n        });\n\n        producer.on(\"producer.disconnect\", (_) => {\n            if (!connectedToKafka) {\n                clearTimeout(timeoutID);\n                reject(new Error(\"producer.disconnect\"));\n            }\n        });\n    });\n};\n\n/**\n * Use NTLM Auth for a http request.\n * @param {Object} options The http request options\n * @param {Object} ntlmOptions The auth options\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.httpNtlm = function (options, ntlmOptions) {\n    return new Promise((resolve, reject) => {\n        let client = NtlmClient(ntlmOptions);\n\n        client(options)\n            .then((resp) => {\n                resolve(resp);\n            })\n            .catch((err) => {\n                reject(err);\n            });\n    });\n};\n\n/**\n * Resolves a given record using the specified DNS server\n * @param {string} hostname The hostname of the record to lookup\n * @param {string} resolverServer The DNS server to use\n * @param {string} resolverPort Port the DNS server is listening on\n * @param {string} rrtype The type of record to request\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.dnsResolve = function (hostname, resolverServer, resolverPort, rrtype) {\n    const resolver = new Resolver();\n    // Remove brackets from IPv6 addresses so we can re-add them to\n    // prevent issues with ::1:5300 (::1 port 5300)\n    resolverServer = resolverServer.replace(\"[\", \"\").replace(\"]\", \"\");\n    resolver.setServers([ `[${resolverServer}]:${resolverPort}` ]);\n    return new Promise((resolve, reject) => {\n        if (rrtype === \"PTR\") {\n            resolver.reverse(hostname, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        } else {\n            resolver.resolve(hostname, rrtype, (err, records) => {\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(records);\n                }\n            });\n        }\n    });\n};\n\n/**\n * Run a query on SQL Server\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mssqlQuery = async function (connectionString, query) {\n    let pool;\n    try {\n        pool = new mssql.ConnectionPool(connectionString);\n        await pool.connect();\n        await pool.request().query(query);\n        pool.close();\n    } catch (e) {\n        if (pool) {\n            pool.close();\n        }\n        throw e;\n    }\n};\n\n/**\n * Run a query on Postgres\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.postgresQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const config = postgresConParse(connectionString);\n\n        if (config.password === \"\") {\n            // See https://github.com/brianc/node-postgres/issues/1927\n            return reject(new Error(\"Password is undefined.\"));\n        }\n\n        const client = new Client({ connectionString });\n\n        client.connect((err) => {\n            if (err) {\n                reject(err);\n                client.end();\n            } else {\n                // Connected here\n                try {\n                    // No query provided by user, use SELECT 1\n                    if (!query || (typeof query === \"string\" && query.trim() === \"\")) {\n                        query = \"SELECT 1\";\n                    }\n\n                    client.query(query, (err, res) => {\n                        if (err) {\n                            reject(err);\n                        } else {\n                            resolve(res);\n                        }\n                        client.end();\n                    });\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        });\n\n    });\n};\n\n/**\n * Run a query on MySQL/MariaDB\n * @param {string} connectionString The database connection string\n * @param {string} query The query to validate the database with\n * @returns {Promise<(string)>}\n */\nexports.mysqlQuery = function (connectionString, query) {\n    return new Promise((resolve, reject) => {\n        const connection = mysql.createConnection(connectionString);\n\n        connection.on(\"error\", (err) => {\n            reject(err);\n        });\n\n        connection.query(query, (err, res) => {\n            if (err) {\n                reject(err);\n            } else {\n                if (Array.isArray(res)) {\n                    resolve(\"Rows: \" + res.length);\n                } else {\n                    resolve(\"No Error, but the result is not an array. Type: \" + typeof res);\n                }\n            }\n\n            try {\n                connection.end();\n            } catch (_) {\n                connection.destroy();\n            }\n        });\n    });\n};\n\n/**\n * Connect to and Ping a MongoDB database\n * @param {string} connectionString The database connection string\n * @returns {Promise<(string[]|Object[]|Object)>}\n */\nexports.mongodbPing = async function (connectionString) {\n    let client = await MongoClient.connect(connectionString);\n    let dbPing = await client.db().command({ ping: 1 });\n    await client.close();\n\n    if (dbPing[\"ok\"] === 1) {\n        return \"UP\";\n    } else {\n        throw Error(\"failed\");\n    }\n};\n\n/**\n * Query radius server\n * @param {string} hostname Hostname of radius server\n * @param {string} username Username to use\n * @param {string} password Password to use\n * @param {string} calledStationId ID of called station\n * @param {string} callingStationId ID of calling station\n * @param {string} secret Secret to use\n * @param {number} [port=1812] Port to contact radius server on\n * @param {number} [timeout=2500] Timeout for connection to use\n * @returns {Promise<any>}\n */\nexports.radius = function (\n    hostname,\n    username,\n    password,\n    calledStationId,\n    callingStationId,\n    secret,\n    port = 1812,\n    timeout = 2500,\n) {\n    const client = new radiusClient({\n        host: hostname,\n        hostPort: port,\n        timeout: timeout,\n        retries: 1,\n        dictionaries: [ file ],\n    });\n\n    return client.accessRequest({\n        secret: secret,\n        attributes: [\n            [ attributes.USER_NAME, username ],\n            [ attributes.USER_PASSWORD, password ],\n            [ attributes.CALLING_STATION_ID, callingStationId ],\n            [ attributes.CALLED_STATION_ID, calledStationId ],\n        ],\n    }).catch((error) => {\n        if (error.response?.code) {\n            throw Error(error.response.code);\n        } else {\n            throw Error(error.message);\n        }\n    });\n};\n\n/**\n * Redis server ping\n * @param {string} dsn The redis connection string\n */\nexports.redisPingAsync = function (dsn) {\n    return new Promise((resolve, reject) => {\n        const client = redis.createClient({\n            url: dsn\n        });\n        client.on(\"error\", (err) => {\n            if (client.isOpen) {\n                client.disconnect();\n            }\n            reject(err);\n        });\n        client.connect().then(() => {\n            if (!client.isOpen) {\n                client.emit(\"error\", new Error(\"connection isn't open\"));\n            }\n            client.ping().then((res, err) => {\n                if (client.isOpen) {\n                    client.disconnect();\n                }\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(res);\n                }\n            }).catch(error => reject(error));\n        });\n    });\n};\n\n/**\n * Retrieve value of setting based on key\n * @param {string} key Key of setting to retrieve\n * @returns {Promise<any>} Value\n * @deprecated Use await Settings.get(key)\n */\nexports.setting = async function (key) {\n    return await Settings.get(key);\n};\n\n/**\n * Sets the specified setting to specifed value\n * @param {string} key Key of setting to set\n * @param {any} value Value to set to\n * @param {?string} type Type of setting\n * @returns {Promise<void>}\n */\nexports.setSetting = async function (key, value, type = null) {\n    await Settings.set(key, value, type);\n};\n\n/**\n * Get settings based on type\n * @param {string} type The type of setting\n * @returns {Promise<Bean>}\n */\nexports.getSettings = async function (type) {\n    return await Settings.getSettings(type);\n};\n\n/**\n * Set settings based on type\n * @param {string} type Type of settings to set\n * @param {Object} data Values of settings\n * @returns {Promise<void>}\n */\nexports.setSettings = async function (type, data) {\n    await Settings.setSettings(type, data);\n};\n\n// ssl-checker by @dyaa\n//https://github.com/dyaa/ssl-checker/blob/master/src/index.ts\n\n/**\n * Get number of days between two dates\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysBetween = (validFrom, validTo) =>\n    Math.round(Math.abs(+validFrom - +validTo) / 8.64e7);\n\n/**\n * Get days remaining from a time range\n * @param {Date} validFrom Start date\n * @param {Date} validTo End date\n * @returns {number}\n */\nconst getDaysRemaining = (validFrom, validTo) => {\n    const daysRemaining = getDaysBetween(validFrom, validTo);\n    if (new Date(validTo).getTime() < new Date().getTime()) {\n        return -daysRemaining;\n    }\n    return daysRemaining;\n};\n\n/**\n * Fix certificate info for display\n * @param {Object} info The chain obtained from getPeerCertificate()\n * @returns {Object} An object representing certificate information\n */\nconst parseCertificateInfo = function (info) {\n    let link = info;\n    let i = 0;\n\n    const existingList = {};\n\n    while (link) {\n        log.debug(\"cert\", `[${i}] ${link.fingerprint}`);\n\n        if (!link.valid_from || !link.valid_to) {\n            break;\n        }\n        link.validTo = new Date(link.valid_to);\n        link.validFor = link.subjectaltname?.replace(/DNS:|IP Address:/g, \"\").split(\", \");\n        link.daysRemaining = getDaysRemaining(new Date(), link.validTo);\n\n        existingList[link.fingerprint] = true;\n\n        // Move up the chain until loop is encountered\n        if (link.issuerCertificate == null) {\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            break;\n        } else if (link.issuerCertificate.fingerprint in existingList) {\n            // a root CA certificate is typically \"signed by itself\"  (=> \"self signed certificate\") and thus the \"issuerCertificate\" is a reference to itself.\n            log.debug(\"cert\", `[Last] ${link.issuerCertificate.fingerprint}`);\n            link.certType = (i === 0) ? \"self-signed\" : \"root CA\";\n            link.issuerCertificate = null;\n            break;\n        } else {\n            link.certType = (i === 0) ? \"server\" : \"intermediate CA\";\n            link = link.issuerCertificate;\n        }\n\n        // Should be no use, but just in case.\n        if (i > 500) {\n            throw new Error(\"Dead loop occurred in parseCertificateInfo\");\n        }\n        i++;\n    }\n\n    return info;\n};\n\n/**\n * Check if certificate is valid\n * @param {Object} res Response object from axios\n * @returns {Object} Object containing certificate information\n */\nexports.checkCertificate = function (res) {\n    if (!res.request.res.socket) {\n        throw new Error(\"No socket found\");\n    }\n\n    const info = res.request.res.socket.getPeerCertificate(true);\n    const valid = res.request.res.socket.authorized || false;\n\n    log.debug(\"cert\", \"Parsing Certificate Info\");\n    const parsedInfo = parseCertificateInfo(info);\n\n    return {\n        valid: valid,\n        certInfo: parsedInfo\n    };\n};\n\n/**\n * Check if the provided status code is within the accepted ranges\n * @param {number} status The status code to check\n * @param {string[]} acceptedCodes An array of accepted status codes\n * @returns {boolean} True if status code within range, false otherwise\n */\nexports.checkStatusCode = function (status, acceptedCodes) {\n    if (acceptedCodes == null || acceptedCodes.length === 0) {\n        return false;\n    }\n\n    for (const codeRange of acceptedCodes) {\n        if (typeof codeRange !== \"string\") {\n            log.error(\"monitor\", `Accepted status code not a string. ${codeRange} is of type ${typeof codeRange}`);\n            continue;\n        }\n\n        const codeRangeSplit = codeRange.split(\"-\").map(string => parseInt(string));\n        if (codeRangeSplit.length === 1) {\n            if (status === codeRangeSplit[0]) {\n                return true;\n            }\n        } else if (codeRangeSplit.length === 2) {\n            if (status >= codeRangeSplit[0] && status <= codeRangeSplit[1]) {\n                return true;\n            }\n        } else {\n            log.error(\"monitor\", `${codeRange} is not a valid status code range`);\n            continue;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Get total number of clients in room\n * @param {Server} io Socket server instance\n * @param {string} roomName Name of room to check\n * @returns {number}\n */\nexports.getTotalClientInRoom = (io, roomName) => {\n\n    const sockets = io.sockets;\n\n    if (!sockets) {\n        return 0;\n    }\n\n    const adapter = sockets.adapter;\n\n    if (!adapter) {\n        return 0;\n    }\n\n    const room = adapter.rooms.get(roomName);\n\n    if (room) {\n        return room.size;\n    } else {\n        return 0;\n    }\n};\n\n/**\n * Allow CORS all origins if development\n * @param {Object} res Response object from axios\n */\nexports.allowDevAllOrigin = (res) => {\n    if (process.env.NODE_ENV === \"development\") {\n        exports.allowAllOrigin(res);\n    }\n};\n\n/**\n * Allow CORS all origins\n * @param {Object} res Response object from axios\n */\nexports.allowAllOrigin = (res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\");\n    res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n};\n\n/**\n * Check if a user is logged in\n * @param {Socket} socket Socket instance\n */\nexports.checkLogin = (socket) => {\n    if (!socket.userID) {\n        throw new Error(\"You are not logged in.\");\n    }\n};\n\n/**\n * For logged-in users, double-check the password\n * @param {Socket} socket Socket.io instance\n * @param {string} currentPassword\n * @returns {Promise<Bean>}\n */\nexports.doubleCheckPassword = async (socket, currentPassword) => {\n    if (typeof currentPassword !== \"string\") {\n        throw new Error(\"Wrong data type?\");\n    }\n\n    let user = await R.findOne(\"user\", \" id = ? AND active = 1 \", [\n        socket.userID,\n    ]);\n\n    if (!user || !passwordHash.verify(currentPassword, user.password)) {\n        throw new Error(\"Incorrect current password\");\n    }\n\n    return user;\n};\n\n/** Start Unit tests */\nexports.startUnitTest = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"jest-backend\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/** Start end-to-end tests */\nexports.startE2eTests = async () => {\n    console.log(\"Starting unit test...\");\n    const npm = /^win/.test(process.platform) ? \"npm.cmd\" : \"npm\";\n    const child = childProcess.spawn(npm, [ \"run\", \"cy:run\" ]);\n\n    child.stdout.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.stderr.on(\"data\", (data) => {\n        console.log(data.toString());\n    });\n\n    child.on(\"close\", function (code) {\n        console.log(\"Jest exit code: \" + code);\n        process.exit(code);\n    });\n};\n\n/**\n * Convert unknown string to UTF8\n * @param {Uint8Array} body Buffer\n * @returns {string}\n */\nexports.convertToUTF8 = (body) => {\n    const guessEncoding = chardet.detect(body);\n    const str = iconv.decode(body, guessEncoding);\n    return str.toString();\n};\n\n/**\n * Returns a color code in hex format based on a given percentage:\n * 0% => hue = 10 => red\n * 100% => hue = 90 => green\n *\n * @param {number} percentage float, 0 to 1\n * @param {number} maxHue\n * @param {number} minHue, int\n * @returns {string}, hex value\n */\nexports.percentageToColor = (percentage, maxHue = 90, minHue = 10) => {\n    const hue = percentage * (maxHue - minHue) + minHue;\n    try {\n        return chroma(`hsl(${hue}, 90%, 40%)`).hex();\n    } catch (err) {\n        return badgeConstants.naColor;\n    }\n};\n\n/**\n * Joins and array of string to one string after filtering out empty values\n *\n * @param {string[]} parts\n * @param {string} connector\n * @returns {string}\n */\nexports.filterAndJoin = (parts, connector = \"\") => {\n    return parts.filter((part) => !!part && part !== \"\").join(connector);\n};\n\n/**\n * Send an Error response\n * @param {Object} res Express response object\n * @param {string} [msg=\"\"] Message to send\n */\nmodule.exports.sendHttpError = (res, msg = \"\") => {\n    if (msg.includes(\"SQLITE_BUSY\") || msg.includes(\"SQLITE_LOCKED\")) {\n        res.status(503).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else if (msg.toLowerCase().includes(\"not found\")) {\n        res.status(404).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    } else {\n        res.status(403).json({\n            \"status\": \"fail\",\n            \"msg\": msg,\n        });\n    }\n};\n\nfunction timeObjectConvertTimezone(obj, timezone, timeObjectToUTC = true) {\n    let offsetString;\n\n    if (timezone) {\n        offsetString = dayjs().tz(timezone).format(\"Z\");\n    } else {\n        offsetString = dayjs().format(\"Z\");\n    }\n\n    let hours = parseInt(offsetString.substring(1, 3));\n    let minutes = parseInt(offsetString.substring(4, 6));\n\n    if (\n        (timeObjectToUTC && offsetString.startsWith(\"+\")) ||\n        (!timeObjectToUTC && offsetString.startsWith(\"-\"))\n    ) {\n        hours *= -1;\n        minutes *= -1;\n    }\n\n    obj.hours += hours;\n    obj.minutes += minutes;\n\n    // Handle out of bound\n    if (obj.minutes < 0) {\n        obj.minutes += 60;\n        obj.hours--;\n    } else if (obj.minutes > 60) {\n        obj.minutes -= 60;\n        obj.hours++;\n    }\n\n    if (obj.hours < 0) {\n        obj.hours += 24;\n    } else if (obj.hours > 24) {\n        obj.hours -= 24;\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToUTC = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, true);\n};\n\n/**\n *\n * @param {object} obj\n * @param {string} timezone\n * @returns {object}\n */\nmodule.exports.timeObjectToLocal = (obj, timezone = undefined) => {\n    return timeObjectConvertTimezone(obj, timezone, false);\n};\n\n/**\n * Create gRPC client stib\n * @param {Object} options from gRPC client\n */\nmodule.exports.grpcQuery = async (options) => {\n    const { grpcUrl, grpcProtobufData, grpcServiceName, grpcEnableTls, grpcMethod, grpcBody } = options;\n    const protocObject = protojs.parse(grpcProtobufData);\n    const protoServiceObject = protocObject.root.lookupService(grpcServiceName);\n    const Client = grpc.makeGenericClientConstructor({});\n    const credentials = grpcEnableTls ? grpc.credentials.createSsl() : grpc.credentials.createInsecure();\n    const client = new Client(\n        grpcUrl,\n        credentials\n    );\n    const grpcService = protoServiceObject.create(function (method, requestData, cb) {\n        const fullServiceName = method.fullName;\n        const serviceFQDN = fullServiceName.split(\".\");\n        const serviceMethod = serviceFQDN.pop();\n        const serviceMethodClientImpl = `/${serviceFQDN.slice(1).join(\".\")}/${serviceMethod}`;\n        log.debug(\"monitor\", `gRPC method ${serviceMethodClientImpl}`);\n        client.makeUnaryRequest(\n            serviceMethodClientImpl,\n            arg => arg,\n            arg => arg,\n            requestData,\n            cb);\n    }, false, false);\n    return new Promise((resolve, _) => {\n        try {\n            return grpcService[`${grpcMethod}`](JSON.parse(grpcBody), function (err, response) {\n                const responseData = JSON.stringify(response);\n                if (err) {\n                    return resolve({\n                        code: err.code,\n                        errorMessage: err.details,\n                        data: \"\"\n                    });\n                } else {\n                    log.debug(\"monitor:\", `gRPC response: ${JSON.stringify(response)}`);\n                    return resolve({\n                        code: 1,\n                        errorMessage: \"\",\n                        data: responseData\n                    });\n                }\n            });\n        } catch (err) {\n            return resolve({\n                code: -1,\n                errorMessage: `Error ${err}. Please review your gRPC configuration option. The service name must not include package name value, and the method name must follow camelCase format`,\n                data: \"\"\n            });\n        }\n\n    });\n};\n\nmodule.exports.SHAKE256_LENGTH = 16;\n\n/**\n *\n * @param {string} data\n * @param {number} len\n * @return {string}\n */\nmodule.exports.shake256 = (data, len) => {\n    if (!data) {\n        return \"\";\n    }\n    return crypto.createHash(\"shake256\", { outputLength: len })\n        .update(data)\n        .digest(\"hex\");\n};\n\n// For unit test, export functions\nif (process.env.TEST_BACKEND) {\n    module.exports.__test = {\n        parseCertificateInfo,\n    };\n    module.exports.__getPrivateFunction = (functionName) => {\n        return module.exports.__test[functionName];\n    };\n}\n"], "filenames": ["server/model/user.js", "server/server.js", "server/util-server.js"], "buggy_code_start_loc": [3, 85, 35], "buggy_code_end_loc": [29, 393, 1057], "fixing_code_start_loc": [4, 86, 36], "fixing_code_end_loc": [45, 398, 1076], "type": "CWE-384", "message": "Uptime Kuma is a self-hosted monitoring tool. Prior to version 1.23.3, attackers with access to a user's device can gain persistent account access. This is caused by missing verification of Session Tokens after password changes and/or elapsed inactivity periods. Version 1.23.3 has a patch for the issue.", "other": {"cve": {"id": "CVE-2023-44400", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-09T16:15:10.567", "lastModified": "2023-10-13T18:24:14.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Uptime Kuma is a self-hosted monitoring tool. Prior to version 1.23.3, attackers with access to a user's device can gain persistent account access. This is caused by missing verification of Session Tokens after password changes and/or elapsed inactivity periods. Version 1.23.3 has a patch for the issue."}, {"lang": "es", "value": "Uptime Kuma es una herramienta de monitoreo autohospedada. Antes de la versi\u00f3n 1.23.3, los atacantes con acceso al dispositivo de un usuario pod\u00edan obtener acceso persistente a la cuenta. Esto se debe a la falta de verificaci\u00f3n de los tokens de sesi\u00f3n despu\u00e9s de cambios de contrase\u00f1a y/o per\u00edodos de inactividad transcurridos. La versi\u00f3n 1.23.3 tiene un parche para el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uptime.kuma:uptime_kuma:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.23.3", "matchCriteriaId": "F178E40D-CC31-4E9A-B03C-A648C13E94D2"}]}]}], "references": [{"url": "https://github.com/louislam/uptime-kuma/commit/88afab6571ef7d4d41bb395cdb6ecd3968835a4a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/louislam/uptime-kuma/issues/3481", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Mitigation"]}, {"url": "https://github.com/louislam/uptime-kuma/security/advisories/GHSA-g9v2-wqcj-j99g", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/louislam/uptime-kuma/commit/88afab6571ef7d4d41bb395cdb6ecd3968835a4a"}}