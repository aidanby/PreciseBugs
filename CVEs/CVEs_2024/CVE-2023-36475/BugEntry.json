{"buggy_code": ["{\n    \"root\": true,\n    \"extends\": \"eslint:recommended\",\n    \"env\": {\n        \"node\": true,\n        \"es6\": true\n    },\n    \"parser\": \"@babel/eslint-parser\",\n    \"plugins\": [\n        \"flowtype\"\n    ],\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"requireConfigFile\": false\n    },\n    \"rules\": {\n        \"indent\": [\"error\", 2, { \"SwitchCase\": 1 }],\n        \"linebreak-style\": [\"error\", \"unix\"],\n        \"no-trailing-spaces\": 2,\n        \"eol-last\": 2,\n        \"space-in-parens\": [\"error\", \"never\"],\n        \"no-multiple-empty-lines\": 1,\n        \"prefer-const\": \"error\",\n        \"space-infix-ops\": \"error\",\n        \"no-useless-escape\": \"off\",\n        \"require-atomic-updates\": \"off\"\n    }\n}\n", "const request = require('../lib/request');\n\ndescribe('Vulnerabilities', () => {\n  describe('Object prototype pollution', () => {\n    it('denies object prototype to be polluted with keyword \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {\n            constructor: {\n              prototype: {\n                dummy: 0,\n              },\n            },\n          },\n        }),\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n\n    it('denies object prototype to be polluted with keypath string \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const objResponse = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {},\n        }),\n      }).catch(e => e);\n      const pollResponse = await request({\n        headers: headers,\n        method: 'PUT',\n        url: `http://localhost:8378/1/classes/PP/${objResponse.data.objectId}`,\n        body: JSON.stringify({\n          'obj.constructor.prototype.dummy': {\n            __op: 'Increment',\n            amount: 1,\n          },\n        }),\n      }).catch(e => e);\n      expect(Object.prototype.dummy).toBeUndefined();\n      expect(pollResponse.status).toBe(400);\n      const text = JSON.parse(pollResponse.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n\n    it('denies object prototype to be polluted with keyword \"__proto__\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({ 'obj.__proto__.dummy': 0 }),\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"__proto__\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n  });\n\n  describe('Request denylist', () => {\n    it('denies BSON type code data in write request by default', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.'\n      );\n    });\n\n    it('denies expanding existing object with polluted keys', async () => {\n      const obj = await new Parse.Object('RCE', { a: { foo: [] } }).save();\n      await reconfigureServer({\n        requestKeywordDenylist: ['foo'],\n      });\n      obj.addUnique('a.foo', 'abc');\n      await expectAsync(obj.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Prohibited keyword in request data: \"foo\".`)\n      );\n    });\n\n    it('denies creating a cloud trigger with polluted data', async () => {\n      Parse.Cloud.beforeSave('TestObject', ({ object }) => {\n        object.set('obj', {\n          constructor: {\n            prototype: {\n              dummy: 0,\n            },\n          },\n        });\n      });\n      await expectAsync(new Parse.Object('TestObject').save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"constructor\"}.'\n        )\n      );\n    });\n\n    it('denies creating a hook with polluted data', async () => {\n      const express = require('express');\n      const bodyParser = require('body-parser');\n      const port = 34567;\n      const hookServerURL = 'http://localhost:' + port;\n      const app = express();\n      app.use(bodyParser.json({ type: '*/*' }));\n      const server = await new Promise(resolve => {\n        const res = app.listen(port, undefined, () => resolve(res));\n      });\n      app.post('/BeforeSave', function (req, res) {\n        const object = Parse.Object.fromJSON(req.body.object);\n        object.set('hello', 'world');\n        object.set('obj', {\n          constructor: {\n            prototype: {\n              dummy: 0,\n            },\n          },\n        });\n        res.json({ success: object });\n      });\n      await Parse.Hooks.createTrigger('TestObject', 'beforeSave', hookServerURL + '/BeforeSave');\n      await expectAsync(new Parse.Object('TestObject').save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"constructor\"}.'\n        )\n      );\n      await new Promise(resolve => server.close(resolve));\n    });\n\n    it('allows BSON type code data in write request with custom denylist', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(201);\n      const text = JSON.parse(response.text);\n      expect(text.objectId).toBeDefined();\n    });\n\n    it('denies write request with custom denylist of key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of nested key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            nested: {\n              aKey: 'aValue321',\n              code: 'delete Object.prototype.evalFunctions',\n            },\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of key/value in array', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: [\n            {\n              aKey: 'aValue321',\n              code: 'delete Object.prototype.evalFunctions',\n            },\n          ],\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of key', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\"}.');\n    });\n\n    it('denies write request with custom denylist of value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"value\":\"aValue[123]*\"}.');\n    });\n\n    it('denies BSON type code data in file metadata', async () => {\n      const str = 'Hello World!';\n      const data = [];\n      for (let i = 0; i < str.length; i++) {\n        data.push(str.charCodeAt(i));\n      }\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      file.addMetadata('obj', {\n        _bsontype: 'Code',\n        code: 'delete Object.prototype.evalFunctions',\n      });\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          `Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.`\n        )\n      );\n    });\n\n    it('denies BSON type code data in file tags', async () => {\n      const str = 'Hello World!';\n      const data = [];\n      for (let i = 0; i < str.length; i++) {\n        data.push(str.charCodeAt(i));\n      }\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      file.addTag('obj', {\n        _bsontype: 'Code',\n        code: 'delete Object.prototype.evalFunctions',\n      });\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          `Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.`\n        )\n      );\n    });\n  });\n\n  describe('Ignore non-matches', () => {\n    it('ignores write request that contains only fraction of denied keyword', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'abc' }],\n      });\n      // Initially saving an object executes the keyword detection in RestWrite.js\n      const obj = new TestObject({ a: { b: { c: 0 } } });\n      await expectAsync(obj.save()).toBeResolved();\n      // Modifying a nested key executes the keyword detection in DatabaseController.js\n      obj.increment('a.b.c');\n      await expectAsync(obj.save()).toBeResolved();\n    });\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from '../Adapters/Storage/Postgres/PostgresStorageAdapter';\nimport SchemaCache from '../Adapters/Cache/SchemaCache';\nimport type { LoadSchemaOptions } from './types';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQueryKeys = ['$and', '$or', '$nor', '_rperm', '_wperm'];\nconst specialMasterQueryKeys = [\n  ...specialQueryKeys,\n  '_email_verify_token',\n  '_perishable_token',\n  '_tombstone',\n  '_email_verify_token_expires_at',\n  '_failed_login_count',\n  '_account_lockout_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst validateQuery = (\n  query: any,\n  isMaster: boolean,\n  isMaintenance: boolean,\n  update: boolean\n): void => {\n  if (isMaintenance) {\n    isMaster = true;\n  }\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (\n      !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/) &&\n      ((!specialQueryKeys.includes(key) && !isMaster && !update) ||\n        (update && isMaster && !specialMasterQueryKeys.includes(key)))\n    ) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  isMaintenance: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController | any,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms =\n    schema && schema.getClassLevelPermissions ? schema.getClassLevelPermissions(className) : {};\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n  if (isUserClass) {\n    object.password = object._hashed_password;\n    delete object._hashed_password;\n    delete object.sessionToken;\n  }\n\n  if (isMaintenance) {\n    return object;\n  }\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    // but were needed to apply protectedFields\n    perms?.protectedFields?.temporaryKeys?.forEach(k => delete object[k]);\n  }\n\n  for (const key in object) {\n    if (key.charAt(0) === '_') {\n      delete object[key];\n    }\n  }\n\n  if (!isUserClass || isMaster) {\n    return object;\n  }\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n  idempotencyOptions: any;\n\n  constructor(adapter: StorageAdapter, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.options = options || {};\n    this.idempotencyOptions = this.options.idempotencyOptions || {};\n    // Prevent mutable this.schema, otherwise one request could use\n    // multiple schemas, so instead use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions,\n    maintenance: boolean\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query, maintenance);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query, isMaster, false, true);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query, isMaster, false, false);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(getRootFieldName(field)) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    SchemaCache.clear();\n    return this.adapter.deleteAllClasses(fast);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    const promises = [];\n    if (query['$or']) {\n      const ors = query['$or'];\n      promises.push(\n        ...ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      );\n    }\n    if (query['$and']) {\n      const ands = query['$and'];\n      promises.push(\n        ...ands.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$and'][index] = aQuery;\n          });\n        })\n      );\n    }\n\n    const otherKeys = Object.keys(query).map(key => {\n      if (key === '$and' || key === '$or') {\n        return;\n      }\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all([...promises, ...otherKeys]).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    if (query['$and']) {\n      return Promise.all(\n        query['$and'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaintenance = auth.isMaintenance;\n    const isMaster = acl === undefined || isMaintenance;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n            if (!schema.fields[fieldName.split('.')[0]] && fieldName !== 'score') {\n              delete sort[fieldName];\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query, isMaster, isMaintenance, false);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        isMaintenance,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    let schemaController;\n    return this.loadSchema({ clearCache: true })\n      .then(s => {\n        schemaController = s;\n        return schemaController.getOneSchema(className, true);\n      })\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                SchemaCache.del(className);\n                return schemaController.reloadData();\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController | any,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms =\n      schema && schema.getClassLevelPermissions\n        ? schema.getClassLevelPermissions(className)\n        : schema;\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  async performInitialization() {\n    await this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n    await this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'));\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for usernames: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['email'], 'case_insensitive_email', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for role name: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n        throw error;\n      });\n\n    const isMongoAdapter = this.adapter instanceof MongoStorageAdapter;\n    const isPostgresAdapter = this.adapter instanceof PostgresStorageAdapter;\n    if (isMongoAdapter || isPostgresAdapter) {\n      let options = {};\n      if (isMongoAdapter) {\n        options = {\n          ttl: 0,\n        };\n      } else if (isPostgresAdapter) {\n        options = this.idempotencyOptions;\n        options.setIdempotencyFunction = true;\n      }\n      await this.adapter\n        .ensureIndex('_Idempotency', requiredIdempotencyFields, ['expire'], 'ttl', false, options)\n        .catch(error => {\n          logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n          throw error;\n        });\n    }\n    await this.adapter.updateSchemaWithIndexes();\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue(\n          { [firstKey]: true, [nextPath]: true },\n          keyword.key,\n          true\n        );\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: (any, boolean, boolean, boolean) => void;\n  static filterSensitiveData: (boolean, boolean, any[], any, any, any, string, any[], any) => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\nmodule.exports.filterSensitiveData = filterSensitiveData;\n", "// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nconst Auth = require('./Auth');\nconst Utils = require('./Utils');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\nconst util = require('util');\nimport RestQuery from './RestQuery';\nimport _ from 'lodash';\nimport logger from './logger';\nimport { requiredColumns } from './Controllers/SchemaController';\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK, context, action) {\n  if (auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      'Cannot perform a write operation when using readOnlyMasterKey'\n    );\n  }\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  this.context = context || {};\n\n  if (action) {\n    this.runOptions.action = action;\n  }\n\n  if (!query) {\n    if (this.config.allowCustomObjectId) {\n      if (Object.prototype.hasOwnProperty.call(data, 'objectId') && !data.objectId) {\n        throw new Parse.Error(\n          Parse.Error.MISSING_OBJECT_ID,\n          'objectId must not be empty, null or undefined'\n        );\n      }\n    } else {\n      if (data.objectId) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n      }\n      if (data.id) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'id is an invalid field name.');\n      }\n    }\n  }\n\n  this.checkProhibitedKeywords(data);\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n\n  // Shared SchemaController to be reused to reduce the number of loadSchema() calls per request\n  // Once set the schemaData should be immutable\n  this.validSchemaController = null;\n  this.pendingOps = {\n    operations: null,\n    identifier: null,\n  };\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.handleInstallation();\n    })\n    .then(() => {\n      return this.handleSession();\n    })\n    .then(() => {\n      return this.validateAuthData();\n    })\n    .then(() => {\n      return this.runBeforeSaveTrigger();\n    })\n    .then(() => {\n      return this.ensureUniqueAuthDataId();\n    })\n    .then(() => {\n      return this.deleteEmailResetTokenIfNeeded();\n    })\n    .then(() => {\n      return this.validateSchema();\n    })\n    .then(schemaController => {\n      this.validSchemaController = schemaController;\n      return this.setRequiredFieldsIfNeeded();\n    })\n    .then(() => {\n      return this.transformUser();\n    })\n    .then(() => {\n      return this.expandFilesForExistingObjects();\n    })\n    .then(() => {\n      return this.destroyDuplicatedSessions();\n    })\n    .then(() => {\n      return this.runDatabaseOperation();\n    })\n    .then(() => {\n      return this.createSessionTokenIfNeeded();\n    })\n    .then(() => {\n      return this.handleFollowup();\n    })\n    .then(() => {\n      return this.runAfterSaveTrigger();\n    })\n    .then(() => {\n      return this.cleanUserAuthData();\n    })\n    .then(() => {\n      // Append the authDataResponse if exists\n      if (this.authDataResponse) {\n        if (this.response && this.response.response) {\n          this.response.response.authDataResponse = this.authDataResponse;\n        }\n      }\n      return this.response;\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster || this.auth.isMaintenance) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.runOptions.acl = this.runOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    !this.auth.isMaintenance &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function () {\n  return this.config.database.validateObject(\n    this.className,\n    this.data,\n    this.query,\n    this.runOptions,\n    this.auth.isMaintenance\n  );\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeSaveTrigger = function () {\n  if (this.response || this.runOptions.many) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)\n  ) {\n    return Promise.resolve();\n  }\n\n  const { originalObject, updatedObject } = this.buildParseObjects();\n  const identifier = updatedObject._getStateIdentifier();\n  const stateController = Parse.CoreManager.getObjectStateController();\n  const [pending] = stateController.getPendingOps(identifier);\n  this.pendingOps = {\n    operations: { ...pending },\n    identifier,\n  };\n\n  return Promise.resolve()\n    .then(() => {\n      // Before calling the trigger, validate the permissions for the save operation\n      let databasePromise = null;\n      if (this.query) {\n        // Validate for updating\n        databasePromise = this.config.database.update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          true,\n          true\n        );\n      } else {\n        // Validate for creating\n        databasePromise = this.config.database.create(\n          this.className,\n          this.data,\n          this.runOptions,\n          true\n        );\n      }\n      // In the case that there is no permission for the operation, it throws an error\n      return databasePromise.then(result => {\n        if (!result || result.length <= 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n      });\n    })\n    .then(() => {\n      return triggers.maybeRunTrigger(\n        triggers.Types.beforeSave,\n        this.auth,\n        updatedObject,\n        originalObject,\n        this.config,\n        this.context\n      );\n    })\n    .then(response => {\n      if (response && response.object) {\n        this.storage.fieldsChangedByTrigger = _.reduce(\n          response.object,\n          (result, value, key) => {\n            if (!_.isEqual(this.data[key], value)) {\n              result.push(key);\n            }\n            return result;\n          },\n          []\n        );\n        this.data = response.object;\n        // We should delete the objectId for an update write\n        if (this.query && this.query.objectId) {\n          delete this.data.objectId;\n        }\n      }\n      this.checkProhibitedKeywords(this.data);\n    });\n};\n\nRestWrite.prototype.runBeforeLoginTrigger = async function (userData) {\n  // Avoid doing any setup for triggers if there is no 'beforeLogin' trigger\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeLogin, this.config.applicationId)\n  ) {\n    return;\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  const extraData = { className: this.className };\n\n  // Expand file objects\n  this.config.filesController.expandFilesInObject(this.config, userData);\n\n  const user = triggers.inflate(extraData, userData);\n\n  // no need to return a response\n  await triggers.maybeRunTrigger(\n    triggers.Types.beforeLogin,\n    this.auth,\n    user,\n    null,\n    this.config,\n    this.context\n  );\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function () {\n  if (this.data) {\n    return this.validSchemaController.getAllClasses().then(allClasses => {\n      const schema = allClasses.find(oneClass => oneClass.className === this.className);\n      const setRequiredFieldIfNeeded = (fieldName, setDefault) => {\n        if (\n          this.data[fieldName] === undefined ||\n          this.data[fieldName] === null ||\n          this.data[fieldName] === '' ||\n          (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete')\n        ) {\n          if (\n            setDefault &&\n            schema.fields[fieldName] &&\n            schema.fields[fieldName].defaultValue !== null &&\n            schema.fields[fieldName].defaultValue !== undefined &&\n            (this.data[fieldName] === undefined ||\n              (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete'))\n          ) {\n            this.data[fieldName] = schema.fields[fieldName].defaultValue;\n            this.storage.fieldsChangedByTrigger = this.storage.fieldsChangedByTrigger || [];\n            if (this.storage.fieldsChangedByTrigger.indexOf(fieldName) < 0) {\n              this.storage.fieldsChangedByTrigger.push(fieldName);\n            }\n          } else if (schema.fields[fieldName] && schema.fields[fieldName].required === true) {\n            throw new Parse.Error(Parse.Error.VALIDATION_ERROR, `${fieldName} is required`);\n          }\n        }\n      };\n\n      // Add default fields\n      this.data.updatedAt = this.updatedAt;\n      if (!this.query) {\n        this.data.createdAt = this.updatedAt;\n\n        // Only assign new objectId if we are creating new object\n        if (!this.data.objectId) {\n          this.data.objectId = cryptoUtils.newObjectId(this.config.objectIdSize);\n        }\n        if (schema) {\n          Object.keys(schema.fields).forEach(fieldName => {\n            setRequiredFieldIfNeeded(fieldName, true);\n          });\n        }\n      } else if (schema) {\n        Object.keys(this.data).forEach(fieldName => {\n          setRequiredFieldIfNeeded(fieldName, false);\n        });\n      }\n    });\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  const authData = this.data.authData;\n  const hasUsernameAndPassword =\n    typeof this.data.username === 'string' && typeof this.data.password === 'string';\n\n  if (!this.query && !authData) {\n    if (typeof this.data.username !== 'string' || _.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required');\n    }\n  }\n\n  if (\n    (authData && !Object.keys(authData).length) ||\n    !Object.prototype.hasOwnProperty.call(this.data, 'authData')\n  ) {\n    // Nothing to validate here\n    return;\n  } else if (Object.prototype.hasOwnProperty.call(this.data, 'authData') && !this.data.authData) {\n    // Handle saving authData to null\n    throw new Parse.Error(\n      Parse.Error.UNSUPPORTED_SERVICE,\n      'This authentication method is unsupported.'\n    );\n  }\n\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    const canHandleAuthData = providers.some(provider => {\n      var providerAuthData = authData[provider];\n      var hasToken = providerAuthData && providerAuthData.id;\n      return hasToken || providerAuthData === null;\n    });\n    if (canHandleAuthData || hasUsernameAndPassword || this.auth.isMaster || this.getUserId()) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(\n    Parse.Error.UNSUPPORTED_SERVICE,\n    'This authentication method is unsupported.'\n  );\n};\n\nRestWrite.prototype.filteredObjectsByACL = function (objects) {\n  if (this.auth.isMaster || this.auth.isMaintenance) {\n    return objects;\n  }\n  return objects.filter(object => {\n    if (!object.ACL) {\n      return true; // legacy users that have no ACL field on them\n    }\n    // Regular users that have been locked out.\n    return object.ACL && Object.keys(object.ACL).length > 0;\n  });\n};\n\nRestWrite.prototype.getUserId = function () {\n  if (this.query && this.query.objectId && this.className === '_User') {\n    return this.query.objectId;\n  } else if (this.auth && this.auth.user && this.auth.user.id) {\n    return this.auth.user.id;\n  }\n};\n\n// Developers are allowed to change authData via before save trigger\n// we need after before save to ensure that the developer\n// is not currently duplicating auth data ID\nRestWrite.prototype.ensureUniqueAuthDataId = async function () {\n  if (this.className !== '_User' || !this.data.authData) {\n    return;\n  }\n\n  const hasAuthDataId = Object.keys(this.data.authData).some(\n    key => this.data.authData[key] && this.data.authData[key].id\n  );\n\n  if (!hasAuthDataId) return;\n\n  const r = await Auth.findUsersWithAuthData(this.config, this.data.authData);\n  const results = this.filteredObjectsByACL(r);\n  if (results.length > 1) {\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n  // use data.objectId in case of login time and found user during handle validateAuthData\n  const userId = this.getUserId() || this.data.objectId;\n  if (results.length === 1 && userId !== results[0].objectId) {\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n};\n\nRestWrite.prototype.handleAuthData = async function (authData) {\n  const r = await Auth.findUsersWithAuthData(this.config, authData);\n  const results = this.filteredObjectsByACL(r);\n\n  if (results.length > 1) {\n    // To avoid https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5\n    // Let's run some validation before throwing\n    await Auth.handleAuthDataValidation(authData, this, results[0]);\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n\n  // No user found with provided authData we need to validate\n  if (!results.length) {\n    const { authData: validatedAuthData, authDataResponse } = await Auth.handleAuthDataValidation(\n      authData,\n      this\n    );\n    this.authDataResponse = authDataResponse;\n    // Replace current authData by the new validated one\n    this.data.authData = validatedAuthData;\n    return;\n  }\n\n  // User found with provided authData\n  if (results.length === 1) {\n    const userId = this.getUserId();\n    const userResult = results[0];\n    // Prevent duplicate authData id\n    if (userId && userId !== userResult.objectId) {\n      throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n    }\n\n    this.storage.authProvider = Object.keys(authData).join(',');\n\n    const { hasMutatedAuthData, mutatedAuthData } = Auth.hasMutatedAuthData(\n      authData,\n      userResult.authData\n    );\n\n    const isCurrentUserLoggedOrMaster =\n      (this.auth && this.auth.user && this.auth.user.id === userResult.objectId) ||\n      this.auth.isMaster;\n\n    const isLogin = !userId;\n\n    if (isLogin || isCurrentUserLoggedOrMaster) {\n      // no user making the call\n      // OR the user making the call is the right one\n      // Login with auth data\n      delete results[0].password;\n\n      // need to set the objectId first otherwise location has trailing undefined\n      this.data.objectId = userResult.objectId;\n\n      if (!this.query || !this.query.objectId) {\n        this.response = {\n          response: userResult,\n          location: this.location(),\n        };\n        // Run beforeLogin hook before storing any updates\n        // to authData on the db; changes to userResult\n        // will be ignored.\n        await this.runBeforeLoginTrigger(deepcopy(userResult));\n\n        // If we are in login operation via authData\n        // we need to be sure that the user has provided\n        // required authData\n        Auth.checkIfUserHasProvidedConfiguredProvidersForLogin(\n          authData,\n          userResult.authData,\n          this.config\n        );\n      }\n\n      // Prevent validating if no mutated data detected on update\n      if (!hasMutatedAuthData && isCurrentUserLoggedOrMaster) {\n        return;\n      }\n\n      // Force to validate all provided authData on login\n      // on update only validate mutated ones\n      if (hasMutatedAuthData || !this.config.allowExpiredAuthDataToken) {\n        const res = await Auth.handleAuthDataValidation(\n          isLogin ? authData : mutatedAuthData,\n          this,\n          userResult\n        );\n        this.data.authData = res.authData;\n        this.authDataResponse = res.authDataResponse;\n      }\n\n      // IF we are in login we'll skip the database operation / beforeSave / afterSave etc...\n      // we need to set it up there.\n      // We are supposed to have a response only on LOGIN with authData, so we skip those\n      // If we're not logging in, but just updating the current user, we can safely skip that part\n      if (this.response) {\n        // Assign the new authData in the response\n        Object.keys(mutatedAuthData).forEach(provider => {\n          this.response.response.authData[provider] = mutatedAuthData[provider];\n        });\n\n        // Run the DB update directly, as 'master' only if authData contains some keys\n        // authData could not contains keys after validation if the authAdapter\n        // uses the `doNotSave` option. Just update the authData part\n        // Then we're good for the user, early exit of sorts\n        if (Object.keys(this.data.authData).length) {\n          await this.config.database.update(\n            this.className,\n            { objectId: this.data.objectId },\n            { authData: this.data.authData },\n            {}\n          );\n        }\n      }\n    }\n  }\n};\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function () {\n  var promise = Promise.resolve();\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (!this.auth.isMaintenance && !this.auth.isMaster && 'emailVerified' in this.data) {\n    const error = `Clients aren't allowed to manually update email verification.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // Do not cleanup session if objectId is not set\n  if (this.query && this.objectId()) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    })\n      .execute()\n      .then(results => {\n        results.results.forEach(session =>\n          this.config.cacheController.user.del(session.sessionToken)\n        );\n      });\n  }\n\n  return promise\n    .then(() => {\n      // Transform the password\n      if (this.data.password === undefined) {\n        // ignore only if undefined. should proceed if empty ('')\n        return Promise.resolve();\n      }\n\n      if (this.query) {\n        this.storage['clearSessions'] = true;\n        // Generate a new session only if the user requested\n        if (!this.auth.isMaster && !this.auth.isMaintenance) {\n          this.storage['generateNewSession'] = true;\n        }\n      }\n\n      return this._validatePasswordPolicy().then(() => {\n        return passwordCrypto.hash(this.data.password).then(hashedPassword => {\n          this.data._hashed_password = hashedPassword;\n          delete this.data.password;\n        });\n      });\n    })\n    .then(() => {\n      return this._validateUserName();\n    })\n    .then(() => {\n      return this._validateEmail();\n    });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  /*\n    Usernames should be unique when compared case insensitively\n\n    Users should be able to make case sensitive usernames and\n    login using the case they entered.  I.e. 'Snoopy' should preclude\n    'snoopy' as a valid username.\n  */\n  return this.config.database\n    .find(\n      this.className,\n      {\n        username: this.data.username,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.USERNAME_TAKEN,\n          'Account already exists for this username.'\n        );\n      }\n      return;\n    });\n};\n\n/*\n  As with usernames, Parse should not allow case insensitive collisions of email.\n  unlike with usernames (which can have case insensitive collisions in the case of\n  auth adapters), emails should never have a case insensitive collision.\n\n  This behavior can be enforced through a properly configured index see:\n  https://docs.mongodb.com/manual/core/index-case-insensitive/#create-a-case-insensitive-index\n  which could be implemented instead of this code based validation.\n\n  Given that this lookup should be a relatively low use case and that the case sensitive\n  unique index will be used by the db for the query, this is an adequate solution.\n*/\nRestWrite.prototype._validateEmail = function () {\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(\n      new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.')\n    );\n  }\n  // Case insensitive match, see note above function.\n  return this.config.database\n    .find(\n      this.className,\n      {\n        email: this.data.email,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.EMAIL_TAKEN,\n          'Account already exists for this email address.'\n        );\n      }\n      if (\n        !this.data.authData ||\n        !Object.keys(this.data.authData).length ||\n        (Object.keys(this.data.authData).length === 1 &&\n          Object.keys(this.data.authData)[0] === 'anonymous')\n      ) {\n        // We updated the email, send a new validation\n        this.storage['sendVerificationEmail'] = true;\n        this.config.userController.setEmailVerifyToken(this.data);\n      }\n    });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function () {\n  if (!this.config.passwordPolicy) return Promise.resolve();\n  return this._validatePasswordRequirements().then(() => {\n    return this._validatePasswordHistory();\n  });\n};\n\nRestWrite.prototype._validatePasswordRequirements = function () {\n  // check if the password conforms to the defined password policy if configured\n  // If we specified a custom error in our configuration use it.\n  // Example: \"Passwords must include a Capital Letter, Lowercase Letter, and a number.\"\n  //\n  // This is especially useful on the generic \"password reset\" page,\n  // as it allows the programmer to communicate specific requirements instead of:\n  // a. making the user guess whats wrong\n  // b. making a custom password reset page that shows the requirements\n  const policyError = this.config.passwordPolicy.validationError\n    ? this.config.passwordPolicy.validationError\n    : 'Password does not meet the Password Policy requirements.';\n  const containsUsernameError = 'Password cannot contain your username.';\n\n  // check whether the password meets the password strength requirements\n  if (\n    (this.config.passwordPolicy.patternValidator &&\n      !this.config.passwordPolicy.patternValidator(this.data.password)) ||\n    (this.config.passwordPolicy.validatorCallback &&\n      !this.config.passwordPolicy.validatorCallback(this.data.password))\n  ) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) {\n      // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0)\n        return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError));\n    } else {\n      // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', { objectId: this.objectId() }).then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        if (this.data.password.indexOf(results[0].username) >= 0)\n          return Promise.reject(\n            new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError)\n          );\n        return Promise.resolve();\n      });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function () {\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database\n      .find(\n        '_User',\n        { objectId: this.objectId() },\n        { keys: ['_password_history', '_hashed_password'] },\n        Auth.maintenance(this.config)\n      )\n      .then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history)\n          oldPasswords = _.take(\n            user._password_history,\n            this.config.passwordPolicy.maxPasswordHistory - 1\n          );\n        oldPasswords.push(user.password);\n        const newPassword = this.data.password;\n        // compare the new password hash with all old password hashes\n        const promises = oldPasswords.map(function (hash) {\n          return passwordCrypto.compare(newPassword, hash).then(result => {\n            if (result)\n              // reject if there is a match\n              return Promise.reject('REPEAT_PASSWORD');\n            return Promise.resolve();\n          });\n        });\n        // wait for all comparisons to complete\n        return Promise.all(promises)\n          .then(() => {\n            return Promise.resolve();\n          })\n          .catch(err => {\n            if (err === 'REPEAT_PASSWORD')\n              // a match was found\n              return Promise.reject(\n                new Parse.Error(\n                  Parse.Error.VALIDATION_ERROR,\n                  `New password should not be the same as last ${this.config.passwordPolicy.maxPasswordHistory} passwords.`\n                )\n              );\n            throw err;\n          });\n      });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n  // Don't generate session for updating user (this.query is set) unless authData exists\n  if (this.query && !this.data.authData) {\n    return;\n  }\n  // Don't generate new sessionToken if linking via sessionToken\n  if (this.auth.user && this.data.authData) {\n    return;\n  }\n  if (\n    !this.storage.authProvider && // signup call, with\n    this.config.preventLoginWithUnverifiedEmail && // no login without verification\n    this.config.verifyUserEmails\n  ) {\n    // verification is on\n    return; // do not create the session token in that case!\n  }\n  return this.createSessionToken();\n};\n\nRestWrite.prototype.createSessionToken = async function () {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n\n  if (this.storage.authProvider == null && this.data.authData) {\n    this.storage.authProvider = Object.keys(this.data.authData).join(',');\n  }\n\n  const { sessionData, createSession } = RestWrite.createSession(this.config, {\n    userId: this.objectId(),\n    createdWith: {\n      action: this.storage.authProvider ? 'login' : 'signup',\n      authProvider: this.storage.authProvider || 'password',\n    },\n    installationId: this.auth.installationId,\n  });\n\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = sessionData.sessionToken;\n  }\n\n  return createSession();\n};\n\nRestWrite.createSession = function (\n  config,\n  { userId, createdWith, installationId, additionalSessionData }\n) {\n  const token = 'r:' + cryptoUtils.newToken();\n  const expiresAt = config.generateSessionExpiresAt();\n  const sessionData = {\n    sessionToken: token,\n    user: {\n      __type: 'Pointer',\n      className: '_User',\n      objectId: userId,\n    },\n    createdWith,\n    expiresAt: Parse._encode(expiresAt),\n  };\n\n  if (installationId) {\n    sessionData.installationId = installationId;\n  }\n\n  Object.assign(sessionData, additionalSessionData);\n\n  return {\n    sessionData,\n    createSession: () =>\n      new RestWrite(config, Auth.master(config), '_Session', null, sessionData).execute(),\n  };\n};\n\n// Delete email reset tokens if user is changing password or email.\nRestWrite.prototype.deleteEmailResetTokenIfNeeded = function () {\n  if (this.className !== '_User' || this.query === null) {\n    // null query means create\n    return;\n  }\n\n  if ('password' in this.data || 'email' in this.data) {\n    const addOps = {\n      _perishable_token: { __op: 'Delete' },\n      _perishable_token_expires_at: { __op: 'Delete' },\n    };\n    this.data = Object.assign(this.data, addOps);\n  }\n};\n\nRestWrite.prototype.destroyDuplicatedSessions = function () {\n  // Only for _Session, and at creation time\n  if (this.className != '_Session' || this.query) {\n    return;\n  }\n  // Destroy the sessions in 'Background'\n  const { user, installationId, sessionToken } = this.data;\n  if (!user || !installationId) {\n    return;\n  }\n  if (!user.objectId) {\n    return;\n  }\n  this.config.database.destroy(\n    '_Session',\n    {\n      user,\n      installationId,\n      sessionToken: { $ne: sessionToken },\n    },\n    {},\n    this.validSchemaController\n  );\n};\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function () {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database\n      .destroy('_Session', sessionQuery)\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken().then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an _Session object.\nRestWrite.prototype.handleSession = function () {\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster && !this.auth.isMaintenance) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' + 'ACL on a Session.');\n  }\n\n  if (this.query) {\n    if (this.data.user && !this.auth.isMaster && this.data.user.objectId != this.auth.user.id) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.installationId) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.sessionToken) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    }\n    if (!this.auth.isMaster) {\n      this.query = {\n        $and: [\n          this.query,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  if (!this.query && !this.auth.isMaster && !this.auth.isMaintenance) {\n    const additionalSessionData = {};\n    for (var key in this.data) {\n      if (key === 'objectId' || key === 'user') {\n        continue;\n      }\n      additionalSessionData[key] = this.data[key];\n    }\n\n    const { sessionData, createSession } = RestWrite.createSession(this.config, {\n      userId: this.auth.user.id,\n      createdWith: {\n        action: 'create',\n      },\n      additionalSessionData,\n    });\n\n    return createSession().then(results => {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      this.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData,\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function () {\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (\n    !this.query &&\n    !this.data.deviceToken &&\n    !this.data.installationId &&\n    !this.auth.installationId\n  ) {\n    throw new Parse.Error(\n      135,\n      'at least one ID field (deviceToken, installationId) ' + 'must be specified in this operation'\n    );\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  let installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster && !this.auth.isMaintenance) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  const orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId,\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      installationId: installationId,\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({ deviceToken: this.data.deviceToken });\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise\n    .then(() => {\n      return this.config.database.find(\n        '_Installation',\n        {\n          $or: orQueries,\n        },\n        {}\n      );\n    })\n    .then(results => {\n      results.forEach(result => {\n        if (this.query && this.query.objectId && result.objectId == this.query.objectId) {\n          objectIdMatch = result;\n        }\n        if (result.installationId == installationId) {\n          installationIdMatch = result;\n        }\n        if (result.deviceToken == this.data.deviceToken) {\n          deviceTokenMatches.push(result);\n        }\n      });\n\n      // Sanity checks when running a query\n      if (this.query && this.query.objectId) {\n        if (!objectIdMatch) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for update.');\n        }\n        if (\n          this.data.installationId &&\n          objectIdMatch.installationId &&\n          this.data.installationId !== objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'installationId may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceToken &&\n          objectIdMatch.deviceToken &&\n          this.data.deviceToken !== objectIdMatch.deviceToken &&\n          !this.data.installationId &&\n          !objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'deviceToken may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceType &&\n          this.data.deviceType &&\n          this.data.deviceType !== objectIdMatch.deviceType\n        ) {\n          throw new Parse.Error(136, 'deviceType may not be changed in this ' + 'operation');\n        }\n      }\n\n      if (this.query && this.query.objectId && objectIdMatch) {\n        idMatch = objectIdMatch;\n      }\n\n      if (installationId && installationIdMatch) {\n        idMatch = installationIdMatch;\n      }\n      // need to specify deviceType only if it's new\n      if (!this.query && !this.data.deviceType && !idMatch) {\n        throw new Parse.Error(135, 'deviceType must be specified in this operation');\n      }\n    })\n    .then(() => {\n      if (!idMatch) {\n        if (!deviceTokenMatches.length) {\n          return;\n        } else if (\n          deviceTokenMatches.length == 1 &&\n          (!deviceTokenMatches[0]['installationId'] || !installationId)\n        ) {\n          // Single match on device token but none on installationId, and either\n          // the passed object or the match is missing an installationId, so we\n          // can just return the match.\n          return deviceTokenMatches[0]['objectId'];\n        } else if (!this.data.installationId) {\n          throw new Parse.Error(\n            132,\n            'Must specify installationId when deviceToken ' +\n              'matches multiple Installation objects'\n          );\n        } else {\n          // Multiple device token matches and we specified an installation ID,\n          // or a single match where both the passed and matching objects have\n          // an installation ID. Try cleaning out old installations that match\n          // the deviceToken, and return nil to signal that a new object should\n          // be created.\n          var delQuery = {\n            deviceToken: this.data.deviceToken,\n            installationId: {\n              $ne: installationId,\n            },\n          };\n          if (this.data.appIdentifier) {\n            delQuery['appIdentifier'] = this.data.appIdentifier;\n          }\n          this.config.database.destroy('_Installation', delQuery).catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored.\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n          return;\n        }\n      } else {\n        if (deviceTokenMatches.length == 1 && !deviceTokenMatches[0]['installationId']) {\n          // Exactly one device token match and it doesn't have an installation\n          // ID. This is the one case where we want to merge with the existing\n          // object.\n          const delQuery = { objectId: idMatch.objectId };\n          return this.config.database\n            .destroy('_Installation', delQuery)\n            .then(() => {\n              return deviceTokenMatches[0]['objectId'];\n            })\n            .catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n        } else {\n          if (this.data.deviceToken && idMatch.deviceToken != this.data.deviceToken) {\n            // We're setting the device token on an existing installation, so\n            // we should try cleaning out old installations that match this\n            // device token.\n            const delQuery = {\n              deviceToken: this.data.deviceToken,\n            };\n            // We have a unique install Id, use that to preserve\n            // the interesting installation\n            if (this.data.installationId) {\n              delQuery['installationId'] = {\n                $ne: this.data.installationId,\n              };\n            } else if (\n              idMatch.objectId &&\n              this.data.objectId &&\n              idMatch.objectId == this.data.objectId\n            ) {\n              // we passed an objectId, preserve that instalation\n              delQuery['objectId'] = {\n                $ne: idMatch.objectId,\n              };\n            } else {\n              // What to do here? can't really clean up everything...\n              return idMatch.objectId;\n            }\n            if (this.data.appIdentifier) {\n              delQuery['appIdentifier'] = this.data.appIdentifier;\n            }\n            this.config.database.destroy('_Installation', delQuery).catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored.\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n          }\n          // In non-merge scenarios, just return the installation match id\n          return idMatch.objectId;\n        }\n      }\n    })\n    .then(objId => {\n      if (objId) {\n        this.query = { objectId: objId };\n        delete this.data.objectId;\n        delete this.data.createdAt;\n      }\n      // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n    });\n  return promise;\n};\n\n// If we short-circuited the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function () {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function () {\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n    if (this.config.liveQueryController) {\n      this.config.liveQueryController.clearCachedRoles(this.auth.user);\n    }\n  }\n\n  if (this.className === '_User' && this.query && this.auth.isUnauthenticated()) {\n    throw new Parse.Error(\n      Parse.Error.SESSION_MISSING,\n      `Cannot modify user ${this.query.objectId}.`\n    );\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (\n      this.className === '_User' &&\n      this.data.ACL &&\n      this.auth.isMaster !== true &&\n      this.auth.isMaintenance !== true\n    ) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordAge\n    ) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    let defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordHistory\n    ) {\n      defer = this.config.database\n        .find(\n          '_User',\n          { objectId: this.objectId() },\n          { keys: ['_password_history', '_hashed_password'] },\n          Auth.maintenance(this.config)\n        )\n        .then(results => {\n          if (results.length != 1) {\n            throw undefined;\n          }\n          const user = results[0];\n          let oldPasswords = [];\n          if (user._password_history) {\n            oldPasswords = _.take(\n              user._password_history,\n              this.config.passwordPolicy.maxPasswordHistory\n            );\n          }\n          //n-1 passwords go into history including last password\n          while (\n            oldPasswords.length > Math.max(0, this.config.passwordPolicy.maxPasswordHistory - 2)\n          ) {\n            oldPasswords.shift();\n          }\n          oldPasswords.push(user.password);\n          this.data._password_history = oldPasswords;\n        });\n    }\n\n    return defer.then(() => {\n      // Run an update\n      return this.config.database\n        .update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          false,\n          false,\n          this.validSchemaController\n        )\n        .then(response => {\n          response.updatedAt = this.updatedAt;\n          this._updateResponseWithData(response, this.data);\n          this.response = { response };\n        });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        if (!this.config.enforcePrivateUsers) {\n          ACL['*'] = { read: true, write: false };\n        }\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database\n      .create(this.className, this.data, this.runOptions, false, this.validSchemaController)\n      .catch(error => {\n        if (this.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n\n        // Quick check, if we were able to infer the duplicated field name\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'username') {\n          throw new Parse.Error(\n            Parse.Error.USERNAME_TAKEN,\n            'Account already exists for this username.'\n          );\n        }\n\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'email') {\n          throw new Parse.Error(\n            Parse.Error.EMAIL_TAKEN,\n            'Account already exists for this email address.'\n          );\n        }\n\n        // If this was a failed user creation due to username or email already taken, we need to\n        // check whether it was username or email and return the appropriate error.\n        // Fallback to the original method\n        // TODO: See if we can later do this without additional queries by using named indexes.\n        return this.config.database\n          .find(\n            this.className,\n            {\n              username: this.data.username,\n              objectId: { $ne: this.objectId() },\n            },\n            { limit: 1 }\n          )\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.USERNAME_TAKEN,\n                'Account already exists for this username.'\n              );\n            }\n            return this.config.database.find(\n              this.className,\n              { email: this.data.email, objectId: { $ne: this.objectId() } },\n              { limit: 1 }\n            );\n          })\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.EMAIL_TAKEN,\n                'Account already exists for this email address.'\n              );\n            }\n            throw new Parse.Error(\n              Parse.Error.DUPLICATE_VALUE,\n              'A duplicate value for a field with unique values was provided'\n            );\n          });\n      })\n      .then(response => {\n        response.objectId = this.data.objectId;\n        response.createdAt = this.data.createdAt;\n\n        if (this.responseShouldHaveUsername) {\n          response.username = this.data.username;\n        }\n        this._updateResponseWithData(response, this.data);\n        this.response = {\n          status: 201,\n          response,\n          location: this.location(),\n        };\n      });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterSaveTrigger = function () {\n  if (!this.response || !this.response.response || this.runOptions.many) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  const hasAfterSaveHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterSave,\n    this.config.applicationId\n  );\n  const hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  const { originalObject, updatedObject } = this.buildParseObjects();\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  this.config.database.loadSchema().then(schemaController => {\n    // Notifiy LiveQueryServer if possible\n    const perms = schemaController.getClassLevelPermissions(updatedObject.className);\n    this.config.liveQueryController.onAfterSave(\n      updatedObject.className,\n      updatedObject,\n      originalObject,\n      perms\n    );\n  });\n\n  // Run afterSave trigger\n  return triggers\n    .maybeRunTrigger(\n      triggers.Types.afterSave,\n      this.auth,\n      updatedObject,\n      originalObject,\n      this.config,\n      this.context\n    )\n    .then(result => {\n      const jsonReturned = result && !result._toFullJSON;\n      if (jsonReturned) {\n        this.pendingOps.operations = {};\n        this.response.response = result;\n      } else {\n        this.response.response = this._updateResponseWithData(\n          (result || updatedObject).toJSON(),\n          this.data\n        );\n      }\n    })\n    .catch(function (err) {\n      logger.warn('afterSave caught an error', err);\n    });\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function () {\n  var middle = this.className === '_User' ? '/users/' : '/classes/' + this.className + '/';\n  const mount = this.config.mount || this.config.serverURL;\n  return mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function () {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function () {\n  const data = Object.keys(this.data).reduce((data, key) => {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n};\n\n// Returns an updated copy of the object\nRestWrite.prototype.buildParseObjects = function () {\n  const extraData = { className: this.className, objectId: this.query?.objectId };\n  let originalObject;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  const className = Parse.Object.fromJSON(extraData);\n  const readOnlyAttributes = className.constructor.readOnlyAttributes\n    ? className.constructor.readOnlyAttributes()\n    : [];\n  if (!this.originalData) {\n    for (const attribute of readOnlyAttributes) {\n      extraData[attribute] = this.data[attribute];\n    }\n  }\n  const updatedObject = triggers.inflate(extraData, this.originalData);\n  Object.keys(this.data).reduce(function (data, key) {\n    if (key.indexOf('.') > 0) {\n      if (typeof data[key].__op === 'string') {\n        if (!readOnlyAttributes.includes(key)) {\n          updatedObject.set(key, data[key]);\n        }\n      } else {\n        // subdocument key with dot notation { 'x.y': v } => { 'x': { 'y' : v } })\n        const splittedKey = key.split('.');\n        const parentProp = splittedKey[0];\n        let parentVal = updatedObject.get(parentProp);\n        if (typeof parentVal !== 'object') {\n          parentVal = {};\n        }\n        parentVal[splittedKey[1]] = data[key];\n        updatedObject.set(parentProp, parentVal);\n      }\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n\n  const sanitized = this.sanitizedData();\n  for (const attribute of readOnlyAttributes) {\n    delete sanitized[attribute];\n  }\n  updatedObject.set(sanitized);\n  return { updatedObject, originalObject };\n};\n\nRestWrite.prototype.cleanUserAuthData = function () {\n  if (this.response && this.response.response && this.className === '_User') {\n    const user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach(provider => {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function (response, data) {\n  const stateController = Parse.CoreManager.getObjectStateController();\n  const [pending] = stateController.getPendingOps(this.pendingOps.identifier);\n  for (const key in this.pendingOps.operations) {\n    if (!pending[key]) {\n      data[key] = this.originalData ? this.originalData[key] : { __op: 'Delete' };\n      this.storage.fieldsChangedByTrigger.push(key);\n    }\n  }\n  const skipKeys = [...(requiredColumns.read[this.className] || [])];\n  if (!this.query) {\n    skipKeys.push('objectId', 'createdAt');\n  } else {\n    skipKeys.push('updatedAt');\n    delete response.objectId;\n  }\n  for (const key in response) {\n    if (skipKeys.includes(key)) {\n      continue;\n    }\n    const value = response[key];\n    if (\n      value == null ||\n      (value.__type && value.__type === 'Pointer') ||\n      util.isDeepStrictEqual(data[key], value) ||\n      util.isDeepStrictEqual((this.originalData || {})[key], value)\n    ) {\n      delete response[key];\n    }\n  }\n  if (_.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  const clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(fieldName => {\n    const dataValue = data[fieldName];\n\n    if (!Object.prototype.hasOwnProperty.call(response, fieldName)) {\n      response[fieldName] = dataValue;\n    }\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n};\n\nRestWrite.prototype.checkProhibitedKeywords = function (data) {\n  if (this.config.requestKeywordDenylist) {\n    // Scan request data for denied keywords\n    for (const keyword of this.config.requestKeywordDenylist) {\n      const match = Utils.objectContainsKeyValue(data, keyword.key, keyword.value);\n      if (match) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n        );\n      }\n    }\n  }\n};\n\nexport default RestWrite;\nmodule.exports = RestWrite;\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\nconst Utils = require('../Utils');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      Middlewares.handleParseSession,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.handleParseSession,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    if (!config) {\n      res.status(403);\n      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');\n      res.json({ code: err.code, error: err.message });\n      return;\n    }\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const fileExtensions = config.fileUpload?.fileExtensions;\n    if (!isMaster && fileExtensions) {\n      const isValidExtension = extension => {\n        return fileExtensions.some(ext => {\n          if (ext === '*') {\n            return true;\n          }\n          const regex = new RegExp(fileExtensions);\n          if (regex.test(extension)) {\n            return true;\n          }\n        });\n      };\n      let extension = contentType;\n      if (filename && filename.includes('.')) {\n        extension = filename.split('.')[1];\n      } else if (contentType && contentType.includes('/')) {\n        extension = contentType.split('/')[1];\n      }\n      extension = extension.split(' ').join('');\n\n      if (!isValidExtension(extension)) {\n        next(\n          new Parse.Error(\n            Parse.Error.FILE_SAVE_ERROR,\n            `File upload of extension ${extension} is disabled.`\n          )\n        );\n        return;\n      }\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    if (req.config && req.config.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of req.config.requestKeywordDenylist) {\n        const match =\n          Utils.objectContainsKeyValue(metadata, keyword.key, keyword.value) ||\n          Utils.objectContainsKeyValue(tags, keyword.key, keyword.value);\n        if (match) {\n          next(\n            new Parse.Error(\n              Parse.Error.INVALID_KEY_NAME,\n              `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n            )\n          );\n          return;\n        }\n      }\n    }\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSave,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(triggers.Types.afterSave, fileObject, config, req.auth);\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    try {\n      const config = Config.get(req.params.appId);\n      const { filesController } = config;\n      const { filename } = req.params;\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  const range = (req.get('Range') || '/-/').split('-');\n  const start = Number(range[0]);\n  const end = Number(range[1]);\n  return (\n    (!isNaN(start) || !isNaN(end)) && typeof filesController.adapter.handleFileStream === 'function'\n  );\n}\n", "/**\n * utils.js\n * @file General purpose utilities\n * @description General purpose utilities.\n */\n\nconst path = require('path');\nconst fs = require('fs').promises;\n\n/**\n * The general purpose utilities.\n */\nclass Utils {\n  /**\n   * @function getLocalizedPath\n   * @description Returns a localized file path accoring to the locale.\n   *\n   * Localized files are searched in subfolders of a given path, e.g.\n   *\n   * root/\n   * \u251c\u2500\u2500 base/                    // base path to files\n   * \u2502   \u251c\u2500\u2500 example.html         // default file\n   * \u2502   \u2514\u2500\u2500 de/                  // de language folder\n   * \u2502   \u2502   \u2514\u2500\u2500 example.html     // de localized file\n   * \u2502   \u2514\u2500\u2500 de-AT/               // de-AT locale folder\n   * \u2502   \u2502   \u2514\u2500\u2500 example.html     // de-AT localized file\n   *\n   * Files are matched with the locale in the following order:\n   * 1. Locale match, e.g. locale `de-AT` matches file in folder `de-AT`.\n   * 2. Language match, e.g. locale `de-AT` matches file in folder `de`.\n   * 3. Default; file in base folder is returned.\n   *\n   * @param {String} defaultPath The absolute file path, which is also\n   * the default path returned if localization is not available.\n   * @param {String} locale The locale.\n   * @returns {Promise<Object>} The object contains:\n   * - `path`: The path to the localized file, or the original path if\n   *   localization is not available.\n   * - `subdir`: The subdirectory of the localized file, or undefined if\n   *   there is no matching localized file.\n   */\n  static async getLocalizedPath(defaultPath, locale) {\n    // Get file name and paths\n    const file = path.basename(defaultPath);\n    const basePath = path.dirname(defaultPath);\n\n    // If locale is not set return default file\n    if (!locale) {\n      return { path: defaultPath };\n    }\n\n    // Check file for locale exists\n    const localePath = path.join(basePath, locale, file);\n    const localeFileExists = await Utils.fileExists(localePath);\n\n    // If file for locale exists return file\n    if (localeFileExists) {\n      return { path: localePath, subdir: locale };\n    }\n\n    // Check file for language exists\n    const language = locale.split('-')[0];\n    const languagePath = path.join(basePath, language, file);\n    const languageFileExists = await Utils.fileExists(languagePath);\n\n    // If file for language exists return file\n    if (languageFileExists) {\n      return { path: languagePath, subdir: language };\n    }\n\n    // Return default file\n    return { path: defaultPath };\n  }\n\n  /**\n   * @function fileExists\n   * @description Checks whether a file exists.\n   * @param {String} path The file path.\n   * @returns {Promise<Boolean>} Is true if the file can be accessed, false otherwise.\n   */\n  static async fileExists(path) {\n    try {\n      await fs.access(path);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * @function isPath\n   * @description Evaluates whether a string is a file path (as opposed to a URL for example).\n   * @param {String} s The string to evaluate.\n   * @returns {Boolean} Returns true if the evaluated string is a path.\n   */\n  static isPath(s) {\n    return /(^\\/)|(^\\.\\/)|(^\\.\\.\\/)/.test(s);\n  }\n\n  /**\n   * Flattens an object and crates new keys with custom delimiters.\n   * @param {Object} obj The object to flatten.\n   * @param {String} [delimiter='.'] The delimiter of the newly generated keys.\n   * @param {Object} result\n   * @returns {Object} The flattened object.\n   **/\n  static flattenObject(obj, parentKey, delimiter = '.', result = {}) {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const newKey = parentKey ? parentKey + delimiter + key : key;\n\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\n          this.flattenObject(obj[key], newKey, delimiter, result);\n        } else {\n          result[newKey] = obj[key];\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether an object is a Promise.\n   * @param {any} object The object to validate.\n   * @returns {Boolean} Returns true if the object is a promise.\n   */\n  static isPromise(object) {\n    return object instanceof Promise;\n  }\n\n  /**\n   * Creates an object with all permutations of the original keys.\n   * For example, this definition:\n   * ```\n   * {\n   *   a: [true, false],\n   *   b: [1, 2],\n   *   c: ['x']\n   * }\n   * ```\n   * permutates to:\n   * ```\n   * [\n   *   { a: true, b: 1, c: 'x' },\n   *   { a: true, b: 2, c: 'x' },\n   *   { a: false, b: 1, c: 'x' },\n   *   { a: false, b: 2, c: 'x' }\n   * ]\n   * ```\n   * @param {Object} object The object to permutate.\n   * @param {Integer} [index=0] The current key index.\n   * @param {Object} [current={}] The current result entry being composed.\n   * @param {Array} [results=[]] The resulting array of permutations.\n   */\n  static getObjectKeyPermutations(object, index = 0, current = {}, results = []) {\n    const keys = Object.keys(object);\n    const key = keys[index];\n    const values = object[key];\n\n    for (const value of values) {\n      current[key] = value;\n      const nextIndex = index + 1;\n\n      if (nextIndex < keys.length) {\n        Utils.getObjectKeyPermutations(object, nextIndex, current, results);\n      } else {\n        const result = Object.assign({}, current);\n        results.push(result);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Validates parameters and throws if a parameter is invalid.\n   * Example parameter types syntax:\n   * ```\n   * {\n   *   parameterName: {\n   *      t: 'boolean',\n   *      v: isBoolean,\n   *      o: true\n   *   },\n   *   ...\n   * }\n   * ```\n   * @param {Object} params The parameters to validate.\n   * @param {Array<Object>} types The parameter types used for validation.\n   * @param {Object} types.t The parameter type; used for error message, not for validation.\n   * @param {Object} types.v The function to validate the parameter value.\n   * @param {Boolean} [types.o=false] Is true if the parameter is optional.\n   */\n  static validateParams(params, types) {\n    for (const key of Object.keys(params)) {\n      const type = types[key];\n      const isOptional = !!type.o;\n      const param = params[key];\n      if (!(isOptional && param == null) && !type.v(param)) {\n        throw `Invalid parameter ${key} must be of type ${type.t} but is ${typeof param}`;\n      }\n    }\n  }\n\n  /**\n   * Computes the relative date based on a string.\n   * @param {String} text The string to interpret the date from.\n   * @param {Date} now The date the string is comparing against.\n   * @returns {Object} The relative date object.\n   **/\n  static relativeTimeToDate(text, now = new Date()) {\n    text = text.toLowerCase();\n    let parts = text.split(' ');\n\n    // Filter out whitespace\n    parts = parts.filter(part => part !== '');\n\n    const future = parts[0] === 'in';\n    const past = parts[parts.length - 1] === 'ago';\n\n    if (!future && !past && text !== 'now') {\n      return {\n        status: 'error',\n        info: \"Time should either start with 'in' or end with 'ago'\",\n      };\n    }\n\n    if (future && past) {\n      return {\n        status: 'error',\n        info: \"Time cannot have both 'in' and 'ago'\",\n      };\n    }\n\n    // strip the 'ago' or 'in'\n    if (future) {\n      parts = parts.slice(1);\n    } else {\n      // past\n      parts = parts.slice(0, parts.length - 1);\n    }\n\n    if (parts.length % 2 !== 0 && text !== 'now') {\n      return {\n        status: 'error',\n        info: 'Invalid time string. Dangling unit or number.',\n      };\n    }\n\n    const pairs = [];\n    while (parts.length) {\n      pairs.push([parts.shift(), parts.shift()]);\n    }\n\n    let seconds = 0;\n    for (const [num, interval] of pairs) {\n      const val = Number(num);\n      if (!Number.isInteger(val)) {\n        return {\n          status: 'error',\n          info: `'${num}' is not an integer.`,\n        };\n      }\n\n      switch (interval) {\n        case 'yr':\n        case 'yrs':\n        case 'year':\n        case 'years':\n          seconds += val * 31536000; // 365 * 24 * 60 * 60\n          break;\n\n        case 'wk':\n        case 'wks':\n        case 'week':\n        case 'weeks':\n          seconds += val * 604800; // 7 * 24 * 60 * 60\n          break;\n\n        case 'd':\n        case 'day':\n        case 'days':\n          seconds += val * 86400; // 24 * 60 * 60\n          break;\n\n        case 'hr':\n        case 'hrs':\n        case 'hour':\n        case 'hours':\n          seconds += val * 3600; // 60 * 60\n          break;\n\n        case 'min':\n        case 'mins':\n        case 'minute':\n        case 'minutes':\n          seconds += val * 60;\n          break;\n\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n          seconds += val;\n          break;\n\n        default:\n          return {\n            status: 'error',\n            info: `Invalid interval: '${interval}'`,\n          };\n      }\n    }\n\n    const milliseconds = seconds * 1000;\n    if (future) {\n      return {\n        status: 'success',\n        info: 'future',\n        result: new Date(now.valueOf() + milliseconds),\n      };\n    } else if (past) {\n      return {\n        status: 'success',\n        info: 'past',\n        result: new Date(now.valueOf() - milliseconds),\n      };\n    } else {\n      return {\n        status: 'success',\n        info: 'present',\n        result: new Date(now.valueOf()),\n      };\n    }\n  }\n\n  /**\n   * Deep-scans an object for a matching key/value definition.\n   * @param {Object} obj The object to scan.\n   * @param {String | undefined} key The key to match, or undefined if only the value should be matched.\n   * @param {any | undefined} value The value to match, or undefined if only the key should be matched.\n   * @returns {Boolean} True if a match was found, false otherwise.\n   */\n  static objectContainsKeyValue(obj, key, value) {\n    const isMatch = (a, b) => (typeof a === 'string' && new RegExp(b).test(a)) || a === b;\n    const isKeyMatch = k => isMatch(k, key);\n    const isValueMatch = v => isMatch(v, value);\n    for (const [k, v] of Object.entries(obj)) {\n      if (key !== undefined && value === undefined && isKeyMatch(k)) {\n        return true;\n      } else if (key === undefined && value !== undefined && isValueMatch(v)) {\n        return true;\n      } else if (key !== undefined && value !== undefined && isKeyMatch(k) && isValueMatch(v)) {\n        return true;\n      }\n      if (['[object Object]', '[object Array]'].includes(Object.prototype.toString.call(v))) {\n        return Utils.objectContainsKeyValue(v, key, value);\n      }\n    }\n    return false;\n  }\n}\n\nmodule.exports = Utils;\n"], "fixing_code": ["{\n    \"root\": true,\n    \"extends\": \"eslint:recommended\",\n    \"env\": {\n        \"node\": true,\n        \"es6\": true\n    },\n    \"parser\": \"@babel/eslint-parser\",\n    \"plugins\": [\n        \"flowtype\"\n    ],\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"requireConfigFile\": false\n    },\n    \"rules\": {\n        \"indent\": [\"error\", 2, { \"SwitchCase\": 1 }],\n        \"linebreak-style\": [\"error\", \"unix\"],\n        \"no-trailing-spaces\": 2,\n        \"eol-last\": 2,\n        \"space-in-parens\": [\"error\", \"never\"],\n        \"no-multiple-empty-lines\": 1,\n        \"prefer-const\": \"error\",\n        \"space-infix-ops\": \"error\",\n        \"no-useless-escape\": \"off\",\n        \"require-atomic-updates\": \"off\"\n    },\n    \"globals\": {\n        \"Parse\": true\n    }\n}\n", "const request = require('../lib/request');\n\ndescribe('Vulnerabilities', () => {\n  describe('Object prototype pollution', () => {\n    it('denies object prototype to be polluted with keyword \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {\n            constructor: {\n              prototype: {\n                dummy: 0,\n              },\n            },\n          },\n        }),\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n\n    it('denies object prototype to be polluted with keypath string \"constructor\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const objResponse = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({\n          obj: {},\n        }),\n      }).catch(e => e);\n      const pollResponse = await request({\n        headers: headers,\n        method: 'PUT',\n        url: `http://localhost:8378/1/classes/PP/${objResponse.data.objectId}`,\n        body: JSON.stringify({\n          'obj.constructor.prototype.dummy': {\n            __op: 'Increment',\n            amount: 1,\n          },\n        }),\n      }).catch(e => e);\n      expect(Object.prototype.dummy).toBeUndefined();\n      expect(pollResponse.status).toBe(400);\n      const text = JSON.parse(pollResponse.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"constructor\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n\n    it('denies object prototype to be polluted with keyword \"__proto__\"', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const response = await request({\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/PP',\n        body: JSON.stringify({ 'obj.__proto__.dummy': 0 }),\n      }).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"__proto__\"}.');\n      expect(Object.prototype.dummy).toBeUndefined();\n    });\n  });\n\n  describe('Request denylist', () => {\n    it('denies BSON type code data in write request by default', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.'\n      );\n    });\n\n    it('denies expanding existing object with polluted keys', async () => {\n      const obj = await new Parse.Object('RCE', { a: { foo: [] } }).save();\n      await reconfigureServer({\n        requestKeywordDenylist: ['foo'],\n      });\n      obj.addUnique('a.foo', 'abc');\n      await expectAsync(obj.save()).toBeRejectedWith(\n        new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Prohibited keyword in request data: \"foo\".`)\n      );\n    });\n\n    it('denies creating a cloud trigger with polluted data', async () => {\n      Parse.Cloud.beforeSave('TestObject', ({ object }) => {\n        object.set('obj', {\n          constructor: {\n            prototype: {\n              dummy: 0,\n            },\n          },\n        });\n      });\n      await expectAsync(new Parse.Object('TestObject').save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"constructor\"}.'\n        )\n      );\n    });\n\n    it('denies creating global config with polluted data', async () => {\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-Master-Key': 'test',\n      };\n      const params = {\n        method: 'PUT',\n        url: 'http://localhost:8378/1/config',\n        json: true,\n        body: {\n          params: {\n            welcomeMesssage: 'Welcome to Parse',\n            foo: { _bsontype: 'Code', code: 'shell' },\n          },\n        },\n        headers,\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.'\n      );\n    });\n\n    it('denies direct database write wih prohibited keys', async () => {\n      const Config = require('../lib/Config');\n      const config = Config.get(Parse.applicationId);\n      const user = {\n        objectId: '1234567890',\n        username: 'hello',\n        password: 'pass',\n        _session_token: 'abc',\n        foo: { _bsontype: 'Code', code: 'shell' },\n      };\n      await expectAsync(config.database.create('_User', user)).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.'\n        )\n      );\n    });\n\n    it('denies direct database update wih prohibited keys', async () => {\n      const Config = require('../lib/Config');\n      const config = Config.get(Parse.applicationId);\n      const user = {\n        objectId: '1234567890',\n        username: 'hello',\n        password: 'pass',\n        _session_token: 'abc',\n        foo: { _bsontype: 'Code', code: 'shell' },\n      };\n      await expectAsync(\n        config.database.update('_User', { _id: user.objectId }, user)\n      ).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.'\n        )\n      );\n    });\n\n    it('denies creating a hook with polluted data', async () => {\n      const express = require('express');\n      const bodyParser = require('body-parser');\n      const port = 34567;\n      const hookServerURL = 'http://localhost:' + port;\n      const app = express();\n      app.use(bodyParser.json({ type: '*/*' }));\n      const server = await new Promise(resolve => {\n        const res = app.listen(port, undefined, () => resolve(res));\n      });\n      app.post('/BeforeSave', function (req, res) {\n        const object = Parse.Object.fromJSON(req.body.object);\n        object.set('hello', 'world');\n        object.set('obj', {\n          constructor: {\n            prototype: {\n              dummy: 0,\n            },\n          },\n        });\n        res.json({ success: object });\n      });\n      await Parse.Hooks.createTrigger('TestObject', 'beforeSave', hookServerURL + '/BeforeSave');\n      await expectAsync(new Parse.Object('TestObject').save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          'Prohibited keyword in request data: {\"key\":\"constructor\"}.'\n        )\n      );\n      await new Promise(resolve => server.close(resolve));\n    });\n\n    it('allows BSON type code data in write request with custom denylist', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            _bsontype: 'Code',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(201);\n      const text = JSON.parse(response.text);\n      expect(text.objectId).toBeDefined();\n    });\n\n    it('denies write request with custom denylist of key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of nested key/value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            nested: {\n              aKey: 'aValue321',\n              code: 'delete Object.prototype.evalFunctions',\n            },\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of key/value in array', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: [\n            {\n              aKey: 'aValue321',\n              code: 'delete Object.prototype.evalFunctions',\n            },\n          ],\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe(\n        'Prohibited keyword in request data: {\"key\":\"a[K]ey\",\"value\":\"aValue[123]*\"}.'\n      );\n    });\n\n    it('denies write request with custom denylist of key', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'a[K]ey' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"key\":\"a[K]ey\"}.');\n    });\n\n    it('denies write request with custom denylist of value', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ value: 'aValue[123]*' }],\n      });\n      const headers = {\n        'Content-Type': 'application/json',\n        'X-Parse-Application-Id': 'test',\n        'X-Parse-REST-API-Key': 'rest',\n      };\n      const params = {\n        headers: headers,\n        method: 'POST',\n        url: 'http://localhost:8378/1/classes/RCE',\n        body: JSON.stringify({\n          obj: {\n            aKey: 'aValue321',\n            code: 'delete Object.prototype.evalFunctions',\n          },\n        }),\n      };\n      const response = await request(params).catch(e => e);\n      expect(response.status).toBe(400);\n      const text = JSON.parse(response.text);\n      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);\n      expect(text.error).toBe('Prohibited keyword in request data: {\"value\":\"aValue[123]*\"}.');\n    });\n\n    it('denies BSON type code data in file metadata', async () => {\n      const str = 'Hello World!';\n      const data = [];\n      for (let i = 0; i < str.length; i++) {\n        data.push(str.charCodeAt(i));\n      }\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      file.addMetadata('obj', {\n        _bsontype: 'Code',\n        code: 'delete Object.prototype.evalFunctions',\n      });\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          `Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.`\n        )\n      );\n    });\n\n    it('denies BSON type code data in file tags', async () => {\n      const str = 'Hello World!';\n      const data = [];\n      for (let i = 0; i < str.length; i++) {\n        data.push(str.charCodeAt(i));\n      }\n      const file = new Parse.File('hello.txt', data, 'text/plain');\n      file.addTag('obj', {\n        _bsontype: 'Code',\n        code: 'delete Object.prototype.evalFunctions',\n      });\n      await expectAsync(file.save()).toBeRejectedWith(\n        new Parse.Error(\n          Parse.Error.INVALID_KEY_NAME,\n          `Prohibited keyword in request data: {\"key\":\"_bsontype\",\"value\":\"Code\"}.`\n        )\n      );\n    });\n  });\n\n  describe('Ignore non-matches', () => {\n    it('ignores write request that contains only fraction of denied keyword', async () => {\n      await reconfigureServer({\n        requestKeywordDenylist: [{ key: 'abc' }],\n      });\n      // Initially saving an object executes the keyword detection in RestWrite.js\n      const obj = new TestObject({ a: { b: { c: 0 } } });\n      await expectAsync(obj.save()).toBeResolved();\n      // Modifying a nested key executes the keyword detection in DatabaseController.js\n      obj.increment('a.b.c');\n      await expectAsync(obj.save()).toBeResolved();\n    });\n  });\n});\n", "\ufeff// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse } from 'parse/node';\n// @flow-disable-next\nimport _ from 'lodash';\n// @flow-disable-next\nimport intersect from 'intersect';\n// @flow-disable-next\nimport deepcopy from 'deepcopy';\nimport logger from '../logger';\nimport Utils from '../Utils';\nimport * as SchemaController from './SchemaController';\nimport { StorageAdapter } from '../Adapters/Storage/StorageAdapter';\nimport MongoStorageAdapter from '../Adapters/Storage/Mongo/MongoStorageAdapter';\nimport PostgresStorageAdapter from '../Adapters/Storage/Postgres/PostgresStorageAdapter';\nimport SchemaCache from '../Adapters/Cache/SchemaCache';\nimport type { LoadSchemaOptions } from './types';\nimport type { ParseServerOptions } from '../Options';\nimport type { QueryOptions, FullQueryOptions } from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { $in: [null, ...acl] };\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = { $in: [null, '*', ...acl] };\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n};\n\nconst specialQueryKeys = ['$and', '$or', '$nor', '_rperm', '_wperm'];\nconst specialMasterQueryKeys = [\n  ...specialQueryKeys,\n  '_email_verify_token',\n  '_perishable_token',\n  '_tombstone',\n  '_email_verify_token_expires_at',\n  '_failed_login_count',\n  '_account_lockout_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst validateQuery = (\n  query: any,\n  isMaster: boolean,\n  isMaintenance: boolean,\n  update: boolean\n): void => {\n  if (isMaintenance) {\n    isMaster = true;\n  }\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(value => validateQuery(value, isMaster, isMaintenance, update));\n    } else {\n      throw new Parse.Error(\n        Parse.Error.INVALID_QUERY,\n        'Bad $nor format - use an array of at least 1 value.'\n      );\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_QUERY,\n            `Bad $options value for query: ${query[key].$options}`\n          );\n        }\n      }\n    }\n    if (\n      !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/) &&\n      ((!specialQueryKeys.includes(key) && !isMaster && !update) ||\n        (update && isMaster && !specialMasterQueryKeys.includes(key)))\n    ) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n};\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (\n  isMaster: boolean,\n  isMaintenance: boolean,\n  aclGroup: any[],\n  auth: any,\n  operation: any,\n  schema: SchemaController.SchemaController | any,\n  className: string,\n  protectedFields: null | Array<any>,\n  object: any\n) => {\n  let userId = null;\n  if (auth && auth.user) userId = auth.user.id;\n\n  // replace protectedFields when using pointer-permissions\n  const perms =\n    schema && schema.getClassLevelPermissions ? schema.getClassLevelPermissions(className) : {};\n  if (perms) {\n    const isReadOperation = ['get', 'find'].indexOf(operation) > -1;\n\n    if (isReadOperation && perms.protectedFields) {\n      // extract protectedFields added with the pointer-permission prefix\n      const protectedFieldsPointerPerm = Object.keys(perms.protectedFields)\n        .filter(key => key.startsWith('userField:'))\n        .map(key => {\n          return { key: key.substring(10), value: perms.protectedFields[key] };\n        });\n\n      const newProtectedFields: Array<string>[] = [];\n      let overrideProtectedFields = false;\n\n      // check if the object grants the current user access based on the extracted fields\n      protectedFieldsPointerPerm.forEach(pointerPerm => {\n        let pointerPermIncludesUser = false;\n        const readUserFieldValue = object[pointerPerm.key];\n        if (readUserFieldValue) {\n          if (Array.isArray(readUserFieldValue)) {\n            pointerPermIncludesUser = readUserFieldValue.some(\n              user => user.objectId && user.objectId === userId\n            );\n          } else {\n            pointerPermIncludesUser =\n              readUserFieldValue.objectId && readUserFieldValue.objectId === userId;\n          }\n        }\n\n        if (pointerPermIncludesUser) {\n          overrideProtectedFields = true;\n          newProtectedFields.push(pointerPerm.value);\n        }\n      });\n\n      // if at least one pointer-permission affected the current user\n      // intersect vs protectedFields from previous stage (@see addProtectedFields)\n      // Sets theory (intersections): A x (B x C) == (A x B) x C\n      if (overrideProtectedFields && protectedFields) {\n        newProtectedFields.push(protectedFields);\n      }\n      // intersect all sets of protectedFields\n      newProtectedFields.forEach(fields => {\n        if (fields) {\n          // if there're no protctedFields by other criteria ( id / role / auth)\n          // then we must intersect each set (per userField)\n          if (!protectedFields) {\n            protectedFields = fields;\n          } else {\n            protectedFields = protectedFields.filter(v => fields.includes(v));\n          }\n        }\n      });\n    }\n  }\n\n  const isUserClass = className === '_User';\n  if (isUserClass) {\n    object.password = object._hashed_password;\n    delete object._hashed_password;\n    delete object.sessionToken;\n  }\n\n  if (isMaintenance) {\n    return object;\n  }\n\n  /* special treat for the user class: don't filter protectedFields if currently loggedin user is\n  the retrieved user */\n  if (!(isUserClass && userId && object.objectId === userId)) {\n    protectedFields && protectedFields.forEach(k => delete object[k]);\n\n    // fields not requested by client (excluded),\n    // but were needed to apply protectedFields\n    perms?.protectedFields?.temporaryKeys?.forEach(k => delete object[k]);\n  }\n\n  for (const key in object) {\n    if (key.charAt(0) === '_') {\n      delete object[key];\n    }\n  }\n\n  if (!isUserClass || isMaster) {\n    return object;\n  }\n\n  if (aclGroup.indexOf(object.objectId) > -1) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = [\n  '_hashed_password',\n  '_perishable_token',\n  '_email_verify_token',\n  '_email_verify_token_expires_at',\n  '_account_lockout_expires_at',\n  '_failed_login_count',\n  '_perishable_token_expires_at',\n  '_password_changed_at',\n  '_password_history',\n];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n};\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n        case 'Increment':\n          if (typeof object[key].amount !== 'number') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].amount;\n          break;\n        case 'Add':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'AddUnique':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = object[key].objects;\n          break;\n        case 'Remove':\n          if (!(object[key].objects instanceof Array)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n          }\n          object[key] = [];\n          break;\n        case 'Delete':\n          delete object[key];\n          break;\n        default:\n          throw new Parse.Error(\n            Parse.Error.COMMAND_UNAVAILABLE,\n            `The ${object[key].__op} operator is not supported yet.`\n          );\n      }\n    }\n  }\n};\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete',\n        };\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' };\n      }\n    });\n    delete object.authData;\n  }\n};\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({ _rperm, _wperm, ...output }) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n};\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0];\n};\n\nconst relationSchema = {\n  fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } },\n};\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n  _transactionalSession: ?any;\n  options: ParseServerOptions;\n  idempotencyOptions: any;\n\n  constructor(adapter: StorageAdapter, options: ParseServerOptions) {\n    this.adapter = adapter;\n    this.options = options || {};\n    this.idempotencyOptions = this.options.idempotencyOptions || {};\n    // Prevent mutable this.schema, otherwise one request could use\n    // multiple schemas, so instead use loadSchema to get a schema.\n    this.schemaPromise = null;\n    this._transactionalSession = null;\n    this.options = options;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(\n        new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className)\n      );\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, options);\n    this.schemaPromise.then(\n      () => delete this.schemaPromise,\n      () => delete this.schemaPromise\n    );\n    return this.loadSchema(options);\n  }\n\n  loadSchemaIfNeeded(\n    schemaController: SchemaController.SchemaController,\n    options: LoadSchemaOptions = { clearCache: false }\n  ): Promise<SchemaController.SchemaController> {\n    return schemaController ? Promise.resolve(schemaController) : this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then(schema => {\n      var t = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(\n    className: string,\n    object: any,\n    query: any,\n    runOptions: QueryOptions,\n    maintenance: boolean\n  ): Promise<boolean> {\n    let schema;\n    const acl = runOptions.acl;\n    const isMaster = acl === undefined;\n    var aclGroup: string[] = acl || [];\n    return this.loadSchema()\n      .then(s => {\n        schema = s;\n        if (isMaster) {\n          return Promise.resolve();\n        }\n        return this.canAddField(schema, className, object, aclGroup, runOptions);\n      })\n      .then(() => {\n        return schema.validateObject(className, object, query, maintenance);\n      });\n  }\n\n  update(\n    className: string,\n    query: any,\n    update: any,\n    { acl, many, upsert, addsField }: FullQueryOptions = {},\n    skipSanitization: boolean = false,\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    try {\n      Utils.checkProhibitedKeywords(this.options, update);\n    } catch (error) {\n      return Promise.reject(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));\n    }\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'update')\n      )\n        .then(() => {\n          relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n          if (!isMaster) {\n            query = this.addPointerPermissions(\n              schemaController,\n              className,\n              'update',\n              query,\n              aclGroup\n            );\n\n            if (addsField) {\n              query = {\n                $and: [\n                  query,\n                  this.addPointerPermissions(\n                    schemaController,\n                    className,\n                    'addField',\n                    query,\n                    aclGroup\n                  ),\n                ],\n              };\n            }\n          }\n          if (!query) {\n            return Promise.resolve();\n          }\n          if (acl) {\n            query = addWriteACL(query, acl);\n          }\n          validateQuery(query, isMaster, false, true);\n          return schemaController\n            .getOneSchema(className, true)\n            .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n              if (error === undefined) {\n                return { fields: {} };\n              }\n              throw error;\n            })\n            .then(schema => {\n              Object.keys(update).forEach(fieldName => {\n                if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n                const rootFieldName = getRootFieldName(fieldName);\n                if (\n                  !SchemaController.fieldNameIsValid(rootFieldName, className) &&\n                  !isSpecialUpdateKey(rootFieldName)\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_KEY_NAME,\n                    `Invalid field name for update: ${fieldName}`\n                  );\n                }\n              });\n              for (const updateOperation in update) {\n                if (\n                  update[updateOperation] &&\n                  typeof update[updateOperation] === 'object' &&\n                  Object.keys(update[updateOperation]).some(\n                    innerKey => innerKey.includes('$') || innerKey.includes('.')\n                  )\n                ) {\n                  throw new Parse.Error(\n                    Parse.Error.INVALID_NESTED_KEY,\n                    \"Nested keys should not contain the '$' or '.' characters\"\n                  );\n                }\n              }\n              update = transformObjectACL(update);\n              transformAuthData(className, update, schema);\n              if (validateOnly) {\n                return this.adapter.find(className, schema, query, {}).then(result => {\n                  if (!result || !result.length) {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  }\n                  return {};\n                });\n              }\n              if (many) {\n                return this.adapter.updateObjectsByQuery(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else if (upsert) {\n                return this.adapter.upsertOneObject(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              } else {\n                return this.adapter.findOneAndUpdate(\n                  className,\n                  schema,\n                  query,\n                  update,\n                  this._transactionalSession\n                );\n              }\n            });\n        })\n        .then((result: any) => {\n          if (!result) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n          if (validateOnly) {\n            return result;\n          }\n          return this.handleRelationUpdates(\n            className,\n            originalQuery.objectId,\n            update,\n            relationUpdates\n          ).then(() => {\n            return result;\n          });\n        })\n        .then(result => {\n          if (skipSanitization) {\n            return Promise.resolve(result);\n          }\n          return this._sanitizeDatabaseResult(originalUpdate, result);\n        });\n    });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({ key, op });\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({ key, op }) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className, objectId, object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className, objectId, object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter.upsertOneObject(\n      `_Join:${key}:${fromClassName}`,\n      relationSchema,\n      doc,\n      doc,\n      this._transactionalSession\n    );\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId,\n    };\n    return this.adapter\n      .deleteObjectsByQuery(\n        `_Join:${key}:${fromClassName}`,\n        relationSchema,\n        doc,\n        this._transactionalSession\n      )\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(\n    className: string,\n    query: any,\n    { acl }: QueryOptions = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      return (isMaster\n        ? Promise.resolve()\n        : schemaController.validatePermission(className, aclGroup, 'delete')\n      ).then(() => {\n        if (!isMaster) {\n          query = this.addPointerPermissions(\n            schemaController,\n            className,\n            'delete',\n            query,\n            aclGroup\n          );\n          if (!query) {\n            throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n          }\n        }\n        // delete by query\n        if (acl) {\n          query = addWriteACL(query, acl);\n        }\n        validateQuery(query, isMaster, false, false);\n        return schemaController\n          .getOneSchema(className)\n          .catch(error => {\n            // If the schema doesn't exist, pretend it exists with no fields. This behavior\n            // will likely need revisiting.\n            if (error === undefined) {\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(parseFormatSchema =>\n            this.adapter.deleteObjectsByQuery(\n              className,\n              parseFormatSchema,\n              query,\n              this._transactionalSession\n            )\n          )\n          .catch(error => {\n            // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n            if (className === '_Session' && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n              return Promise.resolve({});\n            }\n            throw error;\n          });\n      });\n    });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(\n    className: string,\n    object: any,\n    { acl }: QueryOptions = {},\n    validateOnly: boolean = false,\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    try {\n      Utils.checkProhibitedKeywords(this.options, object);\n    } catch (error) {\n      return Promise.reject(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));\n    }\n    // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n\n    return this.validateClassName(className)\n      .then(() => this.loadSchemaIfNeeded(validSchemaController))\n      .then(schemaController => {\n        return (isMaster\n          ? Promise.resolve()\n          : schemaController.validatePermission(className, aclGroup, 'create')\n        )\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            if (validateOnly) {\n              return {};\n            }\n            return this.adapter.createObject(\n              className,\n              SchemaController.convertSchemaToAdapterSchema(schema),\n              object,\n              this._transactionalSession\n            );\n          })\n          .then(result => {\n            if (validateOnly) {\n              return originalObject;\n            }\n            return this.handleRelationUpdates(\n              className,\n              object.objectId,\n              object,\n              relationUpdates\n            ).then(() => {\n              return this._sanitizeDatabaseResult(originalObject, result.ops[0]);\n            });\n          });\n      });\n  }\n\n  canAddField(\n    schema: SchemaController.SchemaController,\n    className: string,\n    object: any,\n    aclGroup: string[],\n    runOptions: QueryOptions\n  ): Promise<void> {\n    const classSchema = schema.schemaData[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema.fields);\n    const newKeys = fields.filter(field => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(getRootFieldName(field)) < 0;\n    });\n    if (newKeys.length > 0) {\n      // adds a marker that new field is being adding during update\n      runOptions.addsField = true;\n\n      const action = runOptions.action;\n      return schema.validatePermission(className, aclGroup, 'addField', action);\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  /**\n   * Delete all classes and clears the schema cache\n   *\n   * @param {boolean} fast set to true if it's ok to just delete rows and not indexes\n   * @returns {Promise<void>} when the deletions completes\n   */\n  deleteEverything(fast: boolean = false): Promise<any> {\n    this.schemaPromise = null;\n    SchemaCache.clear();\n    return this.adapter.deleteAllClasses(fast);\n  }\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(\n    className: string,\n    key: string,\n    owningId: string,\n    queryOptions: QueryOptions\n  ): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { _id: sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter\n      .find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter\n      .find(\n        joinTableName(className, key),\n        relationSchema,\n        { relatedId: { $in: relatedIds } },\n        { keys: ['owningId'] }\n      )\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n    // Search for an in-relation or equal-to-relation\n    // Make it sequential for now, not sure of paralleization side effects\n    const promises = [];\n    if (query['$or']) {\n      const ors = query['$or'];\n      promises.push(\n        ...ors.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$or'][index] = aQuery;\n          });\n        })\n      );\n    }\n    if (query['$and']) {\n      const ands = query['$and'];\n      promises.push(\n        ...ands.map((aQuery, index) => {\n          return this.reduceInRelation(className, aQuery, schema).then(aQuery => {\n            query['$and'][index] = aQuery;\n          });\n        })\n      );\n    }\n\n    const otherKeys = Object.keys(query).map(key => {\n      if (key === '$and' || key === '$or') {\n        return;\n      }\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?(any[]) = null;\n      if (\n        query[key] &&\n        (query[key]['$in'] ||\n          query[key]['$ne'] ||\n          query[key]['$nin'] ||\n          query[key].__type == 'Pointer')\n      ) {\n        // Build the list of queries\n        queries = Object.keys(query[key]).map(constraintKey => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds,\n          };\n        });\n      } else {\n        queries = [{ isNegation: false, relatedIds: [] }];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map(q => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then(ids => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      });\n    });\n\n    return Promise.all([...promises, ...otherKeys]).then(() => {\n      return Promise.resolve(query);\n    });\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n    if (query['$or']) {\n      return Promise.all(\n        query['$or'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    if (query['$and']) {\n      return Promise.all(\n        query['$and'].map(aQuery => {\n          return this.reduceRelationKeys(className, aQuery, queryOptions);\n        })\n      );\n    }\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions\n      )\n        .then(ids => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        })\n        .then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> =\n      typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> =\n      query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> =\n      query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(\n      list => list !== null\n    );\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId,\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin, ...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId,\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  //  caseInsensitive make string comparisons case insensitive\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(\n    className: string,\n    query: any,\n    {\n      skip,\n      limit,\n      acl,\n      sort = {},\n      count,\n      keys,\n      op,\n      distinct,\n      pipeline,\n      readPreference,\n      hint,\n      caseInsensitive = false,\n      explain,\n    }: any = {},\n    auth: any = {},\n    validSchemaController: SchemaController.SchemaController\n  ): Promise<any> {\n    const isMaintenance = auth.isMaintenance;\n    const isMaster = acl === undefined || isMaintenance;\n    const aclGroup = acl || [];\n    op =\n      op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = count === true ? 'count' : op;\n\n    let classExists = true;\n    return this.loadSchemaIfNeeded(validSchemaController).then(schemaController => {\n      //Allow volatile classes if querying with Master (for _PushStatus)\n      //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n      //that api.parse.com breaks when _PushStatus exists in mongo.\n      return schemaController\n        .getOneSchema(className, isMaster)\n        .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n          if (error === undefined) {\n            classExists = false;\n            return { fields: {} };\n          }\n          throw error;\n        })\n        .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n          if (sort._created_at) {\n            sort.createdAt = sort._created_at;\n            delete sort._created_at;\n          }\n          if (sort._updated_at) {\n            sort.updatedAt = sort._updated_at;\n            delete sort._updated_at;\n          }\n          const queryOptions = {\n            skip,\n            limit,\n            sort,\n            keys,\n            readPreference,\n            hint,\n            caseInsensitive,\n            explain,\n          };\n          Object.keys(sort).forEach(fieldName => {\n            if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n              throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n            }\n            const rootFieldName = getRootFieldName(fieldName);\n            if (!SchemaController.fieldNameIsValid(rootFieldName, className)) {\n              throw new Parse.Error(\n                Parse.Error.INVALID_KEY_NAME,\n                `Invalid field name: ${fieldName}.`\n              );\n            }\n            if (!schema.fields[fieldName.split('.')[0]] && fieldName !== 'score') {\n              delete sort[fieldName];\n            }\n          });\n          return (isMaster\n            ? Promise.resolve()\n            : schemaController.validatePermission(className, aclGroup, op)\n          )\n            .then(() => this.reduceRelationKeys(className, query, queryOptions))\n            .then(() => this.reduceInRelation(className, query, schemaController))\n            .then(() => {\n              let protectedFields;\n              if (!isMaster) {\n                query = this.addPointerPermissions(\n                  schemaController,\n                  className,\n                  op,\n                  query,\n                  aclGroup\n                );\n                /* Don't use projections to optimize the protectedFields since the protectedFields\n                  based on pointer-permissions are determined after querying. The filtering can\n                  overwrite the protected fields. */\n                protectedFields = this.addProtectedFields(\n                  schemaController,\n                  className,\n                  query,\n                  aclGroup,\n                  auth,\n                  queryOptions\n                );\n              }\n              if (!query) {\n                if (op === 'get') {\n                  throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                } else {\n                  return [];\n                }\n              }\n              if (!isMaster) {\n                if (op === 'update' || op === 'delete') {\n                  query = addWriteACL(query, aclGroup);\n                } else {\n                  query = addReadACL(query, aclGroup);\n                }\n              }\n              validateQuery(query, isMaster, isMaintenance, false);\n              if (count) {\n                if (!classExists) {\n                  return 0;\n                } else {\n                  return this.adapter.count(\n                    className,\n                    schema,\n                    query,\n                    readPreference,\n                    undefined,\n                    hint\n                  );\n                }\n              } else if (distinct) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.distinct(className, schema, query, distinct);\n                }\n              } else if (pipeline) {\n                if (!classExists) {\n                  return [];\n                } else {\n                  return this.adapter.aggregate(\n                    className,\n                    schema,\n                    pipeline,\n                    readPreference,\n                    hint,\n                    explain\n                  );\n                }\n              } else if (explain) {\n                return this.adapter.find(className, schema, query, queryOptions);\n              } else {\n                return this.adapter\n                  .find(className, schema, query, queryOptions)\n                  .then(objects =>\n                    objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(\n                        isMaster,\n                        isMaintenance,\n                        aclGroup,\n                        auth,\n                        op,\n                        schemaController,\n                        className,\n                        protectedFields,\n                        object\n                      );\n                    })\n                  )\n                  .catch(error => {\n                    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                  });\n              }\n            });\n        });\n    });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    let schemaController;\n    return this.loadSchema({ clearCache: true })\n      .then(s => {\n        schemaController = s;\n        return schemaController.getOneSchema(className, true);\n      })\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }, null, '', false))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(\n                255,\n                `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`\n              );\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(\n                fieldName => schema.fields[fieldName].type === 'Relation'\n              );\n              return Promise.all(\n                relationFieldNames.map(name =>\n                  this.adapter.deleteClass(joinTableName(className, name))\n                )\n              ).then(() => {\n                SchemaCache.del(className);\n                return schemaController.reloadData();\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      });\n  }\n\n  // This helps to create intermediate objects for simpler comparison of\n  // key value pairs used in query objects. Each key value pair will represented\n  // in a similar way to json\n  objectToEntriesStrings(query: any): Array<string> {\n    return Object.entries(query).map(a => a.map(s => JSON.stringify(s)).join(':'));\n  }\n\n  // Naive logic reducer for OR operations meant to be used only for pointer permissions.\n  reduceOrOperation(query: { $or: Array<any> }): any {\n    if (!query.$or) {\n      return query;\n    }\n    const queries = query.$or.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the longer query.\n            query.$or.splice(longer, 1);\n            queries.splice(longer, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$or.length === 1) {\n      query = { ...query, ...query.$or[0] };\n      delete query.$or;\n    }\n    return query;\n  }\n\n  // Naive logic reducer for AND operations meant to be used only for pointer permissions.\n  reduceAndOperation(query: { $and: Array<any> }): any {\n    if (!query.$and) {\n      return query;\n    }\n    const queries = query.$and.map(q => this.objectToEntriesStrings(q));\n    let repeat = false;\n    do {\n      repeat = false;\n      for (let i = 0; i < queries.length - 1; i++) {\n        for (let j = i + 1; j < queries.length; j++) {\n          const [shorter, longer] = queries[i].length > queries[j].length ? [j, i] : [i, j];\n          const foundEntries = queries[shorter].reduce(\n            (acc, entry) => acc + (queries[longer].includes(entry) ? 1 : 0),\n            0\n          );\n          const shorterEntries = queries[shorter].length;\n          if (foundEntries === shorterEntries) {\n            // If the shorter query is completely contained in the longer one, we can strike\n            // out the shorter query.\n            query.$and.splice(shorter, 1);\n            queries.splice(shorter, 1);\n            repeat = true;\n            break;\n          }\n        }\n      }\n    } while (repeat);\n    if (query.$and.length === 1) {\n      query = { ...query, ...query.$and[0] };\n      delete query.$and;\n    }\n    return query;\n  }\n\n  // Constraints query using CLP's pointer permissions (PP) if any.\n  // 1. Etract the user id from caller's ACLgroup;\n  // 2. Exctract a list of field names that are PP for target collection and operation;\n  // 3. Constraint the original query so that each PP field must\n  // point to caller's id (or contain it in case of PP field being an array)\n  addPointerPermissions(\n    schema: SchemaController.SchemaController,\n    className: string,\n    operation: string,\n    query: any,\n    aclGroup: any[] = []\n  ): any {\n    // Check if class has public permission for operation\n    // If the BaseCLP pass, let go through\n    if (schema.testPermissionsForClassName(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.getClassLevelPermissions(className);\n\n    const userACL = aclGroup.filter(acl => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n\n    const groupKey =\n      ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    const permFields = [];\n\n    if (perms[operation] && perms[operation].pointerFields) {\n      permFields.push(...perms[operation].pointerFields);\n    }\n\n    if (perms[groupKey]) {\n      for (const field of perms[groupKey]) {\n        if (!permFields.includes(field)) {\n          permFields.push(field);\n        }\n      }\n    }\n    // the ACL should have exactly 1 user\n    if (permFields.length > 0) {\n      // the ACL should have exactly 1 user\n      // No user set return undefined\n      // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer = {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: userId,\n      };\n\n      const queries = permFields.map(key => {\n        const fieldDescriptor = schema.getExpectedType(className, key);\n        const fieldType =\n          fieldDescriptor &&\n          typeof fieldDescriptor === 'object' &&\n          Object.prototype.hasOwnProperty.call(fieldDescriptor, 'type')\n            ? fieldDescriptor.type\n            : null;\n\n        let queryClause;\n\n        if (fieldType === 'Pointer') {\n          // constraint for single pointer setup\n          queryClause = { [key]: userPointer };\n        } else if (fieldType === 'Array') {\n          // constraint for users-array setup\n          queryClause = { [key]: { $all: [userPointer] } };\n        } else if (fieldType === 'Object') {\n          // constraint for object setup\n          queryClause = { [key]: userPointer };\n        } else {\n          // This means that there is a CLP field of an unexpected type. This condition should not happen, which is\n          // why is being treated as an error.\n          throw Error(\n            `An unexpected condition occurred when resolving pointer permissions: ${className} ${key}`\n          );\n        }\n        // if we already have a constraint on the key, use the $and\n        if (Object.prototype.hasOwnProperty.call(query, key)) {\n          return this.reduceAndOperation({ $and: [queryClause, query] });\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, queryClause);\n      });\n\n      return queries.length === 1 ? queries[0] : this.reduceOrOperation({ $or: queries });\n    } else {\n      return query;\n    }\n  }\n\n  addProtectedFields(\n    schema: SchemaController.SchemaController | any,\n    className: string,\n    query: any = {},\n    aclGroup: any[] = [],\n    auth: any = {},\n    queryOptions: FullQueryOptions = {}\n  ): null | string[] {\n    const perms =\n      schema && schema.getClassLevelPermissions\n        ? schema.getClassLevelPermissions(className)\n        : schema;\n    if (!perms) return null;\n\n    const protectedFields = perms.protectedFields;\n    if (!protectedFields) return null;\n\n    if (aclGroup.indexOf(query.objectId) > -1) return null;\n\n    // for queries where \"keys\" are set and do not include all 'userField':{field},\n    // we have to transparently include it, and then remove before returning to client\n    // Because if such key not projected the permission won't be enforced properly\n    // PS this is called when 'excludeKeys' already reduced to 'keys'\n    const preserveKeys = queryOptions.keys;\n\n    // these are keys that need to be included only\n    // to be able to apply protectedFields by pointer\n    // and then unset before returning to client (later in  filterSensitiveFields)\n    const serverOnlyKeys = [];\n\n    const authenticated = auth.user;\n\n    // map to allow check without array search\n    const roles = (auth.userRoles || []).reduce((acc, r) => {\n      acc[r] = protectedFields[r];\n      return acc;\n    }, {});\n\n    // array of sets of protected fields. separate item for each applicable criteria\n    const protectedKeysSets = [];\n\n    for (const key in protectedFields) {\n      // skip userFields\n      if (key.startsWith('userField:')) {\n        if (preserveKeys) {\n          const fieldName = key.substring(10);\n          if (!preserveKeys.includes(fieldName)) {\n            // 1. put it there temporarily\n            queryOptions.keys && queryOptions.keys.push(fieldName);\n            // 2. preserve it delete later\n            serverOnlyKeys.push(fieldName);\n          }\n        }\n        continue;\n      }\n\n      // add public tier\n      if (key === '*') {\n        protectedKeysSets.push(protectedFields[key]);\n        continue;\n      }\n\n      if (authenticated) {\n        if (key === 'authenticated') {\n          // for logged in users\n          protectedKeysSets.push(protectedFields[key]);\n          continue;\n        }\n\n        if (roles[key] && key.startsWith('role:')) {\n          // add applicable roles\n          protectedKeysSets.push(roles[key]);\n        }\n      }\n    }\n\n    // check if there's a rule for current user's id\n    if (authenticated) {\n      const userId = auth.user.id;\n      if (perms.protectedFields[userId]) {\n        protectedKeysSets.push(perms.protectedFields[userId]);\n      }\n    }\n\n    // preserve fields to be removed before sending response to client\n    if (serverOnlyKeys.length > 0) {\n      perms.protectedFields.temporaryKeys = serverOnlyKeys;\n    }\n\n    let protectedKeys = protectedKeysSets.reduce((acc, next) => {\n      if (next) {\n        acc.push(...next);\n      }\n      return acc;\n    }, []);\n\n    // intersect all sets of protectedFields\n    protectedKeysSets.forEach(fields => {\n      if (fields) {\n        protectedKeys = protectedKeys.filter(v => fields.includes(v));\n      }\n    });\n\n    return protectedKeys;\n  }\n\n  createTransactionalSession() {\n    return this.adapter.createTransactionalSession().then(transactionalSession => {\n      this._transactionalSession = transactionalSession;\n    });\n  }\n\n  commitTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to commit');\n    }\n    return this.adapter.commitTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  abortTransactionalSession() {\n    if (!this._transactionalSession) {\n      throw new Error('There is no transactional session to abort');\n    }\n    return this.adapter.abortTransactionalSession(this._transactionalSession).then(() => {\n      this._transactionalSession = null;\n    });\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  async performInitialization() {\n    await this.adapter.performInitialization({\n      VolatileClassesSchemas: SchemaController.VolatileClassesSchemas,\n    });\n    const requiredUserFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._User,\n      },\n    };\n    const requiredRoleFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Role,\n      },\n    };\n    const requiredIdempotencyFields = {\n      fields: {\n        ...SchemaController.defaultColumns._Default,\n        ...SchemaController.defaultColumns._Idempotency,\n      },\n    };\n    await this.loadSchema().then(schema => schema.enforceClassExists('_User'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Role'));\n    await this.loadSchema().then(schema => schema.enforceClassExists('_Idempotency'));\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for usernames: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['username'], 'case_insensitive_username', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive username index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureIndex('_User', requiredUserFields, ['email'], 'case_insensitive_email', true)\n      .catch(error => {\n        logger.warn('Unable to create case insensitive email index: ', error);\n        throw error;\n      });\n\n    await this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']).catch(error => {\n      logger.warn('Unable to ensure uniqueness for role name: ', error);\n      throw error;\n    });\n\n    await this.adapter\n      .ensureUniqueness('_Idempotency', requiredIdempotencyFields, ['reqId'])\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for idempotency request ID: ', error);\n        throw error;\n      });\n\n    const isMongoAdapter = this.adapter instanceof MongoStorageAdapter;\n    const isPostgresAdapter = this.adapter instanceof PostgresStorageAdapter;\n    if (isMongoAdapter || isPostgresAdapter) {\n      let options = {};\n      if (isMongoAdapter) {\n        options = {\n          ttl: 0,\n        };\n      } else if (isPostgresAdapter) {\n        options = this.idempotencyOptions;\n        options.setIdempotencyFunction = true;\n      }\n      await this.adapter\n        .ensureIndex('_Idempotency', requiredIdempotencyFields, ['expire'], 'ttl', false, options)\n        .catch(error => {\n          logger.warn('Unable to create TTL index for idempotency expire date: ', error);\n          throw error;\n        });\n    }\n    await this.adapter.updateSchemaWithIndexes();\n  }\n\n  _expandResultOnKeyPath(object: any, key: string, value: any): any {\n    if (key.indexOf('.') < 0) {\n      object[key] = value[key];\n      return object;\n    }\n    const path = key.split('.');\n    const firstKey = path[0];\n    const nextPath = path.slice(1).join('.');\n\n    // Scan request data for denied keywords\n    if (this.options && this.options.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of this.options.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue(\n          { [firstKey]: true, [nextPath]: true },\n          keyword.key,\n          true\n        );\n        if (match) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_KEY_NAME,\n            `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`\n          );\n        }\n      }\n    }\n\n    object[firstKey] = this._expandResultOnKeyPath(\n      object[firstKey] || {},\n      nextPath,\n      value[firstKey]\n    );\n    delete object[key];\n    return object;\n  }\n\n  _sanitizeDatabaseResult(originalObject: any, result: any): Promise<any> {\n    const response = {};\n    if (!result) {\n      return Promise.resolve(response);\n    }\n    Object.keys(originalObject).forEach(key => {\n      const keyUpdate = originalObject[key];\n      // determine if that was an op\n      if (\n        keyUpdate &&\n        typeof keyUpdate === 'object' &&\n        keyUpdate.__op &&\n        ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1\n      ) {\n        // only valid ops that produce an actionable result\n        // the op may have happened on a keypath\n        this._expandResultOnKeyPath(response, key, result);\n      }\n    });\n    return Promise.resolve(response);\n  }\n\n  static _validateQuery: (any, boolean, boolean, boolean) => void;\n  static filterSensitiveData: (boolean, boolean, any[], any, any, any, string, any[], any) => void;\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\nmodule.exports.filterSensitiveData = filterSensitiveData;\n", "// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nconst Auth = require('./Auth');\nconst Utils = require('./Utils');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\nconst util = require('util');\nimport RestQuery from './RestQuery';\nimport _ from 'lodash';\nimport logger from './logger';\nimport { requiredColumns } from './Controllers/SchemaController';\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK, context, action) {\n  if (auth.isReadOnly) {\n    throw new Parse.Error(\n      Parse.Error.OPERATION_FORBIDDEN,\n      'Cannot perform a write operation when using readOnlyMasterKey'\n    );\n  }\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  this.context = context || {};\n\n  if (action) {\n    this.runOptions.action = action;\n  }\n\n  if (!query) {\n    if (this.config.allowCustomObjectId) {\n      if (Object.prototype.hasOwnProperty.call(data, 'objectId') && !data.objectId) {\n        throw new Parse.Error(\n          Parse.Error.MISSING_OBJECT_ID,\n          'objectId must not be empty, null or undefined'\n        );\n      }\n    } else {\n      if (data.objectId) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n      }\n      if (data.id) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'id is an invalid field name.');\n      }\n    }\n  }\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n\n  // Shared SchemaController to be reused to reduce the number of loadSchema() calls per request\n  // Once set the schemaData should be immutable\n  this.validSchemaController = null;\n  this.pendingOps = {\n    operations: null,\n    identifier: null,\n  };\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function () {\n  return Promise.resolve()\n    .then(() => {\n      return this.getUserAndRoleACL();\n    })\n    .then(() => {\n      return this.validateClientClassCreation();\n    })\n    .then(() => {\n      return this.handleInstallation();\n    })\n    .then(() => {\n      return this.handleSession();\n    })\n    .then(() => {\n      return this.validateAuthData();\n    })\n    .then(() => {\n      return this.runBeforeSaveTrigger();\n    })\n    .then(() => {\n      return this.ensureUniqueAuthDataId();\n    })\n    .then(() => {\n      return this.deleteEmailResetTokenIfNeeded();\n    })\n    .then(() => {\n      return this.validateSchema();\n    })\n    .then(schemaController => {\n      this.validSchemaController = schemaController;\n      return this.setRequiredFieldsIfNeeded();\n    })\n    .then(() => {\n      return this.transformUser();\n    })\n    .then(() => {\n      return this.expandFilesForExistingObjects();\n    })\n    .then(() => {\n      return this.destroyDuplicatedSessions();\n    })\n    .then(() => {\n      return this.runDatabaseOperation();\n    })\n    .then(() => {\n      return this.createSessionTokenIfNeeded();\n    })\n    .then(() => {\n      return this.handleFollowup();\n    })\n    .then(() => {\n      return this.runAfterSaveTrigger();\n    })\n    .then(() => {\n      return this.cleanUserAuthData();\n    })\n    .then(() => {\n      // Append the authDataResponse if exists\n      if (this.authDataResponse) {\n        if (this.response && this.response.response) {\n          this.response.response.authDataResponse = this.authDataResponse;\n        }\n      }\n      return this.response;\n    });\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function () {\n  if (this.auth.isMaster || this.auth.isMaintenance) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then(roles => {\n      this.runOptions.acl = this.runOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function () {\n  if (\n    this.config.allowClientClassCreation === false &&\n    !this.auth.isMaster &&\n    !this.auth.isMaintenance &&\n    SchemaController.systemClasses.indexOf(this.className) === -1\n  ) {\n    return this.config.database\n      .loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(\n            Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' + 'non-existent class: ' + this.className\n          );\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function () {\n  return this.config.database.validateObject(\n    this.className,\n    this.data,\n    this.query,\n    this.runOptions,\n    this.auth.isMaintenance\n  );\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeSaveTrigger = function () {\n  if (this.response || this.runOptions.many) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)\n  ) {\n    return Promise.resolve();\n  }\n\n  const { originalObject, updatedObject } = this.buildParseObjects();\n  const identifier = updatedObject._getStateIdentifier();\n  const stateController = Parse.CoreManager.getObjectStateController();\n  const [pending] = stateController.getPendingOps(identifier);\n  this.pendingOps = {\n    operations: { ...pending },\n    identifier,\n  };\n\n  return Promise.resolve()\n    .then(() => {\n      // Before calling the trigger, validate the permissions for the save operation\n      let databasePromise = null;\n      if (this.query) {\n        // Validate for updating\n        databasePromise = this.config.database.update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          true,\n          true\n        );\n      } else {\n        // Validate for creating\n        databasePromise = this.config.database.create(\n          this.className,\n          this.data,\n          this.runOptions,\n          true\n        );\n      }\n      // In the case that there is no permission for the operation, it throws an error\n      return databasePromise.then(result => {\n        if (!result || result.length <= 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n      });\n    })\n    .then(() => {\n      return triggers.maybeRunTrigger(\n        triggers.Types.beforeSave,\n        this.auth,\n        updatedObject,\n        originalObject,\n        this.config,\n        this.context\n      );\n    })\n    .then(response => {\n      if (response && response.object) {\n        this.storage.fieldsChangedByTrigger = _.reduce(\n          response.object,\n          (result, value, key) => {\n            if (!_.isEqual(this.data[key], value)) {\n              result.push(key);\n            }\n            return result;\n          },\n          []\n        );\n        this.data = response.object;\n        // We should delete the objectId for an update write\n        if (this.query && this.query.objectId) {\n          delete this.data.objectId;\n        }\n      }\n      try {\n        Utils.checkProhibitedKeywords(this.config, this.data);\n      } catch (error) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, error);\n      }\n    });\n};\n\nRestWrite.prototype.runBeforeLoginTrigger = async function (userData) {\n  // Avoid doing any setup for triggers if there is no 'beforeLogin' trigger\n  if (\n    !triggers.triggerExists(this.className, triggers.Types.beforeLogin, this.config.applicationId)\n  ) {\n    return;\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  const extraData = { className: this.className };\n\n  // Expand file objects\n  this.config.filesController.expandFilesInObject(this.config, userData);\n\n  const user = triggers.inflate(extraData, userData);\n\n  // no need to return a response\n  await triggers.maybeRunTrigger(\n    triggers.Types.beforeLogin,\n    this.auth,\n    user,\n    null,\n    this.config,\n    this.context\n  );\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function () {\n  if (this.data) {\n    return this.validSchemaController.getAllClasses().then(allClasses => {\n      const schema = allClasses.find(oneClass => oneClass.className === this.className);\n      const setRequiredFieldIfNeeded = (fieldName, setDefault) => {\n        if (\n          this.data[fieldName] === undefined ||\n          this.data[fieldName] === null ||\n          this.data[fieldName] === '' ||\n          (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete')\n        ) {\n          if (\n            setDefault &&\n            schema.fields[fieldName] &&\n            schema.fields[fieldName].defaultValue !== null &&\n            schema.fields[fieldName].defaultValue !== undefined &&\n            (this.data[fieldName] === undefined ||\n              (typeof this.data[fieldName] === 'object' && this.data[fieldName].__op === 'Delete'))\n          ) {\n            this.data[fieldName] = schema.fields[fieldName].defaultValue;\n            this.storage.fieldsChangedByTrigger = this.storage.fieldsChangedByTrigger || [];\n            if (this.storage.fieldsChangedByTrigger.indexOf(fieldName) < 0) {\n              this.storage.fieldsChangedByTrigger.push(fieldName);\n            }\n          } else if (schema.fields[fieldName] && schema.fields[fieldName].required === true) {\n            throw new Parse.Error(Parse.Error.VALIDATION_ERROR, `${fieldName} is required`);\n          }\n        }\n      };\n\n      // Add default fields\n      this.data.updatedAt = this.updatedAt;\n      if (!this.query) {\n        this.data.createdAt = this.updatedAt;\n\n        // Only assign new objectId if we are creating new object\n        if (!this.data.objectId) {\n          this.data.objectId = cryptoUtils.newObjectId(this.config.objectIdSize);\n        }\n        if (schema) {\n          Object.keys(schema.fields).forEach(fieldName => {\n            setRequiredFieldIfNeeded(fieldName, true);\n          });\n        }\n      } else if (schema) {\n        Object.keys(this.data).forEach(fieldName => {\n          setRequiredFieldIfNeeded(fieldName, false);\n        });\n      }\n    });\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  const authData = this.data.authData;\n  const hasUsernameAndPassword =\n    typeof this.data.username === 'string' && typeof this.data.password === 'string';\n\n  if (!this.query && !authData) {\n    if (typeof this.data.username !== 'string' || _.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING, 'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING, 'password is required');\n    }\n  }\n\n  if (\n    (authData && !Object.keys(authData).length) ||\n    !Object.prototype.hasOwnProperty.call(this.data, 'authData')\n  ) {\n    // Nothing to validate here\n    return;\n  } else if (Object.prototype.hasOwnProperty.call(this.data, 'authData') && !this.data.authData) {\n    // Handle saving authData to null\n    throw new Parse.Error(\n      Parse.Error.UNSUPPORTED_SERVICE,\n      'This authentication method is unsupported.'\n    );\n  }\n\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    const canHandleAuthData = providers.some(provider => {\n      var providerAuthData = authData[provider];\n      var hasToken = providerAuthData && providerAuthData.id;\n      return hasToken || providerAuthData === null;\n    });\n    if (canHandleAuthData || hasUsernameAndPassword || this.auth.isMaster || this.getUserId()) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(\n    Parse.Error.UNSUPPORTED_SERVICE,\n    'This authentication method is unsupported.'\n  );\n};\n\nRestWrite.prototype.filteredObjectsByACL = function (objects) {\n  if (this.auth.isMaster || this.auth.isMaintenance) {\n    return objects;\n  }\n  return objects.filter(object => {\n    if (!object.ACL) {\n      return true; // legacy users that have no ACL field on them\n    }\n    // Regular users that have been locked out.\n    return object.ACL && Object.keys(object.ACL).length > 0;\n  });\n};\n\nRestWrite.prototype.getUserId = function () {\n  if (this.query && this.query.objectId && this.className === '_User') {\n    return this.query.objectId;\n  } else if (this.auth && this.auth.user && this.auth.user.id) {\n    return this.auth.user.id;\n  }\n};\n\n// Developers are allowed to change authData via before save trigger\n// we need after before save to ensure that the developer\n// is not currently duplicating auth data ID\nRestWrite.prototype.ensureUniqueAuthDataId = async function () {\n  if (this.className !== '_User' || !this.data.authData) {\n    return;\n  }\n\n  const hasAuthDataId = Object.keys(this.data.authData).some(\n    key => this.data.authData[key] && this.data.authData[key].id\n  );\n\n  if (!hasAuthDataId) return;\n\n  const r = await Auth.findUsersWithAuthData(this.config, this.data.authData);\n  const results = this.filteredObjectsByACL(r);\n  if (results.length > 1) {\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n  // use data.objectId in case of login time and found user during handle validateAuthData\n  const userId = this.getUserId() || this.data.objectId;\n  if (results.length === 1 && userId !== results[0].objectId) {\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n};\n\nRestWrite.prototype.handleAuthData = async function (authData) {\n  const r = await Auth.findUsersWithAuthData(this.config, authData);\n  const results = this.filteredObjectsByACL(r);\n\n  if (results.length > 1) {\n    // To avoid https://github.com/parse-community/parse-server/security/advisories/GHSA-8w3j-g983-8jh5\n    // Let's run some validation before throwing\n    await Auth.handleAuthDataValidation(authData, this, results[0]);\n    throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n  }\n\n  // No user found with provided authData we need to validate\n  if (!results.length) {\n    const { authData: validatedAuthData, authDataResponse } = await Auth.handleAuthDataValidation(\n      authData,\n      this\n    );\n    this.authDataResponse = authDataResponse;\n    // Replace current authData by the new validated one\n    this.data.authData = validatedAuthData;\n    return;\n  }\n\n  // User found with provided authData\n  if (results.length === 1) {\n    const userId = this.getUserId();\n    const userResult = results[0];\n    // Prevent duplicate authData id\n    if (userId && userId !== userResult.objectId) {\n      throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED, 'this auth is already used');\n    }\n\n    this.storage.authProvider = Object.keys(authData).join(',');\n\n    const { hasMutatedAuthData, mutatedAuthData } = Auth.hasMutatedAuthData(\n      authData,\n      userResult.authData\n    );\n\n    const isCurrentUserLoggedOrMaster =\n      (this.auth && this.auth.user && this.auth.user.id === userResult.objectId) ||\n      this.auth.isMaster;\n\n    const isLogin = !userId;\n\n    if (isLogin || isCurrentUserLoggedOrMaster) {\n      // no user making the call\n      // OR the user making the call is the right one\n      // Login with auth data\n      delete results[0].password;\n\n      // need to set the objectId first otherwise location has trailing undefined\n      this.data.objectId = userResult.objectId;\n\n      if (!this.query || !this.query.objectId) {\n        this.response = {\n          response: userResult,\n          location: this.location(),\n        };\n        // Run beforeLogin hook before storing any updates\n        // to authData on the db; changes to userResult\n        // will be ignored.\n        await this.runBeforeLoginTrigger(deepcopy(userResult));\n\n        // If we are in login operation via authData\n        // we need to be sure that the user has provided\n        // required authData\n        Auth.checkIfUserHasProvidedConfiguredProvidersForLogin(\n          authData,\n          userResult.authData,\n          this.config\n        );\n      }\n\n      // Prevent validating if no mutated data detected on update\n      if (!hasMutatedAuthData && isCurrentUserLoggedOrMaster) {\n        return;\n      }\n\n      // Force to validate all provided authData on login\n      // on update only validate mutated ones\n      if (hasMutatedAuthData || !this.config.allowExpiredAuthDataToken) {\n        const res = await Auth.handleAuthDataValidation(\n          isLogin ? authData : mutatedAuthData,\n          this,\n          userResult\n        );\n        this.data.authData = res.authData;\n        this.authDataResponse = res.authDataResponse;\n      }\n\n      // IF we are in login we'll skip the database operation / beforeSave / afterSave etc...\n      // we need to set it up there.\n      // We are supposed to have a response only on LOGIN with authData, so we skip those\n      // If we're not logging in, but just updating the current user, we can safely skip that part\n      if (this.response) {\n        // Assign the new authData in the response\n        Object.keys(mutatedAuthData).forEach(provider => {\n          this.response.response.authData[provider] = mutatedAuthData[provider];\n        });\n\n        // Run the DB update directly, as 'master' only if authData contains some keys\n        // authData could not contains keys after validation if the authAdapter\n        // uses the `doNotSave` option. Just update the authData part\n        // Then we're good for the user, early exit of sorts\n        if (Object.keys(this.data.authData).length) {\n          await this.config.database.update(\n            this.className,\n            { objectId: this.data.objectId },\n            { authData: this.data.authData },\n            {}\n          );\n        }\n      }\n    }\n  }\n};\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function () {\n  var promise = Promise.resolve();\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (!this.auth.isMaintenance && !this.auth.isMaster && 'emailVerified' in this.data) {\n    const error = `Clients aren't allowed to manually update email verification.`;\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // Do not cleanup session if objectId is not set\n  if (this.query && this.objectId()) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    })\n      .execute()\n      .then(results => {\n        results.results.forEach(session =>\n          this.config.cacheController.user.del(session.sessionToken)\n        );\n      });\n  }\n\n  return promise\n    .then(() => {\n      // Transform the password\n      if (this.data.password === undefined) {\n        // ignore only if undefined. should proceed if empty ('')\n        return Promise.resolve();\n      }\n\n      if (this.query) {\n        this.storage['clearSessions'] = true;\n        // Generate a new session only if the user requested\n        if (!this.auth.isMaster && !this.auth.isMaintenance) {\n          this.storage['generateNewSession'] = true;\n        }\n      }\n\n      return this._validatePasswordPolicy().then(() => {\n        return passwordCrypto.hash(this.data.password).then(hashedPassword => {\n          this.data._hashed_password = hashedPassword;\n          delete this.data.password;\n        });\n      });\n    })\n    .then(() => {\n      return this._validateUserName();\n    })\n    .then(() => {\n      return this._validateEmail();\n    });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  /*\n    Usernames should be unique when compared case insensitively\n\n    Users should be able to make case sensitive usernames and\n    login using the case they entered.  I.e. 'Snoopy' should preclude\n    'snoopy' as a valid username.\n  */\n  return this.config.database\n    .find(\n      this.className,\n      {\n        username: this.data.username,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.USERNAME_TAKEN,\n          'Account already exists for this username.'\n        );\n      }\n      return;\n    });\n};\n\n/*\n  As with usernames, Parse should not allow case insensitive collisions of email.\n  unlike with usernames (which can have case insensitive collisions in the case of\n  auth adapters), emails should never have a case insensitive collision.\n\n  This behavior can be enforced through a properly configured index see:\n  https://docs.mongodb.com/manual/core/index-case-insensitive/#create-a-case-insensitive-index\n  which could be implemented instead of this code based validation.\n\n  Given that this lookup should be a relatively low use case and that the case sensitive\n  unique index will be used by the db for the query, this is an adequate solution.\n*/\nRestWrite.prototype._validateEmail = function () {\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(\n      new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.')\n    );\n  }\n  // Case insensitive match, see note above function.\n  return this.config.database\n    .find(\n      this.className,\n      {\n        email: this.data.email,\n        objectId: { $ne: this.objectId() },\n      },\n      { limit: 1, caseInsensitive: true },\n      {},\n      this.validSchemaController\n    )\n    .then(results => {\n      if (results.length > 0) {\n        throw new Parse.Error(\n          Parse.Error.EMAIL_TAKEN,\n          'Account already exists for this email address.'\n        );\n      }\n      if (\n        !this.data.authData ||\n        !Object.keys(this.data.authData).length ||\n        (Object.keys(this.data.authData).length === 1 &&\n          Object.keys(this.data.authData)[0] === 'anonymous')\n      ) {\n        // We updated the email, send a new validation\n        this.storage['sendVerificationEmail'] = true;\n        this.config.userController.setEmailVerifyToken(this.data);\n      }\n    });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function () {\n  if (!this.config.passwordPolicy) return Promise.resolve();\n  return this._validatePasswordRequirements().then(() => {\n    return this._validatePasswordHistory();\n  });\n};\n\nRestWrite.prototype._validatePasswordRequirements = function () {\n  // check if the password conforms to the defined password policy if configured\n  // If we specified a custom error in our configuration use it.\n  // Example: \"Passwords must include a Capital Letter, Lowercase Letter, and a number.\"\n  //\n  // This is especially useful on the generic \"password reset\" page,\n  // as it allows the programmer to communicate specific requirements instead of:\n  // a. making the user guess whats wrong\n  // b. making a custom password reset page that shows the requirements\n  const policyError = this.config.passwordPolicy.validationError\n    ? this.config.passwordPolicy.validationError\n    : 'Password does not meet the Password Policy requirements.';\n  const containsUsernameError = 'Password cannot contain your username.';\n\n  // check whether the password meets the password strength requirements\n  if (\n    (this.config.passwordPolicy.patternValidator &&\n      !this.config.passwordPolicy.patternValidator(this.data.password)) ||\n    (this.config.passwordPolicy.validatorCallback &&\n      !this.config.passwordPolicy.validatorCallback(this.data.password))\n  ) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) {\n      // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0)\n        return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError));\n    } else {\n      // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', { objectId: this.objectId() }).then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        if (this.data.password.indexOf(results[0].username) >= 0)\n          return Promise.reject(\n            new Parse.Error(Parse.Error.VALIDATION_ERROR, containsUsernameError)\n          );\n        return Promise.resolve();\n      });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function () {\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database\n      .find(\n        '_User',\n        { objectId: this.objectId() },\n        { keys: ['_password_history', '_hashed_password'] },\n        Auth.maintenance(this.config)\n      )\n      .then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history)\n          oldPasswords = _.take(\n            user._password_history,\n            this.config.passwordPolicy.maxPasswordHistory - 1\n          );\n        oldPasswords.push(user.password);\n        const newPassword = this.data.password;\n        // compare the new password hash with all old password hashes\n        const promises = oldPasswords.map(function (hash) {\n          return passwordCrypto.compare(newPassword, hash).then(result => {\n            if (result)\n              // reject if there is a match\n              return Promise.reject('REPEAT_PASSWORD');\n            return Promise.resolve();\n          });\n        });\n        // wait for all comparisons to complete\n        return Promise.all(promises)\n          .then(() => {\n            return Promise.resolve();\n          })\n          .catch(err => {\n            if (err === 'REPEAT_PASSWORD')\n              // a match was found\n              return Promise.reject(\n                new Parse.Error(\n                  Parse.Error.VALIDATION_ERROR,\n                  `New password should not be the same as last ${this.config.passwordPolicy.maxPasswordHistory} passwords.`\n                )\n              );\n            throw err;\n          });\n      });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function () {\n  if (this.className !== '_User') {\n    return;\n  }\n  // Don't generate session for updating user (this.query is set) unless authData exists\n  if (this.query && !this.data.authData) {\n    return;\n  }\n  // Don't generate new sessionToken if linking via sessionToken\n  if (this.auth.user && this.data.authData) {\n    return;\n  }\n  if (\n    !this.storage.authProvider && // signup call, with\n    this.config.preventLoginWithUnverifiedEmail && // no login without verification\n    this.config.verifyUserEmails\n  ) {\n    // verification is on\n    return; // do not create the session token in that case!\n  }\n  return this.createSessionToken();\n};\n\nRestWrite.prototype.createSessionToken = async function () {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n\n  if (this.storage.authProvider == null && this.data.authData) {\n    this.storage.authProvider = Object.keys(this.data.authData).join(',');\n  }\n\n  const { sessionData, createSession } = RestWrite.createSession(this.config, {\n    userId: this.objectId(),\n    createdWith: {\n      action: this.storage.authProvider ? 'login' : 'signup',\n      authProvider: this.storage.authProvider || 'password',\n    },\n    installationId: this.auth.installationId,\n  });\n\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = sessionData.sessionToken;\n  }\n\n  return createSession();\n};\n\nRestWrite.createSession = function (\n  config,\n  { userId, createdWith, installationId, additionalSessionData }\n) {\n  const token = 'r:' + cryptoUtils.newToken();\n  const expiresAt = config.generateSessionExpiresAt();\n  const sessionData = {\n    sessionToken: token,\n    user: {\n      __type: 'Pointer',\n      className: '_User',\n      objectId: userId,\n    },\n    createdWith,\n    expiresAt: Parse._encode(expiresAt),\n  };\n\n  if (installationId) {\n    sessionData.installationId = installationId;\n  }\n\n  Object.assign(sessionData, additionalSessionData);\n\n  return {\n    sessionData,\n    createSession: () =>\n      new RestWrite(config, Auth.master(config), '_Session', null, sessionData).execute(),\n  };\n};\n\n// Delete email reset tokens if user is changing password or email.\nRestWrite.prototype.deleteEmailResetTokenIfNeeded = function () {\n  if (this.className !== '_User' || this.query === null) {\n    // null query means create\n    return;\n  }\n\n  if ('password' in this.data || 'email' in this.data) {\n    const addOps = {\n      _perishable_token: { __op: 'Delete' },\n      _perishable_token_expires_at: { __op: 'Delete' },\n    };\n    this.data = Object.assign(this.data, addOps);\n  }\n};\n\nRestWrite.prototype.destroyDuplicatedSessions = function () {\n  // Only for _Session, and at creation time\n  if (this.className != '_Session' || this.query) {\n    return;\n  }\n  // Destroy the sessions in 'Background'\n  const { user, installationId, sessionToken } = this.data;\n  if (!user || !installationId) {\n    return;\n  }\n  if (!user.objectId) {\n    return;\n  }\n  this.config.database.destroy(\n    '_Session',\n    {\n      user,\n      installationId,\n      sessionToken: { $ne: sessionToken },\n    },\n    {},\n    this.validSchemaController\n  );\n};\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function () {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId(),\n      },\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database\n      .destroy('_Session', sessionQuery)\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken().then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an _Session object.\nRestWrite.prototype.handleSession = function () {\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster && !this.auth.isMaintenance) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' + 'ACL on a Session.');\n  }\n\n  if (this.query) {\n    if (this.data.user && !this.auth.isMaster && this.data.user.objectId != this.auth.user.id) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.installationId) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.sessionToken) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    }\n    if (!this.auth.isMaster) {\n      this.query = {\n        $and: [\n          this.query,\n          {\n            user: {\n              __type: 'Pointer',\n              className: '_User',\n              objectId: this.auth.user.id,\n            },\n          },\n        ],\n      };\n    }\n  }\n\n  if (!this.query && !this.auth.isMaster && !this.auth.isMaintenance) {\n    const additionalSessionData = {};\n    for (var key in this.data) {\n      if (key === 'objectId' || key === 'user') {\n        continue;\n      }\n      additionalSessionData[key] = this.data[key];\n    }\n\n    const { sessionData, createSession } = RestWrite.createSession(this.config, {\n      userId: this.auth.user.id,\n      createdWith: {\n        action: 'create',\n      },\n      additionalSessionData,\n    });\n\n    return createSession().then(results => {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      this.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData,\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function () {\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (\n    !this.query &&\n    !this.data.deviceToken &&\n    !this.data.installationId &&\n    !this.auth.installationId\n  ) {\n    throw new Parse.Error(\n      135,\n      'at least one ID field (deviceToken, installationId) ' + 'must be specified in this operation'\n    );\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  let installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster && !this.auth.isMaintenance) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  const orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId,\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      installationId: installationId,\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({ deviceToken: this.data.deviceToken });\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise\n    .then(() => {\n      return this.config.database.find(\n        '_Installation',\n        {\n          $or: orQueries,\n        },\n        {}\n      );\n    })\n    .then(results => {\n      results.forEach(result => {\n        if (this.query && this.query.objectId && result.objectId == this.query.objectId) {\n          objectIdMatch = result;\n        }\n        if (result.installationId == installationId) {\n          installationIdMatch = result;\n        }\n        if (result.deviceToken == this.data.deviceToken) {\n          deviceTokenMatches.push(result);\n        }\n      });\n\n      // Sanity checks when running a query\n      if (this.query && this.query.objectId) {\n        if (!objectIdMatch) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for update.');\n        }\n        if (\n          this.data.installationId &&\n          objectIdMatch.installationId &&\n          this.data.installationId !== objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'installationId may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceToken &&\n          objectIdMatch.deviceToken &&\n          this.data.deviceToken !== objectIdMatch.deviceToken &&\n          !this.data.installationId &&\n          !objectIdMatch.installationId\n        ) {\n          throw new Parse.Error(136, 'deviceToken may not be changed in this ' + 'operation');\n        }\n        if (\n          this.data.deviceType &&\n          this.data.deviceType &&\n          this.data.deviceType !== objectIdMatch.deviceType\n        ) {\n          throw new Parse.Error(136, 'deviceType may not be changed in this ' + 'operation');\n        }\n      }\n\n      if (this.query && this.query.objectId && objectIdMatch) {\n        idMatch = objectIdMatch;\n      }\n\n      if (installationId && installationIdMatch) {\n        idMatch = installationIdMatch;\n      }\n      // need to specify deviceType only if it's new\n      if (!this.query && !this.data.deviceType && !idMatch) {\n        throw new Parse.Error(135, 'deviceType must be specified in this operation');\n      }\n    })\n    .then(() => {\n      if (!idMatch) {\n        if (!deviceTokenMatches.length) {\n          return;\n        } else if (\n          deviceTokenMatches.length == 1 &&\n          (!deviceTokenMatches[0]['installationId'] || !installationId)\n        ) {\n          // Single match on device token but none on installationId, and either\n          // the passed object or the match is missing an installationId, so we\n          // can just return the match.\n          return deviceTokenMatches[0]['objectId'];\n        } else if (!this.data.installationId) {\n          throw new Parse.Error(\n            132,\n            'Must specify installationId when deviceToken ' +\n              'matches multiple Installation objects'\n          );\n        } else {\n          // Multiple device token matches and we specified an installation ID,\n          // or a single match where both the passed and matching objects have\n          // an installation ID. Try cleaning out old installations that match\n          // the deviceToken, and return nil to signal that a new object should\n          // be created.\n          var delQuery = {\n            deviceToken: this.data.deviceToken,\n            installationId: {\n              $ne: installationId,\n            },\n          };\n          if (this.data.appIdentifier) {\n            delQuery['appIdentifier'] = this.data.appIdentifier;\n          }\n          this.config.database.destroy('_Installation', delQuery).catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored.\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n          return;\n        }\n      } else {\n        if (deviceTokenMatches.length == 1 && !deviceTokenMatches[0]['installationId']) {\n          // Exactly one device token match and it doesn't have an installation\n          // ID. This is the one case where we want to merge with the existing\n          // object.\n          const delQuery = { objectId: idMatch.objectId };\n          return this.config.database\n            .destroy('_Installation', delQuery)\n            .then(() => {\n              return deviceTokenMatches[0]['objectId'];\n            })\n            .catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n        } else {\n          if (this.data.deviceToken && idMatch.deviceToken != this.data.deviceToken) {\n            // We're setting the device token on an existing installation, so\n            // we should try cleaning out old installations that match this\n            // device token.\n            const delQuery = {\n              deviceToken: this.data.deviceToken,\n            };\n            // We have a unique install Id, use that to preserve\n            // the interesting installation\n            if (this.data.installationId) {\n              delQuery['installationId'] = {\n                $ne: this.data.installationId,\n              };\n            } else if (\n              idMatch.objectId &&\n              this.data.objectId &&\n              idMatch.objectId == this.data.objectId\n            ) {\n              // we passed an objectId, preserve that instalation\n              delQuery['objectId'] = {\n                $ne: idMatch.objectId,\n              };\n            } else {\n              // What to do here? can't really clean up everything...\n              return idMatch.objectId;\n            }\n            if (this.data.appIdentifier) {\n              delQuery['appIdentifier'] = this.data.appIdentifier;\n            }\n            this.config.database.destroy('_Installation', delQuery).catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored.\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n          }\n          // In non-merge scenarios, just return the installation match id\n          return idMatch.objectId;\n        }\n      }\n    })\n    .then(objId => {\n      if (objId) {\n        this.query = { objectId: objId };\n        delete this.data.objectId;\n        delete this.data.createdAt;\n      }\n      // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n    });\n  return promise;\n};\n\n// If we short-circuited the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function () {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function () {\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n    if (this.config.liveQueryController) {\n      this.config.liveQueryController.clearCachedRoles(this.auth.user);\n    }\n  }\n\n  if (this.className === '_User' && this.query && this.auth.isUnauthenticated()) {\n    throw new Parse.Error(\n      Parse.Error.SESSION_MISSING,\n      `Cannot modify user ${this.query.objectId}.`\n    );\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (\n      this.className === '_User' &&\n      this.data.ACL &&\n      this.auth.isMaster !== true &&\n      this.auth.isMaintenance !== true\n    ) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordAge\n    ) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    let defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (\n      this.className === '_User' &&\n      this.data._hashed_password &&\n      this.config.passwordPolicy &&\n      this.config.passwordPolicy.maxPasswordHistory\n    ) {\n      defer = this.config.database\n        .find(\n          '_User',\n          { objectId: this.objectId() },\n          { keys: ['_password_history', '_hashed_password'] },\n          Auth.maintenance(this.config)\n        )\n        .then(results => {\n          if (results.length != 1) {\n            throw undefined;\n          }\n          const user = results[0];\n          let oldPasswords = [];\n          if (user._password_history) {\n            oldPasswords = _.take(\n              user._password_history,\n              this.config.passwordPolicy.maxPasswordHistory\n            );\n          }\n          //n-1 passwords go into history including last password\n          while (\n            oldPasswords.length > Math.max(0, this.config.passwordPolicy.maxPasswordHistory - 2)\n          ) {\n            oldPasswords.shift();\n          }\n          oldPasswords.push(user.password);\n          this.data._password_history = oldPasswords;\n        });\n    }\n\n    return defer.then(() => {\n      // Run an update\n      return this.config.database\n        .update(\n          this.className,\n          this.query,\n          this.data,\n          this.runOptions,\n          false,\n          false,\n          this.validSchemaController\n        )\n        .then(response => {\n          response.updatedAt = this.updatedAt;\n          this._updateResponseWithData(response, this.data);\n          this.response = { response };\n        });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        if (!this.config.enforcePrivateUsers) {\n          ACL['*'] = { read: true, write: false };\n        }\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database\n      .create(this.className, this.data, this.runOptions, false, this.validSchemaController)\n      .catch(error => {\n        if (this.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n\n        // Quick check, if we were able to infer the duplicated field name\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'username') {\n          throw new Parse.Error(\n            Parse.Error.USERNAME_TAKEN,\n            'Account already exists for this username.'\n          );\n        }\n\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'email') {\n          throw new Parse.Error(\n            Parse.Error.EMAIL_TAKEN,\n            'Account already exists for this email address.'\n          );\n        }\n\n        // If this was a failed user creation due to username or email already taken, we need to\n        // check whether it was username or email and return the appropriate error.\n        // Fallback to the original method\n        // TODO: See if we can later do this without additional queries by using named indexes.\n        return this.config.database\n          .find(\n            this.className,\n            {\n              username: this.data.username,\n              objectId: { $ne: this.objectId() },\n            },\n            { limit: 1 }\n          )\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.USERNAME_TAKEN,\n                'Account already exists for this username.'\n              );\n            }\n            return this.config.database.find(\n              this.className,\n              { email: this.data.email, objectId: { $ne: this.objectId() } },\n              { limit: 1 }\n            );\n          })\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(\n                Parse.Error.EMAIL_TAKEN,\n                'Account already exists for this email address.'\n              );\n            }\n            throw new Parse.Error(\n              Parse.Error.DUPLICATE_VALUE,\n              'A duplicate value for a field with unique values was provided'\n            );\n          });\n      })\n      .then(response => {\n        response.objectId = this.data.objectId;\n        response.createdAt = this.data.createdAt;\n\n        if (this.responseShouldHaveUsername) {\n          response.username = this.data.username;\n        }\n        this._updateResponseWithData(response, this.data);\n        this.response = {\n          status: 201,\n          response,\n          location: this.location(),\n        };\n      });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterSaveTrigger = function () {\n  if (!this.response || !this.response.response || this.runOptions.many) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  const hasAfterSaveHook = triggers.triggerExists(\n    this.className,\n    triggers.Types.afterSave,\n    this.config.applicationId\n  );\n  const hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  const { originalObject, updatedObject } = this.buildParseObjects();\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  this.config.database.loadSchema().then(schemaController => {\n    // Notifiy LiveQueryServer if possible\n    const perms = schemaController.getClassLevelPermissions(updatedObject.className);\n    this.config.liveQueryController.onAfterSave(\n      updatedObject.className,\n      updatedObject,\n      originalObject,\n      perms\n    );\n  });\n\n  // Run afterSave trigger\n  return triggers\n    .maybeRunTrigger(\n      triggers.Types.afterSave,\n      this.auth,\n      updatedObject,\n      originalObject,\n      this.config,\n      this.context\n    )\n    .then(result => {\n      const jsonReturned = result && !result._toFullJSON;\n      if (jsonReturned) {\n        this.pendingOps.operations = {};\n        this.response.response = result;\n      } else {\n        this.response.response = this._updateResponseWithData(\n          (result || updatedObject).toJSON(),\n          this.data\n        );\n      }\n    })\n    .catch(function (err) {\n      logger.warn('afterSave caught an error', err);\n    });\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function () {\n  var middle = this.className === '_User' ? '/users/' : '/classes/' + this.className + '/';\n  const mount = this.config.mount || this.config.serverURL;\n  return mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function () {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function () {\n  const data = Object.keys(this.data).reduce((data, key) => {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n};\n\n// Returns an updated copy of the object\nRestWrite.prototype.buildParseObjects = function () {\n  const extraData = { className: this.className, objectId: this.query?.objectId };\n  let originalObject;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  const className = Parse.Object.fromJSON(extraData);\n  const readOnlyAttributes = className.constructor.readOnlyAttributes\n    ? className.constructor.readOnlyAttributes()\n    : [];\n  if (!this.originalData) {\n    for (const attribute of readOnlyAttributes) {\n      extraData[attribute] = this.data[attribute];\n    }\n  }\n  const updatedObject = triggers.inflate(extraData, this.originalData);\n  Object.keys(this.data).reduce(function (data, key) {\n    if (key.indexOf('.') > 0) {\n      if (typeof data[key].__op === 'string') {\n        if (!readOnlyAttributes.includes(key)) {\n          updatedObject.set(key, data[key]);\n        }\n      } else {\n        // subdocument key with dot notation { 'x.y': v } => { 'x': { 'y' : v } })\n        const splittedKey = key.split('.');\n        const parentProp = splittedKey[0];\n        let parentVal = updatedObject.get(parentProp);\n        if (typeof parentVal !== 'object') {\n          parentVal = {};\n        }\n        parentVal[splittedKey[1]] = data[key];\n        updatedObject.set(parentProp, parentVal);\n      }\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n\n  const sanitized = this.sanitizedData();\n  for (const attribute of readOnlyAttributes) {\n    delete sanitized[attribute];\n  }\n  updatedObject.set(sanitized);\n  return { updatedObject, originalObject };\n};\n\nRestWrite.prototype.cleanUserAuthData = function () {\n  if (this.response && this.response.response && this.className === '_User') {\n    const user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach(provider => {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function (response, data) {\n  const stateController = Parse.CoreManager.getObjectStateController();\n  const [pending] = stateController.getPendingOps(this.pendingOps.identifier);\n  for (const key in this.pendingOps.operations) {\n    if (!pending[key]) {\n      data[key] = this.originalData ? this.originalData[key] : { __op: 'Delete' };\n      this.storage.fieldsChangedByTrigger.push(key);\n    }\n  }\n  const skipKeys = [...(requiredColumns.read[this.className] || [])];\n  if (!this.query) {\n    skipKeys.push('objectId', 'createdAt');\n  } else {\n    skipKeys.push('updatedAt');\n    delete response.objectId;\n  }\n  for (const key in response) {\n    if (skipKeys.includes(key)) {\n      continue;\n    }\n    const value = response[key];\n    if (\n      value == null ||\n      (value.__type && value.__type === 'Pointer') ||\n      util.isDeepStrictEqual(data[key], value) ||\n      util.isDeepStrictEqual((this.originalData || {})[key], value)\n    ) {\n      delete response[key];\n    }\n  }\n  if (_.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  const clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(fieldName => {\n    const dataValue = data[fieldName];\n\n    if (!Object.prototype.hasOwnProperty.call(response, fieldName)) {\n      response[fieldName] = dataValue;\n    }\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n};\n\nexport default RestWrite;\nmodule.exports = RestWrite;\n", "import express from 'express';\nimport BodyParser from 'body-parser';\nimport * as Middlewares from '../middlewares';\nimport Parse from 'parse/node';\nimport Config from '../Config';\nimport mime from 'mime';\nimport logger from '../logger';\nconst triggers = require('../triggers');\nconst http = require('http');\nconst Utils = require('../Utils');\n\nconst downloadFileFromURI = uri => {\n  return new Promise((res, rej) => {\n    http\n      .get(uri, response => {\n        response.setDefaultEncoding('base64');\n        let body = `data:${response.headers['content-type']};base64,`;\n        response.on('data', data => (body += data));\n        response.on('end', () => res(body));\n      })\n      .on('error', e => {\n        rej(`Error downloading file from ${uri}: ${e.message}`);\n      });\n  });\n};\n\nconst addFileDataIfNeeded = async file => {\n  if (file._source.format === 'uri') {\n    const base64 = await downloadFileFromURI(file._source.uri);\n    file._previousSave = file;\n    file._data = base64;\n    file._requestTask = null;\n  }\n  return file;\n};\n\nexport class FilesRouter {\n  expressRouter({ maxUploadSize = '20Mb' } = {}) {\n    var router = express.Router();\n    router.get('/files/:appId/:filename', this.getHandler);\n    router.get('/files/:appId/metadata/:filename', this.metadataHandler);\n\n    router.post('/files', function (req, res, next) {\n      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));\n    });\n\n    router.post(\n      '/files/:filename',\n      BodyParser.raw({\n        type: () => {\n          return true;\n        },\n        limit: maxUploadSize,\n      }), // Allow uploads without Content-Type, or with any Content-Type.\n      Middlewares.handleParseHeaders,\n      Middlewares.handleParseSession,\n      this.createHandler\n    );\n\n    router.delete(\n      '/files/:filename',\n      Middlewares.handleParseHeaders,\n      Middlewares.handleParseSession,\n      Middlewares.enforceMasterKeyAccess,\n      this.deleteHandler\n    );\n    return router;\n  }\n\n  getHandler(req, res) {\n    const config = Config.get(req.params.appId);\n    if (!config) {\n      res.status(403);\n      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');\n      res.json({ code: err.code, error: err.message });\n      return;\n    }\n    const filesController = config.filesController;\n    const filename = req.params.filename;\n    const contentType = mime.getType(filename);\n    if (isFileStreamable(req, filesController)) {\n      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {\n        res.status(404);\n        res.set('Content-Type', 'text/plain');\n        res.end('File not found.');\n      });\n    } else {\n      filesController\n        .getFileData(config, filename)\n        .then(data => {\n          res.status(200);\n          res.set('Content-Type', contentType);\n          res.set('Content-Length', data.length);\n          res.end(data);\n        })\n        .catch(() => {\n          res.status(404);\n          res.set('Content-Type', 'text/plain');\n          res.end('File not found.');\n        });\n    }\n  }\n\n  async createHandler(req, res, next) {\n    const config = req.config;\n    const user = req.auth.user;\n    const isMaster = req.auth.isMaster;\n    const isLinked = user && Parse.AnonymousUtils.isLinked(user);\n    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {\n      next(\n        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {\n      next(\n        new Parse.Error(\n          Parse.Error.FILE_SAVE_ERROR,\n          'File upload by authenticated user is disabled.'\n        )\n      );\n      return;\n    }\n    if (!isMaster && !config.fileUpload.enableForPublic && !user) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));\n      return;\n    }\n    const filesController = config.filesController;\n    const { filename } = req.params;\n    const contentType = req.get('Content-type');\n\n    if (!req.body || !req.body.length) {\n      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));\n      return;\n    }\n\n    const error = filesController.validateFilename(filename);\n    if (error) {\n      next(error);\n      return;\n    }\n\n    const fileExtensions = config.fileUpload?.fileExtensions;\n    if (!isMaster && fileExtensions) {\n      const isValidExtension = extension => {\n        return fileExtensions.some(ext => {\n          if (ext === '*') {\n            return true;\n          }\n          const regex = new RegExp(fileExtensions);\n          if (regex.test(extension)) {\n            return true;\n          }\n        });\n      };\n      let extension = contentType;\n      if (filename && filename.includes('.')) {\n        extension = filename.split('.')[1];\n      } else if (contentType && contentType.includes('/')) {\n        extension = contentType.split('/')[1];\n      }\n      extension = extension.split(' ').join('');\n\n      if (!isValidExtension(extension)) {\n        next(\n          new Parse.Error(\n            Parse.Error.FILE_SAVE_ERROR,\n            `File upload of extension ${extension} is disabled.`\n          )\n        );\n        return;\n      }\n    }\n\n    const base64 = req.body.toString('base64');\n    const file = new Parse.File(filename, { base64 }, contentType);\n    const { metadata = {}, tags = {} } = req.fileData || {};\n    try {\n      Utils.checkProhibitedKeywords(config, metadata);\n      Utils.checkProhibitedKeywords(config, tags);\n    } catch (error) {\n      next(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));\n      return;\n    }\n    file.setTags(tags);\n    file.setMetadata(metadata);\n    const fileSize = Buffer.byteLength(req.body);\n    const fileObject = { file, fileSize };\n    try {\n      // run beforeSaveFile trigger\n      const triggerResult = await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeSave,\n        fileObject,\n        config,\n        req.auth\n      );\n      let saveResult;\n      // if a new ParseFile is returned check if it's an already saved file\n      if (triggerResult instanceof Parse.File) {\n        fileObject.file = triggerResult;\n        if (triggerResult.url()) {\n          // set fileSize to null because we wont know how big it is here\n          fileObject.fileSize = null;\n          saveResult = {\n            url: triggerResult.url(),\n            name: triggerResult._name,\n          };\n        }\n      }\n      // if the file returned by the trigger has already been saved skip saving anything\n      if (!saveResult) {\n        // if the ParseFile returned is type uri, download the file before saving it\n        await addFileDataIfNeeded(fileObject.file);\n        // update fileSize\n        const bufferData = Buffer.from(fileObject.file._data, 'base64');\n        fileObject.fileSize = Buffer.byteLength(bufferData);\n        // prepare file options\n        const fileOptions = {\n          metadata: fileObject.file._metadata,\n        };\n        // some s3-compatible providers (DigitalOcean, Linode) do not accept tags\n        // so we do not include the tags option if it is empty.\n        const fileTags =\n          Object.keys(fileObject.file._tags).length > 0 ? { tags: fileObject.file._tags } : {};\n        Object.assign(fileOptions, fileTags);\n        // save file\n        const createFileResult = await filesController.createFile(\n          config,\n          fileObject.file._name,\n          bufferData,\n          fileObject.file._source.type,\n          fileOptions\n        );\n        // update file with new data\n        fileObject.file._name = createFileResult.name;\n        fileObject.file._url = createFileResult.url;\n        fileObject.file._requestTask = null;\n        fileObject.file._previousSave = Promise.resolve(fileObject.file);\n        saveResult = {\n          url: createFileResult.url,\n          name: createFileResult.name,\n        };\n      }\n      // run afterSaveFile trigger\n      await triggers.maybeRunFileTrigger(triggers.Types.afterSave, fileObject, config, req.auth);\n      res.status(201);\n      res.set('Location', saveResult.url);\n      res.json(saveResult);\n    } catch (e) {\n      logger.error('Error creating a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_SAVE_ERROR,\n        message: `Could not store file: ${fileObject.file._name}.`,\n      });\n      next(error);\n    }\n  }\n\n  async deleteHandler(req, res, next) {\n    try {\n      const { filesController } = req.config;\n      const { filename } = req.params;\n      // run beforeDeleteFile trigger\n      const file = new Parse.File(filename);\n      file._url = filesController.adapter.getFileLocation(req.config, filename);\n      const fileObject = { file, fileSize: null };\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.beforeDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      // delete file\n      await filesController.deleteFile(req.config, filename);\n      // run afterDeleteFile trigger\n      await triggers.maybeRunFileTrigger(\n        triggers.Types.afterDelete,\n        fileObject,\n        req.config,\n        req.auth\n      );\n      res.status(200);\n      // TODO: return useful JSON here?\n      res.end();\n    } catch (e) {\n      logger.error('Error deleting a file: ', e);\n      const error = triggers.resolveError(e, {\n        code: Parse.Error.FILE_DELETE_ERROR,\n        message: 'Could not delete file.',\n      });\n      next(error);\n    }\n  }\n\n  async metadataHandler(req, res) {\n    try {\n      const config = Config.get(req.params.appId);\n      const { filesController } = config;\n      const { filename } = req.params;\n      const data = await filesController.getMetadata(filename);\n      res.status(200);\n      res.json(data);\n    } catch (e) {\n      res.status(200);\n      res.json({});\n    }\n  }\n}\n\nfunction isFileStreamable(req, filesController) {\n  const range = (req.get('Range') || '/-/').split('-');\n  const start = Number(range[0]);\n  const end = Number(range[1]);\n  return (\n    (!isNaN(start) || !isNaN(end)) && typeof filesController.adapter.handleFileStream === 'function'\n  );\n}\n", "/**\n * utils.js\n * @file General purpose utilities\n * @description General purpose utilities.\n */\n\nconst path = require('path');\nconst fs = require('fs').promises;\n\n/**\n * The general purpose utilities.\n */\nclass Utils {\n  /**\n   * @function getLocalizedPath\n   * @description Returns a localized file path accoring to the locale.\n   *\n   * Localized files are searched in subfolders of a given path, e.g.\n   *\n   * root/\n   * \u251c\u2500\u2500 base/                    // base path to files\n   * \u2502   \u251c\u2500\u2500 example.html         // default file\n   * \u2502   \u2514\u2500\u2500 de/                  // de language folder\n   * \u2502   \u2502   \u2514\u2500\u2500 example.html     // de localized file\n   * \u2502   \u2514\u2500\u2500 de-AT/               // de-AT locale folder\n   * \u2502   \u2502   \u2514\u2500\u2500 example.html     // de-AT localized file\n   *\n   * Files are matched with the locale in the following order:\n   * 1. Locale match, e.g. locale `de-AT` matches file in folder `de-AT`.\n   * 2. Language match, e.g. locale `de-AT` matches file in folder `de`.\n   * 3. Default; file in base folder is returned.\n   *\n   * @param {String} defaultPath The absolute file path, which is also\n   * the default path returned if localization is not available.\n   * @param {String} locale The locale.\n   * @returns {Promise<Object>} The object contains:\n   * - `path`: The path to the localized file, or the original path if\n   *   localization is not available.\n   * - `subdir`: The subdirectory of the localized file, or undefined if\n   *   there is no matching localized file.\n   */\n  static async getLocalizedPath(defaultPath, locale) {\n    // Get file name and paths\n    const file = path.basename(defaultPath);\n    const basePath = path.dirname(defaultPath);\n\n    // If locale is not set return default file\n    if (!locale) {\n      return { path: defaultPath };\n    }\n\n    // Check file for locale exists\n    const localePath = path.join(basePath, locale, file);\n    const localeFileExists = await Utils.fileExists(localePath);\n\n    // If file for locale exists return file\n    if (localeFileExists) {\n      return { path: localePath, subdir: locale };\n    }\n\n    // Check file for language exists\n    const language = locale.split('-')[0];\n    const languagePath = path.join(basePath, language, file);\n    const languageFileExists = await Utils.fileExists(languagePath);\n\n    // If file for language exists return file\n    if (languageFileExists) {\n      return { path: languagePath, subdir: language };\n    }\n\n    // Return default file\n    return { path: defaultPath };\n  }\n\n  /**\n   * @function fileExists\n   * @description Checks whether a file exists.\n   * @param {String} path The file path.\n   * @returns {Promise<Boolean>} Is true if the file can be accessed, false otherwise.\n   */\n  static async fileExists(path) {\n    try {\n      await fs.access(path);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * @function isPath\n   * @description Evaluates whether a string is a file path (as opposed to a URL for example).\n   * @param {String} s The string to evaluate.\n   * @returns {Boolean} Returns true if the evaluated string is a path.\n   */\n  static isPath(s) {\n    return /(^\\/)|(^\\.\\/)|(^\\.\\.\\/)/.test(s);\n  }\n\n  /**\n   * Flattens an object and crates new keys with custom delimiters.\n   * @param {Object} obj The object to flatten.\n   * @param {String} [delimiter='.'] The delimiter of the newly generated keys.\n   * @param {Object} result\n   * @returns {Object} The flattened object.\n   **/\n  static flattenObject(obj, parentKey, delimiter = '.', result = {}) {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const newKey = parentKey ? parentKey + delimiter + key : key;\n\n        if (typeof obj[key] === 'object' && obj[key] !== null) {\n          this.flattenObject(obj[key], newKey, delimiter, result);\n        } else {\n          result[newKey] = obj[key];\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Determines whether an object is a Promise.\n   * @param {any} object The object to validate.\n   * @returns {Boolean} Returns true if the object is a promise.\n   */\n  static isPromise(object) {\n    return object instanceof Promise;\n  }\n\n  /**\n   * Creates an object with all permutations of the original keys.\n   * For example, this definition:\n   * ```\n   * {\n   *   a: [true, false],\n   *   b: [1, 2],\n   *   c: ['x']\n   * }\n   * ```\n   * permutates to:\n   * ```\n   * [\n   *   { a: true, b: 1, c: 'x' },\n   *   { a: true, b: 2, c: 'x' },\n   *   { a: false, b: 1, c: 'x' },\n   *   { a: false, b: 2, c: 'x' }\n   * ]\n   * ```\n   * @param {Object} object The object to permutate.\n   * @param {Integer} [index=0] The current key index.\n   * @param {Object} [current={}] The current result entry being composed.\n   * @param {Array} [results=[]] The resulting array of permutations.\n   */\n  static getObjectKeyPermutations(object, index = 0, current = {}, results = []) {\n    const keys = Object.keys(object);\n    const key = keys[index];\n    const values = object[key];\n\n    for (const value of values) {\n      current[key] = value;\n      const nextIndex = index + 1;\n\n      if (nextIndex < keys.length) {\n        Utils.getObjectKeyPermutations(object, nextIndex, current, results);\n      } else {\n        const result = Object.assign({}, current);\n        results.push(result);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Validates parameters and throws if a parameter is invalid.\n   * Example parameter types syntax:\n   * ```\n   * {\n   *   parameterName: {\n   *      t: 'boolean',\n   *      v: isBoolean,\n   *      o: true\n   *   },\n   *   ...\n   * }\n   * ```\n   * @param {Object} params The parameters to validate.\n   * @param {Array<Object>} types The parameter types used for validation.\n   * @param {Object} types.t The parameter type; used for error message, not for validation.\n   * @param {Object} types.v The function to validate the parameter value.\n   * @param {Boolean} [types.o=false] Is true if the parameter is optional.\n   */\n  static validateParams(params, types) {\n    for (const key of Object.keys(params)) {\n      const type = types[key];\n      const isOptional = !!type.o;\n      const param = params[key];\n      if (!(isOptional && param == null) && !type.v(param)) {\n        throw `Invalid parameter ${key} must be of type ${type.t} but is ${typeof param}`;\n      }\n    }\n  }\n\n  /**\n   * Computes the relative date based on a string.\n   * @param {String} text The string to interpret the date from.\n   * @param {Date} now The date the string is comparing against.\n   * @returns {Object} The relative date object.\n   **/\n  static relativeTimeToDate(text, now = new Date()) {\n    text = text.toLowerCase();\n    let parts = text.split(' ');\n\n    // Filter out whitespace\n    parts = parts.filter(part => part !== '');\n\n    const future = parts[0] === 'in';\n    const past = parts[parts.length - 1] === 'ago';\n\n    if (!future && !past && text !== 'now') {\n      return {\n        status: 'error',\n        info: \"Time should either start with 'in' or end with 'ago'\",\n      };\n    }\n\n    if (future && past) {\n      return {\n        status: 'error',\n        info: \"Time cannot have both 'in' and 'ago'\",\n      };\n    }\n\n    // strip the 'ago' or 'in'\n    if (future) {\n      parts = parts.slice(1);\n    } else {\n      // past\n      parts = parts.slice(0, parts.length - 1);\n    }\n\n    if (parts.length % 2 !== 0 && text !== 'now') {\n      return {\n        status: 'error',\n        info: 'Invalid time string. Dangling unit or number.',\n      };\n    }\n\n    const pairs = [];\n    while (parts.length) {\n      pairs.push([parts.shift(), parts.shift()]);\n    }\n\n    let seconds = 0;\n    for (const [num, interval] of pairs) {\n      const val = Number(num);\n      if (!Number.isInteger(val)) {\n        return {\n          status: 'error',\n          info: `'${num}' is not an integer.`,\n        };\n      }\n\n      switch (interval) {\n        case 'yr':\n        case 'yrs':\n        case 'year':\n        case 'years':\n          seconds += val * 31536000; // 365 * 24 * 60 * 60\n          break;\n\n        case 'wk':\n        case 'wks':\n        case 'week':\n        case 'weeks':\n          seconds += val * 604800; // 7 * 24 * 60 * 60\n          break;\n\n        case 'd':\n        case 'day':\n        case 'days':\n          seconds += val * 86400; // 24 * 60 * 60\n          break;\n\n        case 'hr':\n        case 'hrs':\n        case 'hour':\n        case 'hours':\n          seconds += val * 3600; // 60 * 60\n          break;\n\n        case 'min':\n        case 'mins':\n        case 'minute':\n        case 'minutes':\n          seconds += val * 60;\n          break;\n\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n          seconds += val;\n          break;\n\n        default:\n          return {\n            status: 'error',\n            info: `Invalid interval: '${interval}'`,\n          };\n      }\n    }\n\n    const milliseconds = seconds * 1000;\n    if (future) {\n      return {\n        status: 'success',\n        info: 'future',\n        result: new Date(now.valueOf() + milliseconds),\n      };\n    } else if (past) {\n      return {\n        status: 'success',\n        info: 'past',\n        result: new Date(now.valueOf() - milliseconds),\n      };\n    } else {\n      return {\n        status: 'success',\n        info: 'present',\n        result: new Date(now.valueOf()),\n      };\n    }\n  }\n\n  /**\n   * Deep-scans an object for a matching key/value definition.\n   * @param {Object} obj The object to scan.\n   * @param {String | undefined} key The key to match, or undefined if only the value should be matched.\n   * @param {any | undefined} value The value to match, or undefined if only the key should be matched.\n   * @returns {Boolean} True if a match was found, false otherwise.\n   */\n  static objectContainsKeyValue(obj, key, value) {\n    const isMatch = (a, b) => (typeof a === 'string' && new RegExp(b).test(a)) || a === b;\n    const isKeyMatch = k => isMatch(k, key);\n    const isValueMatch = v => isMatch(v, value);\n    for (const [k, v] of Object.entries(obj)) {\n      if (key !== undefined && value === undefined && isKeyMatch(k)) {\n        return true;\n      } else if (key === undefined && value !== undefined && isValueMatch(v)) {\n        return true;\n      } else if (key !== undefined && value !== undefined && isKeyMatch(k) && isValueMatch(v)) {\n        return true;\n      }\n      if (['[object Object]', '[object Array]'].includes(Object.prototype.toString.call(v))) {\n        return Utils.objectContainsKeyValue(v, key, value);\n      }\n    }\n    return false;\n  }\n\n  static checkProhibitedKeywords(config, data) {\n    if (config?.requestKeywordDenylist) {\n      // Scan request data for denied keywords\n      for (const keyword of config.requestKeywordDenylist) {\n        const match = Utils.objectContainsKeyValue(data, keyword.key, keyword.value);\n        if (match) {\n          throw `Prohibited keyword in request data: ${JSON.stringify(keyword)}.`;\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = Utils;\n"], "filenames": [".eslintrc.json", "spec/vulnerabilities.spec.js", "src/Controllers/DatabaseController.js", "src/RestWrite.js", "src/Routers/FilesRouter.js", "src/Utils.js"], "buggy_code_start_loc": [27, 136, 477, 66, 178, 360], "buggy_code_end_loc": [27, 136, 807, 1774, 194, 360], "fixing_code_start_loc": [28, 137, 478, 65, 178, 361], "fixing_code_end_loc": [31, 202, 818, 1760, 184, 373], "type": "CWE-1321", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to versions 5.5.2 and 6.2.1, an attacker can use a prototype pollution sink to trigger a remote code execution through the MongoDB BSON parser. A patch is available in versions 5.5.2 and 6.2.1.", "other": {"cve": {"id": "CVE-2023-36475", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-28T23:15:21.140", "lastModified": "2023-07-06T17:09:13.360", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. Prior to versions 5.5.2 and 6.2.1, an attacker can use a prototype pollution sink to trigger a remote code execution through the MongoDB BSON parser. A patch is available in versions 5.5.2 and 6.2.1."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede desplegarse en cualquier infraestructura que pueda ejecutar Node.js. Antes de las versiones 5.5.2 y 6.2.1, un atacante puede utilizar un prototipo de \"pollution sink\" para desencadenar una ejecuci\u00f3n remota de c\u00f3digo a trav\u00e9s del analizador BSON de MongoDB. Hay un parche disponible en las versiones 5.5.2 y 6.2.1. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.5.2", "matchCriteriaId": "8059544D-58C9-4AA3-8ABF-C29439C1EF8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2.1", "matchCriteriaId": "505FD02D-F6D9-4B39-B963-03604E91D129"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/3dd99dd80e27e5e1d99b42844180546d90c7aa90", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/parse-community/parse-server/commit/5fad2928fb8ee17304abcdcf259932f827d8c81f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/parse-community/parse-server/issues/8674", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/parse-community/parse-server/issues/8675", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/5.5.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/6.2.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-462x-c3jw-7vr6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/3dd99dd80e27e5e1d99b42844180546d90c7aa90"}}