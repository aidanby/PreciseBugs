{"buggy_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#pragma ident\t\"%Z%%M%\t%I%\t%E% SMI\"\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/errno.h>\n#include <sys/cmn_err.h>\n#include <sys/cred.h>\n#include <sys/stat.h>\n#include <sys/debug.h>\n#include <sys/policy.h>\n#include <sys/fs/tmpnode.h>\n#include <sys/fs/tmp.h>\n#include <sys/vtrace.h>\n\nstatic int tdircheckpath(struct tmpnode *, struct tmpnode *, struct cred *);\nstatic int tdirrename(struct tmpnode *, struct tmpnode *, struct tmpnode *,\n\tchar *, struct tmpnode *, struct tdirent *, struct cred *);\nstatic void tdirfixdotdot(struct tmpnode *, struct tmpnode *, struct tmpnode *);\nstatic int tdirmaketnode(struct tmpnode *, struct tmount *, struct vattr *,\n\tenum de_op, struct tmpnode **, struct cred *);\nstatic int tdiraddentry(struct tmpnode *, struct tmpnode *, char *,\n\tenum de_op, struct tmpnode *);\n\n\n#define\tT_HASH_SIZE\t8192\t\t/* must be power of 2 */\n#define\tT_MUTEX_SIZE\t64\n\nstatic struct tdirent\t*t_hashtable[T_HASH_SIZE];\nstatic kmutex_t\t\t t_hashmutex[T_MUTEX_SIZE];\n\n#define\tT_HASH_INDEX(a)\t\t((a) & (T_HASH_SIZE-1))\n#define\tT_MUTEX_INDEX(a)\t((a) & (T_MUTEX_SIZE-1))\n\n#define\tTMPFS_HASH(tp, name, hash)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tchar Xc, *Xcp;\t\t\t\t\t\\\n\t\thash = (uint_t)(uintptr_t)(tp) >> 8;\t\t\\\n\t\tfor (Xcp = (name); (Xc = *Xcp) != 0; Xcp++)\t\\\n\t\t\thash = (hash << 4) + hash + (uint_t)Xc;\t\\\n\t}\n\nvoid\ntmpfs_hash_init(void)\n{\n\tint\tix;\n\n\tfor (ix = 0; ix < T_MUTEX_SIZE; ix++)\n\t\tmutex_init(&t_hashmutex[ix], NULL, MUTEX_DEFAULT, NULL);\n}\n\n/*\n * This routine is where the rubber meets the road for identities.\n */\nstatic void\ntmpfs_hash_in(struct tdirent *t)\n{\n\tuint_t\t\thash;\n\tstruct tdirent\t**prevpp;\n\tkmutex_t\t*t_hmtx;\n\n\tTMPFS_HASH(t->td_parent, t->td_name, hash);\n\tt->td_hash = hash;\n\tprevpp = &t_hashtable[T_HASH_INDEX(hash)];\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\tt->td_link = *prevpp;\n\t*prevpp = t;\n\tmutex_exit(t_hmtx);\n}\n\n/*\n * Remove tdirent *t from the hash list.\n */\nstatic void\ntmpfs_hash_out(struct tdirent *t)\n{\n\tuint_t\t\thash;\n\tstruct tdirent\t**prevpp;\n\tkmutex_t\t*t_hmtx;\n\n\thash = t->td_hash;\n\tprevpp = &t_hashtable[T_HASH_INDEX(hash)];\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\twhile (*prevpp != t)\n\t\tprevpp = &(*prevpp)->td_link;\n\t*prevpp = t->td_link;\n\tmutex_exit(t_hmtx);\n}\n\n/*\n * Currently called by tdirrename() only.\n * rename operation needs to be done with lock held, to ensure that\n * no other operations can access the tmpnode at the same instance.\n */\nstatic void\ntmpfs_hash_change(struct tdirent *tdp, struct tmpnode *fromtp)\n{\n\tuint_t\t\thash;\n\tkmutex_t\t*t_hmtx;\n\n\thash = tdp->td_hash;\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\ttdp->td_tmpnode = fromtp;\n\tmutex_exit(t_hmtx);\n}\n\nstatic struct tdirent *\ntmpfs_hash_lookup(char *name, struct tmpnode *parent, uint_t hold,\n\tstruct tmpnode **found)\n{\n\tstruct tdirent\t*l;\n\tuint_t\t\thash;\n\tkmutex_t\t*t_hmtx;\n\tstruct tmpnode\t*tnp;\n\n\tTMPFS_HASH(parent, name, hash);\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\tl = t_hashtable[T_HASH_INDEX(hash)];\n\twhile (l) {\n\t\tif ((l->td_hash == hash) &&\n\t\t    (l->td_parent == parent) &&\n\t\t    (strcmp(l->td_name, name) == 0)) {\n\t\t\t/*\n\t\t\t * We need to make sure that the tmpnode that\n\t\t\t * we put a hold on is the same one that we pass back.\n\t\t\t * Hence, temporary variable tnp is necessary.\n\t\t\t */\n\t\t\ttnp = l->td_tmpnode;\n\t\t\tif (hold) {\n\t\t\t\tASSERT(tnp);\n\t\t\t\ttmpnode_hold(tnp);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\t*found = tnp;\n\t\t\tmutex_exit(t_hmtx);\n\t\t\treturn (l);\n\t\t} else {\n\t\t\tl = l->td_link;\n\t\t}\n\t}\n\tmutex_exit(t_hmtx);\n\treturn (NULL);\n}\n\n/*\n * Search directory 'parent' for entry 'name'.\n *\n * The calling thread can't hold the write version\n * of the rwlock for the directory being searched\n *\n * 0 is returned on success and *foundtp points\n * to the found tmpnode with its vnode held.\n */\nint\ntdirlookup(\n\tstruct tmpnode *parent,\n\tchar *name,\n\tstruct tmpnode **foundtp,\n\tstruct cred *cred)\n{\n\tint error;\n\n\t*foundtp = NULL;\n\tif (parent->tn_type != VDIR)\n\t\treturn (ENOTDIR);\n\n\tif ((error = tmp_taccess(parent, VEXEC, cred)))\n\t\treturn (error);\n\n\tif (*name == '\\0') {\n\t\ttmpnode_hold(parent);\n\t\t*foundtp = parent;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Search the directory for the matching name\n\t * We need the lock protecting the tn_dir list\n\t * so that it doesn't change out from underneath us.\n\t * tmpfs_hash_lookup() will pass back the tmpnode\n\t * with a hold on it.\n\t */\n\n\tif (tmpfs_hash_lookup(name, parent, 1, foundtp) != NULL) {\n\t\tASSERT(*foundtp);\n\t\treturn (0);\n\t}\n\n\treturn (ENOENT);\n}\n\n/*\n * Enter a directory entry for 'name' and 'tp' into directory 'dir'\n *\n * Returns 0 on success.\n */\nint\ntdirenter(\n\tstruct tmount\t*tm,\n\tstruct tmpnode\t*dir,\t\t/* target directory to make entry in */\n\tchar\t\t*name,\t\t/* name of entry */\n\tenum de_op\top,\t\t/* entry operation */\n\tstruct tmpnode\t*fromparent,\t/* source directory if rename */\n\tstruct tmpnode\t*tp,\t\t/* source tmpnode, if link/rename */\n\tstruct vattr\t*va,\n\tstruct tmpnode\t**tpp,\t\t/* return tmpnode, if create/mkdir */\n\tstruct cred\t*cred,\n\tcaller_context_t *ctp)\n{\n\tstruct tdirent *tdp;\n\tstruct tmpnode *found = NULL;\n\tint error = 0;\n\tchar *s;\n\n\t/*\n\t * tn_rwlock is held to serialize direnter and dirdeletes\n\t */\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\t/*\n\t * Don't allow '/' characters in pathname component\n\t * (thus in ufs_direnter()).\n\t */\n\tfor (s = name; *s; s++)\n\t\tif (*s == '/')\n\t\t\treturn (EACCES);\n\n\tif (name[0] == '\\0')\n\t\tpanic(\"tdirenter: NULL name\");\n\n\t/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t */\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir)\n\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\tif (tp->tn_nlink == MAXLINK) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (EMLINK);\n\t\t}\n\t\ttp->tn_nlink++;\n\t\tgethrestime(&tp->tn_ctime);\n\t\tmutex_exit(&tp->tn_tlock);\n\t\tif (tp != dir)\n\t\t\trw_exit(&tp->tn_rwlock);\n\t}\n\n\t/*\n\t * This might be a \"dangling detached directory\".\n\t * it could have been removed, but a reference\n\t * to it kept in u_cwd.  don't bother searching\n\t * it, and with any luck the user will get tired\n\t * of dealing with us and cd to some absolute\n\t * pathway.  *sigh*, thus in ufs, too.\n\t */\n\tif (dir->tn_nlink == 0) {\n\t\terror = ENOENT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this is a rename of a directory and the parent is\n\t * different (\"..\" must be changed), then the source\n\t * directory must not be in the directory hierarchy\n\t * above the target, as this would orphan everything\n\t * below the source directory.\n\t */\n\tif (op == DE_RENAME) {\n\t\tif (tp == dir) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (tp->tn_type == VDIR) {\n\t\t\tif ((fromparent != dir) &&\n\t\t\t    (error = tdircheckpath(tp, dir, cred))) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Search for the entry.  Return \"found\" if it exists.\n\t */\n\ttdp = tmpfs_hash_lookup(name, dir, 1, &found);\n\n\tif (tdp) {\n\t\tASSERT(found);\n\t\tswitch (op) {\n\t\tcase DE_CREATE:\n\t\tcase DE_MKDIR:\n\t\t\tif (tpp) {\n\t\t\t\t*tpp = found;\n\t\t\t\terror = EEXIST;\n\t\t\t} else {\n\t\t\t\ttmpnode_rele(found);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DE_RENAME:\n\t\t\terror = tdirrename(fromparent, tp,\n\t\t\t    dir, name, found, tdp, cred);\n\t\t\tif (error == 0) {\n\t\t\t\tif (found != NULL) {\n\t\t\t\t\tvnevent_rename_dest(TNTOV(found),\n\t\t\t\t\t    TNTOV(dir), name, ctp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpnode_rele(found);\n\t\t\tbreak;\n\n\t\tcase DE_LINK:\n\t\t\t/*\n\t\t\t * Can't link to an existing file.\n\t\t\t */\n\t\t\terror = EEXIST;\n\t\t\ttmpnode_rele(found);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*\n\t\t * The entry does not exist. Check write permission in\n\t\t * directory to see if entry can be created.\n\t\t */\n\t\tif (error = tmp_taccess(dir, VWRITE, cred))\n\t\t\tgoto out;\n\t\tif (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\t/*\n\t\t\t * Make new tmpnode and directory entry as required.\n\t\t\t */\n\t\t\terror = tdirmaketnode(dir, tm, va, op, &tp, cred);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (error = tdiraddentry(dir, tp, name, op, fromparent)) {\n\t\t\tif (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\t\t/*\n\t\t\t\t * Unmake the inode we just made.\n\t\t\t\t */\n\t\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);\n\t\t\t\tif ((tp->tn_type) == VDIR) {\n\t\t\t\t\tASSERT(tdp == NULL);\n\t\t\t\t\t/*\n\t\t\t\t\t * cleanup allocs made by tdirinit()\n\t\t\t\t\t */\n\t\t\t\t\ttdirtrunc(tp);\n\t\t\t\t}\n\t\t\t\tmutex_enter(&tp->tn_tlock);\n\t\t\t\ttp->tn_nlink = 0;\n\t\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\t\tgethrestime(&tp->tn_ctime);\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\t\ttmpnode_rele(tp);\n\t\t\t\ttp = NULL;\n\t\t\t}\n\t\t} else if (tpp) {\n\t\t\t*tpp = tp;\n\t\t} else if (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\ttmpnode_rele(tp);\n\t\t}\n\t}\n\nout:\n\tif (error && (op == DE_LINK || op == DE_RENAME)) {\n\t\t/*\n\t\t * Undo bumped link count.\n\t\t */\n\t\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\t\tgethrestime(&tp->tn_ctime);\n\t}\n\treturn (error);\n}\n\n/*\n * Delete entry tp of name \"nm\" from dir.\n * Free dir entry space and decrement link count on tmpnode(s).\n *\n * Return 0 on success.\n */\nint\ntdirdelete(\n\tstruct tmpnode *dir,\n\tstruct tmpnode *tp,\n\tchar *nm,\n\tenum dr_op op,\n\tstruct cred *cred)\n{\n\tstruct tdirent *tpdp;\n\tint error;\n\tsize_t namelen;\n\tstruct tmpnode *tnp;\n\ttimestruc_t now;\n\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(RW_WRITE_HELD(&tp->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tif (nm[0] == '\\0')\n\t\tpanic(\"tdirdelete: NULL name for %p\", (void *)tp);\n\n\t/*\n\t * return error when removing . and ..\n\t */\n\tif (nm[0] == '.') {\n\t\tif (nm[1] == '\\0')\n\t\t\treturn (EINVAL);\n\t\tif (nm[1] == '.' && nm[2] == '\\0')\n\t\t\treturn (EEXIST); /* thus in ufs */\n\t}\n\n\tif (error = tmp_taccess(dir, VEXEC|VWRITE, cred))\n\t\treturn (error);\n\n\t/*\n\t * If the parent directory is \"sticky\", then the user must\n\t * own the parent directory or the file in it, or else must\n\t * have permission to write the file.  Otherwise it may not\n\t * be deleted (except by privileged users).\n\t * Same as ufs_dirremove.\n\t */\n\tif ((error = tmp_sticky_remove_access(dir, tp, cred)) != 0)\n\t\treturn (error);\n\n\tif (dir->tn_dir == NULL)\n\t\treturn (ENOENT);\n\n\ttpdp = tmpfs_hash_lookup(nm, dir, 0, &tnp);\n\tif (tpdp == NULL) {\n\t\t/*\n\t\t * If it is gone, some other thread got here first!\n\t\t * Return error ENOENT.\n\t\t */\n\t\treturn (ENOENT);\n\t}\n\n\t/*\n\t * If the tmpnode in the tdirent changed, we were probably\n\t * the victim of a concurrent rename operation.  The original\n\t * is gone, so return that status (same as UFS).\n\t */\n\tif (tp != tnp)\n\t\treturn (ENOENT);\n\n\ttmpfs_hash_out(tpdp);\n\n\t/*\n\t * Take tpdp out of the directory list.\n\t */\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\tif (tpdp->td_prev) {\n\t\ttpdp->td_prev->td_next = tpdp->td_next;\n\t}\n\tif (tpdp->td_next) {\n\t\ttpdp->td_next->td_prev = tpdp->td_prev;\n\t}\n\n\t/*\n\t * If the roving slot pointer happens to match tpdp,\n\t * point it at the previous dirent.\n\t */\n\tif (dir->tn_dir->td_prev == tpdp) {\n\t\tdir->tn_dir->td_prev = tpdp->td_prev;\n\t}\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\t/*\n\t * tpdp points to the correct directory entry\n\t */\n\tnamelen = strlen(tpdp->td_name) + 1;\n\n\ttmp_memfree(tpdp, sizeof (struct tdirent) + namelen);\n\tdir->tn_size -= (sizeof (struct tdirent) + namelen);\n\tdir->tn_dirents--;\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\ttp->tn_ctime = now;\n\n\tASSERT(tp->tn_nlink > 0);\n\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\tif (op == DR_RMDIR && tp->tn_type == VDIR) {\n\t\ttdirtrunc(tp);\n\t\tASSERT(tp->tn_nlink == 0);\n\t}\n\treturn (0);\n}\n\n/*\n * tdirinit is used internally to initialize a directory (dir)\n * with '.' and '..' entries without checking permissions and locking\n */\nvoid\ntdirinit(\n\tstruct tmpnode *parent,\t\t/* parent of directory to initialize */\n\tstruct tmpnode *dir)\t\t/* the new directory */\n{\n\tstruct tdirent *dot, *dotdot;\n\ttimestruc_t now;\n\n\tASSERT(RW_WRITE_HELD(&parent->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tdot = tmp_memalloc(sizeof (struct tdirent) + 2, TMP_MUSTHAVE);\n\tdotdot = tmp_memalloc(sizeof (struct tdirent) + 3, TMP_MUSTHAVE);\n\n\t/*\n\t * Initialize the entries\n\t */\n\tdot->td_tmpnode = dir;\n\tdot->td_offset = 0;\n\tdot->td_name = (char *)dot + sizeof (struct tdirent);\n\tdot->td_name[0] = '.';\n\tdot->td_parent = dir;\n\ttmpfs_hash_in(dot);\n\n\tdotdot->td_tmpnode = parent;\n\tdotdot->td_offset = 1;\n\tdotdot->td_name = (char *)dotdot + sizeof (struct tdirent);\n\tdotdot->td_name[0] = '.';\n\tdotdot->td_name[1] = '.';\n\tdotdot->td_parent = dir;\n\ttmpfs_hash_in(dotdot);\n\n\t/*\n\t * Initialize directory entry list.\n\t */\n\tdot->td_next = dotdot;\n\tdot->td_prev = dotdot;\t/* dot's td_prev holds roving slot pointer */\n\tdotdot->td_next = NULL;\n\tdotdot->td_prev = dot;\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\t/*\n\t * Link counts are special for the hidden attribute directory.\n\t * The only explicit reference in the name space is \".\" and\n\t * the reference through \"..\" is not counted on the parent\n\t * file. The attrdir is created as a side effect to lookup,\n\t * so don't change the ctime of the parent.\n\t * Since tdirinit is called with both dir and parent being the\n\t * same for the root vnode, we need to increment this before we set\n\t * tn_nlink = 2 below.\n\t */\n\tif (!(dir->tn_vnode->v_flag & V_XATTRDIR)) {\n\t\tINCR_COUNT(&parent->tn_nlink, &parent->tn_tlock);\n\t\tparent->tn_ctime = now;\n\t}\n\n\tdir->tn_dir = dot;\n\tdir->tn_size = 2 * sizeof (struct tdirent) + 5;\t/* dot and dotdot */\n\tdir->tn_dirents = 2;\n\tdir->tn_nlink = 2;\n}\n\n\n/*\n * tdirtrunc is called to remove all directory entries under this directory.\n */\nvoid\ntdirtrunc(struct tmpnode *dir)\n{\n\tstruct tdirent *tdp;\n\tstruct tmpnode *tp;\n\tsize_t namelen;\n\ttimestruc_t now;\n\tint isvattrdir, isdotdot, skip_decr;\n\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tisvattrdir = (dir->tn_vnode->v_flag & V_XATTRDIR) ? 1 : 0;\n\tfor (tdp = dir->tn_dir; tdp; tdp = dir->tn_dir) {\n\t\tASSERT(tdp->td_next != tdp);\n\t\tASSERT(tdp->td_prev != tdp);\n\t\tASSERT(tdp->td_tmpnode);\n\n\t\tdir->tn_dir = tdp->td_next;\n\t\tnamelen = strlen(tdp->td_name) + 1;\n\n\t\t/*\n\t\t * Adjust the link counts to account for this directory\n\t\t * entry removal. Hidden attribute directories may\n\t\t * not be empty as they may be truncated as a side-\n\t\t * effect of removing the parent. We do hold/rele\n\t\t * operations to free up these tmpnodes.\n\t\t *\n\t\t * Skip the link count adjustment for parents of\n\t\t * attribute directories as those link counts\n\t\t * do not include the \"..\" reference in the hidden\n\t\t * directories.\n\t\t */\n\t\ttp = tdp->td_tmpnode;\n\t\tisdotdot = (strcmp(\"..\", tdp->td_name) == 0);\n\t\tskip_decr = (isvattrdir && isdotdot);\n\t\tif (!skip_decr) {\n\t\t\tASSERT(tp->tn_nlink > 0);\n\t\t\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\t\t}\n\n\t\ttmpfs_hash_out(tdp);\n\n\t\ttmp_memfree(tdp, sizeof (struct tdirent) + namelen);\n\t\tdir->tn_size -= (sizeof (struct tdirent) + namelen);\n\t\tdir->tn_dirents--;\n\t}\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\tASSERT(dir->tn_dir == NULL);\n\tASSERT(dir->tn_size == 0);\n\tASSERT(dir->tn_dirents == 0);\n}\n\n/*\n * Check if the source directory is in the path of the target directory.\n * The target directory is locked by the caller.\n *\n * XXX - The source and target's should be different upon entry.\n */\nstatic int\ntdircheckpath(\n\tstruct tmpnode *fromtp,\n\tstruct tmpnode\t*toparent,\n\tstruct cred\t*cred)\n{\n\tint\terror = 0;\n\tstruct tmpnode *dir, *dotdot;\n\tstruct tdirent *tdp;\n\n\tASSERT(RW_WRITE_HELD(&toparent->tn_rwlock));\n\n\ttdp = tmpfs_hash_lookup(\"..\", toparent, 1, &dotdot);\n\tif (tdp == NULL)\n\t\treturn (ENOENT);\n\n\tASSERT(dotdot);\n\n\tif (dotdot == toparent) {\n\t\t/* root of fs.  search trivially satisfied. */\n\t\ttmpnode_rele(dotdot);\n\t\treturn (0);\n\t}\n\tfor (;;) {\n\t\t/*\n\t\t * Return error for cases like \"mv c c/d\",\n\t\t * \"mv c c/d/e\" and so on.\n\t\t */\n\t\tif (dotdot == fromtp) {\n\t\t\ttmpnode_rele(dotdot);\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdir = dotdot;\n\t\terror = tdirlookup(dir, \"..\", &dotdot, cred);\n\t\tif (error) {\n\t\t\ttmpnode_rele(dir);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We're okay if we traverse the directory tree up to\n\t\t * the root directory and don't run into the\n\t\t * parent directory.\n\t\t */\n\t\tif (dir == dotdot) {\n\t\t\ttmpnode_rele(dir);\n\t\t\ttmpnode_rele(dotdot);\n\t\t\tbreak;\n\t\t}\n\t\ttmpnode_rele(dir);\n\t}\n\treturn (error);\n}\n\nstatic int\ntdirrename(\n\tstruct tmpnode *fromparent,\t/* parent directory of source */\n\tstruct tmpnode *fromtp,\t\t/* source tmpnode */\n\tstruct tmpnode *toparent,\t/* parent directory of target */\n\tchar *nm,\t\t\t/* entry we are trying to change */\n\tstruct tmpnode *to,\t\t/* target tmpnode */\n\tstruct tdirent *where,\t\t/* target tmpnode directory entry */\n\tstruct cred *cred)\t\t/* credentials */\n{\n\tint error = 0;\n\tint doingdirectory;\n\ttimestruc_t now;\n\n#if defined(lint)\n\tnm = nm;\n#endif\n\tASSERT(RW_WRITE_HELD(&toparent->tn_rwlock));\n\n\t/*\n\t * Short circuit rename of something to itself.\n\t */\n\tif (fromtp == to)\n\t\treturn (ESAME);\t\t/* special KLUDGE error code */\n\n\trw_enter(&fromtp->tn_rwlock, RW_READER);\n\trw_enter(&to->tn_rwlock, RW_READER);\n\n\t/*\n\t * Check that everything is on the same filesystem.\n\t */\n\tif (to->tn_vnode->v_vfsp != toparent->tn_vnode->v_vfsp ||\n\t    to->tn_vnode->v_vfsp != fromtp->tn_vnode->v_vfsp) {\n\t\terror = EXDEV;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Must have write permission to rewrite target entry.\n\t * Check for stickyness.\n\t */\n\tif ((error = tmp_taccess(toparent, VWRITE, cred)) != 0 ||\n\t    (error = tmp_sticky_remove_access(toparent, to, cred)) != 0)\n\t\tgoto out;\n\n\t/*\n\t * Ensure source and target are compatible (both directories\n\t * or both not directories).  If target is a directory it must\n\t * be empty and have no links to it; in addition it must not\n\t * be a mount point, and both the source and target must be\n\t * writable.\n\t */\n\tdoingdirectory = (fromtp->tn_type == VDIR);\n\tif (to->tn_type == VDIR) {\n\t\tif (!doingdirectory) {\n\t\t\terror = EISDIR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * vn_vfswlock will prevent mounts from using the directory\n\t\t * until we are done.\n\t\t */\n\t\tif (vn_vfswlock(TNTOV(to))) {\n\t\t\terror = EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vn_mountedvfs(TNTOV(to)) != NULL) {\n\t\t\tvn_vfsunlock(TNTOV(to));\n\t\t\terror = EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_enter(&to->tn_tlock);\n\t\tif (to->tn_dirents > 2 || to->tn_nlink > 2) {\n\t\t\tmutex_exit(&to->tn_tlock);\n\t\t\tvn_vfsunlock(TNTOV(to));\n\t\t\terror = EEXIST; /* SIGH should be ENOTEMPTY */\n\t\t\t/*\n\t\t\t * Update atime because checking tn_dirents is\n\t\t\t * logically equivalent to reading the directory\n\t\t\t */\n\t\t\tgethrestime(&to->tn_atime);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_exit(&to->tn_tlock);\n\t} else if (doingdirectory) {\n\t\terror = ENOTDIR;\n\t\tgoto out;\n\t}\n\n\ttmpfs_hash_change(where, fromtp);\n\tgethrestime(&now);\n\ttoparent->tn_mtime = now;\n\ttoparent->tn_ctime = now;\n\n\t/*\n\t * Upgrade to write lock on \"to\" (i.e., the target tmpnode).\n\t */\n\trw_exit(&to->tn_rwlock);\n\trw_enter(&to->tn_rwlock, RW_WRITER);\n\n\t/*\n\t * Decrement the link count of the target tmpnode.\n\t */\n\tDECR_COUNT(&to->tn_nlink, &to->tn_tlock);\n\tto->tn_ctime = now;\n\n\tif (doingdirectory) {\n\t\t/*\n\t\t * The entry for \"to\" no longer exists so release the vfslock.\n\t\t */\n\t\tvn_vfsunlock(TNTOV(to));\n\n\t\t/*\n\t\t * Decrement the target link count and delete all entires.\n\t\t */\n\t\ttdirtrunc(to);\n\t\tASSERT(to->tn_nlink == 0);\n\n\t\t/*\n\t\t * Renaming a directory with the parent different\n\t\t * requires that \"..\" be rewritten.  The window is\n\t\t * still there for \"..\" to be inconsistent, but this\n\t\t * is unavoidable, and a lot shorter than when it was\n\t\t * done in a user process.\n\t\t */\n\t\tif (fromparent != toparent)\n\t\t\ttdirfixdotdot(fromtp, fromparent, toparent);\n\t}\nout:\n\trw_exit(&to->tn_rwlock);\n\trw_exit(&fromtp->tn_rwlock);\n\treturn (error);\n}\n\nstatic void\ntdirfixdotdot(\n\tstruct tmpnode\t*fromtp,\t/* child directory */\n\tstruct tmpnode\t*fromparent,\t/* old parent directory */\n\tstruct tmpnode\t*toparent)\t/* new parent directory */\n{\n\tstruct tdirent\t*dotdot;\n\n\tASSERT(RW_LOCK_HELD(&toparent->tn_rwlock));\n\n\t/*\n\t * Increment the link count in the new parent tmpnode\n\t */\n\tINCR_COUNT(&toparent->tn_nlink, &toparent->tn_tlock);\n\tgethrestime(&toparent->tn_ctime);\n\n\tdotdot = tmpfs_hash_lookup(\"..\", fromtp, 0, NULL);\n\n\tASSERT(dotdot->td_tmpnode == fromparent);\n\tdotdot->td_tmpnode = toparent;\n\n\t/*\n\t * Decrement the link count of the old parent tmpnode.\n\t * If fromparent is NULL, then this is a new directory link;\n\t * it has no parent, so we need not do anything.\n\t */\n\tif (fromparent != NULL) {\n\t\tmutex_enter(&fromparent->tn_tlock);\n\t\tif (fromparent->tn_nlink != 0) {\n\t\t\tfromparent->tn_nlink--;\n\t\t\tgethrestime(&fromparent->tn_ctime);\n\t\t}\n\t\tmutex_exit(&fromparent->tn_tlock);\n\t}\n}\n\nstatic int\ntdiraddentry(\n\tstruct tmpnode\t*dir,\t/* target directory to make entry in */\n\tstruct tmpnode\t*tp,\t/* new tmpnode */\n\tchar\t\t*name,\n\tenum de_op\top,\n\tstruct tmpnode\t*fromtp)\n{\n\tstruct tdirent *tdp, *tpdp;\n\tsize_t\t\tnamelen, alloc_size;\n\ttimestruc_t\tnow;\n\n\t/*\n\t * Make sure the parent directory wasn't removed from\n\t * underneath the caller.\n\t */\n\tif (dir->tn_dir == NULL)\n\t\treturn (ENOENT);\n\n\t/*\n\t * Check that everything is on the same filesystem.\n\t */\n\tif (tp->tn_vnode->v_vfsp != dir->tn_vnode->v_vfsp)\n\t\treturn (EXDEV);\n\n\t/*\n\t * Allocate and initialize directory entry\n\t */\n\tnamelen = strlen(name) + 1;\n\talloc_size = namelen + sizeof (struct tdirent);\n\ttdp = tmp_memalloc(alloc_size, 0);\n\tif (tdp == NULL)\n\t\treturn (ENOSPC);\n\n\tif ((op == DE_RENAME) && (tp->tn_type == VDIR))\n\t\ttdirfixdotdot(tp, fromtp, dir);\n\n\tdir->tn_size += alloc_size;\n\tdir->tn_dirents++;\n\ttdp->td_tmpnode = tp;\n\ttdp->td_parent = dir;\n\n\t/*\n\t * The directory entry and its name were allocated sequentially.\n\t */\n\ttdp->td_name = (char *)tdp + sizeof (struct tdirent);\n\t(void) strcpy(tdp->td_name, name);\n\n\ttmpfs_hash_in(tdp);\n\n\t/*\n\t * Some utilities expect the size of a directory to remain\n\t * somewhat static.  For example, a routine which unlinks\n\t * files between calls to readdir(); the size of the\n\t * directory changes from underneath it and so the real\n\t * directory offset in bytes is invalid.  To circumvent\n\t * this problem, we initialize a directory entry with an\n\t * phony offset, and use this offset to determine end of\n\t * file in tmp_readdir.\n\t */\n\ttpdp = dir->tn_dir->td_prev;\n\t/*\n\t * Install at first empty \"slot\" in directory list.\n\t */\n\twhile (tpdp->td_next != NULL && (tpdp->td_next->td_offset -\n\t    tpdp->td_offset) <= 1) {\n\t\tASSERT(tpdp->td_next != tpdp);\n\t\tASSERT(tpdp->td_prev != tpdp);\n\t\tASSERT(tpdp->td_next->td_offset > tpdp->td_offset);\n\t\ttpdp = tpdp->td_next;\n\t}\n\ttdp->td_offset = tpdp->td_offset + 1;\n\n\t/*\n\t * If we're at the end of the dirent list and the offset (which\n\t * is necessarily the largest offset in this directory) is more\n\t * than twice the number of dirents, that means the directory is\n\t * 50% holes.  At this point we reset the slot pointer back to\n\t * the beginning of the directory so we start using the holes.\n\t * The idea is that if there are N dirents, there must also be\n\t * N holes, so we can satisfy the next N creates by walking at\n\t * most 2N entries; thus the average cost of a create is constant.\n\t * Note that we use the first dirent's td_prev as the roving\n\t * slot pointer; it's ugly, but it saves a word in every dirent.\n\t */\n\tif (tpdp->td_next == NULL && tpdp->td_offset > 2 * dir->tn_dirents)\n\t\tdir->tn_dir->td_prev = dir->tn_dir->td_next;\n\telse\n\t\tdir->tn_dir->td_prev = tdp;\n\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\ttdp->td_next = tpdp->td_next;\n\tif (tdp->td_next) {\n\t\ttdp->td_next->td_prev = tdp;\n\t}\n\ttdp->td_prev = tpdp;\n\ttpdp->td_next = tdp;\n\n\tASSERT(tdp->td_next != tdp);\n\tASSERT(tdp->td_prev != tdp);\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\treturn (0);\n}\n\nstatic int\ntdirmaketnode(\n\tstruct tmpnode *dir,\n\tstruct tmount\t*tm,\n\tstruct vattr\t*va,\n\tenum\tde_op\top,\n\tstruct tmpnode **newnode,\n\tstruct cred\t*cred)\n{\n\tstruct tmpnode *tp;\n\tenum vtype\ttype;\n\n\tASSERT(va != NULL);\n\tASSERT(op == DE_CREATE || op == DE_MKDIR);\n\tif (((va->va_mask & AT_ATIME) && TIMESPEC_OVERFLOW(&va->va_atime)) ||\n\t    ((va->va_mask & AT_MTIME) && TIMESPEC_OVERFLOW(&va->va_mtime)))\n\t\treturn (EOVERFLOW);\n\ttype = va->va_type;\n\ttp = tmp_memalloc(sizeof (struct tmpnode), TMP_MUSTHAVE);\n\ttmpnode_init(tm, tp, va, cred);\n\n\t/* setup normal file/dir's extended attribute directory */\n\tif (dir->tn_flags & ISXATTR) {\n\t\t/* parent dir is , mark file as xattr */\n\t\ttp->tn_flags |= ISXATTR;\n\t}\n\n\n\tif (type == VBLK || type == VCHR) {\n\t\ttp->tn_vnode->v_rdev = tp->tn_rdev = va->va_rdev;\n\t} else {\n\t\ttp->tn_vnode->v_rdev = tp->tn_rdev = NODEV;\n\t}\n\ttp->tn_vnode->v_type = type;\n\ttp->tn_uid = crgetuid(cred);\n\n\t/*\n\t * To determine the group-id of the created file:\n\t *   1) If the gid is set in the attribute list (non-Sun & pre-4.0\n\t *\tclients are not likely to set the gid), then use it if\n\t *\tthe process is privileged, belongs to the target group,\n\t *\tor the group is the same as the parent directory.\n\t *   2) If the filesystem was not mounted with the Old-BSD-compatible\n\t *\tGRPID option, and the directory's set-gid bit is clear,\n\t *\tthen use the process's gid.\n\t *   3) Otherwise, set the group-id to the gid of the parent directory.\n\t */\n\tif ((va->va_mask & AT_GID) &&\n\t    ((va->va_gid == dir->tn_gid) || groupmember(va->va_gid, cred) ||\n\t    secpolicy_vnode_create_gid(cred) == 0)) {\n\t\t/*\n\t\t * XXX - is this only the case when a 4.0 NFS client, or a\n\t\t * client derived from that code, makes a call over the wire?\n\t\t */\n\t\ttp->tn_gid = va->va_gid;\n\t} else {\n\t\tif (dir->tn_mode & VSGID)\n\t\t\ttp->tn_gid = dir->tn_gid;\n\t\telse\n\t\t\ttp->tn_gid = crgetgid(cred);\n\t}\n\t/*\n\t * If we're creating a directory, and the parent directory has the\n\t * set-GID bit set, set it on the new directory.\n\t * Otherwise, if the user is neither privileged nor a member of the\n\t * file's new group, clear the file's set-GID bit.\n\t */\n\tif (dir->tn_mode & VSGID && type == VDIR)\n\t\ttp->tn_mode |= VSGID;\n\telse {\n\t\tif ((tp->tn_mode & VSGID) &&\n\t\t    secpolicy_vnode_setids_setgids(cred, tp->tn_gid) != 0)\n\t\t\ttp->tn_mode &= ~VSGID;\n\t}\n\n\tif (va->va_mask & AT_ATIME)\n\t\ttp->tn_atime = va->va_atime;\n\tif (va->va_mask & AT_MTIME)\n\t\ttp->tn_mtime = va->va_mtime;\n\n\tif (op == DE_MKDIR)\n\t\ttdirinit(dir, tp);\n\n\t*newnode = tp;\n\treturn (0);\n}\n"], "fixing_code": ["/*\n * CDDL HEADER START\n *\n * The contents of this file are subject to the terms of the\n * Common Development and Distribution License (the \"License\").\n * You may not use this file except in compliance with the License.\n *\n * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE\n * or http://www.opensolaris.org/os/licensing.\n * See the License for the specific language governing permissions\n * and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL HEADER in each\n * file and include the License file at usr/src/OPENSOLARIS.LICENSE.\n * If applicable, add the following below this CDDL HEADER, with the\n * fields enclosed by brackets \"[]\" replaced with your own identifying\n * information: Portions Copyright [yyyy] [name of copyright owner]\n *\n * CDDL HEADER END\n */\n/*\n * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#pragma ident\t\"%Z%%M%\t%I%\t%E% SMI\"\n\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/sysmacros.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/vfs.h>\n#include <sys/vnode.h>\n#include <sys/errno.h>\n#include <sys/cmn_err.h>\n#include <sys/cred.h>\n#include <sys/stat.h>\n#include <sys/debug.h>\n#include <sys/policy.h>\n#include <sys/fs/tmpnode.h>\n#include <sys/fs/tmp.h>\n#include <sys/vtrace.h>\n\nstatic int tdircheckpath(struct tmpnode *, struct tmpnode *, struct cred *);\nstatic int tdirrename(struct tmpnode *, struct tmpnode *, struct tmpnode *,\n\tchar *, struct tmpnode *, struct tdirent *, struct cred *);\nstatic void tdirfixdotdot(struct tmpnode *, struct tmpnode *, struct tmpnode *);\nstatic int tdirmaketnode(struct tmpnode *, struct tmount *, struct vattr *,\n\tenum de_op, struct tmpnode **, struct cred *);\nstatic int tdiraddentry(struct tmpnode *, struct tmpnode *, char *,\n\tenum de_op, struct tmpnode *);\n\n\n#define\tT_HASH_SIZE\t8192\t\t/* must be power of 2 */\n#define\tT_MUTEX_SIZE\t64\n\n/* Non-static so compilers won't constant-fold these away. */\nclock_t tmpfs_rename_backoff_delay = 1;\nunsigned int tmpfs_rename_backoff_tries = 0;\nunsigned long tmpfs_rename_loops = 0;\n\nstatic struct tdirent\t*t_hashtable[T_HASH_SIZE];\nstatic kmutex_t\t\t t_hashmutex[T_MUTEX_SIZE];\n\n#define\tT_HASH_INDEX(a)\t\t((a) & (T_HASH_SIZE-1))\n#define\tT_MUTEX_INDEX(a)\t((a) & (T_MUTEX_SIZE-1))\n\n#define\tTMPFS_HASH(tp, name, hash)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tchar Xc, *Xcp;\t\t\t\t\t\\\n\t\thash = (uint_t)(uintptr_t)(tp) >> 8;\t\t\\\n\t\tfor (Xcp = (name); (Xc = *Xcp) != 0; Xcp++)\t\\\n\t\t\thash = (hash << 4) + hash + (uint_t)Xc;\t\\\n\t}\n\nvoid\ntmpfs_hash_init(void)\n{\n\tint\tix;\n\n\tfor (ix = 0; ix < T_MUTEX_SIZE; ix++)\n\t\tmutex_init(&t_hashmutex[ix], NULL, MUTEX_DEFAULT, NULL);\n}\n\n/*\n * This routine is where the rubber meets the road for identities.\n */\nstatic void\ntmpfs_hash_in(struct tdirent *t)\n{\n\tuint_t\t\thash;\n\tstruct tdirent\t**prevpp;\n\tkmutex_t\t*t_hmtx;\n\n\tTMPFS_HASH(t->td_parent, t->td_name, hash);\n\tt->td_hash = hash;\n\tprevpp = &t_hashtable[T_HASH_INDEX(hash)];\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\tt->td_link = *prevpp;\n\t*prevpp = t;\n\tmutex_exit(t_hmtx);\n}\n\n/*\n * Remove tdirent *t from the hash list.\n */\nstatic void\ntmpfs_hash_out(struct tdirent *t)\n{\n\tuint_t\t\thash;\n\tstruct tdirent\t**prevpp;\n\tkmutex_t\t*t_hmtx;\n\n\thash = t->td_hash;\n\tprevpp = &t_hashtable[T_HASH_INDEX(hash)];\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\twhile (*prevpp != t)\n\t\tprevpp = &(*prevpp)->td_link;\n\t*prevpp = t->td_link;\n\tmutex_exit(t_hmtx);\n}\n\n/*\n * Currently called by tdirrename() only.\n * rename operation needs to be done with lock held, to ensure that\n * no other operations can access the tmpnode at the same instance.\n */\nstatic void\ntmpfs_hash_change(struct tdirent *tdp, struct tmpnode *fromtp)\n{\n\tuint_t\t\thash;\n\tkmutex_t\t*t_hmtx;\n\n\thash = tdp->td_hash;\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\ttdp->td_tmpnode = fromtp;\n\tmutex_exit(t_hmtx);\n}\n\nstatic struct tdirent *\ntmpfs_hash_lookup(char *name, struct tmpnode *parent, uint_t hold,\n\tstruct tmpnode **found)\n{\n\tstruct tdirent\t*l;\n\tuint_t\t\thash;\n\tkmutex_t\t*t_hmtx;\n\tstruct tmpnode\t*tnp;\n\n\tTMPFS_HASH(parent, name, hash);\n\tt_hmtx = &t_hashmutex[T_MUTEX_INDEX(hash)];\n\tmutex_enter(t_hmtx);\n\tl = t_hashtable[T_HASH_INDEX(hash)];\n\twhile (l) {\n\t\tif ((l->td_hash == hash) &&\n\t\t    (l->td_parent == parent) &&\n\t\t    (strcmp(l->td_name, name) == 0)) {\n\t\t\t/*\n\t\t\t * We need to make sure that the tmpnode that\n\t\t\t * we put a hold on is the same one that we pass back.\n\t\t\t * Hence, temporary variable tnp is necessary.\n\t\t\t */\n\t\t\ttnp = l->td_tmpnode;\n\t\t\tif (hold) {\n\t\t\t\tASSERT(tnp);\n\t\t\t\ttmpnode_hold(tnp);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\t*found = tnp;\n\t\t\tmutex_exit(t_hmtx);\n\t\t\treturn (l);\n\t\t} else {\n\t\t\tl = l->td_link;\n\t\t}\n\t}\n\tmutex_exit(t_hmtx);\n\treturn (NULL);\n}\n\n/*\n * Search directory 'parent' for entry 'name'.\n *\n * The calling thread can't hold the write version\n * of the rwlock for the directory being searched\n *\n * 0 is returned on success and *foundtp points\n * to the found tmpnode with its vnode held.\n */\nint\ntdirlookup(\n\tstruct tmpnode *parent,\n\tchar *name,\n\tstruct tmpnode **foundtp,\n\tstruct cred *cred)\n{\n\tint error;\n\n\t*foundtp = NULL;\n\tif (parent->tn_type != VDIR)\n\t\treturn (ENOTDIR);\n\n\tif ((error = tmp_taccess(parent, VEXEC, cred)))\n\t\treturn (error);\n\n\tif (*name == '\\0') {\n\t\ttmpnode_hold(parent);\n\t\t*foundtp = parent;\n\t\treturn (0);\n\t}\n\n\t/*\n\t * Search the directory for the matching name\n\t * We need the lock protecting the tn_dir list\n\t * so that it doesn't change out from underneath us.\n\t * tmpfs_hash_lookup() will pass back the tmpnode\n\t * with a hold on it.\n\t */\n\n\tif (tmpfs_hash_lookup(name, parent, 1, foundtp) != NULL) {\n\t\tASSERT(*foundtp);\n\t\treturn (0);\n\t}\n\n\treturn (ENOENT);\n}\n\n/*\n * Enter a directory entry for 'name' and 'tp' into directory 'dir'\n *\n * Returns 0 on success.\n */\nint\ntdirenter(\n\tstruct tmount\t*tm,\n\tstruct tmpnode\t*dir,\t\t/* target directory to make entry in */\n\tchar\t\t*name,\t\t/* name of entry */\n\tenum de_op\top,\t\t/* entry operation */\n\tstruct tmpnode\t*fromparent,\t/* source directory if rename */\n\tstruct tmpnode\t*tp,\t\t/* source tmpnode, if link/rename */\n\tstruct vattr\t*va,\n\tstruct tmpnode\t**tpp,\t\t/* return tmpnode, if create/mkdir */\n\tstruct cred\t*cred,\n\tcaller_context_t *ctp)\n{\n\tstruct tdirent *tdp;\n\tstruct tmpnode *found = NULL;\n\tint error = 0;\n\tchar *s;\n\n\t/*\n\t * tn_rwlock is held to serialize direnter and dirdeletes\n\t */\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\t/*\n\t * Don't allow '/' characters in pathname component\n\t * (thus in ufs_direnter()).\n\t */\n\tfor (s = name; *s; s++)\n\t\tif (*s == '/')\n\t\t\treturn (EACCES);\n\n\tif (name[0] == '\\0')\n\t\tpanic(\"tdirenter: NULL name\");\n\n\t/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t */\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir) {\n\t\t\tunsigned int tries = 0;\n\n\t\t\t/*\n\t\t\t * If we are acquiring tp->tn_rwlock (for SOURCE)\n\t\t\t * inside here, we must consider the following:\n\t\t\t *\n\t\t\t * - dir->tn_rwlock (TARGET) is already HELD (see\n\t\t\t * above ASSERT()).\n\t\t\t *\n\t\t\t * - It is possible our SOURCE is a parent of our\n\t\t\t * TARGET. Yes it's unusual, but it will return an\n\t\t\t * error below via tdircheckpath().\n\t\t\t *\n\t\t\t * - It is also possible that another thread,\n\t\t\t * concurrent to this one, is performing\n\t\t\t * rmdir(TARGET), which means it will first acquire\n\t\t\t * SOURCE's lock, THEN acquire TARGET's lock, which\n\t\t\t * could result in this thread holding TARGET and\n\t\t\t * trying for SOURCE, but the other thread holding\n\t\t\t * SOURCE and trying for TARGET.  This is deadlock,\n\t\t\t * and it's inducible.\n\t\t\t *\n\t\t\t * To prevent this, we borrow some techniques from UFS\n\t\t\t * and rw_tryenter(), delaying if we fail, and\n\t\t\t * if someone tweaks the number of backoff tries to be\n\t\t\t * nonzero, return EBUSY after that number of tries.\n\t\t\t */\n\t\t\twhile (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {\n\t\t\t\t/*\n\t\t\t\t * Sloppy, but this is a diagnostic so atomic\n\t\t\t\t * increment would be overkill.\n\t\t\t\t */\n\t\t\t\ttmpfs_rename_loops++;\n\n\t\t\t\tif (tmpfs_rename_backoff_tries != 0) {\n\t\t\t\t\tif (tries > tmpfs_rename_backoff_tries)\n\t\t\t\t\t\treturn (EBUSY);\n\t\t\t\t\ttries++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * NOTE: We're still holding dir->tn_rwlock,\n\t\t\t\t * so drop it over the delay, so any other\n\t\t\t\t * thread can get its business done.\n\t\t\t\t *\n\t\t\t\t * No state change or state inspection happens\n\t\t\t\t * prior to here, so it is not wholly dangerous\n\t\t\t\t * to release-and-reacquire dir->tn_rwlock.\n\t\t\t\t *\n\t\t\t\t * Hold the vnode of dir in case it gets\n\t\t\t\t * released by another thread, though.\n\t\t\t\t */\n\t\t\t\tVN_HOLD(TNTOV(dir));\n\t\t\t\trw_exit(&dir->tn_rwlock);\n\t\t\t\tdelay(tmpfs_rename_backoff_delay);\n\t\t\t\trw_enter(&dir->tn_rwlock, RW_WRITER);\n\t\t\t\tVN_RELE(TNTOV(dir));\n\t\t\t}\n\t\t}\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\tif (tp->tn_nlink == MAXLINK) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (EMLINK);\n\t\t}\n\t\ttp->tn_nlink++;\n\t\tgethrestime(&tp->tn_ctime);\n\t\tmutex_exit(&tp->tn_tlock);\n\t\tif (tp != dir)\n\t\t\trw_exit(&tp->tn_rwlock);\n\t}\n\n\t/*\n\t * This might be a \"dangling detached directory\".\n\t * it could have been removed, but a reference\n\t * to it kept in u_cwd.  don't bother searching\n\t * it, and with any luck the user will get tired\n\t * of dealing with us and cd to some absolute\n\t * pathway.  *sigh*, thus in ufs, too.\n\t */\n\tif (dir->tn_nlink == 0) {\n\t\terror = ENOENT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this is a rename of a directory and the parent is\n\t * different (\"..\" must be changed), then the source\n\t * directory must not be in the directory hierarchy\n\t * above the target, as this would orphan everything\n\t * below the source directory.\n\t */\n\tif (op == DE_RENAME) {\n\t\tif (tp == dir) {\n\t\t\terror = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (tp->tn_type == VDIR) {\n\t\t\tif ((fromparent != dir) &&\n\t\t\t    (error = tdircheckpath(tp, dir, cred))) {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Search for the entry.  Return \"found\" if it exists.\n\t */\n\ttdp = tmpfs_hash_lookup(name, dir, 1, &found);\n\n\tif (tdp) {\n\t\tASSERT(found);\n\t\tswitch (op) {\n\t\tcase DE_CREATE:\n\t\tcase DE_MKDIR:\n\t\t\tif (tpp) {\n\t\t\t\t*tpp = found;\n\t\t\t\terror = EEXIST;\n\t\t\t} else {\n\t\t\t\ttmpnode_rele(found);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase DE_RENAME:\n\t\t\terror = tdirrename(fromparent, tp,\n\t\t\t    dir, name, found, tdp, cred);\n\t\t\tif (error == 0) {\n\t\t\t\tif (found != NULL) {\n\t\t\t\t\tvnevent_rename_dest(TNTOV(found),\n\t\t\t\t\t    TNTOV(dir), name, ctp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmpnode_rele(found);\n\t\t\tbreak;\n\n\t\tcase DE_LINK:\n\t\t\t/*\n\t\t\t * Can't link to an existing file.\n\t\t\t */\n\t\t\terror = EEXIST;\n\t\t\ttmpnode_rele(found);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\n\t\t/*\n\t\t * The entry does not exist. Check write permission in\n\t\t * directory to see if entry can be created.\n\t\t */\n\t\tif (error = tmp_taccess(dir, VWRITE, cred))\n\t\t\tgoto out;\n\t\tif (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\t/*\n\t\t\t * Make new tmpnode and directory entry as required.\n\t\t\t */\n\t\t\terror = tdirmaketnode(dir, tm, va, op, &tp, cred);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (error = tdiraddentry(dir, tp, name, op, fromparent)) {\n\t\t\tif (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\t\t/*\n\t\t\t\t * Unmake the inode we just made.\n\t\t\t\t */\n\t\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);\n\t\t\t\tif ((tp->tn_type) == VDIR) {\n\t\t\t\t\tASSERT(tdp == NULL);\n\t\t\t\t\t/*\n\t\t\t\t\t * cleanup allocs made by tdirinit()\n\t\t\t\t\t */\n\t\t\t\t\ttdirtrunc(tp);\n\t\t\t\t}\n\t\t\t\tmutex_enter(&tp->tn_tlock);\n\t\t\t\ttp->tn_nlink = 0;\n\t\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\t\tgethrestime(&tp->tn_ctime);\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\t\ttmpnode_rele(tp);\n\t\t\t\ttp = NULL;\n\t\t\t}\n\t\t} else if (tpp) {\n\t\t\t*tpp = tp;\n\t\t} else if (op == DE_CREATE || op == DE_MKDIR) {\n\t\t\ttmpnode_rele(tp);\n\t\t}\n\t}\n\nout:\n\tif (error && (op == DE_LINK || op == DE_RENAME)) {\n\t\t/*\n\t\t * Undo bumped link count.\n\t\t */\n\t\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\t\tgethrestime(&tp->tn_ctime);\n\t}\n\treturn (error);\n}\n\n/*\n * Delete entry tp of name \"nm\" from dir.\n * Free dir entry space and decrement link count on tmpnode(s).\n *\n * Return 0 on success.\n */\nint\ntdirdelete(\n\tstruct tmpnode *dir,\n\tstruct tmpnode *tp,\n\tchar *nm,\n\tenum dr_op op,\n\tstruct cred *cred)\n{\n\tstruct tdirent *tpdp;\n\tint error;\n\tsize_t namelen;\n\tstruct tmpnode *tnp;\n\ttimestruc_t now;\n\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(RW_WRITE_HELD(&tp->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tif (nm[0] == '\\0')\n\t\tpanic(\"tdirdelete: NULL name for %p\", (void *)tp);\n\n\t/*\n\t * return error when removing . and ..\n\t */\n\tif (nm[0] == '.') {\n\t\tif (nm[1] == '\\0')\n\t\t\treturn (EINVAL);\n\t\tif (nm[1] == '.' && nm[2] == '\\0')\n\t\t\treturn (EEXIST); /* thus in ufs */\n\t}\n\n\tif (error = tmp_taccess(dir, VEXEC|VWRITE, cred))\n\t\treturn (error);\n\n\t/*\n\t * If the parent directory is \"sticky\", then the user must\n\t * own the parent directory or the file in it, or else must\n\t * have permission to write the file.  Otherwise it may not\n\t * be deleted (except by privileged users).\n\t * Same as ufs_dirremove.\n\t */\n\tif ((error = tmp_sticky_remove_access(dir, tp, cred)) != 0)\n\t\treturn (error);\n\n\tif (dir->tn_dir == NULL)\n\t\treturn (ENOENT);\n\n\ttpdp = tmpfs_hash_lookup(nm, dir, 0, &tnp);\n\tif (tpdp == NULL) {\n\t\t/*\n\t\t * If it is gone, some other thread got here first!\n\t\t * Return error ENOENT.\n\t\t */\n\t\treturn (ENOENT);\n\t}\n\n\t/*\n\t * If the tmpnode in the tdirent changed, we were probably\n\t * the victim of a concurrent rename operation.  The original\n\t * is gone, so return that status (same as UFS).\n\t */\n\tif (tp != tnp)\n\t\treturn (ENOENT);\n\n\ttmpfs_hash_out(tpdp);\n\n\t/*\n\t * Take tpdp out of the directory list.\n\t */\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\tif (tpdp->td_prev) {\n\t\ttpdp->td_prev->td_next = tpdp->td_next;\n\t}\n\tif (tpdp->td_next) {\n\t\ttpdp->td_next->td_prev = tpdp->td_prev;\n\t}\n\n\t/*\n\t * If the roving slot pointer happens to match tpdp,\n\t * point it at the previous dirent.\n\t */\n\tif (dir->tn_dir->td_prev == tpdp) {\n\t\tdir->tn_dir->td_prev = tpdp->td_prev;\n\t}\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\t/*\n\t * tpdp points to the correct directory entry\n\t */\n\tnamelen = strlen(tpdp->td_name) + 1;\n\n\ttmp_memfree(tpdp, sizeof (struct tdirent) + namelen);\n\tdir->tn_size -= (sizeof (struct tdirent) + namelen);\n\tdir->tn_dirents--;\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\ttp->tn_ctime = now;\n\n\tASSERT(tp->tn_nlink > 0);\n\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\tif (op == DR_RMDIR && tp->tn_type == VDIR) {\n\t\ttdirtrunc(tp);\n\t\tASSERT(tp->tn_nlink == 0);\n\t}\n\treturn (0);\n}\n\n/*\n * tdirinit is used internally to initialize a directory (dir)\n * with '.' and '..' entries without checking permissions and locking\n */\nvoid\ntdirinit(\n\tstruct tmpnode *parent,\t\t/* parent of directory to initialize */\n\tstruct tmpnode *dir)\t\t/* the new directory */\n{\n\tstruct tdirent *dot, *dotdot;\n\ttimestruc_t now;\n\n\tASSERT(RW_WRITE_HELD(&parent->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tdot = tmp_memalloc(sizeof (struct tdirent) + 2, TMP_MUSTHAVE);\n\tdotdot = tmp_memalloc(sizeof (struct tdirent) + 3, TMP_MUSTHAVE);\n\n\t/*\n\t * Initialize the entries\n\t */\n\tdot->td_tmpnode = dir;\n\tdot->td_offset = 0;\n\tdot->td_name = (char *)dot + sizeof (struct tdirent);\n\tdot->td_name[0] = '.';\n\tdot->td_parent = dir;\n\ttmpfs_hash_in(dot);\n\n\tdotdot->td_tmpnode = parent;\n\tdotdot->td_offset = 1;\n\tdotdot->td_name = (char *)dotdot + sizeof (struct tdirent);\n\tdotdot->td_name[0] = '.';\n\tdotdot->td_name[1] = '.';\n\tdotdot->td_parent = dir;\n\ttmpfs_hash_in(dotdot);\n\n\t/*\n\t * Initialize directory entry list.\n\t */\n\tdot->td_next = dotdot;\n\tdot->td_prev = dotdot;\t/* dot's td_prev holds roving slot pointer */\n\tdotdot->td_next = NULL;\n\tdotdot->td_prev = dot;\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\t/*\n\t * Link counts are special for the hidden attribute directory.\n\t * The only explicit reference in the name space is \".\" and\n\t * the reference through \"..\" is not counted on the parent\n\t * file. The attrdir is created as a side effect to lookup,\n\t * so don't change the ctime of the parent.\n\t * Since tdirinit is called with both dir and parent being the\n\t * same for the root vnode, we need to increment this before we set\n\t * tn_nlink = 2 below.\n\t */\n\tif (!(dir->tn_vnode->v_flag & V_XATTRDIR)) {\n\t\tINCR_COUNT(&parent->tn_nlink, &parent->tn_tlock);\n\t\tparent->tn_ctime = now;\n\t}\n\n\tdir->tn_dir = dot;\n\tdir->tn_size = 2 * sizeof (struct tdirent) + 5;\t/* dot and dotdot */\n\tdir->tn_dirents = 2;\n\tdir->tn_nlink = 2;\n}\n\n\n/*\n * tdirtrunc is called to remove all directory entries under this directory.\n */\nvoid\ntdirtrunc(struct tmpnode *dir)\n{\n\tstruct tdirent *tdp;\n\tstruct tmpnode *tp;\n\tsize_t namelen;\n\ttimestruc_t now;\n\tint isvattrdir, isdotdot, skip_decr;\n\n\tASSERT(RW_WRITE_HELD(&dir->tn_rwlock));\n\tASSERT(dir->tn_type == VDIR);\n\n\tisvattrdir = (dir->tn_vnode->v_flag & V_XATTRDIR) ? 1 : 0;\n\tfor (tdp = dir->tn_dir; tdp; tdp = dir->tn_dir) {\n\t\tASSERT(tdp->td_next != tdp);\n\t\tASSERT(tdp->td_prev != tdp);\n\t\tASSERT(tdp->td_tmpnode);\n\n\t\tdir->tn_dir = tdp->td_next;\n\t\tnamelen = strlen(tdp->td_name) + 1;\n\n\t\t/*\n\t\t * Adjust the link counts to account for this directory\n\t\t * entry removal. Hidden attribute directories may\n\t\t * not be empty as they may be truncated as a side-\n\t\t * effect of removing the parent. We do hold/rele\n\t\t * operations to free up these tmpnodes.\n\t\t *\n\t\t * Skip the link count adjustment for parents of\n\t\t * attribute directories as those link counts\n\t\t * do not include the \"..\" reference in the hidden\n\t\t * directories.\n\t\t */\n\t\ttp = tdp->td_tmpnode;\n\t\tisdotdot = (strcmp(\"..\", tdp->td_name) == 0);\n\t\tskip_decr = (isvattrdir && isdotdot);\n\t\tif (!skip_decr) {\n\t\t\tASSERT(tp->tn_nlink > 0);\n\t\t\tDECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);\n\t\t}\n\n\t\ttmpfs_hash_out(tdp);\n\n\t\ttmp_memfree(tdp, sizeof (struct tdirent) + namelen);\n\t\tdir->tn_size -= (sizeof (struct tdirent) + namelen);\n\t\tdir->tn_dirents--;\n\t}\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\tASSERT(dir->tn_dir == NULL);\n\tASSERT(dir->tn_size == 0);\n\tASSERT(dir->tn_dirents == 0);\n}\n\n/*\n * Check if the source directory is in the path of the target directory.\n * The target directory is locked by the caller.\n *\n * XXX - The source and target's should be different upon entry.\n */\nstatic int\ntdircheckpath(\n\tstruct tmpnode *fromtp,\n\tstruct tmpnode\t*toparent,\n\tstruct cred\t*cred)\n{\n\tint\terror = 0;\n\tstruct tmpnode *dir, *dotdot;\n\tstruct tdirent *tdp;\n\n\tASSERT(RW_WRITE_HELD(&toparent->tn_rwlock));\n\n\ttdp = tmpfs_hash_lookup(\"..\", toparent, 1, &dotdot);\n\tif (tdp == NULL)\n\t\treturn (ENOENT);\n\n\tASSERT(dotdot);\n\n\tif (dotdot == toparent) {\n\t\t/* root of fs.  search trivially satisfied. */\n\t\ttmpnode_rele(dotdot);\n\t\treturn (0);\n\t}\n\tfor (;;) {\n\t\t/*\n\t\t * Return error for cases like \"mv c c/d\",\n\t\t * \"mv c c/d/e\" and so on.\n\t\t */\n\t\tif (dotdot == fromtp) {\n\t\t\ttmpnode_rele(dotdot);\n\t\t\terror = EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tdir = dotdot;\n\t\terror = tdirlookup(dir, \"..\", &dotdot, cred);\n\t\tif (error) {\n\t\t\ttmpnode_rele(dir);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We're okay if we traverse the directory tree up to\n\t\t * the root directory and don't run into the\n\t\t * parent directory.\n\t\t */\n\t\tif (dir == dotdot) {\n\t\t\ttmpnode_rele(dir);\n\t\t\ttmpnode_rele(dotdot);\n\t\t\tbreak;\n\t\t}\n\t\ttmpnode_rele(dir);\n\t}\n\treturn (error);\n}\n\nstatic int\ntdirrename(\n\tstruct tmpnode *fromparent,\t/* parent directory of source */\n\tstruct tmpnode *fromtp,\t\t/* source tmpnode */\n\tstruct tmpnode *toparent,\t/* parent directory of target */\n\tchar *nm,\t\t\t/* entry we are trying to change */\n\tstruct tmpnode *to,\t\t/* target tmpnode */\n\tstruct tdirent *where,\t\t/* target tmpnode directory entry */\n\tstruct cred *cred)\t\t/* credentials */\n{\n\tint error = 0;\n\tint doingdirectory;\n\ttimestruc_t now;\n\n#if defined(lint)\n\tnm = nm;\n#endif\n\tASSERT(RW_WRITE_HELD(&toparent->tn_rwlock));\n\n\t/*\n\t * Short circuit rename of something to itself.\n\t */\n\tif (fromtp == to)\n\t\treturn (ESAME);\t\t/* special KLUDGE error code */\n\n\trw_enter(&fromtp->tn_rwlock, RW_READER);\n\trw_enter(&to->tn_rwlock, RW_READER);\n\n\t/*\n\t * Check that everything is on the same filesystem.\n\t */\n\tif (to->tn_vnode->v_vfsp != toparent->tn_vnode->v_vfsp ||\n\t    to->tn_vnode->v_vfsp != fromtp->tn_vnode->v_vfsp) {\n\t\terror = EXDEV;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Must have write permission to rewrite target entry.\n\t * Check for stickyness.\n\t */\n\tif ((error = tmp_taccess(toparent, VWRITE, cred)) != 0 ||\n\t    (error = tmp_sticky_remove_access(toparent, to, cred)) != 0)\n\t\tgoto out;\n\n\t/*\n\t * Ensure source and target are compatible (both directories\n\t * or both not directories).  If target is a directory it must\n\t * be empty and have no links to it; in addition it must not\n\t * be a mount point, and both the source and target must be\n\t * writable.\n\t */\n\tdoingdirectory = (fromtp->tn_type == VDIR);\n\tif (to->tn_type == VDIR) {\n\t\tif (!doingdirectory) {\n\t\t\terror = EISDIR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * vn_vfswlock will prevent mounts from using the directory\n\t\t * until we are done.\n\t\t */\n\t\tif (vn_vfswlock(TNTOV(to))) {\n\t\t\terror = EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vn_mountedvfs(TNTOV(to)) != NULL) {\n\t\t\tvn_vfsunlock(TNTOV(to));\n\t\t\terror = EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmutex_enter(&to->tn_tlock);\n\t\tif (to->tn_dirents > 2 || to->tn_nlink > 2) {\n\t\t\tmutex_exit(&to->tn_tlock);\n\t\t\tvn_vfsunlock(TNTOV(to));\n\t\t\terror = EEXIST; /* SIGH should be ENOTEMPTY */\n\t\t\t/*\n\t\t\t * Update atime because checking tn_dirents is\n\t\t\t * logically equivalent to reading the directory\n\t\t\t */\n\t\t\tgethrestime(&to->tn_atime);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_exit(&to->tn_tlock);\n\t} else if (doingdirectory) {\n\t\terror = ENOTDIR;\n\t\tgoto out;\n\t}\n\n\ttmpfs_hash_change(where, fromtp);\n\tgethrestime(&now);\n\ttoparent->tn_mtime = now;\n\ttoparent->tn_ctime = now;\n\n\t/*\n\t * Upgrade to write lock on \"to\" (i.e., the target tmpnode).\n\t */\n\trw_exit(&to->tn_rwlock);\n\trw_enter(&to->tn_rwlock, RW_WRITER);\n\n\t/*\n\t * Decrement the link count of the target tmpnode.\n\t */\n\tDECR_COUNT(&to->tn_nlink, &to->tn_tlock);\n\tto->tn_ctime = now;\n\n\tif (doingdirectory) {\n\t\t/*\n\t\t * The entry for \"to\" no longer exists so release the vfslock.\n\t\t */\n\t\tvn_vfsunlock(TNTOV(to));\n\n\t\t/*\n\t\t * Decrement the target link count and delete all entires.\n\t\t */\n\t\ttdirtrunc(to);\n\t\tASSERT(to->tn_nlink == 0);\n\n\t\t/*\n\t\t * Renaming a directory with the parent different\n\t\t * requires that \"..\" be rewritten.  The window is\n\t\t * still there for \"..\" to be inconsistent, but this\n\t\t * is unavoidable, and a lot shorter than when it was\n\t\t * done in a user process.\n\t\t */\n\t\tif (fromparent != toparent)\n\t\t\ttdirfixdotdot(fromtp, fromparent, toparent);\n\t}\nout:\n\trw_exit(&to->tn_rwlock);\n\trw_exit(&fromtp->tn_rwlock);\n\treturn (error);\n}\n\nstatic void\ntdirfixdotdot(\n\tstruct tmpnode\t*fromtp,\t/* child directory */\n\tstruct tmpnode\t*fromparent,\t/* old parent directory */\n\tstruct tmpnode\t*toparent)\t/* new parent directory */\n{\n\tstruct tdirent\t*dotdot;\n\n\tASSERT(RW_LOCK_HELD(&toparent->tn_rwlock));\n\n\t/*\n\t * Increment the link count in the new parent tmpnode\n\t */\n\tINCR_COUNT(&toparent->tn_nlink, &toparent->tn_tlock);\n\tgethrestime(&toparent->tn_ctime);\n\n\tdotdot = tmpfs_hash_lookup(\"..\", fromtp, 0, NULL);\n\n\tASSERT(dotdot->td_tmpnode == fromparent);\n\tdotdot->td_tmpnode = toparent;\n\n\t/*\n\t * Decrement the link count of the old parent tmpnode.\n\t * If fromparent is NULL, then this is a new directory link;\n\t * it has no parent, so we need not do anything.\n\t */\n\tif (fromparent != NULL) {\n\t\tmutex_enter(&fromparent->tn_tlock);\n\t\tif (fromparent->tn_nlink != 0) {\n\t\t\tfromparent->tn_nlink--;\n\t\t\tgethrestime(&fromparent->tn_ctime);\n\t\t}\n\t\tmutex_exit(&fromparent->tn_tlock);\n\t}\n}\n\nstatic int\ntdiraddentry(\n\tstruct tmpnode\t*dir,\t/* target directory to make entry in */\n\tstruct tmpnode\t*tp,\t/* new tmpnode */\n\tchar\t\t*name,\n\tenum de_op\top,\n\tstruct tmpnode\t*fromtp)\n{\n\tstruct tdirent *tdp, *tpdp;\n\tsize_t\t\tnamelen, alloc_size;\n\ttimestruc_t\tnow;\n\n\t/*\n\t * Make sure the parent directory wasn't removed from\n\t * underneath the caller.\n\t */\n\tif (dir->tn_dir == NULL)\n\t\treturn (ENOENT);\n\n\t/*\n\t * Check that everything is on the same filesystem.\n\t */\n\tif (tp->tn_vnode->v_vfsp != dir->tn_vnode->v_vfsp)\n\t\treturn (EXDEV);\n\n\t/*\n\t * Allocate and initialize directory entry\n\t */\n\tnamelen = strlen(name) + 1;\n\talloc_size = namelen + sizeof (struct tdirent);\n\ttdp = tmp_memalloc(alloc_size, 0);\n\tif (tdp == NULL)\n\t\treturn (ENOSPC);\n\n\tif ((op == DE_RENAME) && (tp->tn_type == VDIR))\n\t\ttdirfixdotdot(tp, fromtp, dir);\n\n\tdir->tn_size += alloc_size;\n\tdir->tn_dirents++;\n\ttdp->td_tmpnode = tp;\n\ttdp->td_parent = dir;\n\n\t/*\n\t * The directory entry and its name were allocated sequentially.\n\t */\n\ttdp->td_name = (char *)tdp + sizeof (struct tdirent);\n\t(void) strcpy(tdp->td_name, name);\n\n\ttmpfs_hash_in(tdp);\n\n\t/*\n\t * Some utilities expect the size of a directory to remain\n\t * somewhat static.  For example, a routine which unlinks\n\t * files between calls to readdir(); the size of the\n\t * directory changes from underneath it and so the real\n\t * directory offset in bytes is invalid.  To circumvent\n\t * this problem, we initialize a directory entry with an\n\t * phony offset, and use this offset to determine end of\n\t * file in tmp_readdir.\n\t */\n\ttpdp = dir->tn_dir->td_prev;\n\t/*\n\t * Install at first empty \"slot\" in directory list.\n\t */\n\twhile (tpdp->td_next != NULL && (tpdp->td_next->td_offset -\n\t    tpdp->td_offset) <= 1) {\n\t\tASSERT(tpdp->td_next != tpdp);\n\t\tASSERT(tpdp->td_prev != tpdp);\n\t\tASSERT(tpdp->td_next->td_offset > tpdp->td_offset);\n\t\ttpdp = tpdp->td_next;\n\t}\n\ttdp->td_offset = tpdp->td_offset + 1;\n\n\t/*\n\t * If we're at the end of the dirent list and the offset (which\n\t * is necessarily the largest offset in this directory) is more\n\t * than twice the number of dirents, that means the directory is\n\t * 50% holes.  At this point we reset the slot pointer back to\n\t * the beginning of the directory so we start using the holes.\n\t * The idea is that if there are N dirents, there must also be\n\t * N holes, so we can satisfy the next N creates by walking at\n\t * most 2N entries; thus the average cost of a create is constant.\n\t * Note that we use the first dirent's td_prev as the roving\n\t * slot pointer; it's ugly, but it saves a word in every dirent.\n\t */\n\tif (tpdp->td_next == NULL && tpdp->td_offset > 2 * dir->tn_dirents)\n\t\tdir->tn_dir->td_prev = dir->tn_dir->td_next;\n\telse\n\t\tdir->tn_dir->td_prev = tdp;\n\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\ttdp->td_next = tpdp->td_next;\n\tif (tdp->td_next) {\n\t\ttdp->td_next->td_prev = tdp;\n\t}\n\ttdp->td_prev = tpdp;\n\ttpdp->td_next = tdp;\n\n\tASSERT(tdp->td_next != tdp);\n\tASSERT(tdp->td_prev != tdp);\n\tASSERT(tpdp->td_next != tpdp);\n\tASSERT(tpdp->td_prev != tpdp);\n\n\tgethrestime(&now);\n\tdir->tn_mtime = now;\n\tdir->tn_ctime = now;\n\n\treturn (0);\n}\n\nstatic int\ntdirmaketnode(\n\tstruct tmpnode *dir,\n\tstruct tmount\t*tm,\n\tstruct vattr\t*va,\n\tenum\tde_op\top,\n\tstruct tmpnode **newnode,\n\tstruct cred\t*cred)\n{\n\tstruct tmpnode *tp;\n\tenum vtype\ttype;\n\n\tASSERT(va != NULL);\n\tASSERT(op == DE_CREATE || op == DE_MKDIR);\n\tif (((va->va_mask & AT_ATIME) && TIMESPEC_OVERFLOW(&va->va_atime)) ||\n\t    ((va->va_mask & AT_MTIME) && TIMESPEC_OVERFLOW(&va->va_mtime)))\n\t\treturn (EOVERFLOW);\n\ttype = va->va_type;\n\ttp = tmp_memalloc(sizeof (struct tmpnode), TMP_MUSTHAVE);\n\ttmpnode_init(tm, tp, va, cred);\n\n\t/* setup normal file/dir's extended attribute directory */\n\tif (dir->tn_flags & ISXATTR) {\n\t\t/* parent dir is , mark file as xattr */\n\t\ttp->tn_flags |= ISXATTR;\n\t}\n\n\n\tif (type == VBLK || type == VCHR) {\n\t\ttp->tn_vnode->v_rdev = tp->tn_rdev = va->va_rdev;\n\t} else {\n\t\ttp->tn_vnode->v_rdev = tp->tn_rdev = NODEV;\n\t}\n\ttp->tn_vnode->v_type = type;\n\ttp->tn_uid = crgetuid(cred);\n\n\t/*\n\t * To determine the group-id of the created file:\n\t *   1) If the gid is set in the attribute list (non-Sun & pre-4.0\n\t *\tclients are not likely to set the gid), then use it if\n\t *\tthe process is privileged, belongs to the target group,\n\t *\tor the group is the same as the parent directory.\n\t *   2) If the filesystem was not mounted with the Old-BSD-compatible\n\t *\tGRPID option, and the directory's set-gid bit is clear,\n\t *\tthen use the process's gid.\n\t *   3) Otherwise, set the group-id to the gid of the parent directory.\n\t */\n\tif ((va->va_mask & AT_GID) &&\n\t    ((va->va_gid == dir->tn_gid) || groupmember(va->va_gid, cred) ||\n\t    secpolicy_vnode_create_gid(cred) == 0)) {\n\t\t/*\n\t\t * XXX - is this only the case when a 4.0 NFS client, or a\n\t\t * client derived from that code, makes a call over the wire?\n\t\t */\n\t\ttp->tn_gid = va->va_gid;\n\t} else {\n\t\tif (dir->tn_mode & VSGID)\n\t\t\ttp->tn_gid = dir->tn_gid;\n\t\telse\n\t\t\ttp->tn_gid = crgetgid(cred);\n\t}\n\t/*\n\t * If we're creating a directory, and the parent directory has the\n\t * set-GID bit set, set it on the new directory.\n\t * Otherwise, if the user is neither privileged nor a member of the\n\t * file's new group, clear the file's set-GID bit.\n\t */\n\tif (dir->tn_mode & VSGID && type == VDIR)\n\t\ttp->tn_mode |= VSGID;\n\telse {\n\t\tif ((tp->tn_mode & VSGID) &&\n\t\t    secpolicy_vnode_setids_setgids(cred, tp->tn_gid) != 0)\n\t\t\ttp->tn_mode &= ~VSGID;\n\t}\n\n\tif (va->va_mask & AT_ATIME)\n\t\ttp->tn_atime = va->va_atime;\n\tif (va->va_mask & AT_MTIME)\n\t\ttp->tn_mtime = va->va_mtime;\n\n\tif (op == DE_MKDIR)\n\t\ttdirinit(dir, tp);\n\n\t*newnode = tp;\n\treturn (0);\n}\n"], "filenames": ["usr/src/uts/common/fs/tmpfs/tmp_dir.c"], "buggy_code_start_loc": [57], "buggy_code_end_loc": [272], "fixing_code_start_loc": [58], "fixing_code_end_loc": [334], "type": "NVD-CWE-noinfo", "message": "An issue was discovered in illumos before f859e7171bb5db34321e45585839c6c3200ebb90, OmniOS Community Edition r151038, OpenIndiana Hipster 2021.04, and SmartOS 20210923. A local unprivileged user can cause a deadlock and kernel panic via crafted rename and rmdir calls on tmpfs filesystems. Oracle Solaris 10 and 11 is also affected.", "other": {"cve": {"id": "CVE-2021-43395", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-26T06:15:10.677", "lastModified": "2023-01-05T17:26:08.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in illumos before f859e7171bb5db34321e45585839c6c3200ebb90, OmniOS Community Edition r151038, OpenIndiana Hipster 2021.04, and SmartOS 20210923. A local unprivileged user can cause a deadlock and kernel panic via crafted rename and rmdir calls on tmpfs filesystems. Oracle Solaris 10 and 11 is also affected."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:illumos:illumos:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-01-18", "matchCriteriaId": "2A4CF626-104D-4D80-BBB3-AAD92851309C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:omniosce:omnios:r151038:*:*:*:community:*:*:*", "matchCriteriaId": "E79C33B6-754E-44EF-BB8A-CBF3D8F54BC9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:openindiana:openindiana:hipster_2021.04:*:*:*:*:*:*:*", "matchCriteriaId": "39D1A8D6-2008-468C-A894-D3FD867F4D98"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:joyent:smartos:20210923:*:*:*:*:*:*:*", "matchCriteriaId": "3E4E46FC-C324-46AC-B7A8-A7074EA7B6CB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10:*:*:*:*:*:*:*", "matchCriteriaId": "964B57CD-CB8A-4520-B358-1C93EC5EF2DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11:*:*:*:*:*:*:*", "matchCriteriaId": "8E8C192B-8044-4BF9-9F1F-57371FC0E8FD"}]}]}], "references": [{"url": "http://www.tribblix.org/relnotes.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/illumos/illumos-gate/blob/069654420de4aade43c63c43cd2896e66945fc8a/usr/src/uts/common/fs/tmpfs/tmp_vnops.c", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/illumos/illumos-gate/blob/b3403853e80914bd0aade9b5b605da4878078173/usr/src/uts/common/fs/tmpfs/tmp_dir.c", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/illumos/illumos-gate/commit/f859e7171bb5db34321e45585839c6c3200ebb90", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://illumos.topicbox.com/groups/developer/T1c9e4f27f8c2f959/security-heads-up-illumos14424", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://jgardner100.wordpress.com/2022/01/20/security-heads-up/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://kebe.com/blog/?p=505", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.illumos.org/issues/14424", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/illumos/illumos-gate/commit/f859e7171bb5db34321e45585839c6c3200ebb90"}}