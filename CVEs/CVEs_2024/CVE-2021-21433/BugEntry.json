{"buggy_code": ["import discord , subprocess , datetime\nfrom discord.ext import commands\nfrom setting import *\nfrom os import path , getcwd , chdir\n\nfrom assets import CommandInjection\nfrom assets import getIp\nfrom assets import randomStrings\nfrom assets import removeColors\nfrom assets import Duplicates\nfrom assets import removeString\nfrom assets import logsParser\nfrom assets import resolvedParser\nfrom assets import fileSize\nfrom assets import filesUploader\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems: logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems: resolvedItems = {}\n\n# Commands\n@Client.command()\nasync def exec(ctx , *, argument):\n    for ADMIN in ADMINS:\n        if str(ctx.message.author) == ADMIN:\n            try:\n                Process = subprocess.Popen(f'{argument}' , shell=True , executable=\"/bin/bash\" , stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                Results = Process.communicate()[0].decode('UTF-8')\n                if len(Results) > 2000:\n                    RandomStr = randomStrings.Genrate()\n\n                    with open(f'messages/{RandomStr}' , 'w') as Message:\n                        Message.write(Results); Message.close()\n                        await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n                else:\n                    if Results != '': await ctx.send(f'```{Results}```')\n                    else: await ctx.send(f\"**The Command You Performed Didn't Return an Output.**\")\n            except Exception as e:\n                print(\"Exception Happened!\")\n                if DEBUG == True: await ctx.send(f'Python Error: **{str(e)}**')\n                else: await ctx.send(\"**Your Command Returned an Error.**\")\n            return None\n        else: pass\n    await ctx.send(f\"**You're Not Authorized To Make Commands To The Server.**\")\n\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Results = subprocess.check_output([f'nslookup {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'whois {argument}'] , shell=True).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Whois Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Whois Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'dig {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(\"**Dig Results:**\")\n    await ctx.send(f\"```{Output}```\")\n    await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    Message = getIp.getIp(Domain=argument)\n    await ctx.send(Message)\n\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'python3 arjun.py -u {argument}' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n    Output = removeString.removeString('Processing' , Output=Output)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    chdir(MainPath)\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Waybackurls Results: {URL_}\")\n            else:\n                await ctx.send(\"**Waybackurls Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Assetfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Findomain Results: {URL_}\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = removeColors.Remove(Text=Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"ParamSpider Results: {URL_}\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/')\n            Data = open(Path).read().rstrip()\n            Data = removeColors.Remove(Text=Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Message)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Recon Results: {URL_}\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\n@Client.command()\nasync def subdomains(ctx , * , argument):\n    global logsItems, resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    '''\n    Subdomains collections gonna use three tools\n    subfinder, findomain, assetfinder\n\n    it won't use amass until we upgrade the server. if you're a developer\n    and you want to add amass. i guess you know what todo.\n    '''\n\n    await ctx.send(f\"**Collecting Subdomains For {argument}, Gonna Send You It When It's Done**\")\n\n    # global paths\n    findomainPath = TOOLS['findomain']\n\n    # findomain Subdomains\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    findomainResults = Process.communicate()[0].decode('UTF-8')\n\n    # assetfinder Subdomains\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    assetfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # subfinder Subdomains\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # filter duplicates\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = Duplicates.Duplicates(Subdomains=allSubdomains)\n\n    # saving subdomains\n    fileName = randomStrings.Genrate()\n    resolvedName = randomStrings.Genrate()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains); subdomainsFile.close()\n\n    # add resolved into logs\n    resolvedParser.resolvedWriter(Target=argument , fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    # validate subdomains\n    Process = subprocess.Popen(f\"cat data/hosts/{resolvedName} | httpx -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n\n    # saving httpx results\n    with open(f'data/subdomains/{fileName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults); subdomainsFile.close()\n\n    # add results into logs\n    logsParser.logsWriter(Target=argument , fileName=fileName)\n    logsItems[argument] = fileName\n\n    # send httpx results\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subdomains For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Getting Subdomains Information (titles , status-codes, web-servers) for {argument} using httpx.**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = removeColors.Remove(Text=httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Httpx Results For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    Process = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    nucleiResults = Process.communicate()[0].decode('UTF-8')\n    nucleiResults = removeColors.Remove(Text=nucleiResults)\n\n    if nucleiResults == '':\n        await ctx.send(f\"**Nuclei Couldn't Find Issue On {argument}**\")\n    elif len(nucleiResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(nucleiResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Nuclei Results: {URL_}\")\n            else:\n                await ctx.send(\"**Nuclei Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Nuclei Results For {argument}:**\")\n        await ctx.send(f'```{nucleiResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = randomStrings.Genrate()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    Process = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjackResults = Process.communicate()[0].decode('UTF-8')\n    subjackResults = removeColors.Remove(Text=subjackResults)\n\n    if subjackResults == '':\n        await ctx.send(f\"**Subjack Couldn't Find Issue On {argument}**\")\n    elif len(subjackResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjackResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjack Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjack Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjack Results For {argument}:**\")\n        await ctx.send(f'```{subjackResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjsResults = Process.communicate()[0].decode('UTF-8')\n\n    if subjsResults == '':\n        await ctx.send(f\"**Subjs Couldn't Find Issue On {argument}**\")\n    elif len(subjsResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjsResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjs Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjs Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjs Results For {argument}:**\")\n        await ctx.send(f'```{subjsResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = removeColors.Remove(Text=smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Smuggler Results: {URL_}\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = ', '.join(targetsList)\n    await ctx.send(f\"**We Have Subdomains For: {targetsMessage}**\")\n\n@Client.command()\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n\n        await ctx.send(f\"**There's {str(resolvedLength)} Live Hosts For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n\n        await ctx.send(f\"**There's {str(subdomainsLength)} Valid Subdomains For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_member_join(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Joined The Server.\")\n\n@Client.event\nasync def on_member_remove(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Left The Server.\")\n\n@Client.event\nasync def on_ready():\n    Dates = datetime.datetime.now()\n    Message = f\"**ReconServer Started To Work On {Dates.year}-{Dates.month}-{Dates.day}**\"\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(Message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n"], "fixing_code": ["import discord , subprocess , datetime\nfrom discord.ext import commands\nfrom setting import *\nfrom os import path , getcwd , chdir\n\nfrom assets import CommandInjection\nfrom assets import getIp\nfrom assets import randomStrings\nfrom assets import removeColors\nfrom assets import Duplicates\nfrom assets import removeString\nfrom assets import logsParser\nfrom assets import resolvedParser\nfrom assets import fileSize\nfrom assets import filesUploader\n\nClient = commands.Bot(command_prefix=COMMANDS_PREFIX)\n\n# Define globals\nlogsItems = logsParser.logsParser()\nif not logsItems: logsItems = {}\n\nresolvedItems = resolvedParser.resolvedParser()\nif not resolvedItems: resolvedItems = {}\n\n# Commands\n@Client.command()\nasync def exec(ctx , *, argument):\n    for ADMIN in ADMINS:\n        if str(ctx.message.author) == ADMIN:\n            try:\n                Process = subprocess.Popen(f'{argument}' , shell=True , executable=\"/bin/bash\" , stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n                Results = Process.communicate()[0].decode('UTF-8')\n                if len(Results) > 2000:\n                    RandomStr = randomStrings.Genrate()\n\n                    with open(f'messages/{RandomStr}' , 'w') as Message:\n                        Message.write(Results); Message.close()\n                        await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n                else:\n                    if Results != '': await ctx.send(f'```{Results}```')\n                    else: await ctx.send(f\"**The Command You Performed Didn't Return an Output.**\")\n            except Exception as e:\n                print(\"Exception Happened!\")\n                if DEBUG == True: await ctx.send(f'Python Error: **{str(e)}**')\n                else: await ctx.send(\"**Your Command Returned an Error.**\")\n            return None\n        else: pass\n    await ctx.send(f\"**You're Not Authorized To Make Commands To The Server.**\")\n\n@Client.command()\nasync def nslookup(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Results = subprocess.check_output([f'nslookup {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(f'{Results}')\n\n@Client.command()\nasync def whois(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'whois {argument}'] , shell=True).decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Whois Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Whois Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def dig(ctx , * , argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Output = subprocess.check_output([f'dig {argument}'] , shell=True).decode('UTF-8')\n    await ctx.send(\"**Dig Results:**\")\n    await ctx.send(f\"```{Output}```\")\n    await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def ip(ctx , *, argument):\n    Message = getIp.getIp(Domain=argument)\n    await ctx.send(Message)\n\n@Client.command()\nasync def dirsearch(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n    \n    Path = TOOLS['dirsearch']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Dirsearch Scan, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f'python3 dirsearch.py -u {argument} -e * -b' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"Results: \", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def arjun(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n    \n    Path = TOOLS['arjun']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your Arjun Scan, We Will Send The Results When It's Done**\")\n    await ctx.send(f\"**Note: The Bot Won't Respond Until The Scan is Done. All Of Your Commands Now Will Be Executed After This Process is Done.\")\n    Process = subprocess.Popen(f'python3 arjun.py -u {argument}' , shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n    Output = removeColors.Remove(Output); chdir(MainPath)\n    Output = removeString.removeString('Processing' , Output=Output)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output); Message.close()\n            await ctx.send(\"**Arjun Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n            await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        targetName = argument.split(' ')[0].replace('http://' , '').replace('https://' , '')\n        await ctx.send(f'Arjun Results For {targetName}:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def gitgraber(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    Path = TOOLS['gitgraber']; MainPath = getcwd(); chdir(Path)\n    await ctx.send(f\"**Running Your GitGraber Scan, See gitGraber Channel For Possible Leaks**\")\n    _ = subprocess.Popen(f'python3 gitGraber.py -k wordlists/keywords.txt -q {argument} -d' , shell=True , stdin=None, stdout=None, stderr=None, close_fds=True)\n    chdir(MainPath)\n\n@Client.command()\nasync def waybackurls(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Waybackurls, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"echo {argument} | waybackurls\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Waybackurls Results: {URL_}\")\n            else:\n                await ctx.send(\"**Waybackurls Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Waybackurls Results:')\n        await ctx.send(f'```{Output}```')\n\n@Client.command()\nasync def subfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(f\"**Collecting Subdomains Using Subdinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Subfinder Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def assetfinder(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    await ctx.send(\"**Collecting Subdomains Using Assetfinder, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Assetfinder Results: {URL_}\")\n            else:\n                await ctx.send(\"**Assetfinder Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'Results:')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def findomain(ctx , *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    findomainPath = TOOLS['findomain']\n    await ctx.send(\"**Collecting Subdomains Using Findomain, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Findomain Results: {URL_}\")\n            else:\n                await ctx.send(\"**Findomain Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(\"**Findomain Results:**\")\n        await ctx.send(f\"```{Output}```\")\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def paramspider(ctx, *, argument):\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    paramPath = TOOLS['paramspider']\n    await ctx.send(\"**Collecting Parameters Using ParamSpider, We Will Send The Results When It's Done**\")\n    Process = subprocess.Popen(f\"python3 {paramPath}/paramspider.py -d {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    Output = Process.communicate()[0].decode('UTF-8')\n\n    Output = removeColors.Remove(Text=Output)\n    Output = Output.split('\\n')\n    urlsList = []\n    for singleLine in Output:\n        if singleLine.startswith('http'):\n            urlsList.append(singleLine)\n        else:\n            pass\n\n    Output = '\\n'.join(urlsList)\n\n    if len(Output) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Output)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"ParamSpider Results: {URL_}\")\n            else:\n                await ctx.send(\"**ParamSpider Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'**ParamSpider Results:**')\n        await ctx.send(f'```{Output}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# My Own Recon Data. It Isn't About You.\n@Client.command()\nasync def recon(ctx , *, argument):\n    if path.exists(f'/{USER}/{RECON_PATH}/{argument}'):\n        try:\n            Path = f'/{USER}/{RECON_PATH}/{argument}'.replace('//' , '/')\n            Data = open(Path).read().rstrip()\n            Data = removeColors.Remove(Text=Data)\n            Message = f\"\"\"```{Data}```\"\"\"\n        except Exception:\n            Message = f\"**Couldn't Find The Recon Data With This Path: {argument}**\"\n    else:\n        Message = \"**Sorry The Path You Added Doesn't Exists On Our Records**\"\n\n    if len(Message) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(Message)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Recon Results: {URL_}\")\n            else:\n                await ctx.send(\"**Recon Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f'{Message}')\n\n# Recon Collections\n@Client.command()\nasync def subdomains(ctx , * , argument):\n    global logsItems, resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    '''\n    Subdomains collections gonna use three tools\n    subfinder, findomain, assetfinder\n\n    it won't use amass until we upgrade the server. if you're a developer\n    and you want to add amass. i guess you know what todo.\n    '''\n\n    await ctx.send(f\"**Collecting Subdomains For {argument}, Gonna Send You It When It's Done**\")\n\n    # global paths\n    findomainPath = TOOLS['findomain']\n\n    # findomain Subdomains\n    Process = subprocess.Popen(f\"{findomainPath} --target {argument} --quiet\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    findomainResults = Process.communicate()[0].decode('UTF-8')\n\n    # assetfinder Subdomains\n    Process = subprocess.Popen(f\"assetfinder --subs-only {argument}\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    assetfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # subfinder Subdomains\n    Process = subprocess.Popen(f\"subfinder -d {argument} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subfinderResults = Process.communicate()[0].decode('UTF-8')\n\n    # filter duplicates\n    allSubdomains = findomainResults + assetfinderResults + subfinderResults\n    allSubdomains = Duplicates.Duplicates(Subdomains=allSubdomains)\n\n    # saving subdomains\n    fileName = randomStrings.Genrate()\n    resolvedName = randomStrings.Genrate()\n\n    currentPath = getcwd()\n    allSubdomains = '\\n'.join(allSubdomains)\n\n    with open(f'data/hosts/{resolvedName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(allSubdomains); subdomainsFile.close()\n\n    # add resolved into logs\n    resolvedParser.resolvedWriter(Target=argument , fileName=f\"{resolvedName}\\n\")\n    resolvedItems[argument] = resolvedName\n\n    # validate subdomains\n    Process = subprocess.Popen(f\"cat data/hosts/{resolvedName} | httpx -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n\n    # saving httpx results\n    with open(f'data/subdomains/{fileName}' , 'w') as subdomainsFile:\n        subdomainsFile.write(httpxResults); subdomainsFile.close()\n\n    # add results into logs\n    logsParser.logsWriter(Target=argument , fileName=fileName)\n    logsItems[argument] = fileName\n\n    # send httpx results\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subdomains For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def info(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Getting Subdomains Information (titles , status-codes, web-servers) for {argument} using httpx.**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | httpx -title -web-server -status-code -follow-redirects -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    httpxResults = Process.communicate()[0].decode('UTF-8')\n    httpxResults = removeColors.Remove(Text=httpxResults)\n\n    if len(httpxResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(httpxResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Httpx Results: {URL_}\")\n            else:\n                await ctx.send(\"**Httpx Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Httpx Results For {argument}:**\")\n        await ctx.send(f'```{httpxResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Tools collection\n@Client.command()\nasync def nuclei(ctx, *, argument):\n    global logsItems\n    nucleiTemplates = TOOLS['nuclei-templates']\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Issues Using Nuclei.**\")\n    Process = subprocess.Popen(f\"nuclei -l data/subdomains/{subdomainsFile} -t {nucleiTemplates} -silent\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    nucleiResults = Process.communicate()[0].decode('UTF-8')\n    nucleiResults = removeColors.Remove(Text=nucleiResults)\n\n    if nucleiResults == '':\n        await ctx.send(f\"**Nuclei Couldn't Find Issue On {argument}**\")\n    elif len(nucleiResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(nucleiResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Nuclei Results: {URL_}\")\n            else:\n                await ctx.send(\"**Nuclei Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Nuclei Results For {argument}:**\")\n        await ctx.send(f'```{nucleiResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjack(ctx , *, argument):\n    global resolvedItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        fileStr = randomStrings.Genrate()\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Scanning {argument} For Possible Subdomains Takeover Issues Using Subjack**\")\n    Process = subprocess.Popen(f\"subjack -w data/hosts/{resolvedFile} -t 100 -timeout 30 -o data/subjack/{argument}-{fileStr}.subjack -ssl\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjackResults = Process.communicate()[0].decode('UTF-8')\n    subjackResults = removeColors.Remove(Text=subjackResults)\n\n    if subjackResults == '':\n        await ctx.send(f\"**Subjack Couldn't Find Issue On {argument}**\")\n    elif len(subjackResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjackResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjack Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjack Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjack Results For {argument}:**\")\n        await ctx.send(f'```{subjackResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def subjs(ctx , *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    await ctx.send(f\"**Extracting JS Files From {argument} Using Subjs**\")\n    Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | subjs\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n    subjsResults = Process.communicate()[0].decode('UTF-8')\n\n    if subjsResults == '':\n        await ctx.send(f\"**Subjs Couldn't Find Issue On {argument}**\")\n    elif len(subjsResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(subjsResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Subjs Results: {URL_}\")\n            else:\n                await ctx.send(\"**Subjs Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Subjs Results For {argument}:**\")\n        await ctx.send(f'```{subjsResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n@Client.command()\nasync def smuggler(ctx, *, argument):\n    global logsItems\n\n    if not CommandInjection.commandInjection(argument=argument , RCE=RCE):\n        await ctx.send(\"**Your Command Contains Unallowed Chars. Don't Try To Use It Again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    smugglerPath = TOOLS['smuggler']\n    await ctx.send(f\"**Scanning {argument} For HTTP Request Smuggling Issues Using Smuggler**\")\n\n    if \"http:\" in argument or \"https:\" in argument:\n        Process = subprocess.Popen(f\"echo {argument} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n    else:\n        Process = subprocess.Popen(f\"cat data/subdomains/{subdomainsFile} | python3 {smugglerPath}/smuggler.py\",shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        smugglerResults = Process.communicate()[0].decode('UTF-8')\n\n    smugglerResults = removeColors.Remove(Text=smugglerResults)\n    if len(smugglerResults) > 2000:\n        RandomStr = randomStrings.Genrate()\n\n        with open(f'messages/{RandomStr}' , 'w') as Message:\n            Message.write(smugglerResults)\n            Message.close()\n\n            messageSize = fileSize.getSize(filePath=f'messages/{RandomStr}')\n\n            if not messageSize:\n                await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                return\n            elif messageSize > 8:\n                URL_ = filesUploader.uploadFiles(filePath=f'messages/{RandomStr}')\n                if not URL_:\n                    await ctx.send(\"**There's Something Wrong On The Bot While Reading a File That's Already Stored. Check It.**\")\n                    return\n                else:\n                    await ctx.send(f\"Smuggler Results: {URL_}\")\n            else:\n                await ctx.send(\"**Smuggler Results:**\", file=discord.File(f\"messages/{RandomStr}\"))\n                await ctx.send(f\"\\n**- {ctx.message.author}**\")\n    else:\n        await ctx.send(f\"**Smuggler Results For {argument}:**\")\n        await ctx.send(f'```{smugglerResults}```')\n        await ctx.send(f\"\\n**- {ctx.message.author}**\")\n\n# Showing Current Recon Data\n@Client.command()\nasync def show(ctx):\n    global logsItems\n\n    targetsList = []\n    for site,_ in logsItems.items():\n        targetsList.append(site)\n\n    targetsMessage = ', '.join(targetsList)\n    await ctx.send(f\"**We Have Subdomains For: {targetsMessage}**\")\n\n@Client.command()\nasync def count(ctx , *, argument):\n    global logsItems , resolvedItems\n\n    try:\n        resolvedFile = resolvedItems[argument]\n        resolvedContent = open(f'data/hosts/{resolvedFile}' , 'r').readlines()\n        resolvedLength = len(resolvedContent)\n\n        await ctx.send(f\"**There's {str(resolvedLength)} Live Hosts For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n    try:\n        subdomainsFile = logsItems[argument]\n        subdomainsContent = open(f'data/subdomains/{subdomainsFile}' , 'r').readlines()\n        subdomainsLength = len(subdomainsContent)\n\n        await ctx.send(f\"**There's {str(subdomainsLength)} Valid Subdomains For {argument}**\")\n    except Exception:\n        await ctx.send(\"**There's no subdomains has been collected for this target. please use** `.subdomains [TARGET]` **Then try again.**\")\n        return\n\n# Main Event With Admin Channel Logger.\n@Client.event\nasync def on_member_join(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Joined The Server.\")\n\n@Client.event\nasync def on_member_remove(member):\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(f\"{member} Has Left The Server.\")\n\n@Client.event\nasync def on_ready():\n    Dates = datetime.datetime.now()\n    Message = f\"**ReconServer Started To Work On {Dates.year}-{Dates.month}-{Dates.day}**\"\n    adminChannel = Client.get_channel(ADMIN_CHANNEL)\n    await adminChannel.send(Message)\n\nif __name__ == \"__main__\":\n    Client.run(DISCORD_TOKEN)\n"], "filenames": ["app.py"], "buggy_code_start_loc": [97], "buggy_code_end_loc": [117], "fixing_code_start_loc": [98], "fixing_code_end_loc": [126], "type": "CWE-78", "message": "Discord Recon Server is a bot that allows you to do your reconnaissance process from your Discord. Remote code execution in version 0.0.1 would allow remote users to execute commands on the server resulting in serious issues. This flaw is patched in 0.0.2.", "other": {"cve": {"id": "CVE-2021-21433", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-09T18:15:13.693", "lastModified": "2022-10-24T20:34:59.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discord Recon Server is a bot that allows you to do your reconnaissance process from your Discord. Remote code execution in version 0.0.1 would allow remote users to execute commands on the server resulting in serious issues. This flaw is patched in 0.0.2."}, {"lang": "es", "value": "Discord Recon Server, es un bot que te permite realizar tu proceso de reconocimiento desde tu Discord.&#xa0;Una ejecuci\u00f3n de c\u00f3digo remota en versi\u00f3n 0.0.1, permitir\u00eda a usuarios remotos ejecutar comandos en el servidor, resultando en serios problemas.&#xa0;Este fallo es parcheado en versi\u00f3n 0.0.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discord-recon_project:discord-recon:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.2", "matchCriteriaId": "6F23F131-A101-4919-9103-8FB71A74993B"}]}]}], "references": [{"url": "https://github.com/DEMON1A/Discord-Recon/commit/26e2a084679679cccdeeabbb6889ce120eff7e50", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/DEMON1A/Discord-Recon/issues/6", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/DEMON1A/Discord-Recon/security/advisories/GHSA-65fm-5x64-gv9x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/DEMON1A/Discord-Recon/commit/26e2a084679679cccdeeabbb6889ce120eff7e50"}}