{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  W   W  DDDD                               %\n%                             X X   W   W  D   D                              %\n%                              X    W   W  D   D                              %\n%                             X X   W W W  D   D                              %\n%                            X   X   W W   DDDD                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write X Windows System Window Dump Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#if defined(MAGICKCORE_X11_DELEGATE)\n#include \"MagickCore/xwindow-private.h\"\n#if !defined(vms)\n#include <X11/XWDFile.h>\n#else\n#include \"XWDFile.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_X11_DELEGATE)\nstatic MagickBooleanType\n  WriteXWDImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X W D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXWD() returns MagickTrue if the image format type, identified by the\n%  magick string, is XWD.\n%\n%  The format of the IsXWD method is:\n%\n%      MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick+1,\"\\000\\000\",2) == 0)\n    {\n      if (memcmp(magick+4,\"\\007\\000\\000\",3) == 0)\n        return(MagickTrue);\n      if (memcmp(magick+5,\"\\000\\000\\007\",3) == 0)\n        return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X W D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXWDImage() reads an X Window System window dump image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadXWDImage method is:\n%\n%      Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  switch (header.visual_class)\n  {\n    case StaticGray:\n    case GrayScale:\n    {\n      if (header.bits_per_pixel != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case StaticColor:\n    case PseudoColor:\n    {\n      if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n          (header.ncolors == 0))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case TrueColor:\n    case DirectColor:\n    {\n      if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n          (header.bits_per_pixel != 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    {\n      if (header.pixmap_depth != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case XYPixmap:\n    case ZPixmap:\n    {\n      if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      switch (header.bitmap_pad)\n      {\n        case 8:\n        case 16:\n        case 32:\n          break;\n        default:\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_unit)\n  {\n    case 8:\n    case 16:\n    case 32:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.byte_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_bit_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  if (header.ncolors > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  length=(size_t) (header.header_size-sz_XWDheader);\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      colors=(XColor *) AcquireQuantumMemory((size_t) header.ncolors,\n        sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask,exception);\n              SetPixelRed(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].red),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask,exception);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].green),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask,exception);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=(Quantum) ConstrainColormapIndex(image,(ssize_t)\n              XGetPixel(ximage,(int) x,(int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X W D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXWDImage() adds properties for the XWD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXWDImage method is:\n%\n%      size_t RegisterXWDImage(void)\n%\n*/\nModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X W D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXWDImage() removes format registrations made by the\n%  XWD module from the list of supported formats.\n%\n%  The format of the UnregisterXWDImage method is:\n%\n%      UnregisterXWDImage(void)\n%\n*/\nModuleExport void UnregisterXWDImage(void)\n{\n  (void) UnregisterMagickInfo(\"XWD\");\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X W D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXWDImage() writes an image to a file in X window dump\n%  rasterfile format.\n%\n%  The format of the WriteXWDImage method is:\n%\n%      MagickBooleanType WriteXWDImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    bytes_per_line,\n    length,\n    scanline_pad;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  XWDFileHeader\n    xwd_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns != (CARD32) image->columns) ||\n      (image->rows != (CARD32) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  if ((image->storage_class == PseudoClass) && (image->colors > 256))\n    (void) SetImageType(image,TrueColorType,exception);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize XWD file header.\n  */\n  (void) memset(&xwd_info,0,sizeof(xwd_info));\n  xwd_info.header_size=(CARD32) sz_XWDheader;\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    xwd_info.header_size+=(CARD32) strlen(value);\n  xwd_info.header_size++;\n  xwd_info.file_version=(CARD32) XWD_FILE_VERSION;\n  xwd_info.pixmap_format=(CARD32) ZPixmap;\n  xwd_info.pixmap_depth=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.pixmap_width=(CARD32) image->columns;\n  xwd_info.pixmap_height=(CARD32) image->rows;\n  xwd_info.xoffset=(CARD32) 0;\n  xwd_info.byte_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_unit=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  xwd_info.bitmap_bit_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_pad=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  bits_per_pixel=(size_t) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.bits_per_pixel=(CARD32) bits_per_pixel;\n  bytes_per_line=(CARD32) ((((xwd_info.bits_per_pixel*\n    xwd_info.pixmap_width)+((xwd_info.bitmap_pad)-1))/\n    (xwd_info.bitmap_pad))*((xwd_info.bitmap_pad) >> 3));\n  xwd_info.bytes_per_line=(CARD32) bytes_per_line;\n  xwd_info.visual_class=(CARD32)\n    (image->storage_class == DirectClass ? DirectColor : PseudoColor);\n  xwd_info.red_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff0000 : 0);\n  xwd_info.green_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff00 : 0);\n  xwd_info.blue_mask=(CARD32) (image->storage_class == DirectClass ? 0xff : 0);\n  xwd_info.bits_per_rgb=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.colormap_entries=(CARD32)\n    (image->storage_class == DirectClass ? 256 : image->colors);\n  xwd_info.ncolors=(unsigned int)\n    (image->storage_class == DirectClass ? 0 : image->colors);\n  xwd_info.window_width=(CARD32) image->columns;\n  xwd_info.window_height=(CARD32) image->rows;\n  xwd_info.window_x=0;\n  xwd_info.window_y=0;\n  xwd_info.window_bdrwidth=(CARD32) 0;\n  /*\n    Write XWD header.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &xwd_info,sizeof(xwd_info));\n  (void) WriteBlob(image,sz_XWDheader,(unsigned char *) &xwd_info);\n  if (value != (const char *) NULL)\n    (void) WriteBlob(image,strlen(value),(unsigned char *) value);\n  (void) WriteBlob(image,1,(const unsigned char *) \"\\0\");\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      XColor\n        *colors;\n\n      XWDColor\n        color;\n\n      /*\n        Dump colormap to file.\n      */\n      (void) memset(&color,0,sizeof(color));\n      colors=(XColor *) AcquireQuantumMemory((size_t) image->colors,\n        sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        colors[i].pixel=(unsigned long) i;\n        colors[i].red=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].red));\n        colors[i].green=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].green));\n        colors[i].blue=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].blue));\n        colors[i].flags=(char) (DoRed | DoGreen | DoBlue);\n        colors[i].pad='\\0';\n        if ((int) (*(char *) &lsb_first) != 0)\n          {\n            MSBOrderLong((unsigned char *) &colors[i].pixel,\n              sizeof(colors[i].pixel));\n            MSBOrderShort((unsigned char *) &colors[i].red,3*\n              sizeof(colors[i].red));\n          }\n      }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        color.pixel=(CARD32) colors[i].pixel;\n        color.red=colors[i].red;\n        color.green=colors[i].green;\n        color.blue=colors[i].blue;\n        color.flags=(CARD8) colors[i].flags;\n        count=WriteBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != (ssize_t) sz_XWDColor)\n          break;\n      }\n      colors=(XColor *) RelinquishMagickMemory(colors);\n    }\n  /*\n    Allocate memory for pixels.\n  */\n  length=3*bytes_per_line;\n  if (image->storage_class == PseudoClass)\n    length=bytes_per_line;\n  pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,length);\n  /*\n    Convert MIFF to XWD raster pixels.\n  */\n  scanline_pad=(bytes_per_line-((image->columns*bits_per_pixel) >> 3));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    if (image->storage_class == PseudoClass)\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(unsigned char) GetPixelIndex(image,p);\n          p+=GetPixelChannels(image);\n        }\n      }\n    else\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n        *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n        *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n        p+=GetPixelChannels(image);\n      }\n    for (x=0; x < (ssize_t) scanline_pad; x++)\n      *q++='\\0';\n    length=(size_t) (q-pixels);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(y < (ssize_t) image->rows ? MagickFalse :  MagickTrue);\n}\n#endif\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            X   X  W   W  DDDD                               %\n%                             X X   W   W  D   D                              %\n%                              X    W   W  D   D                              %\n%                             X X   W W W  D   D                              %\n%                            X   X   W W   DDDD                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write X Windows System Window Dump Format               %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#if defined(MAGICKCORE_X11_DELEGATE)\n#include \"MagickCore/xwindow-private.h\"\n#if !defined(vms)\n#include <X11/XWDFile.h>\n#else\n#include \"XWDFile.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations.\n*/\n#if defined(MAGICKCORE_X11_DELEGATE)\nstatic MagickBooleanType\n  WriteXWDImage(const ImageInfo *,Image *,ExceptionInfo *);\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s X W D                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsXWD() returns MagickTrue if the image format type, identified by the\n%  magick string, is XWD.\n%\n%  The format of the IsXWD method is:\n%\n%      MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsXWD(const unsigned char *magick,const size_t length)\n{\n  if (length < 8)\n    return(MagickFalse);\n  if (memcmp(magick+1,\"\\000\\000\",2) == 0)\n    {\n      if (memcmp(magick+4,\"\\007\\000\\000\",3) == 0)\n        return(MagickTrue);\n      if (memcmp(magick+5,\"\\000\\000\\007\",3) == 0)\n        return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d X W D I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadXWDImage() reads an X Window System window dump image file and\n%  returns it.  It allocates the memory necessary for the new Image structure\n%  and returns a pointer to the new image.\n%\n%  The format of the ReadXWDImage method is:\n%\n%      Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((MagickSizeType) header.xoffset >= GetBlobSize(image))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  switch (header.visual_class)\n  {\n    case StaticGray:\n    case GrayScale:\n    {\n      if (header.bits_per_pixel != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case StaticColor:\n    case PseudoColor:\n    {\n      if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) ||\n          (header.colormap_entries == 0))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case TrueColor:\n    case DirectColor:\n    {\n      if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) &&\n          (header.bits_per_pixel != 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.pixmap_format)\n  {\n    case XYBitmap:\n    {\n      if (header.pixmap_depth != 1)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      break;\n    }\n    case XYPixmap:\n    case ZPixmap:\n    {\n      if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      switch (header.bitmap_pad)\n      {\n        case 8:\n        case 16:\n        case 32:\n          break;\n        default:\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_unit)\n  {\n    case 8:\n    case 16:\n    case 32:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.byte_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  switch (header.bitmap_bit_order)\n  {\n    case LSBFirst:\n    case MSBFirst:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  length=(size_t) (header.header_size-sz_XWDheader);\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||\n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      if (length > ((~0UL)/sizeof(*colors)))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                red_shift) & red_mask,exception);\n              SetPixelRed(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].red),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                green_shift) & green_mask,exception);\n              SetPixelGreen(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].green),q);\n              index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >>\n                blue_shift) & blue_mask,exception);\n              SetPixelBlue(image,ScaleShortToQuantum(\n                colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=(Quantum) ConstrainColormapIndex(image,(ssize_t)\n              XGetPixel(ximage,(int) x,(int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r X W D I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterXWDImage() adds properties for the XWD image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterXWDImage method is:\n%\n%      size_t RegisterXWDImage(void)\n%\n*/\nModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r X W D I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterXWDImage() removes format registrations made by the\n%  XWD module from the list of supported formats.\n%\n%  The format of the UnregisterXWDImage method is:\n%\n%      UnregisterXWDImage(void)\n%\n*/\nModuleExport void UnregisterXWDImage(void)\n{\n  (void) UnregisterMagickInfo(\"XWD\");\n}\n\f\n#if defined(MAGICKCORE_X11_DELEGATE)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e X W D I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteXWDImage() writes an image to a file in X window dump\n%  rasterfile format.\n%\n%  The format of the WriteXWDImage method is:\n%\n%      MagickBooleanType WriteXWDImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteXWDImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    bytes_per_line,\n    length,\n    scanline_pad;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  XWDFileHeader\n    xwd_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns != (CARD32) image->columns) ||\n      (image->rows != (CARD32) image->rows))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  if ((image->storage_class == PseudoClass) && (image->colors > 256))\n    (void) SetImageType(image,TrueColorType,exception);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize XWD file header.\n  */\n  (void) memset(&xwd_info,0,sizeof(xwd_info));\n  xwd_info.header_size=(CARD32) sz_XWDheader;\n  value=GetImageProperty(image,\"comment\",exception);\n  if (value != (const char *) NULL)\n    xwd_info.header_size+=(CARD32) strlen(value);\n  xwd_info.header_size++;\n  xwd_info.file_version=(CARD32) XWD_FILE_VERSION;\n  xwd_info.pixmap_format=(CARD32) ZPixmap;\n  xwd_info.pixmap_depth=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.pixmap_width=(CARD32) image->columns;\n  xwd_info.pixmap_height=(CARD32) image->rows;\n  xwd_info.xoffset=(CARD32) 0;\n  xwd_info.byte_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_unit=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  xwd_info.bitmap_bit_order=(CARD32) MSBFirst;\n  xwd_info.bitmap_pad=(CARD32) (image->storage_class == DirectClass ? 32 : 8);\n  bits_per_pixel=(size_t) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.bits_per_pixel=(CARD32) bits_per_pixel;\n  bytes_per_line=(CARD32) ((((xwd_info.bits_per_pixel*\n    xwd_info.pixmap_width)+((xwd_info.bitmap_pad)-1))/\n    (xwd_info.bitmap_pad))*((xwd_info.bitmap_pad) >> 3));\n  xwd_info.bytes_per_line=(CARD32) bytes_per_line;\n  xwd_info.visual_class=(CARD32)\n    (image->storage_class == DirectClass ? DirectColor : PseudoColor);\n  xwd_info.red_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff0000 : 0);\n  xwd_info.green_mask=(CARD32)\n    (image->storage_class == DirectClass ? 0xff00 : 0);\n  xwd_info.blue_mask=(CARD32) (image->storage_class == DirectClass ? 0xff : 0);\n  xwd_info.bits_per_rgb=(CARD32) (image->storage_class == DirectClass ? 24 : 8);\n  xwd_info.colormap_entries=(CARD32)\n    (image->storage_class == DirectClass ? 256 : image->colors);\n  xwd_info.ncolors=(unsigned int)\n    (image->storage_class == DirectClass ? 0 : image->colors);\n  xwd_info.window_width=(CARD32) image->columns;\n  xwd_info.window_height=(CARD32) image->rows;\n  xwd_info.window_x=0;\n  xwd_info.window_y=0;\n  xwd_info.window_bdrwidth=(CARD32) 0;\n  /*\n    Write XWD header.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &xwd_info,sizeof(xwd_info));\n  (void) WriteBlob(image,sz_XWDheader,(unsigned char *) &xwd_info);\n  if (value != (const char *) NULL)\n    (void) WriteBlob(image,strlen(value),(unsigned char *) value);\n  (void) WriteBlob(image,1,(const unsigned char *) \"\\0\");\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n      XColor\n        *colors;\n\n      XWDColor\n        color;\n\n      /*\n        Dump colormap to file.\n      */\n      (void) memset(&color,0,sizeof(color));\n      colors=(XColor *) AcquireQuantumMemory((size_t) image->colors,\n        sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        colors[i].pixel=(unsigned long) i;\n        colors[i].red=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].red));\n        colors[i].green=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].green));\n        colors[i].blue=ScaleQuantumToShort(ClampToQuantum(\n          image->colormap[i].blue));\n        colors[i].flags=(char) (DoRed | DoGreen | DoBlue);\n        colors[i].pad='\\0';\n        if ((int) (*(char *) &lsb_first) != 0)\n          {\n            MSBOrderLong((unsigned char *) &colors[i].pixel,\n              sizeof(colors[i].pixel));\n            MSBOrderShort((unsigned char *) &colors[i].red,3*\n              sizeof(colors[i].red));\n          }\n      }\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        color.pixel=(CARD32) colors[i].pixel;\n        color.red=colors[i].red;\n        color.green=colors[i].green;\n        color.blue=colors[i].blue;\n        color.flags=(CARD8) colors[i].flags;\n        count=WriteBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != (ssize_t) sz_XWDColor)\n          break;\n      }\n      colors=(XColor *) RelinquishMagickMemory(colors);\n    }\n  /*\n    Allocate memory for pixels.\n  */\n  length=3*bytes_per_line;\n  if (image->storage_class == PseudoClass)\n    length=bytes_per_line;\n  pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) memset(pixels,0,length);\n  /*\n    Convert MIFF to XWD raster pixels.\n  */\n  scanline_pad=(bytes_per_line-((image->columns*bits_per_pixel) >> 3));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    if (image->storage_class == PseudoClass)\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          *q++=(unsigned char) GetPixelIndex(image,p);\n          p+=GetPixelChannels(image);\n        }\n      }\n    else\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n        *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n        *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n        p+=GetPixelChannels(image);\n      }\n    for (x=0; x < (ssize_t) scanline_pad; x++)\n      *q++='\\0';\n    length=(size_t) (q-pixels);\n    count=WriteBlob(image,length,pixels);\n    if (count != (ssize_t) length)\n      break;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(y < (ssize_t) image->rows ? MagickFalse :  MagickTrue);\n}\n#endif\n"], "filenames": ["coders/xwd.c"], "buggy_code_start_loc": [244], "buggy_code_end_loc": [696], "fixing_code_start_loc": [245], "fixing_code_end_loc": [700], "type": "CWE-125", "message": "The XWD image (X Window System window dumping file) parsing component in ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (application crash resulting from an out-of-bounds Read) in ReadXWDImage in coders/xwd.c by crafting a corrupted XWD image file, a different vulnerability than CVE-2019-11472.", "other": {"cve": {"id": "CVE-2019-15139", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-18T19:15:09.637", "lastModified": "2020-09-08T00:15:20.790", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The XWD image (X Window System window dumping file) parsing component in ImageMagick 7.0.8-41 Q16 allows attackers to cause a denial-of-service (application crash resulting from an out-of-bounds Read) in ReadXWDImage in coders/xwd.c by crafting a corrupted XWD image file, a different vulnerability than CVE-2019-11472."}, {"lang": "es", "value": "El componente de an\u00e1lisis de imagen XWD (archivo de volcado de ventana X Window System) en ImageMagick versi\u00f3n 7.0.8-41 Q16, permite a atacantes causar una denegaci\u00f3n de servicio (bloqueo de aplicaci\u00f3n resultante de una lectura fuera de l\u00edmites) en la funci\u00f3n ReadXWDImage en el archivo coders/xwd.c mediante el dise\u00f1o de un archivo de imagen XWD corrupto, una vulnerabilidad diferente de CVE-2019-11472."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-41:q16:*:*:*:*:*:*", "matchCriteriaId": "34C2A939-19C7-4BC0-8DE5-E3D612C99B0E"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00040.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00042.html", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/c78993d138bf480ab4652b5a48379d4ff75ba5f7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1553", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00007.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3IYH7QSNXXOIDFTYLY455ANZ3JWQ7FCS/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FS76VNCFL3FVRMGXQEMHBOKA7EE46BTS/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c78993d138bf480ab4652b5a48379d4ff75ba5f7"}}