{"buggy_code": ["/*\n * Copyright \u00a9 2012,2017  Google, Inc.\n * Copyright \u00a9 2021 Behdad Esfahbod\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_BIT_SET_INVERTIBLE_HH\n#define HB_BIT_SET_INVERTIBLE_HH\n\n#include \"hb.hh\"\n#include \"hb-bit-set.hh\"\n\n\nstruct hb_bit_set_invertible_t\n{\n  hb_bit_set_t s;\n  bool inverted;\n\n  hb_bit_set_invertible_t () { init (); }\n  ~hb_bit_set_invertible_t () { fini (); }\n\n  void init () { s.init (); inverted = false; }\n  void fini () { s.fini (); }\n  void err () { s.err (); }\n  bool in_error () const { return s.in_error (); }\n  explicit operator bool () const { return !is_empty (); }\n\n  void reset () { s.reset (); inverted = false; }\n  void clear () { s.clear (); inverted = false; }\n  void invert () { inverted = !inverted; }\n\n  bool is_empty () const\n  {\n    hb_codepoint_t v = INVALID;\n    next (&v);\n    return v == INVALID;\n  }\n  hb_codepoint_t get_min () const\n  {\n    hb_codepoint_t v = INVALID;\n    next (&v);\n    return v;\n  }\n  hb_codepoint_t get_max () const\n  {\n    hb_codepoint_t v = INVALID;\n    previous (&v);\n    return v;\n  }\n  unsigned int get_population () const\n  { return inverted ? INVALID - s.get_population () : s.get_population (); }\n\n\n  void add (hb_codepoint_t g) { unlikely (inverted) ? s.del (g) : s.add (g); }\n  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n  { return unlikely (inverted) ? (s.del_range (a, b), true) : s.add_range (a, b); }\n\n  template <typename T>\n  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n  { inverted ? s.del_array (array, count, stride) : s.add_array (array, count, stride); }\n  template <typename T>\n  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n\n  /* Might return false if array looks unsorted.\n   * Used for faster rejection of corrupt data. */\n  template <typename T>\n  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n  { return inverted ? s.del_sorted_array (array, count, stride) : s.add_sorted_array (array, count, stride); }\n  template <typename T>\n  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n\n  void del (hb_codepoint_t g) { unlikely (inverted) ? s.add (g) : s.del (g); }\n  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n  { unlikely (inverted) ? (void) s.add_range (a, b) : s.del_range (a, b); }\n\n  bool get (hb_codepoint_t g) const { return s.get (g) ^ inverted; }\n\n  /* Has interface. */\n  static constexpr bool SENTINEL = false;\n  typedef bool value_t;\n  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n  /* Predicate. */\n  bool operator () (hb_codepoint_t k) const { return has (k); }\n\n  /* Sink interface. */\n  hb_bit_set_invertible_t& operator << (hb_codepoint_t v)\n  { add (v); return *this; }\n  hb_bit_set_invertible_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n  { add_range (range.first, range.second); return *this; }\n\n  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const\n  {\n    hb_codepoint_t c = first - 1;\n    return next (&c) && c <= last;\n  }\n\n  void set (const hb_bit_set_invertible_t &other) { s.set (other.s); inverted = other.inverted; }\n\n  bool is_equal (const hb_bit_set_invertible_t &other) const\n  {\n    if (likely (inverted == other.inverted))\n      return s.is_equal (other.s);\n    else\n    {\n      /* TODO Add iter_ranges() and use here. */\n      auto it1 = iter ();\n      auto it2 = other.iter ();\n      return hb_all (+ hb_zip (it1, it2)\n\t\t     | hb_map ([](hb_pair_t<hb_codepoint_t, hb_codepoint_t> _) { return _.first == _.second; }));\n    }\n  }\n\n  bool is_subset (const hb_bit_set_invertible_t &larger_set) const\n  {\n    if (unlikely (inverted != larger_set.inverted))\n      return hb_all (hb_iter (s) | hb_map (larger_set.s));\n    else\n      return unlikely (inverted) ? larger_set.s.is_subset (s) : s.is_subset (larger_set.s);\n  }\n\n  protected:\n  template <typename Op>\n  void process (const Op& op, const hb_bit_set_invertible_t &other)\n  { s.process (op, other.s); }\n  public:\n  void union_ (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_and, other);\n      else\n\tprocess (hb_bitwise_or, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_gt, other);\n      else\n\tprocess (hb_bitwise_lt, other);\n    }\n    inverted = inverted || other.inverted;\n  }\n  void intersect (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other);\n    }\n    inverted = inverted && other.inverted;\n  }\n  void subtract (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other);\n    }\n    inverted = inverted && !other.inverted;\n  }\n  void symmetric_difference (const hb_bit_set_invertible_t &other)\n  {\n    process (hb_bitwise_xor, other);\n    inverted = inverted ^ other.inverted;\n  }\n\n  bool next (hb_codepoint_t *codepoint) const\n  {\n    if (likely (!inverted))\n      return s.next (codepoint);\n\n    auto old = *codepoint;\n    if (unlikely (old + 1 == INVALID))\n    {\n      *codepoint = INVALID;\n      return false;\n    }\n\n    auto v = old;\n    s.next (&v);\n    if (old + 1 < v)\n    {\n      *codepoint = old + 1;\n      return true;\n    }\n\n    v = old;\n    s.next_range (&old, &v);\n\n    *codepoint = v + 1;\n    return *codepoint != INVALID;\n  }\n  bool previous (hb_codepoint_t *codepoint) const\n  {\n    if (likely (!inverted))\n      return s.previous (codepoint);\n\n    auto old = *codepoint;\n    if (unlikely (old - 1 == INVALID))\n    {\n      *codepoint = INVALID;\n      return false;\n    }\n\n    auto v = old;\n    s.previous (&v);\n\n    if (old - 1 > v || v == INVALID)\n    {\n      *codepoint = old - 1;\n      return true;\n    }\n\n    v = old;\n    s.previous_range (&v, &old);\n\n    *codepoint = v - 1;\n    return *codepoint != INVALID;\n  }\n  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n  {\n    if (likely (!inverted))\n      return s.next_range (first, last);\n\n    if (!next (last))\n    {\n      *last = *first = INVALID;\n      return false;\n    }\n\n    *first = *last;\n    s.next (last);\n    --*last;\n    return true;\n  }\n  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n  {\n    if (likely (!inverted))\n      return s.previous_range (first, last);\n\n    if (!previous (first))\n    {\n      *last = *first = INVALID;\n      return false;\n    }\n\n    *last = *first;\n    s.previous (first);\n    ++*first;\n    return true;\n  }\n\n  static constexpr hb_codepoint_t INVALID = hb_bit_set_t::INVALID;\n\n  /*\n   * Iterator implementation.\n   */\n  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n  {\n    static constexpr bool is_sorted_iterator = true;\n    iter_t (const hb_bit_set_invertible_t &s_ = Null (hb_bit_set_invertible_t),\n\t    bool init = true) : s (&s_), v (INVALID), l(0)\n    {\n      if (init)\n      {\n\tl = s->get_population () + 1;\n\t__next__ ();\n      }\n    }\n\n    typedef hb_codepoint_t __item_t__;\n    hb_codepoint_t __item__ () const { return v; }\n    bool __more__ () const { return v != INVALID; }\n    void __next__ () { s->next (&v); if (l) l--; }\n    void __prev__ () { s->previous (&v); }\n    unsigned __len__ () const { return l; }\n    iter_t end () const { return iter_t (*s, false); }\n    bool operator != (const iter_t& o) const\n    { return s != o.s || v != o.v; }\n\n    protected:\n    const hb_bit_set_invertible_t *s;\n    hb_codepoint_t v;\n    unsigned l;\n  };\n  iter_t iter () const { return iter_t (*this); }\n  operator iter_t () const { return iter (); }\n};\n\n\n#endif /* HB_BIT_SET_INVERTIBLE_HH */\n", "/*\n * Copyright \u00a9 2018  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#include \"hb-map.hh\"\n\n\n/**\n * SECTION:hb-map\n * @title: hb-map\n * @short_description: Object representing integer to integer mapping\n * @include: hb.h\n *\n * Map objects are integer-to-integer hash-maps.  Currently they are\n * not used in the HarfBuzz public API, but are provided for client's\n * use if desired.\n **/\n\n\n/**\n * hb_map_create: (Xconstructor)\n *\n * Creates a new, initially empty map.\n *\n * Return value: (transfer full): The new #hb_map_t\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_create ()\n{\n  hb_map_t *map;\n\n  if (!(map = hb_object_create<hb_map_t> ()))\n    return hb_map_get_empty ();\n\n  map->init_shallow ();\n\n  return map;\n}\n\n/**\n * hb_map_get_empty:\n *\n * Fetches the singleton empty #hb_map_t.\n *\n * Return value: (transfer full): The empty #hb_map_t\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_get_empty ()\n{\n  return const_cast<hb_map_t *> (&Null (hb_map_t));\n}\n\n/**\n * hb_map_reference: (skip)\n * @map: A map\n *\n * Increases the reference count on a map.\n *\n * Return value: (transfer full): The map\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_reference (hb_map_t *map)\n{\n  return hb_object_reference (map);\n}\n\n/**\n * hb_map_destroy: (skip)\n * @map: A map\n *\n * Decreases the reference count on a map. When\n * the reference count reaches zero, the map is\n * destroyed, freeing all memory.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_destroy (hb_map_t *map)\n{\n  if (!hb_object_destroy (map)) return;\n\n  map->fini_shallow ();\n\n  hb_free (map);\n}\n\n/**\n * hb_map_set_user_data: (skip)\n * @map: A map\n * @key: The user-data key to set\n * @data: A pointer to the user data to set\n * @destroy: (nullable): A callback to call when @data is not needed anymore\n * @replace: Whether to replace an existing data with the same key\n *\n * Attaches a user-data key/data pair to the specified map.\n *\n * Return value: %true if success, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_set_user_data (hb_map_t           *map,\n\t\t      hb_user_data_key_t *key,\n\t\t      void *              data,\n\t\t      hb_destroy_func_t   destroy,\n\t\t      hb_bool_t           replace)\n{\n  return hb_object_set_user_data (map, key, data, destroy, replace);\n}\n\n/**\n * hb_map_get_user_data: (skip)\n * @map: A map\n * @key: The user-data key to query\n *\n * Fetches the user data associated with the specified key,\n * attached to the specified map.\n *\n * Return value: (transfer none): A pointer to the user data\n *\n * Since: 1.7.7\n **/\nvoid *\nhb_map_get_user_data (hb_map_t           *map,\n\t\t      hb_user_data_key_t *key)\n{\n  return hb_object_get_user_data (map, key);\n}\n\n\n/**\n * hb_map_allocation_successful:\n * @map: A map\n *\n * Tests whether memory allocation for a set was successful.\n *\n * Return value: %true if allocation succeeded, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_allocation_successful (const hb_map_t  *map)\n{\n  return map->successful;\n}\n\n\n/**\n * hb_map_set:\n * @map: A map\n * @key: The key to store in the map\n * @value: The value to store for @key\n *\n * Stores @key:@value in the map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_set (hb_map_t       *map,\n\t    hb_codepoint_t  key,\n\t    hb_codepoint_t  value)\n{\n  /* Immutable-safe. */\n  map->set (key, value);\n}\n\n/**\n * hb_map_get:\n * @map: A map\n * @key: The key to query\n *\n * Fetches the value stored for @key in @map.\n *\n * Since: 1.7.7\n **/\nhb_codepoint_t\nhb_map_get (const hb_map_t *map,\n\t    hb_codepoint_t  key)\n{\n  return map->get (key);\n}\n\n/**\n * hb_map_del:\n * @map: A map\n * @key: The key to delete\n *\n * Removes @key and its stored value from @map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_del (hb_map_t       *map,\n\t    hb_codepoint_t  key)\n{\n  /* Immutable-safe. */\n  map->del (key);\n}\n\n/**\n * hb_map_has:\n * @map: A map\n * @key: The key to query\n *\n * Tests whether @key is an element of @map.\n *\n * Return value: %true if @key is found in @map, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_has (const hb_map_t *map,\n\t    hb_codepoint_t  key)\n{\n  return map->has (key);\n}\n\n\n/**\n * hb_map_clear:\n * @map: A map\n *\n * Clears out the contents of @map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n\n  return map->clear ();\n}\n\n/**\n * hb_map_is_empty:\n * @map: A map\n *\n * Tests whether @map is empty (contains no elements).\n *\n * Return value: %true if @map is empty\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_is_empty (const hb_map_t *map)\n{\n  return map->is_empty ();\n}\n\n/**\n * hb_map_get_population:\n * @map: A map\n *\n * Returns the number of key-value pairs in the map.\n *\n * Return value: The population of @map\n *\n * Since: 1.7.7\n **/\nunsigned int\nhb_map_get_population (const hb_map_t *map)\n{\n  return map->get_population ();\n}\n", "/*\n * Copyright \u00a9 2018  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_MAP_HH\n#define HB_MAP_HH\n\n#include \"hb.hh\"\n\n\n/*\n * hb_hashmap_t\n */\n\ntemplate <typename K, typename V,\n\t  K kINVALID = hb_is_pointer (K) ? 0 : hb_is_signed (K) ? hb_int_min (K) : (K) -1,\n\t  V vINVALID = hb_is_pointer (V) ? 0 : hb_is_signed (V) ? hb_int_min (V) : (V) -1>\nstruct hb_hashmap_t\n{\n  HB_DELETE_COPY_ASSIGN (hb_hashmap_t);\n  hb_hashmap_t ()  { init (); }\n  ~hb_hashmap_t () { fini (); }\n\n  static_assert (hb_is_integral (K) || hb_is_pointer (K), \"\");\n  static_assert (hb_is_integral (V) || hb_is_pointer (V), \"\");\n\n  struct item_t\n  {\n    K key;\n    V value;\n    uint32_t hash;\n\n    void clear () { key = kINVALID; value = vINVALID; hash = 0; }\n\n    bool operator == (const K &o) { return hb_deref (key) == hb_deref (o); }\n    bool operator == (const item_t &o) { return *this == o.key; }\n    bool is_unused () const    { return key == kINVALID; }\n    bool is_tombstone () const { return key != kINVALID && value == vINVALID; }\n    bool is_real () const { return key != kINVALID && value != vINVALID; }\n    hb_pair_t<K, V> get_pair() const { return hb_pair_t<K, V> (key, value); }\n  };\n\n  hb_object_header_t header;\n  bool successful; /* Allocations successful */\n  unsigned int population; /* Not including tombstones. */\n  unsigned int occupancy; /* Including tombstones. */\n  unsigned int mask;\n  unsigned int prime;\n  item_t *items;\n\n  void init_shallow ()\n  {\n    successful = true;\n    population = occupancy = 0;\n    mask = 0;\n    prime = 0;\n    items = nullptr;\n  }\n  void init ()\n  {\n    hb_object_init (this);\n    init_shallow ();\n  }\n  void fini_shallow ()\n  {\n    hb_free (items);\n    items = nullptr;\n    population = occupancy = 0;\n  }\n  void fini ()\n  {\n    hb_object_fini (this);\n    fini_shallow ();\n  }\n\n  void reset ()\n  {\n    successful = true;\n    clear ();\n  }\n\n  bool in_error () const { return !successful; }\n\n  bool resize ()\n  {\n    if (unlikely (!successful)) return false;\n\n    unsigned int power = hb_bit_storage (population * 2 + 8);\n    unsigned int new_size = 1u << power;\n    item_t *new_items = (item_t *) hb_malloc ((size_t) new_size * sizeof (item_t));\n    if (unlikely (!new_items))\n    {\n      successful = false;\n      return false;\n    }\n    for (auto &_ : hb_iter (new_items, new_size))\n      _.clear ();\n\n    unsigned int old_size = mask + 1;\n    item_t *old_items = items;\n\n    /* Switch to new, empty, array. */\n    population = occupancy = 0;\n    mask = new_size - 1;\n    prime = prime_for (power);\n    items = new_items;\n\n    /* Insert back old items. */\n    if (old_items)\n      for (unsigned int i = 0; i < old_size; i++)\n\tif (old_items[i].is_real ())\n\t  set_with_hash (old_items[i].key,\n\t\t\t old_items[i].hash,\n\t\t\t old_items[i].value);\n\n    hb_free (old_items);\n\n    return true;\n  }\n\n  bool set (K key, V value)\n  {\n    return set_with_hash (key, hb_hash (key), value);\n  }\n\n  V get (K key) const\n  {\n    if (unlikely (!items)) return vINVALID;\n    unsigned int i = bucket_for (key);\n    return items[i].is_real () && items[i] == key ? items[i].value : vINVALID;\n  }\n\n  void del (K key) { set (key, vINVALID); }\n\n  /* Has interface. */\n  static constexpr V SENTINEL = vINVALID;\n  typedef V value_t;\n  value_t operator [] (K k) const { return get (k); }\n  bool has (K k, V *vp = nullptr) const\n  {\n    V v = (*this)[k];\n    if (vp) *vp = v;\n    return v != SENTINEL;\n  }\n  /* Projection. */\n  V operator () (K k) const { return get (k); }\n\n  void clear ()\n  {\n    if (items)\n      for (auto &_ : hb_iter (items, mask + 1))\n\t_.clear ();\n\n    population = occupancy = 0;\n  }\n\n  bool is_empty () const { return population == 0; }\n  explicit operator bool () const { return !is_empty (); }\n\n  unsigned int get_population () const { return population; }\n\n  /*\n   * Iterator\n   */\n  auto iter () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::get_pair)\n  )\n  auto keys () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::key)\n    | hb_map (hb_ridentity)\n  )\n  auto values () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::value)\n    | hb_map (hb_ridentity)\n  )\n\n  /* Sink interface. */\n  hb_hashmap_t& operator << (const hb_pair_t<K, V>& v)\n  { set (v.first, v.second); return *this; }\n\n  protected:\n\n  bool set_with_hash (K key, uint32_t hash, V value)\n  {\n    if (unlikely (!successful)) return false;\n    if (unlikely (key == kINVALID)) return true;\n    if (unlikely ((occupancy + occupancy / 2) >= mask && !resize ())) return false;\n    unsigned int i = bucket_for_hash (key, hash);\n\n    if (value == vINVALID && items[i].key != key)\n      return true; /* Trying to delete non-existent key. */\n\n    if (!items[i].is_unused ())\n    {\n      occupancy--;\n      if (!items[i].is_tombstone ())\n\tpopulation--;\n    }\n\n    items[i].key = key;\n    items[i].value = value;\n    items[i].hash = hash;\n\n    occupancy++;\n    if (!items[i].is_tombstone ())\n      population++;\n\n    return true;\n  }\n\n  unsigned int bucket_for (K key) const\n  {\n    return bucket_for_hash (key, hb_hash (key));\n  }\n\n  unsigned int bucket_for_hash (K key, uint32_t hash) const\n  {\n    unsigned int i = hash % prime;\n    unsigned int step = 0;\n    unsigned int tombstone = (unsigned) -1;\n    while (!items[i].is_unused ())\n    {\n      if (items[i].hash == hash && items[i] == key)\n\treturn i;\n      if (tombstone == (unsigned) -1 && items[i].is_tombstone ())\n\ttombstone = i;\n      i = (i + ++step) & mask;\n    }\n    return tombstone == (unsigned) -1 ? i : tombstone;\n  }\n\n  static unsigned int prime_for (unsigned int shift)\n  {\n    /* Following comment and table copied from glib. */\n    /* Each table size has an associated prime modulo (the first prime\n     * lower than the table size) used to find the initial bucket. Probing\n     * then works modulo 2^n. The prime modulo is necessary to get a\n     * good distribution with poor hash functions.\n     */\n    /* Not declaring static to make all kinds of compilers happy... */\n    /*static*/ const unsigned int prime_mod [32] =\n    {\n      1,          /* For 1 << 0 */\n      2,\n      3,\n      7,\n      13,\n      31,\n      61,\n      127,\n      251,\n      509,\n      1021,\n      2039,\n      4093,\n      8191,\n      16381,\n      32749,\n      65521,      /* For 1 << 16 */\n      131071,\n      262139,\n      524287,\n      1048573,\n      2097143,\n      4194301,\n      8388593,\n      16777213,\n      33554393,\n      67108859,\n      134217689,\n      268435399,\n      536870909,\n      1073741789,\n      2147483647  /* For 1 << 31 */\n    };\n\n    if (unlikely (shift >= ARRAY_LENGTH (prime_mod)))\n      return prime_mod[ARRAY_LENGTH (prime_mod) - 1];\n\n    return prime_mod[shift];\n  }\n};\n\n/*\n * hb_map_t\n */\n\nstruct hb_map_t : hb_hashmap_t<hb_codepoint_t,\n\t\t\t       hb_codepoint_t,\n\t\t\t       HB_MAP_VALUE_INVALID,\n\t\t\t       HB_MAP_VALUE_INVALID> {};\n\n\n#endif /* HB_MAP_HH */\n", "/*\n * Copyright \u00a9 2012  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#include \"hb-set.hh\"\n\n\n/**\n * SECTION:hb-set\n * @title: hb-set\n * @short_description: Objects representing a set of integers\n * @include: hb.h\n *\n * Set objects represent a mathematical set of integer values.  They are\n * used in non-shaping APIs to query certain sets of characters or glyphs,\n * or other integer values.\n **/\n\n\n/**\n * hb_set_create: (Xconstructor)\n *\n * Creates a new, initially empty set.\n *\n * Return value: (transfer full): The new #hb_set_t\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_create ()\n{\n  hb_set_t *set;\n\n  if (!(set = hb_object_create<hb_set_t> ()))\n    return hb_set_get_empty ();\n\n  set->init_shallow ();\n\n  return set;\n}\n\n/**\n * hb_set_get_empty:\n *\n * Fetches the singleton empty #hb_set_t.\n *\n * Return value: (transfer full): The empty #hb_set_t\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_get_empty ()\n{\n  return const_cast<hb_set_t *> (&Null (hb_set_t));\n}\n\n/**\n * hb_set_reference: (skip)\n * @set: A set\n *\n * Increases the reference count on a set.\n *\n * Return value: (transfer full): The set\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_reference (hb_set_t *set)\n{\n  return hb_object_reference (set);\n}\n\n/**\n * hb_set_destroy: (skip)\n * @set: A set\n *\n * Decreases the reference count on a set. When\n * the reference count reaches zero, the set is\n * destroyed, freeing all memory.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_destroy (hb_set_t *set)\n{\n  if (!hb_object_destroy (set)) return;\n\n  set->fini_shallow ();\n\n  hb_free (set);\n}\n\n/**\n * hb_set_set_user_data: (skip)\n * @set: A set\n * @key: The user-data key to set\n * @data: A pointer to the user data to set\n * @destroy: (nullable): A callback to call when @data is not needed anymore\n * @replace: Whether to replace an existing data with the same key\n *\n * Attaches a user-data key/data pair to the specified set.\n *\n * Return value: %true if success, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_set_user_data (hb_set_t           *set,\n\t\t      hb_user_data_key_t *key,\n\t\t      void *              data,\n\t\t      hb_destroy_func_t   destroy,\n\t\t      hb_bool_t           replace)\n{\n  return hb_object_set_user_data (set, key, data, destroy, replace);\n}\n\n/**\n * hb_set_get_user_data: (skip)\n * @set: A set\n * @key: The user-data key to query\n *\n * Fetches the user data associated with the specified key,\n * attached to the specified set.\n *\n * Return value: (transfer none): A pointer to the user data\n *\n * Since: 0.9.2\n **/\nvoid *\nhb_set_get_user_data (hb_set_t           *set,\n\t\t      hb_user_data_key_t *key)\n{\n  return hb_object_get_user_data (set, key);\n}\n\n\n/**\n * hb_set_allocation_successful:\n * @set: A set\n *\n * Tests whether memory allocation for a set was successful.\n *\n * Return value: %true if allocation succeeded, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_allocation_successful (const hb_set_t  *set)\n{\n  return !set->in_error ();\n}\n\n/**\n * hb_set_copy:\n * @set: A set\n *\n * Allocate a copy of @set.\n *\n * Return value: Newly-allocated set.\n *\n * Since: 2.8.2\n **/\nhb_set_t *\nhb_set_copy (const hb_set_t *set)\n{\n  hb_set_t *copy = hb_set_create ();\n  copy->set (*set);\n  return copy;\n}\n\n/**\n * hb_set_clear:\n * @set: A set\n *\n * Clears out the contents of a set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->clear ();\n}\n\n/**\n * hb_set_is_empty:\n * @set: a set.\n *\n * Tests whether a set is empty (contains no elements).\n *\n * Return value: %true if @set is empty\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_is_empty (const hb_set_t *set)\n{\n  return set->is_empty ();\n}\n\n/**\n * hb_set_has:\n * @set: A set\n * @codepoint: The element to query\n *\n * Tests whether @codepoint belongs to @set.\n *\n * Return value: %true if @codepoint is in @set, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_has (const hb_set_t *set,\n\t    hb_codepoint_t  codepoint)\n{\n  return set->has (codepoint);\n}\n\n/**\n * hb_set_add:\n * @set: A set\n * @codepoint: The element to add to @set\n *\n * Adds @codepoint to @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_add (hb_set_t       *set,\n\t    hb_codepoint_t  codepoint)\n{\n  /* Immutible-safe. */\n  set->add (codepoint);\n}\n\n/**\n * hb_set_add_range:\n * @set: A set\n * @first: The first element to add to @set\n * @last: The final element to add to @set\n *\n * Adds all of the elements from @first to @last\n * (inclusive) to @set.\n *\n * Since: 0.9.7\n **/\nvoid\nhb_set_add_range (hb_set_t       *set,\n\t\t  hb_codepoint_t  first,\n\t\t  hb_codepoint_t  last)\n{\n  /* Immutible-safe. */\n  set->add_range (first, last);\n}\n\n/**\n * hb_set_del:\n * @set: A set\n * @codepoint: Removes @codepoint from @set\n *\n * Removes @codepoint from @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_del (hb_set_t       *set,\n\t    hb_codepoint_t  codepoint)\n{\n  /* Immutible-safe. */\n  set->del (codepoint);\n}\n\n/**\n * hb_set_del_range:\n * @set: A set\n * @first: The first element to remove from @set\n * @last: The final element to remove from @set\n *\n * Removes all of the elements from @first to @last\n * (inclusive) from @set.\n *\n * If @last is #HB_SET_VALUE_INVALID, then all values\n * greater than or equal to @first are removed.\n *\n * Since: 0.9.7\n **/\nvoid\nhb_set_del_range (hb_set_t       *set,\n\t\t  hb_codepoint_t  first,\n\t\t  hb_codepoint_t  last)\n{\n  /* Immutible-safe. */\n  set->del_range (first, last);\n}\n\n/**\n * hb_set_is_equal:\n * @set: A set\n * @other: Another set\n *\n * Tests whether @set and @other are equal (contain the same\n * elements).\n *\n * Return value: %true if the two sets are equal, %false otherwise.\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_is_equal (const hb_set_t *set,\n\t\t const hb_set_t *other)\n{\n  return set->is_equal (*other);\n}\n\n/**\n * hb_set_is_subset:\n * @set: A set\n * @larger_set: Another set\n *\n * Tests whether @set is a subset of @larger_set.\n *\n * Return value: %true if the @set is a subset of (or equal to) @larger_set, %false otherwise.\n *\n * Since: 1.8.1\n **/\nhb_bool_t\nhb_set_is_subset (const hb_set_t *set,\n\t\t  const hb_set_t *larger_set)\n{\n  return set->is_subset (*larger_set);\n}\n\n/**\n * hb_set_set:\n * @set: A set\n * @other: Another set\n *\n * Makes the contents of @set equal to the contents of @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->set (*other);\n}\n\n/**\n * hb_set_union:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the union of @set and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->union_ (*other);\n}\n\n/**\n * hb_set_intersect:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the intersection of @set and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->intersect (*other);\n}\n\n/**\n * hb_set_subtract:\n * @set: A set\n * @other: Another set\n *\n * Subtracts the contents of @other from @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->subtract (*other);\n}\n\n/**\n * hb_set_symmetric_difference:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the symmetric difference of @set\n * and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->symmetric_difference (*other);\n}\n\n/**\n * hb_set_invert:\n * @set: A set\n *\n * Inverts the contents of @set.\n *\n * Since: 3.0.0\n **/\nvoid\nhb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->invert ();\n}\n\n/**\n * hb_set_get_population:\n * @set: A set\n *\n * Returns the number of elements in the set.\n *\n * Return value: The population of @set\n *\n * Since: 0.9.7\n **/\nunsigned int\nhb_set_get_population (const hb_set_t *set)\n{\n  return set->get_population ();\n}\n\n/**\n * hb_set_get_min:\n * @set: A set\n *\n * Finds the smallest element in the set.\n *\n * Return value: minimum of @set, or #HB_SET_VALUE_INVALID if @set is empty.\n *\n * Since: 0.9.7\n **/\nhb_codepoint_t\nhb_set_get_min (const hb_set_t *set)\n{\n  return set->get_min ();\n}\n\n/**\n * hb_set_get_max:\n * @set: A set\n *\n * Finds the largest element in the set.\n *\n * Return value: maximum of @set, or #HB_SET_VALUE_INVALID if @set is empty.\n *\n * Since: 0.9.7\n **/\nhb_codepoint_t\nhb_set_get_max (const hb_set_t *set)\n{\n  return set->get_max ();\n}\n\n/**\n * hb_set_next:\n * @set: A set\n * @codepoint: (inout): Input = Code point to query\n *             Output = Code point retrieved\n *\n * Fetches the next element in @set that is greater than current value of @codepoint.\n *\n * Set @codepoint to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a next value, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_next (const hb_set_t *set,\n\t     hb_codepoint_t *codepoint)\n{\n  return set->next (codepoint);\n}\n\n/**\n * hb_set_previous:\n * @set: A set\n * @codepoint: (inout): Input = Code point to query\n *             Output = Code point retrieved\n *\n * Fetches the previous element in @set that is lower than current value of @codepoint.\n *\n * Set @codepoint to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a previous value, %false otherwise\n *\n * Since: 1.8.0\n **/\nhb_bool_t\nhb_set_previous (const hb_set_t *set,\n\t\t hb_codepoint_t *codepoint)\n{\n  return set->previous (codepoint);\n}\n\n/**\n * hb_set_next_range:\n * @set: A set\n * @first: (out): The first code point in the range\n * @last: (inout): Input = The current last code point in the range\n *         Output = The last code point in the range\n *\n * Fetches the next consecutive range of elements in @set that\n * are greater than current value of @last.\n *\n * Set @last to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a next range, %false otherwise\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_next_range (const hb_set_t *set,\n\t\t   hb_codepoint_t *first,\n\t\t   hb_codepoint_t *last)\n{\n  return set->next_range (first, last);\n}\n\n/**\n * hb_set_previous_range:\n * @set: A set\n * @first: (inout): Input = The current first code point in the range\n *         Output = The first code point in the range\n * @last: (out): The last code point in the range\n *\n * Fetches the previous consecutive range of elements in @set that\n * are greater than current value of @last.\n *\n * Set @first to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a previous range, %false otherwise\n *\n * Since: 1.8.0\n **/\nhb_bool_t\nhb_set_previous_range (const hb_set_t *set,\n\t\t       hb_codepoint_t *first,\n\t\t       hb_codepoint_t *last)\n{\n  return set->previous_range (first, last);\n}\n"], "fixing_code": ["/*\n * Copyright \u00a9 2012,2017  Google, Inc.\n * Copyright \u00a9 2021 Behdad Esfahbod\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_BIT_SET_INVERTIBLE_HH\n#define HB_BIT_SET_INVERTIBLE_HH\n\n#include \"hb.hh\"\n#include \"hb-bit-set.hh\"\n\n\nstruct hb_bit_set_invertible_t\n{\n  hb_bit_set_t s;\n  bool inverted;\n\n  hb_bit_set_invertible_t () { init (); }\n  ~hb_bit_set_invertible_t () { fini (); }\n\n  void init () { s.init (); inverted = false; }\n  void fini () { s.fini (); }\n  void err () { s.err (); }\n  bool in_error () const { return s.in_error (); }\n  explicit operator bool () const { return !is_empty (); }\n\n  void reset ()\n  {\n    s.reset ();\n    inverted = false;\n  }\n  void clear ()\n  {\n    s.clear ();\n    if (likely (s.successful))\n      inverted = false;\n  }\n  void invert ()\n  {\n    if (likely (s.successful))\n      inverted = !inverted;\n  }\n\n  bool is_empty () const\n  {\n    hb_codepoint_t v = INVALID;\n    next (&v);\n    return v == INVALID;\n  }\n  hb_codepoint_t get_min () const\n  {\n    hb_codepoint_t v = INVALID;\n    next (&v);\n    return v;\n  }\n  hb_codepoint_t get_max () const\n  {\n    hb_codepoint_t v = INVALID;\n    previous (&v);\n    return v;\n  }\n  unsigned int get_population () const\n  { return inverted ? INVALID - s.get_population () : s.get_population (); }\n\n\n  void add (hb_codepoint_t g) { unlikely (inverted) ? s.del (g) : s.add (g); }\n  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n  { return unlikely (inverted) ? (s.del_range (a, b), true) : s.add_range (a, b); }\n\n  template <typename T>\n  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n  { inverted ? s.del_array (array, count, stride) : s.add_array (array, count, stride); }\n  template <typename T>\n  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n\n  /* Might return false if array looks unsorted.\n   * Used for faster rejection of corrupt data. */\n  template <typename T>\n  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n  { return inverted ? s.del_sorted_array (array, count, stride) : s.add_sorted_array (array, count, stride); }\n  template <typename T>\n  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n\n  void del (hb_codepoint_t g) { unlikely (inverted) ? s.add (g) : s.del (g); }\n  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n  { unlikely (inverted) ? (void) s.add_range (a, b) : s.del_range (a, b); }\n\n  bool get (hb_codepoint_t g) const { return s.get (g) ^ inverted; }\n\n  /* Has interface. */\n  static constexpr bool SENTINEL = false;\n  typedef bool value_t;\n  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n  /* Predicate. */\n  bool operator () (hb_codepoint_t k) const { return has (k); }\n\n  /* Sink interface. */\n  hb_bit_set_invertible_t& operator << (hb_codepoint_t v)\n  { add (v); return *this; }\n  hb_bit_set_invertible_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n  { add_range (range.first, range.second); return *this; }\n\n  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const\n  {\n    hb_codepoint_t c = first - 1;\n    return next (&c) && c <= last;\n  }\n\n  void set (const hb_bit_set_invertible_t &other)\n  {\n    s.set (other.s);\n    if (likely (s.successful))\n      inverted = other.inverted;\n  }\n\n  bool is_equal (const hb_bit_set_invertible_t &other) const\n  {\n    if (likely (inverted == other.inverted))\n      return s.is_equal (other.s);\n    else\n    {\n      /* TODO Add iter_ranges() and use here. */\n      auto it1 = iter ();\n      auto it2 = other.iter ();\n      return hb_all (+ hb_zip (it1, it2)\n\t\t     | hb_map ([](hb_pair_t<hb_codepoint_t, hb_codepoint_t> _) { return _.first == _.second; }));\n    }\n  }\n\n  bool is_subset (const hb_bit_set_invertible_t &larger_set) const\n  {\n    if (unlikely (inverted != larger_set.inverted))\n      return hb_all (hb_iter (s) | hb_map (larger_set.s));\n    else\n      return unlikely (inverted) ? larger_set.s.is_subset (s) : s.is_subset (larger_set.s);\n  }\n\n  protected:\n  template <typename Op>\n  void process (const Op& op, const hb_bit_set_invertible_t &other)\n  { s.process (op, other.s); }\n  public:\n  void union_ (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_and, other);\n      else\n\tprocess (hb_bitwise_or, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_gt, other);\n      else\n\tprocess (hb_bitwise_lt, other);\n    }\n    if (likely (s.successful))\n      inverted = inverted || other.inverted;\n  }\n  void intersect (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other);\n    }\n    if (likely (s.successful))\n      inverted = inverted && other.inverted;\n  }\n  void subtract (const hb_bit_set_invertible_t &other)\n  {\n    if (likely (inverted == other.inverted))\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_lt, other);\n      else\n\tprocess (hb_bitwise_gt, other); /* Main branch. */\n    }\n    else\n    {\n      if (unlikely (inverted))\n\tprocess (hb_bitwise_or, other);\n      else\n\tprocess (hb_bitwise_and, other);\n    }\n    if (likely (s.successful))\n      inverted = inverted && !other.inverted;\n  }\n  void symmetric_difference (const hb_bit_set_invertible_t &other)\n  {\n    process (hb_bitwise_xor, other);\n    if (likely (s.successful))\n      inverted = inverted ^ other.inverted;\n  }\n\n  bool next (hb_codepoint_t *codepoint) const\n  {\n    if (likely (!inverted))\n      return s.next (codepoint);\n\n    auto old = *codepoint;\n    if (unlikely (old + 1 == INVALID))\n    {\n      *codepoint = INVALID;\n      return false;\n    }\n\n    auto v = old;\n    s.next (&v);\n    if (old + 1 < v)\n    {\n      *codepoint = old + 1;\n      return true;\n    }\n\n    v = old;\n    s.next_range (&old, &v);\n\n    *codepoint = v + 1;\n    return *codepoint != INVALID;\n  }\n  bool previous (hb_codepoint_t *codepoint) const\n  {\n    if (likely (!inverted))\n      return s.previous (codepoint);\n\n    auto old = *codepoint;\n    if (unlikely (old - 1 == INVALID))\n    {\n      *codepoint = INVALID;\n      return false;\n    }\n\n    auto v = old;\n    s.previous (&v);\n\n    if (old - 1 > v || v == INVALID)\n    {\n      *codepoint = old - 1;\n      return true;\n    }\n\n    v = old;\n    s.previous_range (&v, &old);\n\n    *codepoint = v - 1;\n    return *codepoint != INVALID;\n  }\n  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n  {\n    if (likely (!inverted))\n      return s.next_range (first, last);\n\n    if (!next (last))\n    {\n      *last = *first = INVALID;\n      return false;\n    }\n\n    *first = *last;\n    s.next (last);\n    --*last;\n    return true;\n  }\n  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n  {\n    if (likely (!inverted))\n      return s.previous_range (first, last);\n\n    if (!previous (first))\n    {\n      *last = *first = INVALID;\n      return false;\n    }\n\n    *last = *first;\n    s.previous (first);\n    ++*first;\n    return true;\n  }\n\n  static constexpr hb_codepoint_t INVALID = hb_bit_set_t::INVALID;\n\n  /*\n   * Iterator implementation.\n   */\n  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n  {\n    static constexpr bool is_sorted_iterator = true;\n    iter_t (const hb_bit_set_invertible_t &s_ = Null (hb_bit_set_invertible_t),\n\t    bool init = true) : s (&s_), v (INVALID), l(0)\n    {\n      if (init)\n      {\n\tl = s->get_population () + 1;\n\t__next__ ();\n      }\n    }\n\n    typedef hb_codepoint_t __item_t__;\n    hb_codepoint_t __item__ () const { return v; }\n    bool __more__ () const { return v != INVALID; }\n    void __next__ () { s->next (&v); if (l) l--; }\n    void __prev__ () { s->previous (&v); }\n    unsigned __len__ () const { return l; }\n    iter_t end () const { return iter_t (*s, false); }\n    bool operator != (const iter_t& o) const\n    { return s != o.s || v != o.v; }\n\n    protected:\n    const hb_bit_set_invertible_t *s;\n    hb_codepoint_t v;\n    unsigned l;\n  };\n  iter_t iter () const { return iter_t (*this); }\n  operator iter_t () const { return iter (); }\n};\n\n\n#endif /* HB_BIT_SET_INVERTIBLE_HH */\n", "/*\n * Copyright \u00a9 2018  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#include \"hb-map.hh\"\n\n\n/**\n * SECTION:hb-map\n * @title: hb-map\n * @short_description: Object representing integer to integer mapping\n * @include: hb.h\n *\n * Map objects are integer-to-integer hash-maps.  Currently they are\n * not used in the HarfBuzz public API, but are provided for client's\n * use if desired.\n **/\n\n\n/**\n * hb_map_create: (Xconstructor)\n *\n * Creates a new, initially empty map.\n *\n * Return value: (transfer full): The new #hb_map_t\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_create ()\n{\n  hb_map_t *map;\n\n  if (!(map = hb_object_create<hb_map_t> ()))\n    return hb_map_get_empty ();\n\n  map->init_shallow ();\n\n  return map;\n}\n\n/**\n * hb_map_get_empty:\n *\n * Fetches the singleton empty #hb_map_t.\n *\n * Return value: (transfer full): The empty #hb_map_t\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_get_empty ()\n{\n  return const_cast<hb_map_t *> (&Null (hb_map_t));\n}\n\n/**\n * hb_map_reference: (skip)\n * @map: A map\n *\n * Increases the reference count on a map.\n *\n * Return value: (transfer full): The map\n *\n * Since: 1.7.7\n **/\nhb_map_t *\nhb_map_reference (hb_map_t *map)\n{\n  return hb_object_reference (map);\n}\n\n/**\n * hb_map_destroy: (skip)\n * @map: A map\n *\n * Decreases the reference count on a map. When\n * the reference count reaches zero, the map is\n * destroyed, freeing all memory.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_destroy (hb_map_t *map)\n{\n  if (!hb_object_destroy (map)) return;\n\n  map->fini_shallow ();\n\n  hb_free (map);\n}\n\n/**\n * hb_map_set_user_data: (skip)\n * @map: A map\n * @key: The user-data key to set\n * @data: A pointer to the user data to set\n * @destroy: (nullable): A callback to call when @data is not needed anymore\n * @replace: Whether to replace an existing data with the same key\n *\n * Attaches a user-data key/data pair to the specified map.\n *\n * Return value: %true if success, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_set_user_data (hb_map_t           *map,\n\t\t      hb_user_data_key_t *key,\n\t\t      void *              data,\n\t\t      hb_destroy_func_t   destroy,\n\t\t      hb_bool_t           replace)\n{\n  return hb_object_set_user_data (map, key, data, destroy, replace);\n}\n\n/**\n * hb_map_get_user_data: (skip)\n * @map: A map\n * @key: The user-data key to query\n *\n * Fetches the user data associated with the specified key,\n * attached to the specified map.\n *\n * Return value: (transfer none): A pointer to the user data\n *\n * Since: 1.7.7\n **/\nvoid *\nhb_map_get_user_data (hb_map_t           *map,\n\t\t      hb_user_data_key_t *key)\n{\n  return hb_object_get_user_data (map, key);\n}\n\n\n/**\n * hb_map_allocation_successful:\n * @map: A map\n *\n * Tests whether memory allocation for a set was successful.\n *\n * Return value: %true if allocation succeeded, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_allocation_successful (const hb_map_t  *map)\n{\n  return map->successful;\n}\n\n\n/**\n * hb_map_set:\n * @map: A map\n * @key: The key to store in the map\n * @value: The value to store for @key\n *\n * Stores @key:@value in the map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_set (hb_map_t       *map,\n\t    hb_codepoint_t  key,\n\t    hb_codepoint_t  value)\n{\n  /* Immutable-safe. */\n  map->set (key, value);\n}\n\n/**\n * hb_map_get:\n * @map: A map\n * @key: The key to query\n *\n * Fetches the value stored for @key in @map.\n *\n * Since: 1.7.7\n **/\nhb_codepoint_t\nhb_map_get (const hb_map_t *map,\n\t    hb_codepoint_t  key)\n{\n  return map->get (key);\n}\n\n/**\n * hb_map_del:\n * @map: A map\n * @key: The key to delete\n *\n * Removes @key and its stored value from @map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_del (hb_map_t       *map,\n\t    hb_codepoint_t  key)\n{\n  /* Immutable-safe. */\n  map->del (key);\n}\n\n/**\n * hb_map_has:\n * @map: A map\n * @key: The key to query\n *\n * Tests whether @key is an element of @map.\n *\n * Return value: %true if @key is found in @map, %false otherwise\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_has (const hb_map_t *map,\n\t    hb_codepoint_t  key)\n{\n  return map->has (key);\n}\n\n\n/**\n * hb_map_clear:\n * @map: A map\n *\n * Clears out the contents of @map.\n *\n * Since: 1.7.7\n **/\nvoid\nhb_map_clear (hb_map_t *map)\n{\n  return map->clear ();\n}\n\n/**\n * hb_map_is_empty:\n * @map: A map\n *\n * Tests whether @map is empty (contains no elements).\n *\n * Return value: %true if @map is empty\n *\n * Since: 1.7.7\n **/\nhb_bool_t\nhb_map_is_empty (const hb_map_t *map)\n{\n  return map->is_empty ();\n}\n\n/**\n * hb_map_get_population:\n * @map: A map\n *\n * Returns the number of key-value pairs in the map.\n *\n * Return value: The population of @map\n *\n * Since: 1.7.7\n **/\nunsigned int\nhb_map_get_population (const hb_map_t *map)\n{\n  return map->get_population ();\n}\n", "/*\n * Copyright \u00a9 2018  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#ifndef HB_MAP_HH\n#define HB_MAP_HH\n\n#include \"hb.hh\"\n\n\n/*\n * hb_hashmap_t\n */\n\ntemplate <typename K, typename V,\n\t  K kINVALID = hb_is_pointer (K) ? 0 : hb_is_signed (K) ? hb_int_min (K) : (K) -1,\n\t  V vINVALID = hb_is_pointer (V) ? 0 : hb_is_signed (V) ? hb_int_min (V) : (V) -1>\nstruct hb_hashmap_t\n{\n  HB_DELETE_COPY_ASSIGN (hb_hashmap_t);\n  hb_hashmap_t ()  { init (); }\n  ~hb_hashmap_t () { fini (); }\n\n  static_assert (hb_is_integral (K) || hb_is_pointer (K), \"\");\n  static_assert (hb_is_integral (V) || hb_is_pointer (V), \"\");\n\n  struct item_t\n  {\n    K key;\n    V value;\n    uint32_t hash;\n\n    void clear () { key = kINVALID; value = vINVALID; hash = 0; }\n\n    bool operator == (const K &o) { return hb_deref (key) == hb_deref (o); }\n    bool operator == (const item_t &o) { return *this == o.key; }\n    bool is_unused () const    { return key == kINVALID; }\n    bool is_tombstone () const { return key != kINVALID && value == vINVALID; }\n    bool is_real () const { return key != kINVALID && value != vINVALID; }\n    hb_pair_t<K, V> get_pair() const { return hb_pair_t<K, V> (key, value); }\n  };\n\n  hb_object_header_t header;\n  bool successful; /* Allocations successful */\n  unsigned int population; /* Not including tombstones. */\n  unsigned int occupancy; /* Including tombstones. */\n  unsigned int mask;\n  unsigned int prime;\n  item_t *items;\n\n  void init_shallow ()\n  {\n    successful = true;\n    population = occupancy = 0;\n    mask = 0;\n    prime = 0;\n    items = nullptr;\n  }\n  void init ()\n  {\n    hb_object_init (this);\n    init_shallow ();\n  }\n  void fini_shallow ()\n  {\n    hb_free (items);\n    items = nullptr;\n    population = occupancy = 0;\n  }\n  void fini ()\n  {\n    hb_object_fini (this);\n    fini_shallow ();\n  }\n\n  void reset ()\n  {\n    successful = true;\n    clear ();\n  }\n\n  bool in_error () const { return !successful; }\n\n  bool resize ()\n  {\n    if (unlikely (!successful)) return false;\n\n    unsigned int power = hb_bit_storage (population * 2 + 8);\n    unsigned int new_size = 1u << power;\n    item_t *new_items = (item_t *) hb_malloc ((size_t) new_size * sizeof (item_t));\n    if (unlikely (!new_items))\n    {\n      successful = false;\n      return false;\n    }\n    for (auto &_ : hb_iter (new_items, new_size))\n      _.clear ();\n\n    unsigned int old_size = mask + 1;\n    item_t *old_items = items;\n\n    /* Switch to new, empty, array. */\n    population = occupancy = 0;\n    mask = new_size - 1;\n    prime = prime_for (power);\n    items = new_items;\n\n    /* Insert back old items. */\n    if (old_items)\n      for (unsigned int i = 0; i < old_size; i++)\n\tif (old_items[i].is_real ())\n\t  set_with_hash (old_items[i].key,\n\t\t\t old_items[i].hash,\n\t\t\t old_items[i].value);\n\n    hb_free (old_items);\n\n    return true;\n  }\n\n  bool set (K key, V value)\n  {\n    return set_with_hash (key, hb_hash (key), value);\n  }\n\n  V get (K key) const\n  {\n    if (unlikely (!items)) return vINVALID;\n    unsigned int i = bucket_for (key);\n    return items[i].is_real () && items[i] == key ? items[i].value : vINVALID;\n  }\n\n  void del (K key) { set (key, vINVALID); }\n\n  /* Has interface. */\n  static constexpr V SENTINEL = vINVALID;\n  typedef V value_t;\n  value_t operator [] (K k) const { return get (k); }\n  bool has (K k, V *vp = nullptr) const\n  {\n    V v = (*this)[k];\n    if (vp) *vp = v;\n    return v != SENTINEL;\n  }\n  /* Projection. */\n  V operator () (K k) const { return get (k); }\n\n  void clear ()\n  {\n    if (unlikely (!successful)) return;\n\n    if (items)\n      for (auto &_ : hb_iter (items, mask + 1))\n\t_.clear ();\n\n    population = occupancy = 0;\n  }\n\n  bool is_empty () const { return population == 0; }\n  explicit operator bool () const { return !is_empty (); }\n\n  unsigned int get_population () const { return population; }\n\n  /*\n   * Iterator\n   */\n  auto iter () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::get_pair)\n  )\n  auto keys () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::key)\n    | hb_map (hb_ridentity)\n  )\n  auto values () const HB_AUTO_RETURN\n  (\n    + hb_array (items, mask ? mask + 1 : 0)\n    | hb_filter (&item_t::is_real)\n    | hb_map (&item_t::value)\n    | hb_map (hb_ridentity)\n  )\n\n  /* Sink interface. */\n  hb_hashmap_t& operator << (const hb_pair_t<K, V>& v)\n  { set (v.first, v.second); return *this; }\n\n  protected:\n\n  bool set_with_hash (K key, uint32_t hash, V value)\n  {\n    if (unlikely (!successful)) return false;\n    if (unlikely (key == kINVALID)) return true;\n    if (unlikely ((occupancy + occupancy / 2) >= mask && !resize ())) return false;\n    unsigned int i = bucket_for_hash (key, hash);\n\n    if (value == vINVALID && items[i].key != key)\n      return true; /* Trying to delete non-existent key. */\n\n    if (!items[i].is_unused ())\n    {\n      occupancy--;\n      if (!items[i].is_tombstone ())\n\tpopulation--;\n    }\n\n    items[i].key = key;\n    items[i].value = value;\n    items[i].hash = hash;\n\n    occupancy++;\n    if (!items[i].is_tombstone ())\n      population++;\n\n    return true;\n  }\n\n  unsigned int bucket_for (K key) const\n  {\n    return bucket_for_hash (key, hb_hash (key));\n  }\n\n  unsigned int bucket_for_hash (K key, uint32_t hash) const\n  {\n    unsigned int i = hash % prime;\n    unsigned int step = 0;\n    unsigned int tombstone = (unsigned) -1;\n    while (!items[i].is_unused ())\n    {\n      if (items[i].hash == hash && items[i] == key)\n\treturn i;\n      if (tombstone == (unsigned) -1 && items[i].is_tombstone ())\n\ttombstone = i;\n      i = (i + ++step) & mask;\n    }\n    return tombstone == (unsigned) -1 ? i : tombstone;\n  }\n\n  static unsigned int prime_for (unsigned int shift)\n  {\n    /* Following comment and table copied from glib. */\n    /* Each table size has an associated prime modulo (the first prime\n     * lower than the table size) used to find the initial bucket. Probing\n     * then works modulo 2^n. The prime modulo is necessary to get a\n     * good distribution with poor hash functions.\n     */\n    /* Not declaring static to make all kinds of compilers happy... */\n    /*static*/ const unsigned int prime_mod [32] =\n    {\n      1,          /* For 1 << 0 */\n      2,\n      3,\n      7,\n      13,\n      31,\n      61,\n      127,\n      251,\n      509,\n      1021,\n      2039,\n      4093,\n      8191,\n      16381,\n      32749,\n      65521,      /* For 1 << 16 */\n      131071,\n      262139,\n      524287,\n      1048573,\n      2097143,\n      4194301,\n      8388593,\n      16777213,\n      33554393,\n      67108859,\n      134217689,\n      268435399,\n      536870909,\n      1073741789,\n      2147483647  /* For 1 << 31 */\n    };\n\n    if (unlikely (shift >= ARRAY_LENGTH (prime_mod)))\n      return prime_mod[ARRAY_LENGTH (prime_mod) - 1];\n\n    return prime_mod[shift];\n  }\n};\n\n/*\n * hb_map_t\n */\n\nstruct hb_map_t : hb_hashmap_t<hb_codepoint_t,\n\t\t\t       hb_codepoint_t,\n\t\t\t       HB_MAP_VALUE_INVALID,\n\t\t\t       HB_MAP_VALUE_INVALID> {};\n\n\n#endif /* HB_MAP_HH */\n", "/*\n * Copyright \u00a9 2012  Google, Inc.\n *\n *  This is part of HarfBuzz, a text shaping library.\n *\n * Permission is hereby granted, without written agreement and without\n * license or royalty fees, to use, copy, modify, and distribute this\n * software and its documentation for any purpose, provided that the\n * above copyright notice and the following two paragraphs appear in\n * all copies of this software.\n *\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n *\n * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * Google Author(s): Behdad Esfahbod\n */\n\n#include \"hb-set.hh\"\n\n\n/**\n * SECTION:hb-set\n * @title: hb-set\n * @short_description: Objects representing a set of integers\n * @include: hb.h\n *\n * Set objects represent a mathematical set of integer values.  They are\n * used in non-shaping APIs to query certain sets of characters or glyphs,\n * or other integer values.\n **/\n\n\n/**\n * hb_set_create: (Xconstructor)\n *\n * Creates a new, initially empty set.\n *\n * Return value: (transfer full): The new #hb_set_t\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_create ()\n{\n  hb_set_t *set;\n\n  if (!(set = hb_object_create<hb_set_t> ()))\n    return hb_set_get_empty ();\n\n  set->init_shallow ();\n\n  return set;\n}\n\n/**\n * hb_set_get_empty:\n *\n * Fetches the singleton empty #hb_set_t.\n *\n * Return value: (transfer full): The empty #hb_set_t\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_get_empty ()\n{\n  return const_cast<hb_set_t *> (&Null (hb_set_t));\n}\n\n/**\n * hb_set_reference: (skip)\n * @set: A set\n *\n * Increases the reference count on a set.\n *\n * Return value: (transfer full): The set\n *\n * Since: 0.9.2\n **/\nhb_set_t *\nhb_set_reference (hb_set_t *set)\n{\n  return hb_object_reference (set);\n}\n\n/**\n * hb_set_destroy: (skip)\n * @set: A set\n *\n * Decreases the reference count on a set. When\n * the reference count reaches zero, the set is\n * destroyed, freeing all memory.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_destroy (hb_set_t *set)\n{\n  if (!hb_object_destroy (set)) return;\n\n  set->fini_shallow ();\n\n  hb_free (set);\n}\n\n/**\n * hb_set_set_user_data: (skip)\n * @set: A set\n * @key: The user-data key to set\n * @data: A pointer to the user data to set\n * @destroy: (nullable): A callback to call when @data is not needed anymore\n * @replace: Whether to replace an existing data with the same key\n *\n * Attaches a user-data key/data pair to the specified set.\n *\n * Return value: %true if success, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_set_user_data (hb_set_t           *set,\n\t\t      hb_user_data_key_t *key,\n\t\t      void *              data,\n\t\t      hb_destroy_func_t   destroy,\n\t\t      hb_bool_t           replace)\n{\n  return hb_object_set_user_data (set, key, data, destroy, replace);\n}\n\n/**\n * hb_set_get_user_data: (skip)\n * @set: A set\n * @key: The user-data key to query\n *\n * Fetches the user data associated with the specified key,\n * attached to the specified set.\n *\n * Return value: (transfer none): A pointer to the user data\n *\n * Since: 0.9.2\n **/\nvoid *\nhb_set_get_user_data (hb_set_t           *set,\n\t\t      hb_user_data_key_t *key)\n{\n  return hb_object_get_user_data (set, key);\n}\n\n\n/**\n * hb_set_allocation_successful:\n * @set: A set\n *\n * Tests whether memory allocation for a set was successful.\n *\n * Return value: %true if allocation succeeded, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_allocation_successful (const hb_set_t  *set)\n{\n  return !set->in_error ();\n}\n\n/**\n * hb_set_copy:\n * @set: A set\n *\n * Allocate a copy of @set.\n *\n * Return value: Newly-allocated set.\n *\n * Since: 2.8.2\n **/\nhb_set_t *\nhb_set_copy (const hb_set_t *set)\n{\n  hb_set_t *copy = hb_set_create ();\n  copy->set (*set);\n  return copy;\n}\n\n/**\n * hb_set_clear:\n * @set: A set\n *\n * Clears out the contents of a set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_clear (hb_set_t *set)\n{\n  /* Immutible-safe. */\n  set->clear ();\n}\n\n/**\n * hb_set_is_empty:\n * @set: a set.\n *\n * Tests whether a set is empty (contains no elements).\n *\n * Return value: %true if @set is empty\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_is_empty (const hb_set_t *set)\n{\n  return set->is_empty ();\n}\n\n/**\n * hb_set_has:\n * @set: A set\n * @codepoint: The element to query\n *\n * Tests whether @codepoint belongs to @set.\n *\n * Return value: %true if @codepoint is in @set, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_has (const hb_set_t *set,\n\t    hb_codepoint_t  codepoint)\n{\n  return set->has (codepoint);\n}\n\n/**\n * hb_set_add:\n * @set: A set\n * @codepoint: The element to add to @set\n *\n * Adds @codepoint to @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_add (hb_set_t       *set,\n\t    hb_codepoint_t  codepoint)\n{\n  /* Immutible-safe. */\n  set->add (codepoint);\n}\n\n/**\n * hb_set_add_range:\n * @set: A set\n * @first: The first element to add to @set\n * @last: The final element to add to @set\n *\n * Adds all of the elements from @first to @last\n * (inclusive) to @set.\n *\n * Since: 0.9.7\n **/\nvoid\nhb_set_add_range (hb_set_t       *set,\n\t\t  hb_codepoint_t  first,\n\t\t  hb_codepoint_t  last)\n{\n  /* Immutible-safe. */\n  set->add_range (first, last);\n}\n\n/**\n * hb_set_del:\n * @set: A set\n * @codepoint: Removes @codepoint from @set\n *\n * Removes @codepoint from @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_del (hb_set_t       *set,\n\t    hb_codepoint_t  codepoint)\n{\n  /* Immutible-safe. */\n  set->del (codepoint);\n}\n\n/**\n * hb_set_del_range:\n * @set: A set\n * @first: The first element to remove from @set\n * @last: The final element to remove from @set\n *\n * Removes all of the elements from @first to @last\n * (inclusive) from @set.\n *\n * If @last is #HB_SET_VALUE_INVALID, then all values\n * greater than or equal to @first are removed.\n *\n * Since: 0.9.7\n **/\nvoid\nhb_set_del_range (hb_set_t       *set,\n\t\t  hb_codepoint_t  first,\n\t\t  hb_codepoint_t  last)\n{\n  /* Immutible-safe. */\n  set->del_range (first, last);\n}\n\n/**\n * hb_set_is_equal:\n * @set: A set\n * @other: Another set\n *\n * Tests whether @set and @other are equal (contain the same\n * elements).\n *\n * Return value: %true if the two sets are equal, %false otherwise.\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_is_equal (const hb_set_t *set,\n\t\t const hb_set_t *other)\n{\n  return set->is_equal (*other);\n}\n\n/**\n * hb_set_is_subset:\n * @set: A set\n * @larger_set: Another set\n *\n * Tests whether @set is a subset of @larger_set.\n *\n * Return value: %true if the @set is a subset of (or equal to) @larger_set, %false otherwise.\n *\n * Since: 1.8.1\n **/\nhb_bool_t\nhb_set_is_subset (const hb_set_t *set,\n\t\t  const hb_set_t *larger_set)\n{\n  return set->is_subset (*larger_set);\n}\n\n/**\n * hb_set_set:\n * @set: A set\n * @other: Another set\n *\n * Makes the contents of @set equal to the contents of @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  /* Immutible-safe. */\n  set->set (*other);\n}\n\n/**\n * hb_set_union:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the union of @set and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  /* Immutible-safe. */\n  set->union_ (*other);\n}\n\n/**\n * hb_set_intersect:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the intersection of @set and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  /* Immutible-safe. */\n  set->intersect (*other);\n}\n\n/**\n * hb_set_subtract:\n * @set: A set\n * @other: Another set\n *\n * Subtracts the contents of @other from @set.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  /* Immutible-safe. */\n  set->subtract (*other);\n}\n\n/**\n * hb_set_symmetric_difference:\n * @set: A set\n * @other: Another set\n *\n * Makes @set the symmetric difference of @set\n * and @other.\n *\n * Since: 0.9.2\n **/\nvoid\nhb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  /* Immutible-safe. */\n  set->symmetric_difference (*other);\n}\n\n/**\n * hb_set_invert:\n * @set: A set\n *\n * Inverts the contents of @set.\n *\n * Since: 3.0.0\n **/\nvoid\nhb_set_invert (hb_set_t *set)\n{\n  /* Immutible-safe. */\n  set->invert ();\n}\n\n/**\n * hb_set_get_population:\n * @set: A set\n *\n * Returns the number of elements in the set.\n *\n * Return value: The population of @set\n *\n * Since: 0.9.7\n **/\nunsigned int\nhb_set_get_population (const hb_set_t *set)\n{\n  return set->get_population ();\n}\n\n/**\n * hb_set_get_min:\n * @set: A set\n *\n * Finds the smallest element in the set.\n *\n * Return value: minimum of @set, or #HB_SET_VALUE_INVALID if @set is empty.\n *\n * Since: 0.9.7\n **/\nhb_codepoint_t\nhb_set_get_min (const hb_set_t *set)\n{\n  return set->get_min ();\n}\n\n/**\n * hb_set_get_max:\n * @set: A set\n *\n * Finds the largest element in the set.\n *\n * Return value: maximum of @set, or #HB_SET_VALUE_INVALID if @set is empty.\n *\n * Since: 0.9.7\n **/\nhb_codepoint_t\nhb_set_get_max (const hb_set_t *set)\n{\n  return set->get_max ();\n}\n\n/**\n * hb_set_next:\n * @set: A set\n * @codepoint: (inout): Input = Code point to query\n *             Output = Code point retrieved\n *\n * Fetches the next element in @set that is greater than current value of @codepoint.\n *\n * Set @codepoint to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a next value, %false otherwise\n *\n * Since: 0.9.2\n **/\nhb_bool_t\nhb_set_next (const hb_set_t *set,\n\t     hb_codepoint_t *codepoint)\n{\n  return set->next (codepoint);\n}\n\n/**\n * hb_set_previous:\n * @set: A set\n * @codepoint: (inout): Input = Code point to query\n *             Output = Code point retrieved\n *\n * Fetches the previous element in @set that is lower than current value of @codepoint.\n *\n * Set @codepoint to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a previous value, %false otherwise\n *\n * Since: 1.8.0\n **/\nhb_bool_t\nhb_set_previous (const hb_set_t *set,\n\t\t hb_codepoint_t *codepoint)\n{\n  return set->previous (codepoint);\n}\n\n/**\n * hb_set_next_range:\n * @set: A set\n * @first: (out): The first code point in the range\n * @last: (inout): Input = The current last code point in the range\n *         Output = The last code point in the range\n *\n * Fetches the next consecutive range of elements in @set that\n * are greater than current value of @last.\n *\n * Set @last to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a next range, %false otherwise\n *\n * Since: 0.9.7\n **/\nhb_bool_t\nhb_set_next_range (const hb_set_t *set,\n\t\t   hb_codepoint_t *first,\n\t\t   hb_codepoint_t *last)\n{\n  return set->next_range (first, last);\n}\n\n/**\n * hb_set_previous_range:\n * @set: A set\n * @first: (inout): Input = The current first code point in the range\n *         Output = The first code point in the range\n * @last: (out): The last code point in the range\n *\n * Fetches the previous consecutive range of elements in @set that\n * are greater than current value of @last.\n *\n * Set @first to #HB_SET_VALUE_INVALID to get started.\n *\n * Return value: %true if there was a previous range, %false otherwise\n *\n * Since: 1.8.0\n **/\nhb_bool_t\nhb_set_previous_range (const hb_set_t *set,\n\t\t       hb_codepoint_t *first,\n\t\t       hb_codepoint_t *last)\n{\n  return set->previous_range (first, last);\n}\n"], "filenames": ["src/hb-bit-set-invertible.hh", "src/hb-map.cc", "src/hb-map.hh", "src/hb-set.cc"], "buggy_code_start_loc": [49, 258, 171, 204], "buggy_code_end_loc": [206, 261, 171, 468], "fixing_code_start_loc": [49, 257, 172, 204], "fixing_code_end_loc": [228, 257, 174, 454], "type": "CWE-787", "message": "HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).", "other": {"cve": {"id": "CVE-2021-45931", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-01T01:15:08.477", "lastModified": "2022-10-28T12:54:22.913", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy)."}, {"lang": "es", "value": "HarfBuzz versi\u00f3n 2.9.0, presenta una escritura fuera de l\u00edmites en la funci\u00f3n hb_bit_set_invertible_t::set (llamada desde hb_sparseset_t(hb_bit_set_invertible_t)::set y hb_set_copy).\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:harfbuzz_project:harfbuzz:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "9D420F22-2C65-42CA-BE6A-B1EA85FAD2B9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=37425", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/harfbuzz/OSV-2021-1159.yaml", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4EAIZKL4O67FN2CWJYHYKZEMNYWNWO3D/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5A7TCR2MY46YK3NHQZB3SLESUH354IEA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DI6247WOAKB46CZZ6SCDSJVWWCW3GMZH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-11", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/harfbuzz/harfbuzz/commit/d3e09bf4654fe5478b6dbf2b26ebab6271317d81"}}